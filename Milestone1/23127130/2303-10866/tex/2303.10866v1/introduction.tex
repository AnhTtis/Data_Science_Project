The paper by Held and Karp \cite{10.1145/800029.808532} in the early sixties, sparked an interest in designing (fast) exact exponential algorithms. In the last couple of decades there has been immense progress in this field, resulting in non-trivial exact exponential algorithms \cite{10.1145/800029.808532, 10.1007/11602613_58, Razgon2007ComputingMD, lima2018and, 10.1007/978-3-030-64843-5_21, 10.1145/2897518.2897551, bjrklund:LIPIcs:2017:6948}. Alongside optimisation problems, it is also of interest to find exact exponential algorithms for enumeration problems. These are useful in answering natural questions that arise in Graph Theory, about the number of minimal (maximal) vertex subsets that satisfy a given property in a graph of order $n$. One can prove a trivial bound of $\mathcal{O}(2^{n}/\sqrt{n})$, but better bounds are known only for relatively few problems. The celebrated result of Moon, Moser \cite{moon_moser} proving an upper bound of $\mathcal{O^{\star}}(1.4422^n)$ for maximal independent sets, alongside that of Fomin et al. for Feedback Vertex Set\cite{10.1145/800029.808532} and Dominating Set\cite{10.1007/11602613_58} are some examples. We refer to the monograph by Fomin and Kratsch \cite{fomin_exact} for a detailed survey of the techniques and results in the field. 

A \emph{knot} in a directed graph $D = (V,E)$ is a strongly connected component of size atleast 2, without any out-edge. For a given input digraph $D$, the problem of finding the smallest vertex subset $S\subseteq V$ whose deletion makes $D$ Knot-Free is known as the {\sc Knot-Free Vertex Deletion} (KFVD) Problem. It finds applications in resolution of deadlocks in a classical distributed computation model referred to as the OR-model.

A distributed system consists of independent processors which are interconnected via a network which facilitates resource sharing. It is typically represented using a wait-for digraph $D = (V,E)$, where the vertex set $V$ represents processes and edge set $E$ represents wait-conditions. A deadlock occurs when a set of processes wait indefinitely for resources from each other to take actions such as sending a message or releasing a lock. Deadlocks \cite{10.1007/s10878-018-0279-5} are a common problem in multiprocessing systems, parallel computing and distributed systems.

The AND-model and OR-model are well investigated deadlock models in literature \cite{https://doi.org/10.1002/net.21537}. In the AND-model the process corresponding to a vertex $v$ in the wait-for graph can start only after the processes corresponding to its out-neighbours are completed, while in the OR-model $v$ can begin if atleast one of its out-neighbours has finished execution. Deadlocks in the AND-model correspond to cycles and hence deadlock prevention via preempting processes becomes equivalent to the {\sc Directed Feedback Vertex Set} problem in the wait-for graph, which has received considerable attention from various algorithmic viewpoints \cite{10.1145/1374376.1374404, Razgon2007ComputingMD, 10.1145/3446969, doi:10.1137/1.9781611976465.14}. Meanwhile, the deadlock prevention in OR-models which is equivalent to KFVD, has only been explored recently \cite{DBLP:conf/iwpec/BessyBCPS19, ramanujan2022exact}.

\subsection{Our Contributions}
In this paper, we build upon the work of Ramanujan et al. \cite{ramanujan2022exact} to obtain the following results. The algorithm is designed using the technique of {\em Branching} and its complexity is computed via {\em Measure \& Conquer}

\begin{theorem}
 There exists an algorithm for {\sc Knot-Free Vertex Deletion} running in $\mathcal{O}^*(1.4549^n)$. Furthermore, there is an infinite family of graphs for which the algorithm takes $\Omega(1.4422^n)$ time.
\end{theorem}

\begin{theorem}
 The number of inclusion-wise minimal knot-free vertex deletion sets is $\mathcal{O}^*(1.4549^n)$  and there exists an infinite family of graphs with $\Omega(1.4422^n)$ many such sets.
\end{theorem}

\noindent Our algorithm uses the simple observation that, {\em a directed graph $D$ is knot-free if and only if every vertex in $D$ has a path to some sink}. Furthermore, for any given directed graph $D$ in order to find the optimal solution $S$ to the $KFVD$ problem, it suffices to find the set of sinks $Z$ in $D-S$ \cite{DBLP:conf/iwpec/BessyBCPS19}, since $Z = N^+(Z)$. Given an instance $I = (D,V_1,V_2)$, we pick a vertex $v\in V_1$ and branch on the possibility that $v$ is a sink vertex in some optimal solution. The measure of the instance is $\phi(I) = \lvert V_1\rvert + \frac{\lvert V_2 \rvert}{4}$. The elements of $V_2$ are non-sink vertices and whenever we conclude that a vertex in $V_1$ will not be a sink in the final solution, we shift it to $V_2$, giving us a potential drop. This is how we capture the drop in measure in the branch where $v$ is not a sink. In the other branch where $v$ is a sink, we prove that $N^+(v)$ must belong to the solution set. We further prove that the set of vertices that can reach $v$ after $N^+(v)$ is deleted, cannot contain solution vertices and can hence be removed. Finally, we also show that if $v$ can reach $u$ after $N^+(u)$ is deleted then $u$ cannot be a sink vertex in any optimal solution corresponding to this branch. The above observations allow us to delete vertices or move them from $V_1$ to $V_2$ which gives a potential drop. We do a "potential sensitive" branching, followed by an extensive case analysis in order to obtain the final algorithm. 

\subsection{Previous Work}

Consider the {\sc Directed Feedback Vertex Set} problem, where one has to find the smallest size vertex subset whose deletion makes the input digraph acyclic. Observe that acyclic graphs are also knot-free since they do not have strongly  connected components of size greater than $1$. Hence one way of solving KFVD is to use the solution obtained via an algorithm for DFVS, since the problem has received considerable attention in the past\cite{10.1145/1374376.1374404, 10.1145/3446969, Razgon2007ComputingMD, doi:10.1137/1.9781611976465.14}. But the size of the solution for KFVD could be considerably smaller than that of DFVS and hence it is of merit to focus on the problem directly. 

In 2019, Carnerio, Protti and Souza \cite{10.1007/s10878-018-0279-5} first investigated deadlock resolution in various models via arc or vertex deletion. It was shown that corresponding to the OR-model, the arc deletion problem is polynomial time solvable, while the vertex deletion (KFVD) remains NP-complete even for graphs of maximum degree $4$. They further showed that KFVD is solvable in $\mathcal{O}(m\sqrt{n})$ time in graphs of maximum degree $3$. The first and only non-trivial exact exponential algorithm for KFVD was presented by Ramanujan et al. \cite{ramanujan2022exact} and runs in time $\mathcal{O}^{\star}(1.576^n)$. From the aspect of Parameterised Complexity, Bessy et al. \cite{DBLP:conf/iwpec/BessyBCPS19} showed that KFVD parameterised by solution size is $W[1]$-hard but FPT parameterised by clique-width. The fine grained complexity of $KFVD$ with respect to treewidth ($2^{\mathcal{O}(tw)}$) given ETH and size of largest strongly connected component ($2^{\phi}n^{\mathcal{O}(1)}$) given SETH is also know via \cite{DBLP:conf/iwpec/BessyBCPS19, knot_finegrained}.\\

\noindent {\em Organization of the paper:} In section 2, we state and prove some theorems which are used throughout the paper. By section 3, we present the algorithm and prove its correctness in section 4. We analyse the time complexity in section 5 and provide a lower bound for the run time of the algorithm in section 6. Finally, section 7 is dedicated to proving the upper and a complimentary lower bound on the number of minimal KFVD sets in a graph of size $n$.