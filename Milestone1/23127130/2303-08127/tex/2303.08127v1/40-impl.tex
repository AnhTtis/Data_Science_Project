
\section{Framework Implementation}\label{sec:impl}


The \gamename framework has three main components: a Python server, a Unity client, and a Python headless client. 
The game logic is orchestrated from the server, allowing to customize the interaction without modifying Unity code. 
The Python client simplifies the interaction between learning processes and the system, for example during reinforcement learning. 
\autoref{fig:system} visualizes the architecture. 



\subsection{Server}\label{sec:impl:server}

The server architecture is split into modules by logical function. 
We use asynchronous coroutines to reduce latency efficiently and keep the compute needs small. 
The platform is parameterized via a configuration file that is loaded by the server. 

\paragraph{Map Generation}

 Map generation is relatively expensive compared to other processes on the server, mainly because we may use multiple search iterations for routing paths between landmarks and to prevent the leader or follower from spawning in closed-off regions. 
 We mitigate potential lag because of server load by preparing a pool of maps in advance, which we refill during idle periods. 

\paragraph{Player Lobbies}

The server supports multiple lobbies concurrently. 
Separate lobbies provide different player pairing strategies, such as for human-human and human-model games. 
Players wait in a lobby until they are paired for a game. 
Each lobby maintains multiple queues for pairing players and assigning roles according to their experience or other information. 
For example, by default, we distinguish between expert and novice players, and prioritize pairing experts as leaders with novices as followers.
Each lobby maintains active game rooms of different types,  such as for standard games, tutorials, game replays, and custom scenarios.  
Each game room contains a game state machine and websocket connections to the clients. 



\paragraph{Data Storage}
Game events are recorded into an sqlite3 database, which  allows for efficient interaction with game data. Each game is represented as a linear list of events, which can be replayed to recreate game state at a particular moment in time.

\paragraph{Data Portal}

The data portal provides an interface to view game records and statistics. 
The web data browser shows game-specific recordings, including turns, instructions, and individual player actions. Each game record also includes a link to launch a game replay using the web client. 
There is also a web page with live statistics, such as the mean and median scores, and a page to download an archive of all server data. 
The data portal also provides an HTTP API for programmatic data access. 









\paragraph{Map and Scenario Editor}

Maps are generated procedurally by default. 
\gamename also provides a map editor for researchers to place users in controlled scenarios. 
A real-time API allows attaching to an interaction and update the map in response to the game state, enabling dynamic interactions.

\subsection{Web Client}\label{sec:impl:webclient}

The web client is developed using the Unity game engine, and is packaged as a WebAssembly binary. The client receives game states, actions, and instructions from the server. 
We design the client to be thin, putting as much of the game logic and configuration on the server  as possible, so that changes to game logic can be made purely in Python.
We designed the gameplay user interface (UI) to be accessible and easy to learn by incorporating feedback from players. All UI elements are clustered together, and have keyboard shortcuts. \autoref{fig:scenario:env} shows the leader interface during a leader turn. 

Beyond gameplay, the web client provides a tutorial to onboard players to the game by stepping them through a game interaction accompanied by prompts and tooltips. 
The tutorial flow is specified on the server, and can be modified easily. 
The web client also provides game replay, which is activated by adding URL parameters when the HTML page is loaded. The parameters are added automatically to links in the web data browser (\autoref{sec:impl:server}). 


\subsection{Python Client}

The programmatic Python client API supports fast lightweight interaction with the game. 
It is designed for machine learning processes that require interacting with the game environment, such as reinforcement learning~\cite{Sutton1998:rl-book-second}, and can be used to deploy agents interacting with human players or agent-agent interactions.  
Interaction through this API are similar to interactions with the Unity client, except that recording is optional to reduce overhead. 
When recorded, they can be replayed using the Unity client. 
We also provide an OpenAI Gym-style wrapper for the Python API.
\autoref{fig:game_loop} shows example code. 



\begin{figure}[t]
    \centering
    \begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=black,
fontsize=\scriptsize
]{python}
def PlayGameAsFollower(game):
    game_state = game.initial_state()
    # The game starts with the leader's turn. 
    # Wait for follower's turn by executing a noop.
    game_state = game.step(Action.NoopAction())
    while not game.over():
        action = get_action(game_state)
        game_state = game.step(action)
    (_, _, turn_state, _, _, _) = game_state
    print(f"Game over. Score: {turn_state.score}")
    \end{minted}
    \caption{Example code  using the Python API.}\label{fig:game_loop}
    \vspace{-10pt}
\end{figure}














































