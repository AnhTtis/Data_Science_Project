\section{Appendix}

\subsection{Details on \peralgabbr{} Methods}
\subsubsection{Over/Undercrossing Predictor}
\label{sec:ou_appendix}
\textbf{Model Architecture and Inference:} The binary classification threshold of 0.275 is determined by testing accuracy on a held-out validation set of 75 images on threshold values in the range $[0.05, 0.95]$ at intervals of 0.05. Scores $< 0.275$  indicate undercrossing predictions and scores $\geq 0.275$ indicate overcrossing predictions. We output the raw prediction score and a scaled confidence value (0.5 to 1) indicating the classifier's probability.

\subsection{Details on Robot Untangling using \peralgabbr{}}
\label{sec:untangling_deets}

\subsubsection{Knot Definition}
\label{sec:knot_def}
Consider a pair of points $p_1$ and $p_2$ on the cable path at time $t$ with ($p_1, p_2 \in \mathcal{C}_t)$. Knot theory strictly operates with closed loops, so to form a loop with the current setup, we construct an imaginary cable segment with no crossings joining $p_1$ to $p_2$ \cite{reidemeister1983knot}. This imaginary cable segment passes above the manipulation surface to complete the loop between $p_1$ and $p_2$ (``$p_1\rightarrow p_2$ loop").
A knot exists between $p_1$ and $p_2$ at time $t$ if no combination of Reidemeister moves I, II (both shown in Figure \ref{fig:reid_cc}), and III can simplify the $p_1 \rightarrow p_2$ loop to an unknot, i.e. a crossing-free loop. In this paper, we aim to untangle semi-planar knots. For convenience, we define an indicator function $k(s):[0,1]\rightarrow\{0,1\}$ which is 1 if the point $\theta(s)$ lies between any such points $p_1$ and $p_2$, and 0 otherwise.
 
Based on the above knot definition, this objective is to remove all knots, such that $\int k(s)_0^1=0$. In other words, the cable, if treated as a closed loop from the endpoints, can be deformed into an unknot. We measure the success rate of the system at removing knots, as well as the time taken to remove these knots. 


\subsubsection{State Definition}
\label{sec:analytic-knot-detect}
We construct line segments between consecutive points on the trace outputted by the learned cable tracer (Section \ref{sec:tracer}). Crossings are located at the points of intersection of these line segments.
We use the crossing classifier (Section \ref{sec:classifier}) to estimate whether these crossings are over/undercrossings. We also implement probabilistic crossing correction with the aim of rectifying classification errors, as we describe in Section \ref{subsubsec:crossingcorrection}.

We denote the sequence of corrected crossings, in the order that they are encountered in the trace, by $\mathcal{X} = (c_1, ..., c_n)$, where $n$ is the total number of crossings and $c_1, ..., c_n$ represent the crossings along the trace. 

%To reduce the number of actions required to successfully untangle the cable, we algorithmically apply Reidemeister moves I and II to discard non-essential crossings (Fig.~\ref{fig:reid_cc}). We exclude Reidemeister move III from this scheme as it does not lead to a direct reduction in the number of crossings, unlike moves I and II. We are allowed to perform this algorithmic manipulation as Reidemeister moves maintain knot equivalence \cite{reidemeister1983knot}. 

\subsubsection{Crossing Cancellation}

\begin{figure}[!t]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/CoRL_cc.pdf}
    \caption{\textbf{Reidemeister Moves and Crossing Cancellation}: Left of part 1 depicts Reidemeister Move II. Right of part 1 depicts Reidemeister Move I. Part 2 shows that by algorithmically applying Reidemeister Moves II and I, we can cancel trivial loops, even if they visually appear as knots.}
    \label{fig:reid_cc}
    % \vspace*{-0.25in}
\end{figure}

\label{sec:cc_appendix}
Crossing cancellation allows for the simplification of cable structure by removing non-essential crossings, shown in Figure \ref{fig:reid_cc}. It allows the system to filter out some trivial configurations as Reidemeister moves maintain knot equivalence \cite{reidemeister1983knot}. We cancel all pairs of consecutive crossings ($c_i$, $c_{i + 1}$) in $\mathcal{X}$ for some $j$) that meet any of the following conditions: \begin{itemize}
    \item \emph{Reidemeister I:} $c_i$ and $c_{i + 1}$ are at the same location, or
    \item \emph{Reidemeister II:} $c_i$ and $c_{i + 1}$ are at the same set of locations as $c_j$ and $c_{j + 1}$ ($c_j, c_{j + 1} \in \mathcal{X}$). Additionally, $c_i$ and $c_{i + 1}$ are either both overcrossings or both undercrossings. We also cancel ($c_j, c_{j + 1}$) in this case.
\end{itemize}

We algorithmically perform alternating Reidemeister moves I and II as described. We iteratively apply this step on the subsequence obtained until there are no such pairs left. We denote the final subsequence, where no more crossings can be canceled, by $\mathcal{X}'$.

\subsubsection{Knot Detection}
\label{sec:knot_detection}
We say that a subsequence of $\mathcal{X}'$, $\mathcal{K}_{ij} = (c_i, ..., c_j)$, defines a potential knot if: \begin{itemize}
    \item $c_i$ is an undercrossing, and
    \item $c_j$ is an overcrossing at the same location, and
    \item at least one intermediate crossing, i.e. crossing in $\mathcal{X}'$ that is not $c_i$ or $c_j$, is an overcrossing.
\end{itemize}

The first invariant is a result of the fact that all overcrossings preceding the first undercrossing (as seen from an endpoint) are removable. We can derive this by connecting both endpoints from above via an imaginary cable (as in Section \ref{sec:knot_def}): all such overcrossings can be removed by manipulating the loop formed. The second invariant results from the fact that a cable cannot be knotted without a closed loop of crossings. The third and final invariant can be obtained by noting that a configuration where all intermediate crossings are undercrossings reduces to the unknot via the application of the 3 Reidemeister moves. Therefore, for a knot to exist, it must have at least one intermediate overcrossing.

Notably, these conditions are necessary, but not sufficient, to identify knots. However, they improve the likelihood of bypassing trivial configurations and detecting knots. This increases the system's efficiency by enabling it to focus its actions on potential knots.

\begin{figure}[!t]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/knot_CP.pdf}
    \caption{\textbf{Knot Detection and Cage Pinch Point Selection}: The left image shows using crossing cancellation rules from knot theory, the knot detection algorithm analytically determines where the knot begins in the cable. The right image shows the survey process for selecting the cap pinch points.}
    \label{fig:cp_point}
    % \vspace*{-0.25in}
\end{figure}

\subsubsection{Algorithmic Cage-Pinch Point Detection}
As per the definition introduced in Section \ref{sec:knot_detection}, given knot $\mathcal{K}_{ij} = (c_i, ..., c_j)$, $c_i$ and $c_j$ define the segments that encompass the knot where $c_i$ is an undercrossing and $c_j$ is an overcrossing for the same crossing. The pinch point is located on the overcrossing cable segment, intended to increase space for the section of cable and endpoint being pulled through. The cage point is located on the undercrossing cable segment. To determine the pinch point, we search from crossing $c_{u1}$ to crossing $c_{u2}$. $c_{u1}$ is the previous undercrossing in the knot closest in the trace to $j$. $u2 > j$ and $c_{u2}$ is the next undercrossing after the knot. We search in this region and select the most graspable region to pinch at, where graspability ($G$) is defined by the number of pixels that correspond to a cable within a given crop and a requirement of sufficient distance from all crossings $c_i$. To determine the cage point, we search from crossing $c_i$ to $c_{k}$ where $i < k < j$ and $c_{k}$ is the next undercrossing in the knot closest in the trace to $c_{i}$. We similarly select the most graspable point. If no points in the search space for either the cage or pinch point are graspable, meaning $G < \mathcal{T}$ where $\mathcal{T}$ is an experimentally derived threshold value, we continue to step along the trace from $c_{u2}$ for pinch and from $c_k$ for cage until $G \geq \mathcal{T}$. This search process is shown in Figure \ref{fig:cp_point}.

\subsubsection{Manipulation Primitives}
\label{sec:manip}
We use the same primitives as in SGTM 2.0 (Sliding and Grasping for Tangle Manipulation 2.0) \cite{shivakumar2022sgtm} to implement \peralgabbr{} as shown in Figure \ref{fig:algorithm} for untangling long cables. We add a \emph{perturbation} move. 

\textbf{Cage-Pinch Dilation:} We use cage-pinch grippers as in ~\citet{viswanath2022autonomously}. We have one gripper cage grasp the cable, allowing the cable to slide between the gripper fingers but not slip out. The other gripper pinch grasps the cable, holding the cable firmly in place. This is crucial for preventing knots in series from colliding and tightening during untangling. The \textit{partial} version of this move introduced by \citet{shivakumar2022sgtm} separates the grippers to a small, fixed distance of 5 cm.

\textbf{Reveal Moves:} First, we detect endpoints using a Mask R-CNN object detection model. If both endpoints are visible, the robot performs an \emph{Endpoint Separation Move} by grasping at the two endpoints and then pulling them apart and upwards, away from the workspace, allowing gravity to help remove loops before placing the cable back on the workspace. If both endpoints are not visible, the robot performs an \emph{Exposure Move}. This is when it pulls in cable segments exiting the workspace. Building on prior work, we add a focus on where this move is applied. While tracing, if we detect the trace hits the edge, we perform an exposure move at the point where the trace exits the image. 

\textbf{Perturbation Move:} If an endpoint or the cable segment near an endpoint has distracting cable segments nearby, making it difficult for the analytic tracer to trace, we perturb it by grasping it and translating in the x-y plane by uniformly random displacement in a $10$cm $\times$ $10$cm square in order to separate it from slack.

\begin{figure*}[!ht]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/Full_Untangling_Pipeline.pdf}
    \caption{\textbf{Untangling Algorithm with \peralgabbr{}}: We first detect the endpoints and initialize the tracer with start points. If we are not able to obtain start points, we perturb the endpoint and try again. Next, we trace. While tracing, if the cable exits the workspace, we pull the cable towards the center of the workspace. If the tracer gets confused and begins retracing a knot region, we perform a partial cage-pinch dilation that will loosen the knot, intended to make the configuration easier to trace on the next iteration. If the trace is able to successfully complete, we analyze the topology. If there are no knots, we are done. If there are knots, we perform a cage-pinch dilation and return to the first step.}
    \label{fig:algorithm}
    \vspace*{-0.18in}
\end{figure*}

\subsubsection{Cable Untangling System}
Combining \peralgabbr{} and the manipulation primitives from Section \ref{sec:manip}, the cable untangling algorithm works as follows:
First, detect endpoints and initialize the learned tracer with 6 steps of the analytic tracer. If \peralgabbr{} is unable to get these initialization points, perturb the endpoint from which we are tracing and return to the endpoint detect step. Otherwise, during tracing, if the cable leaves the workspace, perform an exposure move. If the trace fails and begins retracing itself, which can happen in denser knots, perform a partial cage-pinch dilation as in \cite{shivakumar2022sgtm}. If the trace completes and reaches the other endpoint, analyze the topology. If knots are present, determine the cage-pinch points for it, apply a cage-pinch dilation move to them, and repeat the pipeline. If no knots are present, the cable is considered to be untangled. The entire system is depicted in Figure \ref{fig:algorithm}.

\subsection{Details on Knot Tying Experiments}
\label{sec:demos_appendix}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/Demos.pdf}
    \caption{\textbf{Using \peralgabbr{} for Learning from Demos:} The left (blue panel) displays the single human demonstration, indicating the pick and place points for tying an overhand knot. The right (pink panel) shows this demonstration successfully applied to the cable in a different configuration with 2 other distractor cables in the scene. The first step of the demonstration is achieved through an arc length relative action while the second step is achieved through a crossing relative action.}
    \label{fig:demos}
    % \vspace*{-0.2in}
\end{figure}

When performing state-based imitation, each of the pick and place points $p_i$ from the demonstration is parameterized in the following way: 1) find the point along the trace, $T$, closest to the chosen point $\hat{p_i}$ with index $j$ in $T$, 2) find the displacement $d_i = p_i - \hat{p_i}$ in the local trace-aligned coordinate system of $\hat{p_i}$, 3) in memory, for point $p_i$, store $d_i$, arc length of $\hat{p_i}$ ($\sum_{x=1}^{j} T_x - T_{x-1}$), and the index value of the crossing in the list of crossings just before $\hat{p_i}$.

When rolling out a policy using this demonstration, there are two ways to do so: 1) relative to the arc length along the cable, or 2) relative to the fraction of the arc length between the 2 crossing indices. The way to do so is to find the point on the cable with the same arc length as $\hat{p_i}$ from the demo or the fractional arc length between the same 2 crossing indices, depending on the type of demonstration. Then, apply $d_i$ in the correct trace-aligned coordinate system. An example demonstration is shown in Figure \ref{fig:demos}.
\subsection{Experiments Failure Mode Analysis}
\label{sec:failures}
\subsubsection{Using \peralgabbr{} for Tracing Cables Unseen During Training}
\label{sec:gen_fail}

\begin{figure}[!t]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/generalize_tracer.pdf}
    \caption{\textbf{Cables for Tracing Unseen Cables Experiment}}
    \label{fig:generalize_tracer}
    % \vspace*{-0.25in}
\end{figure}

\begin{table}[!t]
    \centering
    \footnotesize
    \newcolumntype{?}{!{\vrule width 1.75pt}}
    \caption{Tracing on Unseen Cables Results}
    \setlength\tabcolsep{4pt}
    \begin{tabular}{|c|c|c|c|c|c|c|c|} \hline 
    \cellcolor{gray!15}{Cable Reference} & TR & 1 & 2 & 3 & 4 & 5 & \textbf{Avg.} \\ \hline
    \cellcolor{gray!15}{Tracing Success Rate} & 6/8 & 7/8 & 8/8 & 7/8 & 6/8 & 6/8 & \textbf{40/48=83\%} \\ \hline
    \cellcolor{gray!15}{Failures} & (I) 2 & (I) 1 & & (II) 1 & (I) 1, (III) 1 & (II) 1, (III) 1 & \\ \hline
    \end{tabular}
    \label{tab:gen-trace-results-failures}
\end{table}

\begin{enumerate}[(1)]
    \item Retraces previously traced cable (went in a loop). 
    \item Missteps onto a parallel cable.
    \item Skips a loop.
\end{enumerate}

Figure \ref{fig:generalize_tracer} shows the cables tested on. The most common failure mode is (I), retracing previously traced cable. This is commonly observed in cases with near parallel segments or in dense loop areas within a knot.


\subsubsection{Using \peralgabbr{} for Cable Inspection in Multi-Cable Settings} 

\begin{enumerate}[(I)]
    \item Misstep in the trace, i.e. the trace did not reach any adapter.
    \item The trace reaches the wrong adapter.
    \item The trace reaches the correct adapter but  is an incorrect trace.
\end{enumerate}

\begin{table}
    \centering
    \scriptsize
    \newcolumntype{?}{!{\vrule width 1.75pt}}
    \caption{Multi-Cable Tracing Results}
    \setlength\tabcolsep{4pt}
    \begin{tabular}{|c?c|c|} \hline 
    % \multicolumn{1}{|c?}{} & \multicolumn{2}{|c|}{{\textbf{Tier B1}}} \\ \hline
    \multicolumn{1}{|c?}{} & \cellcolor{gray!15}{Analytic} & \cellcolor{gray!15}{Learned} \\ \hline
    Tier A1 & 3/30 & \textbf{27/30} \\ \hline
    Tier A2 & 2/30 & \textbf{23/30} \\ \hline
    Tier A3 & 1/30 & \textbf{23/30} \\ \hline
    Failures & {(I) 3, (II) 45, (III) 36} & {(I) 14, (II) 1, (III) 2} \\ \hline
    \end{tabular}
    \label{tab:multi-cable-failures}
    \vspace*{-0.12in}
\end{table}

The most common failure mode for the learned tracer, especially in Tier A3, is (I). One reason for such failures is the presence of multiple twists along the cable path (particularly in Tier A3 setups, which contain more complex inter-cable knot configurations). The tracer is also prone to deviating from the correct path on encountering parallel cable segments. In Tier A2, we observe two instances of failure mode (III), where the trace was almost entirely correct in that it reached the correct adapter but skipped a section of the cable.

The most common failure modes across all tiers for the analytic tracer are (II) and (III). The analytic tracer particularly struggles in regions of close parallel cable segments and twists. As a result of the scoring metric, 87 of the 90 paths that we test reach an adapter; however, 45/90 paths did not reach the correct adapter. Even for traces that reach the correct adapter, the trace is incorrect, jumping to other cables and skipping sections of the true cable path.

\subsubsection{Using \peralgabbr{} for Physical Robot Knot Tying from Demonstrations}
\begin{table}[]
    \centering
    \scriptsize
    \newcolumntype{?}{!{\vrule width 1.25pt}}
    \captionof{table}{Learning From Demos}
     \label{tab:demo_failures}
    \setlength\tabcolsep{4pt}
    \begin{tabular}{|c?c|c|} \hline 
    \multicolumn{1}{|c?}{} & \cellcolor{gray!15}{Succ. Rate} & \cellcolor{gray!15}{Failures} \\ \hline
    Tier B1 & 5/5 & - \\ \hline
    Tier B2 & 4/5 & (1) 1 \\ \hline
    Tier B3 & 4/5 & (1) 1, (2) 1\\ \hline
    \end{tabular}
\end{table}

\begin{enumerate}[(1)]
    \item Trace missteps onto a parallel cable.
    \item Cable shifted during manipulation, not resulting in a knot at the end.
\end{enumerate}

Failure mode (1) occurs when the distractor cable creates near parallel sections to the cable of interest for knot tying, causing the trace to misstep. Failure mode (2) occurs when the manipulation sometimes slightly perturbs the rest of the cable's position while moving one point of the cable, causing the end configuration to not be a knot, as intended. 


\subsubsection{Using \peralgabbr{} for Knot Detection}
\begin{table}[!t]
    \centering
    \scriptsize
    \newcolumntype{?}{!{\vrule width 1.75pt}}
    \label{tab:tusk-results}
    \caption{\peralgabbr{} Experiments}
    \setlength\tabcolsep{4pt}
    \begin{tabular}{|c?c|c|c|c|} \hline 
    % \multicolumn{1}{|c?}{} & \multicolumn{4}{|c|}{{\textbf{Tier A1}}} \\ \hline
    \multicolumn{1}{|c?}{} & \cellcolor{gray!15}{SGTM 2.0} & \cellcolor{gray!15}{\peralgabbr{} (-LT)} & \cellcolor{gray!15}{\peralgabbr{} (-CC)} & \cellcolor{gray!15}{\peralgabbr{}} \\ \hline
    Tier C1 & 2/30 & {14/30} & 20/30 & \textbf{24/30} \\ \hline
    Tier C2 & \textbf{28/30} & 8/30 & 21/30 & 26/30 \\ \hline
    Tier C3 & 12/30 & 14/30 & 0/30 & \textbf{19/30} \\ \hline
    Failures & (A) 30, (B) 18 & (D) 11, (F) 7 & (B) 38, (C) 5, & (B) 11, (D) 8 \\ 
     & & (G) 24, (H) 11 & (E) 6 & (F) 1 \\ \hline
    \end{tabular}
    \label{tab:tusk_exp}
    % \vspace*{-0.18in}
\end{table}

\begin{enumerate}[(A)]
    \item The system fails to detect a knot that is present---a false negative.
    \item The system detects a knot where there is no knot present---a false positive. 
    \item The tracer retraces previously traced regions of cable.
    \item The crossing classification and correction schemes fail to infer the correct cable topology.
    \item The knot detection algorithm does not fully isolate the knot, also getting surrounding trivial loops.
    \item The trace skips a section of the true cable path.
    \item The trace is incorrect in regions containing a series of close parallel crossings.
    \item The tracer takes an incorrect turn, jumping to another cable segment.
\end{enumerate}

For SGTM 2.0, the most common failure modes are (A) and (B), where it misses knots or incorrectly identifies knots when they are out of distribution. For \peralgabbr{} (-LT), the most common failure modes are (F), (G), and (H). All 3 failures are trace-related and result in knots going undetected or being incorrectly detected. For \peralgabbr{} (-CC), the most common failure modes are (B) and (E). This is because \peralgabbr{} (-CC) is unable to distinguish between trivial loops and knots without the crossing cancellation scheme. By the same token, \peralgabbr{} (-CC) is also unable to fully isolate a knot from surrounding trivial loops. For \peralgabbr{}, the most common failure mode is (B). However, this is a derivative of failure mode (D), which is present in \peralgabbr{} (-LT), \peralgabbr{} (-CC), and \peralgabbr{}. Crossing classification is a common failure mode across all systems and is a bottleneck for accurate knot detection. In line with this observation, we hope to dig deeper into accurate crossing classification in future work. 

\subsubsection{Using \peralgabbr{} for Physical Robot Untangling}

\begin{table*}[!t]
    \centering
    \scriptsize
    \newcolumntype{?}{!{\vrule width 1.75pt}}
    \caption{\peralgabbr{} and Physical Robot Experiments (90 total trials)}
    \setlength\tabcolsep{4pt}
    \begin{tabular}{|c?c|c?c|c?c|c|}
    \hline \multicolumn{1}{|c?}{} & \multicolumn{2}{|c?}{\cellcolor{gray!20}{{\textbf{Tier D1}}}} & \multicolumn{2}{|c?}{\cellcolor{gray!20}{\textbf{Tier D2}}} & \multicolumn{2}{|c|}{\cellcolor{gray!20}{\textbf{Tier D3}}} \\ 
    \hline
    \multicolumn{1}{|c?}{} & {SGTM 2.0} & {\peralgabbr{}} & {SGTM 2.0} & \peralgabbr{} & {SGTM 2.0} & {\peralgabbr{}} \\ \hline
    Knot 1 Succ. & {11/15} & {\textbf{12/15}} & {6/15} & {\textbf{11/15}} & {9/15} & {\textbf{14/15}} \\ \hline
    Knot 2 Succ. & {-} & {-} & {-} & {-} & 2/15 & \textbf{6/15} \\ 
    \hline
    Verif. Rate & {\textbf{11/11}} & 8/12 & \textbf{6/6} & 6/11 & \textbf{1/2} & 2/6 \\
    \hline
    Knot 1 Time (min) & 1.1$\pm$0.1 & 2.1$\pm$0.3 & 3.5$\pm$0.7 & 3.9$\pm$1.1 & 1.8$\pm$0.4 & 2.0$\pm$0.4 \\
    \hline
    Knot 2 Time (min) & {-} & {-} & - & - & 3.1$\pm$1.2 & 7.5$\pm$1.6 \\ 
    \hline
    Verif. Time (min) & 5.7$\pm$0.9 & 6.1$\pm$1.4 & 6.4$\pm$1.8 & 10.1$\pm$0.7 & 5.4 & 9.6$\pm$1.5 \\
    \hline
    \multicolumn{1}{|c?}{Failures} & {(7) 4} & {(1) 2, (2) 1} & {(1) 3, (5) 6} & {(2) 2, (4) 1} & {(1) 3, (2) 3, (5) 3} & {(1) 2, (2) 3} \\
    \multicolumn{1}{|c?}{} & & {(1) 2, (2) 1} & {(1) 3, (5) 6} & {(5) 1} & {(6) 2, (7) 2} & {(3) 1, (6) 3} \\
    \hline 
    \end{tabular}
    \label{tab:results_all-failures}
    \vspace{-0.2in}
\end{table*}

\begin{enumerate}[(1)]
    \item Incorrect actions create a complex knot. 
    \item The system misses a grasp on tight knots.
    \item The cable falls off the workspace.
    \item The cable drapes on the robot, creating an irrecoverable configuration.
    \item False termination. 
    \item Manipulation failure.
    \item Timeout.
\end{enumerate}

The main failure modes in \peralgabbr{} are (1), (2), and (6). Due to incorrect cable topology estimates, failure mode (1) occurs: a bad action causes the cable to fall into complex, irrecoverable states. Additionally, due to the limitations of the cage-pinch dilation and endpoint separation moves, knots sometimes get tighter during the process of untangling. While the perception system is still able to perceive the knot and select correct grasp points, the robot grippers bump the tight knot, moving the entire knot and causing missed grasps (2). Lastly, we experience manipulation failures while attempting some grasps as the YuMi has a conservative controller (6). We hope to resolve these hardware issues in future work. 

The main failure modes in SGTM 2.0 are (5) and (7). Perception experiments indicate that SGTM 2.0 has both false positives and false negatives for cable configurations that are out of distribution. (5) occurs when out-of-distribution knots go undetected. (7) occurs when trivial loops are identified as knots, preventing the algorithm from terminating.
