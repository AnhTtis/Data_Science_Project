\section{Background}\label{sec:background}

\ITEM{Vulnerability Detection vs.\ Weakness Warning}.
According to the Common Weakness Enumeration, \href{https://cwe.mitre.org/about/index.html}{cwe.mitre.org}, weaknesses are \emph{flaws, faults, bugs, or other errors in software or hardware implementation, code, design, or architecture that if left unaddressed could result in systems, networks, or hardware being vulnerable to attack.}

The tools in our study report findings with varying degrees of certainty, from warnings about potential weaknesses to exploits demonstrating the existence of a vulnerability or, more rarely, proofs guaranteeing their absence.
As proving the absence or presence of software properties is difficult, most tools employ heuristics, usually favoring a higher number of false positives over the possibility to overlook an actual vulnerability.
Such tools issue warnings and leave the final assessment to the user.


\ITEM{Deployment vs.\ runtime code.}
To deploy a contract on an Ethereum chain, an external user submits a create transaction, or the Ethereum Virtual Machine (EVM) executes a create instruction.
The transaction/instruction contains the \emph{deployment code}.
It consists of an active part, $D$, which typically sets up the environment for the new contract.
At its end, $D$ returns the pointer to a memory area with the actual \emph{runtime code}, which the EVM then stores at the address of the new contract.
The deployment code is free to assemble the runtime code arbitrarily, but typically just copies code following~$D$.

\ITEM{Source code vs.\ bytecode.}
The majority of Ethereum contracts are written in Solidity, a programming language inspired by \Cpp.
The so-called constructor and any global initializations compile to the active part of the deployment code, $D$, whereas all other parts of the source file compile to the runtime code proper,~$R$, which is appended to $D$.
After~$R$, the compiler appends \emph{meta-data}, $M$, which contains a hash identifying the original source code.
Changing any character in the Solidity file, including comments, alters $M$ and leads to a superficially different deployment and runtime code.

\autoref{fig:Solidity program} shows the Solidity code of a contract \texttt{C1} that deploys a contract of type \texttt{C2} as part of its own deployment.
At runtime, each call to function \texttt{f} deploys a contract \texttt{C3}.
The compiler generates a bytecode of the form \(D_1R_1D_3R_3M_3M_1D_2R_2M_2\).

\begin{solidity}[basicstyle=\footnotesize\ttfamily,caption=Solidity contract creating contracts during deployment (\texttt{C2}) as well as during runtime (\texttt{C3}).,label=fig:Solidity program,numbers=none,float]
contract C1 {
    C2 c = new C2();
    constructor() { }
    function f() public returns(C3) {
        return new C3();
}   }
\end{solidity}

During deployment, $D_1$ creates the contract~\texttt{C2} by executing $D_2R_2M_2$, with the runtime code $R_2M_2$ getting stored at the address of \texttt{C2}.
$D_1$ returns $R_1D_3R_3M_3M_1$ as the runtime code of \texttt{C1}.
When function~\texttt{f} is called, $D_3R_3M_3$ is executed and creates a new contract with runtime code $R_3M_3$.

\ITEM{Skeletons.}
The skeleton of a contract is obtained by removing meta-data, the arguments of \OP{PUSH} operations, constructor arguments, and trailing zeros.
The rationale is to remove parts that contribute little to the functionality of the contract, with the aim to equate contracts with the same skeleton.%
\footnote{See \url{https://github.com/gsalzer/ethutils} for more information and scripts.}

\autoref{tab:deployments} gives an overview of the deployment activities on Ethereum's main chain up to block 14\,M (Jan 2022).
\begin{table}[!t]
\caption{Deployments up to Block 14\,M (Jan 2022)}\label{tab:deployments}     
  \centering
  \begin{tabular}{@{}lr@{}}
    \toprule
    Metric & \# Contracts \\
    \midrule
    Deployments                        & \np{48262411} \\
    Distinct deployment codes          & \np{2206793} \\
    Distinct runtime codes             & \np{514893}\\
    \dots\ without meta-data           & \np{364599} \\
    \dots\ without \OP{PUSH} arguments & \np{249076} \\
    Skeletons                          & \np{248328} \\
    \bottomrule
  \end{tabular}
\end{table}     
The 48.3\,M contract creations involved 2.2\,M different deployment codes, generating a total of 0.5\,M distinct runtime codes.
The removal of meta-data reduces the number of distinct codes by 29\,\%, the removal of \OP{PUSH} constants by another 22\,\%.

A \emph{family of codes} is a collection of codes with the same skeleton.
The size of the families seems to follow a Pareto principle: 84\,\% of the families are singletons (the skeleton is uniquely associated with a single runtime code), 15\,\% of the families consist of 2 to 10 codes, whereas at the other end of the spectrum we find a skeleton shared by \np{16372} codes.%
\footnote{These codes are proxy contracts of 45 bytes that forward any incoming call to a fixed address.
The \np{16372} codes only differ with respect to this hard-coded address.}
