\section{Introduction}
\label{sec:introduction}

\emph{Smart contracts} are event-driven programs running on the nodes of decentralized networks known as \emph{blockchains}.
Specific transactions, once included in the blockchain, trigger the execution of these blockchain programs.
Every node executes the code locally within a virtual machine and updates its state of the blockchain.
The computations are deterministic, ensuring that all nodes arrive at the same state.
The flexibility of smart contracts and the unique properties of blockchains, most notably decentralization and immutability, gave rise to innovative applications in areas like decentralized finance and supply chain management.
Their potential has led to ecosystems with large numbers of start-ups and market caps of hundreds of billions of USD.

Against this background, functionalities in smart contracts can lead, and have led, to costly disruptions and losses.
Early on, academia and industry focused on methods and tools for developing secure smart contracts.
In a survey on automated vulnerability detection conducted in mid-2021, \cite{Rameder2022} identified 140 tools for Ethereum, the major smart contract platform.
The sheer number makes it hard to decide which tools may be suited for the task at hand and calls for regular tool evaluations and comparisons.

The work presented in this paper is unique in several respects. 
First, we analyze the \emph{evolution of weakness detection} over time with a focus on the quality of tools.

Second, we aim at a \emph{complete coverage of the Ethereum main chain}, which is a formidable endeavor in light of 48 million deployments of smart contracts (up to Jan 2022).
This enables us to investigate the evolution of weakness detection over a period of more than six years.
We select one contract per skeleton of bytecode (cf.\ \autoref{ssec:data}), which reduces the number of objects to analyze to \np{248328}.

Third, we concentrate on the \emph{runtime bytecode} as input to the tools.
In fact, surveys usually evaluate tools based on benchmarks of Solidity source code (cf.\ \autoref{sec:related}).
However, many tools, in particular those considered here, actually analyze the bytecode.
If possible, any findings are later attributed to the source line closest to where the bytecode originated from.
Moreover, for many contracts on the blockchain, the source code is not available.
By choosing runtime bytecode as the least denominator, we can include tools not contextualizing their findings, and we are able to consider all smart contracts deployed so far.

Finally, to perform our study, we extended SmartBugs~\citep{ferreira2020smartbugs}, a framework for executing analysis tools in a unified manner, which is used by developers to analyze smart contracts routinely with several tools at once.
Integrating new tools into the framework makes them available for future evaluations by others.

With 13 tools, 15 weakness classes, \np{248328} runtime bytecodes of smart contracts and an execution time of 31 years, our evaluation is more comprehensive than previous studies.
In summary, the contributions of this paper are:
\begin {itemize} [topsep=0pt, itemsep=0pt]
\item A method for selecting a feasible number of smart contracts that are representative of \np[M]{48} blockchain programs deployed on Ethereum in the course of six years.
\item An extension of the framework SmartBugs to include 13 tools for vulnerability detection with bytecode-only input.
\item A portrait of the evolution of tool behavior and weakness detection on the \np{248328} representative smart contracts.\footnote{available at \url{https://figshare.com/s/5efef6335fa98ddc3ae2}}
\footnote{available at \url{https://github.com/smartbugs/smartbugs}}
\end {itemize} 
