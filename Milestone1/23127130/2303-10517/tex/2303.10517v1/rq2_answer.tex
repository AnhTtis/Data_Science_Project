\subsection{Weakness Detection}
In this section, we take a look at the overall findings reported by the single tools, and the numbers per weakness class on a timeline of blocks to portray the evolution.

\begin{figure}
\centering
\includegraphics[width=.9\columnwidth]{pics/hits.png}
\caption{Accumulated findings per tool over time. Each data point shows the percentage of bytecodes for which the tool reports a finding, in bins of 100\,k blocks.}
\label{fig:findings}
\end{figure}


\ITEM{Tool reports.}
\autoref{fig:findings} depicts the reporting rate of the single tools over the range of 14\,M blocks.
Each data point represents the percentage of bytecodes in a bin of 100\,k blocks that were marked with at least one finding by the respective tool.
The gray vertical lines indicate forks that added EVM opcodes that may have affected weakness detection.

Overall, the share of contracts flagged by the tools diminishes over time.
This can be interpreted as newer contracts being less vulnerable than older ones, or as the tools becoming less effective in detecting weaknesses.
The latter may apply to unmaintained tools that cannot cope with the code generated by more recent versions of the Solidity compiler.

There are some exceptions to the general trend.
In the upper plot of \autoref{fig:findings}, eThor (red) flags an increasing number of contracts near the end of the timeline.
eThor reports contracts as insecure regarding a reentrancy attack \emph{or as provably secure from such an attack}.
This second type of findings is responsible for the rise from block \np[M]{11.5} onward, while the number of contracts flagged as insecure falls like the orange line.
Hence, the rise in eThor's findings actually confirms that reentrancy issues become less common.
For our further discussions on weaknesses, we will consider the finding `insecure' only.

Another exception is Vandal (third plot in \autoref{fig:findings}, orange).
It flags \np[\%]{76} of the contracts even though it only checks for five weaknesses (SWC\,104, 105, 106, 107, 115).
\np[\%]{97} of the contracts with a \OP{CALL} instruction are reported to contain an \textit{unchecked call} (SWC\,104), in most cases also a \textit{reentrant call} (SWC\,107).
This is surprising as the return value of most calls is indeed checked, in particular method calls where the Solidity compiler automatically inserts appropriate instructions.
Vandal even flags contracts without \OP{CALL} instruction, probably irritated by a byte among the meta-data with the same value as~\OP{CALL}.
We omit Vandal from the comparison below since its overreporting distorts the overall picture.

\begin{figure}
\centering
\includegraphics[width=.9\columnwidth]{pics/evolution_vuls.png}
\caption{SWC classes over time. Percentage of bytecodes flagged with a specific weakness, in bins of 100\,k blocks.}
\label{fig:swc_classes}
\end{figure}

\ITEM{SWC classes detected}.
In~\autoref{tab:vuls}, we give an overview of the weaknesses reported by the tools that we are able to map to a suitable SWC class.
The column \emph{frequency} counts the number of unique skeleton bytecodes, where at least one tool reports the respective weakness\footnote{%
  Most tools do not verify their assessment by providing an exploit (like teEther does) or by proving the absence of the vulnerability (like eThor does). Hence, the table counts warnings rather than vulnerabilities.%
}.
As the tools tackle differing subsets of the SWC classes, the number of tools addressing a specific weakness varies from one to seven.
Due to our cumulative counting, the frequency of a weakness increases with the number of tools claiming to detect it, especially with overreporting tools.

\autoref{fig:swc_classes} depicts the 15 SWC classes on the timeline of 14\,M blocks.
For every SWC class, a data point represents the percentage of skeleton bytecodes in a bin of 100\,k blocks that were marked with the respective weakness by at least one tool (Vandal excluded).
The top plot shows the classes detected by four or more tools (SWC\,101, 105, 107, 114, 116), the middle one those handled by two or three tools (SWC\,104, 106, 112, 113, 124), and the third one those addressed by just one (SWC\,110, 115, 120, 127, 128).


\ITEM{Comparison by SWC class.}
We see five weaknesses decreasing over time from a high ($\geq$~\np[\%]{50}) or medium (\np[\%]{20}) level to a medium or low ($\leq$~\np[\%]{10}) level:
The findings of classes 101, 104, 107, 110, and 114 start falling from about block~4\,M onward.
%
The other 10 weaknesses stay on a steady, but low level after block~4\,M, except for 113 (middle plot), which fluctuates around \np[\%]{10} and 116 (top plot), which fluctuates around \np[\%]{20}.

The decrease of potential integer overflows (101) seems natural: Since version 0.8.0, the Solidity compiler adds appropriate checks automatically, and already some time before, the use of math libraries with the same effect had become quasi-standard.
Reentrancy (107) is probably the most (in)famous vulnerability.
The decrease in detection can be attributed at least partially to developers taking adequate precautions.

\begin{mdframed}[style=mpdframe]
  \textbf{Observation 2.}
  Of the 37 SWC classes, 15 are covered by at least one tool, and 8 by at least three tools.
  For all weaknesses but one, the number of flagged contracts decreases over time or stagnates on a low level.
  Reasons for the decrease in detected weaknesses are unmaintained tools that do not adequately cope with newer EVM instructions as well as compilers and programmers taking counter-measures.
  At the end of the timeline, \emph{integer bugs} (SWC\,101), \emph{reentrancy} (SWC\,107) and \emph{block values as a proxy for time} (SWC\,116) are the most frequent weaknesses with a share of about 20\,\% each.
  The overall picture indicates the need for further work on methods and tools.
\end{mdframed}
