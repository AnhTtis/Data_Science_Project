\section{Analysis Tools}
\label{sec:tools}
In this section, we specify the selection of tools and describe those that we use in our analysis.

\subsection{Selection of Tools}

The setting of our study imposes several restrictions on the tools that we can use.
Starting from the \np{140} tools identified by \cite{Rameder2022}, we apply the following selection criteria.
The numbers in parentheses indicate how many tools in the initial collection fulfill the criterion. 
\begin{enumerate}
\item Availability: The tool needs to be publicly available with its source open (83).
\item Input: The tool is able to analyze contracts based on their runtime bytecode alone (73).
  This excludes tools that need access to the application binary interface\footnote{\url{https://docs.soliditylang.org/en/latest/abi-spec.html}}, to the source code, or to a particular state of the blockchain.
\item Findings: The tool offers an automated mode (41) to report weaknesses (79).
  Some systems are tool boxes for the manual analysis of single contracts.
  Moreover, not all tools target weaknesses, but contracts like honeypots or Ponzi schemes. 
\item Interface: The tool can be controlled via a command-line interface.
\item Documentation: There is sufficient documentation to operate the tool.
\end{enumerate}
Criteria without a number were only checked after the ones with a number had been applied.
The selection processes yielded the 12 tools in \autoref{tab:tools}.
\input{table_tools}

\subsection{Synopsis of Tools}

\ITEM{Conkas} uses the third-party component Rattle to construct a control flow graph and to lift the bytecode to static single assignments.
Then it executes this intermediate representation symbolically and checks the execution traces for patterns that indicate weaknesses.

\ITEM{Ethainter} uses taint analysis to detect whether attacker-injected data reaches critical operations.
It relies on the component Gigahorse that abstracts the bytecode to Datalog rules.
The Datalog program, augmented by rules for the addressed weaknesses, is translated to a \Cpp\ program (using the tool Soufflé), which is compiled to machine code that performs the actual analysis.

\ITEM{eThor} attempts to either prove that the contract is not reentrant and thus is not susceptible to a reentrancy attack, or to find a trace with a reentrant call that indicates that the contract may be vulnerable.
eThor lifts the bytecode to constrained Horn clauses that constitute a sound abstraction of the EVM semantics.
The Horn clauses are then translated into the constraint language of the SMT solver Z3 that does the final analysis.
Various optimizations like the unfolding of Horn clauses are crucial to make the analysis feasible.

\ITEM{MadMax} concentrates on gas-related vulnerabilities.\footnote{%
  EVM instructions consume gas proportional to the time and storage they need.
  Each transaction is endowed with a limit on the total gas it may use, ensuring that each contract terminates.}
Like Ethainter, it uses Gigahorse and Soufflé to lift the bytecode to Datalog.

\ITEM{Maian} executes the EVM bytecode symbolically, relying on the SMT solver Z3 to check the satisfiability of path conditions.
When analyzing source or deployment code, Maian additionally validates the detected weaknesses by deploying the contract on a private blockchain and attacking it with the transactions computed by the SMT solver.
For runtime code this validation step has to be omitted, as there is not enough information for deployment.

\ITEM{Mythril} uses symbolic execution, SMT solving (Z3) and taint analysis to detect a variety of security vulnerabilities.
To increase code coverage, it applies concolic execution that alternates between symbolic execution and runs with concrete values.
It is the only tool in the selection that is actively maintained.

\ITEM{Oyente} constructs a control-flow graph and then executes the contract symbolically.
The execution traces are checked for patterns characteristic of certain weaknesses.
In a final validation step, certain false positives are eliminated before reporting the findings.
Symbolic path constraints and the SMT solver Z3 are used to prune the search space.

\ITEM{Osiris} extends Oyente by adding modules for further weaknesses.

\ITEM{Pakala} executes the bytecode symbolically, without constructing a control flow graph first.
It proceeds in two phases.
First, it collects transactions that lead to state changes or Ether transfers.
Then, the transactions are combined in varying sequences to find one that extracts more Ether than was invested with the transaction.

\ITEM{Securify} constructs a control flow graph and lifts the bytecode to single static assignments.
It uses Souffl\'e to derive semantic facts from inference rules specified in Datalog that describe the data and control flow dependencies.
These facts are then checked against a set of compliance and violation patterns written in a logic-based domain-specific language.

\ITEM{teEther} constructs a control flow graph and searches for paths that lead to critical instructions, with arguments controllable by an attacker.
Symbolic execution translates these paths into constraints for the SMT solver Z3.
The solutions computed by Z3 can then be turned into exploits, i.e., into transactions that trigger the suspected vulnerabilities.

\ITEM{Vandal} constructs a control flow graph and lifts the bytecode to single static assignments.
This intermediate representation is translated to logic relations that represent the semantics of the initial bytecode.
Weaknesses are specified as Datalog rules.
Soufflé synthesizes executable programs that read the logic relations and perform the security analysis.

\subsection{Maintenance Aspects}

\input{table_tool_statistics}
\autoref{tab:maintenance} lists statistics related to the effort put into keeping the tools up to date.
Some tools show a small number of commits and closed issues only, and thus seem unmaintained.
But even tools with several hundred commits became unmaintained at some point.
Judged by the last code commits, Mythril is the only tool actively maintained: it has 74 contributors, \np{4785} commits, and 709 issues resolved.
For our study, maintenance mainly boils down to the question which EVM operations the tools are actually able to handle.


\subsection{Supported EVM Operations}\label{sec:supported_ops}

\input{table_operations}
We say that a tool supports an EVM operation if it models at least the effect of the operation on the stack, by removing and adding an appropriate number of elements.
This way the analysis of the current execution path can proceed, even if little may be known about the state after the operation.
EVM operations may be unsupported either because of having been omitted deliberately or because of having been introduced by a fork after the tool was released (see \autoref{sec:new_ops}).
Tools handle unsupported operations by either stopping the analysis of the current path with an error message, by reverting the computation like the EVM would do for an unused opcode, or by aborting with an exception.

The effect of unsupported operations depends on the type of property checked for.
Most properties are existential: A bytecode satisfies the property if \emph{some} execution path satisfies a characteristic condition.
In such cases an unhandled operation will reduce the number of paths that can be checked.
The tool remains sound, but its detection rate diminishes with the number of paths it cannot check.
A few properties are universal in nature: The property holds for a bytcode if a condition is met by \emph{all} execution paths.
Here, any path that cannot be checked is a threat to the validity of the result, making the method unsound.
\emph{Ether lock} is an example for both property types: The weakness is present if there is at least one execution path that increases the balance of the contract (the contract accepts Ether), whereas all execution paths have the property that they do not decrease the balance (the contract offers no withdraw functionality).

To interpret the analysis results later on, we determine the operations supported by each tool.
The data in \autoref{tab:operations} was obtained by inspecting the source code as well as by executing the tools on a collection of crafted contracts where each consists of one of the listed operations, with some \OP{PUSH} operations preparing the stack. 
A checkmark in the table indicates that the tool supports the operation, while a question mark means that the tool supports the operation according to its source code, but fails on the corresponding crafted contract.

The tools usually support the operations up to the most recent fork before their last update.
Most tools analyze single contracts only, therefore they handle interactions with other contracts by not supporting the operations \OP{DELEGATECALL}, \OP{STATICCALL}, \OP{CREATE2} and \OP{EXTCODEHASH} at all, or if they do, by invalidating those parts of the state that might have been affected by the operation.
Conkas and eThor stick out as handling several operations in their source code that lead to exceptions during execution.
Maian is older than it looks: The tool was published some time after the fork at block 4.37\,M, yet it does not support the two \OP{RETURNDATA} operations. 