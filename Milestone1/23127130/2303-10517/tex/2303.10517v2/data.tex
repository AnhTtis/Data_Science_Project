\section{Contract Data}
\label{sec:data}

This section describes the collection and preparation of the contract data that we are going to analyze.
Moreover, we assess some characteristics of the data that will be needed to interpret the results of the analysis tools.
We start by clarifying some concepts specific to Ethereum.

\subsection{Creation of Contracts}
\label{sec:creation}

\ITEM{Deployment vs.\ runtime code.}
To deploy a contract on an Ethereum chain, an external user submits a create transaction, or the Ethereum Virtual Machine (EVM) executes a create operation.
The transaction/operation includes the \emph{deployment code}.
The code consists of an active part, $D$, which typically initializes the environment for the new contract.
At its end, $D$ returns the pointer to a memory area with the actual \emph{runtime code}, which the EVM then stores at the address of the new contract.
The deployment code is free to assemble the runtime code arbitrarily, but typically just copies code following~$D$ in the deployment code.

\ITEM{Source code vs.\ bytecode.}
The majority of Ethereum contracts are written in Solidity, a programming language inspired by \Cpp.
The so-called constructor and any global initializations compile to the active part of the deployment code, $D$, whereas all other parts of the source file compile to the runtime code proper,~$R$, which is appended to $D$.
After~$R$, the compiler appends \emph{meta-data}, $M$, which contains a hash identifying the original source code and version information.
Changing any character in the Solidity file, including comments and the newline encoding, alters $M$ and leads to superficially different deployment and runtime codes.

To illustrate the role of the different forms of code, consider the program in \autoref{fig:Solidity program}.
It shows the Solidity code of a contract \texttt{C1} that deploys a contract of type \texttt{C2} as part of its own deployment.
At runtime, each call to function \texttt{f} deploys a contract of type~\texttt{C3}.
From this source code, the compiler generates a bytecode of the form \(D_1R_1D_3R_3M_3M_1D_2R_2M_2\).
During deployment, $D_1$ creates the contract~\texttt{C2} by executing $D_2R_2M_2$, with the runtime code $R_2M_2$ getting stored at the address of \texttt{C2}.
Then $D_1$ returns $R_1D_3R_3M_3M_1$ as runtime code, which is stored at the address of~\texttt{C1}.
Later, when the function~\texttt{f} of contract~\texttt{C1} is called, $D_3R_3M_3$ gets executed and creates a new contract with runtime code $R_3M_3$.
Note the multiple occurrences of meta-data and their proliferation during deployment and runtime.

\begin{solidity}[float,basicstyle=\footnotesize\ttfamily,caption=Solidity contract creating contracts during deployment (\texttt{C2}) as well as during runtime (\texttt{C3}). The definitions of \texttt{C2} and \texttt{C3} have been omitted.,label=fig:Solidity program,numbers=none]
contract C1 {
    C2 c = new C2();
    function f() public returns(C3) {
        return new C3();
}   }
\end{solidity}

\ITEM{Skeletons.}
The skeleton of a contract is obtained by removing meta-data, the arguments of \OP{PUSH} operations, constructor arguments, and trailing zeros.
The rationale is to remove parts that contribute little to the functionality of the contract, with the aim to equate contracts with the same skeleton.

\ITEM{Code family.}
A \emph{family of codes} is a collection of runtime codes with the same skeleton.


\subsection{Data Collection}

We strive for a complete coverage of Ethereum's main chain.
Therefore, we collect the runtime codes of all contracts (including the self-destructed ones) that were successfully deployed up to block 14\,M (13~Jan 2022).%
\footnote{We used an OpenEthereum client, \url{https://github.com/openethereum/openethereum}.}
\autoref{tab:deployments} gives an overview of the deployment activities.
\begin{table}
  \caption{Deployments up to Block 14\,M (Jan 2022)}
  \label{tab:deployments}
  \centering
  \begin{tabular}{@{}lr@{}}
    \toprule
    Metric & \# Contracts \\
    \midrule
    Deployments & \np{48262411} \\
    Distinct deployment codes & \np{2206793} \\
    Distinct runtime codes & \np{514893}\\
    \dots\ without meta-data & \np{364599} \\
    \dots\ without \OP{PUSH} arguments & \np{249076} \\
    Skeletons & \np{248328} \\
    \bottomrule
  \end{tabular}%
\end{table}
The 48.3\,M contract creations involved 2.2\,M different deployment codes, generating a total of 0.5\,M distinct runtime codes.
The removal of meta-data reduces the number of distinct codes by \np[\%]{29}, and the removal of \OP{PUSH} constants by another \np[\%]{22}.

For each family of codes, i.e., for each collection of codes sharing the same skeleton, we pick a single representative and omit the others.
For practical purposes, we prefer deployments where Etherscan lists the corresponding source code.
The longest-lived family consists of two codes implementing an ERC20 token, deployed \np{17333} times over a range of almost 12 million blocks, whereas the most prolific family consists of 20 codes deployed over 12 million times.%
\footnote{%
  The codes of this family, 21 bytes in length, belong to gas token systems.
  When called from the address mentioned in the code, the contracts self-destruct, leading in earlier versions of Ethereum to a gas refund.}
The size of the families seems to follow a Pareto principle: 84\,\% of the families are singletons (the skeleton is uniquely associated with a single runtime code), 15\,\% of the families consist of 2 to 10 codes, whereas at the other end of the spectrum we find a skeleton shared by \np{16372} codes.%
\footnote{%
  These codes are proxy contracts of 45 bytes that forward any incoming call to a fixed address.
  The \np{16372} codes only differ with respect to this hard-coded address, occurring as the argument of a \OP{PUSH} operation.}

We obtain a dataset of \np{248328} runtime codes with distinct skeletons that represent all deployments up to January 13, 2022.
\np[\%]{99.0} of these codes originate from the Solidity compiler (as determined by characteristic byte sequences), with the source code for 46.5\,\% actually available on Etherscan.
\emph{For our temporal analyses, we associate each code with the block number where the first member of the family was deployed.}

Not all bytecodes are proper contracts.
In particular in the early days of the main chain, during an attack, a number of large `contracts' were deployed that served as data repositories for other contracts. 
For some tools, this leads to a noticeable spike in the error rate around block 2.3\,M.

\subsection{Forks Introducing New Operations}\label{sec:new_ops}

\begin{table}
  \centering
  \caption{Forks on Ethereum's main chain introducing new operations}
  \label{tab:forks}
  \makebox[0pt]{%
  \begin{tabular}{lrl}
    \toprule
    name of fork&activated at&new operations\\
    \midrule
    Homestead & 1.150\,M & \OP{DELEGATECALL}\\
    Byzantium & 4.370\,M & \OP{RETURNDATASIZE}, \OP{RETURNDATACOPY},
                           \OP{REVERT}, \OP{STATICCALL}\\
    Constantinople & 7.280\,M & \OP{CREATE2}, \OP{EXTCODEHASH}, \OP{SAR},
                                \OP{SHL}, \OP{SHR}\\
    Istanbul & 9.200\,M & \OP{CHAINID}, \OP{SELFBALANCE}\\
    London & 12.965\,M & \OP{BASEFEE}\\
    \bottomrule
  \end{tabular}}
\end{table}
Over time, Ethereum has seen several updates, so-called forks.
Some of them add new operations to the EVM; \autoref{tab:forks} gives an overview of those relevant to our study.
When interpreting the results of an analysis tool, we have to relate the age of the tool to these forks in order to understand the effect of new operations.

\begin{figure}
  \centering
  \includegraphics[width=.9\columnwidth]{ops_evolution.pdf}
  \caption{%
    The use of new EVM operations as well as the adoption of new compiler versions over time.
    In the foreground, each line shows the percentage of bytecodes containing a particular operation, per bin of 100\,k blocks.
    The background shows the distribution of compiler versions for each bin.
    \OP{DELEGATECALL} appears from compiler version 0.4.9 onwards, \OP{REVERT} from 0.4.10, \OP{RETURNDATACOPY} and \OP{RETURNDATASIZE} from 0.4.22, \OP{STATICCALL} from 0.5.0, \OP{SAR}, \OP{SHL} and \OP{SHR} from 0.5.5, \OP{SELFBALANCE} from 0.5.14, \OP{CREATE2} from 0.6.2, \OP{CHAINID} from 0.8.0, and \OP{BASEFEE} from 0.8.7 onwards.
    \OP{EXTCODEHASH} is only available via assembly code.}
  \label{fig:ops_evol}
\end{figure}
The actual use of new operations varies.
It depends on the integration of the operations into the Solidity compiler, the adoption of new compiler versions by the contract developers, and on the relevance of the operation.
\autoref{fig:ops_evol} shows the use of compiler versions as well as the share of contracts using a particular operation.
In the remainder of the section, we first explain the origin of the data and then discuss the details of the figure.

For bytecodes with a source code on Etherscan.io (\np[\%]{46.5}), we take the compiler version from there.
For the others, we try to extract it from the embedded meta-data, succeeding for another 22.8\,\% of the bytecodes.
Given that \np[\%]{99} of the bytecodes have been generated by the Solidity compiler, we extend the compiler distribution in each bin of 100\,k blocks from the codes with a known version to the remaining ones.
For the stackplot in the background of \autoref{fig:ops_evol}, this amounts to considering the share of \np[\%]{69.3} bytecodes with version information as 100\,\% of the data.

We group the 100+ compiler versions into 10 ranges, such that from each range to the next, at least one additional operation from~\autoref{tab:forks} is supported, either by Solidity offering a new language element related to the operation, or by the compiler using the new operation internally to generate better bytecode.

It is inherently difficult to determine the parts of a bytecode that are reachable and may get executed.
To obtain a list of the operations in a bytecode, we identify the first code block and extract its operations linearly.
This yields an overapproximation, as data embedded in the code may be mistaken as operations.

In \autoref{fig:ops_evol}, the effect of this overapproximation is visible up to block 3\,M.
Except for \OP{DELEGATECALL}, none of the new operations has been added to the EVM yet, but the plots show their occurrence at a rate of up to \np[\%]{8} nonetheless.
The spike at block 2.3\,M, with all operations seemingly occurring simultaneously at a rate of \np[\%]{28}, is an artefact caused by a large number of `contracts' consisting entirely of data (the by-product of an attack).
The first real phenomenon to observe is the \OP{REVERT} operation (medium blue line), introduced by compiler version 0.4.10 (gray area).
The compiler starts to use \OP{REVERT} for exception handling shortly after 3\,M, even though the operation is added to the EVM only at fork 4.37\,M.
Before the fork, \OP{REVERT} causes an EVM exception just like the invalid opcode used for this purpose until then, but performs a more refined error handling after the fork.

The other operations of fork 4.37\,M are adopted by the Solidity compiler with some delay.
From version 0.4.22 onwards, the pair of \OP{RETURNDATA} operations (lines in two shades of violet, with the plots almost coinciding) is used for most calls and eventually occurs at a rate beyond \np[\%]{80}.
\OP{STATICCALL} (light blue line) gets in use even later, rising to a rate of \np[\%]{60} towards the end of the timeline.

The shift operations \OP{SHL} (yellow line) and \OP{SHR} (orange line) are of particular importance.
At the end of the study period, they occur in almost every contract.
As the function dispatcher at the start of a contract now uses \OP{SHR}, this operation gets executed with virtually every invocation of a contract.
Of the other operations, only \OP{SELFBALANCE} and \OP{EXTCODEHASH} are used to some extent, while \OP{DELEGETECALL}, \OP{CREATE2}, \OP{SAR}, \OP{CHAINID} and \OP{BASEFEE} play a lesser role.%
\footnote{%
  The low number of contracts containing \OP{DELEGATECALL} may seem surprising, given that this operation is essential for hundreds of thousands of proxy contracts.
  But as these contracts show little variety (few skeletons), they are represented by only a small number of contracts in our dataset.}
