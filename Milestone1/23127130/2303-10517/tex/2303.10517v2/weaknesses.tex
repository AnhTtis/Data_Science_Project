\section{Weaknesses}
\label{sec:weaknesses}
In this section, we describe the weaknesses considered in our study as well as the taxonomy used and the mapping of the tool findings to the taxonomy.

\subsection{Vulnerability Detection vs.\ Weakness Warning}
According to the Common Weakness Enumeration, \href{https://cwe.mitre.org/about/index.html}{cwe.mitre.org}, weaknesses are \emph{flaws, faults, bugs, or other errors in software or hardware implementation, code, design, or architecture that if left unaddressed could result in systems, networks, or hardware being vulnerable to attack.}

The tools in our study report findings with varying degrees of certainty, from warnings about potential weaknesses to exploits demonstrating the existence of a vulnerability or, more rarely, proofs guaranteeing their absence.
As proving the absence or presence of software properties is difficult, most tools employ heuristics, usually favoring a higher number of false positives over the possibility to overlook an actual vulnerability.
Such tools issue warnings and leave the final assessment to the user.

\subsection{Synopsis of Weaknesses}
\label{sec:synopsis_weaknesses}
\ITEM{Integer Overflow and Underflow (SWC 101)}
Integer over- and underflow weaknesses arise in situations, where the result of an arithmetic operation exceeds the admissible range and the system performs a silent wrap-around instead of throwing an exception.
The wrong result may lead to an unexpected behavior or a security breach.

\ITEM{Unchecked Call Return Value (SWC 104)}
This weakness arises when smart contracts do not properly validate the return value of an external contract call, such that an unusual behavior of the call goes unnoticed.

\ITEM{Unprotected Ether Withdrawal (SWC 105)}
Unprotected Ether withdrawal weaknesses occur when smart contracts allow unauthorized parties to withdraw Ether without proper access controls, risking financial loss.

\ITEM{Unprotected \OP{SELFDESTRUCT} Instruction (SWC 106)}
This weakness arises when a \OP{SELFDESTRUCT} instruction is not properly guarded such that an attacker can trigger the destruction of the contract, potentially resulting in the loss of funds or a disruption of services.

\ITEM{Reentrancy (SWC 107)}
A reentrancy weakness occurs when a contract calls another one without updating its internal state beforehand.
If the callee calls the caller back, the latter may be in an inconsistent state.

\ITEM{Assert Violation (SWC 110)}
Assertions are sanity checks that are meant to hold for every run.
An assert violation means that such a check can be made to fail for certain inputs, which can lead to unexpected termination and loss of funds.

\ITEM{Delegatecall to Untrusted Callee (SWC 112)}
Code invoked by a \OP{DELEGATECALL} instruction operates on the caller's storage and funds.
This weakness means that an attacker is able to manipulate the caller's state by controlling the code that is invoked.

\ITEM{DoS with Failed Call (SWC 113)}
A failing call to an external contract may prevent subsequent actions from taking place.
A buggy or malicious callee may cause a DoS with the caller.

\ITEM{Transaction Order Dependence (SWC 114)}
This weakness arises when a contract's behavior depends on the order in which transactions are mined, leading to inconsistencies and potential security issues.

\ITEM{Authorization through tx.origin (SWC 115)}
This weakness means that a contract relies on tx.origin for authorization, which can be exploited by a man-in-the-middle attack to bypass access controls.

\ITEM{Block Values as a Proxy for Time (SWC 116)}
This weakness results from using block-related values as a substitute for precise timing, as these values can be manipulated by attackers.

\ITEM{Weak Sources of Randomness from Chain Attributes (SWC 120)}
Seeding random number generators with chain attributes leads to weak randomness, as these attributes can be predicted or even manipulated by attackers.

\ITEM{Write to Arbitrary Storage Location (SWC 124)}
This weakness occurs when an attacker is able to write to an unintended storage location, e.g.\ by overflowing one data structure into the next in storage.

\ITEM{Arbitrary Jump with Function Type Variable (SWC 127)}
Solidity supports function types.
By low level manipulations of variables that hold a function, control can be handed over to code other than the function, leading to unintended execution paths.

\ITEM{DoS With Block Gas Limit (SWC 128)}
The resource consumption of every call to a contract is limited by the gas supplied.
But this gas limit is capped itself by the block gas limit.
Once the call to a contract requires more gas than that, e.g.\ because of looping over a data structure that has been grown too big by an attacker, the contract may become inoperable.

\ITEM{Ether Lock}
This weakness means that a contract accepts Ether without offering the functionality to withdraw it, thus locking any funds sent to it.
    
\ITEM{Callstack Depth Bug}
Originally, the number of nested calls was limited to 1024.
Calling a contract at this limit would make any further nested calls fail unexpectedly, leading to a potentially harmful situation for the called contract.
As early as block 2.463\,M, this limit was replaced by a better mechanism that made the weakness related to the callstack depth limit obsolete.


\subsection{Mapping of Tool Findings}\label{sec:mapping}

\ITEM{Taxonomy.}
To compare the tools regarding their ability to detect weaknesses, we need a taxonomy with an adequate granularity.
Since there is no established taxonomy of weaknesses for smart contracts, previous studies~\citep{Chen2020survey, Tang2021, Wang2021survey, Kushwaha2022vuls, Rameder2022, tolmach2022survey, Zhou2022state} not only summarize potential issues, but also structure them with respect to their own taxonomies, none of which is compelling or widely used.

Among the community projects, there are two popular taxonomies: the DASP (Decentralized Application Security Project) TOP 10~\footnote{https://dasp.co} from 2018, which features 10 categories, and the SWC registry (Smart Contract Weakness Classification and Test Cases)~\footnote{https://swcregistry.io} with 37 classes, last updated 2020.
As for DASP, two categories, \textit{Access Control~(2)} and \textit{Other~(10)}, are quite broad, while \textit{Short Address~(9)} is checked by hardly any tool.
Moreover, \textit{DOS~(5)} and \textit{Bad Randomness~(6)} are effects that may be the result of various causes, and most tools detect causes rather than consequences.

The SWC registry is more granular as it offers several classes for the broad categories \textit{Access Control} and \textit{DOS}.
Moreover, most of its categories match relevant findings of the tools.
Therefore, we select this taxonomy as the basis of our comparison.


\input{table\_vulnerabilities}

\ITEM{Findings mapped.}
The tools report \np{82} different findings, of which we can map \np{56} to one of the 37 classes of the SWC taxonomy (see  \autoref{tab:mapping} in the appendix).
In total, the tools cover \np{15} SWC classes.
\autoref{tab:vuls} lists the weakness classes, the accumulated number of findings that the tools report, and the number of tools that address the weakness.
\autoref{tab:tool_vuls} gives an overview of the coverage of the SWC classes by tool.

\input{table_tool_vuls}

When a tool reports a finding, we assume that it is not invalidated by an accompanying error condition, a low coverage of the bytecode, or a timeout.
However, we note errors, timeouts, and unhandled conditions (fails).

\ITEM{Findings omitted.}
In order not to count the same weakness twice, we exclude redundant and intermediate findings.
Moreover, some findings state the absence of a weakness and thus should not be counted as a weakness.
Altogether, we exclude seven findings:
For eThor the positive finding \emph{secure} (from reentrancy);
for Maian the intermediate finding \emph{accepts\_Ether} and the positive findings \emph{no\_Ether\_leak}, \emph{no\_Ether\_lock}, \emph{not\_destructible};
for Osiris the redundant finding \emph{arithmetic\_bug} (as it is doubled by a more specific one); 
and for Vandal the preliminary finding \emph{checked\_call\_state\_update}. 

