\section{Lower Bounds for PD Approximate Counting via Shift Finding}\label{sec:reductionish_Shift_counting}


In this section, we prove \Cref{thm:connection_Shift_Counting}.
The proof involves three problems from different settings:
(a) PD approximate counting in the streaming model;
(b) Shift Finding in the query-access model; and
(c) MESSAGE in one-way communication with shared randomness.
The proof essentially shows that if there is an algorithm for Shift Finding that makes only $q$ queries and also a streaming algorithm for PD approximate counting that uses $b$ bits of space,
then MESSAGE can be solved using $O(b\log q)$ bits of communication.
Combining this bound with the well-known lower bound for MESSAGE in \Cref{lem:comm_problem_message} yields a lower bound for $b$.

A core idea in the proof is that an execution of a PD streaming algorithm $A$ for the approximate counting problem $\prac$
on a stream with $s^*$ insertions, can be used (even without knowing $s^*$,
by making additional insertions and then querying the streaming algorithm $A$) 
to provide query access to the shifted function $F_{s^*}: x\mapsto F(s^*+x)$.
This query access, along with a query-efficient algorithm for the Shift Finding problem $\prsf$, is then used to solve an instance of the MESSAGE problem $\prmsg$.


In fact, we prove the following theorem,
which holds for each string $F$ separately
(rather than a bound that depends on the worst-case $F$),
and yields \Cref{thm:connection_Shift_Counting} as an immediate corollary.


\begin{theorem}\label{thm:single_F_connection_shiftFind}
Let $A$ be a PD streaming algorithm for problem $\prac$, where $c,n>1$, 
and let $F:[0,(c+1)n]\to\set{0,1}$ be the canonical function of $A$. 
%
Suppose that Shift Finding with respect to this specific $F$ 
(the problem of finding an unknown shift $s^*\in[n]$
with probability at least $9/10$ given query access to $F_{s^*}$)
admits a randomized algorithm that makes
at most $q=q(F)$ (possibly adaptive) queries. 
%
Then the streaming algorithm $A$ must use
$\Omega(\tfrac{\log n}{\log q})$ bits of space.
\end{theorem}



\begin{proof} 
Define algorithm $A'$ to be an amplification of $A$
to success probability $1-1/(10q)$,
by running $O(\log q)$ independent repetitions and reporting their majority. 
Assume there exists an algorithm $Q$ that for every $s^*\in[n]$,
makes at most $q=q(F)$ queries to $F_{s^*}$ (possibly adaptive)
and outputs $s^*$ with probability at least $9/10$.

Consider an instance of problem $\prmsg$ with alphabet $\Sigma = [0,n]$,
and consider the following protocol for it.
Alice starts an execution of the streaming algorithm $A'$ using the shared randomness, 
then takes her input $s^*\in \Sigma$ and makes $s^*$ stream insertions to algorithm $A'$, 
and finally sends the state (memory contents) of $A'$ to Bob.

Bob continues the execution of the streaming algorithm $A'$ (using the shared randomness),
and uses it to provide query access to $F_{s^*}$, as follows.
In order to query $F_{s^*}$ at any index $x$,
Bob makes a fresh copy $A_0$ of the streaming algorithm $A'$,
insert $x$ stream items to algorithm $A_0$ and then reads its output.
With probability at least $1-1/(10q)$, 
the answer that Bob gets is indeed $F_{s^*}(x)$ (because the number of items inserted to this instance of the algorithm is $x+s^*$).
Bob uses this query access and his knowledge of $F$
to simulate algorithm $Q$ 
(with the goal of recovering $s^*$).


Consider Bob's simulation of algorithm $Q$. 
If $Q$ was executed with true query access to $F_{s^*}$,
then it would have had success probability $9/10$,
and would have made a sequence of queries $X_Q$ to $F_{s^*}$. 
This sequence $X_Q$ depends only on $F_{s^*}$ and the coin tosses of algorithm $Q$.
In particular, revealing $X_Q$ (i.e., conditioned on $X_Q$) 
does not affect the coins of the streaming algorithm $A'$,
and it still succeeds with probability at least $1-1/(10q)$. 
We can thus apply a union bound to conclude that
algorithm $A'$ succeeds on all queries $x\in X_Q$
(i.e., outputs the corresponding $F_{s^*}(x)$)
with probability at least $1-q\cdot\tfrac{1}{10q}=9/10$. 
Hence, when Bob simulates algorithm $Q$ using the streaming algorithm $A'$,
with probability $9/10$ (over the coins of $A'$)
the execution is identical to running algorithm $Q$ with true access to $F_{s^*}$,
which itself succeeds with probability $9/10$. 
By a union bound, with probability $8/10$ both algorithm $Q$ and the streaming algorithm $A'$ succeed, in which case Bob recovers $s^*$,
and therefore this communication protocol solves problem $\prmsg$ with alphabet $\Sigma = [0,n]$.


By Lemma~\ref{lem:comm_problem_message}, the message Alice sends must contain $\Omega(\log n)$ bits, and thus the streaming algorithm $A'$ must use $\Omega(\log n)$ bits of space.
Recall that algorithm $A'$ consists of $O(\log q)$ copies of the streaming algorithm $A$ and thus algorithm $A$ must use $\Omega(\tfrac{\log n}{\log q})$ bits of space.
\end{proof}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
