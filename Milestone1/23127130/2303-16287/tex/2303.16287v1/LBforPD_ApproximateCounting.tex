\section{Lower Bound for PD Approximate Counting}\label{sec:LB_PD_counting}

In this section, we prove Theorem~\ref{thm:LB_PD_counting}, i.e., for every $c,n>1$, we prove that every PD streaming algorithm for the approximate counting problem $\prac$ must use $\Omega_c(\sqrt{\tfrac{\log n}{\loglog n}})$ bits of space.

Let $F$ be the canonical function of a PD streaming algorithm for problem $\prac$.
% let $A$ be a PD streaming algorithm for the approximate counting problem $\prac$, and let $F$ be the corresponding canonical function.
Our analysis is split into two cases depending on $F$,
which informally correspond to whether a fixed pattern (like ``01'')
appears in the string $F$ at most $t$ times or not. 
These cases are analyzed using  \Cref{thm:generalized_connection_Shift_Counting,thm:single_F_connection_shiftFind}.
The overall bound will be derived by optimizing the threshold $t$
between the two cases to roughly $t=n/2^{\sqrt{\log n}}$.





\subsection{Scenario One}
In this scenario, there is a specific pattern in $F$
that appears at most $t$ times, where $t=t_c(n)$ will be set at the end of our proof.
We first consider the pattern "01" in $F$,
which corresponds to $x\in [0,(c+1)n-1]$ such that $F(x)=0$ and $F(x+1)=1$, and later generalize this pattern to a broader family.


\begin{lemma}\label{cl:hardness_few_01}
If the pattern "01" appears at most $t$ times in $F$, 
then every PD streaming algorithm for problem $\prac$ whose canonical function is $F$
must use $\Omega(\tfrac{\log (n/t)}{\loglog (cn)})$ bits of space.
\end{lemma}



% The proof of \Cref{cl:hardness_few_01} is by a reduction.. \ssnote{moved to \Cref{sec:reductionish_Shift_counting}.}


\begin{proof}%[Proof of \Cref{cl:hardness_few_01}]
The proof is by a reduction from problem MESSAGE, similarly to the proof of \Cref{thm:single_F_connection_shiftFind}.
Perhaps the most delicate part is the definition of an alphabet $\Sigma$ for the MESSAGE problem $\prmsg$, and it proceeds as follows.


% The construction 
% We shall first define a mapping $M:[n]\to [cn]$. 
Given $s\in[n]$, consider the following execution of Binary Search (B.S.)
on the function $F_s$. 
Initialize $l=0$ and $r=cn+1$,
and at every iteration query $F_{s}(\floor{\tfrac{l+r}{2}})$;
if $F_{s}(\floor{\tfrac{l+r}{2}})=0$,
then $l\gets\floor{\tfrac{l+r}{2}}$, otherwise $r\gets\floor{\tfrac{l+r}{2}}$.
These iterations maintain the invariant that $F_s(l)=0$ and $F_s(r)=1$,
and after at most $\log (cn)$ iterations arrive at $r=l+1$ with the pattern "01".
Define a mapping $M:[n]\to [cn]$ such that $M(s)$ is the location where the binary search finds a "01" in $F_s$, i.e., the final index $l$; thus $F(s+M(s))=0$ and $F(s+M(s)+1)=1$.


In order to define an alphabet $\Sigma$,
consider a partitioning of $[n]$ to buckets, defined
such that items $s,s'$ are from the same bucket $B$ if and only if they are mapped to the same value $M(s)=M(s')$.
For every bucket $B$ and every $s,s'\in B$,
we know from above that $F(s'+M(s))=0$ and $F(s'+M(s)+1)=1$,
so there are at most $t$ possibilities for $s'$ (one of which is $s'=s$), and thus the size of the bucket $|B|\leq t$.
Define $\Sigma\subset [n]$ by taking one representative from each bucket.
Thus, every $s_1\neq s_2\in \Sigma$ satisfy $M(s_1)\neq M(s_2)$ and
 $|\Sigma|\geq n/t$.



Let $A$ be a streaming algorithm whose canonical function is $F$ and let algorithm $A'$ be an amplification of algorithm $A$ that succeeds with probability $1-1/(10\log (cn))$ (by making $O(\loglog (cn))$ repetitions and taking the majority).
Consider an instance of the MESSAGE problem $\prmsg$,
and proceed similarly to the proof of \Cref{thm:single_F_connection_shiftFind}.
We provide a self-contained analysis for completeness.
Alice and Bob perform the following protocol.
Alice starts an execution of algorithm $A'$ using the shared randomness.
For input $s^*\in \Sigma$, she inserts $s^*$ stream items to algorithm $A'$ and sends the state (memory contents) of this algorithm $A'$ to Bob.
In order to get query access to $F_{s^*}$ at index $x$, 
Bob makes a fresh copy $A_0$ of algorithm $A'$, continues the algorithm's execution (using the shared randomness),
inserts $x$ stream items to algorithm $A_0$ and finally reads its output.
Bob uses this query access to simulate the B.S. algorithm on $F_{s^*}$ (with the goal of recovering $M(s^*)$).
He then infers which bucket corresponds to his result, and outputs the representative of that bucket (which is $s^*$ if he recovers $M(s^*)$).



If the B.S. algorithm were executed with true query access to $F_{s^*}$, then it would have output $M(s^*)$ and would have made a sequence of queries $X_{BS}$ to $F_{s^*}$.
This sequence depends only on $F_{s^*}$, and in particular
independent of the random coins of algorithm $A'$.
Thus by a union bound, algorithm $A'$ succeeds on all queries $x\in X_{BS}$ (i.e. outputs the corresponding $F_{s^*}(x)$) with probability at least $1-\log (cn)\cdot 1/(10\log (cn))=9/10$.
Hence, when Bob simulates the B.S. algorithm using the streaming algorithm $A'$, then with probability $9/10$ the execution is identical to running the B.S. algorithm with true query access to $F_{s^*}$.
Thus with this probability $9/10$, Bob recovers $M(s^*)$, and hence outputs $s^*$, which concludes the correctness analysis of the communication protocol.

    
    
     By Lemma~\ref{lem:comm_problem_message}, the message Alice sends must contain $\Omega(\log|\Sigma|)\geq \Omega(\log (n/t))$ bits, and thus algorithm $A'$ must use $\Omega(\log (n/t))$ bits of space.
    Recall that algorithm $A'$ is made of $O(\loglog (cn))$ copies of algorithm $A$ and thus algorithm $A$ must use $\Omega(\tfrac{\log (n/t)}{\loglog (cn)})$ bits of space.
\end{proof}

\begin{remark}
This proof can be easily generalized to prove \Cref{thm:generalized_connection_Shift_Counting}.
The first extension is
by replacing the B.S. algorithm and the corresponding buckets with any deterministic algorithm $Q$ that returns a subset containing $s^*$.
In order to generalize $Q$ to any PD algorithm $Y$,
consider the canonical function of $Y$ instead of the mapping $M$, and apply the same proof.
It holds because the crucial property of the B.S. algorithm was the existence of the mapping $M$.
Then by an additional union bound, both algorithms $Q$ and $A'$ succeed with probability $8/10$ (as in the proof of \Cref{thm:single_F_connection_shiftFind}).
\end{remark}


We now generalize \Cref{cl:hardness_few_01} to a larger family of patterns in $F$, where each pattern
is characterized by a parameter $k\in [n]$, and appears at index $x\in [0,(c+1)n-k]$ such that $F(x)=0$ and $F(x+k)=1$.
Denote such a pattern by "$0?^{k-1}1$", 
where each question mark can represent either $0$ or $1$,
and the number of question marks is $k-1<n$.
A copy of this pattern can be found in $O(\log \tfrac{n}{k})$ queries to $F_{s^*}$ by a binary search on the grid $(0,k,...,\ceil{\tfrac{cn}{k}}k)$, since $F_{s^*}(0)=0$ and $F_{s^*}(\ceil{\tfrac{cn}{k}}k)=1$.
Hence, if there exists $k$ for which this pattern appears at most $t$ times in $F$, then the communication protocol above can be adjusted to imply that algorithm $A$ must use at least $\Omega(\tfrac{\log (n/t)}{\loglog (cn/k)})\geq \Omega(\tfrac{\log (n/t)}{\loglog (cn)})$ bits of space.
The only change in the proof is in the number of queries that Bob makes,
which affects the number of repetitions in algorithm $A'$,
and thus only affects the $\loglog$ term.


\begin{corollary}\label{cor:scenario_1}
    If for some $k\leq n$ the pattern "$0?^{k-1}1$" appears at most $t$ times in $F$, then every PD streaming algorithm for problem $\prac$ whose canonical function is $F$, must use $\Omega(\tfrac{\log (n/t)}{\loglog (cn)})$ bits of space.

\end{corollary}


\subsection{Scenario Two}

In this scenario, for every $k\leq n$ the pattern "$0?^{k-1}1$" appears at least $t$ times in $F$.

\begin{lemma}\label{lem:scenario_2}
    If for all $k\in [n]$, the pattern "$0?^{k-1}1$"  appear at least $t$ times in $F$, then every PD streaming algorithm for problem $\prac$ whose canonical function is $F$, must use $\Omega(\tfrac{\log n}{\log(cn/t)+\loglog n})$ bits of space.
\end{lemma}


\begin{proof}
In this case, there is an algorithm for the Shift Finding problem $\prsf$ using $q=O(\tfrac{cn\log n}{t})$ queries to $F_{s^*}$, as follows.


\begin{enumerate}
\item let $S=[0,n]$
\item repeat the following $\tfrac{10cn\log n}{t}$ times:
  \begin{enumerate}
  \item pick $r\in[cn]$ uniformly at random and query $F_{s^*}(r)$
  \item let $S\gets \{s\in S:\ F(s+r)= F_{s^*}(r) \}$
  \end{enumerate}
\item if $|S|=1$, return $s\in S$; else return FAIL
\end{enumerate}
% \rnote{in pseudocode, do not use capital letters and period. }
% \ssnote{Done. Is the if-else statement ok?}
% \ssnote{Use the same format as in \Cref{alg:sqrt_n_shift_finding}? Not sure. The alg here is not particularly important, only matters as part of the proof.}


The final set $S$ clearly contains the shift $s^*$.
It remains to show that all $s\neq s^*$ are removed from the set $S$ with high probability.

Fix $s\in [n], s\neq s^*$. 
There are $t$ values for $r\in[cn]$ for which $F(s^*+r)\neq F(s+r)$, as follows.
Assume without loss of generality that $s^*<s$ and denote $k = s-s^*\in [n]$.
Let $l$ be a location that corresponds to the pattern "$0?^{k-1}1$" in $F$, i.e. $F(l)=0$ and $F(l+k)=1$.
If $l\in [s^*+1,s^*+cn]$, then there is $r\in[cn]$ such that $s^*+r=l$, for which $F(s^*+r)=0\neq F(l+k) = F(s+r)$.
There are at least $t$ locations for this pattern (i.e. possible values for $l$), thus it remains to show that indeed $l\in [s^*+1,s^*+cn]$.
It must be that $l+k> n$ since $F(x)=0$ for all $x\leq n$, and similarly $l\leq cn$ since $F(x)=1$ for all $x> cn$.
Hence $l\in [n-k+1,cn]\subset [s^*+1,s^*+cn]$,
and thus there are $t$ values for $r\in[cn]$ for which $F(s^*+r)\neq F(s+r)$ (each value for $r$ corresponds to a possible value for $l$).



Thus, in each repetition, $s$ is removed from the set $S$ with probability at least $\tfrac{t}{cn}$.
The probability $s$ is not removed after $\tfrac{10cn\log n}{t}$ repetitions
is $(1-\tfrac{t}{cn})^{(10cn\log n)/t}<\tfrac{1}{n^2}$.
By a union bound, all $s\neq s^*$ are removed with probability $1-\tfrac{1}{n}$,
which concludes the correctness analysis of the algorithm for problem $\prsf$.

By \Cref{thm:single_F_connection_shiftFind}, every PD streaming algorithm for the approximate counting problem $\prac$ with a canonical function $F$ 
must use $\Omega(\tfrac{\log n}{\log((cn\log n)/t)})$ bits of space.

\end{proof}


\subsection{Concluding the Proof of Theorem~\ref{thm:LB_PD_counting}}

Concluding the two scenarios, set $t=n/2^{\sqrt{\log n \cdot \log\log (cn)}}$ and get by Corollary~\ref{cor:scenario_1} and Lemma~\ref{lem:scenario_2} that every PD streaming algorithm for the approximate counting problem $\prac$ must use
\[
\Omega(\min\{\tfrac{\log (n/t)}{\loglog (cn)}, \tfrac{\log n}{\log ((cn/t)\log n)}\})
= \Omega(\tfrac{\log n}{\sqrt{\log n\loglog (cn)} + \log c})
\]
bits of space, which boils down to $\Omega(\sqrt{\tfrac{\log n}{\loglog n}})$ for $c<2^{\sqrt{\log n \loglog n}}$.






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:


