\section{Analysis}\label{sec:analysis}

Since execution and emulation of the Xtensa instruction set is demonstrated through successfully running the flash binary via QEMU, the primary focus of the analysis is networking.  Emulating the Xtensa is a core feature of the Tiny Code Generator within QEMU.  However, networking does have different possible code paths and configurations as well as a requirement to interface with the host network stack.  Network emulation in QEMU \cite{qemu_net} can take 2 forms: TAP and user mode network stack.  The former adds a virtual network device on the host (called tapN) and can then be configured as a real ethernet card.  The latter was used in this project and will now be described.

As shown in Section \ref{sub:emulate_app}, the networking interface was configured via launching QEMU with the 
\begin{quote}\textbf{-nic user,model=open\_eth,id=lo0,hostfwd=tcp::8000-:80}\end{quote} options.  
These options configure the user mode network stack without root privileges.  Figure \ref{fig:user_mode_stack} shows the resulting virtual network configuration. The QEMU Virtual Machine (VM) behaves as if it was behind a firewall which blocks all incoming connections.  The DHCP server assigns addresses to the guests starting from 10.0.2.15.

\begin{figure}[H]
    \centerline{\includegraphics[width=1.0\linewidth, keepaspectratio]{user_mode_stack.png}}
    \captionsetup{width=.8\linewidth}
    \caption{The virtual network configuration created by the user mode network stack options.}\label{fig:user_mode_stack}   
\end{figure}

In order for the host to access the IP ports listening on the guest OS, port forwarding must be configured.  The \textbf{hostfwd=tcp::8000-:80} takes care of this by forwarding the guest OS port 80 (our HTTP server) to the host port 8000.  The forwarding is not specific to any one of the host's network interfaces. For instance, both \textbf{lo0} and \textbf{en0} on the host are listening on port 8000.

From Section \ref{sub:emulate_app}, we stated that the ESP32 load was built with support for the OpenCores Ethernet MAC driver \cite{eth_mac}.  This driver, implemented in QEMU, provides the Media Access Control (MAC) layer in the emulator allowing the guest OS to transmit and receive ethernet frames which are subsequently forwarded to the host MAC.  In the QEMU project, \textbf{opencores\_eth.c} implements a set of functions providing the emulated MAC layer interface.  The relevant functions used in transmitting and receiving ethernet frames to the guest OS are:

\begin{itemize}
    \item open\_eth\_desc\_write()
    \item open\_eth\_desc\_read()
    \item open\_eth\_reg\_read()
    \item open\_eth\_reg\_write()
    \item open\_eth\_mii\_read()
    \item open\_eth\_mii\_write()
    \item open\_eth\_start\_xmit()
    \item open\_eth\_receive()
    \item open\_eth\_receive\_desc()
    \item open\_eth\_receive\_mcast()
    \item open\_eth\_update\_irq()
\end{itemize}

\subsection{GDB debugging}\label{sub:gdb}
It is possible to start the QEMU session listening on a debug port.  The ``-s'' option allows this.  Thus, the new launch command on native macOS:

\begin{lstlisting}
    qemu-system-xtensa -nographic -machine esp32 \ 
        -nic user,model=open_eth,
            id=lo0,hostfwd=tcp::8000-:80 \
        -drive file=merged_qemu.bin,
            if=mtd,format=raw \ 
        -s
\end{lstlisting}

Now, we can connect and debug the guest OS and application with: 
\begin{lstlisting}
    xtensa-esp32-elf-gdb esp_http_server.elf \
        -ex "target remote :1234" \
        -ex "monitor system_reset" \
        -ex "tb app_main" -ex "c"
\end{lstlisting}
This GDB session will provide an interactive prompt and will temporarily break at the application entry point.  The FreeRTOS kernel, drivers and HTTP server application is in scope with this debug session.  The \textbf{xtensa-esp32-elf-gdb} is a ESP32-specific build of GDB that is provided through the ESP-IDF SDK.

In theory, GDB stepping through the ESP32 binary will not show anything unique in the emulated session since the guest OS implements a network stack and simply binds to the MAC address at the lower layer.  A more relevant option is to follow the networking code path in the QEMU emulator, specifically the OpenCores Ethernet MAC driver.  Unfortunately, a binary with symbols file (i.e. .elf) is not generated during a custom build which prevents productive GDB stepping through the \textbf{opencores\_eth.c} driver.  This is the entity that provides networking emulation in our experiments.  Also, due to the high transaction rate and asynchronous nature of the network stack operation, GDB stepping will not provide the best analysis of the emulated code path.  A better option is to explore function tracing.

\subsection{QEMU function tracing}\label{sub:tracing}
QEMU provides a function tracing framework which can be enabled at runtime \cite{tracing}. The \begin{quote}\textbf{--trace "open\_eth*"}\end{quote} option will enable tracing on all \textbf{opencores\_eth.c} driver functions.  Thus, we launch QEMU with the following options:

\begin{lstlisting}
    qemu-system-xtensa -nographic -machine esp32 \ 
        -nic user,model=open_eth,
            id=lo0,hostfwd=tcp::8000-:80 \
        -drive file=merged_qemu.bin,
            if=mtd,format=raw \ 
        --trace "open_eth*"
\end{lstlisting}

The new option results in tracing messages for all functions prefixed with ``open\_eth''.  These messages print to stderr.  Log options are also available.  The trace framework is realized by a ``trace()'' function call in each of the subsystem API functions.  The trace function calls outside open\_eth generate a nop such that there is no performance penalty or extraneous messages.

The full stderr trace is too much data to display here.  Listing \ref{lst:trace} is an abbreviation with many in-between open\_eth messages removed.

\lstinputlisting[basicstyle=\tiny, numbers=left, label=lst:trace,
  caption={Standard console messages along with trace of open\_eth calls.}]
  {trace.log}

All lines with the ``open\_eth'' prefix represent functions calls to the OpenCores Ethernet MAC driver.  Lines 1-35 show the ESP32 load initializing the network stack through a sequence of calls to discover the underlying ethernet interface.  The OpenCores driver services these requests and passes through to the host, eventually responding back to the guest OS.  Reads and writes to the MAC register are handled via the driver, followed by data transmit (line 20), receive (line 21) and interrupt masking (line 23).

The next steps in lines 36-49 show the binding of the IP stack to the ethernet interface.  Again, the ethernet interface is serviced by the OpenCores driver utilizing the same open\_eth functions calls to read, write the MAC register and transmit data frames.

Lines 50-56 show the application HTTP server starting and binding port 80 with the IP stack.  As IP packet headers are stripped and forwarded to the MAC layer, the OpenCores driver services these requests and passes to the host.  The same API is used with function calls to read the MAC register (line 52) and write the MAC (line 53),

The final set is after we hit the host port 8000 with an HTTP request.  These are shown lines 57-73.  The host command

\begin{lstlisting}
    curl http://localhost:8000/hello
\end{lstlisting}

sends an HTTP (IP) request to the guest.  When this is broken down into ethernet frames, we see the OpenCores driver receive the request data (line 58) and set the interrupt mask (line 60).  The HTTP server then sends its response.  The server itself writes a message on line 66 that it has responded to the request from localhost:8000.  The data payload contains ``Hello World!'' and its transmit is handled by OpenCores on line 69.

For a graphical representation of the above analysis, see Figure \ref{fig:emulation_layers}.

\begin{figure}[h]
    \centerline{\includegraphics[width=1.0\linewidth, keepaspectratio]{emulation_layers.png}}
    \captionsetup{width=.8\linewidth}
    \caption{Components of the guest OS and the network data flow to the host. The Tiny Code Generator (TCG) emulates the Xtensa-native instructions while the OpenCores Ethernet MAC driver forwards ethernet traffic to the host MAC.}\label{fig:emulation_layers}   
\end{figure}
\newpage