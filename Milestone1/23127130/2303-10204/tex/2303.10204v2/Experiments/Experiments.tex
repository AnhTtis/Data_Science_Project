\section{Experiments}\label{sec:experiments}

The objective of the experiments is to build the ESP32 application, build QEMU, emulate the application via QEMU and containerize both application and QEMU.  Once the setup steps are complete, an HTTP interaction with the application is performed to test and analyze the emulation.

\subsection{Build the ESP32 application}\label{sub:build_app}
The first step is to download and configure the SDK to build the target application.  ESP-IDF is cloned from GitHub \cite{esp_git} and an installation script ensures the necessary binaries and scripts are in the host execution path.  Multiple passes were performed.  However, the final pass took advantage of the VSCode extension which wrapped the underlying clone and install operations.  All build, merge, flash and monitor commands were subsequently run via the \emph{Espressif IDF} extension in VSCode.

After cloning and installing ESP-IDF, the template project selector was used to create a new project based on the simple HTTP server template.  The first pass enabled Wi-Fi through the \begin{quote}CONFIG\_EXAMPLE\_CONNECT\_WIFI=y\end{quote} project configuration.  This repo may be publicly viewed at \url{https://github.com/zemar/esp\_http\_server}.  The application was built, merged into a flash image and flashed to the USB-connected ESP32 target board.  The monitor command then prints all stdout messages from the USB port.

\subsection{Natively run the ESP32 application}\label{sub:native_run}
After loading and monitoring the target board, an HTTP message request was sent from the host.  The correct response message contains ``Hello World!''.  The stdout of the target board is also displayed.  See Figure \ref{fig:target_response} for the actual results.

\begin{figure}[H]
    \centerline{\includegraphics[width=1.0\linewidth, keepaspectratio]{target_response.png}}
    \captionsetup{width=.8\linewidth}
    \caption{Screenshot of host sending a ``/hello'' request with the corresponding ``Hello World!'' response.  Stdout of the ESP32 USB port is also displayed showing the internal handling of the message.}\label{fig:target_response}   
\end{figure}

\subsection{Emulating the ESP32 application}\label{sub:emulate_app}
Since the QEMU fork for ESP32 does not maintain pre-built binaries for macOS, the first step is to clone and build the emulator.  The following steps are used to accomplish this:  

\begin{lstlisting}
    git clone https://github.com/espressif/qemu
    brew install libgcrypt
    ./configure --target-list=xtensa-softmmu \
        --enable-gcrypt --enable-debug \ 
        --enable-sanitizers \
        --disable-strip --disable-user \ 
        --disable-capstone --disable-vnc \
        --disable-sdl --disable-gtk
    ninja -C build
\end{lstlisting}

Note that the target is specified as ``xtensa-softmmu'', thus forcing pure software emulation without requiring Apple's hypervisor library.  
The resulting binary is \textbf{qemu-system-xtensa}.  
However, the ESP32 application is configured for Wi-Fi and there is no pass-through to connect the application network stack to the host Wi-Fi device.  
The solution is to build the ESP32 with an experimental OpenCores Ethernet MAC driver \cite{eth_mac} which provides the \emph{open\_eth} device for configuring the network interface.  This driver is able to pass networking transactions through to the host ethernet interface.  It is configured by setting project options: \begin{quote}CONFIG\_EXAMPLE\_CONNECT\_ETHERNET=y\end{quote} and \begin{quote}CONFIG\_EXAMPLE\_USE\_OPENETH=y\end{quote} and rebuilding.

Our custom QEMU now runs (with emulation) the ESP32 flash image using the command:
\begin{lstlisting}
    qemu-system-xtensa -nographic -machine esp32 \ 
        -nic user,model=open_eth,
            id=lo0,hostfwd=tcp::8000-:80 \
        -drive file=merged_qemu.bin,
            if=mtd,format=raw
\end{lstlisting}

Running the above command on our host results in a successful emulation run as shown in Figure \ref{fig:qemu_response}.
\begin{figure}[H]
    \centerline{\includegraphics[width=1.0\linewidth, keepaspectratio]{qemu_response.png}}
    \captionsetup{width=.8\linewidth}
    \caption{Screenshot of host sending a ``/hello'' request with the corresponding ``Hello World!'' response.  Stdout of the QEMU process is also displayed showing the internal handling of the message.}\label{fig:qemu_response}   
\end{figure}
The HTTP server is able to bind to 10.0.2.15 on the ``example\_netif\_eth'' interface and the QEMU TCP forwarding allows port 80 in the guest OS to be forwarded to 8000 on the host.  Our HTTP request to port 8000 is then successfully processed with the correct returned response.

\subsection{Containerizing the emulated application}\label{sub:containerize_app}
Building the container image described in Figure \ref{fig:container_image} is straight forward using the Docker engine client and the following command:
\begin{lstlisting}
    docker build -t esp\_qemu .
\end{lstlisting}

With the image built and locally stored, it is run taking the QEMU application command as an argument.  This will run immediately upon launching the container.  Note that the ESP32 flash image, \textbf{merged\_qemu.bin} needs to be present in the container at run time.  A volume mount of the build directory accomplishes this.

The command to run for the experiment:
\begin{lstlisting}
    docker run -it --name esp --rm -p 8000:8000 \ 
        -v $(pwd)/build:/app \
        esp-qemu:latest qemu-system-xtensa \
        -nographic -machine esp32 \ 
        -nic user,model=open\_eth,
            id=lo0,hostfwd=tcp::8000-:80 \
        -drive file=merged\_qemu.bin,
            if=mtd,format=raw
\end{lstlisting}

The above runs the container locally, maps (mounts) the local folder to the container and publishes port 8000 inside the container to the host.  The internal version (inside the container) of the QEMU binary is used to run the mapped \textbf{merged\_qemu.bin}.  As shown in Figure \ref{fig:container_response}, an identical response and set of QEMU messages is generated when virtualized in a container compared to running the emulator natively in macOS.

\begin{figure}[H]
    \centerline{\includegraphics[width=1.0\linewidth, keepaspectratio]{container_response.png}}
    \captionsetup{width=.8\linewidth}
    \caption{Screenshot of host sending a ``/hello'' request with the corresponding ``Hello World!'' response.  Stdout of the Docker container is also displayed showing the QEMU internal handling of the message.}\label{fig:container_response}   
\end{figure}