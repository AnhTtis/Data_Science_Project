
\section{Method}
\label{sec:METHOD}
\subsection{Overview}
We aim to reconstruct the surfaces $\mathcal{S}$ of a solid transparent object from a set of posed object masks and the correspondences between the camera view rays and locations on the background under each viewpoint.
We propose to adopt an implicit Signed Distance Function (SDF) as surface representation and leverage volume rendering~\cite{wang2021neus} to enforce the refraction-tracing consistency, which enables stable and robust optimization.
Moreover, we propose a simple but effective strategy to identify the rays passing through self-occluded parts and then exclude these rays during optimization to avoid mistakenly enforcing refraction-tracing consistency. 

\begin{figure}[t]
\centering
\begin{overpic}
% [width=1.0\linewidth]{figure/ICCV/figure_seting_and_correspondence.pdf}
[width=1.0\linewidth]{figure/ICCV/figure_setting1.pdf}
\put(11, 61.5){ \small(a) Capture setup}
\put(22, -1.5){\small(c) Ray-location correspondence}
\put(60,61.5){ \small (b) Captured image}
\end{overpic}
\caption{
(a) Our transparent object capture setup;
(b) a captured image of a real Bull object;
(c) and the ray-location correspondence. (See details in preliminaries)}

\label{fig:ray_location}
% \vspace{-5mm}
\end{figure}
	
	
\subsection{Preliminaries}
 
    \textbf{Object capture setup.}
    To reconstruct the transparent objects, we adopt the similar object capture system proposed in ~\cite{lyu2020differentiable,wu2018full}.
    The system consists of a static LCD monitor, a turntable, and a camera.
    The monitor displays horizontal and vertical stripe patterns that form a Gray-coded background, and is placed behind the object and the camera.
    The transparent object is placed on the turntable, which is rotated in data acquisition to provide the static camera with multiple views of the object. 
    The silhouette mask information and environment matte can be extracted from the patterns displayed on the monitor.
 \begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth,scale=1.00]{figure/ICCV/self-occlusion2.pdf}
    
    \caption{The diagram of a ray with self-occlusion $r_e$ and a ray without self-occlusion $r_p$. 
    The ray $r_p$ only refracts twice on the object surfaces, while the ray $r_e$ refracts on the surfaces more than twice due to self-occlusion.
    The rays with self-occlusion should be excluded in the optimization for high-quality reconstruction.
    }
    \label{fig:two_and_biger_two}
    % \vspace{-5mm}
\end{figure}
    
    \textbf{Refraction-tracing consistency.}
    For general objects, feature points of the input images are extracted to establish correspondences for 3D reconstruction.
    However, for transparent objects, it's difficult to extract reliable feature points to establish correspondences, so the prior works and ours leverage the environment matting technique to establish the relationship between object geometry and the observed images.
    As shown in Figure~\ref{fig:ray_location}, a ray $r$ shooting from the camera center passes through the transparent object, which refracts twice on the object surfaces and then hits on the monitor at point $Q$.
    Since the gray-coded patterns are known, we can calculate the exact location of $Q$, and therefore we obtain a pair of camera ray $r$ and hit location $Q$.
    Our method is based on optimizing the correspondences between camera rays and the locations, which can also be named refraction-tracing consistency. 
    
	
 \subsection{SDF-based refraction tracing}
    \textbf{Surface representation.}
    Unlike that the prior works adopt point clouds or meshes as geometry representations, we adopt Signed Distance Function (SDF) as surface representation.
    Specifically, the SDF field maps a point $x\in\mathbb{R}^3$ to its signed distance value to the surfaces, and the field is encoded by a Multi-layer Perceptrons (MLP) network. The surface $\mathcal{S}$ of the object is represented by the zero-set of the signed distance function (SDF), that is,\;$\mathcal{S} = \left\{ x \in  \mathbb{R}^3 | g(x) = 0\right\}$.
    The SDF field is initialized as a unit sphere. For convenience, we denote the shape being optimized as a virtual shape.

    
\textbf{Refraction-tracing.}
As shown in Figure~\ref{fig:ray_location}, given the current virtual shape, we first trace rays from the camera center that intersect and refract through the shape, and then optimize the SDF values of associated surface intersections according to the captured correspondences between the view rays and background locations (e.g., the ray $\overrightarrow{cq}$ and the location $Q$ in Figure~\ref{fig:ray_location}).
We take a ray that only refracts on the surfaces exactly twice as an example, the ray first enters the virtual shape at point $p_1^{\prime}$, and then it exits the shape at point $p_2^{\prime}$.
Finally, the simulated light path, shown in purple in Figure~\ref{fig:ray_location}, hits on the background monitor at a virtual location $Q^{\prime}$.
Before the optimization of geometry converges, $Q^{\prime}$ is generally different from the destination of the actual optical path passing through the real object, which is shown in orange, and finally hits on the background monitor at $Q$.
The goal of optimization is to minimize the differences between the virtual hitting location and real hitting location, that is, $\Delta=\left\|Q-Q^{\prime}\right\|^2$.

To trace how the simulated light path interacts with the virtual shape and then penalize the location differences in the optimization, we leverage the SDF-based volume rendering technique~\cite{wang2021neus} to calculate the exact locations of the two refraction intersections $p_1^{\prime}$ and $p_2^{\prime}$. The SDF-based surface rendering technique~\cite{yariv2020multiview} can also be used for the intersection calculation, as discussed in Section~\ref{surface_vs_Volume}, volume rendering yields more robust and stable optimization and leads to better reconstruction quality.

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth,scale=1.00]{figure/ICCV/self_occlusion_analysis.pdf}

\caption{A example of self-occlusion checking strategy applied on the real Horse object.}
\label{fig:self_occlusion_example}
% \vspace{-5mm}
\end{figure}

\subsection{Self-occlusion handling}
Since the objects to be reconstructed are solid, most camera rays will refract on the object surfaces exactly twice.
When a ray passes through self-occluded regions, the refractions will be more complex, and the ray may refract on the surfaces more than twice. 
As shown in Figure~\ref{fig:two_and_biger_two}, the light path without self-occlusion (blue line in Figure~\ref{fig:two_and_biger_two}) has two refracted intersections with object surfaces, while the light path with self-occlusion (green line) has four refracted intersections.
However, the prior works~\cite{lyu2020differentiable,wu2018full} ignore the self-occlusion problem and assume that all the camera rays only refract exactly twice. 
As a result, for the rays that refract more than twice, the simulated light paths will be mistakenly approximated, thus introducing wrong supervision information into the geometry optimization.

\textbf{Naive checking strategy.} To tackle this problem, the key is to identify whether a ray refracts more than twice, and then exclude the ray in the optimization.
A naive solution is to calculate the exact locations of the refraction intersections. As shown in Figure~\ref{fig:two_and_biger_two}, when a ray passes through the self-occluded parts, we can leverage Snell's law to obtain the directions of the refracted lights, and then calculate the locations of the intersections, $e_1, e_2, e_3, e_4$.
However, we have to extensively conduct iterative sampling and network queries to find the points sampled in the refracted lights which are in the surfaces, which significantly increases the computational costs.

\textbf{Proposed checking strategy.} 
We, therefore, propose a simple but effective strategy to identify the rays that refract more than twice at low costs.
The motivation is based on the {law of reversibility}, that is, \textit{If the direction of a light beam is reversed, it will follow the same path.}


As shown in Figure~\ref{fig:checking_strategy}, the procedure of the strategy is introduced below:

\begin{algorithm}

\caption{Self-occlusion checking strategy}
1) Shoot a ray $r_p$/$r_e$ emitting from the camera center, and get its first forward intersection $p_f$/$e_f$.

2) Leverage Snell's Law to obtain the refracted light line $\overrightarrow{p_f v_p}$/$\overrightarrow{e_f v_e}$, where $v_p$/$v_e$ is an infinite point on the line.

3) Shoot the reversed refracted light line $\overrightarrow{v_p p_f}$/$\overrightarrow{v_e e_f}$ from $v_p$/$v_e$, and then obtain the backward intersection $p_b$/$e_b$.

4) Sample points on the line segment $\overline{p_f p_b}$/$\overline{e_f e_b}$, and then evaluate the SDF values of the points.

5) If there exist points with positive SDF values, the ray refracts more than twice; if not, the ray refracts exactly twice.

\end{algorithm}

We can see the ray $r_p$ refracts the surfaces exactly twice, and there are no intersections on the line segment $\overline{p_f p_b}$, which indicates the light path $c \rightarrow p_f \rightarrow v_p$ is reversible.
On the other hand, for the ray $r_e$, there exist two more intersections on the line segment $\overline{e_f e_b}$, which indicates that the light path $c \rightarrow e_f \rightarrow v_e$ is not reversible with the twice refraction assumption.
Moreover, thanks to the properties of SDF (negative values inside and positive values outside), we can evaluate whether there exist any points with positive SDF values between the forward and backward intersections to identify the existence of self-occlusion.

Unlike that the naive checking strategy requires accurately finding the locations of all intersections, our proposed checking strategy only needs to identify whether there exist positive SDF values in a line segment with a short length.
We provide an example of the self-occlusion checking strategy applied on a real Horse object in Figure~\ref{fig:self_occlusion_example}, and our method can accurately identify the self-occluded regions (the overlapping legs of the horse). 
 
% {\color{red}After excluding the rays with self-occlusion ï¼Œthe rays are more efficient. In other batches, there exists rays passing through the self-occlusion area. Through excluding the rays with self-occluded, the quality of reconstruction can be further improved.}

% {\color{red}The rays that pass through the sub-occluded regions are excluded from the current batch.

% If the ray passes through the self-occlusion area, it does not participate in the calculation for refraction loss. Moreover, additional rays pass through the self-occlusion area. Therefore, by excluding the rays with self-occlusion in the optimization, the reconstruction quality can be further improved.}

% After excluding the rays with self-occlusion in the optimization, the quality of reconstruction can be further improved.


\begin{figure}[t]
\centering
\includegraphics[width=\linewidth,scale=1.00]{NeTO/figure/ICCV/self-occlusion1.pdf}

\caption{The illustration of self-occlusion checking strategy. 
For the ray $r_p$, there are no surfaces on the line segment $\overline{ p_f p_b}$, where all SDF values of the sampled points are negative.
For the ray $r_e$, there exist surfaces on the line segment $\overline{ e_f e_b}$, where the SDF values of some sampled points are positive.
}
\label{fig:checking_strategy}
% \vspace{-5mm}
\end{figure}


\begin{figure*}[tp]
\centering
\begin{overpic}
[width=1.0\linewidth]{figure/ICCV/res_9_.pdf}
\put(7,-1){\small Ours}
\put(27,-1){\small DRT\cite{lyu2020differentiable}}
\put(45,-1){\small Ground Truth}
\put(66,-1){\small Li~\etal\cite{li2020through}}
\put(86,-1){\small Li~\etal's GT}
\end{overpic}
\caption{Qualitative comparisons with $sparsity=8$ (9 views) on the Mouse and Monkey objects. Even with a limited set of images (9 images), Our method reconstructs faithful geometry with rich details.
However, DRT and Li~\etal\cite{li2020through} fail to reconstruct the geometries, the reconstructed models are over-smoothing, and the details are missing.
It should be noted that, due to different manufacturing batches, there are slight differences between the shapes used by Li~\etal and DRT, and therefore their results are compared to a different set of ground truth models.
}
\label{compare_with_four_views}
% \vspace{-3mm}
\end{figure*}

\subsection{Loss Functions}
We optimize the SDF field by sampling a batch of rays with their ray-location correspondences and object masks $\left\{Q, M\right\}$, where $Q$ is the observed location on the background monitor, and ${M}\in\left\{0, 1\right\}$ is mask value. 
We sample $n$ points on the ray, and the batch size is $m$. The loss function is defined as~$:$
\begin{equation}
\mathcal{L} = \omega_1\mathcal{L}_{Refraction} +  \omega_2\mathcal{L}_{Eikonal} + \omega_3\mathcal{L}_{Mask} 	
\end{equation}
	
\textbf{Refraction loss.} We minimize the difference between simulated background position $Q^{'}$ and and its corresponding captured
ground truth $Q$ (see Figure~\ref{fig:ray_location}). The refraction loss is defined as follows~$:$ 
\begin{equation}			
\mathcal{L}_{Refraction} = \sum_{i \in R}(\left\|Q_i-Q_i^{\prime} \right\|^{2})	
\end{equation}
where $R$ is the set containing ray paths that go through the object and refract on surfaces exactly twice.

% After excluding the rays with self-occlusion in the optimization,
With our proposed self-occlusion checking strategy, the invalid rays are excluded in the optimization, and the refraction loss gets rid of noises and makes reconstruction accurate.

 \begin{table}[t]
  \centering
  % \caption{Add caption}
  \resizebox{\linewidth}{!}{
    \begin{tabular}{ccccccc}
    \hline
        & \multicolumn{6}{c}{Sparsity=18 } 
        % & \multicolumn{6}{c}{9 Views}      
        % & \multicolumn{6}{c}{20 Views }
        \\ \hline
          & \multicolumn{2}{c}{Li~\etal~\cite{li2020through}} & \multicolumn{2}{c}{DRT\cite{lyu2020differentiable}} & \multicolumn{2}{c}{\textbf{Ours}} 
          \\ \hline
          
          & Acc. / Com.$\downarrow$ & F-score$\uparrow$
          & Acc. / Com.$\downarrow$ & F-score$\uparrow$ 
          & Acc. / Com.$\downarrow$& F-score$\uparrow$  
          \\ \hline
    Pig   & 2.63 / 3.01 & 0.18  & 1.87 / 1.45 & 0.35  & \textbf{0.91 / 0.88} & \textbf{0.47 } \\
    Dog   & 3.27 / 2.87 & 0.22  & 1.51 / 1.39 & 0.36  & \textbf{0.88 / 0.78} & \textbf{0.57 } \\
    Mouse & 1.93 / 2.8 & 0.25  & 2.90 / 2.29 & 0.23  & \textbf{1.27 / 1.09} & \textbf{0.41 } \\
    Monkey & 2.59 / 3.02 & 0.20  & 2.56 / 1.60 & 0.23  & \textbf{1.02 / 0.91} & \textbf{0.41 } \\
    Horse &   /    &   /    & 1.95 / 1.08 & 0.51  & \textbf{0.86 / 0.79} & \textbf{0.66 } \\
    Tiger &   /    &    /   & 3.04 / 1.74 & 0.40  & \textbf{1.01 / 0.86} & \textbf{0.59 } \\
    Rabbit &   /    &  /     & 1.44 / 1.27 & 0.38  & \textbf{1.07 / 0.93} & \textbf{0.50 } \\
    Hand  &    /   &   /    & 1.32 / 1.49 & 0.19  & \textbf{0.60 / 0.53} & \textbf{0.63 } \\
     \hline
    Avg.  & 2.60 / 2.92 & 0.21  & 2.07 / 1.53 & 0.33  & \textbf{0.95 / 0.84} & \textbf{0.53 } \\
     \hline
    \end{tabular}%
    }
    \caption{Evaluation of reconstruction with $sparsity=18$ (4 views).  
    Compared with Li~\etal~\cite{li2020through} and DRT~\cite{lyu2020differentiable}, our method achieves the best performance in all cases.
} 
\label{table:compare1}
% \vspace{-5mm}
\end{table}%

\textbf{Mask loss.} Following the prior works~\cite{lyu2020differentiable, wu2018full}, the mask loss is also included and defined as~$:$
\begin{equation}
    \mathcal{L}_{mask} = BCE(M_k, O_k) \label{mask_loss}
\end{equation}
where $O_k$ is the sum of weights along the $k_{th}$ camera ray, $M_k$ is the mask of the $k_{th}$ ray, and $BCE$ is the binary cross entropy loss.

\textbf{Eikonal loss.} We add an Eikonal loss to regularize the SDF field of the sampling point on the ray to have a unit norm of gradients. The loss term is defined as~$:$
\begin{equation}
\mathcal{L}_{Eikonal} = \frac{1}{nm}\sum_{k,i}(||\triangledown g({x}_{k,i})||_2 - 1) ^2 \label{Eikonal_loss}
\end{equation}
 where ${x}_{k,i}$ is the $i_{th}$ sampled point at the $k_{th}$ ray, $g$ is the geometry function.

\begin{table}[t]
  \centering
  % \caption{Add caption}
  \resizebox{\linewidth}{!}{
    \begin{tabular}{ccccccc}
    \hline
        & \multicolumn{6}{c}{Sparsity=9}      
        \\ \hline
          & \multicolumn{2}{c}{Li~\etal~\cite{li2020through}} & \multicolumn{2}{c}{DRT\cite{lyu2020differentiable}} & \multicolumn{2}{c}{\textbf{Ours}}  
          \\ \hline        
          & Acc. / Com.$\downarrow$ & F-score$\uparrow$
          & Acc. / Com.$\downarrow$ & F-score$\uparrow$ 
          & Acc. / Com.$\downarrow$& F-score$\uparrow$  
          \\ \hline
    Pig         
    & 1.56 / 1.77 & 0.23  & 0.90 / 0.91 & 0.56  & \textbf{0.83 / 0.77} & \textbf{0.60 } \\
    Dog   
    
    & 1.15 / 1.19 & 0.41  & 1.48 / 1.49 & 0.33  & \textbf{0.83 / 0.74} & \textbf{0.58 } \\
    Mouse 
    & 1.54 / 1.63 & 0.29  & 1.32 / 1.52 & 0.36  & \textbf{0.79 / 0.72} & \textbf{0.50 } \\
    Monkey 
    & 1.61 / 1.52 & 0.25  & 1.18 / 1.27 & 0.30  & \textbf{0.88 / 0.8} & \textbf{0.42 } \\
    Horse 
    &   /    &   /    & 0.68 / 0.60 & 0.80  & \textbf{0.68 / 0.45} & \textbf{0.81 } \\
    Tiger 
    &   /    &   /    & 1.58 / 1.23 & 0.59  & \textbf{0.85 / 0.69} & \textbf{0.71 } \\
    Rabbit 
    &   /    &   /    & 0.75 / 0.77 & 0.62  & \textbf{0.67 / 0.57} & \textbf{0.73 } \\

    Hand  
    &    /   &   /    & 0.88 / 0.98 & 0.32  & \textbf{0.60 / 0.53} & \textbf{0.63 } \\
     \hline
    Avg.  
    & 1.46 / 1.52 & 0.29  & 1.09 / 1.09 & 0.48  & \textbf{0.76 / 0.65} & \textbf{0.62 } \\
     \hline
    \end{tabular}%
    }
    \caption{Evaluation of reconstruction with $sparsity=8$ (9 views).  
    Compared with Li~\etal~\cite{li2020through} and DRT~\cite{lyu2020differentiable}, our method achieves the best performance in all cases.
} 
\label{table:compare2}
% \vspace{-3mm}
\end{table}%