\documentclass{article}

\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{libertine}
%\usepackage{leftidx}
\usepackage{mathtools}
\usepackage{multirow}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lem}[thm]{Lemma}
%\newdefinition{rmk}{Remark}
%\newproof{pf}{Proof}
%\newproof{pot}{Proof of Theorem \ref{thm2}}
%\newdefinition{definition}{Definition}
\usepackage{graphicx}
%\usepackage{svg}
%\graphicspath{ {./} }
%\usepackage[inkscapeformat=png]{svg}
\usepackage{subcaption}
\usepackage{url}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

%\journal{Engineering Applications of Artificial Intelligence }



%\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
%\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
%\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}}

%Added by IL
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }
\newcommand{\Nat}{\mathord{\mathbb{N}}}
\newcommand{\tu}[1]{\stackrel{#1}{\to}}
\newcommand{\pre}[1]{{^\bullet{#1}}}
\newcommand{\post}[1]{{#1^\bullet}}
\newcommand{\reachable}[2]{\mathcal{R}(#1,#2)}
\newcommand{\Loop}{\mathit{Loop}}

%%%%%%%%%%%%%%%%
%\begin{frontmatter}

% hierarchical process models discovery based on event partition

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \affiliation{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%% \fntext[label3]{}

\title{Discovering Hierarchical Process Models: an Approach Based on Events Clustering
\thanks{This work is supported by the Basic Research Program at HSE University, Russia.}}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \affiliation[label1]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%%
%% \affiliation[label2]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}

\author{Antonina K. Begicheva, Irina A. Lomazova, Roman A. Nesterov}
\date{\normalsize HSE University, Faculty of Computer Science\\%
\normalsize12 Pokrovksy Boulevard, Moscow, 109028, Russia}


\begin{document}
\maketitle

\begin{abstract}
%% Text of abstract
Process mining is a field of computer science that deals with  discovery and analysis of process models based on automatically generated event logs. 
Currently, many companies use this technology for  optimization and improving their processes. 
However, a discovered process model may be too detailed, sophisticated and difficult for experts to understand. 
In this paper, we consider the problem of discovering a hierarchical business process model from a low-level event log, i.e., the problem of automatic synthesis of more readable and understandable process models based on  information stored in  event logs of information systems. 

Discovery of better structured and more readable process models is intensively studied in the frame of process mining research from different perspectives. 
In this paper, we present an algorithm for discovering hierarchical process models represented as two-level workflow nets. The algorithm is based on  predefined event clustering  so that the cluster defines a sub-process corresponding to a high-level transition at the top level of the net. 
Unlike existing solutions, our algorithm does not impose  restrictions on the process control flow and allows for concurrency and iteration.



\emph{Keywords:}
%% keywords here, in the form: keyword \sep keyword
process mining; Petri nets; workflow nets; process discovery; hierarchical process model; event log
\end{abstract}


%\end{frontmatter}

%% \linenumbers

%% main text
\section{Introduction}\label{sec1}

Over the past decade, companies whose processes are supported by various information systems have become convinced of the need to store as much potentially useful information about the execution of processes within the system as possible. This was facilitated by the qualitative development of areas related to the extraction of valuable information from recorded data, which helps to correct the work of organizations in time and, thus, save and increase their resources. Process mining is a field of science that provides a palette of tools for extracting the logic of system behavior, as well as modeling and optimizing the processes occurring in it. In particular, process mining methods allow you to find inconsistencies between the planned and actual behavior of the system, and also timely track the appearance of inefficient or incorrect behavior.  


Despite the fact that more and more attention is being paid to preserving the optimal amount of necessary information about the execution of processes, process execution data is not always available in a convenient format and with the necessary degree of detail, since system logs are generated automatically. Process discovery is aimed at extracting processes from event logs and their representation in the form of a model.  Most of the available process discovery methods provide a model with the same level of detail as a given event log \cite{augusto2018automated}. 


Because of this, a promising area for research is the task of discovering a more readable process model from a detailed event log, while preserving important information about the process execution for experts. Readability can be provided in various ways. The most commonly used methods are filtering rare behavior from the original event log, skipping "minor" events (the significance of an event is assessed according to the chosen methodology), and abstraction, where some events are considered indistinguishable from each other. In our study, we consider the latter approach, when more readable models are the result of model abstraction --- they are more compact and have an optimal level of detail for the work of experts than what could be obtained by  direct discovery methods.
In order not to lose important information, we are dealing not only with abstract (high-level) models, but also with hierarchical models that store low-level information in the form of sub-processes.

Thus, in this paper, we propose an algorithm for discovering hierarchical process models from event logs. Processes are modeled with workflow nets \cite{wfnets00}, a special subclass of Petri nets for modeling a control flow of business processes. This study continues our previous study 
\cite{begicheva2017discovering}, in which we have proposed an approach to discover abstract models for processes without cycles.
Here we provide a more general solution by overcoming the prohibition of  cyclic behavior. 

Hierarchical models allows us to have a high-level view of the model by ``folding''  the behavior of an individual  sub-process  into a high-level transition  with the ability to unfold it back. 
So, at the top level there is a high-level model, in which each individual transition corresponds to a sub-process built from low-level events.
The history of the detailed behavior of the process is recorded in a low-level log. 
Regarding the number of levels in the hierarchy, we will only use two levels --- high and low, but the algorithm can naturally be extended to any number of levels.

The paper is structured as follows. Section 2 presents the review of related research. 
Section 3 gives theoretical preliminaries and definitions used in the text. 
In Section 4, we discuss the basics of the hierarchical process discovery algorithm. 
Section 5 presents the main discovery algorithm and the proof of its correctness. 
Section 6 reports the outcomes from the experimental evaluation. 
In Section 7, we conclude the paper and discuss the possible future work directions. 

%В данной работе мы сосредоточимся на области Process Mining извлечения процессов, применяемой к низкоуровневым (подробным) журналам событий для получения иерархических моделей. Мы рассматриваем модели процессов, представленные workflow-сетями – специальным подклассом сетей Петри [1] для моделирования рабочих процессов. Мы предполагаем, что модель не содержит перекрывающихся циклов. В абстрактной модели каждое отдельное действие представляет собой подпроцесс, построенный из набора более низкоуровневых действий. История подробного поведения процесса записывается в низкоуровневые логи. В качестве количества уровней иерархии в данной работе мы будем использовать всего два уровня – детальный и абстрактный, но алгоритм органично может быть расширен на любое количество уровней.


\section{Related Work}\label{sec2}

Research connected with our paper can be classified into approaches to abstracting event logs and process models and approaches to discovering hierarchical process models from event logs.

The recent work \cite{van2021event} gives a comprehensive review of approaches and methods that can be applied for low-level events abstraction.
The authors divide the methods according to: the learning strategy (supervised or unsupervised), the structure of the process models (strictly sequential or with interleaving), the low-level events grouping approach (deterministic or probabilistic), the nature of the processed data (discrete or continuous data). 
For instance, the method presented in \cite{maneschijn2022methodology} is a supervised method that converts a low-level event log into its high-level representation using detected behavioral patterns, such as sequence, selection, parallelism, interleaving and repetition.

A supervised approach to event abstraction was also presented in \cite{Mannhardt2016}.
This method takes a low-level event log and transforms it to an event log at the desired level of abstraction, using behavioral patterns: sequence, choice, parallel, interleaving and repetition of events.
This technique allows us to obtain a reliable mapping from low-level events to activity patterns automatically and construct a high-level event log using these patterns.
Another supervised event abstraction method was discussed in \cite{tax2016event}. 
The nature of this method is as follows.
We annotate a low-level event with the correct high-level event using the domain knowledge from the actual process model by the special attribute in an event log. 
In addition, this paper assumes that multiple high-level events are executed in parallel. 
This allows us to interpret a sequence of identical values as the single instance of a high-level event. 

A general approach to the representation of multi-level event logs and corresponding multi-level hierarchical models was studied in \cite{leemans2020using}.
The authors especially note that this approach can combine multiple formalisms for representing different levels in a multi-level process models.

There are many ways of abstracting process models by reducing their size in order to make them more convenient to work with. 
Each method may be useful depending on a group of interrelated factors: the abstraction purposes, the presence of certain patterns and constructs, and the specifics of modeling notation. 
Reducing the size of the model by abstraction can be done as the ``convolution'' of groups of elements, or implemented by throwing some parts away (insignificant in a particular case). 
The importance of the low-level event log abstraction is emphasized, among the others, in \cite{Smirnov2012}. 

The researchers determine, which level of abstraction is appropriate for a particular case in different ways, but the main criterion is that the model should be readable and understandable. 
In \cite{gunther2007fuzzy}, the abstraction of a process model occurs through ``simplification'' automatically: a user determines only the desired degree of detail, but not the actual correctness of identifying high-level events.
Conversely, the paper \cite{maneschijn2022methodology} stressed the importance of the abstraction level dependence on the domain expert knowledge.

Petri nets \cite{Reisig13} can also be extended by adding the hierarchy as, e.g., in Colored Petri nets (CPN) \cite{jensen2009coloured}.
Hierarchy also allows one to construct more compact, readable and understandable process models. 
Hierarchy of CPN models can be used as an abstraction, in the case of two levels: a high-level \emph{abstract} model and a low-level \emph{refined} model. 
In our paper the high-level model is a model with abstract transitions. 
An abstract transition refers to a Petri net subprocess, which refines the activity represented by this high-level transition. 
The complete low-level (``flat'') process model can be obtained from a high-level model by substituting subprocesses for high-level transitions.

``Flat'' synthesis (when process model and log are at the same-level) is a standard process discovery problem, which has been extensively studied in the literature.
A wide range of process discovery algorithms supports the automated flat process model synthesis \cite{augusto2018automated}.
\emph{Inductive miner} \cite{Leemans13} is one of the most widely used process discovery algorithm that produces well-structured process models recursively built from building blocks for standard behavioral patterns.
They can be potentially used for constructing high-level process models.
However, this technique does not take the actual correspondence between low-level events and subprocesses.
In \cite{greco2008mining}, the authors also used the recognition of behavioral patterns in a process by a structural clustering algorithm and then define a specific workflow schema for each pattern. 

In \cite{li2010mining}, a two-phase approach to mining hierarchical process models was presented. 
Process models here were considered as interactive and context-depen\-dent maps based on common execution patterns. 
On the first phase, an event log is abstracted to the desired level by detecting relevant execution patterns. 
An example of such pattern is the maximal repeat that captures typical sequences of activities the log. 
Every pattern is then estimated by its frequency, significance, or some other metric needed for accurate abstraction. 
On the second phase, Fuzzy miner discovery algorithm \cite{gunther2007fuzzy} adapted to process maps discovery is applied to  the transformed log.

\emph{FlexHMiner} \cite{lu2020discovering} is a general algorithm based on process trees implemented in ProM software. 
The authors stresses the flexibility of this approach: to identify the hierarchy of events, the method supports both supervised methods and methods using the general knowledge on a process. 
The limitations of this method include the fact that each of the sub-processes can be executed only once, which means that the method is not suitable for processes with cycles. 

Detecting high-level events based on the patterns of behavior in an event log does not make it possible to refine the accuracy of abstraction based on the general knowledge of the system or provide it only partially.
Patterns provide only the ability to change the scale, but not to participate in the selection of correct high-level events. 
This could be useful only for a superficial analysis.
However, there is a real risk of combining unrelated low-level events into a single high-level event only because they are executed sequentially, but not because they belong to the same logical component of a system.

A large amount of literature is devoted to the problem of discovering structured models from event logs.
Researchers offer different techniques to improve the structure of discovered models, e.g., in \cite{Fstr07}, and to produce already well-structured process models \cite{MpPM14,Pedro16}.
Different ways of detecting subprocesses in event logs using low-level transition systems were discussed in \cite{LocEv15,Kalenkova14-1,Kalenkova14}.
These papers do not consider mining hierarchical process models from event logs.

In our previous paper \cite{begicheva2017discovering}, we presented an algorithm for the discovery of a high-level process model from the event log for acyclic processes. 
The method takes the initial data about abstraction in the form of a set of detailed events grouped into high-level ones, which means that any method of identifying abstract events can potentially be used, including those based on expert knowledge. 
Moreover, the algorithm is based on event logs pre-processing.
This includes converting an initial event log into a high-level form and improving a target high-level process model
After pre-processing, we can use any of the existing process discovery algorithms suitable for the same-level (flat) process discovery. 
Both possibilities of using existing approaches as components make the earlier proposed algorithm flexible.

This paper expands the conditions of the applicability of the algorithm from \cite{begicheva2017discovering} since  it only works for acyclic models. 
For the algorithm to find and process potential cycles in the event log, we will reuse the method for detecting the repetitive behavior in a event log proposed in \cite{alvarez2020identifying}, which partially covers the general solution of the cycle detection problem. 

%Modern systems generate event logs automatically, which allows us to easily record even the lowest-level events occurring during the process. 
%Also, it helps to save as much data about each event as may be useful for further efficiency analysis. 
%Detailed event logs can be used as the input for process discovery algorithms, the output model of which is specified by one of the generally accepted formalisms for process modeling, such as BPMN (Business Process Model and Notation), Petri nets, declarative models and others. 

%If we apply a process discovery algorithm for the direct synthesis to the initial log containing a large amount of data, the resulting model will look like ``spaghetti'' due to the inclusion of a large number of details.
%An example of such a model is shown in Figure \ref{fig:spaghetti}.
%This process model is not comprehensible, and it does not provide the practical value for experts in the domain.
%The behavior of a real process can also include the unstructured behavior modified for a specific situation, which results in the loss of readability.
%, which also leads to the model readability loss if we obtained the model directly from the original event log. 

%In this section, we provide an overview of existing approaches to constructing hierarchical process models.
%We also discuss the existing process discovery algorithms suitable for synthesizing two-level hierarchical process models from low-level event logs. 
%process model abstraction approaches and hierarchical structure detection. The section also introduces several existing process discovery methods, which could be used for hierarchical process model synthesis and discusses their limitations.

%\subsection{How to make a model more readable and \textcolor{red}{comprehensible}?}\label{subsec2}

%Several approaches were proposed to identify the hierarchical structure in process models directly discovered from low-level event logs.
%optimizing oversized models were already discussed in the literature. 
%Among the others, in \cite{conforti2016bpmn}, the authors proposed an algorithm that splits a ``spaghetti'' process model into the set of sub-processes using data recorded during the execution of the process. 

%The more compact the process model can be depicted, the more convenient it is for visual analysis.
%The quality and convenience of the visual analysis of a process model depends on how compact we construct this model.
%One of the ways to obtain a more compact model without losing the important process execution information is to represent the process in a hierarchical form consisting of two levels: \emph{high} (abstract) and \emph{low} (detailed). 
%For a better understanding of what a high-level process model is, one can imagine a topographic map of some area with the possibility to change the scale. 
%Many details of a such map could be ``hidden'' under more general outlines. 
%When one zooms out on a map, it remains readable and comprehensible. 
%For example, if we want to see where the border of a city district passes, we are unlikely to need details such as the shape of each building.
%Thus, we can hide such details from the visual representation, leaving only the general scheme of streets --- this will correspond to the mechanism of abstraction in our terminology. 
%The opposite of abstraction is the detailing mechanism, which is accompanied by an increase in the number of visible details, both on the terrain map and in the process model. 
%Hierarchical process models, therefore, can include many representations of the same process, differing in the degree of abstraction, where each abstract element of a model can include a whole sub-process of low-level events combined by a given adjacency attribute.

%\begin{figure}[ht]
%\caption{Spaghetti model}
%\centering
%\includegraphics[width=0.5\textwidth]{spaghetti.png}
%\label{fig:spaghetti}
%\end{figure}

%The paper \cite{van2021event} presents a fairly complete and comprehensive review of the literature on the problem of events abstraction. 
%The authors divide the methods according to the learning strategy (supervised and unsupervised), according to the structure of the processed models (strictly sequential or with interleaving), according to the events grouping approach (deterministic or probabilistic), and by the nature of the processed data (discrete or continuous data). 
%For example, the method described in \cite{maneschijn2022methodology} is a supervised method that converts the input event log into a high-level one using detected behavioral patterns: sequence, selection, parallelism, interleaving and repetition. 

%В работе [25] представлен достаточно полный и всесторонний обзор литературы по теме абстракции событий. Авторы разделяют методы по стратегии обучения (с возможностью обучения на существующих данных и без такой возможности), по структуре обрабатываемых моделей (строго последовательные и те, в которых допускается интерливинг), по типу подхода к разделению событий на абстрактные (детерминистический либо вероятностный), а также по природе обрабатываемых данных (принимает ли метод на вход дискретные данные либо непрерывные, такие, как данные с сенсоров). Так, например, метод, описанный в [20] является методом, основанным на обучении, конвертирует исходный лог в высокоуровневый, опираясь на поведенческие паттерны событий: последовательность, выбор, параллелизм, интерливинг и повторения. 

%The researchers determine, which level of abstraction is appropriate for a particular case in different ways, but the invariable criterion is that the model should be understandable to the end user \cite{gunther2007fuzzy}. 
%The paper \cite{maneschijn2022methodology} emphasized the importance of the abstraction-level dependence on \textcolor{red}{the expert's sphere of interests}. 
%The paper proposed to determine the detail level, required for each end user of the model, in advance at the stage of the preparation to modeling via fuzzy miner presented in \cite{gunther2007fuzzy}. 
%Abstraction of the model in this case occurs through “simplification” automatically: the user determines only the desired degree of detail, but not the correctness of dividing the system into high-level events.


%Какой именно уровень абстракции является подходящим для конкретного случая авторы определяют по-разному, но неизменным критерием является то, что модель должна быть понятна конечному пользователю [14]. Работа [20] подчеркивает важность зависимости уровня абстракции от сферы интересов эксперта, для которого выполняется построение модели. Для этого в работе предлагается определить уровень детализации необходимый каждому из конечных пользователей модели заранее, на этапе подготовки к моделированию. Авторы используют для моделирования fuzzy miner [14], опираясь на то, какой уровень погрешности и допущений применим для будущих пользователей. Абстракция модели в этом случае происходит посредством “упрощения” в автоматическом режиме, то есть пользователь определяет только степень детализации, но не корректность разделения системы на высокоуровневые события.

%Several notations used for process modeling provide the ability to construct hierarchical model.
%For instance, colored Petri nets (CPN) \cite{jensen2015colored} include the possibility of defining a hierarchy using substitution transitions. 
%Each substitution transition is an abstract view refering to one of the system submodules, which refines this transition and are also stored as a colored Petri net. 
%Thus, it is possible to build a low-level process model from a hierarchical CPN by replacing each substitution transition with its corresponding submodule representation. 

%Некоторые языки моделирования, используемые при визуализации процессов, содержат в себе возможность для органического расширения. Так, например, раскрашенные сети Петри (CPN) [13] содержат в себе возможность задания иерархии использованием абстрактных переходов. Каждый абстрактный переход ссылается на подпроцесс, также хранимый в виде сети Петри, который является уточнением данного перехода. Таким образом построить низкоуровневую модель из высокоуровневой CPN можно, заменив абстрактные переходы на входящие в них подпроцессы.

%\subsection{Existing approaches: peculiarities and limitations}\label{subsec3}

%As already mentioned, none of the existing methods of synthesizing high-level process models from event logs solves the problem of obtaining an understandable model from a detailed low-level event log completely. 
%In this subsection we consider the hierarchical process discovery techniques proposed in the literature, their limitations and the scope of their application.

%Как уже было сказано, ни один из существующих методов извлечения абстрактных моделей из журналов событий не решает проблему получения понятной и читаемой модели из детального лога событий полностью, в этом параграфе мы рассмотрим предложенные в литературе техники, их ограничения и сферу их применения. 

%Some of the existing approaches solve this problem only for the area of the operation of a software product. 
%For example, in \cite{liu2020discovery}, the problem is considered from the point of view of software development: the authors use information about groups of program components specified as a low-level logging level to decompose the program into smaller independent components. 
%This allows the authors to present each of the component groups as a high-level event. 
%Another method for constructing a high-level model of a software system is presented in \cite{leemans2018recursion}. 
%The authors use hierarchical information from an event log to build a process tree.

%Некоторые из предложенных на настоящий момент методов решают проблему извлечения высокоуровневой модели из лога только для извлечения информации о работе программного продукта. Так, например, в [18] проблема рассматривается с точки зрения разработки программного обеспечения: авторы используют информацию о группах компонент программы, заданных в качестве уровня логирования, для декомпозиции программы на более мелкие независимые компоненты. Это позволяет авторам представить каждую из групп компонент в качестве высокоуровневого события. Еще один метод для построения высокоуровневой модели программной системы представлен в [15]. Авторы используют иерархическую информацию из журнала событий для построения дерева процессов.

%In addition, there exist methods for discovering hierarchical processes based on the automatic detection of behavioral patterns in event logs and combining each identified group of detailed events into a single high-level event. 
%Various machine learning methods, including, for example, clustering, also are used to combine low-level events into high-level groups in several existing process discovery algorithms. 
%For instance, machine learning methods are used in the BPMN Miner \cite{conforti2016bpmn}.

%В литературе также встречаются методы выявления иерархических процессов из логов событий, основанные на автоматическом выявлении шаблонного поведения в журналах событий и объединении каждой выявленной группы событий в одно абстрактное событие. В таких методах, для разделения низкоуровневых событий на высокоуровневые группы могут, в том числе, быть использованы различные методы машинного обучения, например, кластеризация.  Такой метод, например, применяется в статье [11], где авторами представлен BPMN Miner — метод автоматического извлечения BPMN-моделей. 

%Extracting high-level events based on the patterns of behavior does not make it possible to refine the accuracy of abstraction based on the general knowledge of the system or provide it only partially.
%They provide only the ability to change the scale, but not to participate in the selection of correct high-level events. 
%This could be useful only for a superficial analysis.
%However, there is a risk of combining unrelated low-level events into a single abstract event only because they are executed sequentially, but not because they belong to the same logical component of a system.

%Методы извлечения высокоуровневых событий на основе паттернов поведения не дают возможность уточнения точности абстракции на основе общих знаний о системе, либо обеспечивают ее лишь частично (например, предоставляют только возможность изменения масштаба, но не участие в выделении корректных абстрактных событий). Это может быть полезно для поверхностного анализа, но есть риск объединения низкоуровневых событий, не связанных друг с другом, в одно абстрактное событие только по причине того, что данные события исполнялись последовательно в логе событий, а не потому, что они действительно относятся к одному логическому компоненту системы.

%In \cite{leemans2020using}, the authors introduced the concept of multilevel information in the log, without limitations on the number of levels.
%A hierarchical process model is naturally built on the basis of such information. 
%In their method, the authors combine many techniques and formalisms. 
%The method has a number of limitations connected with detecting concurrent low-level events, which belong to different high-level events. 

%В работе [17] авторы вводят понятие многоуровневой информации в логе, без ограничения на количество уровней, и на основе такой информации органически строится иерархическая модель. В своем методе авторы объединяют множество техник и формализмов. В отличие от методов, выделяющих абстрактные события из низкоуровневых самостоятельно, и не обязательно корректно, данный метод использует информацию об уровнях событий, уже записанную в логе, что помогает избегать логических ошибок. У метода имеется ряд оговоренных ограничений, как, например, ограничение в выявлении параллелизма низкоуровневых событий, принадлежащих разным высокоуровневым событиям.

%FlexHMiner \cite{lu2020discovering} is a general algorithm based on process trees implemented in ProM software. 
%The authors emphasize the flexibility of the approach: to determine the hierarchy of events, the method supports both supervised methods and methods which using general knowledge about the process. 
%The limitations of this method include the fact that each of the sub-processes can be executed only once, which means that the method is not suitable for processes with cycles. 

%FlexHMiner [19] - общий подход, на основе деревьев процессов, с реализованным плагином под ProM (http://www.promtools.org/). Авторы делают упор на гибкость подхода: для выделения иерархии событий метод поддерживает как методы с обучением, так и методы с использованием общих знаний о процессе. К ограничениям данного метода относится то, что каждый из подпроцессов может быть исполнен только однократно, а значит метод не подходит для обработки процессов с циклами.

%In our previous paper \cite{begicheva2017discovering}, we presented an algorithm for the synthesis of a high-level process model from the event log for acyclic processes. 
%The method takes the initial data about abstraction in the form of a set of detailed events grouped into high-level ones, which means that any method of identifying abstract events can potentially be used, including those based on expert data. 
%Moreover, the algorithm is based on event logs pre-processing.
%This includes converting a log into an abstract form and improving the final high-level model, which means that in this part of the algorithm, after pre-processing, we can also use any of the existing process discovery algorithms. 
%Both possibilities of using existing methods as components make the earlier proposed algorithm flexible.

%This paper expands the conditions of the applicability of the algorithm from \cite{begicheva2017discovering} since  it only works for acyclic models. 
%For the algorithm to find and process potential cycles in the event log, we will use the method for detecting the repetitive behavior in a log proposed in \cite{alvarez2020identifying}, which partially covers the general solution of the cycle detection problem. 


\section{Preliminaries}\label{sec3}

By $\Nat$  we denote the set of non-negative integers.

Let $X$ be a set. A \emph{multiset} $m$ over a set $X$ is a mapping: $m : X \rightarrow \Nat$, where $\Nat$ -- is the set of natural numbers (including zero), i.e., a multiset may contain several copies of the same element. 
For an element $x\in X$, we write  $x\in m$ , if $m(x) >0$.
For two multisets $m,m'$ over $X$ we write $m\subseteq m'$  iff $\forall x\in X: m(x) \leq m'(x)$ (the inclusion relation). 
The sum, the union and the subtraction of two multisets $m$ and $m'$ are defined as usual:
$\forall x\in X: (m+m')(x)=m(x)+m'(x), (m\cup m')(x)=max(m(x),m'(x)), (m-m')(x)=m(x) - m'(x)$, if  $m(x) - m'(x) \geq 0$, otherwise $(m-m')(x)= 0$.
By $\mathcal{M}(X)$ we denote the set of all multisets over $X$.

\smallskip

For a set $X$, by $X^*$ with elements of the form $\langle x_1,\dots, x_k \rangle$ we denote the set of all finite sequences (words) over $X$, $\langle \rangle$ denotes the empty word, \ie the word of zero length. Concatenation of two words $w_1$ and $w_2$ is denoted by $w_1\cdot w_2$.

Let  $Q \subseteq X$ be a subset of $X$. The 
 projection $\restriction_Q : X^*  \rightarrow Q^*$ is  defined recursively as follows: 
 ${\langle \rangle}{\restriction_Q}  = \langle \rangle$,  and for $\sigma \in X^*$ and $x \in X$: 
$$(\sigma	\cdot \langle x\rangle) {\restriction_Q}= 
    \begin{cases} 
    \sigma {\restriction_Q}           $ if $ x\notin Q \\
   \sigma {\restriction_Q}  \cdot  \langle x \rangle $ if $ x \in Q
    \end{cases} $$

\smallskip

We say that $X = X_1 \cup X_2 \cup \dots  \cup X_n$ is a partition of the set $X$ if for all $1{\leq}i,j{\leq}n $ such that 
$i\not = j$ we have $X_i \cap X_j = \emptyset$. 

\subsection{Petri Nets}
   
%We consider Petri nets as one of the formalisms with a convenient visualization and clear semantics for modeling concurrent systems. Also, this formalism has such advantages such as a strong theoretical basis, and a wide range of analysis techniques. 

Let $P$ and $T$  be two disjoint finite sets of places and transitions respectively, and $F : (P \times T) \cup (T \times P) \to \Nat$ be an arc-weight function. 
Let also $A$ be a finite set of \emph{event names} (or \emph{activities}) representing observable actions or events, $\tau$ --- a special label for \emph{silent} or invisible action, $\lambda : T \to A\cup \{\tau\}$ is a transition labeling function. 
Then $N = (P,T,F, \lambda)$ is a \emph{labeled Petri net}. 

Graphically, a Petri net is designated as a bipartite graph, where places are represented by circles, transitions by boxes, and the flow relation $F$ by directed arcs.

%For working with Petri nets as a bipartite graph it is appropriate to use incidence matrixes. 
%The incidence matrix of N is C = C^+-C^-, where C^-   = [c_ij^-]; c_ij^-= I(p_i,t_j); and C^+  = [c_ij^+];
%c_ij^+  = O(p_i,t_j) are the pre-incidence and post-incidence matrices, respectively.

A \emph{marking} in a Petri net $N = (P,T,F, \lambda)$ is a function $m : P \to \Nat$  mapping  each place to some  number of tokens (possibly zero). Hence, a marking in a Petri net may be considered as a multiset over its set of places.  
Tokens are graphically designated by filled circles, and then a current marking $m$  is  represented by putting $m(p)$ tokens into each place $p \in P$.
A \emph{marked Petri net} $(N,m_0)$ is a Petri net $N$ together with its initial marking $m_0$.

For  transition $t \in T$, its \emph{preset}  (denoted $\pre{t} $)  and its \emph{postset} (denoted $\post{t}$) are defined as  sets of its input and output places respectively, \ie %for each $p \in P$,
$\pre{t} = \{p \mid F(p,t)\not = 0\}$ and $\post{t}= \{p \mid F(t,p)\not = 0\}$.


A transition $t \in T$ is \emph{enabled} in a marking $m$, if for all $p \in \pre{t}$, $m(p)  \geq F(p,t)$. An enabled transition $t$ may \emph{fire} yielding a new marking $m'$, such that $m'(p) = m(p) - F(p,t) + F(t,p)$ for each $p \in P$ (denoted $m\tu{\lambda(t)} m'$, or just $m\to m'$).
A marking $m'$ is reachable from a marking $m$, if there exists a sequence of firings $m=m_0 \to m_1 \to \dots m_k=m'$. By 
$\reachable{N}{m}$ we denote the set of all markings reachable from marking $m$ in a net $N$.

Let $(N,m_0)$ be a marked Petri net with transitions labeled by activities from $A\cup\{\tau\}$, and let $m_0 \tu{a_1} m_1 \tu{a_2} \dots$ be a finite or infinite sequence of firings in $N$, which starts from the initial marking $m_0$ and cannot be extended. Then a sequence of observable activities $\rho$, such that $\rho = 
\langle a_1, a_2,\dots \rangle{\restriction_A}$, is called a \emph{run}, \ie a run is a sequence of observable activities representing a variant of Petri net behavior. For a finite run $\rho$, which corresponds to a sequence of firings $m_0\tu{a_1}\dots \tu{a_k}m_k$, we call $m_0$ and $m_k$ its initial and final markings respectively.

A transition $t\in T$ is called \emph{dead} for a marked net $(N,m_0)$, if for each reachable marking $m\in \reachable{N}{m_0}$, $t$ is not enabled in $m$.

% INVARIANTS ARE NOT USED !!!
%To work with a cycle structures we also need to introduce the concept of t-invariants of Petri net.

%\begin{definition}
%A \emph{t-invariant} $Y_i$  of a Petri net is a positive integer solution to the equation $CY_i=0$. The \emph{support} of $Y_i$  denoted as $\langle Y_i \rangle $ is the set of transitions whose corresponding elements in $Y_i$ are positive. $Y$ is minimal if its support is not included in the support of another t-invariant. A t-component $N(Y_i)$ is a subnet of Petri net induced by a $\langle Y_i \rangle : N(Y_i) = (P_i,T_i,I_i,O_i )$, where  $P_i = \leftidx{^\bullet}{\langle Y_i \rangle }{} \cup \langle Y_i \rangle ^{\bullet}$, $T_i=\langle Y_i \rangle$ , $I_i = P_i \times T_i \cap I$, and $O_i = P_i\times T_i \cap O$.
%\end{definition}

%For each t-invariant $Y_i$ it is true that, if we have an initial marking ($M_0$) that enables a $t_i \in \langle Y_i \rangle$, when $t_i$ is fired, then $M_0$ can be reached again by firing only transitions from $\langle Y_i\rangle$.

\begin{figure}[ht]
 
    \centering
    \includegraphics[width=0.7\textwidth]{classic_net.png}
    \caption{A workflow net for handling compensation requests}   
    \label{fig:petrinet}
\end{figure}



 
\smallskip

In our study we consider  \emph{workflow nets} --- a special subclass of Petri nets 
\cite{van2002workflow} 
for workflow modeling. A \emph{workflow net} is a (labeled) Petri net with two special places: $i$ and $f$. These places mark the beginning and the ending of a workflow process.% (Figure 3).

%\begin{definition}
A (labeled) marked Petri net $N = (P,T,F,\lambda, m_0)$ is called a workflow net (WF-net) if the following conditions hold:
\begin{enumerate}
\item	There is one source place $i\in P$ and one sink place $f\in P$, such that  $\pre{i} = \post{f} = \emptyset$.
\item	Every node from $P \cup T$ is on a path from $i$ to $f$.
\item	The initial marking $m_0$ in $N$ contains the only token in its source place.
\end{enumerate}
%\end{definition}

Given a WF-net, by $[i]$ we denote its initial marking with the only token in place $i$, and by $[f]$ --- its \emph{final} marking with the only token in place $f$.

 An example of a workflow net that simulates a simple process of handling ticket refund requests, is shown in Fig.~\ref{fig:petrinet} \cite{Aalst11}. Here $p_0$ is the source place, and $p_6$ --- the sink place. 

\smallskip

Soundness \cite{van2002workflow} is the main correctness property for workflow nets.
%\begin{definition}
A WF-net $N = (P,T,F,\lambda, [i])$ is called \emph{sound}, if 
\begin{enumerate}
    \item For any marking $m \in R (N,[i])$, $[f]\in \reachable{N}{m}$;
    \item If for some $m \in R (N,[i])$, $[f]\subseteq m$, then $m=[f]$;
    \item There are no dead transitions in $N$.
\end{enumerate}
%\end{definition}



%The following definition proposes an element of Petri Net, which can be used to embed WF-net into some place of Petri Net:

%%%%%%%%%%%%%% не используется
%\begin{definition} 
%Let $N = (P,T,F,\lambda)$ be a WF-net. Then we define the \emph{extended WF-net (EWF-net)} $N' = (P',T',F',\lambda')$ as follows: $P' = P; T' = T \cup \{t_i; t_f\}$ and $F' = F \cup \{\langle t_i,i \rangle , \langle f,t_f \rangle \}$; where $t_i, t_f$ are new (not occurring in $P,T$) nodes. The new transitions $t_i,t_f$ are labeled with invisible event $\tau$, all other transitions in $N'$ have the same labels as in $N$. The initial marking in an extended WF-net contains no tokens. Thus, an extended WF-net may start a new case at any moment.
%\end{definition}

\subsection{Event Logs}

Most information systems record  history of their process execution into event logs. An \emph{event record} usually contains case ID, an activity name, a time step, and some information about resources, data, etc. For our study, we use case IDs for splitting an event log into  traces, timestamps --- for ordering events within each trace, and abstract from event information different from event names (activities).

%\begin{definition}
Let A be a finite set of activities. A \emph{trace} $\sigma$ is a finite sequence of activities from $A$, i.e., $\sigma \in A^*$. By $\# a(\sigma)$ we denote the number of occurrences of activity $a$ in  trace $\sigma$. 

An \emph{event log} $L$ is a finite multi-set of traces, i.e., $L \in\mathcal{M}(A^*)$. 
A log $L'$ is called  a \emph{sub-log} of $L$, if $L'\subseteq L$.
Let $X \subseteq A$. We extend projection $\restriction_X$ to event logs, i.e., for an event log $L \in M(A^*)$, its projection is a sub-log $L{\restriction_X}$, defined as the multiset of projections of all traces from $L$, \ie $L{\restriction_X}(\sigma{\restriction_X}) = L(\sigma)$ for all $\sigma\in L$.

An important question is whether the event log matches the behavior of the process model and vice versa. There are several metrics to measure  conformance between a WF-net and an event log. Specifically, \emph{fitness} defines to what extend the log can be replayed by the model. 

  Let $N$ be a WF-net with transition labels from $A$, an initial marking $[i]$, and a final marking $[f]$. Let $\sigma$ be a trace over $A$. We say that trace $\sigma = \langle a_1, \dots , a_k\rangle$ \emph{perfectly fits} $N$, if $\sigma$ is a run in $N$ with initial marking $[i]$ and final marking $[f]$.
A log $L$ perfectly fits $N$, if every trace from $L$ perfectly fits $N$.

\section{Discovering Hierarchical WF-Nets}
\subsection{Hierarchical WF-Nets}
\label{subsec:HWF}
%PROPOSED NOTATION (a suject for discussion and change, if needed)

%Set of (low level activities) $A = \{a,\dots\}$ \\
%Subprocesses (modules) names (activities for upper level WF-net) $\Tilde{A} = \{\alpha, \dots\}$ \\
%Hierarchical WF-net $\mathcal{N}= (\Tilde{N},N_1,N_2,\dots,N_k)$
%where transitions in $\Tilde{N}$ are labeled with subprocess names from $\Tilde{A}$, transitions in $N_i$ --- by activities from $A$. %$A_i$, $A_i\subseteq A$.
%We may not require that $A=A_1\cup\dots\cup A_k$ is a partition in this definition, I guess)

Let $A$ denote the set of low level process activity names.
Let $\Tilde{A} = \{\alpha_1, \alpha_2, \dots,$ $\alpha_k\}$ denote the set of sub-process names, which represent high-level activity names, respectively.

Here we define \emph{hierarchical workflow} (HWF) nets with two levels of representing the process behavior.
The \emph{high level} is a WF-net, whose transitions are labeled by the names of sub-processes from $\Tilde{A}$.
The \emph{low level} is a set of WF-nets corresponding to the \emph{refinement} of transitions in a high-level WF-net.
Transitions in a low level WF-net are labeled by the names of activities from $A$.
%\textcolor{red}{We also do not require that every transition in an upper level WF-net should be refined with a WF-net at the low level.}
Below we provide the necessary definitions and study the semantics of HWF-nets.

An HWF-net is a tuple $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots, N_k,\ell)$, where:
\begin{enumerate}
    \item $\Tilde{N} = (\Tilde{P}, \Tilde{T}, \Tilde{F}, \Tilde{\lambda}, \Tilde{[i]})$ is a high-level WF-net, where $\Tilde{\lambda} \colon \Tilde{T} \to \Tilde{A}$ is a bijective transition labeling function, which assigns sub-process names to transitions in $\Tilde{N}$;
    \item $N_i = (P_i, T_i, F_i, \lambda_i, [i]_i)$ is a low-level WF-net for every $i \in [1, k]$ with a transition labeling function $\lambda_i \colon T_i \to A_i$, where $A_i \subseteq A$ is a  subset of low level activities for $N_i$;
    \item $\ell \colon \Tilde{A} \to \{N_1, N_2, \dots, N_k\}$ is a bijection which establish the correspondence between a sub-process name (transition in a high-level WF-net) and a low-level WF-net.
\end{enumerate}

Accordingly, every transition in a high-level WF-net $\mathcal{N}$ has a corresponding low-level WF-net modeling the behavior of a sub-process.
The example of an HWF-net is shown in Figure \ref{fig:hwf1}.
We only show the refinement of two transitions $t_1$ and $t_2$ in the high-level WF-net $\Tilde{N}$ with two low-level WF-nets $N_1$ and $N_2$.
They represent the detailed behavior of two sub-processes $\alpha_1$ and $\alpha_2$ correspondingly.

\begin{figure}[h]
        \centering
     \includegraphics[width=0.7\textwidth]{hwf11.pdf}
     \caption{A HWF-net with two refined transitions}
    \label{fig:hwf1}
\end{figure}

We next consider the operational semantics of an HWF-nets by defining its run.
For what follows, let $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots, N_k, \ell)$ be an HWF-net.

Let $\Tilde{m}$ be a reachable marking in a high-level WF-net of an HWF-net $\mathcal{N}$ and $T_{\Tilde{m}}$ be a set of transitions enabled at $\Tilde{m}$.
Intuitively, a set of transitions enabled in a high-level WF-net $\Tilde{m}$ corresponds to a set of sub-processes for which we can start to fire their low level transitions.

If some transitions in a high-level WF-net enabled at $\Tilde{m}$ share common places, then there is a \emph{conflict}, and we can choose, which sub-process to start, while the other sub-rocesses corresponding to conflicting transitions in a high-level WF-net will not be able to run.

If some transitions in a high-level WF-net enabled at $\Tilde{m}$ do not share common places, then they are enabled \emph{concurrently}, and we can start all sub-processes corresponding to these concurrently enabled transitions using the ordinary interleaving semantics.

The firing of a transition in a high-level WF-net will be complete when the corresponding sub-process reaches its final marking.

For instance, let us consider the HWF-net shown in Figure \ref{fig:hwf1}.
After firing  high-level transition $t_3$ and executing a corresponding sub-process $\alpha_3$ (not provided in Figure \ref{fig:hwf1}), two high-level transitions $t_1$ and $t_2$ become enabled.
They do not share common places, i.e.,  high-level transitions $t_1$ and $t_2$ are enabled concurrently.
Thus, the corresponding sub-processes $\alpha_1$ (low-level WF-net $N_1$) and $\alpha_2$ (low-level WF-net $N_2$) can also be executed concurrently.
We can obtain a sequence $\rho = \langle \alpha_3, e_1, e_5, e_2, e_6, \alpha_4 \rangle$, which will represent a possible run of an HWF-net from Figure \ref{fig:hwf1}.
High-level activities $\alpha_3$ and $\alpha_4$ should also be replaced with corresponding sub-process runs.

Lastly, we give a straightforward approach to transforming an HWF-net $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots,$ $ N_k, \ell)$ to the corresponding \emph{flat} WF-net denoted by $\mathbf{fl}(\mathcal{N}) = (P, T, F, \lambda, [i])$.
We need to replace transitions in a high-level WF-net with their sub-process implementation given by low-level WF-net corresponding by $\ell$.
When a transition $t$ in a  high-level WF-net $\Tilde{N}$ is replaced by a low-level WF-net $N_i$, we need to fuse a source place in $N_i$ with all input places of $t$ and to fuse a sink place in $N_i$ with all output places of $t$.

For instance, the flat WF-net $\mathbf{fl}(\mathcal{N})$ constructed for the HWF-net, shown in Figure \ref{fig:hwf1}, is provided in Figure \ref{fig:flatwf}.
We replaced transition $t_1$ with $N_1$ and transition $t_2$ with $N_2$ as determined by the labels of low-level WF-nets.
This figure also shows the double-line contours of corresponding  high-level transitions.

\begin{figure}[!h]
        \centering
    \includegraphics[width=0.35\textwidth]{flat11.pdf}
    \caption{The flat WF-net for the HWF-net in Fig.~\ref{fig:hwf1}}
    \label{fig:flatwf}
\end{figure}

Proposition \ref{prop:conn} gives the main connection between an HWF-net and its flat representation. 

\begin{prop}\label{prop:conn}
    Let $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots, N_k, \ell)$ be a HWF-net, and $\mathbf{fl}(\mathcal{N})$ be the corresponding flat WF-net.
    A sequence $\rho$ is a run in $\mathcal{N}$ if and only if $\rho$ is a run in $\mathbf{fl}(\mathcal{N})$.
\end{prop}

In other words, the set of all possible runs of a HWF-net is exactly the same as the set of all possible runs of the corresponding flat WF-net.
Proof of this proposition directly follows from the construction of the flat WF-net and from the way we define the sequential semantics of a hierarchical WF-net.

To sum up, the constructive representation of the HWF-net sequential semantics fully agrees with the ordinary Petri net firing rule and the definition of a run discussed in Section 3.

\subsection{Problem Statement}
Let $L$ be a log over a set $A$ of activities, and let $A=A_1\cup A_2 \cup\dots\cup A_k$ be a partition of $A$. Let also $\Tilde{A} = \{\alpha_1, \alpha_2,\dots\alpha_k\}$ be a set of high-level activities (sub-process names).

The problem is to construct a HWF-net $\mathcal{N}= (\Tilde{N},N_1,N_2,\dots,N_k,l)$, where for each $i\in [1, k]$, $N_i$ is a sub-process (WF-net) labeled by $\alpha_i$  over the set of activities $A_i$. Runs of $\mathcal{N}$ should conform to traces from $L$.

We suppose that partitioning $A$ into subsets $A_1, \dots A_k$ is made either by an expert, or automatically based on some information contained in extended action records, such as resources or data. In Section~\ref{evaluation} we give two examples of partitioning activities for a real log. Then we consider that a sub-process is defined by its set of activities, and we suppose that sets of activities for two sub-processes do not intersect. If it is not the case and two sub-processes include some common activities like 'close the file', one can easily distinguish them by including resource or file name into activity identifier.

One more important comment concerning partitioning activities: we suppose that it does not violate the log control flow. Specifically, if there are iterations in the process, then for a set of iterated activities $B$ and for each sub-process activities set $A_i$, we suppose that either $B\cap A_i = \emptyset$, or $B\subseteq A_i$, or $A_i\subseteq B$. Note that this is a reasonable requirement, taking into account the concept of a sub-process. If still it is not true, 
\ie only a part of $A_i$ activities are iterated, then the partition can be refined,  exactly $A_i$ can be splitted into two subsets, within and out of iteration.

\subsection{Basics of the Proposed Solution}
Now we describe the main ideas and the structure of the algorithm for discovery of hierarchical WF-net from event log.

Let once more $L$ be a log with activities from $A$, and let $A=A_1\cup A_2 \cup\dots\cup A_k$ be a partition of $A$. Let also $\Tilde{A} = \{\alpha_1, \alpha_2,\dots\alpha_k\}$ be a set of high-level activities (sub-process names).
A hierarchical WF-net $\mathcal{N}$ consists of a high-level WF-net $\Tilde{N}$ with activities from $\Tilde{A}= \{\alpha_1,\dots,\alpha_k\}$, and $k$  sub-process WF-nets $N_1,N_2,\dots,N_k$, where for each $N_i$, all its activities belong to $A_i$.

Sub-process WF-nets $N_1,N_2,\dots,N_k$ can be discovered directly. To discover $N_i$ we filter log $L$ to $L_i = L{\restriction_{A_i}}$.
Then we apply one of popular algorithms (\eg Inductive Miner) to discover WF-model from the log $L_i$. Fitness and precision of the obtained model depend on the choice of the discovery algorithm.

Discovering high-level WF-model is not so easy and is quite a challenge. Problems with it are coursed by possible interleaving of concurrent sub-processes and iteration. A naive solution could be like follows: in the log $L$ replace each activity $a\in A_i$ by $\alpha_i$ --- the name of the corresponding sub-process. Remove 'stuttering', \ie replace wherever possible several sequential occurrences of the same high-level activity by one such activity. Then apply one of popular discovery algorithms to the new log over the set $\Tilde{A}$ of activities. However, this does not work.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.5\textwidth}
        %\includesvg[width=1\textwidth]{interleav12.svg} 
		     \includegraphics[width=1\textwidth]{interleav12.png}		
        \caption{concurrent sub-processes}
        \label{fig:interleaving}
    \end{subfigure}\\
    \begin{subfigure}{0.9\textwidth}
        \includegraphics[width=1\textwidth]{cycles4.png}
        \caption{sub-processes inside a loop}
        \label{fig:cycles}
    \end{subfigure}

    \caption{Interleaving and iteration of sub-processes}
    \label{fig:subproc_problems}
\end{figure}

Consider examples in Fig.~\ref{fig:subproc_problems}. Fragment (a) in Fig.\ref{fig:subproc_problems} shows two concurrent sub-processes $\beta$ and $\gamma$, going after sub-process $\alpha$, which consists of just one transition. After replacing of low level activities with the corresponding sub-process names and removing stuttering, for the fragment (a), we get runs $\langle \alpha,  \beta,  \gamma, \dots\rangle$,  $\langle \alpha, \gamma, \beta, \dots\rangle$, $\langle \alpha, \beta,\gamma, \beta, \gamma, \dots\rangle$,
$\langle \alpha, \gamma, \beta, \gamma,  \beta,\dots\rangle$, etc.  
Fragment (b) in Fig.~\ref{fig:subproc_problems} shows a cycle. The body of this cycle is the sequence of two sub-processes $\beta$ and $\gamma$. Among runs for the fragment (b) we also have $\langle \alpha,  \beta,  \gamma, \dots\rangle$,  $\langle \alpha, \beta,\gamma, \beta, \gamma, \dots\rangle$. So, iterations should be considered separately. 

Discovering high-level WF-nets for acyclic models (\ie logs without iteration) was studied earlier in \cite{begicheva2017discovering}, where all details can be found. Here we call  this algorithm as Algorithm $\mathfrak{A}_0$ and illustrate it with the  example in Fig.~\ref{fig:subproc_problems}(a). The algorithm $\mathfrak{A}_0$ to discover a high-level WF-model from a log $L$ without iterations reduces this problem to the classical discovery problem, which can be solved by many popular algorithms, such as e.g. Inductive Miner.  Therefore, we parameterize Algorithm $\mathfrak{A}_0$ with Algorithm~$\mathfrak{D}$ for solving classical discovery problem.

%is executed in several steps.

\smallskip

\textit{Algorithm $\mathfrak{A}_0(\mathfrak{D})$}:

\begin{enumerate}
    \item[\textit{Step 1.}] For all traces in $L$, replace low level activities with the corresponding sub-process names and remove stuttering.
    \item[\textit{Step 2.}]  For each trace $\sigma$ with more than one occurrence of the same activity  replace $\sigma$ with the set of all possible clones of $\sigma$ by removing for each activity $\alpha$, all its multiple occurrences except one, and by removing (newly formed) stuttering. For example, the trace $\langle \alpha, \beta,\gamma, \beta, \gamma, \dots\rangle$ will be replaces by two traces $\langle \alpha, \beta,\gamma, \dots\rangle$ and $\langle \alpha, \gamma, \beta, \dots\rangle$ obtained by keeping the first occurrences of $\beta$ and $\gamma$, and correspondingly by keeping the first occurrence of $\gamma$ and the second occurrence of $\beta$. In this example, constructing clones by keeping other occurrences of $\gamma$ does not generate new traces.
    \item[\textit{Step 3.}]  Let $\Tilde{L}$ be the log resulting from executing two previous steps.  To obtain a high-level WF-net $\Tilde{N}$, apply a popular algorithm $\mathfrak{D}$ to discover a WF-net from event log $\Tilde{L}$.
\end{enumerate}

It was proved in~\cite{begicheva2017discovering} that if an algorithm used in Step~3 of the Algorithm $\mathfrak{A}_0$ for each input log $L$ discovers  a WF-net  perfectly fitting $L$, then the Algorithm $\mathfrak{A}_0$, given a log $L$ without repetitive behavior, produces a HWF-net $\mathcal{N}$, such that $\mathbf{fl}(\mathcal{N})$ perfectly fits $L$.

\medskip

Now we come to logs with repetitive behavior. The main idea here is to represent a loop body as a subset of its activities. Then a body of a loop can be considered as a sub-process with a new loop sub-process name.

To discover repetitive behavior we use  methods from \cite{alvarez2020identifying,tapia2017discovering}, which allow  to determine causal, concurrency, and repetitive relations between events in an event log.
Actually, for our purpose we need only repetitive relations and based on them loop discovery. The algorithm in \cite{tapia2017discovering} (we call it here as  Algorithm $\mathfrak{B}$) allows us to discover elementary loop bodies as sets of their activities and process them recursively, starting with inner elementary loops.  Thus, at every iteration we deal with a loop body without inner loops. To obtain a sub-trace, corresponding to a loop body with a set of activities $B$ from a log trace $\sigma$ we construct the projection $\sigma{\restriction_B}$. After filtering all current traces this way, we get an event log for discovering a WF-net modeling the loop body behavior by applying Algorithm $\mathfrak{A}_0$.

Then the result high-level WF-net is built recursively by substituting discovered loop bodies for loop sub-process  names, starting from inner loops.

\section{Algorithm for Discovering  HWF-Nets from Low Level Event Logs}\label{sec5}

Here we describe  our discovery algorithm  in more details.

Let $A$ be a set of activities and $L$ --- a log over $A$. Let then $A=A_1\cup\dots\cup A_k$ be a partition of $A$, where for $i\in [1, k]$, $A_i$ is a set of activities of a sub-process $\alpha_i$ and $\Tilde{A}= \{\alpha_1, \dots, \alpha_k\}$ --- a set of sub-process names.

Then Algorithm $\mathfrak{A}(\mathfrak{D})$  constructs a HWF-net $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots, N_k,\ell)$ with  high-level WF-net $\Tilde{N} = (\Tilde{P}, \Tilde{T}, \Tilde{F}, \Tilde{\lambda}, \Tilde{[i]})$, where
$\Tilde{\lambda} \colon \Tilde{T} \to \Tilde{A}$ and for each $\alpha_i\in \Tilde{A}$, $\ell(\alpha_i) = N_i$, \ie sub-process name $\alpha_i$ corresponds to  low-level WF-net $N_i$ in $\mathcal{N}$.

\smallskip


\textit{Algorithm $\mathfrak{A}(\mathfrak{D})$}: 

\smallskip
By $\Tilde{B}$ we denote a  set of loop body names with elements $\{\beta, \beta',\dots\}$ and by $\ell_B$ --- a function which maps a name from $\Tilde{B}$ to a WF-net that implements the loop body. For a WF-net $N$, denote by $\Loop(N)$  a WF-net that is a loop with  body $N$.

\begin{enumerate} 
\item[\textit{Step 0.}] Set $\Tilde{B}= \emptyset$ and $\ell, \ell_B$ to be two functions with  empty domains. 
\item[\textit{Step 1.}]
    Apply Algorithm $\mathfrak{B}$ to $L$ to find a set $B$ of activities of some inner elementary loop body. If there is no repetitive behavior in $L$, \emph{go to Step 2}, otherwise do the following.
    
  
    Construct the projection $L{\restriction_B}$ and apply Algorithm~$\mathfrak{A_0}(\mathfrak{D})$ to it (with respect to the partition $A=A_1\cup\dots\cup A_k$). 
    
    Let $\Tilde{N}$ be the result high level WF-net over the set $\Tilde{A}$ of sub-process names,  $N_{i_1},\dots, N_{i_j}$ --- result WF-nets for sub-processes with names $\alpha_{i_1},\dots, \alpha_{i_j}$ respectively (for each $\alpha_i$, such that $A_i\subseteq B$, \ie for sub-processes  within the loop body), and let $\beta$  be a new name. Then
    \begin{itemize}
        \item 
        For each $\beta'\in \Tilde{B}$, if there is a transition labeled by $\beta'$ in some of %result subprocess WF-nets 
        $N_{i_1},\dots, N_{i_j}$ or $\Tilde{N}$, replace this transition with  sub-process $\Loop(\ell_B(\beta'))$, as was done when constructing  a flat WF-net in Subsection~\ref{subsec:HWF}, \ie substitute inner loops in the loop body. Remove $\beta'$ from $\Tilde{A}$, $\Tilde{B}$ and from the domains of $\ell$ and $\ell_B$.
        \item
        Add $\beta$ to $\Tilde{B}$ and extend $\ell_B$ by defining $\ell_B(\beta) = \Tilde{N}$.
    Extend also $\ell$ by defining $\ell(A_{i_1}) = N_{i_1}, \dots, \ell(A_{i_j}) = N_{i_j}$.
        \item
    Replace by $\beta$ all occurrences of activities from $B$ in $L$ and remove stuttering.
        \item 
    If for some $i\in [1\dots k]$, $B\subseteq A_i$, then add $\beta$ to $A_i$ (and respectively to $A$) as one more activity. Otherwise, add $\beta$ to $A$, as well as add  $\{\beta\}$ to partition of $A$. (Thus, $\beta$ is both an activity and a process name, which  should not be confusing.)
    \end{itemize}
    
    \emph{Repeat Step 1}.
     
\item[\textit{Step 2.}] 
Apply Algorithm~$\mathfrak{A_0}(\mathfrak{D})$ to  current log $L$ with respect to the current partition of activities. Let $\Tilde{N}$ be a result high level WF-net.

\item[\textit{Step 3.}] 
While $\Tilde{B}$ is not empty, for each $\beta\in \Tilde{B}$,
 replace a transition labeled by $\beta$ in $\Tilde{N}$ with the sub-process $\Loop(\ell_B(\beta))$, as it is done in Step 1.
    \end{enumerate}
The resulting net $\Tilde{N}$ is a high-level WF-net for the HWF-net constructed by the Algorithm. Its low-level WF-nets are defined by function $\ell$, also built during the Algorithm operation. 
    
%is an upper level WF-net, where  is a bijective transition labeling function, which assigns subprocess names to transitions in $\Tilde{N}$;
   % \item $N_i = (P_i, T_i, F_i, \lambda_i, [i]_i)$ is a low level WF-net for every $i \in [1, 2, \dots, k]$ with a a \textcolor{red}{total} transition labeling function $\lambda_i \colon T_i \to A_i$, where $A_i \subseteq A$ is a corresponding subset of low level activities;
 %   \item $\ell \colon N_i \to \Tilde{A}$ is a bijection which establish the correspondence between a subprocess name (transition in an upper level WF-net) and a low level WF-net.

\bigskip

\textit{Correctness of the Algorithm~$\mathfrak{A}(\mathfrak{D})$} is justified by the following statement.

\begin{thm}
Let $A$ be a set of activities and $L$ --- a log over $A$. Let also $A=A_1\cup\dots\cup A_k$ be a partition of $A$, % where for $i\in [1\dots k]$, $A_i$ is a set of activities of a subprocess $\alpha_i$ 
and $\Tilde{A}= \{\alpha_1, \dots, \alpha_k\}$ --- a set of sub-process names.

If Algorithm $\mathfrak{D}$ for any log $L'$ discovers a WF-net $N'$, such that $N'$ perfectly fits $L'$,
then Algorithm $\mathfrak{A}(\mathfrak{D})$  constructs a HWF-net $\mathcal{N} = (\Tilde{N}, N_1, N_2, \dots, N_k,\ell)$, such that 
%for $\Tilde{N} = (\Tilde{P}, \Tilde{T}, \Tilde{F}, \Tilde{\lambda}, \Tilde{[i]})$,  transitions in $\Tilde{N}$ are labeled with names of subprocesses from $\Tilde{A}$, \ie  $\Tilde{\lambda} \colon \Tilde{T} \to \Tilde{A}$; for each $\alpha_i\in \Tilde{A}$, $\ell(\alpha_i) = N_i$, \ie subprocess name $\alpha_i$ corresponds to the low level WF-net $N_i$ in $\mathcal{N}$; 
$\mathbf{fl}(\mathcal{N})$ perfectly fits $L$.
\end{thm}


\begin{proof}
To prove that the HWF-net built using Algorithm $\mathfrak{A}(\mathfrak{D})$ perfectly fits the input log, provided that Algorithm $\mathfrak{D}$ discovers models with perfect fitness, we use three previously proven assertions.  Namely, 
\begin{itemize}
    \item
    Theorem in \cite{begicheva2017discovering} states that when $\mathfrak{D}$ is an discovery algorithm with perfect fitness, Algorithm~$\mathfrak{A}_0(\mathfrak{D})$ discovers a high-level WF-net, whose refinement perfectly fits the input log without repetitions (\ie  the log of an acyclic process).
    \item
    In \cite{tapia2017discovering} it is proved  that, given a log  $L$, Algorithm $\mathfrak{B}$ correctly finds in $L$ all repetitive components that correspond to supports of T-invariants in the Petri net model for $L$.
    \item
    Proposition~\ref{prop:conn} in Subsection~\ref{subsec:HWF} justify correctness of refining a high-level WF-net by substituting sub-process modules for high-level transitions.
\end{itemize}

With all this, proving the Theorem is straightforward, though quite technical. So, we informally describe the logic of the proof here.

Let 
Algorithm~$\mathfrak{D}$ be a discovery algorithm, which discovers a perfectly fitting WF-net for a given event log.

At each iteration of Step~1, an inner elementary repetitive component in the log is discovered  using Algorithm $\mathfrak{B}$. Activities of this component are activities of an inner loop body, which itself does not  have repetitions. Then a WF-net $N$ for this loop body is correctly discovered using Algorithm~$\mathfrak{A}_0(\mathfrak{D})$, the  loop itself is folded into one high-level activity $\beta$, and $N$ is kept as the value $\ell_B(\beta)$. WF-nets for sub-processes within the body of this loop are also discovered by Algorithm~$\mathfrak{A}_0(\mathfrak{D})$ and accumulated in $\ell$.
If  loop activity $\beta$ is itself within  an upper loop body, then with one more iteration of Step 1, the upper loop $N'$ is discovered, the transition labeled with $\beta$ in it is replaced with $N$, and $N'$ is itself folded into a new activity. 

After processing all loops, the Algorithm proceeds to Step 2, where after reducing all loops to high-level activities, Algorithm~$\mathfrak{A}_0(\mathfrak{D})$ is applied to a log without repetitions.

In Step 3 all transitions labeled with loop activities in a high-level and low-level WF-nets are replaced by WF-nets for these loops, kept in $\ell_B$.

So, we can see that while Algorithm~$\mathfrak{A}_0(\mathfrak{D})$ ensures perfect fitness between acyclic fragments of the model (when loops are folded to transitions), Algorithm $\mathfrak{B}$ ensures correct processing of cyclic behavior, and Proposition~\ref{prop:conn} guarantees that replacing loop activities by corresponding loop WF-nets does not violate fitness, the main algorithm provides systematic log processing and model construction.
\end{proof}

\section{Experimental Evaluation}\label{evaluation}
%\subsection{Implementation}\label{subsec8}

In this section, we report the main outcomes from a series of experiments conducted to evaluate the algorithm for discovering two-level hierarchical process models from event logs.

To support the automated experimental evaluation, we implemented the hierarchical process discovery algorithm described in the previous section using the open-source library PM4Py \cite{berti2019process}.
The source files of our implementation are published in the open GitHub repository \cite{ExRepo}.
We conducted experiments using two kinds of event logs:
\begin{enumerate}
    \item \emph{Artificial} event logs generated by manually prepared process models;
    \item \emph{Real-life} event logs provided by various information systems.
\end{enumerate}

Event logs are encoded in a standard way as XML-based XES files.

\emph{Conformance checking} is an important part of process mining along with process discovery \cite{Carmona18}.
The main aim of conformance checking is to evaluate the quality of process discovery algorithm by estimating the corresponding quality of discovered process models.
Conformance checking provides four main quality dimensions.
\emph{Fitness} estimates the extent to which a discovered process model can execute traces in an event log. 
A model perfectly fits an event log if it can execute all traces in an event log.
According to Theorem 1, the hierarchical process discovery algorithm yields perfectly fitting process models.
\emph{Precision} evaluates the ratio between the behavior allowed by a process model and not recorded in an event log. 
A model with perfect precision can only execute traces in an event log. The perfect precision limits the use of a process model since an event log represents only a finite ``snapshot'' of all possible process executions. 
Generalization and precision are two dual metrics. 
The fourth metric, \emph{simplicity}, captures the structural complexity of a discovered model.
We improve simplicity by the two-level structure of a discovered process models.

Within the experimental evaluation, we estimated fitness and precision of process models discovered from artificially generated and real-life event logs.
Fitness was estimated using alignments between a process model and an event log as defined in \cite{adriansyah2011conformance}.
Precision was estimated using the complex ETC-align measures proposed in \cite{munoz2010fresh}.
Both measures are values in the interval $[0, 1]$.

\subsection{Discovering HWF-Nets from Artificial Event Logs}
The high-level source for generating artificial low-level event logs was the Petri net earlier shown in Figure \ref{fig:petrinet}.
In this model, we refined its transitions with different sub-processes containing sequential, parallel and cyclic executions of low-level events.
The example of refining the Petri net from Figure \ref{fig:petrinet} is shown in Figure \ref{fig:llclassic}, where we show the corresponding flat representation of an HWF-net.

\begin{figure}[!h]
        \centering
    \includegraphics[width=\textwidth]{llclassic.pdf}
    \caption{A flat WF-net with generated by refining  the WF-net in~Fig.~\ref{fig:petrinet}}
    \label{fig:llclassic}
\end{figure}

Generation of low-level event logs from the prepared model was implemented using the algorithm presented in \cite{Gena2014}.
Afterwards, we transform a low-level event log into a high-level event log by grouping low-level events into a single high-level event and by extracting the information about cyclic behavior.

The corresponding high-level WF-net discovered from the artificial low-level event log generated from the WF-net shown in \ref{fig:llclassic} is provided in Figure \ref{fig:final_net}.
Intuitively, one can see that this high-level WF-net is rather similar to the original Petri net from Figure \ref{fig:petrinet}.

\begin{figure}[!h]
        \centering
    \includegraphics[width=\textwidth]{final_net_ind.pdf}
    \caption{A high-level WF-net discovered from an event log generated by refining the WF-net in Fig.~\ref{fig:llclassic}}
    \label{fig:final_net}
\end{figure}

As for the quality evaluation for the above presented high-level model, we have the following:
\begin{enumerate}
    \item The discovered high-level WF-net perfectly fits the high-level event log obtained from a low-level log, where we identified cycles and grouped activities correspondingly.
    \item The flat WF-net obtained by refining transitions in a discovered high-level WF-net almost perfectly fits ($0.9534$) a low-level log. The main reason for this is the combination of the coverability lack and the straightforward accuracy indicators of the algorithm.
    \item Precision of the flat WF-net is $0.3729$, which is the result of identifying independent sub-processes generalizing the behavior recorded in an initial low-level event log.
\end{enumerate}

Other examples of process models that were used for the artificial event log generation are also provided in the main repository \cite{ExRepo}. 

\subsection{Discovering HWF-Nets from Real-Life Event Logs}

We used two real-life event logs provided by \emph{BPI} (Business Process Intelligence) \emph{Challenge} 2015 and 2017 \cite{bpiData}.
These event logs were also enriched with the additional statistical information about flat process models.

The \emph{BPI Challenge 2015} event log was provided by five Dutch municipalities.
The cases in this event log contain information on the main application and objection procedures in various stages.
A flat low-level WF-net for case $f1$ discovered using the Inductive miner is shown in Figure \ref{fig:initial_net_BPIC151}.
It is easy to see that this model is absolutely inappropriate for the visual analysis.

\begin{figure}[!h]
        \centering
    \includegraphics[width=\textwidth]{initial_net_BPIC151_ind.pdf}
    \caption{A flat WF-net discovered from BPI Challenge 2015 event log}
    \label{fig:initial_net_BPIC151}
\end{figure}

The code of each event in the \emph{BPI Challenge 2015} event log consists of three parts: two digits, a variable number of characters, and three digits more. 
From the event log description we know that the first two digits and the characters indicate the sub-process the event belongs to, which allows us to assume an option of identifying the sub-processes. 
We used the first two parts of the event name to create the mapping between low-level events and sub-proces names. 
After applying our hierarchical process discovery algorithm in combination with the Inductive Miner, we obtained a high-level model presented in Figure \ref{fig:hl_net_BPIC151} that is far more comprehensible than the flat model mainly because of its size.

\begin{figure}[!h]
        \centering
    \includegraphics[width=0.8\textwidth]{BPIC15_hl_net_ind.pdf}
    \caption{A high-level WF-net discovered from the 'BPI Challenge 2015' event log}
    \label{fig:hl_net_BPIC151}
\end{figure}

The \emph{BPI Challenge 2017} event log pertains to a loan application process of a Dutch financial institute. 
The data contains all applications filed trough an online system from 2016 till February of 2017. 
Here, as a base for mapping low-level events to sub-proces names, we used the mark of the event type in its name --- application, offer or workflow.
Thus, a mapping could be based on various features of event data dependint on the expert's needs. 
The flat model for this data is presented in Figure \ref{fig:initial_net_BPIC17}, which is also difficult to read because of  its purely sequential representation.
\medskip

\begin{figure}%[!h]
        \centering
    \includegraphics[width=\textwidth]{initial_net_BPIC17_ind.pdf}
    \caption{A flat WF-net discovered from the 'BPI Challenge 2017' event log}
    \label{fig:initial_net_BPIC17}
\end{figure}

Applying the  principle of mapping low-level events in the \emph{BPI Challenge 2017} event log  described above, we obtained the high-level WF-net shown in Fig.~\ref{fig:hl_net_BPIC17}, which clearly demonstrates sub-processes (if necessary, they can be expanded) and their order.
\bigskip

\begin{figure}%[!h]
        \centering
    \includegraphics[width=0.34\textwidth]{BPIC17_hl_net_ind.pdf}
    \caption{A high-level WF-net discovered from the 'BPI Challenge 2017' event log}
    \label{fig:hl_net_BPIC17}
\end{figure}

Table \ref{tab:rlq} shows fitness and precision evaluation for flat and high-level WF-nets discovered from real-life \emph{BPI Challenge 2015} and \emph{2017} event logs.

\medskip

\begin{table}[!h]
	\centering
	\caption{Comparing metrics for  flat and high-level WF-nets discovered from 'BPI Challenge' event logs}\label{tab:rlq}
	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
        \multirow{2}{*}{Event log} & \multicolumn{3}{|c|}{High-level WF-net} & \multicolumn{2}{|c|}{Flat WF-net} \\ \cline{2-6}
        & Fitness 1 & Fitness 2& Precision & Fitness & Precision \\ \hline
        BPI Challenge 2015 & 0.9122 & 1 & 0.5835 & 0.9700 & 0.5700 \\ \hline
        BPI Challenge 2017 & 0.9393 & 1 & 0.3898 & 0.9800 & 0.7000 \\ \hline
	\end{tabular}
\end{table}

\emph{Fitness 1} shows the fitness evaluation between the flat WF-net constructed from the high-level WF-net by refining transitions with low-level subprocesses.
\emph{Fitness 2} shows the fitness evaluation between the high-level WF-net and an event log with low-level events grouped into sub-processes.
This confirms the formal correctness results of the hierarchical process discovery algorithm.
Similar to the experimental results for artificial event logs, here we also observe a decrease in the precision for the identification of sub-processes, therefore, generalizing traces in an initial low-level event log.

%The algorithm presented in this work was implemented on the base of the open-source library PM4Py \cite{berti2019process}. We evaluated the quality of the models created by the algorithm using artificial and real-life data sets and compared the results.
 
%The PM4Py framework was created to fill up the gap in process mining software instruments which were either massive and not easily customized or extendable, or not allowed someone to easily conduct large-scale experiments. PM4Py provides for developers a strict separation of visualization components from algorithms and objects, and some basic process mining algorithms (other actual algorithms are implemented by the community as needed). 
 
%Event logs are given as the input in the form of XES files (eXtensible Event Stream \cite{acampora2017ieee}) format. 

%PM4Py provides the function to extract strongly connected components from a graph, but there are not so many types of graphs already implemented in objects, so the procedure which builds the causality graph of the log was also implemented by us in the cycles-oriented class.  

%During the work the event partitioning function was implemented: it reads low-level events to high-level events mapping from the JSON file, example of such file is presented as Example JSON Event Partitioning in Appendix. Functions for removing events stuttering and any event log transformation from a low-level form to a more abstract one also were implemented to have a full package of necessary methods.  

%The implementation of the solution is presented in the public GitHub repository: https://github.com/gingerabsurdity/hldiscovery.


%\subsection{Experimental Setup}\label{subsec9}
%In order to test the results of work of the proposed algorithm in practice, a number of experiments were conducted to check conformance of the high-level model with the event logs that were generated by the low-level model of the same process. In real conditions, the process of recording the log does not always pass without interference, various external interventions are also possible in the execution of the process itself, but for the needs of confirming the process extraction algorithm, checking the preservation of perfect fitness when converting the log to a low-level view is mandatory.

%Logs were generated according to the model shown in Figure \ref{fig:llclassic}, that is an example of low-level model from Figure \ref{fig:petrinet}. The event logs needed for analysis were obtained as a result of the operation of the Gena 2 software product for generating logs, the principle of its operation is described in \cite{pertsukhov2019simulating}. Then, the received logs were provided as input to the algorithm implementation written in Python using the PM4Py library. We propose several python submodules: for the Algorithm~$\mathfrak{A_0}(\mathfrak{D})$ and Algorithm $\mathfrak{A}$, and, also we implement the Algorithm $\mathfrak{B}$ from \cite{tapia2017discovering} to extract information about cycles from event log. After applying algorithms submodules we obtain a high-level log which could be given as input to one of the process discovery methods. In the PM4Py library the more sustainable one is Inductive Miner, so we use it for our evaluation.

%As a result of high-level net discovering for logs, generated by model from Figure \ref{fig:llclassic} we obtained the model that is quite similar to the one from Figure \ref{fig:petrinet}. This net is presented on Figure \ref{fig:final_net}.

%To check the conformance of resulting logs with an initially created model we need to replay the resulting traces on the model using the alignment technique defined in \cite{adriansyah2011conformance}. For each trace, four values have to be determined: produced tokens, remaining tokens, missing tokens, and consumed tokens. Based on that, a formula can be derived, whereby a Petri net $N$ and a trace $\sigma$ are given as input: $fitness(\sigma,N)=1/2*(1-m/c)+1/2*(1-r/p), fitness \in [0,1]$. Note, that in the cycle extraction algorithm from \cite{tapia2017discovering} uses one of basic realization of some miner to build a relations matrix. So, the coverability of initial log affects the defining boundaries accuracy of cycles. For precision $precision(\sigma,N) \in [0,1]$, we use the ETC-align measure that is defined in \cite{munoz2010fresh}.

%The resulting row for generated by the model from Figure \ref{fig:llclassic} is presented in Table, which also summarises the results of real data evaluation. For each data set (Data) we show the $F1$ value -- a fitness between final high-level log and corresponding final model, as a reference data, that shows the perfect fitness. $F2$ shows a fitness value that is calculated taking into account unfolding of abstract events to low-level. Also we fixed information about logs number and traces number in them. For artificially generated data we calculate mean value for fitness and precision score. A little deviation from 1 in the $F@$ value is caused by combination of coverability lack and the straightforward miners accuracy indicators.


%link to table: https://docs.google.com/document/d/1ozivKIlTFSsWmhkMVZ09Ya-lyl5-RIJpOGGhizUFY0Q/edit

%\subsection{Real Datasets}\label{subsec10}

%As a real data example, we use data from filtered logs from the  BPI Challenge 2015 and 2017 \cite{augusto2018automated}, because there is statistical information about flat models for these event logs and it could be used as a benchmark. Results of evaluation are also in the Table, in corresponding rows. For these data we also have two columns with fitness and precision values for flat discovery algorithms, fixed in \cite{augusto2018automated},

%The BPI Challenge 2015 data provided by five Dutch municipalities. The cases in the log contain information on the main application as well as objection procedures in various stages. Using InductiveMiner to synthesize a flat process model for case f1 data we could obtain the model from Figure \ref{fig:initial_net_BPIC151}

%Each activity code consists of three parts: two digits, a variable number of characters, and then three digits. From the log description we know that the first two digits as well as the characters indicate the subprocess the activity belongs to, that allows us to assume an option separation of all processes into subprocesses. We used the first two parts of the event name to create events - subprocesses mapping. After applying our algorithm in combination with InductiveMiner as a last step, we obtain a model which is presented on Figure … that is much more readable because of its size.

%\begin{figure}[!h]
%    \caption{The high-level model for BPI Challenge 2015 data}
%    \centering
%    \includegraphics[width=\textwidth]{BPIC15_hl_net_ind.png}
%    \label{fig:initial_net_BPIC151}
%\end{figure}

%The BPI Challenge 2017 event log pertains to a loan application process of a Dutch financial institute. The data contains all applications filed trough an online system from 2016 till February of 2017. Here as a base for events to subprocesses mapping we used the event type mark in the name of event (application, offer or workflow), to show that mapping could be based on every feature of data depends on expert's needs. The flat model for this data is on Figure \ref{fig:initial_net_BPIC17} and the final abstract one is presented on Figure \ref{fig:initial_net_BPIC17}.

%\begin{figure}[!h]
%    \caption{The flat model for BPI Challenge 2017 data}
%    \centering
%    \includegraphics{initial_net_BPIC17_ind.svg }
%    \label{fig:initial_net_BPIC17}
%\end{figure}

\section{Conclusion and Future Work}\label{sec7}
%Information systems usually generate detailed event logs, which are not easy to work with. Detailed models discovered from these logs are often intricate and confusing. Abstract and hierarchical models are much more clear and more convenient for experts. The problem of discovering abstract process models from existing detailed event logs is important for simplification of the experts' work on analysis and enhancement of information systems.

In this research, we provide a new process discovery technique for solving the problem of discovering a hierarchical WF-net model from a low-level event log, based on ``folding'' sub-processes into high-level transitions according to event clustering. Unlike the previous solutions, we allow cycles and concurrency in process behavior. 

We prove that the proposed technique makes it possible to obtain hierarchical models, which fit event logs perfectly. The technique was also evaluated on artificial and real event logs. Experiments show that fitness and precision of obtained hierarchical models are almost the same as for the standard ``flat'' case, while hierarchical models are much more compact, more readable and more visual.

To implement our algorithm and check it on real data we used \emph{Python} and one of the most convenient instruments for process mining at the moment --- the \emph{PM4Py} \cite{berti2019process}. The implementation  is provided in the public \emph{GitHub} repository \cite{ExRepo}.

In further research, we plan to develop and evaluate various event clustering methods for automatic discovery of hierarchical models.

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%
 \bibliographystyle{elsarticle-num} 
 \bibliography{references}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

% \begin{thebibliography}{00}

% %% \bibitem{label}
% %% Text of bibliographic item

% \bibitem{}

% \end{thebibliography}
\end{document}
\endinput
%%
%% End of file `elsarticle-template-num.tex

