
\section{Evaluated Stream Processing Frameworks}\label{sec:frameworks}

In their textbook, \citet{Bellemare2020} distinguishes between lightweight and heavyweight stream processing frameworks.
Lightweight frameworks are embedded as a programming library into the source code of independently deployable components such as microservices.
This way, the stream processing framework does not require any specific way to build or deploy the microservice. This allows the service to also perform other tasks beyond stream processing such as providing a REST API. Individual instances of a service discover each other (e.g., via features of the messaging system or Kubernetes) and perform the necessary coordination internally.
Heavyweight frameworks on the contrary are provided as deployable software systems, which can be configured by one or more stream processing jobs to be executed. They are typically designed as a master--worker architecture. In this study, we mainly focus on lightweight frameworks.
All modern stream processing frameworks can be deployed containerized on commodity hardware with Kubernetes.
In the following, we give a brief overview of frameworks, particularly suited to be deployed as microservices and which we decided to benchmark in this study.
For a detailed comparison of the framework's features, see the works of, for example, \citet{Hesse2015}, %
\citet{Fragkoulis2023}, and \citet{vanDongen2021c}.




\paragraph{Apache Flink}
Originating from a scientific research project~\cite{Alexandrov2014}, Apache Flink~\cite{Carbone2015} has been extensively used, evaluated, and extended in research and became increasingly popular in industry.
It offers one of the most elaborated dataflow models, providing precise control of time and state~\cite{Carbone2015,Carbone2017,Akidau2021}.
Moreover, Flink provides different abstraction layers and a rich feature set regarding the integration with external systems.
Flink clearly falls into the category of heavyweight frameworks~\cite{Bellemare2020}. Its deployment consists of one or---for fault-tolerance---more coordinating \textit{JobManagers} and a scalable amount of \textit{TaskManagers}.
Although heavyweight, we consider Flink in this study due to its widespread adoption and since we observe recent trends to more lightweight deployments of Flink.

\paragraph{Apache Kafka Streams}
Kafka Streams~\cite{Sax2018,Wang2021} is a stream processing framework built on top of Apache Kafka.
It is available as a Java library and, thus, aligns with the idea of incorporating stream processing in standalone microservices.
Compared to most other stream processing frameworks, it has a restricted set of features, in particular, concerning the integration with external systems.
Kafka Streams only supports Kafka topics as data sources and sinks.
Integrating external systems always requires transferring data via Kafka topics.

\paragraph{Apache Samza}
Similar to Kafka Streams, Apache Samza~\cite{Noghabi2017} can be embedded as a library in standalone applications. Individual instances of the same application use Apache Zookeeper and Apache Kafka for coordination, data transfer, and fault tolerance.
Although still maintained, Samza is sometimes considered a predecessor of Kafka Streams~\cite{Kleppmann2015}.
In this study, we use Samza as a runner for Apache Beam pipelines (see below), which allows implementing more complex use cases~\cite{Zhang2020}. 

\paragraph{Hazelcast Jet}
Hazelcast Jet~\cite{Gencer2021} is a stream processing framework built on top of the Hazelcast IMDG distributed, in-memory object store.
It can be embedded into Java applications and does not have any dependencies on an external system.
Instead, individual instances discover each other, form a cluster, and handle coordination and data replication internally.
Hazelcast Jet differs from other frameworks in its execution model, which is based on a concept similar to coroutines and cooperative threads~\cite{Gencer2021}.
With the release of Hazelcast~5.0 in 2021, Hazelcast Jet has been merged with Hazelcast IMDG into one unified product.

\paragraph{Apache Beam}

Apache Beam is not a stream processing system by itself, but instead, an SDK to implement stream processing jobs in a uniform model, which can be executed by several modern stream processing systems.
Apache Beam implements Google's Dataflow model \cite{Akidau2015}, which is also internally used by Google's cloud service \textit{Google Cloud Dataflow}.
A stream processing job implemented with Apache Beam is executed by a so-called runner. Runners can be seen as adapters for the actual stream processing systems. Besides a runner for Google Cloud Dataflow, Apache Beam provides also runners for several other systems, including the aforementioned Apache Flink, Apache Samza, and Hazelcast Jet.
Previous research found that using Apache Beam as an abstraction layer comes with a significant negative impact on performance~\cite{Hesse2019}.

\paragraph{Other Stream Processing Frameworks}
Apache Spark \cite{Zaharia2016}, Apache Storm \cite{Toshniwal2014}, and the successor of the latter, Apache Heron \cite{Kulkarni2015}, are considered heavyweight frameworks and, thus, fit less into the context of microservices~\cite{Bellemare2020}.
Spark differs from the frameworks discussed before in that it processes data streams in ``micro-batches''.
Storm and Heron provide less sophisticated programming models and weaker fault tolerance mechanisms~\cite{Fragkoulis2023}.
Moreover, there are several cloud services available for stream processing, which, however, are out of scope of our study.

