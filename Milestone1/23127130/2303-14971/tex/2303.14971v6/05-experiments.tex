In this section, we experimentally evaluate the impact of different
CNF-izations on the disjoint and non-disjoint AllSAT %\ignoreinshort{%} 
%\ignoreinshort{
and AllSMT tasks. In order to compare them on fair ground, we have implemented
a base version of each from scratch in
PySMT~\cite{garioPySMTSolveragnosticLibrary2015}, avoiding specific
optimizations done by the solvers.%}
%\ignoreinshort{

We have conducted a very extensive collection of experiments on AllSAT and
AllSMT. We tested the encodings on \mathsat{}, which supports disjoint
    and non-disjoint AllSAT and AllSMT, and on \tabularallsat{} and \tabularallsmt{}, which support
    disjoint AllSAT and AllSMT, respectively. 
%  Unfortunately, to the best of our knowledge, there is no other available solver that allows us to test different CNF encodings for AllSAT and AllSMT, i.e., that allows performing projected enumeration of partial truth assignments for CNF formulas.\@ In~\sref{sec:survey-allsat-solvers} we present a survey of other candidate solvers, and the reasons why they are not suitable for our experiments.\@ %}
The choice of the solvers is motivated in~\sref{sec:survey-allsat-solvers}; the
benchmarks are described in~\sref{sec:experiments:benchmarks},
the information for the reproducibility of the experiments is given in \sref{sec:experimentsdata},
and the results
are presented in~\sref{sec:experiments:results};
finally, in \sref{sec:experiments:others} we analyze and discuss the
application of the encodings to related fields.
% \ignoreinlong{We used \mathsat{}~\cite{mathsat5_tacas13} as a SAT \ignoreinshort{\GMCHANGE{and \smt{}}} enumerators, because it implements the enumeration strategy by~\citeA{lahiriSMTTechniquesFast2006} described in~\sref{sec:background:allsat}.\@}
%To compute a set \TA{}, we invoked \mathsat{} with the following options: \textsf{-dpll.allsat\_allow\_duplicates=false} (assignments must be pairwise disjoint), \textsf{-dpll.allsat\_minimize\_model=true} (assignments are minimal), \textsf{-preprocessor.simplification=0} and \textsf{-preprocessor.toplevel\_propagation=false} (disable several non-validity-preserving preprocessing steps).
% \ignoreinlong{
%     We set the options \textsf{-dpll.branching\_initial\_phase=0} to split on the false branch first and \textsf{-dpll.branching\_cache\_phase=2} to enable phase caching.}

%     \ignoreinshort{\GMCHANGE{

% \begin{gmchangep}
\subsection{An analysis of available solvers}%
\label{sec:survey-allsat-solvers}
% table reporting: solver name + citation | input cnf | projected | partial assignments | disjoint | non-disjoint | code available | notes
%
%%%% moved to appendix
%\input{tools-table}
%
In order to evaluate the different CNF encodings, we need an AllSAT/AllSMT
solver that
\begin{enumerate*}[(i)]
    \item\label{item:tool:avail} is publicly available,
    \item\label{item:tool:cnf} takes as input a CNF formula,
    \item\label{item:tool:proj} allows performing {\em projected} enumeration,
    \item\label{item:tool:part} allows enumerating (disjoint or
      non-disjoint) {\em partial} truth assignments;
      \item\label{item:tool:minimal} also, the ability of producing \emph{minimal} assignments is valuable although not necessary.
%    even minimal ones \item\label{item:tool:minimal} if possible. 
% \item\label{item:tool:minimal} produces {\em minimal} partial assignments (when possible) .
      % \RSCHANGE{(even {\em minimal}
      % ones if possible)}.
\end{enumerate*}
% If  
%     \item\label{item:tool:minimal} produces {\em minimal} partial assignments.

%In order to test different CNF encodings for SAT and SMT enumeration, 
In the literature, we found the following candidate solvers: for AllSAT, we
found
% 1997
\textsc{RELSAT}~\cite{bayardoUsingCSPLookback1997},
% 2004
\textsc{Grumberg}~\cite{grumbergMemoryEfficientAllSolutions2004}, \textsc{SOLALL}~\cite{liNovelSATAllsolutions2004},
% 2005
\textsc{Jin}~\cite{jinEfficientConflictAnalysis2005,jin2005prime},
% 2007
\textsc{clasp}~\cite{gebserConflictDrivenAnswerSet2007},
% 2008
\textsc{PicoSAT}~\cite{bierePicoSATEssentials2008},
% 2014
\textsc{Yu}~\cite{yuAllSATUsingMinimal2014},
% 2016
\textsc{BC}, \textsc{NBC}, and \textsc{BDD}~\cite{todaImplementingEfficientAll2016},
% 2017
\textsc{depbdd}~\cite{todaExploitingFunctionalDependencies2017},
% 2018
\textsc{Dualiza}~\cite{mohleDualizingProjectedModel2018},
% 2020
\textsc{BASolver}~\cite{zhangAcceleratingAllSATComputation2020},
% 2022
\textsc{AllSATCC}~\cite{liangAllSATCCBoostingAllSAT2022},
% 2023
\textsc{HALL}~\cite{friedAllSATCombinationalCircuits2023,friedEntailingGeneralizationBoosts2024},
\tabularallsat~\cite{spallittaDisjointPartialEnumeration2024,spallittaDisjointProjectedEnumeration2024},
and \decdnnf~\cite{lagniezLeveragingDecisionDNNFCompilation2024}.
For AllSMT, the only candidates are
% 2013
\mathsat{}~\cite{mathsat5_tacas13},
% 2015
\textsc{aZ3}~\cite{phanAllSolutionSatisfiabilityModulo2015}, and
\tabularallsmt{}~\cite{spallittaDisjointProjectedEnumeration2024}.

In Appendix~\ref{appendix:tooltable} \Cref{tab:allsat-solvers} we report an
analysis of the above features \ref{item:tool:avail}-\ref{item:tool:minimal}
for each of the above-mentioned solvers. Overall, we observe that only
    four solvers match all our needs: \mathsat{}, \tabularallsat{}, \tabularallsmt{}, and
    \textsc{Dualiza}. \mathsat{} supports disjoint and non-disjoint AllSAT and
    AllSMT enumeration of minimal partial assignments, using the
    blocking-clause-based enumeration strategy
    by~\citeA{lahiriSMTTechniquesFast2006} described
    in~\sref{sec:background:allsat}. \tabularallsat{} supports disjoint AllSAT
    enumeration of non-minimal partial assignments, based on chronological
    backtracking without blocking
    clauses~\cite{spallittaDisjointPartialEnumeration2024,spallittaDisjointProjectedEnumeration2024}.
    \tabularallsmt{}, its counterpart for AllSMT, supports disjoint AllSMT.
    \textsc{Dualiza} supports disjoint and non-disjoint AllSAT enumeration of
    non-minimal partial assignments, based on dual reasoning. Since
    \textsc{Dualiza} has been shown empirically to perform
    poorly~\cite{friedEntailingGeneralizationBoosts2024}, we decided to leave it
    out of our experiments, and to focus on \mathsat{}, \tabularallsat{}, and \tabularallsmt{} only.
%Overall, we observe that the only solver that matches all our needs is
%\mathsat{}, both for AllSAT and AllSMT.\@
% \ignore{For AllSAT, a possible alternative would be \textsc{Dualiza},
%     % but its enumeration strategy %does not match properties~\ref{item:mumodelsvi}-\ref{item:muAminimal} 
%     % is different from the one described in~\sref{sec:background:allsat} since it is based on dual reasoning. %The \textsc{Grumberg} solver would match all the requirements, but it is not publicly available.
%     \GMCHANGE{but its enumerations strategy based on dual reasoning has
%         been shown empirically to perform poorly, since it requires studying both the satisfiability of the original formula and the unsatisfiability of its negation to retrieve partial assignments.}
%     For AllSMT, the only alternative is \textsc{aZ3}, but it only
%     enumerates total truth assignments over the relevant atoms, which,
%     besides,  can only be Boolean atoms\footnote{Notice that even though
%         it is always possible to label a \T-atom $\alpha$ with a Boolean
%         atom $A$ as $(A\iff{}\alpha)$ and use $A$ as relevant atom, this
%         implicitly forces every partial assignment to assign a truth value
%         to $A$, for the same reasons that we analyzed
%         in~\sref{sec:problem:label} for the labels used by the Tseitin
%         encoding.}.
% }
% Notice that 7 solvers were not available, even after contacting the authors.
% \end{gmchangep}

\subsection{Description of the problem sets}%
\label{sec:experiments:benchmarks}
We consider %\ignoreinshort{\GMCHANGE{
five %}}\ignoreinlong{three} 
sets of benchmarks of non-CNF formulas coming from different sources, both synthetic and real-world.
% \ignoreinlong{
%     In the first set of benchmarks, we generate random Boolean formulas by nesting Boolean operators up to a fixed depth. The second problem set consists of Boolean formulas encoding properties of ISCAS'85 circuits~\cite{brglezNeutralNetlist101985,hansenUnveilingISCAS85Benchmarks1999,tibebuAugmentingAllSolution2018}. As a third set of problems, we consider formulas encoding Booleanized Weighted Model Integration (WMI) problems~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022}.
% }
% \begin{ignoreinshortenv}
%     \begin{gmchangep}
For AllSAT, we evaluate the different CNF encodings on three sets of
benchmarks. The first one consists of synthetic Boolean formulas, which were
randomly generated by nesting Boolean operators up to a fixed depth. The second
one consists of formulas encoding properties of ISCAS'85
circuits~\cite{brglezNeutralNetlist101985,hansenUnveilingISCAS85Benchmarks1999}
as done by~\citeA{tibebuAugmentingAllSolution2018}. The third one is a set of
benchmarks on combinatorial circuits encoded as And-Inverter Graphs (AIGs) used
by~\citeA{friedAllSATCombinationalCircuits2023}.

For AllSMT, we consider two sets of benchmarks. The first one consists of
synthetic \smtlarat{} formulas, which were randomly generated by nesting
Boolean and \smtlarat{} operators up to a fixed depth. The second one consists
of formulas encoding Weighted Model Integration (WMI)
problems~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022,spallittaEnhancingSMTbasedWeighted2024a}.

With respect to the conference version of the
paper~\cite{masinaCNFConversionDisjoint2023}, we have extended the set of
Boolean synthetic benchmarks and added the AIG benchmarks. Moreover, we have
added the \smtlarat{} benchmarks, and modified the WMI benchmarks so that they
contain also \larat{} atoms.

%     \end{gmchangep}
%   \end{ignoreinshortenv}

%\subsubsection*{The  Boolean synthetic benchmarks}
\paragraph{The  Boolean synthetic benchmarks.}
The Boolean synthetic benchmarks were generated by nesting Boolean operators
$\wedge, \vee, \iff$ until some fixed depth $d$. Internal and leaf nodes are
negated with $0.5$ probability. Operators in internal nodes are chosen
randomly, giving less probability to the $\iff$ operator. In particular, $\iff$
is chosen with $0.1$ probability, whereas the other two are chosen with an
equal probability of $0.45$. We generated 100 instances over a set of 20
Boolean atoms and depth $d=8$, 100 instances over a set of 25 Boolean atoms and
depth $d=8$, and 100 instances over a set of 30 Boolean atoms and depth $d=6$,
for a total of 300 instances. %\ignoreinshort{\GMCHANGE{, %}}

% \ignoreinshort{
% \GMCHANGEp{
% We have extended this set of benchmarks with respect to the conference version of the paper~\cite{masinaCNFConversionDisjoint2023}, where we used only the first 100 instances described above. %}%}.

\paragraph{The %\ignoreinlong{circuits}\ignoreinshort{\GMCHANGEp{
    ISCAS'85 %}} 
    benchmarks.}%
\label{sec:benchmarks:iscas}
The ISCAS'85 benchmarks are a set of 10 combinatorial circuits used in test generation, timing analysis, and technology mapping~\cite{brglezNeutralNetlist101985}. They have well-defined, high-level structures and functions based on multiplexers, ALUs, decoders, and other common building blocks~\cite{hansenUnveilingISCAS85Benchmarks1999}.
We generated random instances as described by~\citeA{tibebuAugmentingAllSolution2018}. In particular, for each circuit, we constrained 60\%, 70\%, 80\%, 90\%, and 100\% of the outputs to either 0 or 1, for a total of 250 instances.

% \begin{ignoreinshortenv}
%     \begin{gmchangep}
\paragraph{The AIG benchmarks.}
The AIG benchmarks are a set of formulas encoded as And-Inverter Graphs used
by~\citeA{friedAllSATCombinationalCircuits2023}. They consist of a total of 89
instances, subdivided into 3 groups: 29 instances encoding industrial Static
Timing Analysis (STA) problems containing up to $13000$ input variables, 40
instances from the ``arithmetic'' and ``random\_control'' benchmarks of the
EPFL suite~\cite{amaruEPFLCombinationalBenchmark2015a} ---combining the
multiple outputs with an \emph{or} or an \emph{xor} operator--- containing up
to 1200 input variables, and 20 instances consisting of large
randomly-generated AIGs containing up to 2800 input variables.

We notice that the discussed CNF encodings can be applied to AIGs as well, as
an AIG can be seen as a non-CNF formula involving only $\wedge$ and $\neg$
operators. Moreover, we store formulas as DAGs, so that the same sub-formula is
not duplicated multiple times, and the CNF encodings use the same Boolean atom
to label the different occurrences of the same sub-formula. Hence, all the
discussed CNF encodings result in a CNF formula of linear size w.r.t.\ the size
of the AIG.
% This is particularly important for AIGs, since the sharing of sub-formulas is at the core of their compactness.
%     \end{gmchangep}
% \end{ignoreinshortenv}

% \begin{ignoreinshortenv}
%     \begin{gmchange}
\paragraph{The \smtlarat{} synthetic benchmarks.} These problems were generated with the same procedure as
the Boolean ones, with the difference that atoms are randomly-generated
\smtlarat{} atoms over a set of $R$ real variables $\set{x_1, \dots, x_R}$, in
the form $(\sum_{i=1}^R a_i x_i \leq b)$, where each $a_i$ and $b$ are random
real coefficients. We generated 100 instances with depth $d=5$, 100 instances
with depth $d=6$, and 100 instances with depth $d=7$, all of them involving
$R=5$ real variables, for a total of 300 instances.
%     \end{gmchange}
% \end{ignoreinshortenv}

\paragraph{The WMI benchmarks.}
WMI problems were generated using the procedure described
by~\citeA{spallittaSMTbasedWeightedModel2022}. Specifically, the paper
addresses the problem of enumerating all the different paths of the weight
function by encoding it into a skeleton formula. Each instance consists of a
skeleton formula of a randomly-generated weight function, where the conditions
are random formulas over Boolean and \larat{}-atoms. Since the conditions are
typically non-atomic, the resulting formula is not in CNF, and thus we
preprocessed it with the different CNF-izations before enumerating its
\TA{\dots}. %\ignoreinlong{only over Boolean atoms}\ignoreinshort{\GMCHANGE{%}}. %\ignoreinlong{models}\ignoreinshort{\GMCHANGE{%}}.\@ \ignoreinlong{We generate 10 instances for each depth value 3, 5, 7, 9, each instance involving 10 Boolean atoms and no real variable, for a total of 40 problems.}
%\ignoreinshort{\GMCHANGE{
As done by~\citeA{spallittaSMTbasedWeightedModel2022}, we fixed the number of
Boolean atoms to 3, and the number of real variables to 3, and we generated 10
instances for each depth value 4, 5, 6, and 7, for a total of 40 problems.
%}}
% \ignoreinlong{We remark on two aspects of these benchmarks. First, we have chosen to have Boolean-only weight conditions in order to better analyze the capacity of Boolean reasoning of the solver with the different transformations, without additional factors brought by the SMT component. Nevertheless, we expect to have similar outcomes also for formulas involving both Boolean and $\smtlarat$ atoms. Notice that these can still be meaningful WMI instances, as the $\larat$ component may be constrained by the rest of the formula.}
% (i.e.\ the \emph{support} formula~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022})}. 
% \ignoreinlong{Second,}
% \GMNOTE{Togliere la frase qui sotto che usa notazione non spiegata?}
% \ignoreinshort{\GMCHANGE{We remark that}}
% these formulas contain existentially quantified $\euf$-atoms, so that we enumerate $\exists\ally.\vi(\allA,\ignoreinshort{\allx,}\ally)$ by projecting the \ignoreinlong{models  of $\vi$}\ignoreinshort{\GMCHANGE{assignments}} over the \ignoreinlong{relevant}\ignoreinshort{\GMCHANGEp{Boolean }}atoms $\allA$\ignoreinshort{\GMCHANGEp{\ and the \larat{}-atoms containing only variables in \allx}}~\cite{spallittaSMTbasedWeightedModel2022}.

% \ignoreinshort{
%     \GMCHANGEp{
% We have extended this set of benchmarks with respect to the conference version of the paper~\cite{masinaCNFConversionDisjoint2023}, where we restricted to Booleanized WMI problems.
%         }
%         }

\subsection{Information for the reproducibility of the experiments}
\label{sec:experimentsdata}
We ran \mathsat{} with the option \textsf{-dpll.allsat\_minimize\_model=true}
to enumerate minimal partial assignments. For disjoint and non-disjoint
enumeration, we set the options \textsf{-dpll.allsat\_allow\_duplicates=false}
and \textsf{-dpll.allsat\_allow\_duplicates=true}, respectively. We also set
\textsf{-preprocessor.simplification=0} and
\textsf{-preprocessor.toplevel\_propagation=false} to disable several
non-validity-preserving preprocessing steps.
%To use the heuristic discussed in~\sref{sec:problem:polarity}
%and~\sref{sec: solution}  to best exploit the properties of both
%Plaisted and Greenbaum encoding and our encoding,  
As discussed in~\sref{sec:problem:polarity} and~\sref{sec:solution}, we also
set the options \textsf{-dpll.branching\_initial\_phase=0} and
\textsf{-dpll.branching\_cache\_phase=2} to split on the false branch first but
enabling phase caching. \tabularallsat{} was run with default options,
    which include branching on the false branch first.
\tabularallsmt{} was run with the same options as \mathsat{} to disable preprocessing steps, since it uses \mathsat{} as a backend for theory reasoning. 
% }}
%\GMCHANGE{
%    We checked the results by ensuring that (a) $\muA\pmodels\vi$ for every $\muA\in\TA{\exists\allB.\vicnfgen}$; (b) for every $\etaA\in\TTA{\vi}$ there exists a $\muA\in\TA{\exists\allB.\vicnfgen}$ s.t. $\muA\subseteq\etaA$. This check was done only on the WMI benchmarks, because the problems in the other two groups of benchmarks had too many partial and total truth assignments to be checked in a reasonable time.
%}

% The code and the experiments are available at: \url{TODO}\\
All the experiments were run on an Intel Xeon Gold 6238R @ 2.20GHz 28 Core
machine with 128 GB of RAM, running Ubuntu Linux 20.04. For each problem set,
we set a timeout of 3600s. %}}.
%\ignoreinshort{\GMCHANGE{
Benchmarks, results, and source code are made available
  online on a Zenodo repository~\cite{masina_2024_cnf_results,masina_2024_cnf_code}.\@
    An updated version of the source code is available at \url{https://github.com/masinag/allsat-cnf}.


\subsection{Results}%
\label{sec:experiments:results}

\begin{figure}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \centering
        \includegraphics[height=2em]{plots/msat/bool/rep/all/legend.pdf}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:bool:norep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:norep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:norep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:bool:norep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:norep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/no-rep/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:norep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for disjoint enumeration.}%
        \label{fig:plt:all:bool:norep:scatter}
    \end{subfigure}
    %%%%%%%%%%%% REP %%%%%%%%%%%%%
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:bool:rep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:rep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:rep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:bool:rep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:rep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/bool/rep/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:bool:rep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for non-disjoint enumeration.}%
        \label{fig:plt:all:bool:rep:scatter}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        {\small
            \input{plots/msat/bool/timeouts.tex}
        }
        \caption{Number of timeouts.}%
        \label{tab:timeouts:bool}
    \end{subfigure}
    \caption{Results on the Boolean benchmarks using \mathsat{}.
            Scatter plots in~\ref{fig:plt:all:bool:norep:scatter} and~\ref{fig:plt:all:bool:rep:scatter} compare CNF-izations by \TAna{} size (first row) and execution time (second row).
            Points on dashed lines represent timeouts, summarized in~\ref{tab:timeouts:bool}.
            All axes use a logarithmic scale.}%
    \label{fig:plt:all:bool:scatter}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \centering
        \includegraphics[height=2em]{plots/tabularallsat/all/legend.pdf}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsat/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:bool:norep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for disjoint enumeration.}%
        \label{fig:plt:tabula:all:bool:norep:scatter}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        {\small
            \input{plots/tabularallsat/timeouts.tex}
        }
        \caption{Number of timeouts.}%
        \label{tab:timeouts:tabula:bool}
    \end{subfigure}
    \caption{Results on the Boolean benchmarks using \tabularallsat{}.
            Scatter plots in~\ref{fig:plt:tabula:all:bool:norep:scatter} compare CNF-izations by \TAna{} size (first row) and execution time (second row).
            Points on dashed lines represent timeouts, summarized in~\ref{tab:timeouts:tabula:bool}.
            All axes use a logarithmic scale.}%
    \label{fig:plt:tabula:all:bool:scatter}
\end{figure}

% \ignoreinlong{\cref{fig:plt:syn:bool:scatter,,fig:plt:circ:scatter,,fig:plt:wmi:scatter} show the results of the experiments on the synthetic, circuits and WMI benchmarks, respectively.}
% \ignoreinshort{\GMCHANGEp{
\cref{fig:plt:all:bool:scatter,fig:plt:tabula:all:bool:scatter} show the results for AllSAT with \mathsat{} and \tabularallsat{}, respectively.\@ \cref{fig:plt:all:lra:scatter,fig:plt:tabula:all:lra:scatter} show the results for AllSMT with \mathsat{} and \tabularallsmt{}, respectively.
%}}
%     }%
% }%
%
    %
    For each figure, we report a pair of subfigures comparing the CNF-izations for
    disjoint and non-disjoint enumeration (when both are supported).\@ Each
    subfigure reports a set of scatter plots to compare \TseitinCNF{},
    \PlaistedCNF{} and \NNFPlaisted{} in terms of number of partial
    truth assignments (size of \TAna), in the first row, and execution time, in the
    second row. %\ignoreinshort{\GMCHANGE{%}}%\ignoreinlong{models}\ignoreinshort{\GMCHANGE{%}}, 
    %
    Each problem set is represented by a different color and marker.
    (In~\cref{appendix:experiments}, we report the scatter plots for each group of
    benchmarks separately.) Timeouts are represented by the points on the dashed
    line, and summarized in the tables below the plots.

%
Notice the logarithmic scale of the axes (!).
%
%\cref{tab:timeouts:bool,tab:timeouts:lra} report the total number of timeouts for the Boolean and \smtlarat{} benchmarks, respectively.

% Each problem set is represented by a different color, 
%\ignoreinshort{\GMCHANGE{
%}}
% Moreover, we show with CDF plots (\cref{fig:plt:syn:time:ecdf,fig:plt:circ:time:ecdf,fig:plt:wmi:time:ecdf}) the cumulative execution time taken to enumerate the models of the formulas CNF-ized with the different transformations.
\begin{figure}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \centering
        \includegraphics[height=2em]{plots/msat/lra/rep/all/legend.pdf}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:lra:norep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:norep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:norep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:lra:norep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:norep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/no-rep/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:norep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for disjoint enumeration.}%
        \label{fig:plt:all:lra:norep:scatter}
    \end{subfigure}
    %%%%%%%%%%%% REP %%%%%%%%%%%%%
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:lra:rep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:rep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:rep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:all:lra:rep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:rep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/msat/lra/rep/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:all:lra:rep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for non-disjoint enumeration.}%
        \label{fig:plt:all:lra:rep:scatter}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        {\small
            \input{plots/msat/lra/timeouts.tex}
        }
        \caption{Number of timeouts.}%
        \label{tab:timeouts:lra}
    \end{subfigure}
    \caption{Results on the \smtlarat{} benchmarks using \mathsat{}.
            Scatter plots in~\ref{fig:plt:all:lra:norep:scatter}, \ref{fig:plt:all:lra:rep:scatter} compare CNF-izations by \TAna{} size (first row) and execution time (second row).
            Points on dashed lines represent timeouts, summarized in~\ref{tab:timeouts:lra}.
            All axes use a logarithmic scale.}%
    \label{fig:plt:all:lra:scatter}
\end{figure}
\begin{figure}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \centering
        \includegraphics[height=2em]{plots/tabularallsmt/all/legend.pdf}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:models:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:models:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:models:lab_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:time:lab_vs_pol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:time:pol_vs_nnfpol}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{0.29\textwidth}
            \centering
            \includegraphics[width=.85\textwidth]{plots/tabularallsmt/all/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:tabula:all:lra:norep:time:lab_vs_nnfpol}
            % \end{subfigure}
        \end{subfigure}
        \caption{Results for disjoint enumeration.}%
        \label{fig:plt:tabula:all:lra:norep:scatter}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        {\small
            \input{plots/tabularallsmt/timeouts.tex}
        }
        \caption{Number of timeouts.}%
        \label{tab:timeouts:tabula:lra}
    \end{subfigure}
    \caption{Results on the \smtlarat{} benchmarks using \tabularallsmt{}.
            Scatter plots in~\ref{fig:plt:tabula:all:lra:norep:scatter} compare CNF-izations by \TAna{} size (first row) and execution time (second row).
            Points on dashed lines represent timeouts, summarized in~\ref{tab:timeouts:tabula:lra}.
            All axes use a logarithmic scale.}%
    \label{fig:plt:tabula:all:lra:scatter}
\end{figure}

\paragraph{The %\ignoreinshort{\GMCHANGE{
    Boolean %}}
    synthetic benchmarks.} (\cref{fig:plt:all:bool:scatter,fig:plt:tabula:all:bool:scatter})
%
%
% The results on the %\ignoreinshort{\GMCHANGE{
% Boolean %}} 
% synthetic benchmarks are shown in~\cref{fig:plt:syn:bool:scatter}. %\ignoreinlong{All the problems were solved for all the encodings within the timeout.} 
% The plots %\ignoreinshort{\GMCHANGE{\ 
% in~\cref{fig:plt:syn:bool:norep:scatter} %}} 
% show that %\ignoreinshort{\GMCHANGE{
The plots show that in the disjoint case \PlaistedCNF{} performs better than
\TseitinCNF{}, since both
    \mathsat{}~(\cref{fig:plt:all:bool:norep:scatter}) and
    \tabularallsat~(\cref{fig:plt:tabula:all:bool:norep:scatter}) enumerate a
smaller \TAna (first row) in less time (second row) on every instance.
Furthermore, the combination of \NNFna{} and \PlaistedCNF{} yields by far the
best results for both solvers, drastically reducing the size of \TAna{}
and the execution time by orders of magnitude w.r.t.\ both \TseitinCNF{} and
\PlaistedCNF{}. % in~\cref{fig:plt:all:bool:scatter} %\ }}%The analysis on the execution time is confirmed by the CDF in~\cref{fig:plt:syn:time:ecdf}.}
%\ignoreinshort{\GMCHANGE{
The advantage of \NNFPlaisted{} over both \TseitinCNF{} and
\PlaistedCNF{} is even more evident for the non-disjoint case
    (\cref{fig:plt:all:bool:rep:scatter}). %, as shown in~\cref{fig:plt:all:bool:rep:scatter}.
% }}

\paragraph{The ISCAS'85 benchmarks.}
(\cref{fig:plt:all:bool:scatter,fig:plt:tabula:all:bool:scatter})
%
%\cref{fig:plt:circ:scatter} shows the performance of the different CNF-izations in the circuits benchmarks. %\ignoreinlong{The timeouts are represented by the points on the dashed lines. }
%
First, we notice that \TseitinCNF{} and \PlaistedCNF{} have very similar
behavior, both in terms of execution time and size of \TAna{}. The reason is
that in circuits most of the sub-formulas occur with double polarity, so that
the two encodings are very similar, if not identical.%, it is typical to have a lot of sharing of sub-formulas. Since we constrain the outputs to be 0 or 1 at random~\cite{tibebuAugmentingAllSolution2018}, 

Second, we notice that by converting the formula into NNF before applying
\PlaistedCNF{} the enumeration, both disjoint and non-disjoint, %\ignoreinshort{\GMCHANGE{, 
% }} 
is much more effective, as a much smaller \TAna is enumerated, with only a few
outliers.
%This can be due to the fact that the enumerated \TA{}  is \emph{minimal} and not \emph{minimum}, and its size can be affected also by the order in which the assignments are found.
%We also notice that a smaller number of models does not always correspond to a shorter execution time. 
The fact that for some instances \NNFPlaisted{} takes a little more
time can be due to the fact that it can produce a formula that is up to
twice as large and contains up to twice as many label atoms as the other two
encodings, increasing the time to find the assignments. Notice also that, even
enumerating a smaller \TAna{} at a price of a small time overhead can be
beneficial in many applications. %, for instance in
% WMI~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022,spallittaEnhancingSMTbasedWeighted2024a}.

% \begin{ignoreinshortenv}
%     \begin{gmchangep}

\paragraph{The AIG benchmarks.} (\cref{fig:plt:all:bool:scatter,fig:plt:tabula:all:bool:scatter})
%
%In~\Cref{fig:plt:aig:scatter} we show the results on the AIG benchmarks. 
This set of benchmarks is by far the most challenging one, as they contain many
Boolean atoms and a very complex structure. For this reason, even the
best-performing encoding, \NNFPlaisted{}, reports many timeouts. %even though we use a higher timeout of 3600 seconds, 

Nevertheless, we can still observe that the combination of \NNFna{} and
\PlaistedCNF{} is the best-performing encoding for both solvers, both
in terms of size of \TAna{} and execution time. %, for both disjoint and non-disjoint enumeration.

%     \end{gmchangep}
% \end{ignoreinshortenv}

% \begin{ignoreinshortenv}
%     \begin{gmchange}
\paragraph{The \smtlarat{} synthetic benchmarks.} (\cref{fig:plt:all:lra:scatter,fig:plt:tabula:all:lra:scatter})
%
%The results on the \smtlarat{} benchmarks are shown in \cref{fig:plt:all:lra:scatter}.
The plots confirm that the analysis holds also for the All\smt{} case. 
The results are in line with those obtained on the Boolean benchmarks, for
both the disjoint and non-disjoint cases.%(\cref{fig:plt:syn:lra:norep:scatter}) %(\cref{fig:plt:syn:lra:rep:scatter}) 
%     \end{gmchange}
% \end{ignoreinshortenv}

\paragraph{The WMI benchmarks.} (\cref{fig:plt:all:lra:scatter,fig:plt:tabula:all:lra:scatter})
%
%
%
%The plots in~\cref{fig:plt:wmi:scatter} compare the different CNF-izations in the WMI benchmarks in terms of size of \TAna{} and time. 
%All the problems were solved for all the encodings within the timeout. NNant,
In these benchmarks, most of the sub-formulas occur with double polarity, so
that \TseitinCNF{} and \PlaistedCNF{} encodings are almost identical, and they
obtain very similar results in both metrics. The advantage is significant,
instead, if the formula is converted into NNF upfront, since by using
\NNFPlaisted{} the solvers enumerate a smaller \TAna. 
In this
application, it is crucial to enumerate as few partial truth assignments as
possible, since for each truth assignment an integral must be computed, which
is a very expensive
operation~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022,spallittaEnhancingSMTbasedWeighted2024a}.
% \ignoreinshort{\GMCHANGE{
Notice also that WMI requires disjoint enumeration to decompose the
whole integral into a sum of directly-computable integrals, one for each
satisfying truth assignment. Nevertheless, for completeness, we also report the
results for the non-disjoint case.
% }}

  \paragraph{Overall Results.} Overall, from the plots and tables in
  \cref{fig:plt:all:bool:scatter,fig:plt:tabula:all:bool:scatter,fig:plt:all:lra:scatter,fig:plt:tabula:all:lra:scatter},
  it is eye-catching that the usage of \NNFPlaisted{} instead of
  \TseitinCNF{} or \PlaistedCNF{} causes a
  dramatic
  improvement in the performances of \mathsat{}, \tabularallsat{}, and \tabularallsmt{}, in terms of both
  CPU time and size of the assignment sets generated, for both disjoint and non-disjoint
  enumeration, on all AllSAT and AllSMT benchmark sets under test. 

%\newpage
%\subsection{Comparing the CNF encodings for  related problems}%
\subsection{Discussion: Using \NNFPlaisted{} with related problems}%
\label{sec:experiments:others}
%We wish to draw the borderlines for the applicability of the proposed \NNFPlaisted{} encoding.
We stress the fact that the proposed \NNFPlaisted{} encoding is conceived and expected to be
effective for \emph{enumeration} techniques which generate  \emph{partial}
assignments (see \sref{sec:solution}).
Thus, we do not expect benefits in using it with plain SAT or SMT \emph{solving}
(see also \cref{rem:ex3:preconv}), nor with enumeration techniques which generate
{\em total} or {\em nearly-total} assignments only.
%
To this extent,  
we investigate empirically and discuss some related problems for which we
do not expect benefits in using \NNFPlaisted{} for the above reason.
(See also \sref{sec:related-work}.)
%These investigate this fact, we have performed some extra 

%\subsubsection{Using \vinnfcnfpg{} with  plain  SAT  and SMT solving}%
\paragraph{Plain  SAT  and SMT solving.}%
\label{sec:experiments:sat}
%
% \ignore{%
%     In~\sref{sec:experiments:sat} we also report the CDF of the execution
%     time for {\em plain SAT and SMT solving} on the above groups of benchmarks\ADDED{, using \mathsat}. We see from the results that, unlike with enumeration, for plain solving the pre-conversion into NNF has no benefit and even slightly worsens performance, as we observed in~\cref{rem:ex3:preconv}.
% }
To support \cref{rem:ex3:preconv},
in Appendix~\ref{appendix:sat} we compare the different CNF encodings for plain SAT %\ignoreinshort{\GMCHANGEp{
and SMT %}} 
solving on all the benchmarks in~\sref{sec:experiments:benchmarks}.
Even though these problems are very small for plain solving, and SAT %\ignoreinshort{\GMCHANGEp{
and SMT
% }} 
solvers deal with them efficiently, we can see that the usage of \NNFPlaisted{} brings no advantage, and solving is uniformly slower than with \PlaistedCNF{} or \TseitinCNF{}. This shows that our
novel technique works specifically for enumeration but not for solving, as
expected.

\paragraph{Answer Set Programming.}
For the reason discussed above, we do not expect our new CNF encoding to bring benefits to
{Answer Set Programming (ASP)}, 
%\RSSIDENOTE{Riportato anche qui}
because answer sets represent \emph{total} truth assignments, since they
include atoms assigned to true, and other atoms are implicitly assumed to be assigned to false.
(We received confirmation from the clasp and clingo developers that these tools do not support partial assignments. See the discussion at  \url{https://github.com/potassco/clingo/issues/512#issuecomment-2223162682}.)
Notice that the concept of ``minimal'' in ASP refers to the minimality
of the set of atoms that are true in the answer set, and not to the
minimality of the set of atoms that are assigned a truth value, as in
this paper.

\paragraph{(Weighted) Model Counting.}
For {(weighted) model counting} the \TseitinCNF{} encoding is
currently the most
suitable, because it preserves the model count, whereas
\PlaistedCNF{} ---and hence \NNFPlaisted{}--- does not.
%With \PlaistedCNF{()} or \PlaistedCNF{(\NNF{}) one should project away 
In order to preserve the model count with these encodings and with current model counters, one should
make them project away the \allB{} labels, drastically worsening their
performances.

Although investigating ad-hoc model counting techniques for
\NNFPlaisted{}-encoded formulas (e.g., by exploiting the
polarity of label variables) could be an interesting topic for future research, it would definitely exceed the scope of this paper.

    % \subsubsection{Comparing the CNF encodings for d-DNNF-based
    % enumeration and counting}%
%\paragraph{d-DNNF-based (projected)       enumeration and counting.}  
\paragraph{d-DNNF compilation, (projected)       enumeration and counting.}%
 % \subsubsection{Using \vinnfcnfpg{} with d-DNNF-based
 %      enumeration and counting} 
\label{sec:experiments:d4}
We investigated the effect of the different CNF-izations on d-DNNF compilation, (projected) enumeration, and model counting.
We tested the tools \dfdecdnnf{}~\cite{lagniezLeveragingDecisionDNNFCompilation2024} for {projected} d-DNNF compilation and enumeration,
    and \df{}~\cite{lagniezImprovedDecisionDNNFCompiler2017} for
  projected d-DNNF model counting, on the Boolean benchmarks in
  \sref{sec:experiments:benchmarks}.
  %
  Each formula was converted into CNF, and then compiled into d-DNNF projected on the original atoms \allA{}.
  
%
%    We ran experiments on the Boolean benchmarks proposed in \sref{sec:experiments:benchmarks}.
    The results are reported in
    \cref{appendix:d4:enum,appendix:d4:counting}  for enumeration and model counting, respectively.
    We notice that, by using
\NNFPlaisted{} instead of \TseitinCNF{} or \PlaistedCNF{},
these tools
\begin{enumerate*}[(a)]
    \item\label{item:d4:analysis:models} show no substantial difference in terms of number and size of the assignments generated, and
    \item\label{item:d4:analysis:time} even worsen their time performance.    
\end{enumerate*}
The former fact~\ref{item:d4:analysis:models} is due to the fact that \df{}$_p$ algorithm~\cite{lagniezRecursiveAlgorithmProjected2019} ---implemented by \df{} for projected compilation and counting--- branches first on
important atoms \allA, and only at the
end of the branch it tries to assign also the non-important atoms \allB{}  to be
projected away. Consequently,
the projected assignments include all or almost-all important
atoms, thus producing total or nearly-total projected assignments on \allA.
%\RSSIDENOTE{Spostata qui da \S6}
This is not surprising, since d-DNNF-based tools typically do not rely their efficiency on the enumeration of short partial assignments, but rather on the effective decomposition
and caching of subproblems. 
% (Other projected d-DNNF compilation algorithms behave similarly.)
% \GMSIDENOTE{Forse toglierei la frase tra parentesi, non ne sono
% sicurissimo.} % RS: DONE
%
The latter fact~\ref{item:d4:analysis:time} may be due to several reasons:
%
    unlike with
    \TseitinCNF, with \PlaistedCNF{}
the assignment of the \allA{} values does not force the deterministic
assignment of the \allB values by BCP, causing extra useless search;
%
also,
the NNF transformation up to doubles the number of
    the non-important atoms  \allB{} to be projected away;
%
furthermore, we conjecture that the duplication of labels
    \poslab{B_i} and \neglab{B_i}, along with distinct encodings \poslab{\vi_i} and
    \neglab{\vi_i} for \NNF{\vi_i} and \NNF{\neg\vi_i}, may affect the
    effectiveness of the caching and partitioning
    mechanisms inside the \df{} d-DNNF compiler.


% Overall, these tools do not rely their
% efficiency on the enumeration of short partial assignments, rather on decomposition
% and caching of subproblems. 
   Although in principle ad-hoc d-DNNF compilation strategies for d-DNNF-based model
  counting and enumeration
could be devised to exploit the properties of our \NNFPlaisted{} encoding, 
investigating such techniques 
would exceed the scope of this paper. 