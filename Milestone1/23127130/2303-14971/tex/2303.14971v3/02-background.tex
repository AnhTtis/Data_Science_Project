This section introduces the notation and the theoretical background necessary to understand what is presented in this paper. We recall the standard syntax, semantics, and results of propositional logic, and the fundamental ideas behind SAT enumeration and projected enumeration implemented by modern AllSAT solvers.

\paragraph*{Notation}
In the paper, we adopt the following conventions. We refer to propositional atoms with capital letters, such as $A$ and $B$. Propositional formulas are referred to with Greek letters such as $\vi, \psi$. Total truth assignments are denoted by $\eta$, while partial truth assignments are denoted by $\mu$.
The symbols $\allA\defas\set{A_1, \dots, A_N }$ and $\allB\defas\set{B_1, \dots, B_K}$ denote disjoint sets of propositional atoms. We denote Boolean constants by $\B\defas\set{\top, \bot}$.
\subsection{Propositional logic}
In this section, we summarize some basic definitions and results of propositional logic.
% \begin{definition}
    A \emph{propositional formula} $\vi$ can be defined recursively as follows. The Boolean constants $\top$ and $\bot$ are formulas; a Boolean atom $A$ and its negation $\neg A$ are formulas, also referred to as \emph{literals}; a connection of two formulas $\vi$ and $\psi$ by one of the connectors $\wedge, \vee, \imp, \limp,\iff$ is a formula. A sub-formula occurs with \emph{positive \resp{negative} polarity} (also \emph{positively \resp{negatively}}) if it occurs under an even \resp{odd} number of nested negations. Specifically, $\vi$ occurs positively in $\vi$; if $\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or $\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and $\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if $\vi_1\iff\vi_2$ occurs in $\vi$,
    then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% \end{definition}
% \begin{definition}
    A Boolean formula is in \emph{Negation Normal Form (NNF)} iff it is given only by the recursive applications of $\wedge$ and $\vee$ to literals.
% \end{definition}
A formula can be converted into NNF by recursively rewriting implications $(\alpha\imp\beta)$ as $(\neg\alpha\vee\beta)$ and double implications $(\alpha\iff\beta)$ as $(\neg\alpha\vee\beta)\wedge(\alpha\vee\neg\beta)$, and by recursively ``pushing down'' the negations $\neg(\alpha\vee\beta)$ as $(\neg\alpha\wedge\neg\beta)$ and $\neg(\alpha\wedge\beta)$ as $(\neg\alpha\vee\neg\beta)$.
If the formula is represented as a Directed Acyclic Graph (DAG), then the size of the resulting formula is linear w.r.t.\ the original one.
% \begin{definition}
A Boolean formula is in \emph{Conjunctive Normal Form (CNF)} iff it is a conjunction $(\wedge)$ of clauses, where a clause is a disjunction $(\vee)$ of literals. 
% \end{definition}
Numerous CNF transformation procedures, commonly referred to as CNF-izations, have been proposed in the literature. In the next paragraph, we summarize the three most frequently employed techniques.


\paragraph*{CNF Transformations}%
\label{sec:bg:cnf}

The \emph{Classic CNF-ization} (\DeMorganCNF{}) converts any propositional formula into a logically equivalent formula in CNF by applying DeMorgan's rules. First, it converts the formula into NNF.\@ Second, it recursively rewrites sub-formulas $\alpha\vee(\beta\wedge\gamma)$ as $(\alpha\vee\beta)\wedge(\alpha\vee\gamma)$ to distribute $\vee$ over $\wedge$, until the formula is in CNF.\@ The principal limitation of this transformation lies in the possible exponential growth of the resulting formula compared to the original, making it unsuitable for modern SAT solvers.

The \emph{Tseitin CNF-ization} (\TseitinCNF{})~\cite{tseitin68} avoids this exponential blow-up by labelling each sub-formula $\vi_i$ with a fresh Boolean atom $B_i$, which is used as a placeholder for the sub-formula. Specifically, it consists in applying recursively bottom-up the rewriting rule $\vi\Longrightarrow\vi[\vi_i|B_i] \wedge \DeMorganCNF(B_i\iff\vi_i)$ until the resulting formula is in CNF, where $\vi[\vi_i|B_i]$ is the formula obtained by substituting in $\vi$ every occurrence of $\vi_i$ with $B_i$. 

The \emph{Plaisted\&Greenbaum CNF-ization} (\PlaistedCNF{})~\cite{plaisted1986structure} is a variant of the \TseitinCNF{} that exploits the polarity of sub-formulas to reduce the number of clauses of the final formula. Specifically, if a sub-formula $\vi_i$ appears only with positive \resp{negative} polarity, then it can be labelled with a single implication as $\DeMorganCNF(B_i\imp\vi_i)$ \resp{$\DeMorganCNF(B_i\limp\vi_i)$}.

With both \TseitinCNF{} and \PlaistedCNF{}, due to the introduction of the label variables, the final formula does not preserve the equivalence with the original formula but only the equisatisfiability.
Moreover, they also have a stronger property. 
If $\vi(\allA)$ is a non-CNF formula and $\vicnf(\allA, \allB)$ is either the \TseitinCNF{} or the \PlaistedCNF{} encoding of $\vi$, where $\allB$ are the fresh Boolean atoms introduced by the transformation, then $\vi(\allA)\equiv\exists\allB.\vicnf(\allA, \allB)$.

\paragraph*{Total and partial truth assignments}
% \begin{definition}
    Given a set of Boolean atoms $\allA$, a \emph{total truth assignment} is a total map $\eta: \allA\longmapsto\B$. 
    A \emph{partial truth assignment} is a partial map $\mu: \allA\longmapsto\B$.  
% \end{definition}
Notice that a partial truth assignment represents $2^K$ total truth assignments, where $K$ is the number of unassigned variables by $\mu$.
With a little abuse of notation, we sometimes represent a truth assignment either as a set, s.t.\ $\mu\defas\set{A\ |\ \mu(A)=\top}\cup\set{\neg A\ |\ \mu(A)=\bot}$, or as a cube, s.t.\ $\mu\defas\bigwedge_{\mu(A)=\top}{A}\wedge\bigwedge_{\mu(A)=\bot}{\neg A}$.
If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that $\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of $\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict super-assignment}} of $\mu_1$.
We denote with $\residual{\vi}{\mu}$ the \emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by substituting in $\vi$ each $A_i\in\allA$ with $\mu(A_i)$, and by recursively applying the standard propagation rules of truth values through Boolean operators.

% \begin{definition}
Given a set of Boolean atoms $\allA$ and a formula $\vi(\allA)$, we say that a \emph{[partial or total] truth assignment $\mu:\allA\longmapsto\B$ satisfies} $\vi$, denoted as $\mu\models\vi$, iff $\residual{\vi}{\mu}=\top$\footnote{
    The definition of satisfiability by partial assignment may present some ambiguities for non-CNF and existentially-quantified formulas~\cite{sebastiani_are_2020,mohle_four_2020}. Here we adopt the above definition because it is the easiest to implement, and it is the one typically used by state-of-the-art SAT solvers. We refer to~\cite{sebastiani_are_2020,mohle_four_2020} for details.
}. If $\mu\models\vi$, then we say that $\mu$ is a \emph{model} of $\vi$.
% \end{definition}
% \footnote{
 %}
A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff $\mu\models\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such that $\mu{}'\not\models\vi$.\\ 
Most of the modern SAT and SMT solvers do not deal directly with non-CNF formulas, rather they convert them into CNF by using either \TseitinCNF{} or \PlaistedCNF{}. As seen in the previous paragraph, since these transformations introduce fresh atoms into the resulting formulas, a model of $\vi(\allA)$ can be found as a truth assignment satisfying $\exists\allB.\vicnf(\allA,\allB)$.
% \begin{definition}
    Given two disjoint sets of Boolean atoms $\allA, \allB$ and a CNF formula $\vicnf(\allA, \allB)$, we say that a \emph{[partial or total] truth assignment $\muA:\allA\longmapsto\B$ satisfies} $\exists\allB.\vicnf$ iff there exists a total truth assignment $\etaB:\allB\longmapsto\B$ such that $\muA\cup\etaB: \allA\cup\allB\longmapsto\B$ satisfies $\vicnf$.
% \end{definition}

% The work of this paper focuses on the following result from~\cite{sebastiani_are_2020}.
% \begin{lemma}%
%     \label{lemma:noncnf-sat}
%     Let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA, \allB)$ be the result of applying either the \TseitinCNF{} or the \PlaistedCNF{} transformation to $\vi$.\\
%     Given a total truth assignment $\etaA:\allA\longmapsto\B$, then  $\etaA\models\vi$ iff $\etaA\models\exists\allB.\vicnf$. However, given a partial truth assignment $\muA:\allA\longmapsto\B$, then  $\muA\models\vi$ if $\muA\models\exists\allB.\vicnf$, but the reverse implication does not hold. 
% \end{lemma}
% \GMNOTE{Dobbiamo dimostrarlo per Plaisted?}

\subsection{AllSAT and Projected AllSAT}%
\label{sec:background:allsat}
AllSAT is the task of enumerating all the models of a propositional formula. In this paper, we focus on the enumeration of disjoint models, that is, pairwise mutually-inconsistent models.
% \begin{definition}
    Given a Boolean formula $\vi$, we denote with $\TTA{\vi}\defas\set{\eta_1,\dots,\eta_j}$ the set of all total truth assignments satisfying $\vi$.
% \end{definition}
% \begin{definition}
   We denote with $\TA{\vi}\defas\set{\mu_1,\dots,\mu_i}$ a set of partial truth assignments satisfying $\vi$ s.t.:
    \begin{romanenumerate}
        \item every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
        \item every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
    \end{romanenumerate}
% \end{definition}
Notice that, whereas $\TTA{\vi}$ is unique, multiple $\TA{\vi}$s are admissible for the same formula $\vi$, including $\TTA{\vi}$. AllSAT is the task of enumerating either $\TTA{\vi}$ or a set $\TA{\vi}$. Typically, AllSAT solvers aim at enumerating a set $\TA{\vi}$ as small as possible, since every partial model prevents from enumerating a number of total models that is exponential w.r.t.\ the number of unassigned atoms, so that to save computational space and time.

%\mathsat{}~\cite{mathsat5_tacas13}, the SAT/SMT solver that we used for our experiments.\GMSIDENOTE{Riscrivere non riferendosi solo a mathsat}
The enumeration of a $\TA{\vi}$ for a non-CNF formula $\vi$ is typically implemented by first converting it into CNF, and then enumerating its models by means of \emph{Projected AllSAT}.
Specifically, let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA,\allB)$ be the result of applying either \TseitinCNF{} or \PlaistedCNF{} to $\vi$. $\TA{\vi}$ is enumerated via Projected AllSAT as $\TA{\exists\allB.\vicnf}$, i.e.\ as a set of (partial) truth assignments over $\allA$ that can be extended to total models of $\vicnf$ over $\allA\cup\allB$. %, as a consequence of \cref{lemma:noncnf-sat}. 
In this paper, we refer to the procedure for Projected AllSAT described in~\cite{hutchison_smt_2006}, which we briefly recap here.\\
Let $\vicnf(\allA, \allB)$ be a CNF formula over two disjoint sets of Boolean variables $\allA, \allB$, where $\allA$ is a set of \emph{relevant atoms} s.t.\ we want to enumerate a $\TA{\exists\allB.\vicnf}$. The solver enumerates one-by-one partial truth assignments $\mu\defas\muA\cup\etaB$ s.t.:
\begin{romanenumerate}
    \item\label{item:mumodelsvi} (\emph{satisfiability}) $\mu\models\vicnf$;
    \item\label{item:musdisjoint} (\emph{disjointness}) every pair $\mu_i,\mu_j$ assign opposite truth values to at least one atom in $\allA$;
    \item\label{item:muAminimal} (\emph{minimality}) $\muA$ is \emph{minimal}, meaning that no literal can be dropped from it without losing properties~(\ref{item:mumodelsvi}) and~(\ref{item:musdisjoint}).  
\end{romanenumerate}
Specifically, the solver finds a total truth assignment $\eta\defas\etaA\cup\etaB$ s.t.\ $\eta\models\vi$, and then invokes a minimization procedure on $\etaA$ to compute a partial truth assignment $\muA$ satisfying properties~(\ref{item:mumodelsvi}), and~(\ref{item:muAminimal}). Then, it learns the clause $\neg\muA$ to continue the search and to ensure property~(\ref{item:musdisjoint}). This process is iterated until the formula is found to be unsatisfiable, and the set $\set{\muA_i}_i$ is returned.

