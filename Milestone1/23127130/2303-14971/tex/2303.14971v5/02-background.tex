This section introduces the notation and the theoretical background necessary to understand what is presented in this paper.
%\ignoreinshort{
We assume the reader is familiar with the basic syntax, semantics and results of propositional and first-order logics.\@
We briefly summarize the main concepts and results of SAT and SMT, and the fundamental ideas behind SAT and SMT enumeration and projected enumeration implemented by modern AllSAT and AllSMT solvers.
%}
%\ignoreinlong{We recall the standard syntax, semantics, and results of propositional logic and Satisfiability Modulo Theories (SMT), and the fundamental ideas behind SAT enumeration and projected enumeration implemented by modern AllSAT solvers.}



\subsection{%\ignoreinlong{Propositional Logic}\ignoreinshort{
    SAT and SAT Modulo Theories}%}%
\label{sec:background:propositional-logic}
%In this section, we summarize some basic definitions and results of
%propositional logic \ignoreinshort{\GMCHANGE{ and SMT}}.

\paragraph*{Notation.}
%\ignoreinlong{ and Terminology}.
In the paper, we adopt the following conventions. We refer to Boolean atoms with capital letters, such as $A$ and $B$,
%\ignoreinshort{
and to generic atoms, both Boolean and first-order, with Greek letters such as $\alpha$. %}.
The symbols $\allA\defas\set{A_1, \dots, A_N }$ and
$\allB\defas\set{B_1, \dots, B_M}$ denote disjoint sets of
Boolean atoms,
%\ignoreinshort{, 
and $\allalpha{}\defas\set{\alpha_1,\dots,\alpha_k}$ denotes a set of generic Boolean or first-order atoms.
%}
% \ignoreinshort{\GMCHANGE{The symbol $\allalpha\defas\set{\alpha_1,\dots,\alpha_M}$ denotes a set of generic (Boolean or \T{}-) atoms s.t.\ \allalpha{} and \allB{} are disjoint.}}
Propositional
%\ignoreinshort{
and first-order
%} 
formulas are referred to with Greek letters $\vi, \psi$.
We denote Boolean constants by $\B\defas\set{\top, \bot}$.
Total truth assignments are denoted by $\eta$, whereas partial truth assignments are denoted by $\mu$, %\ignoreinshort{, 
possibly annotated with superscripts. %}.

\paragraph*{%\ignoreinshort{
    Propositional Satisfiability.}%}
A \emph{propositional (also Boolean) formula} $\vi$ can be defined recursively as follows. The Boolean constants $\top$ and $\bot$ are formulas; a Boolean atom $A$ and its negation $\neg A$ are formulas, also referred to as \emph{literals}; a connection of two formulas by one of the Boolean connectives $\wedge, \vee, \imp, \iff$ is a formula.
%\ignoreinshort{
A disjunction $(\vee)$ of literals is called a \emph{clause}. A conjunction $(\wedge)$ of literals is called a \emph{cube}.
%\ignoreinshort{
\emph{Propositional satisfiability (SAT)} is the problem of deciding the satisfiability of a propositional formula.
%}
% \ignoreinshort{\GMCHANGE{Some formulas can also present quantifiers to express more complex conditions on Boolean parameters. In particular, the existential quantifier ($\exists B$), means that for at least one truth value of $B$ the formula should be satisfied.}}

% \begin{ignoreinshortenv}
\paragraph*{Satisfiability Modulo Theories.}
% \paragraph*{Satisfiability Modulo Theories}
%Let $\Sigma$ be a first-order signature containing function and predicate symbols. A $\Sigma$-term is either a variable or it is built by applying a function symbol in $\Sigma$ to $\Sigma$-terms. If $t_1, \dots , t_n$ are $\Sigma$-terms and $P$ is a predicate symbol, then $P(t_1, \dots , t_n)$ is a $\Sigma$-atom. Boolean atoms are defined as 0-ary predicate symbols. 
% Given a first-order signature $\Sigma$, i.e., a set of predicate, function and constant symbols, a term is either a variable $v$, a constant symbol, or a combination of terms by means of function symbols. A $\Sigma$-atom is a predicate symbol applied to a tuple of terms (Boolean atoms can be viewed as zero-arity predicates).
% A $\Sigma$-formula $\vi$ is built in the usual way out of the Boolean connectives, and $\Sigma$-atoms. A $\Sigma$-theory is a set of first-order sentences with signature $\Sigma$.
% Examples of theories are bit-vector arithmetic (\bv{}), floating-point arithmetic (\fl{}), linear arithmetic over integers (\laint{}) and real numbers (\larat{}), and arrays (\mem{}).\@ % and their combinations.
% With a little abuse of notation, we often refer to a theory \T{} instead of its corresponding signature, so that by \T-formulas \resp{literals, atoms} we mean formulas \resp{literals, atoms} in the signature of \T{}.
As it is standard in most \smt{} literature, we restrict to quantifier-free first-order formulas.
A first-order term is either a variable, a constant symbol, or a combination of terms by means of function symbols. A first-order atom is a predicate symbol applied to a tuple of terms (Boolean atoms can be viewed as zero-arity predicates).
A first-order formula is either a first-order atom, or a connection of two formulas by one of the Boolean connectives. %
% is built in the usual way out of the existential and universal quantifiers, the
% Boolean connectives, and first-order atoms,
% i.e., predicate symbols applied to tuples of terms (Boolean atoms can be viewed as zero-arity predicates).
A first-order theory \T{} is a (possibly infinite) set of first-order formulas,
that provides an intended interpretation of constant, function, and predicate symbols.
Examples of theories of practical interest are those of equality and uninterpreted functions (\euf{}), of linear arithmetic over integer (\laint{}) or real numbers (\larat{}), and combinations thereof.
We refer to formulas and atoms over symbols defined by \T{} as \T-formulas and \T-atoms, respectively.

\emph{Satisfiability Modulo the Theory $\T$, also $\smtt$,} is the problem of deciding the satisfiability of a first-order formula with respect to some background theory \T{}.
% With a little abuse of notation, we often refer to a theory \T{} instead of its corresponding signature, so that by \T-formulas \resp{literals, atoms} we mean formulas \resp{literals, atoms} in the signature of \T{}.
%~\cite{barrettSatisfiabilityModuloTheories2018} %, i.e.\ a set of closed first-order formulas. 
% In \smtt{} formulas, atoms are either Boolean atoms or \T{}-atoms.
A formula $\vi$ is \emph{\T{}-satisfiable}
%(also \emph{\T{}-consistent}) 
if $\vi\wedge\T{}$ is satisfiable in the first-order sense. Otherwise, it is \emph{\T{}-unsatisfiable}. % (also \emph{\T{}-inconsistent}).
% The notation and terminology introduced for propositional logic can be straightforwardly extended for SMT formulas.
We refer to the work by~\citeA{barrettSatisfiabilityModuloTheories2021} for details.
% In this paper, we focus on quantifier-free SMT formulas.
% Since propositional logic can be seen as a strict subset of first-order logic, by considering

Hereafter, unless otherwise specified, by ``formulas'' we mean both Boolean and \T-formulas, and by ``atoms'' we mean both Boolean and \T-atoms, for a generic theory \T{}.
% \end{ignoreinshortenv}

% \begin{definition}
% \ignoreinlong{A sub-formula occurs with \emph{positive} \resp{\emph{negative}} \emph{polarity} (also \emph{positively} \resp{\emph{negatively}}) if it occurs under an even \resp{odd} number of nested negations. Specifically, $\vi$ occurs positively in $\vi$; if $\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or $\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and $\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if $\vi_1\iff\vi_2$ occurs in $\vi$,
%     then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% }
% \end{definition}
% \begin{definition}

% \begin{ignoreinshortenv}
\paragraph*{Total and partial truth assignments.}
%%%%%%%% SPOSTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%
% \begin{definition}
Given a set of atoms $\allalpha$, a \emph{total truth assignment} is a total map $\eta: \allalpha\longmapsto\B$.
A \emph{partial truth assignment} is a partial map $\mu: \allalpha\longmapsto\B$.
% \end{definition}
Notice that a partial truth assignment represents $2^K$ total truth assignments, where $K$ is the number of atoms unassigned
%\ignoreinlong{variables}\ignoreinshort{
% atoms %} 
by $\mu$.
With a little abuse of notation, we sometimes represent a truth assignment either as a set, s.t.\ $\mu\defas\set{\alpha\ |\ \mu(\alpha)=\top}\cup\set{\neg \alpha\ |\ \mu(\alpha)=\bot}$, or as a cube, s.t.\ $\mu\defas\bigwedge_{\mu(\alpha)=\top}{\alpha}\wedge\bigwedge_{\mu(\alpha)=\bot}{\neg \alpha}$.
If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that $\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of $\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict super-assignment}} of $\mu_1$.
We denote with $\residual{\vi}{\mu}$ the \emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by substituting in $\vi$ each $\alpha_i\in\allalpha$ with $\mu(\alpha_i)$, and by recursively applying the standard propagation rules of truth values through Boolean operators.

% \begin{definition}
Given a set of atoms $\allalpha$ and a formula $\vi(\allalpha)$, we say that a \emph{[partial or total] truth assignment $\mu:\allalpha\longmapsto\B$ %\ignoreinshort{
    propositionally %} 
    satisfies} $\vi$, denoted as $\mu\pmodels\vi$, iff $\residual{\vi}{\mu}=\top$.\footnote{
    The definition of satisfiability by partial assignment may present some ambiguities for non-CNF and existentially-quantified formulas~\cite{sebastiani_are_2020,mohle_four_2020}. Here we adopt the above definition because it is the easiest to implement, %\ignoreinshort{
    the most efficient to compute, %} 
    and it is the one typically used by state-of-the-art SAT solvers. {We refer to the works by~\citeA{sebastiani_are_2020,mohle_four_2020} for details.}
}
% \end{definition}
% \footnote{
%}
A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff $\mu\pmodels\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such that $\mu{}'\not\pmodels\vi$.
%\ignoreinshort{
A Boolean formula is satisfiable iff there exists a truth assignment propositionally satisfying it. A \T-formula is \T-satisfiable iff there exists a \T-satisfiable truth assignment propositionally satisfying it. %}

Given two disjoint sets of %\ignoreinlong{ Boolean} 
atoms $\allalpha, \allB$ and a
%\ignoreinlong{CNF }
formula $\vicnf(\allalpha\cup\allB)$, we say that a \emph{[partial or total] truth assignment $\mualpha:\allalpha\longmapsto\B$ %\ignoreinshort{
    propositionally
    %} 
    satisfies} $\exists\allB.\vicnf$ iff there exists a total truth assignment $\etaB:\allB\longmapsto\B$ such that $\mualpha\cup\etaB: \allalpha\cup\allB\longmapsto\B$ %\ignoreinshort{
propositionally %} 
satisfies $\vicnf$.

%\ignoreinshort{
Two formulas $\vi{}$ and $\psi{}$ are \emph{propositionally equivalent}, denoted as $\vi\pequiv\psi$, iff every total truth assignment propositionally satisfying $\vi$ also propositionally satisfies $\psi$, and vice versa. %}

%%% SPOTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%

% \end{ignoreinshortenv}

\paragraph*{Negation Normal Form.}
%%%%%%%% SPOSTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%
% \ignoreinshort{
Given a formula $\vi$, a sub-formula occurs with \emph{positive} \resp{\emph{negative}} \emph{polarity} (also \emph{positively} \resp{\emph{negatively}}) if it occurs under an even \resp{odd} number of nested negations. Specifically, $\vi$ occurs positively in $\vi$; if $\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or $\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and $\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if $\vi_1\iff\vi_2$ occurs in $\vi$, then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% }

%\begin{rschange}
A %\ignoreinlong{ Boolean} 
formula is in \emph{Negation Normal Form (NNF)} iff it
is given only by the recursive applications of $\wedge$ and $\vee$
to literals, %\ignoreinshort{, 
i.e., iff all its sub-formulas occur positively, except for literals.
An NNF formula can be conveniently represented as a  Directed Acyclic Graph (DAG)
---that is, as a single-root and/or DAG with literals as leaves.
%\ignoreinshort{
We call the {\em size} of an NNF DAG the sum of the numbers of
its nodes and arcs. %}
% \end{definition}
A formula can be converted into %\ignoreinshort{
a propositionally-equivalent %}
NNF %\ignoreinshort{
formula %}
by recursively rewriting
implications $(\vi_1\imp\vi_2)$ as $(\neg\vi_1\vee\vi_2)$ and
equivalences $(\vi_1\iff\vi_2)$ as
$(\neg\vi_1\vee\vi_2)\wedge(\vi_1\vee\neg\vi_2)$, and then by recursively
``pushing down'' the negations: $\neg(\vi_1\vee\vi_2)$ as
$(\neg\vi_1\wedge\neg\vi_2)$, $\neg(\vi_1\wedge\vi_2)$ as
$(\neg\vi_1\vee\neg\vi_2)$ and $\neg\neg\vi_1$ as $\vi_1$.
% \ignoreinlong{
%     If the NNF formula is represented as a DAG,
%     %{---that is, as a single-root and/or DAG with literals as leaves---}
%     then its size is linear w.r.t.\ the original one.
%     (Although this fact is well-known,
%     % we could not to find a formal proof
%     %     of it in the literature; hence,
%     we provide a formal proof in the
%     extended version of this paper~\citeR{masina_cnf_2023}.)
%     %
%     % \footnote{
%     % %    \begin{gmchange}
%     %     In fact, such NNF DAG is a sub-graph of the 2-root NNF DAG for the
%     %     pair $\langle\NNF{\vi},\NNF{\neg\vi}\rangle$, and it is
%     %     straightforward to prove that the latter grows linearly w.r.t.\
%     %     the size of $\vi$ by reasoning inductively on the structure of the
%     %     formula \vi: if $\vi\defas(\vi_1\bowtie\vi_2)$ s.t.\ $\bowtie~\in\set{\wedge,\vee,\imp,\limp,\iff}$, then
%     %     $|\langle \NNF{\vi},\NNF{\neg\vi}\rangle| \leq
%     %          18+|\langle \NNF{\vi_1},\NNF{\neg\vi_1}\rangle|+|\langle \NNF{\vi_2},\NNF{\neg\vi_2}\rangle|$, where ``|\dots|'' is \#nodes(\dots)+\#arcs(\dots).
%     %     \\E.g., if $\bowtie$ is ``$\iff$'', then the DAGs for $\NNF{\vi}$ and $\NNF{\neg\vi}$ share the
%     %     sub-DAGs for
%     %     $\NNF{\vi_1},\NNF{\neg\vi_1},\NNF{\vi_2},\NNF{\neg\vi_2}$, adding
%     %     3+3 ``$\wedge$''/``$\vee$'' nodes and $6+6$ arcs:\\
%     %     % \begin{itemize}
%     %         % \item 
%     %         $
%     %         \begin{aligned}
%     %             \quad\NNF{\pos\phantom{(}\vi_1\iff\vi_2\phantom{)}}\defas(\NNF{\neg\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\pos\vi_1}\vee \NNF{\neg\vi_2});\\
%     %             \quad\NNF{\neg(\vi_1\iff\vi_2)}\defas(\NNF{\pos\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\neg\vi_1}\vee\NNF{\neg\vi_2}).            
%     %         \end{aligned}
%     %         $\\
%     %         % \item 
%     %     % \end{itemize}
%     %     Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of $\vi$,
%     %     representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and negative
%     %     occurrences of $\vi_i$ respectively. These nodes are shared among up
%     %     to exponentially-many branches generated by expanding the nested iffs.
%     % %    \end{gmchange}
%     % }
% }
% \ignoreinshort{%
The following fact holds.
%\begin{gmchange}
\begin{property}%
    \label{th:nnfdaglinear}
    Let \vi{} be a %\ignoreinlong{ Boolean} 
    formula and \NNF{\vi} be the NNF
    formula resulting from converting \vi{} into NNF as described
    above.
    If $\NNF{\vi}$ is represented as a DAG,  then its size is linear w.r.t.\ the original one.
\end{property}
\noindent(Although we believe this fact is well-known,
% we failed to find a formal proof
% in the literature. Hence,
we provide a formal proof in~\cref{sec:proofnnfdaglinear}.)
%\end{gmchange}
% }
Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of $\vi$,
representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and negative
occurrences of $\vi_i$ respectively. These nodes are shared among up
to exponentially-many branches generated by expanding the nested iffs.
%\end{rschange}

% \ignoreinshort{
We have the following fact, for which we provide a complete proof  in~\cref{sec:proofmunnf}.
\begin{property}%
    \label{th:munnf}
    Consider a formula $\vi$, and let $\NNF{\vi}$ be its NNF DAG.\@
    Consider a partial truth assignment $\mu$. % on $\GMCHANGEp{\allalpha $. 
    Then $\residual{\vi}{\mu}=v$ iff $\residual{\NNF{\vi}}{\mu}=v$, for
    $v\in\set{\top,\bot}$.
    % , where $\any$ represents the case in which the residual is neither $\top$ nor $\bot$.
\end{property}
\noindent Notice that this \emph{is not} a direct consequence of the fact that \NNF{\vi} is equivalence-preserving, because the above notion of satisfiability by partial assignment is such that if $\vi_1\pequiv\vi_2$, then $\mu\pmodels\vi_1$ \emph{does not} imply that $\mu\pmodels\vi_2$~\cite{sebastiani_are_2020,mohle_four_2020}. E.g, consider $\vi_1\defas(A\vee{}B)\wedge(A\vee\neg{}B)$ and $\vi_2\defas(A\wedge{}B)\vee(A\wedge{\neg{}B})$, and the partial assignment $\mu\defas\set{A}$.
Although $\vi_1\pequiv\vi_2$, we have that $\residual{\vi_1}{\mu}=\top$, but $\residual{\vi_2}{\mu}=B\vee\neg B$, which, although \emph{logically} equivalent to $\top{}$, is \emph{syntactically} different from it.
% }


\paragraph*{CNF Transformations.}%
\label{sec:bg:cnf}
A %\ignoreinlong{ Boolean} 
formula is in \emph{Conjunctive Normal Form (CNF)} iff it is a conjunction %\ignoreinlong{ $(\wedge)$} 
of clauses. %\ignoreinlong{, where a clause is a disjunction $(\vee)$ of literals}.
% \end{definition}
Numerous CNF transformation procedures, commonly referred to as CNF-izations, have been proposed in the literature.
%\ignoreinlong{In the next paragraph, we}\ignoreinshort{
We %} 
summarize the three most frequently employed techniques.

The \emph{Classic CNF-ization} (\DeMorganCNF{}) converts a formula into a propositionally-equivalent formula in CNF by applying DeMorgan's rules. First, it converts the formula into NNF.\@ Second, it recursively rewrites sub-formulas $\vi_1\vee(\vi_2\wedge\vi_3)$ as $(\vi_1\vee\vi_2)\wedge(\vi_1\vee\vi_3)$ to distribute $\vee$ over $\wedge$, until the formula is in CNF.\@ The principal limitation of this transformation lies in the possible exponential growth of the resulting formula compared to the original (e.g., when the formula is %\ignoreinlong{in DNF}\ignoreinshort{
a disjunction of conjunctions of sub-formulas), %}), 
making it unsuitable for modern SAT %\ignoreinshort{ 
and SMT %} 
solvers~(see e.g., \citeR{prestwichCNFEncodings2021}).

The \emph{Tseitin CNF-ization} (\TseitinCNF{})~\cite{tseitin68} avoids this exponential blow-up by labelling each sub-formula $\vi_i$ with a fresh Boolean atom $B_i$, which is used as a placeholder for the sub-formula. Specifically, it consists in applying recursively bottom-up the rewriting rule $\vi\Longrightarrow\vi[\vi_i|B_i] \wedge \DeMorganCNF(B_i\iff\vi_i)$ until the resulting formula is in CNF, where $\vi[\vi_i|B_i]$ is the formula obtained by substituting in $\vi$ every occurrence of $\vi_i$ with $B_i$.

The \emph{Plaisted and Greenbaum CNF-ization} (\PlaistedCNF{})~\cite{plaisted1986structure} is a variant of the \TseitinCNF{} that exploits the polarity of sub-formulas to reduce the number of clauses of the final formula. Specifically, if a sub-formula $\vi_i$ appears only with positive \resp{negative} polarity, then it can be labelled with a single implication as $\DeMorganCNF(B_i\imp\vi_i)$ \resp{$\DeMorganCNF(B_i\limp\vi_i)$}.

With both \TseitinCNF{} and \PlaistedCNF{}, due to the introduction of the label variables, the final formula does not preserve the %\ignoreinshort{
propositional %}
equivalence with the original formula but only the equisatisfiability.
Moreover, they also have a stronger property.
If $\vi(\allalpha)$ is a non-CNF formula and $\vicnf(\allalpha\cup\allB)$ is either the \TseitinCNF{} or the \PlaistedCNF{} encoding of $\vi$, where $\allB$ are the fresh Boolean atoms introduced by the transformation, then $\vi(\allalpha)\pequiv\exists\allB.\vicnf(\allalpha\cup\allB)$.

% \begin{ignoreinlongenv}
%     \paragraph*{Total and partial truth assignments.}
%     % \begin{definition}
%     Given a set of Boolean atoms $\allA$, a \emph{total truth assignment} is a total map $\eta: \allA\longmapsto\B$.
%     A \emph{partial truth assignment} is a partial map $\mu: \allA\longmapsto\B$.
%     % \end{definition}
%     Notice that a partial truth assignment represents $2^K$ total truth assignments, where $K$ is the number of unassigned variables by $\mu$.
%     With a little abuse of notation, we sometimes represent a truth assignment either as a set, s.t.\ $\mu\defas\set{A\ |\ \mu(A)=\top}\cup\set{\neg A\ |\ \mu(A)=\bot}$, or as a cube, s.t.\ $\mu\defas\bigwedge_{\mu(A)=\top}{A}\wedge\bigwedge_{\mu(A)=\bot}{\neg A}$.
%     If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that $\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of $\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict super-assignment}} of $\mu_1$.
%     We denote with $\residual{\vi}{\mu}$ the \emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by substituting in $\vi$ each $A_i\in\allA$ with $\mu(A_i)$, and by recursively applying the standard propagation rules of truth values through Boolean operators.

%     % \begin{definition}
%     Given a set of Boolean atoms $\allA$ and a formula $\vi(\allA)$, we say that a \emph{[partial or total] truth assignment $\mu:\allA\longmapsto\B$ satisfies} $\vi$, denoted as $\mu\pmodels\vi$, iff $\residual{\vi}{\mu}=\top$.\footnote{
%         The definition of satisfiability by partial assignment may present some ambiguities for non-CNF and existentially-quantified formulas~\cite{sebastiani_are_2020,mohle_four_2020}. Here we adopt the above definition because it is the easiest to implement,\ignoreinshort{\GMCHANGE{\ the most efficient to compute,}} and it is the one typically used by state-of-the-art SAT solvers. {We refer to the works by~\citeA{sebastiani_are_2020,mohle_four_2020} for details.}
%     } If $\mu\pmodels\vi$, then we say that $\mu$ is a \emph{model} of $\vi$.
%     % \end{definition}
%     % \footnote{
%     %}
%     A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff $\mu\pmodels\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such that $\mu{}'\not\pmodels\vi$.
% \end{ignoreinlongenv}


Most of the modern SAT and SMT solvers do not deal directly with non-CNF formulas, rather they convert them into CNF by using either \TseitinCNF{} or \PlaistedCNF{},
% \ignoreinlong{. As seen in the previous paragraph, since these transformations introduce fresh atoms into the resulting formulas, a model of $\vi(\allalpha)$ can be found as a truth assignment satisfying $\exists\allB.\vicnf(\allalpha\cup\allB)$.}%
%\ignoreinshort{, 
and then find truth assignments propositionally satisfying $\vi(\allalpha)$ by finding truth assignments propositionally satisfying $\exists\allB.\vicnf(\allalpha\cup\allB)$. %}
% \begin{definition}
% \end{definition}


% \RSNOTE{@Gabriele: nota che qui ho tolto la parte relativa a ``\any'',
%   perche' non l'abbiamo definita chiaramente, e perche' e' inutile, in
% quanto deriva dal fatto che la proprietà e' in ``iff''.}
% GM: Ok

% The work of this paper focuses on the following result from~\cite{sebastiani_are_2020}.
% \begin{lemma}%
%     \label{lemma:noncnf-sat}
%     Let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA\cup\allB)$ be the result of applying either the \TseitinCNF{} or the \PlaistedCNF{} transformation to $\vi$.\\
%     Given a total truth assignment $\etaA:\allA\longmapsto\B$, then  $\etaA\pmodels\vi$ iff $\etaA\pmodels\exists\allB.\vicnf$. However, given a partial truth assignment $\muA:\allA\longmapsto\B$, then  $\muA\pmodels\vi$ if $\muA\pmodels\exists\allB.\vicnf$, but the reverse implication does not hold. 
% \end{lemma}
% \GMNOTE{Dobbiamo dimostrarlo per Plaisted?}


\subsection{AllSAT, %\ignoreinshort{, 
    AllSMT,
    %}\ignoreinlong{ and} 
    Projected AllSAT %\ignoreinshort{\ 
    and Projected AllSMT}%}%
\label{sec:background:allsat}
AllSAT is the task of enumerating all the truth assignments %\ignoreinshort{
propositionally %}
satisfying a propositional formula.\@ %\ignoreinlong{In this paper, we focus on the enumeration of disjoint models, that is, pairwise mutually-inconsistent models.}
% \begin{ignoreinshortenv}
The task can be found in the literature in two versions: \emph{disjoint} AllSAT, in which the assignments are required to be pairwise mutually-inconsistent, and \emph{non-disjoint} AllSAT, in which they are not. %~\cite{yu_all-sat_2014}.
A generalization to the \smtt{} case is All\smtt{}, defined as the
task of enumerating all the \T{}{\em -satisfiable} truth assignments propositionally satisfying a \smtt{} formula. %\footnote{In the SMT literature the word ``AllSMT'' is used with slightly distinct meanings~\cite{hutchison_smt_2006,mathsat5_tacas13,phanAllSolutionSatisfiabilityModulo2015f}}. 
Also in this case, both disjoint or non-disjoint All\smtt{} are considered.

In the following, for the sake of compactness, we present definitions
and algorithms referring to AllSAT.
An extension to All\smtt{} can be obtained straightforwardly, by
substituting ``\allA'' with ``\allalpha'' and ``truth assignments'' with ``\T{}-satisfiable truth
assignments''.
%restricting to \T{}-satisfiable truth assignments.
% \end{ignoreinshortenv}

% \begin{definition}
Given a %\ignoreinlong{ Boolean} 
formula $\vi$, we denote with $\TTA{\vi}\defas\set{\eta_1,\dots,\eta_j\dots\eta_M}$ the set of all total truth assignments %\ignoreinshort{
propositionally %}
satisfying $\vi$.
% \end{definition}
% \begin{definition}
We denote with $\TA{\vi}\defas\set{\mu_1,\dots,\mu_i\dots,\mu_N}$ a set of partial truth assignments %\ignoreinshort{
propositionally %}
satisfying $\vi$ s.t.:
% \ignoreinlong{
%     \begin{enumerate}[(a)]
%         \item every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
%         \item every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
%     \end{enumerate}
% }
% \ignoreinshort{
\begin{enumerate}[(a)]
    \item\label{item:ta:complete} every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
\end{enumerate}
and, only in the \emph{disjoint} case:
\begin{enumerate}[(b)]
    \item\label{item:ta:disjoint} every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
\end{enumerate}
% }

% \end{definition}
Notice that, whereas $\TTA{\vi}$ is unique, multiple $\TA{\vi}$s are admissible for the same formula $\vi$, including $\TTA{\vi}$. AllSAT is the task of enumerating either $\TTA{\vi}$ or a set $\TA{\vi}$. Typically, AllSAT solvers aim at enumerating a set $\TA{\vi}$ %\ignoreinshort{
which is %}
as small as possible, since every partial %\ignoreinlong{model}\ignoreinshort{
truth assignment %} 
prevents from enumerating a number of total %\ignoreinlong{models}\ignoreinshort{
truth assignments %} 
that is exponential w.r.t.\ the number of unassigned atoms, so that to save computational space and time.

%\mathsat{}~\cite{mathsat5_tacas13}, the SAT/SMT solver that we used for our experiments.\GMSIDENOTE{Riscrivere non riferendosi solo a mathsat}
The enumeration of a $\TA{\vi}$ for a non-CNF formula $\vi$ is
typically implemented by first converting it into CNF, and then by enumerating its %\ignoreinlong{models}\ignoreinshort{
satisfying assignments %} 
by means of \emph{Projected AllSAT}.
%\ignoreinshort{\GMCHANGE{/AllSMT}}}.
Specifically, let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA\cup\allB)$ be the result of applying either \TseitinCNF{} or \PlaistedCNF{} to $\vi$, where $\allB$ is the set of Boolean atoms introduced by either transformation. $\TA{\vi}$ is enumerated via Projected AllSAT %\ignoreinshort{\GMCHANGE{/AllSMT}} 
as $\TA{\exists\allB.\vicnf}$, i.e.\ as a set of (partial) truth assignments over $\allA$ that can be extended to total %\ignoreinlong{models of}\ignoreinshort{
truth assignments satisfying %} 
$\vicnf$ over $\allA\cup\allB$. %, as a consequence of \cref{lemma:noncnf-sat}. 
We refer the reader to the general schema described by~\citeA{hutchison_smt_2006}, which we briefly recap here.\\
Let $\vicnf(\allA\cup\allB)$ be a CNF formula over two disjoint sets
of %\ignoreinlong{Boolean variables}\ignoreinshort{
atoms %} 
$\allA, \allB$, where $\allA$ is a set of
\emph{relevant atoms} s.t.\ we want to enumerate a
$\TA{\exists\allB.\vicnf}$.
%\begin{rschange}
%\ignoreinshort{
For disjoint AllSAT, the %}\ignoreinlong{The} 
solver enumerates one-by-one partial
truth assignments $\mu_1,\dots,\mu_i,\dots\mu_N$ which comply with
point~\ref{item:ta:complete} above where each
$\mu_i\defas\muA_i\cup\etaB_i$ is s.t.:
\begin{enumerate}[(i)]
    \item\label{item:mumodelsvi} (\emph{satisfiability}) $\mu_i\pmodels\vicnf$;
    \item\label{item:musdisjoint} (\emph{disjointness}) for each
    $j<i$, $\muA_i,\muA_j$ assign opposite truth values to some atom in $\allA$;
    \item\label{item:muAminimal} (\emph{minimality}) $\muA_i$ is \emph{minimal}, meaning that no literal can be dropped from it without losing properties~\ref{item:mumodelsvi} and~\ref{item:musdisjoint}.
    % \GMSIDENOTE{la property~\ref{item:muAminimal} può essere ``rilassata''? E.g., se uso chronological backtracking dovrei riuscire a produrre assignment parziali più corti anche se non sono necessariamente ``minimali'' nel senso in cui è inteso qui. Magari solo una footnote.
    % }
\end{enumerate}
%\ignoreinshort{
For the non-disjoint case, property~\ref{item:musdisjoint} is omitted and the reference to it in~\ref{item:muAminimal} is dropped.
Property~\ref{item:muAminimal} is not strictly necessary, but it is highly desirable. %}\RSSIDENOTE{Da rivedere}

A basic %\ignoreinlong{ disjoint} 
AllSAT procedure (implemented e.g.\ in
\mathsatfive{}, \citeR{mathsat5_tacas13}) works as follows. At each step $i$, it finds a total truth
assignment $\eta_i\defas\etaA_i\cup\etaB_i$ s.t.\
$\eta_i\pmodels\psi_i$, where $\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$,
and then invokes a minimization procedure on $\etaA_i$ to compute a
partial truth assignment $\muA_i$ satisfying
properties~\ref{item:mumodelsvi},~\ref{item:musdisjoint}
and~\ref{item:muAminimal}.
Then, the solver adds the clause $\neg\muA_i$ %\ignoreinshort{---}
---to
ensure
property~\ref{item:musdisjoint} %\ignoreinshort{ 
for the disjoint version and to ensure an exhaustive exploration of the solutions space for the non-disjoint version--- %} 
and it continues the search. This process is iterated
until
    {%the formula 
        $\psi_{N+1}$
    }is found to be unsatisfiable for some $N$, and the set $\set{\muA_i}_{i=1}^N$ is returned.

The minimization procedure consists in iteratively dropping literals one-by-one from $\etaA_i$, checking if it still satisfies the
formula. The outline of
this minimization procedure is shown in \cref{alg:minimize}.
Each minimization step is
$O(\#\mathit{clauses}\cdot\#\mathit{vars})$.


\begin{algorithm}[t]
    \begin{algorithmic}[1]
        %\begin{rschange}
        \caption[A]{{\sc Minimize-Assignment}($\psi_i, \eta_i, \allA$)
            \hfill \\
            % \ignoreinlong{$\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$,}%
            % say that if disjoint then ... otherwise only \psi
            % \ignoreinshort{
            \null\quad $\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$ if disjoint, $\psi_i\defas\psi$ if non-disjoint \\%
            % }%
            \null\quad $\eta_i = \etaA_i \cup \etaB_i$
            \label{alg:minimize}}
        \STATE $\muA_i \leftarrow \etaA_i$
        \FOR{$\ell\in\muA_i$}
        \IF{$\residual{\psi_i}{\muA_i\setminus\set{\ell}\ \cup\ \etaB_i} = \top$}
        \STATE $\muA_i \leftarrow \muA_i \setminus \set{\ell}$
        \ENDIF
        \ENDFOR
        \RETURN $\muA_i$
        %\end{rschange}
    \end{algorithmic}
\end{algorithm}


Notice that, since we are in the context of {\em projected} AllSAT,
the minimization
algorithm only minimizes the relevant %\ignoreinshort{
atoms %}\ignoreinlong{variables} 
in $\allA$,
%although 
and the
truth value of existentially quantified variables in $\allB$ is still
used to check the satisfiability of the formula by the current partial
assignment.\@ Moreover, %\ignoreinshort{
in the disjoint case, %} 
to enforce the pairwise disjointness between the
assignments, $\psi_i$ in \cref{alg:minimize} refers to the original
formula conjoined with all current blocking clauses $\bigwedge_{j=1}^{i-1}\neg\muA_j$, %\ignoreinshort{
whereas in the non-disjoint case $\psi_i$ refers to the original formula only, allowing for a more effective minimization and possibly renouncing the disjointness property. %}. 
Conflict clauses are excluded by the minimization, being redundant.
% \ignoreinshort{
The same procedure can be easily generalized to disjoint and non-disjoint All\smtt{}, with the only difference that only \T-satisfiable total truth assignments $\eta_i$ are considered. %, and the minimization procedure is applied to the Boolean abstractions of $\psi_i$ and $\eta_i$.
% }

We stress the fact that the work described in this paper is agnostic
w.r.t.\  the %\ignoreinlong{disjoint }
AllSAT %\ignoreinshort{
or AllSMT %}
procedure used, provided its
% \ignoreinlong{output assignments match conditions~\ref{item:mumodelsvi}-\ref{item:muAminimal} above.}
% \ignoreinshort{
enumeration strategy matches the above conditions. %}


% \GMNOTE{Mention different enumeration approaches, e.g., blocking/non-blocking~\cite{todaImplementingEfficientAll2016}, different minimization techniques (see~\citeR{todaImplementingEfficientAll2016,morgadoGoodLearningImplicit2005,raviMinimalAssignmentsBounded2004}). Mention methods not matching these conditions, e.g., bdd-based, Dualiza}

%\end{rschange}

