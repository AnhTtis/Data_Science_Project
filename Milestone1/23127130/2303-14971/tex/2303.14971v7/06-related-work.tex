% \begin{gmchange}
% \GMTODO{Other AllSAT applications (from~\cite{morgadoGoodLearningImplicit2005,todaImplementingEfficientAll2016,zhangAcceleratingAllSATComputation2020}): in data mining (e.g., frequent itemsets), network verification, image and preimage computation in unbounded Model Checking. AllSMT: predicate abstraction, in probabilistic reasoning (e.g., \#SMT, WMI).}
\paragraph{Applications of AllSAT and AllSMT}
SAT and \smt{} enumeration has an important role in a variety of applications,
ranging from artificial intelligence to formal verification. AllSAT and AllSMT,
mainly in their disjoint version, play a foundational role in several
frameworks for \emph{probabilistic reasoning}, such as model counting in
\smt{}~(\emph{\#\smt})~\cite{chistikovApproximateCountingSMT2017} and
\emph{Weighted Model Integration
    (WMI)}~\cite{belleProbabilisticInferenceHybrid2015,morettin-wmi-ijcar17,morettin-wmi-aij19,spallittaSMTbasedWeightedModel2022,spallittaEnhancingSMTbasedWeighted2024a}.
Specifically,
\#\smtlarat{}~\cite{maVolumeComputationBoolean2009,zhouEstimatingVolumeSolution2015,geComputingEstimatingVolume2018}
consists in summing up the volumes of the convex polytopes defined by each of
the \larat{}-satisfiable truth assignments propositionally satisfying a
\smtlarat{} formula, and has been employed for value estimation of
probabilistic programs~\cite{chistikovApproximateCountingSMT2017} and for
quantitative program analysis~\cite{liuProgramAnalysisQualitative2011}.\@ WMI
can be seen as a generalization of \#\smtlarat{} that additionally considers a
weight function $w$ that has to be integrated over each of such polytopes, and
has been used to perform inference in hybrid probabilistic models such as
Bayesian and Markov networks~\cite{belleProbabilisticInferenceHybrid2015} and
Density Estimation Trees~\cite{spallittaSMTbasedWeightedModel2022}.
%Hence, in these cases, it is essential to enumerate disjoint partial truth assignments that are as small and as few as possible.
%
%
AllSAT, both disjoint and non-disjoint, has applications also in \emph{data
    mining}, where the problem of frequent itemsets can be encoded into a
propositional formula whose satisfying assignments are the frequent
itemsets~\cite{boudaneSATbasedApproachMining2016,dlalaComparativeStudySATBased2016}.
%Specifically, in \#SMT(\larat) consists in summing up the volumes of the convex polytopes defined by each of the assignments, whereas in WMI some function $w$ has to be integrated over each of such polytopes. %Hence, in these cases, it is essential to enumerate disjoint partial \ignoreinlong{models}\ignoreinshort{\GMCHANGE{truth assignments}} that are as small and as few as possible.
% In the context of knowledge compilation (cite), AllSAT can be used to compile a formula into deterministic Decomposable Normal Form (d-DNNF) (cite), that has found applications, e.g., in planning (cite). 
It has also been used in the context of \emph{software testing} to generate a
suite of test inputs that should match a given
output~\cite{khurshidCaseEfficientSolution2004}, and in \emph{circuit design},
to convert a formula from CNF to
DNF~\cite{minatoFindingAllSimple1998,miltersenConvertingCNFDNF2005,bernasconiCompactDSOPPartial2013},
and for Static Timing Analysis to determine the inputs that can trigger a
timing violation in a circuit~\cite{friedAllSATCombinationalCircuits2023}.
AllSAT and AllSMT have also been applied in \emph{network verification} for
checking network reachability and for analyzing the correctness and consistency
of network connectivity
policies~\cite{lopes2013network,jayaraman2014automated,lopesCheckingBeliefsDynamic2015}.
Moreover, they have been used for computing the image and preimage of a given
set of states in \emph{unbounded model
    checking}~\cite{mcmillanApplyingSATMethods2002,grumbergMemoryEfficientAllSolutions2004,liNovelSATAllsolutions2004},
and they are also at the core of algorithms for computing \emph{predicate
    abstraction}, a concept widely used in formal verification for automatically
computing finite-state abstractions for systems with potentially infinite state
space~\cite{lahiriSymbolicApproachPredicate2003,clarkePredicateAbstractionANSIC2004,lahiriSMTTechniquesFast2006}.

\paragraph{AllSAT}
Most of the works on AllSAT have focused on the enumeration of satisfying
assignments for CNF formulas
(e.g.,~\cite{morgadoGoodLearningImplicit2005,huangUsingDPLLEfficient2004,yuAllSATUsingMinimal2014,todaBDDConstructionAll2015,todaImplementingEfficientAll2016,liangAllSATCCBoostingAllSAT2022,spallittaDisjointPartialEnumeration2024}),
with several efforts in developing efficient and effective techniques for
minimizing partial assignments
(e.g.,~\cite{raviMinimalAssignmentsBounded2004,morgadoGoodLearningImplicit2005,todaImplementingEfficientAll2016}).
The problem of minimizing truth assignments for Tseitin-encoded problems was
addressed in~\cite{iserMinimizingModelsTseitinEncoded2013a}. They propose to
%first simplify the formula by considering its original structure and the current model; then they 
make iterative calls to a SAT solver imposing increasingly tighter cardinality
constraints to obtain a minimal assignment. Whereas this approach can be used
to find a single short truth assignment, it can be very expensive, and thus it
is unsuitable for enumeration.

Other works have concentrated on the enumeration of satisfying assignments for
combinatorial circuits, exploiting the structural information of the circuits
to minimize the partial assignments over the input variables
(e.g.,~\cite{jinEfficientConflictAnalysis2005,jin2005prime,tibebuAugmentingAllSolution2018,friedAllSATCombinationalCircuits2023,friedEntailingGeneralizationBoosts2024}).
%
% \begin{gmchange}
In \cite{lagniezLeveragingDecisionDNNFCompilation2024}, the authors proposed a tool to enumerate disjoint partial satisfying assignments of formulas in decomposable, deterministic NNF (d-DNNF).
The tool takes as input a d-DNNF formula compiled with \df{}~\cite{lagniezImprovedDecisionDNNFCompiler2017}, and then efficiently traverses it to enumerate the partial assignments.
However, projected d-DNNFs typically do not allow for finding short partial assignments~\cite{lagniezRecursiveAlgorithmProjected2019}, and hence preprocessing the formula with our encoding does not bring any benefit, as confirmed by the experimental evaluation in~\sref{sec:experiments:others}.
% Most d-DNNF compilers, such as \textsc{D4}~\cite{lagniezImprovedDecisionDNNFCompiler2017} used in their evaluation, compile formulas from CNF to d-DNNF, possibly projected over a set of relevant atoms. Hence, in principle, this tool can be used to perform AllSAT on any formula, by first converting it into CNF, and then compiling it into a d-DNNF projected over the original atoms, and finally enumerating the assignments. 
% This three-step approach, however, would not be very effective, due to the compilation strategy of \textsc{D4} for projected d-DNNFs~\cite{lagniezRecursiveAlgorithmProjected2019}.
% \textsc{D4} uses a DPLL-like compilation strategy, where decisions are made on relevant atoms first. Whenever no relevant atom occurs in the current formula, a SAT solver is invoked to see if the assignment can be extended to non-relevant atoms. This search strategy prevents finding short, and even more so, minimal partial assignments~\cite{lagniezRecursiveAlgorithmProjected2019}. 
% \GMCHANGE{This analysis was confirmed also by experimental evidence, which we report in Appendix~\ref{appendix:d4:enum}.
% }
%Moreover, using different CNF encodings would not help, since the SAT solver is invoked only when no important atom occurs in the formula. % Other d-DNNF compilers, e.g., \textsc{c2d}~\cite{darwicheCompilerDeterministicDecomposable2002} and \textsc{DSharp}~\cite{muiseDsharpFastDDNNF2012}, also work on CNF input and implement similar strategies, and would likely suffer from the same limitations. 
% \end{gmchange}

A problem closely related to AllSAT is that of finding all the prime implicants
of a formula
(e.g.,~\cite{previtiPrimeCompilationNonClausal,jabbourEnumeratingPrimeImplicants2014,luoEfficientTwophaseMethod2021}).
AllSAT is a much simpler problem, and can be viewed as the problem of finding a
subset of implicants (i.e., partial satisfying assignments), not necessarily
prime (i.e., minimal), which covers all the total satisfying assignments of the
formula.
%not-necessarily-prime implicant cover for the formula.

\paragraph{Projected AllSAT}
Projected enumeration, i.e., enumeration of satisfying assignments over a set
of relevant atoms, has been studied mainly for CNF formulas, e.g.,
in~\cite{grumbergMemoryEfficientAllSolutions2004,liNovelSATAllsolutions2004,lahiriSMTTechniquesFast2006,todaExploitingFunctionalDependencies2017,spallittaDisjointProjectedEnumeration2025}.
The ambiguity of the notion of ``satisfiability by partial assignment'' for
non-CNF and existentially-quantified formulas has been raised
in~\cite{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020,sebastianiEntailmentVsVerification2025},
highlighting the difference between ``evaluation to true'', which is simpler to
check and typically used by SAT solvers, and ``logical entailment'', which
allows for producing shorter assignments. The approach based on dual reasoning
in~\cite{mohleDualizingProjectedModel2018,mohleEnumeratingShortProjected2025},
although able to detect logical entailment and thus to produce shorter partial
assignments, is very inefficient even for small formulas. %\GMCHANGEp{, %}. 

\paragraph{AllSMT}
The literature on AllSMT is very limited, and AllSMT algorithms are highly
based on AllSAT techniques and tools. For instance,
\mathsatfive{}~\cite{mathsat5_tacas13} implements an AllSMT functionality based
on the procedure in~\cite{lahiriSMTTechniquesFast2006}. A similar procedure
has been described in~\cite{phanAllSolutionSatisfiabilityModulo2015}. An
AllSMT algorithm based on chronological backtracking has been recently proposed
in~\cite{spallittaDisjointProjectedEnumeration2025}.

\paragraph{Enumeration in related areas}
%    Enumeration of satisfying assignments is also relevant in neighboring areas.   
In Answer Set Programming (ASP), answer sets can be seen as truth assignments
satisfying a logic program. ASP programs can be translated into CNF formulas
and vice versa, so as to have a one-to-one correspondence between satisfying
assignments and answer
sets~\cite{clarkNegationFailure1978,linASSATComputingAnswer2004}. Answer sets,
however, correspond to \emph{total} truth assignments. %Modern ASP solvers are indeed based on AllSAT solvers (e.g.,~\cite{giunchigliaAnswerSetProgramming2006,gebserConflictDrivenAnswerSet2007,gebserSolutionEnumerationProjected2009}). %\footnote{
%     See also \url{https://github.com/potassco/clingo/issues/512\#issuecomment-2223162682}.
% }
Thus, our work is not directly applicable to ASP. %, as no minimization of partial assignments is performed. 
%In principle, if the notion of partial assignment were to be extended to ASP, our approach could be used to enumerate partial answer sets.

Propositional Model Counting (\#SAT) is the task of \emph{counting} the number
of satisfying assignments of a propositional formula. Counting is simpler than
enumeration, since only the number of truth assignments is relevant, but a
complete exploration of the space of solutions is still needed. (This is
different from \#SMT, where each truth assignment is ``consumed'' to compute a
volume.) Efficient algorithms have been developed for \#SAT on CNF formulas,
mostly based either on DPLL-like exhaustive search, or on Knowledge Compilation
(see~\cite{gomesModelCounting2021}).
%
\ignore{% RS: spostato in sez 5
    Typically, they do not rely their efficiency on the enumeration of \emph{short} partial assignments, but rather on decomposition and caching of subproblems, so that the usage of our encoding is not expected to bring any benefit, as confirmed by the experimental evaluation in~\sref{sec:experiments:others}.}
%Hence, we do not expect \#SAT algorithms to benefit from our encoding, as confirmed by the experimental evaluation in~\sref{sec:experiments:d4}.
% We report in Appendix~\ref{appendix:d4:counting} an experimental evaluation of our encoding for \#SAT with \df~\cite{lagniezImprovedDecisionDNNFCompiler2017}.
Notably,~\cite{azizExistsSATProjected2015} proposed the model counter
\textsc{\#clasp} based on enumeration of minimal partial assignment, which
would likely benefit from our encoding. Unfortunately, we did not receive an
answer from the authors about the availability of the tool.
%
% The role of CNF encodings in \#SAT has been analyze, e.g., by~\citeA{kuiterTseitinNotTseitin2022}.
%This said, we remark that the Tseitin CNF preserves the model count, and so it is the most obvious choice for \#SAT. The Plaisted and Greenbaum CNF, instead, would require performing \emph{projected} model counting (\#$\exists$SAT)~\cite{azizExistsSATProjected2015} on the original atoms, which is typically harder than \#SAT. 

\paragraph{The role of CNF encodings}
Although most AllSAT solvers assume the formulas to be in CNF, little or no
work has been done to investigate the impact of the different CNF encodings on
their effectiveness and efficiency. The role of the CNF-ization has been widely
studied for SAT solving
(e.g.,~\cite{boydelatourOptimalityResultClause1992,jacksonClauseFormConversions2005,bjorkSuccessfulSATEncoding2009,kuiterTseitinNotTseitin2022})
and in a recent work also for propositional model counting in the context of
feature model analysis~\cite{kuiterTseitinNotTseitin2022}.

% \subparagraph{Dual-rail encoding.}%
% \label{sec:dualrail}
The idea of using two different variables to label the positive and negative occurrences of a sub-formula shares some similarities with the so-called \emph{dual-rail} encoding~\cite{bryantCOSMOSCompiledSimulator1987,palopoliAlgorithmsSelectiveEnumeration1999}, which has been shown to be successful for prime implicant enumeration~\cite{%palopoliAlgorithmsSelectiveEnumeration1999,
    previtiPrimeCompilationNonClausal,luoEfficientTwophaseMethod2021}, and recently also for AllSAT on combinatorial circuits~\cite{friedAllSATCombinationalCircuits2023}.

Given a CNF formula, the dual-rail encoding maps each atom $A_i$ into a pair of
dual-rail atoms $\pair{\poslab{A_i}}{\neglab{A_i}}$, s.t.\ $A_i,\neg{}A_i$ are
substituted with $\poslab{A_i},\neglab{A_i}$, respectively, and
$(\neg\poslab{A_i}\vee\neg\neglab{A_i})$ is conjoined with the formula. The
resulting CNF formula is equisatisfiable to the original one, and every total
assignment $\eta$ satisfying the dual-rail encoding corresponds to a partial
assignment $\mu$ satisfying the original formula. Such $\mu$ assigns $\mu(A_i)$
to $\top$ or $\bot$ if the pair $\pair{\eta(\poslab{A_i})}{\eta(\neglab{A_i})}$
is $\pair{\top}{\bot}$ or $\pair{\bot}{\top}$, respectively, and leaves it
unassigned if
$\pair{\eta(\poslab{A_i})}{\eta(\neglab{A_i})}=\pair{\bot}{\bot}$. Short
partial assignments can be obtained by maximizing the number of pairs assigned
to $\pair{\bot}{\bot}$, which can be done either exactly by solving a MaxSAT
problem, or heuristically by assigning negative value first to decision
atoms~\cite{friedAllSATCombinationalCircuits2023}.

% \begin{gmchangep}

Using the dual-rail encoding for enumeration, however, requires ad-hoc
enumeration algorithms, since the solver must take into account the
three-valued semantics of truth assignments over dual-rail atoms when
enumerating the assignments~\cite{friedAllSATCombinationalCircuits2023}. Our
contribution, instead, focuses on CNF-ization approaches that can be used in
combination with any enumeration algorithm matching the properties described
in~\sref{sec:background:allsat}.
%
Also, comparing the $\NNFPlaisted{}$ encoding with the dual-rail encoding, we
observe that the former duplicates only the label atoms in $\allB{}$,
introducing fewer atoms than the dual-rail encoding. Moreover, because of this,
the clauses in the form $(\neg\poslab{B_i}\vee\neg\neglab{B_i})$ are not needed
for correctness but only for efficiency, and can in principle be omitted. In
the dual-rail encoding, instead, their presence is essential to prevent the
illegal assignment $\eta(\poslab{B_i})=\eta(\neglab{B_i})=\top$.

% \end{gmchangep}

% Also, differently from the approach by~\citeA{friedAllSATCombinationalCircuits2023}, our approach does not require implementing ad-hoc enumeration algorithms, and any enumeration strategy matching conditions~\ref{item:mumodelsvi}-\ref{item:muAminimal} in \sref{sec:background:allsat} can benefit from it.
%
% A technique that has gained some success in SAT enumeration is the so-called dual-rail encoding~\cite{bryantCOSMOSCompiledSimulator1987%,palopoliAlgorithmsSelectiveEnumeration1999
% }. E.g.,~\citeA{friedAllSATCombinationalCircuits2023} exploit it to enumerate short partial assignments for circuits, and also~\citeA{%palopoliAlgorithmsSelectiveEnumeration1999,
%     previtiPrimeCompilationNonClausal,luoEfficientTwophaseMethod2021} use it in the context of prime implicants enumeration. %We highlight the main similarities and differences of this encoding with the encoding proposed in this paper in~\sref{sec:dualrail}.

% Other works on AllSAT:
% \begin{itemize}
%     \item AllSAT-CNF
%     \begin{itemize}
%         \item \cite{morgadoGoodLearningImplicit2005} survey, minimization techniques for AllSAT-CNF.
%         \item \cite{todaImplementingEfficientAll2016} survey (BC, NBC)
%         \item \cite{raviMinimalAssignmentsBounded2004} minimization for CNF
%         \item \cite{yuAllSATUsingMinimal2014}. Non-disjoint all-sat (CNF), add blocking clauses involving only decision variables.
%         \item \cite{liangAllSATCCBoostingAllSAT2022} Exploit component analysis in enumeration (CNF). No projected. 
%     \end{itemize}
%     \item AllSAT-Circuits: the general idea is to first convert the formula into CNF and once a satisfying assignment is found, exploit the circuit structural information to find a minimal partial assignment.
%     \begin{itemize}
%         \item \cite{jinEfficientConflictAnalysis2005}. Enumerate models of AIG.
%         \item \cite{jin2005prime}. Enumeration of minimal model for circuits.
%         \item \cite{tibebuAugmentingAllSolution2018}. Enumeration of minimal models for AIG.
%         \item Paper Nadel. Enumeration of minimal models for circuits.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
%     \item \cite{huangUsingDPLLEfficient2004,todaBDDConstructionAll2015,todaImplementingEfficientAll2016} compile a propositional formula into a BDD and then enumerate all the satisfying assignments by traversing the BDD.\@ OBDDs can be used also to cache intermediate results.
%     \item \cite{todaExploitingFunctionalDependencies2017} Extend result above to projected enumeration. However, the satisfiability for the existentially quantified formula is not based on entailment (?).
% \end{itemize}

% Enumeration of all the prime implicants:
% \begin{itemize}
%     \item \cite{previtiPrimeCompilationNonClausal} find all the prime implicants and a prime implicates cover for a non-CNF formula. Exploit dual-rail encoding. (tool Primer, not available) 
%     \item \cite{luoEfficientTwophaseMethod2021} first compile the formula into an \textbf{equivalent} CNF, by finding a cover of prime or small implicates, and then find all the prime implicants of the CNF, also in this case exploiting dual-rail encoding. (tool CoAPI, available)
% \end{itemize}

% Dual rail encoding

% The impact of using different CNF encodings on the performance for SAT and SMT solving has been widely studied in the literature~\cite{boydelatourOptimalityResultClause1992,jackson_optimality_2004,bjorkSuccessfulSATEncoding2009,kuiterTseitinNotTseitin2022}.

% \end{gmchange}
