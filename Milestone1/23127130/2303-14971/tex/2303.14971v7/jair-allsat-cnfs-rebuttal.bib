@article{alvianoModelEnumerationPropositional2017,
  title = {Model Enumeration in Propositional Circumscription via Unsatisfiable Core Analysis},
  author = {Alviano, Mario},
  year = {2017},
  month = sep,
  journal = {Theory and Practice of Logic Programming},
  volume = {17},
  number = {5-6},
  pages = {708--725},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068417000278},
  urldate = {2024-08-22},
  abstract = {Many practical problems are characterized by a preference relation over admissible solutions, where preferred solutions are minimal in some sense. For example, a preferred diagnosis usually comprises a minimal set of reasons that is sufficient to cause the observed anomaly. Alternatively, a minimal correction subset comprises a minimal set of reasons whose deletion is sufficient to eliminate the observed anomaly. Circumscription formalizes such preference relations by associating propositional theories with minimal models. The resulting enumeration problem is addressed here by means of a new algorithm taking advantage of unsatisfiable core analysis. Empirical evidence of the efficiency of the algorithm is given by comparing the performance of the resulting solver, circumscriptino, with hclasp, camus\_mcs, lbx and mcsls on the enumeration of minimal models for problems originating from practical applications.},
  langid = {english}
}

@inproceedings{biereCadiBackExtractingBackbones2023,
  title = {{{CadiBack}}: {{Extracting Backbones}} with {{CaDiCaL}}},
  shorttitle = {{{CadiBack}}},
  booktitle = {26th {{International Conference}} on {{Theory}} and {{Applications}} of {{Satisfiability Testing}}},
  author = {Biere, Armin and Froleyks, Nils and Wang, Wenxi},
  year = {2023},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.SAT.2023.3},
  urldate = {2024-08-22},
  abstract = {The backbone of a satisfiable formula is the set of literals that are true in all its satisfying assignments. Backbone computation can improve a wide range of SAT-based applications, such as verification, fault localization and product configuration. In this tool paper, we introduce a new backbone extraction tool called CadiBack. It takes advantage of unique features available in our state-of-the-art SAT solver CaDiCaL including transparent inprocessing and single clause assumptions, which have not been evaluated in this context before. In addition, CaDiCaL is enhanced with an improved algorithm to support model rotation by utilizing watched literal data structures. In our comprehensive experiments with a large number of benchmarks, CadiBack solves 60\% more instances than the state-of-the-art backbone extraction tool MiniBones. Our tool is thoroughly tested with fuzzing, internal correctness checking and cross-checking on a large benchmark set. It is publicly available as open source, well documented and easy to extend.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english}
}

@misc{CompileProjectCRILCNRS,
  title = {Compile! {{Project}} - {{CRIL-CNRS}} \& {{Univ}}. {{Artois}}},
  urldate = {2024-08-22},
  howpublished = {https://www.cril.univ-artois.fr/KC/index.html}
}

@misc{CrillabD42024,
  title = {Crillab/D4},
  year = {2024},
  month = mar,
  urldate = {2024-08-22},
  abstract = {d4 Model Counter},
  copyright = {LGPL-3.0},
  howpublished = {Centre de Recherche en Informatique de Lens}
}

@article{darwicheKnowledgeCompilationMap2002,
  title = {A Knowledge Compilation Map},
  author = {Darwiche, Adnan and Marquis, Pierre},
  year = {2002},
  month = sep,
  journal = {Journal of Artificial Intelligence Research},
  volume = {17},
  number = {1},
  pages = {229--264},
  issn = {1076-9757},
  abstract = {We propose a perspective on knowledge compilation which calls for analyzing different compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime. We then provide a knowledge compilation map, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and queries. We argue that such analysis is necessary for placing new compilation approaches within the context of existing ones. We also go beyond classical, flat target compilation languages based on CNF and DNF, and consider a richer, nested class based on directed acyclic graphs (such as OBDDs), which we show to include a relatively large number of target compilation languages.}
}

@inproceedings{gebserSolutionEnumerationProjected2009,
  title = {Solution {{Enumeration}} for {{Projected Boolean Search Problems}}},
  booktitle = {Integration of {{AI}} and {{OR Techniques}} in {{Constraint Programming}} for {{Combinatorial Optimization Problems}}},
  author = {Gebser, Martin and Kaufmann, Benjamin and Schaub, Torsten},
  editor = {{van Hoeve}, Willem-Jan and Hooker, John N.},
  year = {2009},
  pages = {71--86},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-01929-6_7},
  abstract = {Many real-world problems require the enumeration of all solutions of combinatorial search problems, even though this is often infeasible in practice. However, not always all parts of a solution are needed. We are thus interested in projecting solutions to a restricted vocabulary. Yet, the adaption of Boolean constraint solving algorithms turns out to be non-obvious provided one wants a repetition-free enumeration in polynomial space. We address this problem and propose a new algorithm computing projective solutions. Although we have implemented our approach in the context of Answer Set Programming, it is readily applicable to any solver based on modern Boolean constraint technology.},
  isbn = {978-3-642-01929-6},
  langid = {english}
}

@article{giunchigliaAnswerSetProgramming2006,
  title = {Answer {{Set Programming Based}} on {{Propositional Satisfiability}}},
  author = {Giunchiglia, Enrico and Lierler, Yuliya and Maratea, Marco},
  year = {2006},
  month = apr,
  journal = {Journal of Automated Reasoning},
  volume = {36},
  number = {4},
  pages = {345--377},
  issn = {1573-0670},
  doi = {10.1007/s10817-006-9033-2},
  urldate = {2024-07-25},
  abstract = {Answer set programming (ASP) emerged in the late 1990s as a new logic programming paradigm that has been successfully applied in various application domains. Also motivated by the availability of efficient solvers for propositional satisfiability (SAT), various reductions from logic programs to SAT were introduced. All these reductions, however, are limited to a subclass of logic programs or introduce new variables or may produce exponentially bigger propositional formulas. In this paper, we present a SAT-based procedure, called ASPSAT, that (1) deals with any (nondisjunctive) logic program, (2) works on a propositional formula without additional variables (except for those possibly introduced by the clause form transformation), and (3) is guaranteed to work in polynomial space. From a theoretical perspective, we prove soundness and completeness of ASPSAT. From a practical perspective, we have (1) implemented ASPSAT in Cmodels, (2) extended the basic procedures in order to incorporate the most popular SAT reasoning strategies, and (3) conducted an extensive comparative analysis involving other state-of-the-art answer set solvers. The experimental analysis shows that our solver is competitive with the other solvers we considered and that the reasoning strategies that work best on `small but hard' problems are ineffective on `big but easy' problems and vice versa.},
  langid = {english}
}

@inproceedings{iserMinimizingModelsTseitinEncoded2013,
  title = {Minimizing {{Models}} for {{Tseitin-Encoded SAT Instances}}},
  booktitle = {16th {{International Conference}} on {{Theory}} and {{Applications}} of {{Satisfiability Testing}}},
  author = {Iser, Markus and Sinz, Carsten and Taghdiri, Mana},
  year = {2013},
  month = jul,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {224--232},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-39071-5_17},
  urldate = {2023-11-17},
  abstract = {Many applications of SAT solving can profit from minimal models---a partial variable assignment that is still a witness for satisfiability. Examples include software verification, model checking, and counterexample-guided abstraction refinement. In this paper, we examine how a given model can be minimized for SAT instances that have been obtained by Tseitin encoding of a full propositional logic formula. Our approach uses a SAT solver to efficiently minimize a given model, focusing on only the input variables. Experiments show that some models can be reduced by over 50 percent.},
  isbn = {978-3-642-39070-8},
  langid = {english}
}

@article{janotaAlgorithmsComputingBackbones2015,
  title = {Algorithms for {{Computing Backbones}} of {{Propositional Formulae}}},
  author = {Janota, Mikol{\'a}{\v s} and Lynce, In{\^e}s and {Marques-Silva}, Joao},
  year = {2015},
  month = jan,
  journal = {AI Communications},
  volume = {28},
  pages = {161--177},
  issn = {0921-7126},
  doi = {10.3233/AIC-140640},
  urldate = {2024-08-22},
  abstract = {The problem of propositional satisfiability (SAT) has found a number of applications in both theoretical and practical computer science. In many applications, however, knowing a formula's satisfiability alone is insufficient. Often, some other proper},
  langid = {english}
}

@inproceedings{kilbyBackbonesBackdoorsSatisfiability2005,
  title = {Backbones and {{Backdoors}} in {{Satisfiability}}},
  booktitle = {Proceedings of the {{AAAI Conference}} on {{Artificial Intelligence}}},
  author = {Kilby, Philip and Slaney, John and Thi{\'e}baux, Sylvie and Walsh, Toby},
  year = {2005},
  month = jul,
  series = {{{AAAI}}'05},
  volume = {3},
  pages = {1368--1373},
  publisher = {AAAI Press},
  address = {Pittsburgh, Pennsylvania},
  urldate = {2024-08-22},
  abstract = {We study the backbone and the backdoors of propositional satisfiability problems. We make a number of theoretical, algorithmic and experimental contributions. From a theoretical perspective, we prove that backbones are hard even to approximate. From an algorithmic perspective, we present a number of different procedures for computing backdoors. From an empirical perspective. we study the correlation between being in the backbone and in a backdoor. Experiments show that there tends to be very little overlap between backbones and backdoors. We also study problem hardness for the Davis Putnam procedure. Problem hardness appears to be correlated with the size of strong backdoors, and weakly correlated with the size of the backbone, but does not appear to be correlated to the size of weak backdoors nor their number. Finally, to isolate the effect of backdoors, we look at problems with no backbone.},
  isbn = {978-1-57735-236-5}
}

@inproceedings{lagniezLeveragingDecisionDNNFCompilation2024,
  title = {Leveraging {{Decision-DNNF Compilation}} for {{Enumerating Disjoint Partial Models}}},
  booktitle = {21st {{International Conference}} on {{Principles}} of {{Knowledge Representation}} and {{Reasoning}}},
  author = {Lagniez, Jean-Marie and Lonca, Emmanuel},
  year = {2024},
  month = nov,
  urldate = {2024-07-24},
  abstract = {The All-Solution Satisfiability Problem (AllSAT) extends SAT by requiring the identification of all possible solutions for a propositional formula. In practice, enumerating all complete models is often infeasible, making the identification of partial models essential for generating a concise representation of the solution set. Deterministic Decomposable Negation Normal Form (d-DNNF) serves as a language for representation known to offer polynomial-time algorithms for model enumeration. Specifically, when a propositional formula is encoded in d-DNNF, it enables iterative model enumeration with polynomial delay between models. However, despite the existence of theoretical algorithms for this purpose, no available implementations are currently accessible. Furthermore, these theoretical approaches are nearly impractical as they solely yield complete models. We introduce a novel algorithm that maintains a polynomial delay between partial models while significantly enhancing efficiency compared to baseline approaches. Furthermore, through experimental validation, we demonstrate the superiority of compiling a CNF formula {$\Sigma$} into a d-DNNF formula {$\Sigma\prime$} and subsequently enumerating models of {$\Sigma\prime$} over existing state-of-the-art methodologies for CNF partial model enumeration.},
  langid = {english}
}

@inproceedings{lagniezRecursiveAlgorithmProjected2019,
  title = {A {{Recursive Algorithm}} for {{Projected Model Counting}}},
  booktitle = {Proceedings of the {{AAAI Conference}} on {{Artificial Intelligence}}},
  author = {Lagniez, Jean-Marie and Marquis, Pierre},
  year = {2019},
  month = jul,
  volume = {33},
  pages = {1536--1543},
  doi = {10.1609/aaai.v33i01.33011536},
  urldate = {2024-07-20},
  abstract = {We present a recursive algorithm for projected model counting, i.e., the problem consisting in determining the number of models k{$\exists$}X.{$\Sigma$}k of a propositional formula {$\Sigma$} after eliminating from it a given set X of variables. Based on a ''standard'' model counter, our algorithm projMC takes advantage of a disjunctive decomposition scheme of {$\exists$}X.{$\Sigma$} for computing k{$\exists$}X.{$\Sigma$}k. It also looks for disjoint components in its input for improving the computation. Our experiments show that in many cases projMC is significantly more efficient than the previous algorithms for projected model counting from the literature.},
  copyright = {Copyright (c) 2019 Association for the Advancement of Artificial Intelligence},
  langid = {english}
}

@inproceedings{lahiriSMTTechniquesFast2006,
  title = {{{SMT Techniques}} for {{Fast Predicate Abstraction}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Lahiri, Shuvendu K. and Nieuwenhuis, Robert and Oliveras, Albert},
  year = {2006},
  month = aug,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {424--437},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  doi = {10.1007/11817963_39},
  urldate = {2023-11-17},
  abstract = {Predicate abstraction is a technique for automatically extracting finite-state abstractions for systems with potentially infinite state space. The fundamental operation in predicate abstraction is to compute the best approximation of a Boolean formula {$\phi$} over a set of predicates P . In this work, we demonstrate the use for this operation of a decision procedure based on the DPLL(T) framework for SAT Modulo Theories (SMT). The new algorithm is based on a careful generation of the set of all satisfying assignments over a set of predicates. It consistently outperforms previous methods by a factor of at least 20, on a diverse set of hardware and software verification benchmarks. We report detailed analysis of the results and the impact of a number of variations of the techniques. We also propose and evaluate a scheme for incremental refinement of approximations for predicate abstraction in the above framework.},
  isbn = {978-3-540-37406-0},
  langid = {english}
}

@misc{masina_2024_cnf_code,
  title = {On {{CNF Conversion}} for {{SAT}} and {{SMT Enumeration}}: {{Source Code}}},
  author = {Masina, Gabriele},
  year = {2024},
  month = nov,
  doi = {10.5281/zenodo.14033421},
  howpublished = {Zenodo},
  url = {https://doi.org/10.5281/zenodo.14033421}
}

@misc{masina_2024_cnf_results,
  title = {On {{CNF Conversion}} for {{SAT}} and {{SMT Enumeration}}: {{Benchmarks}}, {{Results}} and {{Plots}}},
  author = {Masina, Gabriele},
  year = {2024},
  month = nov,
  howpublished = {Zenodo},
  url = {https://doi.org/10.5281/zenodo.14035594}
}

@inproceedings{mathsat5_tacas13,
  title = {The {{MathSAT5 SMT Solver}}},
  booktitle = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Cimatti, Alessandro and Griggio, Alberto and Schaafsma, Bastiaan Joost and Sebastiani, Roberto},
  editor = {Piterman, Nir and Smolka, Scott A.},
  year = {2013},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {93--107},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-36742-7_7},
  abstract = {MathSAT is a long-term project, which has been jointly carried on by FBK-IRST and University of Trento, with the aim of developing and maintaining a state-of-the-art SMT tool for formal verification (and other applications). MathSAT5 is the latest version of the tool. It supports most of the SMT-LIB theories and their combinations, and provides many functionalities (like e.g. unsat cores, interpolation, AllSMT). MathSAT5 improves its predecessor MathSAT4 in many ways, also providing novel features: first, a much improved incrementality support, which is vital in SMT applications; second, a full support for the theories of arrays and floating point; third, sound SAT-style Boolean formula preprocessing for SMT formulae; finally, a framework allowing users for plugging their custom tuned SAT solvers. MathSAT5 is freely available, and it is used in numerous internal projects, as well as by a number of industrial partners.},
  isbn = {978-3-642-36742-7},
  langid = {english},
  keywords = {Bound Model Check,Model Check,Predicate Abstraction,Theory Solver,Variable Elimination}
}

@article{pajunenSolutionEnumerationOptimality2021,
  title = {Solution {{Enumeration}} by {{Optimality}} in {{Answer Set Programming}}},
  author = {Pajunen, Jukka and Janhunen, Tomi},
  year = {2021},
  month = nov,
  journal = {Theory and Practice of Logic Programming},
  volume = {21},
  number = {6},
  pages = {750--767},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068421000375},
  urldate = {2024-08-22},
  abstract = {Given a combinatorial search problem, it may be highly useful to enumerate its (all) solutions besides just finding one solution, or showing that none exists. The same can be stated about optimal solutions if an objective function is provided. This work goes beyond the bare enumeration of optimal solutions and addresses the computational task of solution enumeration by optimality (SEO). This task is studied in the context of answer set programming (ASP) where (optimal) solutions of a problem are captured with the answer sets of a logic program encoding the problem. Existing answer set solvers already support the enumeration of all (optimal) answer sets. However, in this work, we generalize the enumeration of optimal answer sets beyond strictly optimal ones, giving rise to the idea of answer set enumeration in the order of optimality (ASEO). This approach is applicable up to the best k answer sets or in an unlimited setting, which amounts to a process of sorting answer sets based on the objective function. As the main contribution of this work, we present the first general algorithms for the aforementioned tasks of answer set enumeration. Moreover, we illustrate the potential use cases of ASEO. First, we study how efficiently access to the next-best solutions can be achieved in a number of optimization problems that have been formalized and solved in ASP. Second, we show that ASEO provides us with an effective sampling technique for Bayesian networks.},
  langid = {english}
}

@inproceedings{spallittaDisjointPartialEnumeration2024,
  title = {Disjoint {{Partial Enumeration}} without {{Blocking Clauses}}},
  booktitle = {Proceedings of the {{AAAI Conference}} on {{Artificial Intelligence}}},
  author = {Spallitta, Giuseppe and Sebastiani, Roberto and Biere, Armin},
  year = {2024},
  month = mar,
  volume = {38},
  pages = {8126--8135},
  doi = {10.1609/aaai.v38i8.28652},
  urldate = {2024-06-18},
  abstract = {A basic algorithm for enumerating disjoint propositional models (disjoint AllSAT) is based on adding blocking clauses incrementally, ruling out previously found models. On the one hand, blocking clauses have the potential to reduce the number of generated models exponentially, as they can handle partial models. On the other hand, the introduction of a large number of blocking clauses affects memory consumption and drastically slows down unit propagation.   We propose a new approach that allows for enumerating disjoint partial models with no need for blocking clauses by integrating: Conflict-Driven Clause-Learning (CDCL), Chronological Backtracking (CB), and methods for shrinking models (Implicant Shrinking). Experiments clearly show the benefits of our novel approach.},
  copyright = {Copyright (c) 2024 Association for the Advancement of Artificial Intelligence},
  langid = {english}
}

@misc{spallittaDisjointProjectedEnumeration2024,
  title = {Disjoint {{Projected Enumeration}} for {{SAT}} and {{SMT}} without {{Blocking Clauses}}},
  author = {Spallitta, Giuseppe and Sebastiani, Roberto and Biere, Armin},
  year = {2024},
  month = oct,
  number = {arXiv:2410.18707},
  eprint = {2410.18707},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2410.18707},
  urldate = {2024-10-28},
  abstract = {All-Solution Satisfiability (AllSAT) and its extension, All-Satisfiability Modulo Theories (AllSMT), have become more relevant in recent years, mainly in formal verification and artificial intelligence applications. The goal of these problems is the enumeration of all satisfying assignments to a formula (for SAT and SMT problems, respectively), making them useful for test generation, model checking, and probabilistic inference. Nevertheless, traditional AllSAT algorithms face significant computational challenges due to the exponential growth of the search space and inefficiencies caused by blocking clauses, which cause memory blowups and degrade unit propagation performances in the long term. This paper presents two novel solvers: {\textbackslash}solverPlus\{\}, a projected AllSAT solver, and {\textbackslash}solverSMT\{\}, a projected AllSMT solver. Both solvers combine Conflict-Driven Clause Learning (CDCL) with chronological backtracking to improve efficiency while ensuring disjoint enumeration. To retrieve compact partial assignments we propose a novel aggressive implicant shrinking algorithm to minimize the number of partial assignments, reducing overall search complexity, and compatible with chronological backtracking. Furthermore, we extend the solver framework to handle projected enumeration and SMT formulae effectively and efficiently, adapting the baseline framework to integrate theory reasoning and the distinction between important and non-important variables. An extensive experimental evaluation demonstrates the superiority of our approach compared to state-of-the-art solvers, particularly in scenarios requiring projection and SMT-based reasoning.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science}
}