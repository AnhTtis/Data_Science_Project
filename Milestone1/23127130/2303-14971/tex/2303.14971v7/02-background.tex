This section introduces the notation and the theoretical background necessary
to understand the content of this paper.
%\ignoreinshort{
We assume the reader is familiar with the basic syntax, semantics, and results
of propositional and first-order logics.\@ We briefly summarize the main
concepts and results of SAT and SMT, and the fundamental ideas behind SAT and
SMT enumeration and projected enumeration implemented by modern AllSAT and
AllSMT solvers.
%}
%\ignoreinlong{We recall the standard syntax, semantics, and results of propositional logic and Satisfiability Modulo Theories (SMT), and the fundamental ideas behind SAT enumeration and projected enumeration implemented by modern AllSAT solvers.}

\subsection{%\ignoreinlong{Propositional Logic}\ignoreinshort{
    SAT and SAT Modulo Theories}%}%
\label{sec:background:propositional-logic}
%In this section, we summarize some basic definitions and results of
%propositional logic \ignoreinshort{\GMCHANGE{ and SMT}}.

\paragraph*{Notation.}
%\ignoreinlong{ and Terminology}.
In the paper, we adopt the following conventions. We refer to Boolean atoms
with capital letters, such as $A$ and $B$,
%\ignoreinshort{
and to first-order atoms (including Boolean atoms), with Greek letters, e.g.,
$\alpha$.\@
% and to  atoms, both Boolean and first-order, with Greek letters such as $\alpha$. %}.
The symbols $\allA\defas\set{A_1, \dots, A_N }$ and $\allB\defas\set{B_1,
        \dots, B_M}$ denote disjoint sets of Boolean atoms,
%\ignoreinshort{, 
and $\allalpha{}\defas\set{\alpha_1,\dots,\alpha_k}$ denotes a set of
first-order (including Boolean) atoms. %generic 
%}
% \ignoreinshort{\GMCHANGE{The symbol $\allalpha\defas\set{\alpha_1,\dots,\alpha_M}$ denotes a set of generic (Boolean or \T{}-) atoms s.t.\ \allalpha{} and \allB{} are disjoint.}}
Propositional
%\ignoreinshort{
and first-order
%} 
formulas are referred to with Greek letters $\vi, \psi$.
%
We write $\vi(\allalpha)$ to denote that $\allalpha$ is the set of atoms
occurring in $\vi$.
%
We denote Boolean constants by $\B\defas\set{\top, \bot}$. Total truth
assignments are denoted by $\eta$, whereas partial truth assignments are
denoted by $\mu$, possibly annotated with superscripts. %\ignoreinshort{, %}.

\paragraph*{%\ignoreinshort{
    Propositional Satisfiability.}%}
A \emph{propositional} (also \emph{Boolean}) \emph{formula} $\vi$ can be defined recursively as follows. The Boolean constants $\top$ and $\bot$ are formulas; a Boolean atom $A$ and its negation $\neg A$ are formulas, also referred to as \emph{literals}; a connection of two formulas by one of the Boolean connectives $\wedge, \vee, \imp, \iff$ is a formula.
%\ignoreinshort{
A disjunction $(\vee)$ of literals is called a \emph{clause}. %A conjunction
%$(\wedge)$ of literals is called a \emph{cube}.
%\ignoreinshort{
\emph{Propositional satisfiability (SAT)} is the problem of deciding the satisfiability of a propositional formula, i.e., if there is a way to assign truth values to the atoms such that the formula evaluates to $\top$.
%
We refer to standard literature (e.g.,~\cite{biereHandbookSatisfiability2021})
for details.
%
%}
% \ignoreinshort{\GMCHANGE{Some formulas can also present quantifiers to express more complex conditions on Boolean parameters. In particular, the existential quantifier ($\exists B$), means that for at least one truth value of $B$ the formula should be satisfied.}}

% \begin{ignoreinshortenv}
\paragraph*{Satisfiability Modulo Theories.}
% \paragraph*{Satisfiability Modulo Theories}
%Let $\Sigma$ be a first-order signature containing function and predicate symbols. A $\Sigma$-term is either a variable or it is built by applying a function symbol in $\Sigma$ to $\Sigma$-terms. If $t_1, \dots , t_n$ are $\Sigma$-terms and $P$ is a predicate symbol, then $P(t_1, \dots , t_n)$ is a $\Sigma$-atom. Boolean atoms are defined as 0-ary predicate symbols. 
% Given a first-order signature $\Sigma$, i.e., a set of predicate, function and constant symbols, a term is either a variable $v$, a constant symbol, or a combination of terms using function symbols. A $\Sigma$-atom is a predicate symbol applied to a tuple of terms (Boolean atoms can be viewed as zero-arity predicates).
% A $\Sigma$-formula $\vi$ is built in the usual way out of the Boolean connectives, and $\Sigma$-atoms. A $\Sigma$-theory is a set of first-order sentences with signature $\Sigma$.
% Examples of theories are bit-vector arithmetic (\bv{}), floating-point arithmetic (\fl{}), linear arithmetic over integers (\laint{}) and real numbers (\larat{}), and arrays (\mem{}).\@ % and their combinations.
% With a little abuse of notation, we often refer to a theory \T{} instead of its corresponding signature, so that by \T-formulas \resp{literals, atoms} we mean formulas \resp{literals, atoms} in the signature of \T{}.
As it is standard in most \smt{} literature, we restrict to quantifier-free
first-order formulas. A first-order term is either a variable, a constant
symbol, or a combination of terms using function symbols. A first-order atom is
a predicate symbol applied to a tuple of terms (Boolean atoms can be viewed as
zero-arity predicates). A first-order formula is either a first-order atom, or
a connection of two formulas by one of the Boolean connectives. %
% is built in the usual way out of the existential and universal quantifiers, the
% Boolean connectives, and first-order atoms,
% i.e., predicate symbols applied to tuples of terms (Boolean atoms can be viewed as zero-arity predicates).
A first-order theory \T{} is a (possibly infinite) set of first-order formulas,
that provides an intended interpretation of constant, function, and predicate
symbols. Examples of theories of practical interest are those of equality and
uninterpreted functions (\euf{}), of linear arithmetic over integer (\laint{})
or real numbers (\larat{}), and combinations thereof. We refer to formulas and
atoms over symbols defined by \T{} as \T-formulas and \T-atoms, respectively.

\emph{Satisfiability Modulo the Theory $\T$, also $\smtt$,} is the problem of deciding the satisfiability of a first-order formula with respect to some background theory \T{}.
% With a little abuse of notation, we often refer to a theory \T{} instead of its corresponding signature, so that by \T-formulas \resp{literals, atoms} we mean formulas \resp{literals, atoms} in the signature of \T{}.
%~\cite{barrettSatisfiabilityModuloTheories2018} %, i.e.\ a set of closed first-order formulas. 
% In \smtt{} formulas, atoms are either Boolean atoms or \T{}-atoms.
A formula $\vi$ is \emph{\T{}-satisfiable}
%(also \emph{\T{}-consistent}) 
if $\vi\wedge\T{}$ is satisfiable in the first-order sense. Otherwise, it is
\emph{\T{}-unsatisfiable}. % (also \emph{\T{}-inconsistent}).
% The notation and terminology introduced for propositional logic can be straightforwardly extended for SMT formulas.
%
We refer to standard literature
(e.g.,~\cite{barrettSatisfiabilityModuloTheories2021}) for details.
% In this paper, we focus on quantifier-free SMT formulas.
% Since propositional logic can be seen as a strict subset of first-order logic, by considering

Hereafter, unless otherwise indicated, by \emph{formulas} we mean both Boolean
and \T-formulas, and by \emph{atoms} we mean both Boolean and \T-atoms, for a
generic theory \T{}.
%
We assume that formulas are internally represented as single-rooted directed acyclic
graphs (DAGs) %, i.e.\ arborescences, 
where internal nodes are labeled
with Boolean connectives, and leaves are labeled with literals or
atoms. (Some authors call them "circuits", e.g.~\cite{friedAllSATCombinationalCircuits2023,friedEntailingGeneralizationBoosts2024}.)
%% RS:  il concetto di "syntactically equivalent formulas" non mi
%% risulta esistere.
%In this way, syntactically equivalent formulas are represented by the same DAG.\@ 
In this way, multiple occurrences of the same sub-formula in one formula are
represented by only one shared sub-DAG. The \emph{size} of a formula is the
number of nodes and arcs of its DAG representation.

% \end{ignoreinshortenv}

% \begin{definition}
% \ignoreinlong{A sub-formula occurs with \emph{positive} \resp{\emph{negative}} \emph{polarity} (also \emph{positively} \resp{\emph{negatively}}) if it occurs under an even \resp{odd} number of nested negations. Specifically, $\vi$ occurs positively in $\vi$; if $\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or $\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and $\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if $\vi_1\iff\vi_2$ occurs in $\vi$,
%     then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% }
% \end{definition}
% \begin{definition}

% \begin{ignoreinshortenv}
\paragraph*{Total and partial truth assignments.}
%%%%%%%% SPOSTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%
% \begin{definition}
Given a set $\allalpha$ of atoms, a \emph{total truth assignment} is a total
map $\eta: \allalpha\longmapsto\B$. A \emph{partial truth assignment} is a
partial map $\mu: \allalpha\longmapsto\B$.
% \end{definition}
Notice that a partial truth assignment represents (aka ``covers'') $2^K$ total
truth assignments extending it, where $K$ is the number of unassigned atoms
%\ignoreinlong{variables}\ignoreinshort{
% atoms %} 
in $\mu$.
%With a little abuse of notation,
We often represent a truth assignment either as a set, s.t.\
$\mu\defas\set{\alpha\ |\ \mu(\alpha)=\top}\cup\set{\neg \alpha\ |\
        \mu(\alpha)=\bot}$, or as a conjunction of literals, s.t.\
$\mu\defas\bigwedge_{\mu(\alpha)=\top}{\alpha}\wedge\bigwedge_{\mu(\alpha)=\bot}{\neg
        \alpha}$. If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that
$\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of
$\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict
        super-assignment}} of $\mu_1$. We denote with $\residual{\vi}{\mu}$ the
\emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by
substituting in $\vi$ each $\alpha_i\in\allalpha$ with $\mu(\alpha_i)$, and by
recursively applying the standard propagation rules of truth values through
Boolean operators.

% \begin{definition}
Given a set $\allalpha$ of atoms and a formula $\vi(\allalpha)$, we say that a
\emph{[partial or total] truth assignment $\mu:\allalpha\longmapsto\B$
    propositionally satisfies} $\vi$, denoted as $\mu\pmodels\vi$, iff
$\residual{\vi}{\mu}=\top$.~\footnote{ The definition of satisfiability by
    partial assignment may present some ambiguities for non-CNF and
    existentially-quantified
    formulas~\cite{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020,sebastianiEntailmentVsVerification2025}.
    Here we adopt the above definition because it is the easiest to implement, the
    most efficient to compute, and it is the one typically used by state-of-the-art
    SAT solvers. {We refer to~\cite{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020,sebastianiEntailmentVsVerification2025} for
            details.} }
            
            %\ignoreinshort{%} %\ignoreinshort{%} 
% \end{definition}
% \footnote{
%}
A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff
$\mu\pmodels\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such
that $\mu{}'\not\pmodels\vi$.
%\ignoreinshort{
A Boolean formula is satisfiable iff there exists a truth assignment
propositionally satisfying it. A \T-formula is \T-satisfiable iff there exists
a \T-satisfiable truth assignment propositionally satisfying it. %}

Given two disjoint sets $\allalpha, \allB$ of atoms, and a%\ignoreinlong{ Boolean} 
%\ignoreinlong{CNF }
formula $\vicnf(\allalpha\cup\allB)$, we say that a \emph{[partial or total]
    truth assignment $\mualpha:\allalpha\longmapsto\B$ propositionally%\ignoreinshort{
    %} 
    satisfies} $\exists\allB.\vicnf$ iff there exists a total truth assignment
$\etaB:\allB\longmapsto\B$ such that $\mualpha\cup\etaB:
    \allalpha\cup\allB\longmapsto\B$ propositionally satisfies $\vicnf$. %\ignoreinshort{%} 

%\ignoreinshort{
Two formulas $\vi{}$ and $\psi{}$ are \emph{propositionally equivalent},
denoted as $\vi\pequiv\psi$, iff every total truth assignment propositionally
satisfying $\vi$ also propositionally satisfies $\psi$, and vice versa. %}

%%% SPOTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%

% \end{ignoreinshortenv}

\paragraph*{Negation Normal Form.}
%%%%%%%% SPOSTATO QUI NELLA VERSIONE LONG %%%%%%%%%%%%%
% \ignoreinshort{
Given a formula $\vi$, a sub-formula occurs with \emph{positive}
\resp{\emph{negative}} \emph{polarity} (also \emph{positively}
\resp{\emph{negatively}}) if it occurs under an even \resp{odd} number of
nested negations. Specifically, $\vi$ occurs positively in $\vi$; if
$\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs
negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or
$\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and
$\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs
positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively
\resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if
$\vi_1\iff\vi_2$ occurs in $\vi$, 
then $\vi_1$ and $\vi_2$ both occur positively and negatively. % in $\vi$.
% then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% }

%\begin{rschange}
A formula is in \emph{Negation Normal Form (NNF)} iff it is given only by the
recursive applications of $\wedge$ and $\vee$ to literals, i.e., iff all its
sub-formulas occur positively, except for literals. %\ignoreinlong{ Boolean} %\ignoreinshort{, 
%An NNF formula can be conveniently represented as a  Directed Acyclic Graph (DAG)
%---that is, as a single-root and/or DAG with literals as leaves.
%\ignoreinshort{
%We call the {\em size} of an NNF DAG the sum of the numbers of
%its nodes and arcs. %}
% \end{definition}
A formula can be converted into a propositionally-equivalent NNF formula by
recursively rewriting implications $(\vi_1\imp\vi_2)$ as $(\neg\vi_1\vee\vi_2)$
and equivalences $(\vi_1\iff\vi_2)$ as
$(\neg\vi_1\vee\vi_2)\wedge(\vi_1\vee\neg\vi_2)$, and then by recursively
``pushing down'' the negations: $\neg(\vi_1\vee\vi_2)$ as
$(\neg\vi_1\wedge\neg\vi_2)$, $\neg(\vi_1\wedge\vi_2)$ as
$(\neg\vi_1\vee\neg\vi_2)$ and $\neg\neg\vi_1$ as $\vi_1$. %\ignoreinshort{%}%\ignoreinshort{%}
% \ignoreinlong{
%     If the NNF formula is represented as a DAG,
%     %{---that is, as a single-root and/or DAG with literals as leaves---}
%     then its size is linear w.r.t.\ the original one.
%     (Although this fact is well-known,
%     % we could not to find a formal proof
%     %     of it in the literature; hence,
%     we provide a formal proof in the
%     extended version of this paper~\cite{masina_cnf_2023}.)
%     %
%     % \footnote{
%     % %    \begin{gmchange}
%     %     In fact, such NNF DAG is a sub-graph of the 2-root NNF DAG for the
%     %     pair $\langle\NNF{\vi},\NNF{\neg\vi}\rangle$, and it is
%     %     straightforward to prove that the latter grows linearly w.r.t.\
%     %     the size of $\vi$ by reasoning inductively on the structure of the
%     %     formula \vi: if $\vi\defas(\vi_1\bowtie\vi_2)$ s.t.\ $\bowtie~\in\set{\wedge,\vee,\imp,\limp,\iff}$, then
%     %     $|\langle \NNF{\vi},\NNF{\neg\vi}\rangle| \leq
%     %          18+|\langle \NNF{\vi_1},\NNF{\neg\vi_1}\rangle|+|\langle \NNF{\vi_2},\NNF{\neg\vi_2}\rangle|$, where ``|\dots|'' is \#nodes(\dots)+\#arcs(\dots).
%     %     \\E.g., if $\bowtie$ is ``$\iff$'', then the DAGs for $\NNF{\vi}$ and $\NNF{\neg\vi}$ share the
%     %     sub-DAGs for
%     %     $\NNF{\vi_1},\NNF{\neg\vi_1},\NNF{\vi_2},\NNF{\neg\vi_2}$, adding
%     %     3+3 ``$\wedge$''/``$\vee$'' nodes and $6+6$ arcs:\\
%     %     % \begin{itemize}
%     %         % \item 
%     %         $
%     %         \begin{aligned}
%     %             \quad\NNF{\pos\phantom{(}\vi_1\iff\vi_2\phantom{)}}\defas(\NNF{\neg\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\pos\vi_1}\vee \NNF{\neg\vi_2});\\
%     %             \quad\NNF{\neg(\vi_1\iff\vi_2)}\defas(\NNF{\pos\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\neg\vi_1}\vee\NNF{\neg\vi_2}).            
%     %         \end{aligned}
%     %         $\\
%     %         % \item 
%     %     % \end{itemize}
%     %     Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of $\vi$,
%     %     representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and negative
%     %     occurrences of $\vi_i$ respectively. These nodes are shared among up
%     %     to exponentially-many branches generated by expanding the nested iffs.
%     % %    \end{gmchange}
%     % }
% }
% \ignoreinshort{%
%\newpage
The following fact holds.
%\begin{gmchange}
\begin{lemma}%
    \label{th:nnfdaglinear}
    Let \vi{} be a %\ignoreinlong{ Boolean} 
    formula and \NNF{\vi} be the NNF
    formula resulting from converting \vi{} into NNF as described
    above. Then the size of \NNF{\vi} is linear w.r.t.\ the size of \vi.
    % If $\NNF{\vi}$ is represented as a DAG,  then its size is linear w.r.t.\ the original one.
\end{lemma}
\noindent(Although we believe this fact is well-known,
% we failed to find a formal proof
% in the literature. Hence,
we provide a formal proof in~\sref{sec:proofnnfdaglinear}.)
%\end{gmchange}
% }
Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of
$\vi$, representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and
negative occurrences of $\vi_i$ respectively. These nodes are shared among up
to exponentially-many branches generated by expanding the nested iffs.~%
%\footnote{%
Notice that \Cref{th:nnfdaglinear} holds {\em because a DAG representation of
        NNF is used}, so that we need at most two nodes for each sub-formula, one for
each polarity. (If instead one represented the NNF formula as a tree, then the
NNF representation would blow up exponentially in the number of nested $\iff$'s
in the original formula, because each sub-formula $(\vi_i \iff \vi_j)$ is
recursively expanded into $(\neg\vi_i \vee \vi_j)\wedge (\vi_i \vee
    \neg\vi_j)$.)
%}
%\end{rschange}

% \ignoreinshort{
We have the following fact, for which we provide a complete proof
in~\sref{sec:proofmunnf}.
\begin{lemma}%
    \label{th:munnf}
    Consider a formula $\vi$, %, and let $\NNF{\vi}$ be its NNF. % DAG.\@
    and a partial truth assignment $\mu$. % on $\GMCHANGEp{\allalpha $. 
    Then $\residual{\vi}{\mu}=v$ iff $\residual{\NNF{\vi}}{\mu}=v$, for
    $v\in\set{\top,\bot}$.
    % , where $\any$ represents the case in which the residual is neither $\top$ nor $\bot$.
\end{lemma}
Notice that \Cref{th:munnf} \emph{is not} a direct consequence of the fact that \NNF{\vi} is equivalence-preserving, because the above notion of satisfiability by partial assignment is such that if $\vi_1\pequiv\vi_2$, then $\mu\pmodels\vi_1$ \emph{does not} imply that $\mu\pmodels\vi_2$~\cite{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020,sebastianiEntailmentVsVerification2025}. Consider, e.g., $\vi_1\defas(A\vee{}B)\wedge(A\vee\neg{}B)$ and $\vi_2\defas(A\wedge{}B)\vee(A\wedge{\neg{}B})$, and the partial assignment $\mu\defas\set{A}$.
Although $\vi_1\pequiv\vi_2$, we have that $\residual{\vi_1}{\mu}=\top$, but $\residual{\vi_2}{\mu}=B\vee\neg B$, which, although \emph{logically} equivalent to $\top{}$, is \emph{syntactically} different from it.
% }

\paragraph*{CNF Transformations.}%
\label{sec:bg:cnf}
A %\ignoreinlong{ Boolean} 
formula is in \emph{Conjunctive Normal Form (CNF)} iff it is a conjunction %\ignoreinlong{ $(\wedge)$} 
of clauses. %\ignoreinlong{, where a clause is a disjunction $(\vee)$ of literals}.
% \end{definition}
Numerous CNF transformation procedures, commonly referred to as CNF-izations,
have been proposed in the literature.
%\ignoreinlong{In the next paragraph, we}\ignoreinshort{
We summarize the three most frequently employed techniques. %} 

The \emph{Classic CNF-ization} (\DeMorganCNF{}) converts a formula into a
propositionally-equivalent formula in CNF by applying DeMorgan's rules. First,
it converts the formula into NNF.\@ Second, it recursively rewrites
sub-formulas $\vi_1\vee(\vi_2\wedge\vi_3)$ as
$(\vi_1\vee\vi_2)\wedge(\vi_1\vee\vi_3)$ to distribute $\vee$ over $\wedge$,
until the formula is in CNF.\@ The principal limitation of this transformation
lies in the possible exponential growth of the resulting formula compared to
the original (e.g., when the formula is a disjunction of conjunctions of
sub-formulas), making it unsuitable for modern SAT and SMT solvers~(see e.g.,
\cite{prestwichCNFEncodings2021}). %\ignoreinlong{in DNF}\ignoreinshort{%}), %\ignoreinshort{ %} 

The \emph{Tseitin CNF-ization}
(\TseitinCNF{})~\cite{tseitinComplexityDerivationPropositional1983} avoids this
exponential blow-up by labeling each sub-formula $\vi_i$ with a fresh Boolean
atom $B_i$, which is used as a placeholder for the sub-formula. Specifically,
it consists in applying recursively bottom-up the rewriting rule
$\vi\Longrightarrow\vi[\vi_i|B_i] \wedge \DeMorganCNF(B_i\iff\vi_i)$ until the
resulting formula is in CNF, where $\vi[\vi_i|B_i]$ is the formula obtained by
substituting in $\vi$ every occurrence of $\vi_i$ with $B_i$.

The \emph{Plaisted and Greenbaum CNF-ization}
(\PlaistedCNF{})~\cite{plaistedStructurepreservingClauseForm1986} is a variant
of the \TseitinCNF{} that exploits the polarity of sub-formulas to reduce the
number of clauses of the final formula. If a sub-formula $\vi_i$
appears only with positive \resp{negative} polarity, then it can be labeled
with a one-way implication as $\DeMorganCNF(B_i\imp\vi_i)$
\resp{$\DeMorganCNF(B_i\limp\vi_i)$}; if $\vi_i$ occurs with both polarities,
then it is labeled as $\DeMorganCNF(B_i\iff\vi_i)$, as
with \TseitinCNF{}.

With both \TseitinCNF{} and \PlaistedCNF{}, due to the introduction of the
label variables, the final formula does not preserve the propositional
equivalence with the original formula but only the equisatisfiability.
Moreover, they also have a stronger property. If $\vi(\allalpha)$ is a non-CNF
formula and $\vicnf(\allalpha\cup\allB)$ is either the \TseitinCNF{} or the
\PlaistedCNF{} encoding of $\vi$, where $\allB$ are the fresh Boolean atoms
introduced by the transformation, then
$\vi(\allalpha)\pequiv\exists\allB.\vicnf(\allalpha\cup\allB)$. %\ignoreinshort{%}

% \begin{ignoreinlongenv}
%     \paragraph*{Total and partial truth assignments.}
%     % \begin{definition}
%     Given a set of Boolean atoms $\allA$, a \emph{total truth assignment} is a total map $\eta: \allA\longmapsto\B$.
%     A \emph{partial truth assignment} is a partial map $\mu: \allA\longmapsto\B$.
%     % \end{definition}
%     Notice that a partial truth assignment represents $2^K$ total truth assignments, where $K$ is the number of unassigned variables by $\mu$.
%     With a little abuse of notation, we sometimes represent a truth assignment either as a set, s.t.\ $\mu\defas\set{A\ |\ \mu(A)=\top}\cup\set{\neg A\ |\ \mu(A)=\bot}$, or as a cube, s.t.\ $\mu\defas\bigwedge_{\mu(A)=\top}{A}\wedge\bigwedge_{\mu(A)=\bot}{\neg A}$.
%     If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that $\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of $\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict super-assignment}} of $\mu_1$.
%     We denote with $\residual{\vi}{\mu}$ the \emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by substituting in $\vi$ each $A_i\in\allA$ with $\mu(A_i)$, and by recursively applying the standard propagation rules of truth values through Boolean operators.

%     % \begin{definition}
%     Given a set of Boolean atoms $\allA$ and a formula $\vi(\allA)$, we say that a \emph{[partial or total] truth assignment $\mu:\allA\longmapsto\B$ satisfies} $\vi$, denoted as $\mu\pmodels\vi$, iff $\residual{\vi}{\mu}=\top$.\footnote{
%         The definition of satisfiability by partial assignment may present some ambiguities for non-CNF and existentially-quantified formulas~\cite{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020}. Here we adopt the above definition because it is the easiest to implement,\ignoreinshort{\GMCHANGE{\ the most efficient to compute,}} and it is the one typically used by state-of-the-art SAT solvers. {We refer to the works by~\citeA{sebastianiAreYouSatisfied2020,mohleFourFlavorsEntailment2020} for details.}
%     } If $\mu\pmodels\vi$, then we say that $\mu$ is a \emph{model} of $\vi$.
%     % \end{definition}
%     % \footnote{
%     %}
%     A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff $\mu\pmodels\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such that $\mu{}'\not\pmodels\vi$.
% \end{ignoreinlongenv}

Most of the modern SAT and SMT solvers do not deal directly with non-CNF
formulas, rather they convert them into CNF by using either \TseitinCNF{} or
\PlaistedCNF{},
% \ignoreinlong{. As seen in the previous paragraph, since these transformations introduce fresh atoms into the resulting formulas, a model of $\vi(\allalpha)$ can be found as a truth assignment satisfying $\exists\allB.\vicnf(\allalpha\cup\allB)$.}%
%\ignoreinshort{, 
and then find truth assignments propositionally satisfying $\vi(\allalpha)$ by
finding truth assignments propositionally satisfying
$\exists\allB.\vicnf(\allalpha\cup\allB)$. %}
% \begin{definition}
% \end{definition}

% \RSNOTE{@Gabriele: nota che qui ho tolto la parte relativa a ``\any'',
%   perche' non l'abbiamo definita chiaramente, e perche' e' inutile, in
% quanto deriva dal fatto che la proprietà e' in ``iff''.}
% GM: Ok

% The work of this paper focuses on the following result from~\cite{sebastianiAreYouSatisfied2020}.
% \begin{lemma}%
%     \label{lemma:noncnf-sat}
%     Let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA\cup\allB)$ be the result of applying either the \TseitinCNF{} or the \PlaistedCNF{} transformation to $\vi$.\\
%     Given a total truth assignment $\etaA:\allA\longmapsto\B$, then  $\etaA\pmodels\vi$ iff $\etaA\pmodels\exists\allB.\vicnf$. However, given a partial truth assignment $\muA:\allA\longmapsto\B$, then  $\muA\pmodels\vi$ if $\muA\pmodels\exists\allB.\vicnf$, but the reverse implication does not hold. 
% \end{lemma}
% \GMNOTE{Dobbiamo dimostrarlo per Plaisted?}

\subsection{AllSAT,
    AllSMT,
    Projected AllSAT
    and Projected AllSMT}%}%
\label{sec:background:allsat}

% \RSTODO{riscrivi \S2.2. di
%   conseguenza, spiegando che l'algoritmo e' solo un esempio e che la
%   disjointness e la minimalità non sono strettamente necessari.}

AllSAT is the task of enumerating all the truth assignments propositionally
satisfying a Boolean formula.\@ %\ignoreinshort{%}%\ignoreinlong{In this paper, we focus on the enumeration of disjoint models, that is, pairwise mutually-inconsistent models.}
% \begin{ignoreinshortenv}
The task can be found in the literature in two versions: \emph{disjoint}
AllSAT, where the assignments are required to be pairwise mutually
inconsistent, and \emph{non-disjoint} AllSAT, where they are not. A
generalization to the \smtt{} case is All\smtt{}, defined as the task of
enumerating all the \T{}{\em -satisfiable} truth assignments propositionally
satisfying a \smtt{} formula. Also in this case, both disjoint or non-disjoint
All\smtt{} are possible. %~\cite{yuAllSATUsingMinimal2014}. %\footnote{In the SMT literature the word ``AllSMT'' is used with slightly distinct meanings~\cite{lahiriSMTTechniquesFast2006,mathsat5_tacas13,phanAllSolutionSatisfiabilityModulo2015f}}. 

In the following, for the sake of compactness, we present definitions and
algorithms referring to AllSAT. An extension to All\smtt{} can be obtained
straightforwardly, by substituting ``\allA'' with ``\allalpha'' and ``truth
assignments'' with ``\T{}-satisfiable truth assignments''.
%restricting to \T{}-satisfiable truth assignments.
% \end{ignoreinshortenv}

% \begin{definition}
Given a formula $\vi$, we denote with
$\TTA{\vi}\defas\set{\eta_1,\dots,\eta_j\dots,\eta_M}$ the set of all total
truth assignments propositionally satisfying $\vi$. %\ignoreinlong{ Boolean} %\ignoreinshort{%}
% \end{definition}
% \begin{definition}
We denote with $\TA{\vi}\defas\set{\mu_1,\dots,\mu_i\dots,\mu_N}$ a set of
partial truth assignments propositionally satisfying $\vi$ s.t.:%\ignoreinshort{%}
% \ignoreinlong{
%     \begin{enumerate}[(a)]
%         \item every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
%         \item every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
%     \end{enumerate}
% }
% \ignoreinshort{
\begin{enumerate}[(a)]
    \item\label{item:ta:complete} every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
\end{enumerate}
and, only in the \emph{disjoint} case:
\begin{enumerate}[(b)]
    \item\label{item:ta:disjoint} every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
\end{enumerate}
% }

% \end{definition}
Notice that, whereas $\TTA{\vi}$ is unique, multiple $\TA{\vi}$s are admissible
for the same formula $\vi$, including $\TTA{\vi}$. AllSAT is the task of
enumerating either $\TTA{\vi}$ or a set $\TA{\vi}$. Typically, AllSAT solvers
aim at enumerating a set $\TA{\vi}$ which is as small as possible, since every
partial truth assignment prevents from enumerating a number of total truth
assignments that is exponential w.r.t.\ the number of unassigned atoms, so that
to save large amounts of computational space and time. %\ignoreinshort{%}%\ignoreinlong{model}\ignoreinshort{%} %\ignoreinlong{models}\ignoreinshort{%} 

%\mathsat{}~\cite{mathsat5_tacas13}, the SAT/SMT solver that we used for our experiments.\GMSIDENOTE{Riscrivere non riferendosi solo a mathsat}
The enumeration of a $\TA{\vi}$ for a non-CNF formula $\vi$ is typically
implemented by first converting it into CNF, and then by enumerating its
satisfying assignments by means of \emph{Projected AllSAT}. %\ignoreinlong{models}\ignoreinshort{%} 
%\ignoreinshort{\GMCHANGE{/AllSMT}}}.
Specifically, let $\vi(\allA)$ be a non-CNF formula and let
$\vicnf(\allA\cup\allB)$ be the result of applying either \TseitinCNF{} or
\PlaistedCNF{} to $\vi$, where $\allB$ is the set of Boolean atoms introduced
by either transformation. $\TA{\vi}$ is enumerated via Projected AllSAT as
$\TA{\exists\allB.\vicnf}$, i.e.\ as a set of (partial) truth assignments over
$\allA$ that can be extended to total truth assignments satisfying $\vicnf$
over $\allA\cup\allB$. We refer the reader to the general schema described
in~\cite{lahiriSMTTechniquesFast2006}, which we briefly recap here for
completeness of narration. %\ignoreinshort{\GMCHANGE{/AllSMT}} %\ignoreinlong{models of}\ignoreinshort{%} %, as a consequence of \cref{lemma:noncnf-sat}. 

Let $\vicnf(\allA\cup\allB)$ be a CNF formula over two disjoint sets
%of %\ignoreinlong{Boolean variables}\ignoreinshort{
%atoms %} 
$\allA, \allB$ of atoms, where $\allA$ is a set of
\emph{relevant atoms} s.t.\ we want to enumerate a
$\TA{\exists\allB.\vicnf}$.
%\begin{rschange}
%\ignoreinshort{
For disjoint AllSAT with minimal models, the solver enumerates one-by-one
partial truth assignments $\mu_1,\dots,\mu_i,\dots\mu_N$ which comply with
point~\ref{item:ta:complete} above where each $\mu_i\defas\muA_i\cup\etaB_i$ is
s.t.:%}\ignoreinlong{The} 
\begin{enumerate}
    \item\label{item:mumodelsvi} (\emph{satisfiability}) $\mu_i\pmodels\vicnf$;
    \item\label{item:musdisjoint} (\emph{disjointness}) for each
          $j<i$, $\muA_i,\muA_j$ assign opposite truth values to some atom in $\allA$;
    \item\label{item:muAminimal} (\emph{minimality}) $\muA_i$ is \emph{minimal}, meaning that no literal can be dropped from it without losing properties~\ref{item:mumodelsvi} and~\ref{item:musdisjoint}.
          % \GMSIDENOTE{la property~\ref{item:muAminimal} può essere ``rilassata''? E.g., se uso chronological backtracking dovrei riuscire a produrre assignment parziali più corti anche se non sono necessariamente ``minimali'' nel senso in cui è inteso qui. Magari solo una footnote.
          % }
\end{enumerate}
%\ignoreinshort{
For the non-disjoint case, property~\ref{item:musdisjoint} is omitted, and the
reference to it in~\ref{item:muAminimal} is dropped. If the minimality of
models is not required, property~\ref{item:muAminimal} is omitted. %}\RSSIDENOTE{Da rivedere}

An example of a basic projected AllSAT procedure producing minimal models
(implemented e.g.\ in \mathsatfive{}~\cite{mathsat5_tacas13}) works as
follows. At each step $i$, it finds a total truth assignment
$\eta_i\defas\etaA_i\cup\etaB_i$ s.t.\ $\eta_i\pmodels\psi_i$, where
$\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$, and then invokes a
minimization procedure on $\etaA_i$ to compute a partial truth assignment
$\muA_i$ satisfying properties~\ref{item:mumodelsvi},~\ref{item:musdisjoint}
and~\ref{item:muAminimal}. Then, the solver adds the blocking clause
$\neg\muA_i$ ---to ensure property~\ref{item:musdisjoint} for the disjoint
version and to ensure an exhaustive exploration of the solutions space for the
non-disjoint version--- and it continues the search. This process is iterated
until {$\psi_{N+1}$ }is found to be unsatisfiable for some $N$, and the set
$\set{\muA_i}_{i=1}^N$ is returned. %\ignoreinshort{---}%\ignoreinshort{ %} %the formula 
%
The minimization procedure consists in iteratively dropping literals one-by-one
from $\etaA_i$, checking if it still satisfies the formula. The outline of this
minimization procedure is shown in \cref{alg:minimize}. Each minimization step
is $O(\#\mathit{clauses}\cdot\#\mathit{vars})$.

\begin{algorithm}[t]
    \begin{algorithmic}[1]
        %\begin{rschange}
        \caption[A]{{\sc Minimize-Assignment}($\psi_i, \eta_i, \allA$)\\
            \hspace*{\algorithmicindent}\textbf{Input}:
                CNF formula $\psi_i$, total truth assignment $\eta_i$ s.t.\ $\eta_i\pmodels\psi_i$, set of relevant atoms $\allA$:\\
                % \ignoreinlong{$\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$,}%
                % say that if disjoint then ... otherwise only \psi
                % \ignoreinshort{
                \hspace*{\algorithmicindent}\null\quad $\psi_i(\allA\cup\allB)\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$ if disjoint, $\psi_i\defas\psi$ if non-disjoint \\%
                % }%
                \hspace*{\algorithmicindent}\null\quad $\eta_i = \etaA_i \cup \etaB_i$\\
            \hspace*{\algorithmicindent}\textbf{Output}: minimal partial truth assignment $\muA_i$ s.t.\ $\muA_i\cup\etaB_i\pmodels\psi_i$%
            \label{alg:minimize}}
        \STATE $\muA_i \leftarrow \etaA_i$
        \FOR{$\ell\in\muA_i$}
        \IF{$\residual{\psi_i}{\muA_i\setminus\set{\ell}\ \cup\ \etaB_i} = \top$}
        \STATE $\muA_i \leftarrow \muA_i \setminus \set{\ell}$
        \ENDIF
        \ENDFOR
        \RETURN $\muA_i$
        %\end{rschange}
    \end{algorithmic}
\end{algorithm}

Notice that, since we are in the context of {\em projected} AllSAT, the
minimization algorithm only minimizes the relevant atoms in $\allA$, %\ignoreinshort{%}\ignoreinlong{variables} 
%although 
and the truth value of existentially quantified variables in $\allB$ is still
used to check the satisfiability of the formula by the current partial
assignment.\@ Moreover, in the disjoint case, to enforce the pairwise
disjointness between the assignments, $\psi_i$ in \cref{alg:minimize} refers to
the original formula conjoined with all current blocking clauses
$\bigwedge_{j=1}^{i-1}\neg\muA_j$, whereas in the non-disjoint case $\psi_i$
refers to the original formula only, allowing for a more effective minimization
while renouncing the disjointness property. %\ignoreinshort{%} %\ignoreinshort{%}. 
%\GMSIDENOTE{Ho tolto la frase "Conflict clauses are excluded by the minimization, being redundant." perché il reviewer E ha chiesto chiarimenti, e nonmi sembra necessaria per il background}
% Conflict clauses are excluded by the minimization, being redundant.
% \ignoreinshort{

The procedure reduces to non-projected AllSAT if $\allB=\emptyset$. The same
procedure can be easily generalized to disjoint and non-disjoint All\smtt{},
with the only difference that only \T-satisfiable total truth assignments
$\eta_i$ are considered. % and the minimization procedure is applied to the Boolean abstractions of $\psi_i$ and $\eta_i$.
% }

We stress the fact that the above procedure is reported just as an example, and
that the work described in this paper is agnostic w.r.t.\ the AllSAT or AllSMT
procedure used, provided that it is able to produce \emph{partial} assignments. %\ignoreinlong{disjoint }%\ignoreinshort{%}
%enumeration strategy matches the above conditions. %}

% \GMNOTE{Mention different enumeration approaches, e.g., blocking/non-blocking~\cite{todaImplementingEfficientAll2016}, different minimization techniques (see~\cite{todaImplementingEfficientAll2016,morgadoGoodLearningImplicit2005,raviMinimalAssignmentsBounded2004}). Mention methods not matching these conditions, e.g., BDD-based, Dualiza}

%\end{rschange}

