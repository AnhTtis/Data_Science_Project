\documentclass[paper=a4,fontsize=11pt]{scrartcl}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[american]{babel}
% \usepackage{underscore}

%% Some suggested packages, as needed:
\usepackage[numbers]{natbib} % has a nice set of citation styles and commands
% \setcitestyle{authoryear, round, comma} %Citation-related commands
\bibliographystyle{abbrvnat}
\usepackage{mathtools} % amsmath with fixes and additions
% \usepackage{siunitx} % for proper typesetting of numbers and units
\usepackage{booktabs} % commands to create good-looking tables
\usepackage{tikz} % nice language for creating drawings and diagrams
\usepackage[draft]{todonotes}
%\usepackage[FIGBOTCAP,TABBOTCAP,center,nooneline]{subfigure}
\usepackage[dvips]{rotating}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsthm}
%\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{booktabs}
\usepackage{color}
\usepackage{comment}
\usepackage{datetime}
\usepackage{epsfig}
\usepackage{graphicx}
%\usepackage{ifthen}
\usepackage{xifthen}
%\usepackage{etoolbox}
\usepackage{latexsym}
\usepackage{marginnote}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{placeins}
\usepackage{rotate} 
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage[draft]{todonotes}
\usepackage{url}
\usepackage{varwidth}
\usepackage{verbatim} 
\usepackage{wrapfig}
\usepackage{xcolor,colortbl}
\usepackage{xspace}
\usepackage{environ}
\usepackage{hyperref}
\usepackage[capitalise, noabbrev]{cleveref}

\usepackage{float} 
\input{rs_macros_general}
\newcommand{\omissis}{[\kern\fontdimen3\font\dots]}
\let\oldquote\quote%
\renewcommand\quote{\color{blue}\em\oldquote}%
%\renewcommand\quote{\color{blue}\em\oldquote}%





%\def\DONE#1{\textcolor{Green}{DONE: #1}}
\def\DONE#1{#1} %uncomment to finalize
\def\TODO#1{\textcolor{Red}{TODO: #1}}
\def\DISCUSS#1{\textcolor{Orange}{DISCUSS: #1}}


\begin{document}
\begin{center}
  {\LARGE {On CNF Conversion for SAT and SMT Enumeration}}\\
  ~\\
  by Gabriele Masina, Giuseppe Spallitta, Roberto Sebastiani
  \\
  ~\\~\\
  {\textbf {\Large Address to the Editor's and Reviewers' Comments}}
\end{center}

\section*{Editor's comments}
\begin{quote}
  The reviewers agree that the paper definitely has promise and is quite interesting. However, they also identify several difficulties, which preclude publication at this stage. You will find the reviewers' comments and suggestions attached. Since JAIR's policy is to accept papers that only require minor revisions, we cannot currently accept the paper. However, we would be happy to see a revised paper on this subject --addressing the reviewers' concerns-- published in JAIR. Thus, I strongly encourage you to resubmit the paper.

  The reviewers have identified several concerns that focus both on writing, comparison with relevant literature as well as additional empirical evaluation needed. Fixing these will enhance chances of acceptance.
\end{quote}


%\TODO{intro for associate editor, including management of major aspects}

\newcommand{\myparagraph}[1]{\medskip\noindent{\textbf{#1.\\}}}
%\newpage
We thank the editor and all reviewers for their valuable comments and suggestions.
%
We have very significantly revised the paper to address the reviewers'
criticisms and resubmitted it. We believe that now the paper has significantly improved in compliance with the reviewers' requests, and we
are confident it will satisfy their criticisms. (For the reviewers'
convenience, we have highlighted the main modifications in \textcolor{blue}{blue} in the
resubmitted version.)

In what follows, we first present some general remarks, addressing
issues that were raised by more than one reviewer and describing our
contributions and the modifications we have performed. Then we 
address each review singularly and pointwise. 

\newpage
\section*{General Remarks}

%\cref{remark:theory}
Here we present some  general remarks, addressing
issues which were raised by more than one reviewer and describing our
contributions and the modifications we have performed.
We will 
address each review singularly and pointwise in the next sections. 

\begin{generalremark}\label{remark:theory}(\textbf{About theoretical contributions.})
%\myparagraph{\cref{remark:theory}. About theoretical contributions}

  \noindent
We wish to stress the fact that the paper has novel and important theoretical
contributions, which we summarize as follows:

\begin{enumerate}
\item In \S3.1 we analyze theoretically the effects of Tseitin CNF
  encoding (\TseitinCNF{}(\vi)) in enumeration, and we identify a
  fundamental weakness:
  
  {\em although $\vi$ and $\exists \allB.\vicnfts$ are equivalent by
    construction, 
    if a \underline{partial} assignment \muA{} suffices to satisfy
    $\vi$, this {does not imply} that \muA{} suffices to satisfy
    $\exists \allB.\vicnfts$}.

  (To emphasize this fact, we have now called it ``Fact 1'' in \S3.1.) 
  Consequently, given $\muA$ satisfying \vi{}, in order to
  produce an assignment \muAprime{} satisfying $\exists 
  \allB.\vicnfts$  the enumerator is most often forced to %(unnecessarily)
  assign
  other 
  atoms in \allA{}, so that $\muAprime\supset\muA$.
  Given the fact that the amount of total assignments covered by a partial
  assignment decreases exponentially with its length (see \S2.2), the above weakness 
  causes a blow-up in
  the number of partial assignments that we need to generate to cover all
  models.
  % , which is up to
  % exponential in the number of unassigned atoms. 
  %$||\muAprime\setminus\muA||$.
  This is illustrated in Example 1 of
  \S3.1, where instead of one short partial assignment the enumerator
  is forced to enumerate no less than 9 longer ones, {\em regardless of the
  enumeration strategy adopted}. 

\item In \S3.2 we notice that, with Plaisted and Greenbaum CNF
  encoding (\PlaistedCNF{}), the above weakness is mitigated ---due to %the presence of
  single-polarity subformulas in $\vi$--- but it is not fixed
  ---due to double-polarity subformulas in $\vi$.
  This is illustrated in Example 2 of \S3.2 on the same problem of 
  Example 1, where instead of one short partial assignment the enumerator
  is forced to enumerate no less than 3 longer ones, regardless of the
  enumeration strategy adopted. 

  \item In \S4 we suggest \NNFPlaisted{} as a much better CNF encoding for enumeration and prove Theorem 1, which  says that, unlike with
    \TseitinCNF{} and \PlaistedCNF{}:

    {\em if a
        partial assignment $\muA$ suffices to satisfy $\vi$, then it
        suffices also to satisfy $\exists
        \allB. \PlaistedCNF(\NNF{\vi})$}.
      
Intuitively, this is due to the fact that in \NNF{\vi} all
      subformulas occur with positive polarity only.
      Thus, the enumerator does not
      need to 
      assign further unassigned atoms in \allA.
      This completely solves the above problem. \\
  The effect of Theorem~1 w.r.t.\ Fact~1 is illustrated in Example~3
  in \S4 on the same problem as in Examples~1 and~2, showing that the enumerator is no more 
  forced to enumerate extra assignments.
    \end{enumerate}

%Assume that the enumerator is able to enumerate short partial assignments
%satisfying \muA{} the formula.
    \noindent
    Notice that, the shorter is $\muA$ w.r.t.\ a total assignment, the
higher is the chance that \TseitinCNF{} and \PlaistedCNF{} force the
production of a high number of extra assignments, and the more beneficial is the usage of \NNFPlaisted{} which avoids it.
Thus, if the enumerator produces  {\em partial}
assignments \muA{}
satisfying the formula, we expect a high benefit from using
\NNFPlaisted{} 
instead of 
\TseitinCNF{} and \PlaistedCNF{}; vice versa, if the enumerator
produces only total or nearly-total assignments, we expect no, or very
limited, benefit. 

\medskip
\noindent\textbf{Actions performed.}
We realize that the above contributions may not have been clear from the
narration in the previously submitted paper.
Therefore,  we have rewritten \S3 and \S4 following a very-different narration
schema: in each (sub)section \S3.1, \S3.2 and \S4, we first introduce
the general theoretical facts, and then we describe  
their general consequences on assignment enumeration, after which we illustrate
them by means of the running example.
Also, the examples have been simplified and made
independent of the enumeration procedure.
Some technical details have been moved into Footnote~2, so that a
non-interested reader can skip them without interrupting the reading flow. 
We believe these sections are readable and comprehensible now.

Also, to address the request of one reviewer, we have moved the
proof of Theorem 1 from the appendix into the main text in \S4. Given
the fact that such proof is constructive ---that is, given \muA,  it tells explicitly
how to assign the values of the \allB's for satisfying 
$\exists \allB. \vinnfcnfpg$--- we believe this proof may help make the theoretical contribution more evident and help understand better the insight behind our technique.
To this extent, we have also added a few paragraphs showing how the main steps in the proof suggest a simple strategy to assign the \allB's given \muA. 
(The reader can skip this part if not interested in these details.)
\end{generalremark}

% \RSTODO{Rimarca come la cosa riguarda partial assignments non
%   necessariamente minimali. La minimalità esaspera il fatto.}

% \RSTODO{riscrivi \S3 e \S4 di
%   conseguenza, spiegando prima l'intuiizione e poi l'esempio.}


\begin{generalremark}\label{remark:enumalgo}(\textbf{About the enumeration algorithm adopted.})

\noindent We wish to clarify that, as a consequence of the above
theoretical properties (Theorem~1 w.r.t.\ Fact~1), the benefit
of our technique is not restricted to the enumeration algorithm of
\S2.2  --which was intended to illustrate one simple way to
implement (projected) AllSAT. Rather, it is supposed to work in
general {\em for all enumeration
procedures based on partial-assignment generation}. In
particular:
\begin{aenumerate}
\item it is not restricted to enumeration procedures based on the blocking-clause
  schema,  like the ones in~\cite{lahiriSMTTechniquesFast2006}
  or~\cite{mathsat5_tacas13}
  %\RSSIDENOTE{c'e' un problema con questa bibref. fix}
\item it is not restricted to procedures generating {\em minimal} partial assignments.
\end{aenumerate}


\noindent\textbf{Actions performed.}
We realize that the narration in \S2.2. in the previously submitted paper was misleading to this extent.
To address this issue:
\begin{itemize}
\item[(i)] we have partly rewritten \S2.2 in line with what said above;
\item[(ii)] we have added to \S5 another empirical evaluation using 
  alternative AllSAT and AllSMT procedures, \tabularallsat{}~\cite{spallittaDisjointProjectedEnumeration2025} and its SMT counterpart \tabularallsmt{}~\cite{spallittaDisjointPartialEnumeration2024} that are based on a very different
  enumeration algorithm ---which does not use blocking clauses, and
  which are not guaranteed to produce minimal assignments.
  We notice that also with these enumeration procedures the performance gap using our
  \NNFPlaisted{} encoding w.r.t.\ using \TseitinCNF{} and
  \PlaistedCNF{} encodings is dramatic, in line with those obtained
  with \mathsat{}.
  
\end{itemize}
\end{generalremark}
% \RSTODO{riscrivi \S2.2. di
%   conseguenza, spiegando che l'algoritmo e' solo un esempio e che la
%   disjointness e la minimalità non sono strettamente necessari.}

   \newpage
\begin{generalremark}\label{remark:otherfields}(\textbf{About applicability to related fields.})
  
\noindent
First, we wish to stress the fact that our CNF encoding is conceived and expected to be
effective for enumeration techniques which generate  \emph{partial}
assignments (Theorem~1 vs. Fact~1.).
%--possibly projected on a set of relevant atoms.
% \GMSIDENOTE{Senza ``possibly''?}
% \RSSIDENOTE{Hai ragione, ma non aggiunge nulla, l'ho tolto}
Thus, we do not expect benefits for techniques that generate
{\em total} or {\em nearly-total} assignments only.
%Consequently:

% \begin{itemize}
% \item
%{\em Answer Set Programming.}
To this extent, we do not expect our CNF encoding to bring benefits to
\textbf{Answer Set Programming}, since the answer sets are
\emph{total} assignments. We received confirmation from the clasp and
clingo developers that these tools do not support partial
assignments. See \url{ https://github.com/potassco/clingo/issues/512#issuecomment-2223162682}.
%\RSSIDENOTE{Riportato anche qui}
Indeed, answer sets represent total assignments, since they include
true atoms, and other atoms are implicitly false. 
Notice that the concept of ``minimal'' in ASP refers to the minimality
of the set of atoms that are true in the answer set, and not to the
minimality of the set of atoms that are assigned a truth value, as in
our paper.


% \item
% {\em d-DNNF-based model
% counting and enumeration.}
Also,
%\RSSIDENOTE{Questo paragrafo e' un po' debole e forse e' sussunto dal
%  prossimo. Parliamone.}
we do not expect our encoding to bring benefits to
  current \textbf{d-DNNF-based (projected) enumeration and model
    counting}, because these
tools typically do not rely their efficiency on the enumeration of partial assignments, but rather on the effective decomposition and caching of subproblems. 
  %
  E.g., the \df{}$_p$
  algorithm~\cite{lagniezRecursiveAlgorithmProjected2019} ---implemented by \df{} for
  {projected} d-DNNF compilation and counting--- does not exploit
  projected {\em partial} assignments,  because it first branches on important atoms, and only at the
end of the branch it tries to assign also the non-important atoms  to be
projected away.
Hence, the projected assignments assign all or almost-all important
atoms, producing thus total or nearly-total projected assignments.
% (Other projected d-DNNF compilation algorithms behave similarly.)
%
%\RSSIDENOTE{Aggiunta}
Notice that that using \NNFPlaisted{}
% instead of \TseitinCNF{}
may
even worsen the efficiency of these tools, since 
unlike with \TseitinCNF, with \PlaistedCNF{} the
\allB values are not always assigned deterministically by BCP from the
\allA{} values, forcing extra search;
also the NNF-ization
up-to-doubles the number of the
\allB{} labels, which are non-important atoms  to be
projected away;
also, we conjecture that the duplication of the labels
\poslab{B_i},\neglab{B_i} and the use of distinct encodings 
\poslab{\vi_i} and \neglab{\vi_i} for \NNF{\vi_i} and \NNF{\neg\vi_i}
may affect the effectiveness of the caching and partitioning
mechanisms of \df{}.


Although in principle ad-hoc d-DNNF compilation strategies for d-DNNF-based model
  counting/enumeration
could be devised to exploit the properties of our \NNFPlaisted{} encoding, 
investigating such techniques 
would exceed the scope of this paper. 

%{\em (Weighted) Model Counting.}
Finally, %and even more importantly,
for \textbf{(weighted) model counting} the \TseitinCNF{} encoding is
currently the most
suitable, because it preserves the model count, whereas
\PlaistedCNF{} and \NNFPlaisted{} do not.
%With \PlaistedCNF{()} or \PlaistedCNF{(\NNF{}) one should project away 
(In order to preserve the model count with these encodings and with current model counters one should
make them project away the \allB{} labels, drastically worsening their
performances.)
Although investigating ad-hoc model counting techniques for
\NNFPlaisted{}-encoded formulas (e.g., by exploiting the
polarity of labels) could be an interesting topic for future research, it would definitely exceed the scope of this paper.
% \TseitinCNF{()} so that standard
% (non-projected) model counting algorithms can be used. 


%\end{itemize}

% \begin{gmchange}
% Unfortunately, this is \emph{not} the case for enumeration in Answer Set Programming, since the answer sets are \emph{total} assignments. We received confirmation from the clasp and clingo developers that these tools do not support partial assignments. See \url{
%   https://github.com/potassco/clingo/issues/512#issuecomment-2223162682
% }.

% This is \emph{not} the case also for d-DNNF-based model counting and enumeration.
% In fact, the \df{}$_p$ algorithm~\cite{lagniezRecursiveAlgorithmProjected2019} for \emph{projected} d-DNNF compilation and counting is not able to exploit short projected partial assignments.
% This is because \df{} first branches on important atoms, and only at the end of the branch it looks if it can be extended to a satisfying assignment including also the non-important atoms. Hence, the projected assignments assign (almost) all important atoms.
% Other d-DNNF compilation algorithms behave similarly.
% Nevertheless, ad-hoc compilation strategies could be devised to exploit the properties of our encoding.

% As an additional note, for counting the Tseitin CNF encoding is the most suitable, as it preserves the model count, so that standard (non-projected) model counting algorithms can be used.


% \end{gmchange}

\medskip
\noindent\textbf{Actions performed.}
We have added a subsection  (\S5.5)   and some
paragraphs in \S6
%\RSSIDENOTE{DAFARE}
discussing these aspects.
%\RSSIDENOTE{Aggiunta.}
Also, we have added to Appendix D and E other
comparisons by using 
d-DNNF-based projected enumeration and model counting  with \df{} on CNF-ized
formulas. %, projecting away the \allB{} labels.
Using
% \PlaistedCNF{(\NNF{})} instead of \TseitinCNF{()} or \PlaistedCNF{()},
%With
\NNFPlaisted{} these tools show no 
benefit in terms of number and size of the assignments generated
and even worsen their time performance, as expected.
\end{generalremark}


\newpage
\section*{Reply to Review B}


(We invite the reviewer to read the General Remarks above
before  the following rebuttal.)

\begin{quote}
  This paper studies the problem of enumerating the cubes (``partial satisfying assignments'') of a Boolean formula in practice. In particular, the paper argues that most off-the-shelf enumeration algorithms expect CNF input, and so to work with a Boolean formula, one needs an efficient conversion to CNF.\@
  Three such conversion techniques are considered; namely, de Morgan's
  transform (typically intractable in practice), the Tseitin
  transform, and the Plaisted-Greenbaum transform (essentially a slightly more efficient variant of the Tseitin transform). 

  The crux of the paper is an argument that --if one wants to
  enumerate the cubes of a Boolean formula-- one should always first
  convert the input formula to NNF first, before running the Tseitin
  or Plaisted-Greenbaum transformation to obtain the CNF (which can
  then be passed to the enumeration algorithm).
\end{quote}

\noindent
More precisely, one should convert to NNF first {\em and then use
  \PlaistedCNF{}}, so that to exploit the positive polarity of all the non-literal
subformulas in \NNF{\vi}. (See
\cref{remark:theory} above). Notice that this would not work with
\NNFna{}+\TseitinCNF{}, because \TseitinCNF{} does not exploit single
polarities. 


\begin{quote}
  This argument is
  illustrated with a running example that shows that doing so, at
  least in the example given, allows one to obtain ``larger'' cubes
  (i.e., cubes with more unassigned variables). 

  All of this assumes that the enumeration algorithm uses an approach
  sketched at the bottom of page 6 in the paper, which involves taking
  satisfying assignments and trying to drop literals to find a larger
  cube.
\end{quote}

\noindent
%The last sentence is not accurate.
The paper does not make such an assumption.
We refer the reviewer to
\cref{remark:enumalgo} in the ``General Remarks'' section above. In short,
our approach is not restricted to the
enumeration algorithm in \S2.2 (previously page 6),
nor it is restricted to procedures based on blocking clauses, nor it is
restricted to procedures producing minimal assignments. 
More generally, the work described in this paper is agnostic w.r.t.\ the AllSAT (or AllSMT) procedure used,
the only restriction being that the enumeration procedure should be able to
produce {\em partial} assignments, so that Fact 1 applies
to \TseitinCNF{}/\PlaistedCNF{} and Theorem 1 applies to \NNFPlaisted{}.

To this extent  (see \cref{remark:enumalgo} above) we have partly rewritten
\S2.2. to highlight the above fact and we have added to \S5 a
new empirical evaluation using completely-different
enumeration procedures, \tabularallsat{} and \tabularallsmt{}, obtaining very similar results. 

  % \RSSIDENOTE{not accurate. Explain that this is not restricted to the
  %   algorithm...}
  \begin{quote}
  I was not able to fully follow the reasoning on why converting to NNF is
  always better --the example needs some improvement. However, I understand
  that it amounts to an argument saying that a minimal cube of the original
  (untransformed) formula may not be a minimal cube of the transformed,
  projected formula, and so running an enumeration algorithm on the
  transformed formula without having converted to NNF first could result in
  many small cubes.
\end{quote}

\noindent
Yes, except that this is not restricted to {\em minimal} assignments
(cubes); rather, this works for {\em partial} assignments in general.
(See \cref{remark:theory} above.)

\begin{quote}
  I would emphasize that many of these details were lost on
  me, so I would encourage the authors to try simplifying and shortening
  their example to better illustrate this. Overall, I found it hard to
  follow. The arguments in the paper were supported with experimental
  results, which seemed convincing enough.
% \end{quote}

% We tried to summarize the basic ideas and make it simpler,
% highlighting the key insights.
% \TODO{...}


% \begin{quote}
  One concern I have is that the novelty of the paper seems limited: it seems
  to amount to saying that one should always convert to NNF first before
  doing CNF conversion in preparation for model enumeration.
% \end{quote}

% \noindent
% More precisely, one should convert to NNF first {\em and then use
%   \PlaistedCNF{}}, so that to exploit the positive polarity of all the non-literal
% subformulas in \NNF{\vi}. (See
% \cref{remark:theory} above). Notice that this would not work with
% \NNF{\TseitinCNF{}}, because \TseitinCNF{} does not exploit single
% polarities. 


% \begin{quote}
  As far as I can
  tell, I did not see any theoretical justification guaranteeing that this is
  always worth doing. Perhaps this is what is being said in Theorem 1, but to
  me it seems to just say that converting to NNF first is sound, in the sense
  that every cube of the original formula can be extended to a (total)
  satisfying assignment of the resulting CNF (I am not sure why this is
  surprising). It is possible I misunderstood this, so I would be interested
  in getting some clarification on this point.
\end{quote}

\noindent
We believe that \cref{remark:theory} above addresses this concern in full.
In short, Fact 1 highlights the theoretical problem with \TseitinCNF{} ---and also
with \PlaistedCNF{}, although to a lesser extent--- whereas Theorem 1 shows that this problem is
solved with \NNFPlaisted{}.

As far as the soundness of the approach is concerned, it is a straightforward
consequence of the fact that \NNFna{} preserves equivalence and that
$\exists \allB. \vinnfcnfpg$ is equivalent to
$\NNF{\vi}$. We have added a few lines into \S4. to state this fact.

\begin{quote}
  Overall presentation of the paper was so-so --- as mentioned above, I found it hard to follow the details in many places, although the general message was clear.
\end{quote}

\noindent
We have rewritten in part \S2.2 and
we have completely rewritten \S3 and
\S4, in line with what we have said in \cref{remark:theory} and \cref{remark:enumalgo} above. We believe
the narration is much more comprehensible now.   
\begin{quote}

  Minor comments:
  \begin{itemize}
    \item I'm not sure why Property 1 is stated here; if you know that the NNF is linearly sized in the original formula, and a DAG representation is linearly sized in any formula, then of course the DAG representation of the NNF will be linearly sized in the original formula?
  \end{itemize}
\end{quote}

\noindent
The NNF is linearly sized in the original formula {\em if and only if
a DAG representation of NNF is used}, because we need to keep at most
two nodes for each subformula, one for each polarity.
(If instead one represented the
NNF formula as a tree, then the NNF representation would blow up
exponentially in the number of nested $\iff$'s in the original
formula, because each subformula $(\vi_i \iff \vi_j)$ is expanded 
into $(\neg\vi_i \vee \vi_j)\wedge (\vi_i \vee \neg\vi_j)$, thus
duplicating both $\vi_i$ and $\vi_j$; if e.g. $\vi_i$ contains some subformula
$(\vi_{i1}\iff\vi_{i2})$, then $\vi_{i1}$ and $\vi_{i12}$ occur 4
times each in the NNF tree,
and so on.)

We have added a few lines in the main text to clarify this point. 

Notice that, we used to think that Property~1 (now ``Lemma 1'') was well-known in the community, until a reviewer
for our SAT'23 paper questioned it, which convinced us to write 
an explicit proof for it and make it available in the appendix.
(A similar motivation applies to Property 2.) 
%
Also, to fulfill an explicit request from another reviewer, we have renamed
``Property'' into ``Lemma''.

\begin{quote}
  \begin{itemize}
    \item Confusingly, and connected to the point above, you seem to sometimes distinguish between DAG representations of a formula and the formula itself, and sometimes not --- in Property 1, you let $\NNF{\vi}$ be a formula, in Property 2, you say $\NNF{\vi}$ is a DAG. Which is it? To me, there should be no distinction: every formula \emph{is} a DAG.
          Since you are not allowing for circuits, you could remove ambiguity and instead of saying DAG, say arborescence (or perhaps rooted tree, or similar).
  \end{itemize}
\end{quote}
\noi
Fixed. We assume that every formula is a single-rooted DAG (arborescence).

\begin{quote}
  Recommendation:  Reject with encouragement to resubmit
\end{quote}

\newpage
\section*{Reply to Review C}
(We invite the reviewer to read the General Remarks above
before  the following rebuttal.)

\begin{quote}
  The authors consider transforming propositional formulas into conjunctive normal form (CNF) in different ways (Tseitin, NNF+Plaisted-Greenbaum) and study the effect on enumerating satisfying assignments (AllSAT) or T-satisfying assignments (AllSMT).

  Main Contributions / Pros:
  \begin{itemize}
    \item Tseitin transformations are disadvantageous for enumeration(introduced auxiliary atoms and double implications prevent short partial assignments)
    \item Plaisted-Greenbaum show advantages if single polarities are helpful
    \item Transforming formula into NNF and then applying Plaisted-Greenbaum can improve effectiveness for enumeration
  \end{itemize}
\end{quote}
Yes.

\begin{quote}
  Main Critics:
  \begin{itemize}
    \item The insights are mainly of practical and empirical nature, however, that does not necessarily have to be a disadvantage.
  \end{itemize}
\end{quote}

\noindent
We believe that \cref{remark:theory} above addresses this issue, and should
convince the reviewer that this paper has novel and important
theoretical contributions. In short, Fact 1 highlights the theoretical problem with \TseitinCNF{} ---and also
with \PlaistedCNF{}, although to a lesser extent--- whereas Theorem 1 shows that such problem is
solved with \NNFPlaisted.


% Although the discussion is presented through examples, also theoretical insights are provided.
% The fact that the proofs are in the appendix may have led to this impression.
% We moved the proof of Theorem 1 to the main text, since we believe it is a key result.

\begin{quote}
  \begin{itemize}
    \item Related works are a bit short when it comes to quite related fields,
          preprocessing, and a like. For example, backbones are not considered~\cite{kilbyBackbonesBackdoorsSatisfiability2005,janotaAlgorithmsComputingBackbones2015,biereCadiBackExtractingBackbones2023}, but might have a notable impact.
  \end{itemize}
\end{quote}

\noindent
We fail to understand this remark about backbones ---possibly because our expertise about backbones is limited.
% (We stress the fact that our paper is not about enumeration techniques,
% but on the effects of CNF-ization on enumeration and on how to deal
% with them.)
%
Although we realize that backbones may have a relevant impact on enumeration,
we do not see a clear
relation between backbones and CNF-ization for enumeration, which is
the main topic of this paper.
%
Our understanding is that our theoretical results are orthogonal to backbones, 
to preprocessing, and to enumeration techniques in general, provided
the latter allow for enumerating {\em partial} assignments. (See also
\cref{remark:theory} and \cref{remark:enumalgo} above.)
%
% In particular, in \cref{remark:enumalgo} above we have pointed out that our CNF-ization technique
% is expected to work regardless the enumeration technique adopted,
% provided it allows for enumerating {\em partial} assignments.   

Nevertheless, if the reviewer could kindly clarify this point and suggest
how we should improve the related work section accordingly, we would be happy to
do so. 

\begin{quote}
  \begin{itemize}
    \item[] Projected solution enumeration is
      already implemented into ASP solvers and runs quite efficiently. It would
      allow more direct encodings (also of non-CNF formulas) and topics related
      to transformations have already been discussed there~\cite{giunchigliaAnswerSetProgramming2006}, especially under
      the light that ASP solvers also need to introduce bi-implications
      (internally) due to Clark's completion. Enumeration techniques have also
      been considered for propositional circumscription~\cite{alvianoModelEnumerationPropositional2017}. While it might in
      fact be quite interesting that these tools are readily available and can
      easily be used also on DIMACS encodings, I'm not necessarily asking to
      include those solvers in the empirical evaluation, but I find it important
      that relations to other constraint-solving areas are discussed in a journal
      paper. Note that the ASP solver options in the paper~\cite{gebserSolutionEnumerationProjected2009}, which the authors
      of the present paper also refer to, are much more elaborate today than
      given in 2008 reference and more recent works also exist~\cite{alvianoModelEnumerationPropositional2017}.
  \end{itemize}
\end{quote}

\noindent
We refer the reviewer to \cref{remark:otherfields} above and the relative
actions performed.  

% In the related work section of the paper, we have added a discussion on ASP and on the possible use of our encoding in combination with ASP solvers.
% The main issue is that answer sets are total assignments, and not
% partial assignments, so we believe that answer set enumeration would not benefit from our encoding.

\begin{quote}
  \begin{itemize}
    \item The empirical evaluation misses works on knowledge compilation. In fact,
          d-DNNFs allow enumeration of satisfying assignments (ME) and DNNFs allow
          projections (forgetting)~\cite{darwicheKnowledgeCompilationMap2002}. Hence, it might be interesting to compare to these approaches as well.
%   \end{itemize}
% \end{quote}
% %
% \begin{quote}
%   \begin{itemize}
    \item If I remember correctly the ISCAS85 circuits and some AIG instances where
          also considered in the model counting competition. If counting works fast on d-DNNFs one might ask whether a comparison to recent knowledge compilers
          might be in advised~\cite{CompileProjectCRILCNRS}.
  \end{itemize}
\end{quote}

\noi
% \RSNOTE{io qui nei prossimi 2 iterm mi riferirei sempicemente al
%   General remark 3, lasciando il prossimo paragrafo riassuntivo}
We refer the reviewer to \cref{remark:otherfields} above and the relative
actions performed.  
%We refer the reviewer to \cref{remark:otherfields} above.  
% In short, \df{} allows for projected d-DNNF compilation (on which assignments can
% be enumerated and/or counted), but the projected compilation algorithm
% used by \df{} 
% %%RS: qui la nozione di "short" puo' essere misleading
% %does not allow for finding short partial assignments; rather, it
% finds only total or nearly-total assignments. 

% We have added a discussion on d-DNNF enumeration in the related work
% section and at the end of experimental section.
% % \RSNOTE{Ma qui non potremmo semplicemente aggiungere un plot di
% %   confronto con \df{} mostrando che la nostra tecnica non ha benefici x
% %   via di total assignments? Ce l'abbiamo?}
% \GMCHANGE{In Appendix D, we have added an empirical evaluation for \dfdecdnnf{}~\cite{lagniezLeveragingDecisionDNNFCompilation2024}, a recently-proposed d-DNNF-based enumeration algorithm. 
% The results show that our encoding does not bring benefits to
% d-DNNF-based enumeration, as expected.}

% \noindent
% We refer the reviewer to \cref{remark:otherfields} above.  
% %Similarly to projected model counting,
% The algorithm implemented in \df{}
% does produces only total or nearly-total assignments, and would  hence
% does not
% benefit from our encoding. 
% We believe that ad-hoc compilation strategies could be devised to exploit the properties of our encoding.

% Moreover, for \#SAT, the most suitable CNF encoding is Tseitin CNF, as it preserves the model count, whereas using Plaisted and Greenbaum CNF would require performing projected model counting, which is generally harder.
% %
% This analysis was confirmed also by experimental evidence\GMCHANGE{, 
% which we have added into Appendix E.}
% % \RSTODO{Ce l'abbiamo? se si io l'aggiungerei}

% We added a section on the related work where we discuss on \#SAT.

\begin{quote}
  \begin{itemize}
    \item Experiments are not replicable. I did not receive a replication package (unless I missed it) and the authors do not provide links for the benchmark instances within the submission. (Solver sources are provided on GitHub only.)
  \end{itemize}
\end{quote}

\noindent
 In the original submission, we included the source code as
 supplementary material.

 Additionally, to further enhance accessibility and ensure the experiments' replicability, we have uploaded all materials (source code, benchmarks, and results) to Zenodo~\cite{masina_2024_cnf_code,masina_2024_cnf_results}. For convenience, the Zenodo links is also provided at the beginning of the Experimental Evaluation section.

\begin{quote}
  Positive:
  \begin{itemize}
    \item The paper studies a quite interesting question that is often neglected very thoroughly, addresses an interesting research question, and provides novel practical insights.
    \item The questions studied will likely have applications to other areas such as NumberSAT and various AI formalisms that involve enumeration or counting together with a propagator, e.g., answer set programming and other areas.
    \item Design decisions very well explained and the paper is easy to understand.
    \item The authors obtain throughout the benchmark set an improvement.
  \end{itemize}

  Summary:

  Since the paper has primarily empirical contributions together with a small trick (NNF) one might ask whether it is sufficient for a JAIR, however, I believe due to the general nature of the problem and potential use in other AI
  formalisms (NumberSAT, ASP Enumeration, and many others) and their solvers that it is actually a very important topic to study. Hence, it should be a clear fit for JAIR.
  Still, due to some shortcomings with other  AI formalisms and solving techniques, I would like to see an improved version
  and my questions addressed or discussed in a response. Thus, I recommend major revision.


  Minors:
  \begin{itemize}
    \item Some parts of the writeup might be improved and would be great if certain parts are less sloppily written.
  \end{itemize}
\end{quote}

\noindent
As also stated in the general remarks above, we have rewritten in part
\S2.2., we have completely rewritten \S3 and \S4 and we have
significantly updated \S5 and we have expanded \S6.

\begin{quote}
  \begin{itemize}
    \item I would find it important that the empirical evaluation section is more clear and better structured.
  \end{itemize}
\end{quote}

\noindent
We have significantly updated the empirical evaluation section.
(See also local points below.)
Nevertheless, if the reviewer has some more suggestions on how to further
improve it, we will be eager to address them. 

\begin{quote}
  \begin{itemize}
    \item References: if the style allows it would be nice to have the references to citations included into hyperref as it makes it more convenient to read on an iPad.
  \end{itemize}
\end{quote}
\noindent
Unfortunately {theapa}, the JAIR bibtex template,  does not allow for hyperlinks in
the references. % by default.

\begin{quote}
  \begin{itemize}
    \item P2. Would recommend to place the contributions into a main contributions paragraph and replace the heading for the ``Content'' paragraph by Organization.
  \end{itemize}
\end{quote}

\noindent
Fixed.

\begin{quote}
  \begin{itemize}
    \item P2. Section signs seem a bit unusual. It's probably fine with US style, but then I would suggest to doublecheck the paper for US spelling and grammar. There are a few places where I spotted BE spelling.
  \end{itemize}
\end{quote}

\noindent
Fixed, we used US spelling throughout the paper.
% Actually, we believe that the Section symbol ``$\S$'' is standard and
% allows for compact reference, making the result lighter.
% We would rather leave it. 
%\TODO{Check}

\begin{quote}
  \begin{itemize}
    \item P2. ``Disclaimer'' $\rightarrow$ Previous works? Maybe also remove the much shorter version?
  \end{itemize}
\end{quote}

\noi Fixed.
%\TODO{We left disclaimer...}

\begin{quote}
  \begin{itemize}
    \item P2/3. Reference to standard literature might be added.
  \end{itemize}
\end{quote}

\noi Fixed.
%\TODO{Check}

\begin{quote}
  \begin{itemize}
    \item P3. What are ``generic atoms''?
  \end{itemize}
\end{quote}

\noi
We meant both Boolean and theory atoms. We have clarified this in the text.

\begin{quote}
  \begin{itemize}
    \item P3. Would suggest clarify the mathematical writing, e.g.,
          ``set A of atoms'' instead of ``set of atoms A''.
  \end{itemize}
\end{quote}
\noi
Fixed.

\begin{quote}
  \begin{itemize}
    \item Proofs in the appendix are fairly sloppy. Pls improve.
  \end{itemize}
\end{quote}
\noi
We revised the proofs, and fixed the overfull sentences and overall formatting.
We fixed a few missing ``$\neg$''s in our proof of Property 3 (now
Lemma 3) in Appendix A.2.

If the reviewer has further indications, then we will be
eager to address them. 

\begin{quote}
  \begin{itemize}
    \item P3. SAT problem defined before giving semantics of satisfiability.
  \end{itemize}
\end{quote}
\noi
Fixed.

\begin{quote}
  \begin{itemize}
    \item P4. $\vi(\allalpha)$ somewhat unclear, whether it refers to free variables (later it just emphasizes on the variables).
  \end{itemize}
\end{quote}
\noi
The notation means that the formula $\vi$ is on the atoms $\allalpha$. We clarified this in the text.

\begin{quote}
  \begin{itemize}
    \item P4. Property $\rightarrow$ Observation/Lemma?
  \end{itemize}
\end{quote}
\noi
We changed from ``Property'' to ``Lemma''.

\begin{quote}
  \begin{itemize}
    \item P5. Starting sentence with E.g. $\rightarrow$ For example, ?
  \end{itemize}
\end{quote}
\noi
Fixed.

\begin{quote}
  \begin{itemize}
    \item P7. Alg 1. More detailed description of input and output could be interesting
  \end{itemize}
\end{quote}

\noi
We added a description of the input and output in Algorithm 1.

\begin{quote}
  \begin{itemize}
    \item P11. Various of today's knowledge compilers work on d-DNNFs. Hence, a comparison might be quite relevant here
  \end{itemize}
\end{quote}

\noi
See the answer above.


\begin{quote}
  \begin{itemize}
    \item P13 The 1. Computational complexity considerations might be interesting here
  \end{itemize}
\end{quote}
\noi
Our result does not impact the theoretical complexity of the problem, but only the practical performance. Indeed, in the worst case, one could be still forced to enumerate all, or a large fraction of, the total assignments of the formula, which can be up to exponential in the number of variables.
This can depend on many factors, such as the structure of the formula, the order in which the solution space is explored, and the minimization strategy adopted.

%\DISCUSS{Dire questo anche nel paper? RS: io lascerei perdere}

\begin{quote}
  \begin{itemize}
    \item P13/14. The beginning of the experimental evaluation and following sections appear to be jumping between topics, a better structure might simplify reading a bit
  \end{itemize}
\end{quote}

\noi
Fixed. We have moved into an ad-hoc subsection (\S5.3) the info about the
parameters of \mathsat{}, \tabularallsat{}, and \tabularallsmt{}, the details of the hardware used
and the links to the material for reproducibility.
We believe this is clear now.

\begin{quote}
  \begin{itemize}
    \item While the benchmark instance section is nicely explained, the results are a bit short and it is a bit hard to read the full page of plots. Might be better to split it up or also present a summary plot. Since plots and tables are not on the same page, it was a bit hard to follow.
  \end{itemize}
\end{quote}

%\TODO{Check}
\noindent
We have enriched the captions of the figures and the description of
the results, and reorganized the structure of the section.

\begin{quote}
  \begin{itemize}
    \item P13. It was not clear to me why the same solver was used for the SAT and SMT part.
  \end{itemize}
\end{quote}
\noi
\mathsat{} is both an AllSAT and AllSMT solver.
As it can be seen from Table 1 in Appendix B, at submission time
\mathsat{} was the only available solver suitable for our experimental evaluation,
because no other solver satisfies the requirements (i)-(v) in Section 5.1.
(In this resubmission we used also the very-recent tools \tabularallsat{} and \tabularallsmt{},
which were not yet available at submission time.)
%\RSTODO{aggiungere TabularAllSAT}

\begin{quote}
  \begin{itemize}
    \item Since related works are relevant quite early, it might be interesting to present related works in the beginning.
  \end{itemize}
\end{quote}
\noi
We would rather not do so. The related work is nearly 3 pages long, and moving it at the beginning would break the flow of the paper.

\begin{quote}
  \begin{itemize}
    \item P23. Overfull sentence
  \end{itemize}
\end{quote}
\noi
Fixed.

\begin{quote}
  \begin{itemize}
    \item P23. Proofs are easy but a bit sloppily written. Could be improved
  \end{itemize}
\end{quote}
\noi
As stated above, we revised the proofs, and fixed overfull sentences and overall formatting. We also fixed some missing ``$\neg$''s in one proof.

\begin{quote}
  \begin{itemize}
    \item Table 1: If I'm not mistaken clasp supports partial, minimal models, and non-disjoint enum via options. See ``clingo --help=3''.\\
          See \texttt{\#show} / \texttt{\#hide} statements in the instance (requires ASP instead of DIMACS input). See also: \texttt{opt-strategy=} , \texttt{--models=0}, \texttt{--project} (for projected enum enumeration), and \texttt{--enum-mode} modes
  \end{itemize}
\end{quote}
\noi
%\RSSIDENOTE{io mi limiterei a questo, senza ripetere.}
%We refer the reviewer to \cref{remark:otherfields} above.  
We refer the reviewer to \cref{remark:otherfields} above and the relative
actions performed.  

% We received confirmation from the clasp and clingo developers that they do not support partial (minimal) models. See \url{https://github.com/potassco/clingo/issues/512\#issuecomment-2223162682}.
% Indeed, answer sets represent total assignments, since they include true atoms, and other atoms are implicitly false.
% Notice that the concept of ``minimal'' in ASP refers to the minimality
% of the set of atoms that are true in the answer set, and not to the
% minimality of the set of atoms that are assigned a truth value as in
% our paper.

\begin{quote}
  \begin{itemize}
    \item \df{} should also be included (requires additional tooling on top of the d-DNNF and might have limitations for the partial enumeration).
  \end{itemize}
\end{quote}
\noi
%\RSSIDENOTE{io mi limiterei a questo, senza ripetere.}
We refer the reviewer to \cref{remark:otherfields} above and the relative
actions performed.  
%We refer the reviewer to \cref{remark:otherfields} above.  

% We added a discussion on enumeration on d-DNNFs in the related work section.
% \GMCHANGE{
%   In Appendix~D, we have also added an empirical evaluation for \dfdecdnnf{}~\cite{lagniezLeveragingDecisionDNNFCompilation2024}, which allows for the enumeration of models of a d-DNNF.  
% }

% \TODO{Aggiungere \df{} experimental evaluation}
\begin{quote}
  \begin{itemize}
    \item Maybe use a publicly archived data repository for sources and datasets for long term archival purposes (e.g., Zenodo operated by CERN and funded by the European Commission)
  \end{itemize}
\end{quote}

\noindent
We have uploaded all materials (source code, benchmarks, and results) to Zenodo~\cite{masina_2024_cnf_code,masina_2024_cnf_results}.

\begin{quote}
  \begin{itemize}
    \item Figure 1 needs additional explanation and I would prefer at least one figure with the main message.
  \end{itemize}
\end{quote}

\noindent
We have improved the caption of Figure 1 and added some sentences in
the main text to improve the explanations of this Figure.
This said, 
we fail to understand the intended meaning of ``one figure with the
main message'' in the above sentence. If the reviewer kindly clarifies this, we will do
our best to address it if possible. Notice that Figures 1, 2, 3, and 4 refer to very different scenarios
(disjoint vs non-disjoint, SAT vs SMT, \mathsat{} vs \tabularallsat{}/\tabularallsmt{}) and
as such cannot be merged into one collective figure. (Figure 4 has been added in the resubmission.)
%\DISCUSS{?}

\newpage
\section*{Reply to Review D}
(We invite the reviewer to read the General Remarks above
before  the following rebuttal.)

\begin{quote}
  This work compares different CNF encoding techniques for enumerating satisfying assignments, both in theory and in practice. It turns out that regular Tseytin transformation might not be the first choice, as it prevents enumeration solvers from instantiating small partial satisfying assignments. The authors back up the insights of this work by empirical results.

  The construction introduced and presented here is interesting, but essentially fits on one page (Section 3), so the actual meat of this paper is more on the lighter side. I am wondering if this approach could be elevated to further characteristics besides assignment size. Nevertheless the paper is self-contained in its current form.

  The results seem fine and are definitely worth publishing, but the current presentation is maybe not over exciting. Regarding significance, this work definitely fits into AI, as enumeration is relevant to a broad range of formalisms. Also, the work was recently presented at the SAT conference, so it was probably judged to be novel.

  It is strange that SMT counting and weighted model integration are
  mentioned, but regular model counting (\#SAT) that seems to be closest is
  not at all mentioned nor cited. Is \#SMT or WMI somehow closer to AllSAT
  than \#SAT?
\end{quote}
\noi
Yes, \#SMT and WMI are much closer to AllSAT/AllSMT than \#SAT. The reason is that \#SAT does not strictly require enumerating
truth assignments, since only their \emph{number} is relevant, whereas
 in \#SMT and WMI truth assignments must be explicitly generated to be
 ``consumed'', because for each assignment a volume or an integral must be computed, respectively.


\begin{quote}
  Do the authors expect different relationships to \#SAT? There are
  even annual competitions~\footnote{\url{https://mccompetition.org/2023/mc_description.html}} that are carried out. Does this approach work
  well for counting?
\end{quote}
\noi
%We refer the reader to \cref{remark:otherfields} above.
We refer the reviewer to \cref{remark:otherfields} above and the relative
actions performed.  
% \RSSIDENOTE{Io taglierei questa sentence.}For \#SAT, advanced
% techniques that do not require enumerating all truth assignments are
% available, even though a complete exploration of the solution space is
% still needed.
%We have added a discussion also on \#SAT in the related work section.

\begin{quote}
  The theoretical results seem to be mostly shifted to the appendix. It would
  have been nice to make a larger section out of it, discussing theoretical
  insights that are then demonstrated in practice. It would be interesting to
  provide a more fine-grained comparison of the three translations in the
  form of a table.
\end{quote}
\noi
Following the reviewer's suggestion, we have moved the proof of
Theorem 1 into the main paper, and we have added some
comments to it into the main text.
%% RS: suona come una leccata di culo
% We thank the reviewer for the valuable suggestion, since this is the main theoretical result of the paper, and it is important to have it in the main text.

\begin{quote}
  Some statements are a bit misleading: ``When passing from solving to
  enumeration''. This somewhat implies that enumeration would not be solving.
  Maybe it is better to reformulate and instead talk about the decision
  problem or the problem of computing a single solution.
\end{quote}
\noi
We rephrased the sentence, both in the abstract and in the introduction, as:
``When passing from \emph{plain} solving to enumeration...''.

\begin{quote}
  Minors:
  \begin{itemize}
    \item Preliminaries
          \begin{itemize}
            \item Page 3: Satisfiability Modulo The Theory $\rightarrow$ Remove ``The''
          \end{itemize}
  \end{itemize}
\end{quote}
\noi
The complete sentence is ``Satisfiability Modulo the Theory T ...'', so the article is needed.

\begin{quote}
  \begin{itemize}
    \item[] \begin{itemize}
        \item ``formulas'' $\rightarrow$ \emph{formulas}
        \item `` atoms'' $\rightarrow$ \emph{atoms}
      \end{itemize}
  \end{itemize}
\end{quote}
\noi
Fixed.

\begin{quote}
  \begin{itemize}
    \item Sections 3 and 4:
          \begin{itemize}
            \item Some examples appear a bit spacious and overly complicated. See Example 1 and Example 3.
          \end{itemize}
  \end{itemize}
\end{quote}
\noindent
We have completely rewritten the examples, shortening and simplifying
them and making 
them independent from the enumeration procedure. (See also general Remark 1.)
% The examples have been revised to illustrate the impact of different CNF transformations on the same input Boolean formula. First, we present a minimal assignment for the CNF-ized formula that goes undetected during enumeration due to the introduction of fresh atoms. We then demonstrate how the enumerator behaves when the variables in the minimal assignment are assigned, and how it handles the remaining non-relevant variables. By explaining the generation of satisfying partial assignments step by step, linking each literal to the clauses that force its truth value, the reader is now better guided to understand the weaknesses of each CNF transformation.

\begin{quote}
  \begin{itemize}
    \item Section 6:
          \begin{itemize}
            \item The figures should be moved to earlier pages.
          \end{itemize}
  \end{itemize}
\end{quote}

\noindent
Fixed.

\begin{quote}
  Recommendation:  Accept with minor revisions
\end{quote}

\newpage
\section*{Reply to Review E}
(We invite the reviewer to read the General Remarks above
before  the following rebuttal.)


\begin{quote}
  The manuscript addresses a novel and significant issue, exploring various CNFization techniques to efficiently enumerate truth assignments for non-CNF formulas. It is commendably clear in articulating the problem statement and demonstrating the limitations of existing CNFization techniques, such as those by Tseitin (Ts) and Plaisted and Greenbaum (PG), which tend to generate excessively lengthy truth assignments due to the assignment of more variables. This, in turn, adversely impacts their scalability.

  The authors propose a preprocessing step that converts a non-CNF formula into Negation Normal Form (NNF) before applying the Plaisted and Greenbaum techniques. This method significantly enhances scalability by facilitating the computation of shorter truth assignments. A notable strength of this approach is its independence from SAT and SMT solvers, which broadens its applicability. The paper supports its technical contributions with formal proofs, which appear to be sound, and further validates its approach through empirical testing. However, the conversion to NNF, while beneficial in producing shorter assignments, also introduces longer enumeration times, as evidenced by circuit benchmark performance.

  Questions for Clarification:
  \begin{itemize}
    \item Does the order of literals affect Algorithm 1's output, and is there a guarantee that it will consistently yield the minimal possible assignment?
  \end{itemize}
\end{quote}
\noi
Yes, the order in which literals are dropped affects the output of Algorithm 1. Here we show a simple greedy strategy, but other strategies can be adopted.
In general, the algorithm is guaranteed to yield an assignment that is minimal \emph{with respect to the $\etaB$ found}.
Hence, better results can be obtained by adopting ad-hoc heuristics to find the ``best'' $\etaB$.

We wish to stress the fact, however, that Algorithm 1 was intended to
illustrate one 
simple way to implement (projected) AllSAT, and that our approach is
not restricted to this algorithm. (See \cref{remark:enumalgo} above.)

\begin{quote}
  \begin{itemize}
    \item In the absence of blocking clauses for non-disjoint cases, what conditions prompt Algorithm 1 to terminate? Is there a risk of indefinite execution?
  \end{itemize}
\end{quote}
\noi
For non-disjoint cases, blocking clauses are still used in the search, but are ignored only in the Minimize-Assignment procedure.
This guarantees that the algorithm terminates.

\begin{quote}
  \begin{itemize}
    \item Could the authors elaborate on potential applications for non-disjoint enumeration?
  \end{itemize}
\end{quote}
\noi
Most applications in data mining, network verification, and model checking (predicate abstraction), listed in the paragraph ``Applications of AllSAT and AllSMT'' in Section 6 can involve both disjoint and non-disjoint enumeration.
Here the requirement is only to ``cover'' all the satisfying assignments of the formula, without any restriction on the intersection of the assignments. Depending on the case, one of the two types of enumeration can be more suitable or more efficient.

\begin{quote}
  \begin{itemize}
    \item In cases involving Syn-LRA within the SMT context, some instances exhibit larger TA (truth assignment) size for NNF + PG application compared to those determined solely by PG. Do you have any explanation?
  \end{itemize}
\end{quote}
\noi
This can depend on many factors that are not directly controllable.
For example:
\begin{itemize}
  \item the order in which assignments are generated
  \item the $\etaB$ found, which could impact the effectiveness of the Minimize-Assignment procedure
  \item the order in which literals are dropped in the Minimize-Assignment procedure
\end{itemize}
However, from experimental evidence, these cases are very rare.

\begin{quote}
  \begin{itemize}
    \item When the TA sizes of PG and NNF+PG applications are (roughly) similar, what implications might this have on the structure of the underlying non-CNF formula?
  \end{itemize}
\end{quote}
\noi
This happens when most sub-formulas occur with single polarity in the original formula.

\begin{quote}
  \begin{itemize}
    \item Why were preprocessing techniques disabled in the MathSAT solver during your experiments?
  \end{itemize}
\end{quote}
\noi
Since \mathsat{} was conceived as an SMT solver, by default it performs
some transformations on the input formula which are
satisfiability-preserving but not equivalence-preserving.
%
We received instructions from the \mathsat{} team to disable these transformations to ensure a correct output for AllSMT.
%
We have clarified this in the text.

\begin{quote}
  \begin{itemize}
    \item Has the team considered calculating the shortest truth assignment using an iterative SAT solver method with increasingly stringent cardinality constraints, similar to the approach by~\cite{iserMinimizingModelsTseitinEncoded2013}?
          Although challenging for complete enumeration, this could provide insights
          into the cardinality of the shortest versus NNF+PG computed truth
          assignments.
  \end{itemize}
\end{quote}

\noi
The suggestion of considering cardinality constraints to check the
quality of the partial assignment is interesting, but as already
stated by the reviewer, it is impractical for enumeration, given the
large number of models involved.

%\RSSIDENOTE{aggiunta}
We also recall that the goal of this paper is not to
investigate novel enumeration procedures; rather, it is to investigate the
effects of CNF-ization for enumeration and to fix a major weakness of
standard CNF-izations. 

\begin{quote}
  \begin{itemize}
    \item The statement ``Conflict clauses resting. We remark, however, that that should be applied for an high number of partial assignments, making it imprare excluded by the minimization, beiactical for testing with the benchmark proposed in this paperng redundant.'' requires clarification regarding its context and implications.
  \end{itemize}
\end{quote}
\noi
A SAT/SMT solver based on CDCL may learn conflict clauses during the search for a satisfying assignment.
Conflict clauses are clauses implied by the formula that rule out non-satisfying assignments.  They are ``redundant'' since they are implied by the formula itself, and they are only useful to prune the search space during the search for a satisfying assignment.
As such, they can be ignored in the minimization procedure. Their presence could otherwise reduce the effectiveness of the Minimize-Assignment procedure, by preventing the removal of literals that would otherwise lead to a smaller assignment.

We removed this sentence since it was not strictly necessary for a high-level understanding of the enumeration procedure, and not enough context was provided.

\begin{quote}
  \begin{itemize}
    \item   The sentence structure in section 3.1, specifically the line ``In fact, each such truth assignment\ldots'', is convoluted and challenging to interpret.
  \end{itemize}
\end{quote}
\noi
Section 3.1 was completely rewritten to address this and other issues raised by the reviewers.

\begin{quote}
  \begin{itemize}
    \item The term ``not-necessarily-prime implicant cover'' lacks clarity and could benefit from a more detailed explanation.
  \end{itemize}
\end{quote}
\noi
With respect to the problem of finding all prime implicants, AllSAT is a much simpler problem. It can be viewed as the problem of finding a subset of implicants (i.e., partial satisfying assignments), not necessarily prime (i.e., minimal), which covers all the total satisfying assignments of the formula.
We have rewritten this sentence to make it clearer.

\begin{quote}
  These clarifications will enhance the comprehensibility and overall impact of the research presented.

  Recommendation:  Accept
\end{quote}

\newpage
\bibliography{jair-allsat-cnfs-rebuttal}

\end{document}
