In this section, we experimentally evaluate the impact of different CNF-izations on the AllSAT task. In order to compare them on a fair ground, we have implemented a base version of each from scratch in PySMT~\cite{gario_pysmt_2015}, avoiding specific optimizations done by the solvers.
We used \mathsat{}~\cite{mathsat5_tacas13} as a SAT enumerator, because it implements the enumeration strategy by~\cite{hutchison_smt_2006} described in~\sref{sec:background:allsat}. 
%To compute a set \TA{}, we invoked \mathsat{} with the following options: \textsf{-dpll.allsat\_allow\_duplicates=false} (assignments must be pairwise disjoint), \textsf{-dpll.allsat\_minimize\_model=true} (assignments are minimal), \textsf{-preprocessor.simplification=0} and \textsf{-preprocessor.toplevel\_propagation=false} (disable several non-validity-preserving preprocessing steps).
We set the options \textsf{-dpll.branching\_initial\_phase=0} to split on the false branch first and \textsf{-dpll.branching\_cache\_phase=2} to enable phase caching.
%\GMCHANGE{
%    We checked the results by ensuring that (a) $\muA\models\vi$ for every $\muA\in\TA{\exists\allB.\vicnfgen}$; (b) for every $\etaA\in\TTA{\vi}$ there exists a $\muA\in\TA{\exists\allB.\vicnfgen}$ s.t. $\muA\subseteq\etaA$. This check was done only on the WMI benchmarks, because the problems in the other two groups of benchmarks had too many   partial and total truth assignments to be checked in a reasonable time.
%}

% The code and the experiments are available at: \url{TODO}\\
Experiments run on an Intel Xeon Gold 6238R @ 2.20GHz 28 Core machine with 128 GB of RAM and running Ubuntu Linux 20.04.
For each instance, we set a timeout of 1200s.

\subsection{Datasets description}
    We consider three sets of benchmarks of non-CNF formulas coming from different sources, both synthetic and real-world.
    In the first set of benchmarks, we generate random Boolean formulas by nesting Boolean operators up to a fixed depth. The second dataset consists of Boolean formulas encoding properties of ISCAS'85 circuits~\cite{brglez_neutral_1985,hansen_unveiling_1999,tibebu_augmenting_2018}. As a third set of problems, we consider formulas encoding Booleanized Weighted Model Integration (WMI) problems~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallitta_smt-based_2022}.
    \subsubsection*{The synthetic benchmarks}
    The synthetic benchmarks are generated by nesting Boolean operators $\wedge, \vee, \iff$ until some fixed depth $d$. Internal and leaf nodes are negated with 50\% probability.
    Operators in internal nodes are chosen randomly, giving less probability to the $\iff$ operator. In particular, $\iff$ is chosen with a probability of 10\%, whereas the other two are chosen with an equal probability of 45\%.
    We generated 100 synthetic instances over a set of 20 Boolean atoms and depth $d=8$.

    \subsubsection*{The circuits benchmarks}%
    \label{sec:benchmarks:iscas}
    The ISCAS'85 benchmarks are a set of 10 combinatorial circuits used in test generation, timing analysis, and technology mapping~\cite{brglez_neutral_1985}. They have well-defined, high-level structures and functions based on multiplexers, ALUs, decoders, and other common building blocks~\cite{hansen_unveiling_1999}.
    We generated random instances as described in~\cite{tibebu_augmenting_2018}. In particular, for each circuit, we constrained 60\%, 70\%, 80\%, 90\% and 100\% of the outputs to either 0 or 1, for a total of 250 instances.


    \subsubsection*{The WMI benchmarks}
    WMI problems are generated using the procedure described in~\cite{spallitta_smt-based_2022}. Specifically, the paper addresses the problem of enumerating all the different paths of the weight function by encoding it into a skeleton formula. Each instance consists of a skeleton formula of a randomly-generated weight function, where the conditions are only over Boolean atoms. Since the conditions are non-atomic, the resulting formula is not in CNF, and thus we preprocess it with the different CNF-izations before enumerating its models.\@ We generate 10 instances for each depth value 3, 5, 7, 9, each instance involving 10 Boolean atoms and no real variable, for a total of 40 problems.

    We remark on two aspects of these benchmarks. First, we have chosen to have Boolean-only weight conditions in order to better analyse the capacity of Boolean reasoning of the solver with the different transformations, without additional factors brought by the SMT component. Nevertheless, we expect to have similar outcomes also for formulas involving both Boolean and $\smtlarat$ atoms. Notice that these can still be meaningful WMI instances, as the $\larat$ component may be constrained by the rest of the formula.
    % (i.e.\ the \emph{support} formula~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallitta_smt-based_2022})}. 
    Second, these formulas contain existentially quantified $\smteuf$ atoms, so that we enumerate $\exists\ally.\vi(\allA,\ally)$ by projecting the models of $\vi$ over the relevant atoms $\allA$~\cite{spallitta_smt-based_2022}.
\subsection{Results}

\cref{fig:plt:syn:scatter,,fig:plt:circ:scatter,,fig:plt:wmi:scatter} show the results of the experiments on the synthetic, ISCAS'85 and WMI benchmarks, respectively.
For each group of benchmarks, we report a set of scatter plots to compare \TseitinCNF{}, \PlaistedCNF{} and $\NNFna{}+\PlaistedCNF{}$ in terms of number models, in the first row, and execution time, in the second row. Notice the logarithmic scale of the axes!
% Moreover, we show with CDF plots (\cref{fig:plt:syn:time:ecdf,fig:plt:circ:time:ecdf,fig:plt:wmi:time:ecdf}) the cumulative execution time taken to enumerate the models of the formulas CNF-ized with the different transformations.

In~\sref{sec:experiments:sat} we also report the CDF of the execution time for plain SAT solving on the same group of benchmarks. We see from the results that, unlike with enumeration, the pre-conversion into NNF has no benefit for plain solving, as we observed in~\cref{rem:ex3:preconv}.

\begin{figure}
    \centering
    % \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:syn:models:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:syn:models:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:syn:models:lab_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:syn:time:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:syn:time:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/syn/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:syn:time:lab_vs_nnfpol}
        % \end{subfigure}
\end{subfigure}
\caption{Set of scatter plots comparing the different CNF-izations on the synthetic benchmarks. The first and second rows compare them in terms of number of models and execution time, respectively. All the axes are on a logarithmic scale. In these problems, there were no timeouts.}%
\label{fig:plt:syn:scatter}
%     \begin{subfigure}[t]{\textwidth}
%         \centering
%         \includegraphics[width=0.4\textwidth]{plots/syn/enum_time_ecdf.pdf}%
%         \caption{CDF of the time taken to compute AllSAT using the different CNF-izations The $y$-axis reports the number of instances for which the enumeration finished within the cumulative time on the $x$-axis.}%
%         \label{fig:plt:syn:time:ecdf}
%     \end{subfigure}
    % \caption{Results on the synthetic benchmarks. \cref{fig:plt:syn:scatter} compares the number of models and the execution time of the different CNF transformations. \cref{fig:plt:syn:time:ecdf} compares the execution times through an CDF.}%
    % \label{fig:plt:syn}
\end{figure}

\subsubsection*{The synthetic benchmarks}

The results on the synthetic benchmarks are shown in~\cref{fig:plt:syn:scatter}. All the problems were solved for all the encodings within the timeout. The plots show that \PlaistedCNF{} performs better than \TseitinCNF{}, since it enumerates fewer models (first row) in less time (second row) on every instance. Furthermore, the combination of NNF and \PlaistedCNF{} yields by far the best results, drastically reducing the number of models and the execution time by orders of magnitude w.r.t.\ both \TseitinCNF{} and \PlaistedCNF{}. %The analysis on the execution time is confirmed by the CDF in~\cref{fig:plt:syn:time:ecdf}.}



\subsubsection*{The circuits benchmarks}

\begin{figure}
    \centering
    % \begin{subfigure}[t]{\textwidth}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:circ:models:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:circ:models:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:circ:models:lab_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:circ:time:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:circ:time:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/circ/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:circ:time:lab_vs_nnfpol}
        \end{subfigure}
        \caption{Set of scatter plots comparing the different CNF-izations on the circuits benchmarks. The first and second rows compare them in terms of number of models and execution time, respectively. All the axes are on a logarithmic scale. In these problems, the \TseitinCNF{}, \PlaistedCNF{} and $\NNFna{}+\PlaistedCNF{}$ reported 49, 44 and 27 timeouts, respectively, represented by the points on the dashed lines.}%
        \label{fig:plt:circ:scatter}
    % \end{subfigure}
    % \begin{subfigure}[t]{\textwidth}
    %     \centering
    %     \includegraphics[width=0.4\textwidth]{plots/circ/enum_time_ecdf.pdf}%
    %     \caption{CDF of the time taken to compute AllSAT using the different CNF-izations The $y$-axis reports the number of instances for which the enumeration finished within the cumulative time on the $x$-axis.}%
    %     \label{fig:plt:circ:time:ecdf}
    % \end{subfigure}
    % \caption{Results on the circuits benchmarks. \cref{fig:plt:circ:scatter} compares the number of models and the execution time of the different CNF transformations. \cref{fig:plt:circ:time:ecdf} compares the execution times through an CDF.}%
    % \label{fig:plt:circ}
\end{figure}
\cref{fig:plt:circ:scatter} shows the performance of the different CNF-izations in the circuits benchmarks. The timeouts are represented by the points on the dashed lines. First, we notice that \TseitinCNF{} and \PlaistedCNF{} have very similar behaviour, both in terms of execution time and number of models. The reason is that in circuits, it is typical to have a lot of sharing of sub-formulas. Since we constrain the outputs to be 0 or 1 at random~\cite{tibebu_augmenting_2018}, most of the sub-formulas occur with double polarity, so that the two encodings are very similar, if not identical. Second, we notice that by converting the formula into NNF before applying \PlaistedCNF{} the enumeration is much more effective, as a much smaller number of models is enumerated, with only a few outliers. 
%This can be due to the fact that the enumerated \TA{}  is \emph{minimal} and not \emph{minimum}, and its size can be affected also by the order in which the assignments are found.
%We also notice that a smaller number of models does not always correspond to a shorter execution time. 
The fact that for some instances $\NNFna{}+\PlaistedCNF{}$ takes a little more time can be caused by the fact that it can produce a formula that is up to twice as large and contains up to twice as many label atoms as the other two encodings, increasing the time to find the assignments. Notice also that, even enumerating a smaller number of models at a price of a small time-overhead can be beneficial in many applications, for instance in WMI~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallitta_smt-based_2022}. 


\subsubsection*{The WMI benchmarks}

\begin{figure}
    \centering
    % \begin{subfigure}[t]{\textwidth}
        
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/models_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:wmi:models:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/models_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:wmi:models:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/models_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:wmi:models:lab_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/time_compare_LAB_vs_LABELNEG_POL.pdf}%
            \label{fig:plt:wmi:time:lab_vs_pol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/time_compare_LABELNEG_POL_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:wmi:time:pol_vs_nnfpol}
        \end{subfigure}
        \begin{subfigure}[t]{0.32\textwidth}
            \includegraphics[width=\textwidth]{plots/wmi/time_compare_LAB_vs_NNF_MUTEX_POL.pdf}%
            \label{fig:plt:wmi:time:lab_vs_nnfpol}
        \end{subfigure}
        \caption{Set of scatter plots comparing the different CNF-izations on the WMI benchmarks. The first and second rows compare them in terms of number of models and execution time, respectively. All the axes are on a logarithmic scale. In these problems, there were no timeouts.}%
    \label{fig:plt:wmi:scatter}
    % \end{subfigure}
    % \begin{subfigure}[t]{\textwidth}
    %     \centering
    %     \includegraphics[width=0.4\textwidth]{plots/wmi/enum_time_ecdf.pdf}%
    %     \caption{CDF of the time taken to compute AllSAT using the different CNF transformations. The $y$-axis reports the number of instances for which the enumeration finished within the cumulative time on the $x$-axis.}%
    %     \label{fig:plt:wmi:time:ecdf}
    % \end{subfigure}
    % \caption{Results on the WMI benchmarks. \cref{fig:plt:wmi:scatter} compares the number of models and the execution time of the different CNF transformations. \cref{fig:plt:wmi:time:ecdf} compares the execution times through an CDF.}%
    % \label{fig:plt:wmi}

\end{figure}

The plots in~\cref{fig:plt:wmi:scatter} compare the different CNF-izations in the WMI benchmarks in terms of number of models and time. All the problems were solved for all the encodings within the timeout. In these benchmarks, most of the sub-formulas occur with double polarity, so that \TseitinCNF{} and \PlaistedCNF{} encodings are almost identical, and they obtain very similar results in both metrics. The advantage is significant, instead, if the formula is converted into NNF upfront, since by using $\NNFna{}+\PlaistedCNF{}$ the solver enumerates a smaller number of models. 
In this application, it is crucial to enumerate as few models as possible, since for each model an integral must be computed, which is a very expensive operation~\cite{morettin-wmi-ijcar17,morettin-wmi-aij19,spallitta_smt-based_2022}.

\subsection{Comparing the CNF encodings for SAT solving}
\label{sec:experiments:sat}
In order to confirm the statement in~\cref{rem:ex3:preconv}, in the CDFs in~\cref{fig:sat:ecdf} we compare the different CNF encodings for \emph{plain SAT solving} on the same benchmarks.
Even though these problems are very small for plain solving and SAT solvers deal with them very efficiently, we can see that converting the formula into NNF before applying \PlaistedCNF{} brings no advantage, and solving is uniformly slower than with \PlaistedCNF{} or \TseitinCNF{}.
This shows that our novel technique works specifically for enumeration but not for solving, as expected. 

\begin{figure}[t]
\centering
\captionsetup[subfigure]{justification=centering}
\begin{subfigure}[b]{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{plots/syn/sat_time_ecdf.pdf}
\caption{Synthetic benchmarks}
\label{fig:sat:syn:ecdf}
\end{subfigure}
\begin{subfigure}[b]{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{plots/circ/sat_time_ecdf.pdf}
\caption{Circuit benchmarks}
\label{fig:sat:circ:ecdf}
\end{subfigure}
\begin{subfigure}[b]{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{plots/wmi/sat_time_ecdf.pdf}
\caption{WMI benchmarks}
\label{fig:sat:wmi:ecdf}
\end{subfigure}
\caption{CDF of the time taken for plain SAT solving using the different CNF transformations. The $y$-axis reports the instances for which the enumeration finished within the cumulative time on the $x$-axis.}
\label{fig:sat:ecdf}
\end{figure}

