This section introduces the notation and the theoretical background necessary to understand what is presented in this paper. We recall the standard syntax, semantics, and results of propositional logic, and the fundamental ideas behind SAT enumeration and projected enumeration implemented by modern AllSAT solvers.


\subsection{Propositional Logic}%
\label{sec:background:propositional-logic}
In this section, we summarize some basic definitions and results of
propositional logic.


\paragraph*{Notation and Terminology}
In the paper, we adopt the following conventions. We refer to propositional atoms with capital letters, such as $A$ and $B$. Propositional formulas are referred to with Greek letters such as $\vi, \psi$. Total truth assignments are denoted by $\eta$, while partial truth assignments are denoted by $\mu$.
The symbols $\allA\defas\set{A_1, \dots, A_N }$ and
$\allB\defas\set{B_1, \dots, B_K}$ denote disjoint sets of
propositional atoms. We denote Boolean constants by
$\B\defas\set{\top, \bot}$.

% \begin{definition}
    A \emph{propositional formula} $\vi$ can be defined recursively as follows. The Boolean constants $\top$ and $\bot$ are formulas; a Boolean atom $A$ and its negation $\neg A$ are formulas, also referred to as \emph{literals}; a connection of two formulas $\vi$ and $\psi$ by one of the connectors $\wedge, \vee, \imp, \iff$ is a formula. A sub-formula occurs with \emph{positive} \resp{\emph{negative}} \emph{polarity} (also \emph{positively} \resp{\emph{negatively}}) if it occurs under an even \resp{odd} number of nested negations. Specifically, $\vi$ occurs positively in $\vi$; if $\neg\vi_1$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} in $\vi$; if $\vi_1\wedge \vi_2$ or $\vi_1\vee\vi_2$ occur positively \resp{negatively} in $\vi$, then $\vi_1$ and $\vi_2$ occur positively \resp{negatively} in $\vi$; if $\vi_1\imp\vi_2$ occurs positively \resp{negatively} in $\vi$, then $\vi_1$ occurs negatively \resp{positively} and $\vi_2$ occurs positively \resp{negatively} in $\vi$; if $\vi_1\iff\vi_2$ occurs in $\vi$,
    then $\vi_1$ and $\vi_2$ occur both positively and negatively in $\vi$.
% \end{definition}
% \begin{definition}

    \paragraph*{Negation Normal Form}
    \begin{rschange}
    A Boolean formula is in \emph{Negation Normal Form (NNF)} iff it
    is given only by the recursive applications of $\wedge$ and $\vee$
    to literals.
    \ignoreinshort{An NNF formula can be conveniently represented as a  Directed Acyclic Graph (DAG)
    ---that is, as a single-root and/or DAG with literals as leaves.}
    \ignoreinshort{We call the {\em size} of an NNF DAG the sum of the numbers of
    its nodes and arcs.}
% \end{definition}
A formula can be converted into NNF by recursively rewriting
implications $(\alpha\imp\beta)$ as $(\neg\alpha\vee\beta)$ and 
equivalences $(\alpha\iff\beta)$ as
$(\neg\alpha\vee\beta)\wedge(\alpha\vee\neg\beta)$, and then by recursively
``pushing down'' the negations: $\neg(\alpha\vee\beta)$ as
$(\neg\alpha\wedge\neg\beta)$, $\neg(\alpha\wedge\beta)$ as
$(\neg\alpha\vee\neg\beta)$ and $\neg\neg\alpha$ as $\alpha$.
\ignoreinlong{
If the NNF formula is represented as a DAG,
%{---that is, as a single-root and/or DAG with literals as leaves---}
then its size is linear w.r.t.\ the original one.
(Although this fact is well-known,
% we could not to find a formal proof
%     of it in the literature; hence,
    we provide a formal proof in the
    extended version of this paper~\cite{masina_cnf_2023}.)
%
% \footnote{
% %    \begin{gmchange}
%     In fact, such NNF DAG is a sub-graph of the 2-root NNF DAG for the
%     pair $\langle\NNF{\vi},\NNF{\neg\vi}\rangle$, and it is
%     straightforward to prove that the latter grows linearly w.r.t.\
%     the size of $\vi$ by reasoning inductively on the structure of the
%     formula \vi: if $\vi\defas(\vi_1\bowtie\vi_2)$ s.t.\ $\bowtie~\in\set{\wedge,\vee,\imp,\limp,\iff}$, then
%     $|\langle \NNF{\vi},\NNF{\neg\vi}\rangle| \leq
%          18+|\langle \NNF{\vi_1},\NNF{\neg\vi_1}\rangle|+|\langle \NNF{\vi_2},\NNF{\neg\vi_2}\rangle|$, where ``|\dots|'' is \#nodes(\dots)+\#arcs(\dots).
%     \\E.g., if $\bowtie$ is ``$\iff$'', then the DAGs for $\NNF{\vi}$ and $\NNF{\neg\vi}$ share the
%     sub-DAGs for
%     $\NNF{\vi_1},\NNF{\neg\vi_1},\NNF{\vi_2},\NNF{\neg\vi_2}$, adding
%     3+3 ``$\wedge$''/``$\vee$'' nodes and $6+6$ arcs:\\
%     % \begin{itemize}
%         % \item 
%         $
%         \begin{aligned}
%             \quad\NNF{\pos\phantom{(}\vi_1\iff\vi_2\phantom{)}}\defas(\NNF{\neg\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\pos\vi_1}\vee \NNF{\neg\vi_2});\\
%             \quad\NNF{\neg(\vi_1\iff\vi_2)}\defas(\NNF{\pos\vi_1}\vee\NNF{\pos\vi_2})\wedge(\NNF{\neg\vi_1}\vee\NNF{\neg\vi_2}).            
%         \end{aligned}
%         $\\
%         % \item 
%     % \end{itemize}
%     Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of $\vi$,
%     representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and negative
%     occurrences of $\vi_i$ respectively. These nodes are shared among up
%     to exponentially-many branches generated by expanding the nested iffs.
% %    \end{gmchange}
% }
}
\ignoreinshort{%
  We have the following fact.\\
    \begin{gmchange}
    \begin{property}%
        \label{th:nnfdaglinear}
        Let \vi{} be a Boolean formula and \NNF{\vi} be the NNF
        formula resulting from converting \vi{} into NNF as described
        above. 
        If $\NNF{\vi}$ is represented as a DAG,  then its size is linear w.r.t.\ the original one.
    \end{property}
    (Although this fact is well-known,
    % we failed to find a formal proof
    % in the literature. Hence,
    we provide a formal proof in~\cref{sec:proofnnfdaglinear}.)
    \end{gmchange}
  }
    Intuitively, we only need at most 2 nodes for each sub-formula $\vi_i$ of $\vi$,
    representing $\NNF{\vi_i}$ and $\NNF{\neg\vi_i}$ for positive and negative
    occurrences of $\vi_i$ respectively. These nodes are shared among up
    to exponentially-many branches generated by expanding the nested iffs.      
    \end{rschange}
  

\paragraph*{CNF Transformations}%
\label{sec:bg:cnf}

A Boolean formula is in \emph{Conjunctive Normal Form (CNF)} iff it is a conjunction $(\wedge)$ of clauses, where a clause is a disjunction $(\vee)$ of literals. 
% \end{definition}
Numerous CNF transformation procedures, commonly referred to as CNF-izations, have been proposed in the literature. In the next paragraph, we summarize the three most frequently employed techniques.

The \emph{Classic CNF-ization} (\DeMorganCNF{}) converts any propositional formula into a logically equivalent formula in CNF by applying DeMorgan's rules. First, it converts the formula into NNF.\@ Second, it recursively rewrites sub-formulas $\alpha\vee(\beta\wedge\gamma)$ as $(\alpha\vee\beta)\wedge(\alpha\vee\gamma)$ to distribute $\vee$ over $\wedge$, until the formula is in CNF.\@ The principal limitation of this transformation lies in the possible exponential growth of the resulting formula compared to the original (e.g.\ when the formula is in DNF), making it unsuitable for modern SAT solvers~\cite{biere_handbook_2021}.

The \emph{Tseitin CNF-ization} (\TseitinCNF{})~\cite{tseitin68} avoids this exponential blow-up by labelling each sub-formula $\vi_i$ with a fresh Boolean atom $B_i$, which is used as a placeholder for the sub-formula. Specifically, it consists in applying recursively bottom-up the rewriting rule $\vi\Longrightarrow\vi[\vi_i|B_i] \wedge \DeMorganCNF(B_i\iff\vi_i)$ until the resulting formula is in CNF, where $\vi[\vi_i|B_i]$ is the formula obtained by substituting in $\vi$ every occurrence of $\vi_i$ with $B_i$. 

The \emph{Plaisted and Greenbaum CNF-ization} (\PlaistedCNF{})~\cite{plaisted1986structure} is a variant of the \TseitinCNF{} that exploits the polarity of sub-formulas to reduce the number of clauses of the final formula. Specifically, if a sub-formula $\vi_i$ appears only with positive \resp{negative} polarity, then it can be labelled with a single implication as $\DeMorganCNF(B_i\imp\vi_i)$ \resp{$\DeMorganCNF(B_i\limp\vi_i)$}.

With both \TseitinCNF{} and \PlaistedCNF{}, due to the introduction of the label variables, the final formula does not preserve the equivalence with the original formula but only the equisatisfiability.
Moreover, they also have a stronger property. 
If $\vi(\allA)$ is a non-CNF formula and $\vicnf(\allA\cup\allB)$ is either the \TseitinCNF{} or the \PlaistedCNF{} encoding of $\vi$, where $\allB$ are the fresh Boolean atoms introduced by the transformation, then $\vi(\allA)\equiv\exists\allB.\vicnf(\allA\cup\allB)$.

\paragraph*{Total and partial truth assignments}
% \begin{definition}
    Given a set of Boolean atoms $\allA$, a \emph{total truth assignment} is a total map $\eta: \allA\longmapsto\B$. 
    A \emph{partial truth assignment} is a partial map $\mu: \allA\longmapsto\B$.  
% \end{definition}
Notice that a partial truth assignment represents $2^K$ total truth assignments, where $K$ is the number of unassigned variables by $\mu$.
With a little abuse of notation, we sometimes represent a truth assignment either as a set, s.t.\ $\mu\defas\set{A\ |\ \mu(A)=\top}\cup\set{\neg A\ |\ \mu(A)=\bot}$, or as a cube, s.t.\ $\mu\defas\bigwedge_{\mu(A)=\top}{A}\wedge\bigwedge_{\mu(A)=\bot}{\neg A}$.
If $\mu_1\subseteq\mu_2$ \resp{$\mu_1\subset\mu_2$} we say that $\mu_1$ is a \emph{sub-assignment} \resp{\emph{strict sub-assignment}} of $\mu_2$ and that $\mu_2$ is a \emph{super-assignment} \resp{\emph{strict super-assignment}} of $\mu_1$.
We denote with $\residual{\vi}{\mu}$ the \emph{residual of $\vi$ under $\mu$}, i.e.\ the formula obtained by substituting in $\vi$ each $A_i\in\allA$ with $\mu(A_i)$, and by recursively applying the standard propagation rules of truth values through Boolean operators.

% \begin{definition}
Given a set of Boolean atoms $\allA$ and a formula $\vi(\allA)$, we say that a \emph{[partial or total] truth assignment $\mu:\allA\longmapsto\B$ satisfies} $\vi$, denoted as $\mu\models\vi$, iff $\residual{\vi}{\mu}=\top$\footnote{
    The definition of satisfiability by partial assignment may present some ambiguities for non-CNF and existentially-quantified formulas~\cite{sebastiani_are_2020,mohle_four_2020}. Here we adopt the above definition because it is the easiest to implement, and it is the one typically used by state-of-the-art SAT solvers. {We refer to~\cite{sebastiani_are_2020,mohle_four_2020} for details.}
}. If $\mu\models\vi$, then we say that $\mu$ is a \emph{model} of $\vi$.
% \end{definition}
% \footnote{
 %}
A partial truth assignment $\mu$ is \emph{minimal} for $\vi$ iff $\mu\models\vi$ and every strict sub-assignment $\mu{}'\subset\mu$ is such that $\mu{}'\not\models\vi$.\\ 
Most of the modern SAT and SMT solvers do not deal directly with non-CNF formulas, rather they convert them into CNF by using either \TseitinCNF{} or \PlaistedCNF{}. As seen in the previous paragraph, since these transformations introduce fresh atoms into the resulting formulas, a model of $\vi(\allA)$ can be found as a truth assignment satisfying $\exists\allB.\vicnf(\allA\cup\allB)$.
% \begin{definition}
    Given two disjoint sets of Boolean atoms $\allA, \allB$ and a CNF formula $\vicnf(\allA\cup\allB)$, we say that a \emph{[partial or total] truth assignment $\muA:\allA\longmapsto\B$ satisfies} $\exists\allB.\vicnf$ iff there exists a total truth assignment $\etaB:\allB\longmapsto\B$ such that $\muA\cup\etaB: \allA\cup\allB\longmapsto\B$ satisfies $\vicnf$.
% \end{definition}

\ignoreinshort{
\begin{gmchange}
We have the following fact, for which we provide a complete proof  in~\cref{sec:proofmuAnnf}.
\begin{property}%
    \label{th:muAnnf}
    Consider a Boolean formula $\vi(\allA)$, and let $\NNF{\vi}$ be its NNF DAG. 
    Consider a partial assignment $\muA$ on $\allA$. Then
    $\residual{\vi}{\muA}=v$ iff $\residual{\NNF{\vi}}{\muA}=v$, for
    $v\in\set{\top,\bot}$.
    % , where $\any$ represents the case in which the residual is neither $\top$ nor $\bot$.
\end{property}
\end{gmchange}
}

% \RSNOTE{@Gabriele: nota che qui ho tolto la parte relativa a ``\any'',
%   perche' non l'abbiamo definita chiaramente, e perche' e' inutile, in
% quanto deriva dal fatto che la propriet√† e' in ``iff''.}
% GM: Ok

% The work of this paper focuses on the following result from~\cite{sebastiani_are_2020}.
% \begin{lemma}%
%     \label{lemma:noncnf-sat}
%     Let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA\cup\allB)$ be the result of applying either the \TseitinCNF{} or the \PlaistedCNF{} transformation to $\vi$.\\
%     Given a total truth assignment $\etaA:\allA\longmapsto\B$, then  $\etaA\models\vi$ iff $\etaA\models\exists\allB.\vicnf$. However, given a partial truth assignment $\muA:\allA\longmapsto\B$, then  $\muA\models\vi$ if $\muA\models\exists\allB.\vicnf$, but the reverse implication does not hold. 
% \end{lemma}
% \GMNOTE{Dobbiamo dimostrarlo per Plaisted?}

\subsection{AllSAT and Projected AllSAT}%
\label{sec:background:allsat}
AllSAT is the task of enumerating all the models of a propositional formula. In this paper, we focus on the enumeration of disjoint models, that is, pairwise mutually-inconsistent models.
% \begin{definition}
    Given a Boolean formula $\vi$, we denote with $\TTA{\vi}\defas\set{\eta_1,\dots,\eta_j\dots\eta_M}$ the set of all total truth assignments satisfying $\vi$.
% \end{definition}
% \begin{definition}
   We denote with $\TA{\vi}\defas\set{\mu_1,\dots,\mu_i\dots,\mu_N}$ a set of partial truth assignments satisfying $\vi$ s.t.:
    \begin{alphaenumerate}
        \item every $\eta\in\TTA{\vi}$ is a super-assignment of some $\mu\in\TA{\vi}$;
        \item every pair $\mu_i,\mu_j\in\TA{\vi}$ assigns opposite truth value to at least one atom.
    \end{alphaenumerate}
% \end{definition}
Notice that, whereas $\TTA{\vi}$ is unique, multiple $\TA{\vi}$s are admissible for the same formula $\vi$, including $\TTA{\vi}$. AllSAT is the task of enumerating either $\TTA{\vi}$ or a set $\TA{\vi}$. Typically, AllSAT solvers aim at enumerating a set $\TA{\vi}$ as small as possible, since every partial model prevents from enumerating a number of total models that is exponential w.r.t.\ the number of unassigned atoms, so that to save computational space and time.

%\mathsat{}~\cite{mathsat5_tacas13}, the SAT/SMT solver that we used for our experiments.\GMSIDENOTE{Riscrivere non riferendosi solo a mathsat}
The enumeration of a $\TA{\vi}$ for a non-CNF formula $\vi$ is typically implemented by first converting it into CNF, and then enumerating its models by means of \emph{Projected AllSAT}.
Specifically, let $\vi(\allA)$ be a non-CNF formula and let $\vicnf(\allA\cup\allB)$ be the result of applying either \TseitinCNF{} or \PlaistedCNF{} to $\vi$, where $\allB$ is the set of Boolean atoms introduced by either transformation. $\TA{\vi}$ is enumerated via Projected AllSAT as $\TA{\exists\allB.\vicnf}$, i.e.\ as a set of (partial) truth assignments over $\allA$ that can be extended to total models of $\vicnf$ over $\allA\cup\allB$. %, as a consequence of \cref{lemma:noncnf-sat}. 
We refer to the general schema described in~\cite{hutchison_smt_2006}, which we briefly recap here.\\
Let $\vicnf(\allA\cup\allB)$ be a CNF formula over two disjoint sets
of Boolean variables $\allA, \allB$, where $\allA$ is a set of
\emph{relevant atoms} s.t.\ we want to enumerate a
$\TA{\exists\allB.\vicnf}$.
%\begin{rschange}
The solver enumerates one-by-one partial
truth assignments $\mu_1,\dots,\mu_i,\dots\mu_N$, where each
  $\mu_i\defas\muA_i\cup\etaB_i$ is s.t.:
\begin{romanenumerate}
    \item\label{item:mumodelsvi} (\emph{satisfiability}) $\mu_i\models\vicnf$;
    \item\label{item:musdisjoint} (\emph{disjointness}) for each
      $j<i$, $\muA_i,\muA_j$ assign opposite truth values to some atom in $\allA$;
    \item\label{item:muAminimal} (\emph{minimality}) $\muA_i$ is \emph{minimal}, meaning that no literal can be dropped from it without losing properties~(\ref{item:mumodelsvi}) and~(\ref{item:musdisjoint}).  
\end{romanenumerate}
A basic disjoint AllSAT procedure (implemented e.g. in
\mathsat{}~\cite{mathsat5_tacas13}) works as follows. At each step $i$, it finds a total truth 
assignment $\eta_i\defas\etaA_i\cup\etaB_i$ s.t.\
$\eta_i\models\psi_i$, where $\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$,
and then invokes a minimization procedure on $\etaA_i$ to compute a
partial truth assignment $\muA_i$ satisfying
properties~\eqref{item:mumodelsvi},~\eqref{item:musdisjoint}
and~\eqref{item:muAminimal}.
{{Then, the solver adds the clause $\neg\muA_i$ to
    ensure
    property~\eqref{item:musdisjoint} and it continues the search.}} This process is iterated
until 
{%the formula 
    $\psi_{N+1}$
}is found to be unsatisfiable for some $N$, and the set $\set{\muA_i}_{i=1}^N$ is returned.  

The minimization procedure consists in iteratively dropping literals one-by-one from $\etaA_i$, checking if it still satisfies the
formula. The outline of
  this minimization procedure is shown in \cref{alg:minimize}.
  Each minimization step is
$O(\#\mathit{clauses}\cdot\#\mathit{vars})$. 


\begin{algorithm}[t]
\begin{algorithmic}[1]
%\begin{rschange}
    \caption[A]{{\sc Minimize-Assignment}($\psi_i, \eta_i, \allA$)\hfill //
      $\psi_i\defas\psi\wedge\bigwedge_{j=1}^{i-1}\neg\muA_j$, \quad $\eta_i = \etaA_i \cup \etaB_i$
      \label{alg:minimize}}
    \STATE $\muA_i \leftarrow \etaA_i$
    \FOR{$\ell\in\muA_i$}
        \IF{$\psi_i|_{[\muA_i\setminus\set{\ell}\ \cup\ \etaB_i]} = \top$}
            \STATE $\muA_i \leftarrow \muA_i \setminus \set{\ell}$
        \ENDIF
    \ENDFOR
    \RETURN $\muA_i$
%\end{rschange}
  \end{algorithmic}
\end{algorithm}


Notice that, since we are in the context of {\em projected} AllSAT,
the minimization
algorithm only minimizes the relevant variables in $\allA$, 
%although 
and the
truth value of existentially quantified variables in $\allB$ is still
used to check the satisfiability of the formula by the current partial
assignment. Moreover, to enforce the pairwise disjointness between the
assignments, $\psi_i$ in \cref{alg:minimize} refers to the original
formula conjoined with all current blocking clauses $\bigwedge_{j=1}^{i-1}\neg\muA_j$, whereas conflict
clauses are excluded by the minimization, being redundant.  

We stress the fact that the work described in this paper is agnostic
w.r.t.\  the disjoint AllSAT procedure used, provided its output assignments match conditions~\eqref{item:mumodelsvi}-\eqref{item:muAminimal} above. 

%\end{rschange}

