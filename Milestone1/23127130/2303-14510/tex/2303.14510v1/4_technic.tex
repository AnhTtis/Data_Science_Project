\section{The TMKU Algorithm} \label{sec:algorithm}

The targeted mining of top-$k$ HUIs algorithm, abbreviated as TMKU, is presented at length in this section. Figure \ref{img1} is the framework diagram of the proposed TMKU algorithm, showing the basic steps of the whole algorithm. TMKU uses a trie structure as storage method similar to the TargetUM algorithm, and then utilizes the idea of filtering to dynamically change $\eta$ (the utility threshold) to select the desired top-$k$ THUIs. The TMKU algorithm enables a wide range of applications by adjusting the target pattern and $k$ to query different targets and the number of result itemsets in a short period of time. After presenting these concepts, we will explain how search space pruning is conducted as well as the processes of the TMKU algorithm in detail.

\begin{figure}
	\centering
	\includegraphics[scale=0.35]{pics/framework.pdf} 
	\caption{The framework of TMKU}
	\label{img1} 
\end{figure}


\subsection{Constructing the TP-tree and query mechanism}

For data analysis, the database must be scanned to process the information and obtain patterns that meet the user's requirements. When using the target-pattern tree as a data structure, the algorithm uses nodes to represent itemsets, and the pattern tree can be updated incrementally by inserting new nodes.

MEIT \cite{fournier2013meit} is an early study about this problem. It uses a compact node-compression mechanism to store information about transactions and answer queries about target itemsets, but it is not designed for utility mining. Later, the TargetUM algorithm was proposed for HUIM. The algorithm uses a trie tree to store HUIs from the whole database, and this was shown to reduce memory consumption. Therefore, the algorithm proposed in this paper also adopts the trie structure, which can reduce the overhead time for queries by using the common prefix of strings to improve efficiency. Then, after identifying all HUIs containing the target item or itemset, a map structure (TopKMap) is built to store the discovered target itemsets. The algorithm takes the utility value of the $k$-th itemset as the initial threshold, and constantly updates the TopKMap w.r.t. the minimum threshold until the top-$k$ target HUIs are discovered.

\begin{definition}
	\rm (Target pattern tree). There are seven elements describing each node in this tree. For a node $n$ (\textit{name}), its parent node (\textit{parent}) is recorded. In addition, the transaction weighted utilization (\textit{twu}), \textit{sumIu} which records the utility of the itemsets represented by the current node, and \textit{sumRu} which records the remaining utility of the itemsets as the current node, are the three elements related to the utility. When $n$ is the last item of a HUI, one variable (\textit{isEnd}) is set to true. If not, \textit{isEnd} is set to false. The last element indicates the link to the next node (\textit{link}) containing the same item.
\end{definition}

\begin{definition}
	\rm (Item header table). Each item has its own item header table. There is also a pointer to the first linked node corresponding to each item in the TP-tree. This table is useful for quickly locating the position of the item nodes.	
\end{definition}

When the initial HUI \{$f$, $c$, $d$\} is found, the node $f$ is first added into this tree since it has the smallest \textit{TWU} value. Moreover, the element information of $f$ is recorded. Then, the algorithm creates the item header table of the $f$ node. The other nodes are then inserted in the same way. However, each time a node is inserted, the algorithm needs to verify whether a node with the same name already exists. If it already exists, the node is not created again. But the inserted itemset will share a common prefix with the already existing node item. When the second HUI \{$f$, $c$, $d$, $b$\} is inserted into the TP-tree, it shares the prefix ($f$, $c$, $d$) with the first HUI \{$f$, $c$, $d$\}. Then, node $b$ is created, and its information is recorded to update the item header table. Furthermore, the update of the item header table for item $b$ requires linking the new node. Subsequently, the last $b$ becomes the updated trailing node. Other HUIs that are stored in the TP-tree must also be inserted using the same process until the construction of the TP-tree is finished. The construction of the TP-tree is illustrated in Figure \ref{img2}.

\begin{figure}
	\centering
	\includegraphics[scale=0.35]{pics/tptree.pdf} 
	\caption{The construction of TP-tree}
	\label{img2} 
\end{figure}


\subsection{Targeted utility raising strategy}

As mentioned before, if only the value of $k$ is set by the user, the task of top-$k$ HUIM is to find out the top-$k$ HUIs. Since the utility threshold is not given by the user, effective utility raising strategies need to be proposed to efficiently find the top-$k$ HUIs. In this paper, the TMKU algorithm adopts two strategies (SUR and RIU) to achieve this goal.

\begin{strategy}
	\label{sur}
	\rm (SUR strategy). The SUR strategy \cite{zhang2021tkus} is a classic threshold raising strategy, used by the TMKU algorithm when storing the results in the TopKMap. The TopKMap can store $k$ items and their utility values dynamically. 
\end{strategy}

At first, the TopKMap is empty, and then when each THUI is found, the designed TMKU algorithm needs to consider whether to add it to the TopKMap or not. If the utility value of THUI is greater than $\eta$, it can be included in the TopKMap. However, when the number of itemsets stored in the TopKMap is greater than the $k$ value set by the user, some itemsets in the TopKMap need to be gradually deleted and updated. Those itemsets with low utility values will be replaced by itemsets with high utility values.

\begin{strategy}
	\label{riu}
	\rm (RIU strategy). The RIU raising strategy \cite{tseng2015efficient} is primarily based on the real utilities of items. If the number of THUIs is more than $k$ and the $k$-th highest utility value after sorting HUIs is still higher than $\eta$, the value of $\eta$ should be changed to the $k$-th highest value.
\end{strategy}

The RIU threshold raising strategy plays an integral role in the TMKU algorithm. The true utility of each item can be identified by scanning THUIs. To raise the utility threshold more quickly, TMKU uses the true utility of the first item as the reference value for $\eta$. Finally, combining with the SUR strategy, the correct top-$k$ THUIs can be quickly mined.

\subsection{Pruning strategies}

The TP-tree and item header table have been presented, which speeds up processing. Furthermore, some utility threshold-raising strategies are also adopted into the TMKU algorithm, which were listed in the previous subsection. Some pruning strategies used in TMKU are introduced in this subsection. They allow the algorithm to considerably reduce the search space and time.

\begin{strategy}
	\label{lab:one}
	\rm If the sum of utilities of $X_i$ $<$ $\xi$, then $X_i$ is not a THUI.	
\end{strategy}

It was shown in prior work that if \textit{TWU($X_i$)} < $\xi$, $u(X_i)$ is also less than the threshold since $u(X_i)$ must be smaller than \textit{TWU($X_i$)}. Therefore, it is not necessary to check any itemsets containing $X_i$. The utility and remaining utility of each item are recorded in its utility-list. If the sum of the utilities of $X_i$ (\textit{sumIu}) is smaller than $\xi$ defined by the user, then $X_i$ is not the HUI that we are looking for. Conversely, it is a HUI. Moreover, the utility-list also records the sum of the remaining utilities called \textit{sumRu}, which can be cleverly used to prune these utility values to improve search efficiency.

\begin{strategy}
	\label{lab:two}
	\rm In the TMKU algorithm, let $X^\prime$ and $\xi$ be the candidate and current minimum utility value, respectively. Suppose that the sum of \textit{sumIu} and \textit{sumRu} of $X^\prime$ is smaller than $\xi$. Then the supersets and extended itemsets of $X^\prime$ do not need to be checked.
\end{strategy}

In other words, the sum of \textit{sumIu} and \textit{sumRu} respects the downward closure property. Therefore, no extension representing $X^\prime$ can be the required top-$k$ THUI. This pruning strategy can prevent exploring several itemsets. It is worth noting that if the sum of \textit{sumIu} and \textit{sumRu} of $X^\prime$ is greater than $\xi$, then the extension of $X^\prime$ is a potential HUI and a further check is needed.

In addition, we can find that more and more branches may be generated during the construction of the TP-tree. However, the task is to discover all the top-$k$ HUIs that contain a target itemset, so not all high-utility itemsets must be searched. The TMKU algorithm needs to determine if the target itemset is included before inserting a node to reduce the running time. Therefore, TMKU uses the item header table to cut off the useless branches in advance and correctly and quickly identify the high-utility itemsets containing the target pattern. Then, we can use the item header table to quickly find the nodes in the target pattern tree.

\begin{strategy}
	\label{lab:three}
	\rm When $T^\prime$ is set as the target pattern, the TMKU algorithm sorts these items of the target itemset in \textit{TWU} ascending order. At this point, the item $i$ with the largest \textit{TWU} value is selected, and the position of $i$ in the TP-tree and its branches is determined using the item header table. A bottom-up approach is used to query whether this HUI contains the target pattern. When determining whether item $j$ in the target pattern is in the branch, we can compare the \textit{TWU} of the current node with the value of $\textit{TWU}(j)$. If the current node's \textit{TWU} is smaller than $\textit{TWU}(j)$, the branch does not contain the target pattern and can be discarded directly. If the current node's \textit{TWU} is greater than $\textit{TWU}(j)$, further exploration is required. If equal, it is also necessary to check whether the current node's node name is $j$ to avoid replacing the same \textit{TWU} value items.
\end{strategy}

For example, supposing that \{$f$, $c$, $d$, $b$\} is a HUI, and \{$a$, $b$\} is denoted as $T^\prime$. First, we find that item $b$ whose \textit{TWU} is the highest in the target pattern. Then, we need to continue checking whether $a$ is in the HUI, and then compare the \textit{TWU} values of other items in the HUI with the \textit{TWU} of $a$ in turn. It is found that the \textit{TWU} of both $d$ and $c$ is greater than $a$, but the \textit{TWU} of $f$ is less than $a$. According to the above analysis, it is known that \{$a$, $b$\} is not in the HUI and the search is stopped.

\subsection{Proposed algorithm}

The TMKU task will be summarized as follows, based on the above introduction. To discover those itemsets containing the target itemset, Algorithm \ref{algo:THUI} focuses on accomplishing this task by constructing the TP-tree and the item header table. Algorithm \ref{algo:TMKU} introduces how to search the TP-tree to find the THUIs followed by mining the top-$k$ itemsets, and through some utility threshold raising strategies, users can get the desired results as soon as possible.

%%%%%%%%%%%%%%%%%   Construct TP-tree procedure   %%%%%%%%%%%%%%%%%%%
\begin{algorithm}[h]
	\small
	\caption{The construction procedure}
	\label{algo:THUI}
	\LinesNumbered
		\KwIn{$X^\prime$: the prefix of HUI; \textit{IUs}: the utility-list of $X^\prime$; \textit{RUs}: the remaining utility-list of $X^\prime$; \textit{TUs}: the \textit{TWU} list of $X^\prime$; $x$: the last item of HUI; $\alpha$: the utility of $x$; $\beta$: the remaining utility of $x$; $\theta$: the \textit{TWU} of $x$; \textit{mapItemNode} store the header node of each item-header table; \textit{mapItemLastNode}: store the tail nodes of each item-header table; $\xi$: the target utility threshold.}
		\KwOut{\textit{TP-tree}; item header table.}
		
        initialize \textit{TP-tree}, \textit{currentNode} = \textit{null}, \textit{parentNode} = \textit{null}, \textit{listNodes} = \textit{root.childs}\;
        insert a HUI into the TP-tree\;
        \For{\rm each item $e$ $\in$ $X^\prime$}{
           search the position of $e$\;
           \If{\textit{currentNode} == \textit{null}}{
            create a new node in the TP-tree and construct item header table of $e$;
       }
       update \textit{parentNode}, \textit{listNodes}\;
      }
      \textit{currentNode} = $x$\;
      \eIf{\textit{currentNode} != \textit{null}}{
      {update} \textit{currentNode.sumIu}, \textit{currentNode.sumRu}, \textit{currentNode.TWU}\;
  }{ 
    construct new item header table of $x$\;
}
\textit{currentNode.isEnd} = \textit{true};
\end{algorithm}

%%%%%%%%%%%%%%%%%%   TMKU procedure  %%%%%%%%%%%%%%%%%%%

\begin{algorithm}[h]
	\small
	\caption{The discovery procedure}
    \label{algo:TMKU}
	\LinesNumbered
	\KwIn{$k$: the number of THUIs; $T^\prime$: the itemset obtain target; $\xi$: the target utility threshold; $\eta$: the minimum utility threshold.}
	\KwOut{top-$k$ THUIs.}  
	
	\textit{posToMatch} = |$T^\prime$|, \textit{node} = the target item of last item\;
	\While{\textit{node} != \textit{null}}{
	    \If{\rm \textit{node.sumIu} + \textit{node.sumRu} $\geq$ $\xi$}{ 
           \textit{node.name} = the current \textit{HUI} $X$\;
           \textit{posToMatch} decrease 1, {update} \textit{currentNode} = \textit{node.parent}\;
           
           \While{\textit{currentNode} != \textit{null}}{
           	  \If{\textit{posToMatch} $\geq$ 0}{
           	      a new item $y$ = $T^\prime$[\textit{posToMatch}]\;
           	      \If{\textit{currentNode.TWU} < \textit{y.TWU}}{
           	      {break}\;
           	    }
           	      \If{\textit{currentNode.TWU} == \textit{y.TWU} \textit{AND}  \textit{currentNode} == $y$}{
           	      	
                  \textit{posToMatch} decrease 1\;
              }
             }
              {update} $x$ and currentNode\;
          }
           	\If{\textit{posToMatch} == -1}{
           		
           	\If{\textit{node.sumRu} $\geq$ $\xi$ \textit{AND} \textit{currentNode.isEnd} = $true$}{
              a THUI has been discovered\;
           }
           recursively explore all suffix nodes of $X$\;
         }
		}
   }
	
   initialize TopKMap = $\emptyset$\;
   \For{\rm  each entry itemset $t$ in THUIs}{
    	\eIf{\textit{t.utility} $\geq$ $\eta$}{
            TopKMap.add(t)\;}{ 
            skip $t$ from TargetUM\;}
        \If{\rm the number of \rm{TopKMap} $>$ $k$}{
          {update} $\eta$ as the $k$-th highest utility in TopKMap\;
          {update} TopKMap and keep $k$ target itemsets with the highest utilities in TopKMap\;
	  }
   	    }
    \textbf{return} top-$k$ THUIs
\end{algorithm}


\textbf{(1) The construction of TMKU}: this procedure can be divided into two parts: the construction of the TP-tree and the processing of the item header table. The construction of a TP-tree is the basis of the TMKU algorithm. There are several indispensable parameters need to be introduced, including its last item $x$, the list of three utilities (\textit{IUs}, \textit{Rus}, \textit{TUs}), and the three utility values of $x$. The \textit{mapItemNode} is available to store the header node of each item header table. During the construction of the TP-tree, the node used to store the last item in each itemset is called the tail node, and the tail node is continuously updated. Besides, the \textit{mapItemLastNode} is required to store the tail nodes of each item header table. First, the algorithm initializes the TP-tree, i.e., sets the initial values for the several parameters (line 1). Based on the HUIs obtained by applying HUI-Miner, once a new HUI is found, we should consider inserting it into the TP-tree (line 2). For each item $n$ in $X^\prime$ (line 3), the position of $n$ in this TP-tree can be found easily (line 4). When there are no $n$ nodes in the TP-tree, the TMKU algorithm creates a new node and stores its information in the item header table (lines 5--6). After that, the values of nodes \textit{parentNode} and \textit{listNodes} are updated (line 8). When all the items of $X^\prime$ have been processed, the TP-tree of $X^\prime$ is completely built (lines 3--8). Then, while $x$ previously existed (found by the binary search method) (line 10), the algorithm will update the information value of the current node (lines 11 to 12). And if it does not exist, an item header table of $x$ is created (line 14). Finally, the value of the \textit{currentNode.isEnd} variable is set to true (line 16).


\textbf{(2) The discovery of TMKU}: The procedure for processing the target query is a depth-first search. First, the procedure determines whether the received prefix appears. Therefore, the node is denoted the last item of $T^\prime$, and then the \textit{posToMatch} parameter is initialized to record the current two items (line 1). Then, each item of $T^\prime$ is traversed. If the sum of \textit{sumLu} and \textit{sumRu} is not less than $\xi$, according to Strategy \ref{lab:two}, $X$ may be a THUI, and further comparison with other items can be performed (lines 2--25). Moreover, according to Strategy \ref{lab:three}, if the \textit{TWU(\textit{currentNode})} is smaller than the current item of $T^\prime$, it can be discarded directly, and the comparison is aborted (lines 9--10). When the value of \textit{posToMatch} decreases to -1, one of the target itemsets is found (lines 19--20). At this point, the algorithm uses a recursive method to output this THUI. First, all suffix nodes of $X$ are explored, and from each node, the extension nodes are obtained (line 22). Then, the THUIs are stored by filtering out the high-utility itemsets that do not contain the target itemset. Finally, if the remaining suffix nodes meet the condition of Strategy \ref{lab:two}, they need to be explored.

After that, the algorithm obtains the target high-utility itemsets. Then, the task of the algorithm is to quickly mine the top-$k$ THUI. First, TopKMap is initialized to the empty set and the utility value of the first THUI is used to initialize $\eta$ (line 26). Then, the algorithm iterates through all the itemsets in the THUIs and if the utility value of the itemset is higher than $\eta$, the itemset is added to the TopKMap (lines 27--29). Otherwise, the THUI is removed (line 31). When the size of the TopKMap is over $k$ (line 33), $\eta$ is updated to the $k$-th highest utility in the TopKMap (line 34). Moreover, the algorithm updates the TopKMap and keeps the $k$ target itemsets with the highest utilities in the TopKMap (line 35). Finally, all the top-$k$ THUIs can be explored and output successfully (line 38).
