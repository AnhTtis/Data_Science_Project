

We now describe two algorithms for Chance-Constrained MRMP (CC-MRMP). We begin by formalizing the composed belief space for $N_A$ robots with models in \eqref{eq: dynamics model} and~\eqref{eq: measurement model}. We then propose a centralized approach to solving CC-MRMP by employing an existing single-robot belief-space planning algorithm called \emph{Belief-}$\mathcal{A}$ \cite{Ho2022_GBT}.
% which provides asymptotically optimal trajectories for systems described by Eqns.~\ref{eq: dynamics model} and~\ref{eq: measurement model}. 
To accommodate larger multi-robot systems, we introduce a decentralized algorithm called \emph{CC-K-CBS} which adapts the novel K-CBS algorithm to plan for systems with state and measurement uncertainty. We describe the empirical advantages and disadvantages of these methods in Sec.~\ref{sec:eval}.

\subsection{Centralized Chance-Constrained MRMP}
%Utilizing 
Centralized methods for uncertain MRMP require composing the system beliefs into a single \emph{meta-belief}, $\textbf{B}_k$, with a single dynamical constraint. We can then leverage Belief-$\mathcal{A}$ on this meta-belief. Belief-$\mathcal{A}$ provides a framework for adapting any kinodynamic sampling-based planner $\mathcal{A}$ to efficiently plan in the Gaussian belief space under chance constraints as described by \eqref{eq:coll cc} and \eqref{eq: goal cc}. See \cite{Ho2022_GBT} for details. 
%, while providing guarantees on satisfying chance constraints on the probability of terminating in a goal region and the point-wise probability of collision
%\ml{delete the explanation for CC to save space - could refer to eqns 7a and 7b instead if we want to be elaborate.}
%. For brevity we only present an overview here, see \cite{Ho2022_GBT} for details. The algorithm builds a motion tree in Gaussian belief space the same way $\mathcal{A}$ does in the state space, e.g., if $\mathcal{A}$ is RRT, Belief-RRT extends the tree by sampling a random Gaussian belief, determining the closest node to that belief via the 2-Wasserstein distance, then extending that node using a computed nominal control input
%\ml{another place to save space}
%. The Gaussian belief is propagated 
% using the techniques derived in \cite{Bry2011_BeliefProp}. The propagated belief is 
%and used for validity checking on the new node.  For collision checking, it adapts the method in \cite{Luders2010_CC-RRT}, which is based on linear constraint checking for static convex polytopic obstacles. 
% In our implementation we used this framework to adapt the Stable Sparse Rapidly Exploring Trees (SSTs)  algorithm, \cite{Li2016_SST}, to Belief-SST.

For centralized CC-MRMP, because all the robots are assumed to be independent, sampling and propagation of the meta-belief can be performed independently for each robot, and the meta-agent belief reconstructed from the individual robots' \emph{expected beliefs}, $\expBelief(x_k^i)$. These individual beliefs are obtained through \cite{Bry2011_BeliefProp}, which provides a method for predicting the belief over states for a linearizable and controllable system that uses a KF for estimation. This method forecasts the belief with a priori unknown measurements, yielding an expected belief defined as:
\begin{align*}
    \label{eq: expected belief}
    \expBelief(x_k^i) &= \mathbb{E}_Y[b(x_k^i | x_0^i, y_{0:k}^i)] 
    = \int_{y_{0:k}^i} \hspace{-3mm} b(x_k^i | x_0^i, y_{0:k}^i) pr(y_{0:k}^i)dy.
    % &= \mathcal{N}(\check{x}_k^i,\Sigma_k^i+\Lambda_k^i) = \mathcal{N}(\mu_k^i,\Gamma_k^i)
     % = \mathcal{N}(\mu_k^i,\Gamma_k^i),
\end{align*}
We use this expected belief for offline motion planning and evaluation of chance constraints in \eqref{eq:coll cc} and \eqref{eq: goal cc}. For a given initial belief $b(x_0^i)$ and nominal trajectory, $\check{X}^i$, the expected belief is
$\expBelief(x_k^i) = \mathcal{N}(\check{x}_k^i,\Gamma_k^i)$, where $\Gamma_k^i = \Sigma_k^i+\Lambda_k^i$ can be recursively calculated as derived in \cite{Bry2011_BeliefProp}:
\begin{align}
    \Sigma_k^{i-} &= A^i \Sigma^i_{k-1}A^{iT} + Q^i, \quad \Sigma_k^i = \Sigma_k^{i-} - L_k^i C^i\Sigma_k^{i-}, \\
    \Lambda_k^i &= (A^i-B^iK^i)\Lambda_{k-1}^i(A^i-B^iK^i)^T + L_k^i C^i \Sigma_k^{i-},
\end{align}
where $\Sigma_k^i$ is the online KF uncertainty, and $\Lambda_k^i$ is covariance of the expected state estimates $\hat{x}_k^i$. Intuitively, this distribution can be thought of as the sum of the online estimation error and the uncertainty from the a priori unknown measurements made during execution. Given the expected beliefs for the agents, the meta-belief can be constructed such that $\textbf{B}_k=\mathcal{N}(\check{X}_k^{M}, \Gamma_k^M)$, where $\check{X}_k^{M}=(\check{x}_k^{iM}, ...,\check{x}_k^{N_A M})$, and $\Gamma_k^M$ is constructed as a block diagonal with elements $\Gamma_k^i, i=1,...,N_A$. 
Similarly, the validity checkers can be iterated for each robot, such that an entire meta-belief node is considered invalid if a single robot's belief is deemed invalid.

This centralized algorithm is the simplest of our two approaches, however it suffers from poor scalability with the number of agents, just as centralized deterministic planners do. To this end, we introduce a decentralized planner. 
% This formulation allows us to use any single-agent belief-space planner to solve uncertain MRMP. We denote this general algorithm as belief-$\mathcal{A}$, where $\mathcal{A}$ is any deterministic sampling-based tree planner. Originally introduced in \jk{cite}, belief-$\mathcal{A}$ works by sampling beliefs according to the Wasserstein distance metric, propagating the beliefs using Eqn.~\ref{eq: dynamics model} and~\ref{eq: measurement model} according to methods introduced in Bry/Roy \jk{cite}, and using off-the-shelf chance constrained agent-to-obstacle collision checkers to ensure safe solutions. Using belief-$\mathcal{A}$ for Uncertain MRMP adds an additional requirement of implementing an agent-to-agent collision checking procedure.  

\subsection{Decentralized Chance-Constrained K-CBS}
\begin{algorithm}[t]
\KwIn{$\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B, $p_{\safe}$}
\KwOut{Valid motion plans $\{(\check{U}^i, \check{X}^i)\}_{i=1}^{N_A}$}
$Q, n_0, \leftarrow \emptyset$;
$n_0$.plan $\leftarrow$ \underline{\textsc{getInitPlan}}$()$;$Q$.add($n_0$)\label{ln:rootNode}\;
%$p_{\safe}^A$,$p_{\safe}^O \leftarrow$\underline{\textsc{allocSafety}}$(p_{\safe})$\label{ln:allocate safety}\;
\While{solution not found \label{ln:mainBegin}}
{
    $c \leftarrow$ $Q$.top()\label{ln:selectKCBS}\;
    \eIf{$c$.plan is empty \label{ln:retry}}
    {
        $Q$.pop(); \underline{\textsc{replan}}(N, $c$);
        % $\mathcal{C}_{\max} \leftarrow$
        % \If{shouldMerge($\mathcal{C}_{\max}$, B)\label{ln:mergeIf1}}
        % {
        %     \KwRet{mrg\&rstrt($\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B,$\mathcal{C}_{max}$)}
        % }
        $Q$.add($c$)\label{ln:retryAdd}\;
    }
    {
        K $\leftarrow$ \underline{\textsc{validatePlan}}($c$.plan, $p_{\safe}$)\label{ln:validate}\;
        \uIf{K is empty\label{ln:isKempty}}
        {
            \KwRet{$c$.plan\label{ln:retPlan}}
        }
        \uElseIf{shouldMerge(K, B)\label{ln:shouldMerge}}
        {
            \KwRet{mrg\&rstrt($\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B, K)}
        }
        \Else
        {
            $Q$.pop()\label{ln:branchPop}\;
            \For{every robot $i$ in K\label{ln:branchForLoop}}
            {
                $c_{new}.\mathcal{C} \leftarrow$ $c.\mathcal{C} \: \cup$ \underline{\textsc{createCSTR}}(K, $i$)\label{ln:create constraint}\;
                \underline{\textsc{replan}}(N, $c_{new}$); $Q$.add($c_{new}$)\label{ln:branchAdd}\; 
                %$\mathcal{C}_{\max} \leftarrow$ 
            }
        }
    }
    \label{ln:mainEnd}
}
\caption{Chance Constrained K-CBS}
\label{alg:G-KCBS}
\end{algorithm}
\setlength{\textfloatsep}{10pt}

Our decentralized CC-MRMP algorithm is based on Kinodynamic Conflict-Based Search (K-CBS)~\cite{Kotting2022_KCBS}. K-CBS consists of a high-level conflict-tree search and a low-level motion planner. At the high-level, K-CBS tracks a constraint-tree (CT), in which each node represents a suggested plan, which might contain conflicts (i.e., collisions). At each iteration, K-CBS picks an unexplored node from the CT based on some heuristic and identifies the conflicts in the nodeâ€™s corresponding plan. Then, K-CBS tries to resolve the conflicts by creating child nodes as follows: if robots $i$ and $j$ are in collision for some time duration $[t_s,t_e]$ (denoted $\langle i,j,[t_s,t_e]\rangle$), then two child nodes are created, one with the constraint that $\mathcal{B}^i$ cannot intersect with $\mathcal{B}^j$ for all $t\in[t_s,t_e]$ and the other dually for robot $j$.
Then, in each child node, a low-level sampling-based planner attempts to replan a trajectory that satisfies the set of all constraints in that branch of the CT within $N>0$ iterations. This process repeats until a non-colliding plan is found. In the case where greater than $B>0$ conflicts arise, K-CBS includes a merge and restart procedure that recursively combines a subset of the robots. We refer the reader to~\cite{Kotting2022_KCBS} for details on the original K-CBS.
We now describe CC-K-CBS (Alg.~\ref{alg:G-KCBS}), which requires several adaptations of K-CBS (underlined in Alg.~\ref{alg:G-KCBS}).
% The pseudocode for (CC)-K-CBS is shown in Alg.~\ref{alg:G-KCBS}. We refer the reader to~\cite{Kotting2022_KCBS} for details on the original K-CBS. 

Firstly, note that in K-CBS, collision checking between robots and static obstacles are performed separately. The low-level planner keeps track of workspace static obstacles, and the CT node accounts for robot-robot collisions at the high-level.  This separation is key for scalability, but it introduces a major challenge in chance-constrained planning for uncertain robots.  We expand on this further in Sec.~\ref{sec:collisionChecking}.
% We extended K-CBS Chance-Constrained K-CBS (CC-K-CBS) for CC-MRMP with three adaptations. 
% The procedures that require changes shown in red, blue, and violate fonts in Alg.~\ref{alg:G-KCBS}.
Secondly, since states are now beliefs, CC-K-CBS requires a Gaussian belief low-level motion planner.  We propose to use Belief-$\mathcal{A}$ for the \textsc{replan} and \textsc{getInitPlan} procedures. Thirdly, CC-K-CBS requires a definition of constraints; we introduce \emph{belief-constraints}. This simply replaces the deterministic shape with a non-deterministic belief. Thus, given a conflict $K=\langle i,j,[t_s,t_e]\rangle$, one constraint forces robot $i$ to satisfy the chance-constraint with $b(x_k^j)$ for all $t\in[t_s,t_e]$ and dually for robot $j$. This enables \textsc{createCSTR} 
(Line~\ref{ln:create constraint}) 
to define meaningful constraints during replanning with Belief-$\mathcal{A}$. 

Lastly, \textsc{validatePlan} (Line~\ref{ln:validate}) requires an efficient way of validating the chance constraints (Equations \ref{eq:coll cc} and \ref{eq: goal cc}) while simulating prospective MRMP plans. We propose several techniques for this computation, each of which is described in detail in Sec.~\ref{sec:collisionChecking}. Every method requires comparison with the maximum allowable probability of collision $p_{coll} = 1-p_{\safe}$. 
We say \textsc{validatePlan} procedure is \emph{complete} if it can correctly evaluate the constraints \eqref{eq:coll cc} and \eqref{eq: goal cc} for all Gaussian beliefs.

The following theorem provides the sufficient conditions for CC-K-CBS to be probabilistically complete. 
% Because deterministic K-CBS has already been proven to be probabilistically complete in \cite{Kotting2022_KCBS}, we focus on the aspects of the algorithm which have been modified for uncertainty.


\begin{theorem}
    \label{thm:completeness}
    CC-K-CBS is probabilistically complete if the underlying planner Belief-$\mathcal{A}$ is  probabilistically complete and the \textsc{validatePlan} procedure is complete.
\end{theorem}
\begin{proof}
The proof builds on Theorem 1 in \cite{Kotting2022_KCBS}, which shows that 
% shows that
% According to \cite{Kotting2022_KCBS},
K-CBS inherits the probabilistic completeness property of the low-level planner. Thus, probabilistic completeness of Belief-$\mathcal{A}$ is required for CC-K-CBS. The completeness of \textsc{validatePlan} ensures that CC-K-CBS does not reject valid plans. It follows that \textsc{createCSTR} does not pass spurious constraints to the low-level planner. Therefore, under these conditions, the probabilistic completeness proof for K-CBS extends to CC-K-CBS.
\end{proof}

The completeness condition on \textsc{validatePlan} 
% requires exact evaluation of the chance constraints in \eqref{eq:coll cc} and \eqref{eq: goal cc}, which is possible 
can be satisfied
by exact evaluation of the probabilities in \eqref{eq:prob goal}-\eqref{eq:prob robot-robot collision}. However, this operation can be computationally expensive. To achieve tractability and scalability, we introduce conservatism into \textsc{validatePlan} by over-approximating the probability of collision.
% in \eqref{eq:prob collision} and \eqref{eq:prob robot-robot collision} and under-approximating the goal probability in \eqref{eq:prob goal}. 
% The use of an over-approximation guarantees satisfaction of the chance constraint, however can result in valid plans being incorrectly pruned.
With this \textsc{validatePlan}, we can still guarantee soundness of the CC-K-CBS solutions, but completeness is affected since valid plans may be rejected.


\begin{corollary}
If \textsc{validatePlan} uses an over-approximation of the probability of collision, then CC-K-CBS is probabilistically complete up to the accuracy of the over-approximation.
\end{corollary}

Below, we introduce several methods for over-approximating the probability of collision. 
% and evaluating the chance constraints.

\begin{comment}
    
\textcolor{blue}{Given an underlying sampling-based tree-search planner, $\mathcal{A}$, we prove the proposed CC-K-CBS algorithm inherits the same completeness properties as $\mathcal{A}$.
\ml{hmm... need to elaborate more here... I think the assumption is that \textsc{validatePlan} is complete w.r.t. $p_\safe$, no?}
}
\ml{another point regarding the theorem/proof, risk allocation \textsc{allocSafety} is only required for Method 1, not Method 2, right?}
\begin{theorem}[]
    \label{thm:completeness}
    \textcolor{blue}{If planner $\mathcal{A}$ is probabilistically complete, then so is CC-K-CBS.}
\end{theorem}
\begin{proof}
\textcolor{blue}{The proof of follows directly from the completeness proofs of the constituent algorithms, K-CBS and Belief-$\mathcal{A}$, which are detailed in \cite{Kotting2022_KCBS} and \cite{Ho2022_GBT} respectively.}

\textcolor{blue}{Note that the introduction of probabilistic chance constraints does not violate the completeness proof of the K-CBS algorithm from \cite{Kotting2022_KCBS}. We can simply substitute the robot-robot chance constraint condition into the deterministic collision avoidance criterion of K-CBS. This does not change the completeness proof, thus preserving the probabilistic completeness property of K-CBS for returning nominal trajectories that respect the chance constraint.}
\ml{This is not a proof... it's an explanation/elaboration.}

\textcolor{blue}{To complete the proof: if $\mathcal{A}$ is probabilistically complete, then so is Belief-$\mathcal{A}$~\cite{Ho2022_GBT}, which in turn implies K-CBS~\cite{Kotting2022_KCBS} is probabilistically complete. Therefore, if $\mathcal{A}$ is probabilistically complete, then so is CC-K-CBS.}
\ml{the last sentence is a repetitive}
\end{proof}

\ml{reword the following paragraph and make it concise given the comments above the theorem.}
\textcolor{blue}{The completeness of CC-K-CBS is complicated by the difficulty of probabilistic collision checking, where the exact probability of collision is almost never available for the collision checking step. To this end we introduce approximations that over-bound the probability of collision. We can thus guarantee that any returned solution satisfies the chance constraint. However, the over approximation means we cannot guarantee that if a valid solution exists it will be found, even as the computation time approaches infinity. Thus the proposed approximate collision checking algorithm is not probabilistically complete with respect to the original chance constraint. However, the algorithm is probabilisitically complete \emph{with respect to the approximations}, meaning if a solution exists under the approximations, the algorithm will return that solution with probability 1 as the computation time approaches infinity.}
\end{comment}


%These three new requirements present themselves inside the red, violet, and blue procedures of Alg.~\ref{alg:G-KCBS}, respectively. 


% \subsection{Belief Propagation}
% \label{sec:beliefProp}
% Work \cite{Bry2011_BeliefProp} provides a method for predicting the belief over states for a linearizable and controllable system that uses a KF for estimation. This method forecasts the belief with a priori unknown measurements, yielding an \emph{expected belief}, $\expBelief(x_k^i)$, defined as:
% \begin{align*}
%     \label{eq: expected belief}
%     \expBelief(x_k^i) &= \mathbb{E}_Y[b(x_k^i \mid x_0^i, y_{0:k}^i)] 
%     = \int_{y_{0:k}^i} \hspace{-3mm} b(x_k^i \mid x_0^i, y_{0:k}^i) pr(y_{0:k}^i)dy.
%     % &= \mathcal{N}(\check{x}_k^i,\Sigma_k^i+\Lambda_k^i) = \mathcal{N}(\mu_k^i,\Gamma_k^i)
%      % = \mathcal{N}(\mu_k^i,\Gamma_k^i),
% \end{align*}
% We use this expected belief for offline motion planning and evaluation of chance constraints \eqref{eq:coll cc} and \eqref{eq: goal cc}. For a given initial belief $b(x_0^i)$ and nominal trajectory, $\check{X}^i$, the expected belief
% $\expBelief(x_k^i) = \mathcal{N}(\check{x}_k^i,\Gamma_k^i)$, where $\Gamma_k^i = \Sigma_k^i+\Lambda_k^i$ can be recursively calculated as derived in \cite{Bry2011_BeliefProp}:
% \begin{align}
%     \Sigma_k^{i-} &= A\Sigma_{k-1}A^{iT} + Q^i, \quad \Sigma_k^i = \Sigma_k^{i-} - L_k^i C^i\Sigma_k^{i-}, \\
%     \Lambda_k^i &= (A^i-B^iK^i)\Lambda_{k-1}^i(A^i-B^iK^i)^T + L_k^i C^i \Sigma_k^{i-},
% \end{align}
% where $\Sigma_k^i$ is the online KF uncertainty, and $\Lambda_k^i$ is covariance of the expected state estimates $\hat{x}_k^i$. Intuitively, this distribution can be thought of as the sum of the online estimation error and the uncertainty from the a priori unknown measurements made during execution.
