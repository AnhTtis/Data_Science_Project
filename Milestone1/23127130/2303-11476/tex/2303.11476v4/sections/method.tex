

We now describe two algorithms for Chance-Constrained MRMP (CC-MRMP). We begin by formalizing the composed belief space for $N_A$ robots with models in \eqref{eq: dynamics model} and~\eqref{eq: measurement model}. We then propose a centralized approach to solving CC-MRMP by employing an existing single-robot belief-space planning algorithm called \emph{Belief-}$\mathcal{A}$ \cite{Ho2022_GBT}.
% which provides asymptotically optimal trajectories for systems described by Eqns.~\ref{eq: dynamics model} and~\ref{eq: measurement model}. 
To accommodate larger multi-robot systems, we introduce a decentralized algorithm called \emph{CC-K-CBS} which adapts the novel K-CBS algorithm to plan for systems with state and measurement uncertainty. We describe the empirical advantages and disadvantages of these methods in Sec.~\ref{sec:eval}.

\subsection{Centralized Chance-Constrained MRMP}
%Utilizing 
Centralized methods for uncertain MRMP require composing the system beliefs into a single \emph{meta-belief}, $\textbf{B}_k$, with a single dynamical constraint. We can then leverage the belief-$\mathcal{A}$ framework on this meta-belief.

Belief-$\mathcal{A}$ provides a framework for adapting any kinodynamic sampling-based planner $\mathcal{A}$ to efficiently plan in the Gaussian belief space \cite{Ho2022_GBT}, while providing guarantees on satisfying chance constraints on the probability of terminating in a goal region and the point-wise probability of collision. For brevity we only present an overview here, see \cite{Ho2022_GBT} for details. The algorithm builds a motion tree in Gaussian belief space the same way $\mathcal{A}$ does in the state space, e.g., if $\mathcal{A}$ is RRT, Belief-RRT extends the tree by sampling a random Gaussian belief, determining the closest node to that belief via the 2-Wasserstein distance, then extending that node using a computed nominal control input. The Gaussian belief is propagated 
% using the techniques derived in \cite{Bry2011_BeliefProp}. The propagated belief is 
and used for validity checking on the new node.  For collision checking, it adapts the method in \cite{Luders2010_CC-RRT}, which is based on linear constraint checking for static convex polytopic obstacles. 
% In our implementation we used this framework to adapt the Stable Sparse Rapidly Exploring Trees (SSTs)  algorithm, \cite{Li2016_SST}, to Belief-SST.

For centralized CC-MRMP, because all the robots are assumed to be independent, sampling and propagation of the meta-belief can be performed independently for each robot, and the meta-agent belief reconstructed from the individual robots' \emph{expected beliefs}, $\expBelief(x_k^i)$. These individual beliefs are obtained through \cite{Bry2011_BeliefProp}, which provides a method for predicting the belief over states for a linearizable and controllable system that uses a KF for estimation. This method forecasts the belief with a priori unknown measurements, yielding an expected belief defined as:
\begin{align*}
    \label{eq: expected belief}
    \expBelief(x_k^i) &= \mathbb{E}_Y[b(x_k^i \mid x_0^i, y_{0:k}^i)] 
    = \int_{y_{0:k}^i} \hspace{-3mm} b(x_k^i \mid x_0^i, y_{0:k}^i) pr(y_{0:k}^i)dy.
    % &= \mathcal{N}(\check{x}_k^i,\Sigma_k^i+\Lambda_k^i) = \mathcal{N}(\mu_k^i,\Gamma_k^i)
     % = \mathcal{N}(\mu_k^i,\Gamma_k^i),
\end{align*}
We use this expected belief for offline motion planning and evaluation of chance constraints in \eqref{eq:coll cc} and \eqref{eq: goal cc}. For a given initial belief $b(x_0^i)$ and nominal trajectory, $\check{X}^i$, the expected belief
$\expBelief(x_k^i) = \mathcal{N}(\check{x}_k^i,\Gamma_k^i)$, where $\Gamma_k^i = \Sigma_k^i+\Lambda_k^i$ can be recursively calculated as derived in \cite{Bry2011_BeliefProp}:
\begin{align}
    \Sigma_k^{i-} &= A\Sigma_{k-1}A^{iT} + Q^i, \quad \Sigma_k^i = \Sigma_k^{i-} - L_k^i C^i\Sigma_k^{i-}, \\
    \Lambda_k^i &= (A^i-B^iK^i)\Lambda_{k-1}^i(A^i-B^iK^i)^T + L_k^i C^i \Sigma_k^{i-},
\end{align}
where $\Sigma_k^i$ is the online KF uncertainty, and $\Lambda_k^i$ is covariance of the expected state estimates $\hat{x}_k^i$. Intuitively, this distribution can be thought of as the sum of the online estimation error and the uncertainty from the a priori unknown measurements made during execution. Given the expected beliefs for the agents, the meta-belief can be constructed such that $\textbf{B}_k=\mathcal{N}(\check{X}_k^{M}, \Gamma_k^M)$, where $\check{X}_k^{M}=(\check{x}_k^{iM}, ...,\check{x}_k^{N_A M})$, and $\Gamma_k^M$ is constructed as a bulk diagonal with elements $\Gamma_k^i, i=1,...,N_A$. 
Similarly, the validity checkers can be iterated for each robot, such that an entire meta-belief node is considered invalid if a single robot's belief is deemed invalid.

This centralized algorithm is the simplest of our two approaches, however it suffers from poor scalability with the number of agents, just as centralized deterministic planners do. To this end, we introduce a decentralized planner. 
% This formulation allows us to use any single-agent belief-space planner to solve uncertain MRMP. We denote this general algorithm as belief-$\mathcal{A}$, where $\mathcal{A}$ is any deterministic sampling-based tree planner. Originally introduced in \jk{cite}, belief-$\mathcal{A}$ works by sampling beliefs according to the Wasserstein distance metric, propagating the beliefs using Eqn.~\ref{eq: dynamics model} and~\ref{eq: measurement model} according to methods introduced in Bry/Roy \jk{cite}, and using off-the-shelf chance constrained agent-to-obstacle collision checkers to ensure safe solutions. Using belief-$\mathcal{A}$ for Uncertain MRMP adds an additional requirement of implementing an agent-to-agent collision checking procedure.  

\subsection{Decentralized Chance-Constrained K-CBS}
\begin{algorithm}[t]
\KwIn{$\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B, $p_{\safe}$}
\KwOut{Collision-free motion plans $\{(\check{U}^i, \check{X}^i)\}_{i=1}^{N_A}$}
$Q, n_0, \leftarrow \emptyset$;
$n_0$.plan $\leftarrow$ \underline{\textsc{getInitPlan}}$()$;$Q$.add($n_0$)\label{ln:rootNode}\;
$p_{safe}^A$,$p_{safe}^O \leftarrow$\underline{\textsc{allocSafety}}$(p_{\safe})$\;
\While{solution not found \label{ln:mainBegin}}
{
    $c \leftarrow$ $Q$.top()\label{ln:selectKCBS}\;
    \eIf{$c$.plan is empty \label{ln:retry}}
    {
        $Q$.pop(); \underline{\textsc{replan}}(N, $c$);
        % $\mathcal{C}_{\max} \leftarrow$
        % \If{shouldMerge($\mathcal{C}_{\max}$, B)\label{ln:mergeIf1}}
        % {
        %     \KwRet{mrg\&rstrt($\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B,$\mathcal{C}_{max}$)}
        % }
        $Q$.add($c$)\label{ln:retryAdd}\;
    }
    {
        K $\leftarrow$ \underline{\textsc{validatePlan}}($c$.plan, $p_{safe}^A$)\label{ln:validate}\;
        \uIf{K is empty\label{ln:isKempty}}
        {
            \KwRet{$c$.plan\label{ln:retPlan}}
        }
        \uElseIf{shouldMerge(K, B)\label{ln:shouldMerge}}
        {
            \KwRet{mrg\&rstrt($\W$, $\{x_0^i\}_{i=1}^{N_A}$, N, B,K)}
        }
        \Else
        {
            $Q$.pop()\label{ln:branchPop}\;
            \For{every robot $i$ in K\label{ln:branchForLoop}}
            {
                $c_{new}.\mathcal{C} \leftarrow$ $c.\mathcal{C} \: \cup$ \underline{\textsc{createCSTR}}(K, $i$)\;
                \underline{\textsc{replan}}(N, $c_{new}$); $Q$.add($c_{new}$)\label{ln:branchAdd}\; 
                %$\mathcal{C}_{\max} \leftarrow$ 
            }
        }
    }
    \label{ln:mainEnd}
}
\caption{Chance Constrained K-CBS}
\label{alg:G-KCBS}
\end{algorithm}
\setlength{\textfloatsep}{10pt}

Our decentralized CC-MRMP algorithm is based on Kinodynamic Conflict-Based Search (K-CBS)~\cite{Kotting2022_KCBS}. K-CBS consists of a high-level conflict-tree search and a low-level motion planner. At the high-level, K-CBS tracks a constraint-tree, in which each node represents a suggested plan, which might contain conflicts (i.e., collisions). At each iteration, K-CBS picks an unexplored node from the constraint-tree (CT), based on some heuristic, and identifies the conflicts in the nodeâ€™s corresponding plan. Then, K-CBS tries to resolve the conflicts by creating child nodes as follows: if robot $i$ and $j$ collide for some finite time range $t\in[t_s,t_e]$ (denoted $\langle i,j,[t_s,t_e]\rangle$), then two child nodes are created, one with the constraint that $\mathcal{B}^i$ cannot intersect with $\mathcal{B}^j$ for all $t\in[t_s,t_e]$ and the other dually for robot $j$.
Then, in each child node, a low-level sampling-based planner attempts to replan a trajectory that satisfies the set of all constraints in that branch of the CT within $N>0$ iterations. This process repeats until a non-colliding plan is found. In the case where greater than $B>0$ conflicts arise, K-CBS includes a merge and restart procedure that recursively combines a subset of the robots. We refer the reader to~\cite{Kotting2022_KCBS} for details on the original K-CBS.
We now describe CC-K-CBS (Alg.~\ref{alg:G-KCBS}), which requires several adaptations of K-CBS (underlined in Alg.~\ref{alg:G-KCBS}).
% The pseudocode for (CC)-K-CBS is shown in Alg.~\ref{alg:G-KCBS}. We refer the reader to~\cite{Kotting2022_KCBS} for details on the original K-CBS. 

Firstly, note that in K-CBS, collision checking between robots and static obstacles are performed separately. The low-lever planner keeps track of workspace static obstacles, and the conflict tree accounts for robot-robot collisions at the high-level.  This separation is key for scalability, but it introduces a major challenge in chance-constrained planning for uncertain robots.  We expand on this further in Sec.~\ref{sec:collisionChecking}.
% We extended K-CBS Chance-Constrained K-CBS (CC-K-CBS) for CC-MRMP with three adaptations. 
% The procedures that require changes shown in red, blue, and violate fonts in Alg.~\ref{alg:G-KCBS}.
Secondly, since states are now beliefs, CC-K-CBS requires a Gaussian belief low-level motion planner.  We propose to use Belief-$\mathcal{A}$. As a result, the \textsc{replan} procedure returns a motion plan $(\check{U}^i, \check{X}^i)$ for robot $i$ while \textsc{getInitPlan} returns $(\check{U}^i, \check{X}^i)$ for all $i\in\{1, \ldots, N_A\}$. Thirdly, CC-K-CBS requires a definition of constraints; we introduce \emph{belief-constraints}. This simply replaces the deterministic shape with a non-deterministic belief. Thus, given a conflict $K=\langle i,j,[t_s,t_e]\rangle$, one constraint forces robot $i$ to satisfy the chance-constraint with $b(x_k^j)$ for all $t\in[t_s,t_e]$ and dually for robot $j$. This enables \textsc{createCSTR} in to define meaningful constraints during replanning with Belief-$\mathcal{A}$. 

Lastly, \textsc{validatePlan} requires an efficient way of validating the chance constraint while simulating prospective MRMP plans. We propose several techniques for this computation, each of which is described in detail in Sec.~\ref{sec:collisionChecking}. Every method requires comparison with the maximum allowable probability of collision $p_{coll} = 1-p_{\safe}$, the two-level structure of CC-K-CBS allows one to distribute $p_{coll}$ amongst the obstacles and robots. \textsc{allocSafety} can do this in a number of ways as explained in Sec.~\ref{sec:Risk Allocation}.  

% , such as normalizing by the percentage of obstacles and robots. Thus, $p_{coll}^A=1-p_{\safe}^A$ is the maximum allowable probability of unsafe behavior for robot-robot chance-constraint validation while $p_{coll}^O=1-p_{\safe}^O$ measures the same quantity for robot-obstacle chance constraint validations. Note that $p_{coll}^A+ p_{coll}^O=p_{coll}$.
\begin{theorem}[]
    \label{thm:completeness}
    If planner $\mathcal{A}$ is probabilistically complete, then so is CC-K-CBS.
\end{theorem}

\begin{proof}
Recall that if $\mathcal{A}$ is probabilistically complete, then so is Belief-$\mathcal{A}$~\cite{Ho2022_GBT}, which in turn implies K-CBS~\cite{Kotting2022_KCBS} is probabilistically complete. Therefore, if $\mathcal{A}$ is probabilistically complete, then so is CC-K-CBS.
\end{proof}



%These three new requirements present themselves inside the red, violet, and blue procedures of Alg.~\ref{alg:G-KCBS}, respectively. 


% \subsection{Belief Propagation}
% \label{sec:beliefProp}
% Work \cite{Bry2011_BeliefProp} provides a method for predicting the belief over states for a linearizable and controllable system that uses a KF for estimation. This method forecasts the belief with a priori unknown measurements, yielding an \emph{expected belief}, $\expBelief(x_k^i)$, defined as:
% \begin{align*}
%     \label{eq: expected belief}
%     \expBelief(x_k^i) &= \mathbb{E}_Y[b(x_k^i \mid x_0^i, y_{0:k}^i)] 
%     = \int_{y_{0:k}^i} \hspace{-3mm} b(x_k^i \mid x_0^i, y_{0:k}^i) pr(y_{0:k}^i)dy.
%     % &= \mathcal{N}(\check{x}_k^i,\Sigma_k^i+\Lambda_k^i) = \mathcal{N}(\mu_k^i,\Gamma_k^i)
%      % = \mathcal{N}(\mu_k^i,\Gamma_k^i),
% \end{align*}
% We use this expected belief for offline motion planning and evaluation of chance constraints \eqref{eq:coll cc} and \eqref{eq: goal cc}. For a given initial belief $b(x_0^i)$ and nominal trajectory, $\check{X}^i$, the expected belief
% $\expBelief(x_k^i) = \mathcal{N}(\check{x}_k^i,\Gamma_k^i)$, where $\Gamma_k^i = \Sigma_k^i+\Lambda_k^i$ can be recursively calculated as derived in \cite{Bry2011_BeliefProp}:
% \begin{align}
%     \Sigma_k^{i-} &= A\Sigma_{k-1}A^{iT} + Q^i, \quad \Sigma_k^i = \Sigma_k^{i-} - L_k^i C^i\Sigma_k^{i-}, \\
%     \Lambda_k^i &= (A^i-B^iK^i)\Lambda_{k-1}^i(A^i-B^iK^i)^T + L_k^i C^i \Sigma_k^{i-},
% \end{align}
% where $\Sigma_k^i$ is the online KF uncertainty, and $\Lambda_k^i$ is covariance of the expected state estimates $\hat{x}_k^i$. Intuitively, this distribution can be thought of as the sum of the online estimation error and the uncertainty from the a priori unknown measurements made during execution.
