\documentclass[runningheads]{llncs}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}
\usepackage[english]{babel}
\usepackage{hyphenat}
\usepackage[dvipsnames]{xcolor}
\usepackage{cmll}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage{ebproof}
\usepackage{multicol}
\usepackage{mdframed}
\usepackage[capitalize]{cleveref}
\usepackage{thmtools}

\usepackage{cancel}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{corollary}{Corollary}[theorem]
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{example}{Example}[section]
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}[section]
%\theoremstyle{remark}
%\newtheorem*{remark}{Remark}

\mdfsetup{innertopmargin=.3cm,innerbottommargin=.6cm}

\usepackage{doc}
\usepackage{ulem} 
\renewcommand{\emph}[1]{{\it #1}}

%\usepackage{macros}
%% Notation

\newcommand{\lamp}{\lam_p}
\newcommand{\lamop}{\lam_{op}}
\newcommand{\lamcc}{\lam_{{\tt gs}}}

\newcommand{\defeq}{:=}

\newcommand{\gctype}{\kappa}
\newcommand{\ctype}{\kappa}
\newcommand{\stype}{\mathcal{S}}
\newcommand{\rtype}{\rho}
\newcommand{\rdel}{\sig}

\newcommand{\conj}[1]{\{#1\}}


\newcommand{\upd}[3]{\name{upd}_{#1}(#2,#3)}
\newcommand{\get}[3]{\name{get}_{#1}(\lam #2.#3)}
\newcommand{\set}[3]{\name{set}_{#1}(#2,#3)}
\newcommand{\lkp}[2]{\name{lkp}_{#1}(#2)}

\newcommand{\defn}[1]{{\bf #1}}

\newcommand{\final}{final}
\newcommand{\undefined}{\name{undefined}}
\newcommand{\splus}{\Cup}

\newcommand{\ret}[1]{{\langle #1 \rangle}}
\newcommand{\bind}[2]{#1 * #2}

\newcommand{\eqstate}{\equiv_{\tt c}}
\newcommand{\equivstate}{\equiv}
\newcommand{\estate}{\epsilon}
\newcommand{\gtype}{\mathcal{T}}

\newcommand{\sz}[1]{{\name{sz}}(#1)}
\newcommand{\size}[1]{|#1|}

\newcommand{\rrule}{\mapsto}
\newcommand{\red}[1][]{\ra_{#1}}
\newcommand{\redn}[1][]{\rra_{#1}}
\newcommand{\redcbv}{\ra_{\beta_v}}
\newcommand{\redgen}{\red[\gname]}
\newcommand{\redbeta}{\red[\beta]}
\newcommand{\redbetav}{\red[\beta_v]}
\newcommand{\redget}{\red[\getname]}
\newcommand{\redset}{\red[\setname]}
\newcommand{\gname}{{\tt r}}
\newcommand{\getname}{{\tt g}}
\newcommand{\setname}{{\tt s}}

\newcommand{\dred}{\ra}
\newcommand{\gsred}{\ra}
\newcommand{\rred}[1][]{\rra_{#1}}
\newcommand{\drred}{\rra}
\newcommand{\gsrred}{\rra}
\newcommand{\esubs}[2]{\[#1\!\setminus\!#2\]}
\newcommand{\subs}[2]{\{#1\!\setminus\!#2\}}
\newcommand{\fv}[1]{{\name{fv}}(#1)}
\newcommand{\bv}[1]{{\name{bv}}(#1)}
\newcommand{\dom}[1]{{\tt dom}(#1)}

\newcommand{\seq}[3]{#1 \vdash #2: #3}
\newcommand{\seqi}[4]{#1 \vdash^{#4} #2: #3}
\newcommand{\mul}[1]{[ #1 ]}
\newcommand{\emul}{[ \, ]}

\newcommand{\betav}{{\beta_v}}

\newcommand{\M}{\mathcal{M}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\ftype}{\rho}
\newcommand{\tightp}[1]{\name{tight}(#1)}
\newcommand{\tightt}{\name{tt}}
\newcommand{\tightv}{\name{tv}}
\newcommand{\tvar}{\name{v}}
\newcommand{\tneutral}{\name{n}}
\newcommand{\tabs}{\name{a}}
\newcommand{\vl}{\name{a}}

\newcommand{\nott}[1]{\overline{#1}}

%% Reduction Contexts

\newcommand{\WOf}[1]{\W \llbracket #1 \rrbracket}

%% Rule Names

\newcommand{\ruleUpd}{\name{upd}}
\newcommand{\ruleEmp}{\name{emp}}
\newcommand{\ruleConf}{\name{conf}}

\newcommand{\ruleGet}{\name{get}}
\newcommand{\ruleSet}{\name{set}}
\newcommand{\ruleBeta}{\name{$\beta_\name{v}$}}
\newcommand{\ruleAppL}{\name{appL}}
\newcommand{\ruleAppR}{\name{appR}}

\newcommand{\ruleLift}{\name{$\uparrow$}}
\newcommand{\ruleAx}{\name{ax}}
\newcommand{\ruleLam}{$\lambda$}
\newcommand{\ruleApp}{\name{@}}
\newcommand{\ruleAppOne}{\ruleApp$_{\name{1}}$}
\newcommand{\ruleAppTwo}{\ruleApp$_{\name{2}}$}

\newcommand{\ruleMany}{\name{m}}

\newcommand{\ruleAxP}{\ruleAx$_\name{p}$}
\newcommand{\ruleAxPOne}{\ruleAx$_\name{p1}$}
\newcommand{\ruleAxPTwo}{\ruleAx$_\name{p2}$}
\newcommand{\ruleLamP}{\ruleLam$_\name{p}$}
\newcommand{\ruleLamPOne}{\ruleLam$_{\name{p1}}$}
\newcommand{\ruleLamPTwo}{\ruleLam$_{\name{p2}}$}
\newcommand{\ruleAppPOne}{\ruleApp$_{\name{p1}}$}
\newcommand{\ruleAppPTwo}{\ruleApp$_{\name{p2}}$}

\newcommand{\ruleAxC}{\ruleAx$_\name{c}$}
\newcommand{\ruleLamC}{\ruleLam$_\name{c}$}
\newcommand{\ruleLamCOne}{\ruleLam$_{\name{c1}}$}
\newcommand{\ruleLamCTwo}{\ruleLam$_{\name{c2}}$}
\newcommand{\ruleAppC}{\ruleApp$_\name{c}$}

\newcommand{\isvalue}[1]{\name{val}(#1)}
\newcommand{\isabs}[1]{\name{abs}(#1)}

%% Shorthands

\newcommand{\nothing}{{\color{white} nothing}}

\newcommand{\neutral}{\name{ne}}
\newcommand{\normal}{\name{no}}

\newcommand{\eset}{\emptyset}
\newcommand{\name}[1]{{\tt #1}}
\newcommand{\sep}{\hspace{.5cm}}
\newcommand{\sm}{\setminus\!\!\!\setminus}
\newcommand{\tr}{\triangleright}

\newcommand{\iI}{i \in I}
\newcommand{\jJ}{j \in J}
\newcommand{\kK}{k \in K}
\newcommand{\ih}{{\it i.h.}\xspace}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\Eg}{\textit{E.g.}}

\newcommand{\tim}{\times}
\newcommand{\ta}{\Rightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\rra}{\twoheadrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lla}{\twoheadleftarrow}
\newcommand{\La}{\Leftarrow}

\newcommand{\gam}{\gamma}
\newcommand{\lam}{\lambda}
\newcommand{\sig}{\sigma}
\newcommand{\del}{\delta}
\newcommand{\sdel}{\hat{\del}}
\newcommand{\kap}{\kappa}
\newcommand{\Gam}{\Gamma}
\newcommand{\Del}{\Delta}

%% Misc.

\newcommand{\exampleautorefname}{Ex.}%
\renewcommand{\sectionautorefname}{Sec.}%
\renewcommand{\subsectionautorefname}{Subsec.}%
\renewcommand{\subsubsectionautorefname}{Subsubsec.}%
\renewcommand{\paragraphautorefname}{Par.}%
\renewcommand{\theoremautorefname}{Thm.}%
\newcommand{\lemmaautorefname}{Lem.}%
\newcommand{\corollaryautorefname}{Cor.}%
\newcommand{\remarkautorefname}{Rem.}%
\newcommand{\definitionautorefname}{Def.}%
\newcommand{\propositionautorefname}{Prop.}%

\newcommand{\val}{{\tt Val}}
\renewcommand{\emph}[1]{{\it #1}}
\newcommand{\id}{{\tt I}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\sn}[1]{\mathcal{SN}(#1)}
\renewcommand{\wn}[1]{\mathcal{WN}(#1)}
\newcommand{\syscbv}{\mathcal{O}}
\newcommand{\sysgs}{\mathcal{P}}

\crefname{definition}{Def.}{Def.}%
\crefname{section}{Sec.}{Sec.}
\crefname{example}{Ex.}{Ex.}
\crefname{figure}{Fig.}{Fig.}
\crefname{proposition}{Prop.}{Prop.}

\newcommand{\cra}{\gg}

\newcommand{\conftype}[2]{#1 \times #2}  % before it was times
\newcommand{\comptype}[2]{#1 \cra #2}  % before it was arrow
\newcommand{\tcomptype}[3]{#1 \cra (#2 \times #3)}  % before it was times

\title{Quantitative Global Memory\thanks{Supported by: National Funds through the Portuguese funding agency, FCT - Fundação para a Ciência e a Tecnologia -, within project LA/P/0063/2020, and the project and individual research grant 2021.04731.BD; Base Funding UIDB/00027/2020 of the Artificial Intelligence and Computer Science Laboratory – LIACC - funded by national funds through the FCT/MCTES (PIDDAC); and Cost Action CA20111 EuroProofNet.}}

\author{
  Sandra Alves
  \inst{1}
  \and
  Delia Kesner
  \inst{2,3}
  \and
  Miguel Ramos
  \inst{4,}\thanks{Corresponding author.}
 % \thanks{Supported by National Funds through the Portuguese funding agency, FCT - Fundação para a Ciência e a Tecnologia, through the}
 }

\institute{
  CRACS/INESC-TEC, DCC, Faculdade de Ciências, Universidade do Porto \\
  Rua do Campo Alegre s/n, 4169–007 Porto, Portugal
  \and
  Universit\'e Paris Cit\'e, CNRS, IRIF \\
  \and
  Institut Universitaire de France \\
  \and
  LIACC, DCC, Faculdade de Ciências, Universidade do Porto \\
  Rua do Campo Alegre s/n, 4169–007 Porto, Portugal
}

\authorrunning{Alves, Kesner and Ramos}
\titlerunning{A Quantitative Model for a Language with Global Memory}

\begin{document}

\maketitle

%\input{abstract}
\begin{abstract}
  We show that recent approaches to static analysis based on quantitative typing systems can be extended to programming languages with global state. More precisely, we define a call-by-value language equipped with operations to access a global memory, together with  a semantic model based on a (tight) multi-type system that captures exact measures of time and space related to evaluation of programs. We show that the type system is quantitatively sound and complete with respect to the operational semantics of the language.
\end{abstract}

\setcounter{tocdepth}{2}
%{\small \tableofcontents}

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%------------------------------------------------------------------------------

%\input{introduction}
\section{Introduction}

The aim of this paper is to extend \emph{quantitative} techniques of {\it static analysis} based on \emph{multi-types} to programs with {\it effects}.

{\bf Effectful Programs.} Programming languages produce different kinds of \emph{effects} (observable interactions with the environment),  such as handling exceptions, read/write from a global memory outside its own scope, using a database or a file, performing non-deterministic choices, or sampling from probabilistic distributions. The degree to which these side effects are used depends on each programming paradigm~\cite{Jones1993} (imperative programming makes use of them while declarative programming does not). In general, avoiding the use of side effects facilitates the formal verification of programs, thus allowing to (statically) ensure their correctness. For example, the functional language Haskell eliminates side effects by replacing them with {\it monadic} actions, a clean approach that continues to attract growing attention. Indeed, rather than writing a function that returns a raw type, an effectful function returns a raw type inside a useful wrapper -- and that wrapper is a monad~\cite{Wadler1993}. This approach allows programming languages to combine the qualities of both the imperative and declarative worlds: programs produce effects, but these are encoded in such a way that formal verification can be performed very conveniently.

{\bf Quantitative Properties.} We address quantitative properties of programs with effects using {\it multi-types}, which originate in the theory of \emph{intersection} type  systems. They extend simple types with a new constructor $\cap$ in such a way that a program $t$ is typable with $\sigma \cap \tau$ if $t$ is typable with both types $\sigma$ and $\tau$ independently. Intersection types were first introduced as \emph{models} capturing computational properties of functional programming in a broader sense~\cite{CDC78}. For example, termination of different evaluation strategies can be characterized by typability in some appropriate intersection type system: a program $t$ is terminating if and only if $t$ is typable. Originally, intersection enjoys associativity, commutativity, and in particular idempotency (\ie\ $\sigma \cap \sigma = \sigma$). By switching to a \emph{non-idempotent} intersection constructor, one naturally comes to represent types by multisets, which is why they are called multi-types. Just like their idempotent precursors, multi-types still allow for a characterization of several operational properties of programs, but they also grant a substantial improvement: they provide  quantitative measures about these properties. For example, it is still possible to prove that a program is terminating if and only if it is typable, but now an {\it upper bound} or {\it exact measure} for the time needed for its evaluation length can be derived from the typing derivation of the program. This shift of perspective, from idempotent to non-idempotent types, goes beyond lowering the logical complexity of the proof: the quantitative information provided by typing derivations in the non-idempotent setting unveils crucial quantitative relations between typing (static) and reduction (dynamic) of programs.

{\bf Upper Bounds and Exact Split Measures.} Multi-types are extensively used to reason about programming languages from a quantitative point of view, as pioneered by de Carvalho \cite{deCarvalho2007,deCarvalho2018}. For example, they are able to provide \emph{upper bounds}, in the sense that the evaluation length of a program $t$ {\it plus} the size of its result (called {\it normal form}) can be bounded by the size of the type derivation of $t$. A major drawback of this approach, however, is that the size of normal forms can be exponentially bigger than the length of the evaluation reaching those normal forms. This means that bounding the sum of these two natural numbers at the same time is too rough, and not very relevant from a quantitative point of view. Fortunately, it is possible to extract better measures from a multi-type system. A crucial point to obtain \emph{exact measures}, instead of upper bounds, is to consider minimal type derivations, called \emph{tight derivations}. Moreover, using appropriate refined tight systems it is also possible to obtain \emph{independent} measures (called exact \emph{split} measures) for {\it length} and for {\it size}. More precisely, the quantitative typing systems\footnote{In this paper, by quantitative types we mean non-idempotent intersection types. Another meaning can be found in~\cite{Atkey18}.} are now equipped with constants and counters, together with an appropriate notion of tightness, which encodes minimality of type derivations. For any tight type derivation $\Phi$ of a program $t$ with counters $b$ and $d$, it is now possible to show that $t$ evaluates to a normal form of size $d$ in exactly $b$ steps. Therefore, the type system is not only \emph{sound}, \ie\ it is able to {\it guess} the number of steps to normal form as well as the size of this normal form, but the opposite direction providing \emph{completeness} of the approach also holds.

{\bf Contribution.} The focus of this paper is on effectful computations, such as reading and writing on a global memory able to hold values in cells. Taking inspiration from the monadic approach adopted in~\cite{deLiguoroT21}, we design a tight quantitative type system that provides exact split measures. More precisely, our system is not only capable of discriminating between length of evaluation to normal form and size of the normal form, but the measure corresponding to the length of the evaluation is split into two different natural numbers: the first one corresponds to the length of standard computation ($\beta$-reduction) and the second one to the number of memory accesses. We show that the system is sound \ie\ for any tight type derivation $\Phi$ of $t$ ending with counters $(b,m,d)$, the term $t$ is normalisable by performing $b$ evaluation steps and $m$ memory accesses, yielding a normal form having size $d$. The opposite direction, giving completeness of the model, is also proved.

In order to  gradually present the material, we first develop the technique for a weak (open) call-by-value (CBV) calculus, which can be seen as a contribution per se, and then we encapsulate these preliminary ideas in the  general framework of the language with global state.

{\bf Summary.} \cref{s:wocbv} illustrates the technique on a weak (open) CBV calculus. We then lift the technique to the $\lam$-calculus with global state in \cref{s:lambda-calculus-with-state} by following the same methodology. More precisely, \cref{s:syntax-gs} introduces the $\lamcc$-calculus, \cref{s:typing-system-gs}  defines a  quantitative type system $\sysgs$. Soundness and completeness of $\sysgs$ w.r.t. $\lamcc$ are proved in \cref{s:sound-complete-lambda-gs}. We conclude and discuss related work in \cref{s:conclusion}. In~\cref{sec:proofs}, we include some additional propositions and lemmas, as well as all the proofs in full detail.

{\bf Preliminary General Notations.} We start with some general notations. Given a (one-step) reduction relation $\red[\rel]$, $\redn[\rel]$ denotes the reflexive-transitive closure of $\red[\rel]$. We write $t \rred^b u$ for a reduction sequence from $t$ to $u$ of length $b$. A term $t$ is said to be (1) in \defn{$\rel$-normal form} (written $t \not \red[\rel]$) iff there is no $u$ such that $t \red[\rel] u$, and (2) \defn{$\rel$-normalizing} iff there is some $\rel$-normal form $u$ such that $t \redn[\rel] u$. The reduction relation $\rel$ is normalizing iff every term is $\rel$-normalizing.

%\input{plotkin}
\section{Weak Open CBV}
\label{s:wocbv}

In this section we first introduce the technique of tight typing on a simple language without effects, the weak open CBV. \cref{s:syntax-wocbv} defines the syntax and operational semantics of the language, \cref{s:types-for-wocbv} presents the tight typing system $\syscbv$ and discusses soundness and completeness of $\syscbv$ w.r.t. the CBV language.

\subsection{Syntax and Operational Semantics}
\label{s:syntax-wocbv}

Weak open CBV is based on two principles: reduction is \emph{weak} (not performed inside abstractions), and terms are \emph{open} (may contain free variables). \defn{Value}, \defn{terms} and \defn{weak contexts} are given by the following grammars, respectively:
\[ v, w  ::=  x \mid \lam x.t \qquad t, u, p ::= v \mid t u \qquad \W ::= \square \mid \W t \mid t \W \]

We write $\val$ for the set of all values. Symbol $\id$ is used to denote the identity function $\lam z.z$.

The sets of \defn{free} and \defn{bound} variables of terms and the notion of $\alpha$-conversion are defined as usual. A term $t$ is said to be \defn{closed} if $t$ does not contain any free variable, and \defn{open} otherwise. The \defn{size of a term $t$}, denoted $\size{t}$, is given by: $\size{x} = \size{\lam x.t} = 0$; and $\size{t u} = 1 + \size{t} + \size{u}$. Since our reduction relation is weak, \ie, reduction does not occur in the body of abstractions, we assign size zero to abstractions.

We now introduce the operational semantics of our language, which models the core behavior of  programming languages such as OCaml, where CBV evaluation is \emph{weak}. The \defn{deterministic reduction relation} (written $\dred$), is given by the following rules:
\[ \begin{array}{l@{\sep}l@{\sep}l}
        \begin{prooftree}
        \hypo{\phantom{DDDD}}
        \infer1[(\ruleBeta)]{(\lam x.t) v \dred t \subs{x}{v}}
    \end{prooftree} & 
    \begin{prooftree}
        \hypo{t \dred t'}
        \infer1[(\ruleAppL)]{t u \dred t' u}
    \end{prooftree} & 
    \begin{prooftree}
        \hypo{t \not\dred}
        \hypo{u \dred u'}
        \infer2[(\ruleAppR)]{t u \dred t u'}
    \end{prooftree}
\end{array} \]

\defn{Terms in $\dred$-normal form} can be characterized by the following grammars: $\normal  ::=  \val  \mid \neutral$ and $\neutral ::=  x \ \normal \mid \normal \ \neutral \mid \neutral \ \normal$.

\begin{restatable}[]{proposition}{propcharnfs}
    \label{prop:char-nfs}
    Let $t$ be a term. Then  $t \in \normal$  iff $t \not\dred$. 
\end{restatable}

In closed CBV~\cite{Plotkin1975} (only reducing closed terms), abstractions are the only normal forms, but in open CBV, the following terms turn out to be also acceptable normal forms: $x y$, $x (\lam y.y (\lam z.z))$ and $(\lam x.x) (y (\lam z.z))$.

\subsection{A Quantitative Type System for the Weak Open CBV}
\label{s:types-for-wocbv}

The \emph{untyped} $\lam$-calculus can be interpreted as a \emph{typed} calculus with a single type $D$, where $D = D \ta D$~\cite{Treglia22}. Applying Girard's~\cite{Girard87} \textit{``boring''} CBV translation of intuitionistic logic into linear logic, we get $D =\ !D \multimap\ !D$~\cite{Accattoli15}. Type system $\syscbv$ is built having this equation in mind.

The \defn{set of types} is given by the following grammar:
\[ \begin{array}{lrcl}
    \textbf{(Tight Constants)} & \tightt & ::= & \tvar \mid \tabs \mid \tneutral \\
    \textbf{(Value Types)} & \sig & ::= & \tvar \mid \tabs \mid \M \mid \M \ta \tau \\
    \textbf{(Multi-Types)} & \M & ::= & \mul{\sig_i}_{\iI} \ \text{where $I$ is a finite set} \\
    \textbf{(Types)} & \tau & ::= & \tneutral \mid \sig
\end{array} \]

Tight constants are minimal types assigned to terms reducing to normal forms ($\tvar$ for persistent variables, $\tabs$ for abstractions or variables that are going to be replaced by abstractions, and $\tneutral$ for neutral terms). Given an arbitrary tight constant $\tightt_0$, we write $\nott{\tightt_0}$ to denote all the other tight constants in $\tightt$ different from $\tightt_0$. Multi-types are multisets of value types. A \defn{(typing) environment}, written $\Gam, \Del$, is a function from variables to multi-types, assigning the empty multi-type $\emul$  to all but a finite set of variables. The domain of $\Gam$ is $\dom{\Gam} \defeq \{x \mid \Gam(x) \not= \emul\}$. The \defn{union} of environments, written $\Gam + \Del$, is defined by $(\Gam + \Del)(x) = \Gam(x) \sqcup \Del(x)$, where $\sqcup$ denotes \defn{multiset union}. An example is $(x : \mul{\sig_1}, y : \mul{\sig_2}) + (x : \mul{\sig_1}, z : \mul{\sig_2}) = (x : \mul{\sig_1, \sig_1}, y : \mul{\sig_2}, z : \mul{\sig_2})$. This notion is extended to a finite union of environments, written $+_{\iI} \Gam_i$ (the empty environment is obtained when $I = \eset$). We write $\Gam \sm x$ for the  environment $(\Gam \sm x)(x) = \emul$ and $(\Gam \sm x)(y) = \Gam(y)$ if $y \not= x$ and we  write $\Gam; x : \M$ for $\Gam + (x : \M)$, when $x \not\in \dom{\Gam}$. Notice that $\Gam$ and $\Gam; x:\emul$ are the same environment. 

A \defn{judgement} has the form $\seqi{\Gam}{t}{\tau}{(b,s)}$, where $b$ and $s$ are two natural numbers, representing, respectively,  the number of $\beta$-steps needed to normalize $t$, and the size of the normal form of $t$. The \defn{typing system $\syscbv$} is defined by the rules in~\cref{fig:typingruleslamop}. We write $\tr \seqi{\Gam}{t}{\tau}{(b,s)}$ if there is a (tree) \defn{type derivation} of the judgement $\seqi{\Gam}{t}{\tau}{(b,s)}$ using the rules of system $\syscbv$. The term $t$ is \defn{$\syscbv$-typable} (we may omit the name $\syscbv$) iff there is an environment  $\Gam$, a type $\tau$ and counters $(b,s)$ such that $\tr \seqi{\Gam}{t}{\tau}{(b,s)}$. We use letters $\Phi, \Psi, \dots$ to name type derivations, by writing for example $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$.

\begin{figure}[h!]
    \[ \begin{array}{c}
        \begin{prooftree}
            \hypo{\phantom{DDDDD}}
            \infer1[(\ruleAx)]{\seqi{x : \mul{\sig}}{x}{\sig}{(0,0)}}
        \end{prooftree}
        \sep 
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tau}{(b,s)}}
            \infer1[(\ruleLam)]{\seqi{\Gam \sm x}{\lam x.t}{\Gam(x) \ta \tau}{(b, s)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\M \ta \tau}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\M}{(b',s')}}
            \infer2[(\ruleApp)]{\seqi{\Gam + \Del}{t u}{\tau}{(1+b+b',s+s')}}
        \end{prooftree} 
        \sep
        \begin{prooftree}
            \hypo{(\seqi{\Gam_i}{v}{\sig_i}{(b_i,s_i)})_{\iI}}
            \infer1[(\ruleMany)]{\seqi{+_{\iI} \Gam_i}{v}{\mul{\sig_i}_{\iI}}{(+_{\iI} b_i, +_{\iI} s_i)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\phantom{UUUUU}}
            \infer1[(\ruleLamP)]{\seqi{}{\lam x.t}{\tabs}{(0,0)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\nott{\tabs}}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\tightt}{(b',s')}}
            \infer2[(\ruleAppPOne)]{\seqi{\Gam + \Del}{t u}{\tneutral}{(b+b',1+s+s')}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tightt}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\tneutral}{(b',s')}}
            \infer2[(\ruleAppPTwo)]{\seqi{\Gam + \Del}{t u}{\tneutral}{(b+b',1+s+s')}}
        \end{prooftree}
    \end{array} \]
    \caption{Typing Rules of System $\syscbv$}
    \label{fig:typingruleslamop}
  \end{figure}
  
Notice that in rule (\ruleAx) of \cref{fig:typingruleslamop} variables can only be assigned value types $\sig$ (in particular no type $\tneutral$): this is because they can only be substituted by values. Due to this fact, multi-types only contain value types. Regarding typing rules (\ruleAx), (\ruleLam), (\ruleApp), and (\ruleMany), they are the usual rules for non-idempotent intersection types~\cite{Bucciarelli2017}. Rules (\ruleLamP), (\ruleAppPOne), and (\ruleAppPTwo) are used to type \emph{persistent} symbols, \ie\ symbols that are not going to be \emph{consumed} during evaluation. More specifically, rule (\ruleLamP) types abstractions (with type $\tabs$) that are normal regardless of the typability of its body. Rule (\ruleAppPOne) types applications that will never reduce to an abstraction on the left (thus of any tight constant that is not $\tabs$, \ie\ $\nott{\tabs}$), while any term reducing to a normal form is allowed on the right (of tight constant $\tightt$). Rule (\ruleAppPTwo) also types applications, but when values will never be obtained on the right (only neutral terms of type $\tneutral$). Rule (\ruleAx) is also used to type persistent variables, in  particular when $\sig \in \{ \tvar, \tabs\}$.

A \defn{type} $\tau$ is \defn{tight} if $\tau \in \tightt$. We write $\tightp{\M}$, if every $\sig \in \M$ is tight. A \defn{type environment} $\Gam$ is \defn{tight} if it assigns tight multi-types to all variables. A \defn{type derivation} $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$ is \defn{tight} if $\Gam$ and $\tau$ are both tight.

\begin{example}
    \label{ex:plotkintypederiv}
    Let $t = (\lam x.(xx) (y y)) (\lam z.z)$. Let $\Phi$ be the following typing derivation:
    {\small \[ \begin{prooftree}
        \infer0[(\ruleAx)]{\seqi{x : \mul{\mul{\tabs} \ta \tabs}}{x}{\mul{\tabs} \ta \tabs}{(0,0)}}
        \infer0[(\ruleAx)]{\seqi{x : \mul{\tabs}}{x}{\tabs}{(0,0)}}
        \infer1[(\ruleMany)]{\seqi{x : \mul{\tabs}}{x}{\mul{\tabs}}{(0,0)}}
        \infer2[(\ruleApp)]{\seqi{x : \mul{\mul{\tabs} \ta \tabs, \tabs}}{xx}{\tabs}{(1,0)}}
    \end{prooftree} \]}
    And $\Psi$ be the following typing derivation:
    {\small \[ \begin{prooftree}
        \hypo{\Phi}
        \infer0[(\ruleAx)]{\seqi{y : \mul{\tvar}}{y}{\tvar}{(0,0)}}
        \infer0[(\ruleAx)]{\seqi{y : \mul{\tvar}}{y}{\tvar}{(0,0)}}
        \infer2[(\ruleAppPOne)]{\seqi{y : \mul{\tvar, \tvar}}{yy}{\tneutral}{(0,1)}}
        \infer2[(\ruleAppPTwo)]{\seqi{x : \mul{\mul{\tabs} \ta \tabs, \tabs}, y : \mul{\tvar, \tvar}}{(xx) (yy)}{\tneutral}{(1,1)}}
        \infer1[(\ruleLam)]{\seqi{y : \mul{\tvar, \tvar}}{\lam x.(xx) (yy)}{\mul{\mul{\tabs} \ta \tabs, \tabs} \ta \tneutral}{(1,2)}}
    \end{prooftree} \]}
    Then, we can build the following tight typing derivation $\Phi_t$ for $t$:
    {\small \[ \begin{prooftree}
        \hypo{\Psi}
        \infer0[(\ruleLamP)]{\seqi{z : \mul{\tabs}}{z}{\tabs}{(0,0)}}
        \infer1[(\ruleLam)]{\seqi{}{\lam z.z}{\mul{\tabs} \ta \tabs}{(0,0)}}
        \infer0[(\ruleLamP)]{\seqi{}{\lam z.z}{\tabs}{(0,0)}}
        %\infer1[(\ruleMany)]{\seqi{}{\lam z.z}{\mul{\tabs}}{(0,0)}}
       \infer2[(\ruleMany)]{\seqi{}{\lam z.z}{\mul{\mul{\tabs} \ta \tabs, \tabs}}{(0,0)}}
        \infer2[(\ruleApp)]{\seqi{y : \mul{\tvar, \tvar}}{(\lam x.(xx)(yy)) (\lam z.z)}{\tneutral}{(2,2)}}
    \end{prooftree} \]}
\end{example}

The type system $\syscbv$ can be shown to be \emph{sound} and \emph{complete} w.r.t. the operational semantics $\dred$ introduced in \cref{s:syntax-wocbv}. Soundness means that not only  a \emph{tightly} typable term $t$ is terminating, but also that the \emph{tight}   type derivation of $t$ gives exact and split measures concerning the reduction sequence from $t$ to normal form. More precisely, if $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$ is tight, then there exists $u \in \normal$ such that  $t \drred^b u$ with $\size{u} = s$. Dually for \emph{completeness}. Because we are going to show this kind of properties for the more sophisticated language with global state (\cref{s:sound-complete-lambda-gs}), we do not give here technical details of them. However, we highlight these properties on our previous example.   Consider again term $t$ in \cref{ex:plotkintypederiv} and its tight derivation $\Phi_t$ with counters $(b,s)=(2,2)$. Counter $b$ is different from $0$, so $t \notin \normal$, but $t$ normalizes in two $\betav$-steps ($b = 2$) to a normal form having size $s = 2$. Indeed, $(\lam x.(xx)(yy))(\lam z.z) \red[\betav] ((\lam z.z)(\lam z.z))(yy) \red[\betav] (\lam z.z)(yy)$ and $\size{(\lam z.z)(yy)}=2$.

%\input{calculus}
\section{A \texorpdfstring{$\lambda$}{Lambda}-Calculus with Global State}
\label{s:lambda-calculus-with-state}

Based on the preliminary presentation of \cref{s:wocbv}, we now introduce a $\lam$-calculus with global state following a CBV strategy. \cref{s:syntax-gs} defines the syntax and operational semantics of the $\lam$-calculus with global state. \cref{s:typing-system-gs} presents the tight typing system $\sysgs$, and \cref{s:sound-complete-lambda-gs} shows soundness and completeness.

\subsection{Syntax and Operational Semantics}
\label{s:syntax-gs}

Let $l$ be a location drawn from some set of location names. \defn{Values}, \defn{terms}, \defn{states} and \defn{configurations} of $\lamcc$ are defined respectively as follows:
\[ \begin{array}{rl@{\hspace{0.6cm}}rl}
    v, w & ::= x \mid \lam x.t & t, u, p & ::= v \mid v t \mid \get{l}{x}{t} \mid \set{l}{v}{t} \\
    s, q & ::= \estate \mid \upd{l}{v}{s} & c & ::= (t, s)
\end{array} \]

Notice that applications are restricted to the form $vt$. This, combined with the use of a deterministic reduction strategy based on weak contexts, ensures that composition of effects is well behaved. Indeed, this kind of restriction is usual in computational calculi~\cite{Moggi1989,Sabry1997,deLiguoroT21,Faggian2021}.

Intuitively, operation $\get{l}{x}{t}$ interacts with the global state by retrieving the value stored in location $l$ and binding it to variable $x$ of the continuation $t$. And operation $\set{l}{v}{t}$ interacts with the state by storing value $v$ in location $l$ and (possibly) overwriting whatever was previously stored there, and then returns $t$.

The  size function is extended to states and configurations: $\size{s}:=0$, and $\size{(t,s)}: = \size{t}$. The update constructor is commutative in the following sense:
\[ \begin{array}{rclr}
        \upd{l}{v}{\upd{l'}{w}{s}} & \eqstate & \upd{l'}{w}{\upd{l}{v}{s}} \text{ if $l \not= l'$}
\end{array} \]
We denote by $\equivstate$ the equivalence relation generated by the axiom $\eqstate$. \label{def:domainS} We write \defn{$l \in \dom{s}$}, if $s \equivstate \upd{l}{v}{q}$, for some value $v$ and state $q$.
Moreover, these $v$ and $q$ are \emph{unique}. For example, if $l_1 \neq l_2$, then $s_1 = \upd{l_1}{v_1}{\upd{l_2}{v_2}{q}} \equivstate \upd{l_2}{v_2}{\upd{l_1}{v_1}{q}} = s_2 $, but $\upd{l_1}{v_1}{\upd{l_1}{v_2}{s}} \not\equivstate \upd{l_1}{v_2}{\upd{l_1}{v_1}{s}}$.
As a consequence, whenever we want to access the content of a particular location in a state, we can simply assume that the location is at the top of the state.

The operational semantics of the $\lamcc$-calculus is given on configurations. The \defn{deterministic reduction relation} $\gsred$ is defined to be the union of the rules $\red[\gname]\ (\gname \in \{\beta_v, \getname, \setname\})$ below. We write $(t,s) \gsrred^{(b,m)} (u,q)$ if $(t,s)$ reduces to $(u,q)$ in $b$ $\beta_v$-steps and $m$ $\getname/\setname$-steps.
\[ \begin{array}{c}
  \begin{prooftree}
    \hypo{\phantom{BUUUUUUUUU}}
    \infer1[(\ruleBeta)]{((\lam x.t) v,s) \redbetav (t \subs{x}{v},s)}
  \end{prooftree} 
  \sep
  \begin{prooftree}
    \hypo{s \equivstate \upd{l}{v}{q}}
    \infer1[(\ruleGet)]{(\get{l}{x}{t}, s) \redget (t \subs{x}{v}, s)}
  \end{prooftree}
  \\[.5cm]
  \begin{prooftree}
    \hypo{(t, s) \red[\gname] (u, q) \sep \gname \in \{\beta_v, \getname, \setname\}}
    \infer1[(\ruleAppR)]{(v t, s) \red[\gname] (v u, q)}
  \end{prooftree}
  \sep
  \begin{prooftree}
    \hypo{\phantom{BUUUUUUUU}}
    \infer1[(\ruleSet)]{(\set{l}{v}{t}, s) \redset (t, \upd{l}{v}{s})}
  \end{prooftree}
\end{array} \]

Note that in reduction rule (\ruleAppR), the $\gname$ appearing as the name of the reduction rule in the premise is the same as the one appearing in the reduction rule in the conclusion.

\newpage

\begin{example}
  \label{ex:globalstate}
  Consider the configuration $c_0 = ((\lam x.\get{l}{y}{yx}) (\set{l}{\id}{z}), \estate)$. Then we can reach an irreducible configuration as follows:
  \[ \begin{array}{c}
    ((\lam x.\get{l}{y}{yx}) (\set{l}{\id}{z}), \estate) \redget ((\lam x.\get{l}{y}{yx}) z, \upd{l}{\id}{\estate})
    \\
    \redbetav (\get{l}{y}{yz}, \upd{l}{\id}{\estate}) \redget (\id z, \upd{l}{\id}{\estate}) \redbetav (z, \upd{l}{\id}{\estate})
  \end{array} \]
\end{example}

A configuration $(t,s)$ is said to be \defn{blocked} if either $t = \get{l}{x}{u}$ and $l \not\in \dom{s}$; or $t = v u$ and $(u,s)$ is blocked. A configuration is \defn{unblocked} if it is not blocked.
As an example, $(\get{l}{x}{x}, \estate)$ is obviously blocked. As a consequence, the following configuration reduces to a blocked one: $((\lam y.y\ \get{l}{x}{x}) z, \estate) \red (z\ \get{l}{x}{x}, \estate)$.
This suggests a notion of \defn{final configuration}: $(t,s)$ is \defn{\final}\ if either $(t, s)$ is blocked; or $t \in \normal$, where \defn{neutral} and \defn{normal} terms are given respectively by the grammars $\neutral ::= x \ \normal \mid (\lam x.t) \ \neutral$ and $\normal ::= \val  \mid \neutral$.

\begin{restatable}[]{proposition}{propnormalifffinal}
    \label{prop:normal-iff-final}
    Let $(t,s)$ be a configuration. Then $(t,s)$ is \final\ iff $(t,s) \not\ra$.
\end{restatable}

Notice that when $(t,s)$ is  an unblocked final configuration, then $t \in \normal$. These are the configurations  captured by the typing system $\sysgs$ in \cref{s:typing-system-gs}. 
Consider the final configurations $c_0=(\get{l}{x}{x}, \estate)$, $c_1=(z\ \get{l}{x}{x}, \estate)$, $c_2= (y, s)$ and $c_3=((\lam x.x) (yz), s)$. Then $c_0$ and $c_1$ are blocked, while $c_2$ and $c_3$ are unblocked.

%\input{typing}
\subsection{A Quantitative Type System for the \texorpdfstring{$\lamcc$}{LambdaCC}-calculus}
\label{s:typing-system-gs}

We now introduce the quantitative type system $\sysgs$ for $\lamcc$. To deal with global states, we extend the language of types with the notions of state, configuration and monadic types. To do this, we translate linear arrow types according to Moggi's~\cite{Moggi1989} CBV interpretation of reflexive objects in the category of $\lam_c$-models: $D =\ !D \multimap\ !D$ becomes $D =\ !D \multimap\ T(!D)$, where $T$ is a monad. Type system $\sysgs$ was built having this equation in mind, similarly to what was done in~\cite{GTV23}.

The \defn{set of types} is given by the following grammar:
\[ \begin{array}{lrcl}
    \textbf{(Tight Constants)} & \tightt & ::= & \tvar \mid \vl \mid \tneutral \\
    \textbf{(Value Types)} & \sig & ::= & \tvar \mid \vl \mid \M \mid \M \ta \del \\
    \textbf{(Multi-types)} & \M & ::= & \mul{\sig_i}_{\iI} \ \text{where $I$ is a finite set} \\
    \textbf{(Liftable Types)} & \mu & ::= & \tvar \mid \vl \mid \M \\
    \textbf{(Types)} & \tau & ::= & \tneutral \mid \sig \\
    \textbf{(State Types)} & \stype & ::= & \conj{(l_i : \M_i)}_{\iI} \mbox{ where all } l_i \mbox{ are distinct} \\
    \textbf{(Configuration Types)} & \ctype & ::= & \conftype{\tau}{\stype} \\
    \textbf{(Monadic Types)} & \del & ::= & \comptype{\stype}{\ctype} \\
\end{array} \]

In system $\sysgs$, the minimal types to be assigned to normal forms distinguish between variables  ($\tvar$), abstractions ($\vl$), and neutral terms ($\tneutral$). A \defn{multi-type} is a multi-set of value types. A \defn{state type} is a partial function mapping labels to (possibly empty) multi-types. A \defn{configuration type} is a product type, where the first component is a type and the second is a state type. A \defn{monadic type} associates a state type to a configuration type.  We use symbol $\gtype$ to denote a value type or a monadic type. \defn{Typing environments} and operations over types are defined in the same way as in system $\syscbv$.

The \defn{domain} of a state type $\stype$ is the set of all its labels, \ie\ $\dom{\stype} := \{ l \mid (l:\M) \in \stype \}$. Also, when $l \in \dom{\stype}$, \ie\ $(l : \M) \in \stype$, we write $\stype(l)$ to denote $\M$. The \defn{union of state types} is defined as follows: 
\begin{align*}
    (\stype \splus \stype')(l) = & \text{ if $(l : \M) \in \stype$ then (if $(l : \M') \in \stype'$ then $\M \sqcup \M'$ else $\M$)} \\ 
                            & \text{ else (if $(l : \M') \in \stype'$ then $\M'$ else \undefined)}
\end{align*}

\begin{example}
    Let $\stype = \{(l_1 : \mul{\sig_1, \sig_2}), (l_2 : \mul{\sig_1})\} \splus \{(l_2 : \mul{\sig_1, \sig_2}), (l_3 : \mul{\sig_3})\}$. Then,
    $\stype(l_1) = \mul{\sig_1,\sig_2}$,
    $\stype(l_2) = \mul{\sig_1, \sig_1, \sig_2}$,
    $\stype(l_3) = \mul{\sig_3}$,
    and $\stype(l) = \undefined$, 
    assuming $l \not= l_i$, for $i \in \{1,2,3\}$.
\end{example}
  
Notice that $\dom{\stype\splus \stype'} = \dom{\stype} \cup \dom{\stype'} $. Also  $\conj{(l : \emul)} \splus \stype \not= \stype$, if $l \not\in \dom{\stype}$, while $x:\emul; \Gam  = \Gam$. Indeed, typing environments are total functions, where variables mapped to $\emul$ do not occur in  typed programs. In contrast, states are partial functions, where labels  mapped to $\emul$ correspond to positions in memory that are accessed (by get or set), but ignored/discarded by the typed program. We use $\conj{(l : \M)}; \stype$ for $\conj{(l : \M)} \splus \stype$ if $l \not\in \dom{\stype}$.

A \defn{term type judgement} {(resp. \defn{state type judgment} and \defn{configuration type judgment})} has the form $\seqi{\Gam}{t}{\gtype}{(b,m,d)}$ (resp. $\seqi{\Gam}{s}{\stype}{(b,m,d)}$ and $\seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$) where $b,m,d$ are three natural numbers, the first and second representing, respectively, the number of $\beta$-steps and $\getname/\setname$-steps needed to normalize $t$, and the third representing the size of the normal form of $t$. The \defn{typing system $\sysgs$} is defined by the rules in~\cref{fig:typingruleslamcc}. We write $\tr \mathcal{J}$ if there is a type derivation of the judgement $\mathcal{J}$ using the rules of system $\sysgs$. The term $t$  (resp. state $s$, configuration $(t,s)$) is \defn{$\sysgs$-typable} iff there is an environment  $\Gam$, a type $\gtype$ (resp. $\stype$, $\ctype$) and counters $(b,m,d)$ such that $\tr \seqi{\Gam}{t}{\gtype}{(b,m,d)}$ (resp. $\tr \seqi{\Gam}{s}{\stype}{(b,m,d)}$, $\tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$). As before, we use letters $\Phi, \Psi, \dots$ to name type derivations.

Rules (\ruleAx), (\ruleLam), (\ruleMany), and (\ruleApp) are essentially the same as in~\cref{fig:typingruleslamop}, but with types lifted to monadic types (\ie\ \emph{decorated} with state types). 
Rule (\ruleApp) assumes a value type associated to a value $v$ on the left premise and a monadic type associated to a term $t$  on the right premise. To type the  application $vt$, it is necessary to match both the value type $\M$ inside the type of $t$ with the input value type of $v$, and the output state type $\stype'$ of $t$ with the input state type of $v$. Rule (\ruleLift) is used to lift multi-types or tight constants $\tvar$ and $\tabs$ (the type of values) to monadic types. Rules (\ruleGet) and (\ruleSet) are used to type operations over the state. Rule (\ruleEmp) types empty states, rule (\ruleUpd) types states, and (\ruleConf) types configurations.

A \defn{type} $\tau$ is \defn{tight}, if $\tau \in \tightt$. We write \defn{$\tightp{\M}$} if every $\rdel \in \M$ is tight. A \defn{state type $\stype$} is \defn{tight} if $\tightp{\stype(l)}$ holds for all $l \in \dom{\stype}$. A \defn{configuration type $\conftype{\tau}{\stype}$} is \defn{tight}, if $\tau$ and $\stype$ are tight. A monadic type $\comptype{\stype}{\ctype}$ is \defn{tight}, if $\ctype$ is tight. The notion of tightness of type derivations is defined in the same way as in system $\syscbv$, \ie\ a \defn{type derivation} $\Phi$ is \defn{tight} if the type environment and the type of the conclusion of $\Phi$ are tight.

\begin{figure}[h]
    \[ \begin{array}{c}
        \mbox{\bf Rules for Terms}
        \\[.2cm]
        \begin{prooftree}
            \hypo{\phantom{AAAAA}}
            \infer1[(\ruleAx)]{\seqi{x : \mul{\rdel}}{x}{\rdel}{(0,0,0)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\mu}{(b,m,d)}}
            \infer1[(\ruleLift)]{\seqi{\Gam}{v}{\tcomptype{\stype}{\mu}{\stype}}{(b,m,d)}}
        \end{prooftree}
        \\[.5cm]
        \hspace{-.4cm}
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \infer1[(\ruleLam)]{\seqi{\Gam \sm x}{\lam x.t}{\Gam(x) \ta (\comptype{\stype}{\ctype})}{(b,m,d)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{(\seqi{\Gam_i}{v}{\rdel_i}{(b_i,m_i,d_i)})_{\iI}}
            \infer1[(\ruleMany)]{\seqi{+_{\iI} \Gam_i}{v}{\mul{\rdel_i}_{\iI}}{(+_{\iI} b_i, +_{\iI} m_i, +_{\iI} d_i)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M \ta (\comptype{\stype'}{\ctype})}{(b,m,d)}}
            \hypo{\seqi{\Del}{t}{\tcomptype{\stype}{\M}{\stype'}}{(b',m',d')}}
            \infer2[(\ruleApp)]{\seqi{\Gam + \Del}{v t}{\comptype{\stype}{\ctype}}{(1+b+b',m+m',d+d')}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \infer1[(\ruleGet)]{\seqi{\Gam \sm x}{\get{l}{x}{t}}{\comptype{\conj{(l : \Gam(x))} \splus \stype}{\ctype}}{(b,1+m,d)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M}{(b,m,d)}}
            \hypo{\seqi{\Del}{t}{\comptype{\conj{(l : \M)}; \stype}{\kap}}{(b',m',d')}}
            \infer2[(\ruleSet)]{\seqi{\Gam + \Del}{\set{l}{v}{t}}{\comptype{\stype}{\kap}}{(b+b',1+m+m',d+d')}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\phantom{text}}
            \infer1[(\ruleLamP)]{\seqi{}{\lam x.t}{\vl}{(0,0,0)}}
        \end{prooftree}
        \\[.5cm]
        \hspace{-.4cm}
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tcomptype{\stype}{\tightt}{\stype'}}{(b,m,d)}}
            \infer1[(\ruleAppPOne)]{\seqi{(x : \mul{\tvar}) + \Gam}{x t}{\tcomptype{\stype}{\tneutral}{\stype'}}{(b,m,1+d)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{u}{\tcomptype{\stype}{\tneutral}{\stype'}}{(b,m,d)}}
            \infer1[(\ruleAppPTwo)]{\seqi{\Gam}{(\lam x.t) u}{\tcomptype{\stype}{\tneutral}{\stype'}}{(b,m,1+d)}}
        \end{prooftree}
        \\[.5cm]     
        \mbox{\bf Rules for States}  
        \\[.2cm]
        \begin{prooftree}
            \hypo{\phantom{text}}
            \infer1[(\ruleEmp)]{\seqi{}{\estate}{\eset}{(0,0,0)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M}{(b,m,d)}}
            \hypo{\seqi{\Del}{s}{\stype}{(b',m',d')}}
            \infer2[(\ruleUpd)]{\seqi{\Gam + \Del}{\upd{l}{v}{s}}{\conj{(l : \M)}; \stype}{(b+b',m+m',d+d')}}
        \end{prooftree}    
        \\[.5cm]
        \mbox{\bf Rule for Configurations}
        \\[.2cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \hypo{\seqi{\Del}{s}{\stype}{(b',m',d')}}
            \infer2[(\ruleConf)]{\seqi{\Gam + \Del}{(t, s)}{\ctype}{(b+b',m+m',d+d')}}
        \end{prooftree}
    \end{array} \]
    \caption{Typing Rules for $\lamcc$.}
    \label{fig:typingruleslamcc}
\end{figure}

\begin{example}
    Consider configuration $c_0$ from~\cref{ex:globalstate}. Let $\M = \mul{\mul{\tvar} \ta \tcomptype{\eset}{\tvar}{\eset}}$, and $\Phi$ be the following typing derivation:
    {\small \[ \begin{prooftree}
        \infer0[(\ruleAx)]{\seqi{y : \M}{y}{\mul{\tvar} \ta \tcomptype{\eset}{\tvar}{\eset}}{(0,0,0)}}
        \infer0[(\ruleAx)]{\seqi{x : \mul{\tvar}}{x}{\tvar}{(0,0,0)}}
        \infer1[(\ruleMany)]{\seqi{x : \mul{\tvar}}{x}{\mul{\tvar}}{(0,0,0)}}
        \infer1[(\ruleLift)]{\seqi{x : \mul{\tvar}}{x}{\tcomptype{\eset}{\mul{\tvar}}{\eset}}{(0,0,0)}}
        \infer2[(\ruleApp)]{\seqi{y : \M, x : \mul{\tvar}}{yx}{\tcomptype{\eset}{\tvar}{\eset}}{(1,0,0)}}
        \infer1[(\ruleGet)]{\seqi{x : \mul{\tvar}}{\get{l}{y}{yx}}{\tcomptype{\conj{(l : \M)}}{\tvar}{\eset}}{(1,1,0)}}
        \infer1[(\ruleLam)]{\seqi{}{\lam x.\get{l}{y}{yx}}{\mul{\tvar} \ta (\tcomptype{\conj{(l : \M)}}{\tvar}{\eset})}{(1,1,0)}}
    \end{prooftree} \]}
    And $\Phi'$ be the following typing derivation:
    {\small \[ \hspace*{-7pt} \begin{prooftree}
            \infer0[(\ruleAx)]{\seqi{x : \mul{\tvar}}{x}{\tvar}{(0,0,0)}}
            \infer1[(\ruleLift)]{\seqi{x : \mul{\tvar}}{x}{\tcomptype{\eset}{\tvar}{\eset}}{(0,0,0)}}
            \infer1[(\ruleLam)]{\seqi{}{\id}{\mul{\tvar} \ta \tcomptype{\eset}{\tvar}{\eset}}{(0,0,0)}}
            \infer1[(\ruleMany)]{\seqi{}{\id}{\M}{(0,0,0)}}
            \infer0[(\ruleAx)]{\seqi{z : \mul{\tvar}}{z}{\tvar}{(0,0,0)}}
            \infer1[(\ruleMany)]{\seqi{z : \mul{\tvar}}{z}{\mul{\tvar}}{(0,0,0)}}
            \infer1[(\ruleLift)]{\seqi{z : \mul{\tvar}}{z}{\tcomptype{\conj{(l : \M)}}{\mul{\tvar}}{\conj{(l : \M)}}}{(0,0,0)}}
            \infer2[(\ruleSet)]{\seqi{z : \mul{\tvar}}{\set{l}{\id}{z}}{\tcomptype{\eset}{\mul{\tvar}}{\conj{(l : \M)}}}{(0,1,0)}}
    \end{prooftree} \]}
    Then we can build the following tight typing derivation $\Phi_c$ for $c$:
    {\small \[ \begin{prooftree}
        \hypo{\Phi}
        \hypo{\Phi'}
        \infer2[(\ruleApp)]{\seqi{z : \mul{\tvar}}{(\lam x.\get{l}{y}{yx})(\set{l}{\id}{z})}{\tcomptype{\eset}{\tvar}{\eset}}{(1,2,0)}}
        \infer0[(\ruleEmp)]{\seqi{}{\estate}{\eset}{(0,0,0)}}
        \infer2[(\ruleConf)]{\seqi{z : \mul{\tvar}}{((\lam x.\get{l}{y}{yx})(\set{l}{\id}{z}), \estate)}{\conftype{\tvar}{\eset}}{(1,2,0)}}
    \end{prooftree} \]}
    We will come back to this example at the end of~\cref{s:sound-complete-lambda-gs}.
\end{example}

%\input{properties}
\subsection{Soundness and Completeness}
\label{s:sound-complete-lambda-gs}

In this section, we show the main properties of the type system $\sysgs$ with respect to the operational semantics of the $\lam$-calculus with global state introduced in \cref{s:syntax-gs}. The properties of type system $\sysgs$ are similar to the ones for $\syscbv$, but now with respect to configurations instead of terms. \emph{Soundness} does not only state that a (tightly) typable configuration $(t,s)$ is terminating, but also gives exact (and split) measures concerning the reduction sequence from $(t,s)$ to a final form. \emph{Completeness} guarantees that a terminating configuration $(t,s)$ is tightly typable, where the measures of the associated reduction sequence of $(t,s)$ to final form are reflected in the counters of the resulting type derivation of $(t,s)$. This is the first work providing a model for a language with global memory being able to count the number of memory accesses.

We start by noting that type system $\sysgs$ does not type blocked configurations, which is exactly the notion that we want to capture.

\begin{restatable}[]{proposition}{proptypedunblock}
    \label{prop:typed-unblock}
    If $\Phi \tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$, then $(t,s)$ is unblocked.
\end{restatable}

We also show that counters capture the notion of normal form correctly, both for terms and states.

\begin{restatable}[]{lemma}{lemzerocounters} \mbox{}
  \label{lem:zero-counters-size-store}
  \begin{enumerate}
    \item \label{lem:zero-counters} Let $\Phi \tr \seqi{\Gam}{t}{\del}{(0,0,d)}$ be tight. Then, (1) $t \in \normal$ and (2) $d = \size{t}$.
    \item \label{lem:zero-size-store} Let $\Phi \tr \seqi{\Del}{s}{\stype}{(0,0,d)}$ be tight. Then $d = 0$.
  \end{enumerate}
\end{restatable}

In fact, we can show the following stronger property with respect to the counters for the number of $\betav$- and $\getname/\setname$-steps.

\begin{restatable}[]{lemma}{lemzeronfs}
    \label{lem:zero-nfs}
    Let $\Phi \tr \seqi{\Gam}{t}{\del}{(b,m,d)}$ be tight. Then, $b = m = 0$ iff $t \in \normal$.
\end{restatable}

The following property is essential for tight type systems~\cite{Accattoli2020}, and it shows that tightness of types spreads throughout type derivations of neutral terms, just as long as the environments are tight. 

\begin{restatable}[{\bf Tight Spreading}]{lemma}{lemcomtightspreading}
    \label{lem:comp-tight-spreading}
    Let $\Phi \tr \seqi{\Gam}{t}{\tcomptype{\stype}{\tau}{\stype'}}{(b,m,d)}$, such that $\Gam$ is tight. If  $t \in \neutral$, then $\tau \in \tightt$.
\end{restatable}

The two following properties ensure tight typability of final configurations. For that we need to be able to \emph{tightly} type any state, as well as any normal form. In fact, normal forms do not depend on a particular state since they are irreducible, so we can type them with any state type.

\begin{restatable}[{\bf Typability of States and Normal Forms}]{lemma}{typstates} \mbox{}
  \label{lem:typestatesnfs}
  \begin{enumerate}
      \item \label{lem:typ-states} Let $s$ be a state. Then, there exists $\Phi\ \tr \seqi{}{s}{\stype}{(0,0,0)}$ tight.
      \item \label{lem:comp-typ-nfs} Let  $t \in \normal$. Then for any tight $\stype$ there exists $\Phi \tr \seqi{\Gam}{t}{\tcomptype{\stype}{\tightt}{\stype}}{(0,0,d)}$ tight s.t. $d = \size{t}$.
  \end{enumerate}
\end{restatable}

Finally, we state the usual basic properties.

\begin{restatable}[{\bf Substitution} and {\bf Anti-Substitution}]{lemma}{lemcompsubsantisubs} \mbox{}
    \label{lem:comp-subs-antisubs}    
    \begin{enumerate}
        \item {\bf (Substitution)} \label{lem:comp-subs} If $\Phi_t \tr \seqi{\Gam_t; x : \M}{t}{\del}{(b_t,m_t,d_t)}$ and $\Phi_v \tr \seqi{\Gam_v}{v}{\M}{(b_v,m_v,d_v)}$, then $\Phi_{t \subs{x}{v}} \tr \seqi{\Gam_t + \Gam_v}{t \subs{x}{v}}{\del}{(b_t+b_v,m_t+m_v,d_t+d_v)}$.
        \item {\bf (Anti-Substitution)} \label{lem:comp-antisubs} If $\Phi_{t \subs{x}{v}} \tr \seqi{\Gam_{t \subs{x}{v}}}{t \subs{x}{v}}{\del}{(b,m,d)}$, then $\Phi_t \tr \seqi{\Gam_t; x : \M}{t}{\del}{(b_t,m_t,d_t)}$ and $\Phi_v \tr \seqi{\Gam_v}{v}{\M}{(b_v,m_v,d_v)}$, such that $\Gam_{t \subs{x}{v}} = \Gam_t + \Gam_v$, $b = b_t+b_v$, $m = m_t+m_v$, and $d = d_t + d_v$.
    \end{enumerate}
\end{restatable}

\begin{restatable}[{\bf Split Exact Subject Reduction} and {\bf Expansion}]{lemma}{lemexactredexp}
  \label{lem-exact-red-exp} \mbox{}
  \begin{enumerate}
    \item {\bf (Subject Reduction)} \label{lem:subj-comp-red} Let $(t,s) \red[\gname] (u,q)$. If $\Phi \tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$ is tight, then $\Phi' \tr \seqi{\Gam}{(u,q)}{\ctype}{(b',m',d)}$, where $\gname =\beta$ implies $b' = b - 1$ and $m' = m$, while $\gname \in \{\getname, \setname\}$ implies $b'=b$ and  $m' = m - 1$.
    \item {\bf (Subject Expansion)} \label{lem:comp-subj-exp} Let $(t,s) \red[\gname] (u,q)$. If $\Phi' \tr \seqi{\Gam}{(u,q)}{\ctype}{(b',m',d)}$ is tight, then $\Phi \tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$, where $\gname =\beta$ implies $b' = b - 1$ and $m' = m$, while $\gname \in \{\getname, \setname\}$ implies $b'=b$ and  $m' = m - 1$.
  \end{enumerate}
\end{restatable}

Soundness (resp. completeness) is based on exact subject reduction (resp. expansion), in turn based on the previous substitution (resp. anti-substitution) lemma.

\begin{restatable}[{\bf Quantitative Soundness} and {\bf Completeness}]{theorem}{compsoundness} \mbox{}
    \begin{enumerate}
        \item {\bf (Soundness)} If $\Phi \tr \seqi{\Gam}{(t,s)}{\kap}{(b,m,d)}$ tight, then there exists $(u,q)$ such that $u \in \normal$ and $(t,s) \gsrred^{(b,m)} (u,q)$ with $b$ $\beta$-steps, $m$ $\getname/\setname$-steps, and $\size{(u,q)} = d$.
        \item {\bf (Completeness)} If $(t,s) \rra^{(b,m,d)} (u,q)$ and $u \in \normal$, then there exists $\Phi \tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,\size{(u,q)})}$ tight.
    \end{enumerate}
\end{restatable}

\begin{example}
  Consider again configuration $c_0$ from~\cref{ex:globalstate} and its associated tight derivation $\Phi_{c_0}$. The first two counters of $\Phi_c$ are different from $0$: this means that $c$ is not a final configuration, but normalizes in one $\betav$-step ($b = 1$) and two $\getname/\setname$-steps ($m = 2$), to a final configuration having size $d = 0 = \size{z} = \size{(z, \upd{l}{I}{\estate})}$.
\end{example}

%\input{conclusion}
\section{Conclusion and Related Work}
\label{s:conclusion}

This paper provides a foundational step into the development of quantitative models for programming languages with effects. We focus on a simple language with global memory access capabilities. Due to the inherent lack of confluence in such framework we fix a particular evaluation strategy following a (weak) CBV approach. We provide a type system for our language that is able to (both) extract and discriminate between (exact) measures for the length of evaluation, number of memory accesses and size of normal forms. This study provides a valuable insight into time and space analysis of languages with global memory, with respect to length of evaluation and the size of normal forms, respectively.

In future work we would like to explore effectful computations involving global memory in a more general framework being able to capture different models of computation, such as the CBPV~\cite{Levy99} or the bang calculus~\cite{BucciarelliKRV20}. Furthermore, we would like to apply our quantitative techniques to other  effects that can be found in programming languages, such as non-termination, exceptions, non-determinism, and I/O.

{\bf Related Work.}  Several papers proposed quantitative approaches for different notions of CBV (without effects). But none of them exploits the idea of exact \emph{and} split tight typing. Indeed, the first non-idempotent intersection type system for Plotkin's CBV is~\cite{Ehrhard12}, where reduction is allowed under abstractions, and terms are considered to be closed.  This work was further extended to~\cite{CarraroG14}, where commutation rules are added to the calculus. None of these contributions extracts quantitative bounds from the type derivations. A calculus for open CBV is proposed in~\cite{AccattoliG18}, where \emph{fireball} --normal forms-- can be either erased or duplicated. Quantitative results are obtained, but no split measures. Other similar approaches appear in~\cite{Guerrieri19}. A logical characterization of CBV solvability is given in~\cite{AccattoliG22}, the resulting non-idempotent system gives quantitative information of the \emph{solvable} associated reduction relation. A similar notion of solvability for CBV for generalized applications was studied in~\cite{KesnerP22}, together with a logical characterization provided by a quantitative system. Other non-idempotent systems for CBV were proposed~\cite{Manzonetto2019,Kerinecetal21}, but they are defective in the sense that they do not enjoy subject reduction and expansion. Split measures for (strong) open CBV are developed in~\cite{KesnerV22}.

In~\cite{Dezani-CiancagliniGR09}, a system with universally quantified intersection and reference types is introduced for a language belonging to the ML-family. However, intersections are idempotent and only (qualitative) soundness is proved.

More recently, there has been a lot of work involving probabilistic versions of the lambda calculus. In~\cite{FaggianR19}, extensions of the lambda calculus with
a probabilistic choice operator are introduced. However, no quantitative results are provided. In~\cite{BreuvartL18}, monadic intersection types are used to obtain a (non-exact) quantitative model for a probabilistic calculus identical to the one in~\cite{FaggianR19}.

Concerning (exact) quantitative models for programming languages with global state, the state of the art is still underexplored. Some sound but not complete approaches are given in~\cite{Benton2009,Davies2000}, and quantitative results are not provided. Our work is inspired by a recent idempotent (thus only qualitative and not quantitative) model for CBV with global memory proposed by~\cite{deLiguoroT21}. This work was further extended in~\cite{GTV23} to a more generic framework of algebraic effectful computation, still the model does not provide any quantitative information about the evaluation of programs and the size of their results.

%% \delia{
%%   \subsection*{Acknowledgements} 
%%   We would like to thank Riccardo Treglia for useful discussions.
%% }

%\renewcommand{\em}[1]{\textit{#1}}
%\bibliographystyle{plain}
\renewcommand{\em}[1]{{\it #1}}

%\bibliographystyle{alphaurl}
\bibliographystyle{splncs04}

%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{refs}

\appendix
\input{proofs}


\end{document}

