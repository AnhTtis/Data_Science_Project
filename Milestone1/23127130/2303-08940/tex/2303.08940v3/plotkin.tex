\section{Weak Open CBV}
\label{s:wocbv}

In this section we first introduce the technique of tight typing on a simple language without effects, the weak open CBV. \cref{s:syntax-wocbv} defines the syntax and operational semantics of the language, \cref{s:types-for-wocbv} presents the tight typing system $\syscbv$ and discusses soundness and completeness of $\syscbv$ w.r.t. the CBV language.

\subsection{Syntax and Operational Semantics}
\label{s:syntax-wocbv}

Weak open CBV is based on two principles: reduction is \emph{weak} (not performed inside abstractions), and terms are \emph{open} (may contain free variables). \defn{Value}, \defn{terms} and \defn{weak contexts} are given by the following grammars, respectively:
\[ v, w  ::=  x \mid \lam x.t \qquad t, u, p ::= v \mid t u \qquad \W ::= \square \mid \W t \mid t \W \]

We write $\val$ for the set of all values. Notation $\id$ denotes the identity function $\lam z.z$. %and $\Omega$ the term $(\lam x. xx)(\lam x. xx)$.  
The sets of \defn{free} and \defn{bound} variables of terms and the notion of $\alpha$-conversion are
defined as usual. A term $t$ is said to be \defn{closed} if $t$ does not contain any free variable, and \defn{open} otherwise. The \defn{size of a term $t$}, denoted $\size{t}$, is given by: $\size{x} = \size{\lam x.t} = 0$; and $\size{t u} = 1 + \size{t} + \size{u}$.

We now introduce the operational semantics of our language,
which models the core behavior of  programming languages such as OCaml, where CBV evaluation is \emph{weak}.
Indeed, the \defn{deterministic reduction relation} (written $\dred$), is given by the following rules:
{\small \[ \begin{array}{l@{\sep}l@{\sep}l}
        \begin{prooftree}
        \hypo{\phantom{DDDD}}
        \infer1[(\ruleBeta)]{(\lam x.t) v \dred t \subs{x}{v}}
    \end{prooftree} & 
    \begin{prooftree}
        \hypo{t \dred t'}
        \infer1[(\ruleAppL)]{t u \dred t' u}
    \end{prooftree} & 
    \begin{prooftree}
        \hypo{t \not\dred}
        \hypo{u \dred u'}
        \infer2[(\ruleAppR)]{t u \dred t u'}
    \end{prooftree}
\end{array} \]}

\defn{Terms in $\dred$-normal form} can be characterized by the following grammars: $\normal  ::=  \val  \mid \neutral$ and $\neutral ::=  x \ \normal \mid \normal \ \neutral \mid \neutral \ \normal$.

\begin{restatable}[]{proposition}{propcharnfs}
    \label{prop:char-nfs}
    Let $t$ be a term. Then  $t \in \normal$  iff $t \not\dred \normal$. 
\end{restatable}

In closed CBV~\cite{Plotkin1975} (only reducing closed terms), abstractions are the only normal forms, but in open CBV, the following terms turn out to be also acceptable normal forms: $x y$, $x (\lam y.y (\lam z.z))$ and $(\lam x.x) (y (\lam z.z))$.

\subsection{A Quantitative Type System for the Weak Open CBV}
\label{s:types-for-wocbv}

The \emph{untyped} $\lam$-calculus can be interpreted as a \emph{typed} calculus with a single type $D$, where $D = D \ta D$~\cite{Treglia22}. Applying Girard's~\cite{Girard87} \textit{boring} CBV translation of intuitionistic logic into linear logic, we get $D =\ !D \multimap\ !D$~\cite{Accattoli15}. Type system $\syscbv$ is built having this equation in mind.

The \defn{set of types} is given by the following grammar:
\[ \begin{array}{lrcl}
    \textbf{(Tight Constants)} & \tightt & ::= & \tvar \mid \tabs \mid \tneutral \\
    \textbf{(Value Types)} & \sig & ::= & \tvar \mid \tabs \mid \M \mid \M \ta \tau \\
    \textbf{(Multi-Types)} & \M & ::= & \mul{\sig_i}_{\iI} \ \text{where $I$ is a finite set} \\
    \textbf{(Types)} & \tau & ::= & \tneutral \mid \sig
\end{array} \]

Tight types are minimal types assigned to terms reducing to normal forms ($\tvar$ for variables, $\tabs$ for abstractions, and $\tneutral$ for neutral terms). Given an arbitrary tight type $\tightt_0$, we write $\nott{\tightt_0}$ to denote all the other tight types in $\tightt$ different from $\tightt_0$. Multi-types are multisets of types. A \defn{(typing) environment}, written $\Gam, \Del$, is a function from variables to multi-types, assigning the empty multi-type $\emul$  to all but a finite set of variables. The domain of $\Gam$ is $\dom{\Gam} \defeq \{x \mid \Gam(x) \not= \emul\}$. The \defn{union} of environments, written $\Gam + \Del$, is defined by $(\Gam + \Del)(x) = \Gam(x) \sqcup \Del(x)$, where $\sqcup$ denotes \defn{multiset union}. An example is $(x : \mul{\sig_1}, y : \mul{\sig_2}) + (x : \mul{\sig_1}, z : \mul{\sig_2}) = (x : \mul{\sig_1, \sig_1}, y : \mul{\sig_2}, z : \mul{\sig_2})$. This notion is extended to a finite union of environments, written $+_{\iI} \Gam_i$ (the empty environment is obtained when $I = \eset$). We write $\Gam \sm x$ for the  environment $(\Gam \sm x)(x) = \emul$ and $(\Gam \sm x)(y) = \Gam(y)$ if $y \not= x$ and we  write $\Gam; x : \M$ for $\Gam + (x : \M)$, when $x \not\in \dom{\Gam}$. Notice that $\Gam$ and $\Gam; x:\emul$ are the same environment. 

A \defn{judgement} has the form $\seqi{\Gam}{t}{\tau}{(b,s)}$, where $b,s$ are two integers. The \defn{typing system $\syscbv$} is defined by the rules in~\cref{fig:typingruleslamop}. We write $\tr \seqi{\Gam}{t}{\tau}{(b,s)}$ if there is a (tree) \defn{type derivation} of the judgement $\seqi{\Gam}{t}{\tau}{(b,s)}$ using the rules of system $\syscbv$. The term $t$ is \defn{$\syscbv$-typable} (we may omit the name $\syscbv$) iff there is an environment  $\Gam$, a type $\tau$ and counters $(b,s)$ such that $\tr \seqi{\Gam}{t}{\tau}{(b,s)}$. We use letters $\Phi, \Psi, \dots$ to name type derivations, by writing for example $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$. 
\begin{figure}[h!]
    \[ \begin{array}{c}
        \begin{prooftree}
            \hypo{\phantom{DDDDD}}
            \infer1[(\ruleAx)]{\seqi{x : \mul{\sig}}{x}{\sig}{(0,0)}}
        \end{prooftree}
        \sep 
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tau}{(b,s)}}
            \infer1[(\ruleLam)]{\seqi{\Gam \sm x}{\lam x.t}{\Gam(x) \ta \tau}{(b, s)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\M \ta \tau}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\M}{(b',s')}}
            \infer2[(\ruleApp)]{\seqi{\Gam + \Del}{t u}{\tau}{(1+b+b',s+s')}}
        \end{prooftree} 
        \sep
        \begin{prooftree}
            \hypo{(\seqi{\Gam_i}{v}{\sig_i}{(b_i,s_i)})_{\iI}}
            \infer1[(\ruleMany)]{\seqi{+_{\iI} \Gam_i}{v}{\mul{\sig_i}_{\iI}}{(+_{\iI} b_i, +_{\iI} s_i)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\phantom{UUUUU}}
            \infer1[(\ruleLamP)]{\seqi{}{\lam x.t}{\tabs}{(0,0)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\nott{\tabs}}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\tightt}{(b',s')}}
            \infer2[(\ruleAppPOne)]{\seqi{\Gam + \Del}{t u}{\tneutral}{(b+b',1+s+s')}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tightt}{(b,s)}}
            \hypo{\seqi{\Del}{u}{\tneutral}{(b',s')}}
            \infer2[(\ruleAppPTwo)]{\seqi{\Gam + \Del}{t u}{\tneutral}{(b+b',1+s+s')}}
        \end{prooftree}
    \end{array} \]
    \caption{Typing Rules of system $\syscbv$}
    \label{fig:typingruleslamop}
\end{figure}
Notice that in rule (\ruleAx) of \cref{fig:typingruleslamop} variables can only be assigned value types $\sig$ (in particular no type $\tneutral$): this is because they can only be substituted by values. Due to this fact, multi-types only contain value types. Regarding typing rules (\ruleAx), (\ruleLam), (\ruleApp), and (\ruleMany), they are the usual rules for non-idempotent intersection types~\cite{Bucciarelli2017}. Rules (\ruleLamP), (\ruleAppPOne), and (\ruleAppPTwo) are used to type \emph{persistent} symbols, \ie\ symbols that are not going to be \emph{consumed} during evaluation. More specifically, rule (\ruleLamP) types abstractions (with type $\tabs$) that are normal regardless of the typability of its body. Rule (\ruleAppPOne) types applications that will never reduce to an abstraction on the left (thus of any tight type that is not $\tabs$, \ie\ $\nott{\tabs}$), while any term reducing to a normal form is allowed on the right (of tight type $\tightt$). Rule (\ruleAppPTwo) also types applications, but when values will never be obtained on the right (only neutral terms of type $\tneutral$). Rule (\ruleAx) is also used to type persistent variables, in  particular when $\sig \in \{ \tvar, \tabs\}$.

A \defn{type} $\tau$ is \defn{tight} if $\tau \in \tightt$. We write $\tightp{\M}$, if every $\sig \in \M$ is tight. A \defn{type environment} $\Gam$ is \defn{tight} if it assigns tight multi-types to all variables. A \defn{type derivation} $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$ is \defn{tight} if $\Gam$ and $\tau$ are both tight.

\begin{example}
    \label{ex:plotkintypederiv}
    Let $t = (\lam x.x (y z)) (\lam z.z)$. Let $\Phi$ be the following typing derivation:
    {\small \[ \begin{prooftree}
        \infer0[(\ruleAx)]{\seqi{x : \mul{\tabs}}{x}{\tabs}{(0,0)}}
        \infer0[(\ruleAx)]{\seqi{y : \mul{\tvar}}{y}{\tvar}{(0,0)}}
        \infer0[(\ruleAx)]{\seqi{z : \mul{\tvar}}{z}{\tvar}{(0,0)}}
        \infer2[(\ruleAppPOne)]{\seqi{y : \mul{\tvar}, z : \mul{\tvar}}{yz}{\tneutral}{(0,1)}}
        \infer2[(\ruleAppPTwo)]{\seqi{x : \mul{\tabs}, y : \mul{\tvar}, z : \mul{\tvar}}{x (yz)}{\tneutral}{(0,2)}}
        \infer1[(\ruleLam)]{\seqi{y : \mul{\tvar}, z : \mul{\tvar}}{\lam x.x (yz)}{\mul{\tabs} \ta \tneutral}{(0,2)}}
    \end{prooftree} \]}
    Then, we can build the following tight typing derivation $\Phi_t$ for $t$:
    {\small \[ \begin{prooftree}
        \hypo{\Phi}
        \infer0[(\ruleLamP)]{\seqi{}{\lam z.z}{\tabs}{(0,0)}}
        \infer1[(\ruleMany)]{\seqi{}{\lam z.z}{\mul{\tabs}}{(0,0)}}
        \infer2[(\ruleApp)]{\seqi{y : \mul{\tvar}, z : \mul{\tvar}}{(\lam x.x(yz)) (\lam z.z)}{\tneutral}{(1,2)}}
    \end{prooftree} \]}
\end{example}

The type system $\syscbv$ can be shown to be  \emph{sound}
and \emph{complete} w.r.t. the operational semantics $\dred$. Soundness  means
that not only  a \emph{tightly} typable term $t$ is terminating, but also
that the \emph{tight}   type derivation of $t$
gives exact and split measures concerning the reduction sequence from $t$ to normal form. More precisely,
if $\Phi \tr \seqi{\Gam}{t}{\tau}{(b,s)}$ is tight, then there exists $u \in \normal$ such that  $t \drred^b u$ with $\size{u} = s$. Dually for \emph{completeness}. Because we are going to show this kind of properties for the more sophisticated language with global state (\cref{s:sound-complete-lambda-gs}), we do not give here technical details of them. However, we highlight these properties on our previous example.   Consider again term $t$ in \cref{ex:plotkintypederiv} and its tight derivation $\Phi_t$ with counters $(b,s)=(1,2)$. Counter $b$ is different from $0$, so   $t \notin \normal$, but $t$ normalizes in one $\betav$-step ($b = 1$) to a normal form having  size $s = 2 = \size{(\lam z.z)(yz)}$.

