\section{A \texorpdfstring{$\lambda$}{Lambda}-Calculus with Global State}
\label{s:lambda-calculus-with-state}

Based on the preliminary presentation of \cref{s:wocbv}, we now introduce a $\lam$-calculus with global state following a CBV strategy. \cref{s:syntax-gs} defines the syntax and operational semantics of the $\lam$-calculus with global state. \cref{s:typing-system-gs} presents the tight typing system $\sysgs$, and \cref{s:sound-complete-lambda-gs} shows soundness and completeness.


\subsection{Syntax and Operational Semantics}
\label{s:syntax-gs}

\defn{Values}, \defn{terms}, \defn{states} and \defn{configurations} of $\lamcc$ are defined resp. as follows:
\[ \begin{array}{rl@{\hspace{0.6cm}}rl}
    v, w & ::= x \mid \lam x.t & t, u, p & ::= v \mid v t \mid \get{l}{x}{t} \mid \set{l}{v}{t} \\
    s, q & ::= \estate \mid \upd{l}{v}{t} & c & ::= (t, s)
\end{array} \]

Notice that applications are restricted to the form $vt$. This, combined with the use of a deterministic reduction strategy based on weak contexts, ensures that composition of effects is well behaved. Indeed, this kind of restriction is usual in computational calculi~\cite{Moggi1989,Sabry1997,deLiguoroT21,Faggian2021}.

The  size function is extended to states and configurations: $\size{s}:=0$, and $\size{(t,s)}: = \size{t}$. The update constructor is commutative in the following sense:
{\small \[ \begin{array}{rclr}
        \upd{l}{v}{\upd{l'}{w}{s}} & \eqstate & \upd{l'}{w}{\upd{l}{v}{s}} \text{ if $l \not= l'$}
\end{array} \]}
We denote by $\equivstate$ the equivalence relation generated by the axiom $\eqstate$. \label{def:domainS} We write \defn{$l \in \dom{s}$}, if $s \equivstate \upd{l}{v}{q}$, for some value $v$ and store $q$.
Moreover, these $v$ and $q$ are \emph{unique}. For example, if $l_1 \neq l_2$, then $s_1 = \upd{l_1}{v_1}{\upd{l_2}{v_2}{q}} \equivstate \upd{l_2}{v_2}{\upd{l_1}{v_1}{q}} = s_2 $, but $\upd{l_1}{v_1}{\upd{l_1}{v_2}{s}} \not\equivstate \upd{l_1}{v_2}{\upd{l_1}{s}}$.
As a consequence, whenever we want to access the content of a particular location in a state, we can simply assume that the location is at the top of the state.

The operational semantics of the $\lamcc$-calculus is given on configurations. The \defn{deterministic reduction relation} $\gsred$ is defined to be the union of the rules $\red[\gname]\ (\gname \in \{\beta_v, \getname, \setname\})$ below. We write $(t,s) \gsrred^{(b,m)} (u,q)$ if $(t,s)$ reduces to $(u,q)$ in $b$ $\beta_v$-steps and $m$ $\getname/\setname$-steps.
{\small \[ \begin{array}{c}
  \begin{prooftree}
    \hypo{\phantom{BUUUUUUUUU}}
    \infer1[(\ruleBeta)]{((\lam x.t) v,s) \redbetav (t \subs{x}{v},s)}
  \end{prooftree} 
  \sep
  \begin{prooftree}
    \hypo{s \equivstate \upd{l}{v}{q}}
    \infer1[(\ruleGet)]{(\get{l}{x}{t}, s) \redget (t \subs{x}{v}, s)}
  \end{prooftree}
  \\[.5cm]
  \begin{prooftree}
    \hypo{(t, s) \red[\gname] (u, q) \sep \gname \in \{\beta_v, \getname, \setname\}}
    \infer1[(\ruleAppR)]{(v t, s) \red[\gname] (v u, q)}
  \end{prooftree}
  \sep
  \begin{prooftree}
    \hypo{\phantom{BUUUUUUUU}}
    \infer1[(\ruleSet)]{(\set{l}{v}{t}, s) \redset (t, \upd{l}{v}{s})}
  \end{prooftree}
\end{array} \]}

\begin{example}
  \label{ex:globalstate}
  Consider the configuration $c_0 = ((\lam x.\get{l}{y}{yx}) (\set{l}{\id}{z}), \estate)$. Then we can reach an irreducible configuration as follows:
  {\small \[ \begin{array}{c}
    ((\lam x.\get{l}{y}{yx}) (\set{l}{\id}{z}), \estate) \redget ((\lam x.\get{l}{y}{yx}) z, \upd{l}{\id}{\estate})
    \\
    \redbetav (\get{l}{y}{yz}, \upd{l}{\id}{\estate}) \redget (\id z, \upd{l}{\id}{\estate}) \redbetav (z, \upd{l}{\id}{\estate})
  \end{array} \]}
\end{example}

A configuration $(t,s)$ is said to be \defn{blocked} if either $t = \get{l}{x}{u}$ and $l \not\in \dom{s}$; or $t = v u$ and $(u,s)$ is blocked. A configuration is \defn{unblocked} if it is not blocked.
As an example, $(\get{l}{x}{x}, \estate)$ is obviously blocked. As a consequence, the following configuration reduces to a blocked one: $((\lam y.y\ \get{l}{x}{x}) z, \estate) \red (z\ \get{l}{x}{x}, \estate)$.
This suggest a notion of \defn{final configuration}: $(t,s)$ is \defn{\final}\ if either $(t, s)$ is blocked; or $t \in \normal$, where \defn{neutral} and \defn{normal} terms are given resp. by the grammars $\neutral ::= x \ \normal \mid (\lam x.t) \ \neutral$ and $\normal ::= \val  \mid \neutral$.

\begin{restatable}[]{proposition}{propnormalifffinal}
    \label{prop:normal-iff-final}
    Let $(t,s)$ be a configuration. Then $(t,s)$ is \final\ iff $(t,s) \not\ra$.
\end{restatable}

Notice that when $(t,s)$ is  an unblocked final configuration, then $t \in \normal$. These are the configurations  captured by the typing system $\sysgs$ in \cref{s:typing-system-gs}. 
Consider the final configurations $c_0=(\get{l}{x}{x}, \estate)$, $c_1=(z\ \get{l}{x}{x}, \estate)$, $c_2= (y, s)$ and $c_3=((\lam x.x) (yz), s)$. Then $c_0$ and $c_1$ are blocked, while $c_2$ and $c_3$ are unblocked.
