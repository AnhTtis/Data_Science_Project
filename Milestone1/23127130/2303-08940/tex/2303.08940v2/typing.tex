\subsection{A Quantitative Type System for the \texorpdfstring{$\lamcc$}{LambdaCC}-calculus}
\label{s:typing-system-gs}

We now introduce the quantitative type system $\sysgs$ for $\lamcc$. To deal with global states, we extend the language of types with the notions of state, configuration and monadic types. To do this, we translate linear arrow types according to Moggi's~\cite{Moggi1989} CBV interpretation of reflexive objects in the category of $\lam_c$-models: $D =\ !D \multimap\ !D$ becomes $D =\ !D \multimap\ T(!D)$, where $T$ a functor. Type system $\sysgs$ was built having this equation in mind, similarly to what was done in~\cite{GTV23}.

The \defn{set of types} is given by the following grammar:
\[ \begin{array}{lrcl}
    \textbf{(Tight Constants)} & \tightt & ::= & \tvar \mid \vl \mid \tneutral \\
    \textbf{(Value Types)} & \sig & ::= & \tvar \mid \vl \mid \M \mid \M \ta \del \\
    \textbf{(Multi-types)} & \M & ::= & \mul{\sig_i}_{\iI} \ \text{where $I$ is a finite set} \\
    \textbf{(Types)} & \tau & ::= & \tneutral \mid \sig \\
    \textbf{(State Types)} & \stype & ::= & \conj{(l_i : \M_i)}_{\iI} \mbox{ where all } l_i \mbox{ are distinct} \\
    \textbf{(Configuration Types)} & \ctype & ::= & \conftype{\tau}{\stype} \\
    \textbf{(Monadic Types)} & \del & ::= & \comptype{\stype}{\ctype} \\
\end{array} \]

In system $\sysgs$, the minimal types to be assigned to normal forms distinguish between variables  ($\tvar$), abstractions ($\vl$), and neutral terms ($\tneutral$). A \defn{multi-type} is a multi-set of value types. A \defn{state type} is a partial function mapping labels to (possibly empty) multi-types. A \defn{configuration type} is a product type, where the first component is a type and the second is a state type. A \defn{monadic type} associates a state type to a configuration type.  We use the notation $\gtype$ to denote a value type or a monadic type. \defn{Typing environments} and operations over types are defined in the same way as in system $\syscbv$.

The \defn{domain} of a state type $\stype$ is the set of all its labels, \ie\ $\dom{\stype} := \{ l \mid (l:\M) \in \stype \}$. Also, when $l \in \dom{\stype}$, \ie\ $(l : \M) \in \stype$, we write $\stype(l)$ to denote $\M$. The \defn{union of state types} is defined as follows: 
{\small \begin{align*}
    (\stype \splus \stype')(l) = & \text{ if $(l : \M) \in \stype$ then (if $(l : \M') \in \stype'$ then $\M \sqcup \M'$ else $\M$)} \\ 
                            & \text{ else (if $(l : \M') \in \stype'$ then $\M'$ else \undefined)}
\end{align*}}

\begin{example}
    Let $\stype = \{(l_1 : \mul{\sig_1, \sig_2}), (l_2 : \mul{\sig_1})\} \splus \{(l_2 : \mul{\sig_1, \sig_2}), (l_3 : \mul{\sig_3})\}$. Then,
    $\stype(l_1) = \mul{\sig_1,\sig_2}$,
    $\stype(l_2) = \mul{\sig_1, \sig_1, \sig_2}$,
    $\stype(l_3) = \mul{\sig_3}$,
    and $\stype(l) = \undefined$, 
    assuming $l \not= l_i$, for $i \in \{1,2,3\}$.
\end{example}
  
\begin{remark}
    Notice that $\dom{\stype\splus \stype'} = \dom{\stype} \cup \dom{\stype'} $. Also  $\conj{(l : \emul)} \splus \stype \not= \stype$, if $l \not\in \dom{\stype}$, while $x:\emul; \Gam  = \Gam$. Indeed, typing environments are total functions, where variables mapped to $\emul$ do not occur in  typed programs. In contrast, states are partial functions, where labels  mapped to $\emul$ correspond to positions in memory that are accessed (by get or set), but ignored/discarded by the typed program. We use $\conj{(l : \M)}; \stype$ for $\conj{(l : \M)} \splus \stype$ if $l \not\in \dom{\stype}$.
\end{remark}

A \defn{term type judgement} {(resp. \defn{state type judgment} and \defn{configuration type judgment})} has the form $\seqi{\Gam}{t}{\gtype}{(b,m,d)}$ (resp. $\seqi{\Gam}{s}{\stype}{(b,m,d)}$ and $\seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$) where $b,m,d$ are three integers. The \defn{typing system $\sysgs$} is defined by the rules in~\cref{fig:typingruleslamcc}. We write $\tr \mathcal{J}$ if there is a type derivation of the judgement $\mathcal{J}$ using the rules of system $\sysgs$. The term $t$  (resp. state $s$, configuration $(t,s)$) is \defn{$\sysgs$-typable} iff there is an environment  $\Gam$, a type $\gtype$ (resp. $\stype$, $\ctype$) and counters $(b,m,d)$ such that $\tr \seqi{\Gam}{t}{\gtype}{(b,m,d)}$ (resp. $\tr \seqi{\Gam}{s}{\stype}{(b,m,d)}$, $\tr \seqi{\Gam}{(t,s)}{\ctype}{(b,m,d)}$). As before, we use letters $\Phi, \Psi, \dots$ to name type derivations.

Rules (\ruleAx), (\ruleLam), (\ruleMany), and (\ruleApp) are essentially the same as in~\cref{fig:typingruleslamop}, but with types lifted to monadic types (\ie\ \emph{decorated} with state types). 
Rule (\ruleApp) assumes a value type associated to a value $v$ on the left premise and a monadic type associated to a term $t$  on the right premise. To type the  application $vt$, it is necessary to match both the value type $\M$ inside the type of $t$ with the input value type of $v$, and the output state type $\stype'$ of $t$ with the input state type of $v$. Rule (\ruleLift) is used to lift multi-types (the type of values) to monadic types. Rules (\ruleGet) and (\ruleSet) are used to type operations over the state. While there was just one single typing rule in system $\syscbv$ (\cref{s:types-for-wocbv}) to type both consuming and persistent variables, we now need to add an explicit persistent rule (\ruleAxP) to type variables with lifted type $\tcomptype{\stype}{\nott{\tneutral}}{\stype}$. Rule (\ruleEmp) types empty states, rule (\ruleUpd) types states, and (\ruleConf) types configurations.

A \defn{type} $\tau$ is \defn{tight}, if $\tau \in \tightt$. We write \defn{$\tightp{\M}$} if every $\rdel \in \M$ is tight. A \defn{state type $\stype$} is \defn{tight} if $\tightp{\stype(l)}$ holds for all $l \in \dom{\stype}$. A \defn{configuration type $\conftype{\tau}{\stype}$} is \defn{tight}, if $\tau$ and $\stype$ are tight. A monadic type $\comptype{\stype}{\ctype}$ is \defn{tight}, if $\ctype$ is tight. The notion of tightness of type derivations is defined in the same way as in system $\syscbv$, \ie\ a \defn{type derivation} $\Phi$ is \defn{tight} if the type environment and the type of the conclusion of $\Phi$ are tight. 

\begin{example}
    Consider configuration $c_0$ from~\cref{ex:globalstate}. Let $\del_0 = \tcomptype{\eset}{\tvar}{\eset}$, $\M = \mul{\mul{\tvar} \ta \del_0}$, and $\Phi$ be the following typing derivation:
    {\small \[ \begin{prooftree}
        \infer0[(\ruleAx)]{\seqi{y : \M}{y}{\mul{\tvar} \ta \del_0}{(0,0,0)}}
        \infer0[(\ruleAx)]{\seqi{x : \mul{\tvar}}{x}{\tvar}{(0,0,0)}}
        \infer1[(\ruleMany)]{\seqi{x : \mul{\tvar}}{x}{\mul{\tvar}}{(0,0,0)}}
        \infer1[(\ruleLift)]{\seqi{x : \mul{\tvar}}{x}{\tcomptype{\eset}{\mul{\tvar}}{\eset}}{(0,0,0)}}
        \infer2[(\ruleApp)]{\seqi{y : \M, x : \mul{\tvar}}{yx}{\del_0}{(1,0,0)}}
        \infer1[(\ruleGet)]{\seqi{x : \mul{\tvar}}{\get{l}{y}{yx}}{\tcomptype{\conj{(l : \M)}}{\tvar}{\eset}}{(1,1,0)}}
        \infer1[(\ruleLam)]{\seqi{}{\lam x.\get{l}{y}{yx}}{\mul{\tvar} \ta (\tcomptype{\conj{(l : \M)}}{\tvar}{\eset})}{(1,1,0)}}
    \end{prooftree} \]}
    And $\Phi'$ be the following typing derivation:
    {\small \[ \begin{prooftree}
            \infer0[(\ruleAxP)]{\seqi{x : \mul{\tvar}}{x}{\del_0}{(0,0,0)}}
            \infer1[(\ruleLam)]{\seqi{}{\id}{\mul{\tvar} \ta \del_0}{(0,0,0)}}
            \infer1[(\ruleMany)]{\seqi{}{\id}{\M}{(0,0,0)}}
            \infer0[(\ruleAx)]{\seqi{z : \mul{\tvar}}{z}{\tvar}{(0,0,0)}}
            \infer1[(\ruleMany)]{\seqi{z : \mul{\tvar}}{z}{\mul{\tvar}}{(0,0,0)}}
            \infer1[(\ruleLift)]{\seqi{z : \mul{\tvar}}{z}{\tcomptype{\conj{(l : \M)}}{\mul{\tvar}}{\conj{(l : \M)}}}{(0,0,0)}}
            \infer2[(\ruleSet)]{\seqi{z : \mul{\tvar}}{\set{l}{\id}{z}}{\tcomptype{\eset}{\mul{\tvar}}{\conj{(l : \M)}}}{(0,1,0)}}
    \end{prooftree} \]}
    Then we can build the following tight typing derivation $\Phi_c$ for $c$:
    {\small \[ \begin{prooftree}
        \hypo{\Phi}
        \hypo{\Phi'}
        \infer2[(\ruleApp)]{\seqi{z : \mul{\tvar}}{(\lam x.\get{l}{y}{yx})(\set{l}{\id}{z})}{\del_0}{(1,2,0)}}
        \infer0[(\ruleEmp)]{\seqi{z : \mul{\tvar}}{\estate}{\eset}{(0,0,0)}}
        \infer2[(\ruleConf)]{\seqi{z : \mul{\tvar}}{((\lam x.\get{l}{y}{yx})(\set{l}{\id}{z}), \estate)}{\conftype{\tvar}{\eset}}{(1,2,0)}}
    \end{prooftree} \]}
  We will come back to this example at the end of~\cref{s:sound-complete-lambda-gs}.
\end{example}

\begin{figure}[h]
    \[ \begin{array}{c}
        \mbox{\bf Rules for Terms}
        \\[.2cm]
        \begin{prooftree}
            \hypo{\phantom{AAAAA}}
            \infer1[(\ruleAx)]{\seqi{x : \mul{\rdel}}{x}{\rdel}{(0,0,0)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M}{(b,m,d)}}
            \infer1[(\ruleLift)]{\seqi{\Gam}{v}{\tcomptype{\stype}{\M}{\stype}}{(b,m,d)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \infer1[(\ruleLam)]{\seqi{\Gam \sm x}{\lam x.t}{\Gam(x) \ta (\comptype{\stype}{\ctype})}{(b,m,d)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{(\seqi{\Gam_i}{v}{\rdel_i}{(b_i,m_i,d_i)})_{\iI}}
            \infer1[(\ruleMany)]{\seqi{+_{\iI} \Gam_i}{v}{\mul{\rdel_i}_{\iI}}{(+_{\iI} b_i, +_{\iI} m_i, +_{\iI} d_i)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M \ta (\comptype{\stype'}{\ctype})}{(b,m,d)}}
            \hypo{\seqi{\Del}{t}{\tcomptype{\stype}{\M}{\stype'}}{(b',m',d')}}
            \infer2[(\ruleApp)]{\seqi{\Gam + \Del}{v t}{\comptype{\stype}{\ctype}}{(1+b+b',m+m',d+d')}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \infer1[(\ruleGet)]{\seqi{\Gam \sm x}{\get{l}{x}{t}}{\comptype{\conj{(l : \Gam(x))} \splus \stype}{\ctype}}{(b,1+m,d)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M}{(b,m,d)}}
            \hypo{\seqi{\Del}{t}{\comptype{\conj{(l : \M)}; \stype}{\kap}}{(b',m',d')}}
            \infer2[(\ruleSet)]{\seqi{\Gam + \Del}{\set{l}{v}{t}}{\comptype{\stype}{\kap}}{(b+b',1+m+m',d+d')}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\phantom{BUUUUUUUUUUU}}
            \infer1[(\ruleAxP)]{\seqi{x : \mul{\nott{\tneutral}}}{x}{\tcomptype{\stype}{\nott{\tneutral}}{\stype}}{(0,0,0)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\phantom{text}}
            \infer1[(\ruleLamP)]{\seqi{}{\lam x.t}{\tcomptype{\stype}{\vl}{\stype}}{(0,0,0)}}
        \end{prooftree}
        \\[.5cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\tcomptype{\stype}{\tightt}{\stype}}{(b,m,d)}}
            \infer1[(\ruleAppPOne)]{\seqi{(x : \mul{\tvar}) + \Gam}{x t}{\tcomptype{\stype}{\tneutral}{\stype}}{(b,m,1+d)}}
        \end{prooftree}
        \sep 
        \begin{prooftree}
            \hypo{\seqi{\Gam}{u}{\tcomptype{\stype}{\tneutral}{\stype}}{(b,m,d)}}
            \infer1[(\ruleAppPTwo)]{\seqi{\Gam}{(\lam x.t) u}{\tcomptype{\stype}{\tneutral}{\stype}}{(b,m,1+d)}}
        \end{prooftree}
        \\[.5cm]     
        \mbox{\bf Rules for States}  
        \\[.2cm]
        \begin{prooftree}
            \hypo{\phantom{text}}
            \infer1[(\ruleEmp)]{\seqi{}{\estate}{\eset}{(0,0,0)}}
        \end{prooftree}
        \sep
        \begin{prooftree}
            \hypo{\seqi{\Gam}{v}{\M}{(b,m,d)}}
            \hypo{\seqi{\Del}{s}{\stype}{(b',m',d')}}
            \infer2[(\ruleUpd)]{\seqi{\Gam + \Del}{\upd{l}{v}{s}}{\conj{(l : \M)}; \stype}{(b+b',m+m',d+d')}}
        \end{prooftree}    
        \\[.5cm]
        \mbox{\bf Rule for Configurations}
        \\[.2cm]
        \begin{prooftree}
            \hypo{\seqi{\Gam}{t}{\comptype{\stype}{\ctype}}{(b,m,d)}}
            \hypo{\seqi{\Del}{s}{\stype}{(b',m',d')}}
            \infer2[(\ruleConf)]{\seqi{\Gam + \Del}{(t, s)}{\ctype}{(b+b',m+m',d+d')}}
        \end{prooftree}
    \end{array} \]
    \caption{Typing rules for $\lamcc$.}
    \label{fig:typingruleslamcc}
\end{figure}
