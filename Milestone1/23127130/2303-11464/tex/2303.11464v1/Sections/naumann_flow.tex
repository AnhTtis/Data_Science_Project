\section{Data Flow Reversal Problems}\label{sec:naumann2}

\begin{flushright}
{\it Uwe Naumann}
\end{flushright}

\mySub{Introduction}

Impressive progress in the development of computer hard- and software has been 
made over the past decades. Consequently, numerical simulation has become one 
of the pillars of science and engineering. Practically relevant real-world 
phenomena are modelled mathematically. Their numerical evaluation yields 
multivariate vector functions 
$F: \R^n \rightarrow \R^m :$ $\Y=F(\X)$
implemented as often 
highly complex computer programs. 

Evaluation of a numerical program at a given input induces a directed 
acyclic graph (DAG) $G=(V,E).$ 
Its integer vertices $V=(X,Z,Y)$ consist of $n \geq 1$ sources 
$X=\{1,\ldots,n\}$ representing $\X \in \R^n,$
$p \geq 0$ intermediate vertices $Z=\{n+1,\ldots,n+p\}$ and $m \geq 0$ 
sinks $Y=\{n+p+1,\ldots,n+p+m\}$ representing $\Y \in \R^m.$ Intermediate 
vertices and sinks model
calls to elemental functions
$$
\V_j=F_j(\V_i)_{(i,j) \in E} \quad \text{for}~j=n+1,\ldots,n+p+m \; .
$$
Directed edges $E \subseteq V \times V$ are due to corresponding 
data dependence within the 
program. A topological order of the vertices is implied. 
DAGs of numerical simulations become very large.
They are nonpersistent in the sense that they cannot be stored in memory.

Algorithmic Differentiation (AD) \cite{Griewank2008EDP,Naumann2012TAo} of numerical 
programs in adjoint mode plays a central role in numerous
areas of computational science and engineering including error estimation, uncertainty quantification, parameter sensitivity analysis, model calibration and 
optimization. It yields efficient (${\mathcal O}(m)$) gradients ($m=1$) with 
machine accuracy which would otherwise have to be approximated numerically 
with a cost of ${\mathcal O}(n)$ where often $n \gg 1.$ Refer to 
\url{www.autodiff.org} for links to AD projects and research groups as well as
for an extensive bibliography on the subject.

The {\em algorithmic adjoint} evaluates 
$\bar{\X}=\bar{\X}+F'(\X)^T \cdot \bar{\Y}$ as
$$
\bar{\V}_i=\bar{\V}_i+F'_j(\V_i)_{(i,j) \in E} \cdot \bar{\V}_j \quad \text{for}~j=n+p+m,\ldots,n+1 
$$
by accessing the nonpersistent $\V_i$ in reverse order. 
Equivalently, the DAG $G$ is reversed by accessing its vertices in 
reverse order.
Values lost due to overwriting of program
variables in the given implementation of $F$ need to be recovered. Naively,
all overwritten {\em required} \cite{Dauvergne2006TDF,Hascoet2005TBR} 
values could be pushed onto a stack. The persistent memory required for data 
flow reversal becomes maximal (${\mathcal O}(n+p)$). Alternatively, 
all overwritten required values could be recomputed 
from the persistent inputs, which yields minimal persistent memory requirement 
(${\mathcal O}(n)$). 
Reversal of the flow of data in nonpersistent memory results in quadratic 
computational cost (${\mathcal O}(p^2)$). Each intermediate value needs to be
recomputed from $\X.$ Without loss of generality, unit cost can be
assumed for all $F_j.$
The combinatorial {\sc DAG Reversal} 
problem aims to minimize the computational cost of data flow reversal in 
limited ($\ll {\mathcal O}(p^2)$) persistent memory.

Applications of data flow reversal beyond algorithmic adjoints include 
reverse debugging of large-scale numerical simulations \cite{Engblom2012ARO} 
and checkpointing for resilience of computer systems \cite{osti_1364654}.

\mySub{Formal Statement of the Problem}

\begin{problem}[{\sc DAG Reversal}] \label{dagr}
Given a DAG $G$ and two integers $M \geq n$ and $O \geq 0$ 
can $G$ be reversed within persistent memory of size less than or equal to
$M$ with computational cost less than or equal to $O?$
\end{problem}

\mySub{What Is [Not] Known}

\begin{theorem}
{\sc DAG Reversal} is NP-complete.
\end{theorem}
The proof can be found in \cite{Naumann2008DRi}.
The related {\sc Call Tree Reversal} problem is also known to be NP-complete
\cite{Naumann2008CTR}.

The state of the art in methods for data flow reversal is mostly driven by 
solutions for special cases due to given simulation scenarios 
\cite{Charpentier2001CSo,Symes2007Rtm,Wang2009MRD}. 
Optimal checkpointing methods for certain types of evolutions (DAG is a simple chain) were developed \cite{Griewank1992ALG,Walther2000Rev}. Generalizations
include mixed-integer programming for {\sc Call Tree Reversal} \cite{Lotz2016MIP} and divide-and-conquer approaches \cite{Siskind2018Dac}. Refer to
\cite{Hascoet2009RSf} for additional information.

The combinatorial data flow reversal problems are expected to benefit
from further formal theoretical analysis. In particular, there are no 
approximation methods available.