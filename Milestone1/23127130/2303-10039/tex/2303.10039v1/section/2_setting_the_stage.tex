\section{Setting the Stage} \seclabel{setting_the_stage}
% introduction of system generating an event log

% 2023-01-27: Artem
A process discovery algorithm aims to construct a model from data generated by historical system executions, such that the model describes the system well.
The system executions are captured in an event log. 
An event log keeps records of events executed by the system.
A desired property of a discovery algorithm is \emph{rediscoverability}.
This property states that if a system $S$, expressed as a model $M$, generates an event log $L$, then the discovery algorithm with the rediscoverability property should construct $M$ from $L$. 
In other words, the algorithm can reverse engineer the model of the system from the data the model has generated. 
Only a few existing algorithms guarantee this property.
For example, if the model is a structured workflow net, and the event log is directly-follows complete, then the $\alpha$ miner algorithm~\cite{AalstWM04} can rediscover the net that generated the event log.
Similarly, under the assumption that the event log is directly-follows complete, Inductive Miner~\cite{Leemans2013} can rediscover process trees without duplicate transitions, self-loops or silent transitions.
Many algorithms use measures of fitness, precision, generalization, and simplicity~\cite{buijs_2014_quality} to assess the quality of the discovered process models. 
However, the quality dimensions only measure the event log with respect to the discovered model instead of with the generating system~\cite{werf_2021_glitters}.

\begin{figure}[t]
	\centering
	\includegraphics[width=.9\textwidth]{figs/runningexample}
	\caption{A simple retailer system of three interacting processes for customers, products and orders.}\figlabel{runningexample}
\end{figure}

%\subsection{Systems as Sets Of Interacting Processes}

% 2023-01-27: Artem
Most existing process discovery algorithms assume that a system executes a single process~\cite{aalst22_foundations}. 
Consequently, an event log is defined as a collection of sequences where a sequence describes the execution of a single process instance. 
However, many information systems, such as ERP systems, do not satisfy this assumption.
A system often executes multiple interacting processes.
For example, consider a retailer system that executes three processes: an order, product, and customer management process, as depicted in~\figref{runningexample}.
These processes are intertwined. 
Specifically, only available products may be ordered, and customers can only have one order per time.
Consequently, events do not belong to a single process but relate to several processes. 
For instance, consider an event $e$ generated by executing transition $G$ for some customer $c$ that creates a new order $o$. 
Event $e$ relates to the customer process instance $c$ and the order process instance $o$.
Traditional process discovery techniques require event $e$ to be stored in multiple event logs and generate multiple models, one for each process. 
%\db{I think that it's important to stress that this way of storing the data does not have a nice way to model the interactions between the objects?}
% Artem: not sure, this information is derivable from multiple logs.

\begin{figure}[t]
	\centering
	\includegraphics[width=.8\textwidth]{figs/principleIdea}
	\caption{The framework for rediscoverability of systems of interacting processes.}\figlabel{principleIdea}
\end{figure}

% 2023-01-28: Artem
A different approach is taken in object-centric process discovery~\cite{aalstB20_discovering}. % Suggestion for reference: https://link.springer.com/referenceworkentry/10.1007/978-3-319-63962-8_93-1?
Instead of linking each event to a single object, this approach assumes that events can be linked to multiple objects stored in object-centric event logs~\cite{Berti2022}. 
Current object-centric discovery algorithms project complex logs on each object type to create a set of ``flattened'' event logs.
For each event log, a model is discovered, after which these models are combined into a single model~\cite{aalstB20_discovering}.
In general, flattening is lossy~\cite{adams22_extractingfeatures}, as in this step, events can disappear~\cite{aalstB20_discovering}, be duplicated (convergence)~\cite{aalst19_divergence}, or lead to worng event orders (divergence)~\cite{aalst19_divergence}.
% 2023-01-28: Artem
We study under what conditions projections in event logs can be used to guarantee rediscoverability for object-centric processes, represented as typed Petri nets with identifiers (\tpnids)~\cite{vanderWerf2022}. 
We model systems as sets of interacting processes. 
The conceptual overview of our approach is depicted in \figref{principleIdea}.
The approach consists of two parts. 

% 2023-01-28: Artem
First, we study typed Jackson Nets (\tjns), a subclass of \tpnids, in which objects behave well imposed by the structure of the nets. 
The class is inspired by Jackson Nets~\cite{vanHee2009}, which are block-structured workflow nets that are sound by definition. 
% Daniel: We no longer talk about process trees in this paper
%As we show in \secref{FIXME}, the class of process trees~\cite{Leemans2013} used in process mining are equivalent to Jackson Nets. 
As the class of Jackson Nets is enclosed in the class of typed Jackson nets, they form a natural class to study in the context of process discovery.
Typed Jackson Nets exhibit a special property: they are \emph{reconstructable}. 
As we show in \secref{decomposability}, composing the projections of each type is insufficient for reconstructing a typed Jackson Net. 
Instead, if the subset-closed set of all type combinations is considered, then the composition returns the original model.
% 2023-01-28: Artem
Second, we show how the reconstructability property can be used to develop a framework for defining algorithms capable of rediscovering typed Jackson nets using traditional process discovery algorithms. 
In the framework, we show that the projected event log is also an event log of the corresponding projected model. 
Consequently, if the process discovery algorithm guarantees the rediscoverability of projected models, then the composition operator for typed Jackson Nets can be used to ensure the rediscoverability of the original system. %, provided that each projected event log satisfies the assumptions of the process discovery algorithm.

%\section{Petri Nets with Identifiers}
%

%
%
%
%To properly account for \emph{types of places used in $N$}, we introduce $\type_\places(N) = \{ \vec\lambda \mid \exists p \in P : \vec\lambda\in\alpha(p)\}$.
% To properly account for objects types used in a \tpnid, we introduce the set of \emph{object types in $N$} $\type_\Lambda(N) = \{ \lambda \mid \lambda\in \vec\lambda, \vec\lambda\in\type_\places(N)\}$.
%â€¢	Goal of process discovery is to "discover" a process model that, given an event log, describes the system well.
%â€¢	Different notions exist to describe how well a model describes a system. Rediscoverability is the ideal property (holy grail ðŸ˜‰) of process discovery. Comes in several "flavors": isomorphic, bisimilar, language equivalent. The Inductive Miner and alpha-miner have isomorphic rediscoverability as property.
%â€¢	Problem however is that most algorithms consider the system to be a single process. However, often the system is a set of coherent, interacting processes. We want to represent these processes by process trees.
%â€¢	Process trees are "identical" to jackson nets, hence, we want to explore the idea of modeling a system of interacting processes by a typed Jackson net, as introduced in (Van der Werf et al, 2022).
%â€¢	In this paper, we show that typed Jackson nets have a very specific property: they are "reconstructable". In other words, if one deconstructs a typed Jackson net with types L in a subset-closed set of projections (i.e., all possible subsets of L), then the reconstruction operator (simple union of all of them) ensures that the original net is reconstructed, modulo "weak places" (where a "weak place" is a typed implicit place)
%â€¢	This reconstruction property forms the basis of a discovery framework: deconstruct a log into a subset-closed set of log projections (i.e., for all possible subsets of identifier types in the log), discover a process tree for each of them, then if the algorithm satisfies some property B, the reconstruction operator ensures that the original net is reconstructed, modulo weak places. 


%\db{Everything below here is copied from main branch; unsure if it is preliminaries or setting the stage territory}
%
%\newcommand{\restr}[2]{\left.#1\right|_{#2}}
%
%% \section{Object-aware logs} \label{sec:oa-logs}
%
%In this section we fix some preliminary notions related to events and traces, and introduce a number of assumptions made about the structure of events and logs.
%%%
%\begin{definition}[Event signature]
%	An \emph{event signature} is a tuple $(n,O)$, where $n$ is the \emph{activity} name;
%	and  $O=\set{o_1,\ldots,o_\ell}\subset\V$ is the set of \emph{object names}.
%\end{definition}
%%%
%\andy{Do we know a priori which events are emitters and which are consumers? This can be also deduced from the log.}
%
%Notice that event signatures may have multiple object names of the same type.
%Let now $\E$ be a finite set of event signatures, \emph{each having a distinct name} (like that we can always refer to an event signature by its name only).
%With $\N_\E=\bigcup_{(n,O)\in\E} n$ we denote the set of all event names from $\E$
%and with $\O_\E=\bigcup_{(n,O)\in\E} O$ the set of all object names occurring in $\E$.
%%We also assume that all object names in $\E$ are of distinct types. 
%%More formally, for any $o_1,o_2\in \O_\E$ s.t. $o_1\neq o_2$ it holds that $\type_{\V}(o_1)\neq\type_{\V}(o_2)$.
%
%%Since we are eventually interested not only in object names but also in their types, 
%%we define a \emph{typing function} $\alpha_o:\O_\E\to\Lambda$.
%
%
%%\andy{does $\zeta$ have to be total? this is not really fitting the setting}
%\begin{definition}[Event]
%	\label{def:event}
%	An \emph{event} of event signature $(n,O)$ is a
%	pair $e=(n,\zeta)$ where $\zeta:O\to\I$ is a
%	total function assigning an identifier value to each object in $O$ s.t. $type_{\I}(\zeta(o))=type_{\V}(o)$, for every $o\in O$.
%\end{definition}
%%W.l.o.g. we say that an event is \emph{empty} iff $O=\emptyset$. In what follows, we assume that whenever we have empty events, they can be safely discarded.
%
%At this point, we provide two assumptions characterizing the type of object-aware logs we intend to work with:
%\begin{assumption}
%	All the objects appearing in an event represent its ``payload''.
%\end{assumption}
%\begin{assumption}
%	An event always creates an implicit $n$-ary relation between objects it manipulates.
%\end{assumption}
%In terms of \tpnids, the payload mentioned in Assumption 1 can be easily seen as a binding provided for variables in $\outvar{n}\cup\invar{n}=O$ of a transition $n\in T$ s.t. $\tuple{n,O}\in \E$.
%Notice that if an object identifier appears for the first time for an event in a trace, then this event is an emitter of that object. Similarly, the last occurrence of the object identifier in the trace makes the related event a collector of that object.
%
%
%
%As customary, a totally ordered sequence of events forms a trace.
%\begin{definition}[Trace, log]
%	\label{def:trace}
%	A \emph{trace} over a set $\E$ of event signatures is a finite sequence
%	$\mathbf{e}=\tuple{e_1\cdots e_m}$, where each $e_i$ is an event of some signature in $\E$.
%	A \emph{log} is a set of traces.%for simplicity we consider sets, but everything can be easily done for multisets 
%\end{definition}
%
%Given that logs are typed, we introduce a typed projection. For an event $e=(n,\zeta)$ and a set $X\subseteq \O_\E$, a \emph{projection} of $e$ on $X$, denoted as $\restr{e}{X}$, is the event $e'=(n,\zeta')$ with $(n,O')$ s.t. $O'=O\cap X$ and $\zeta'=\restr{\zeta}{O'}$.  %If $O'=\emptyset$, then $e=\epsilon$.
%The projection on a trace is then defined inductively as follows:
%\begin{inparaenum}[\it (1)]
%	\item $\restr{\epsilon}{X}=\epsilon$;
%	\item $\restr{\tuple{e\cdot \mathbf{e}}}{X}=\restr{e}{X}\cdot \restr{\mathbf{e}}{X}$, if $X\cap O\neq \emptyset$ for $e=(n,\zeta)$ with $(n,O)\in\E$;
%	\item $\restr{\tuple{e\cdot \mathbf{e}}}{X}=\restr{\mathbf{e}}{X}$, otherwise.
%\end{inparaenum}
%The projection of a log $L=\set{\mathbf{e}_1,\ldots,\mathbf{e}_n}$ on $X$ is defined as $\restr{L}{X}=\set{\restr{\mathbf{e}_1}{X},\ldots,\restr{\mathbf{e}_n}{X}}$.
%With a slight abuse of notation, we use the $Id$ function to get all constants from a log.
%More specifically, given a log $L$, the \emph{set of identifiers of $L$} is defined as $\id{L}= \bigcup_{\mathbf{e}\in L}\bigcup_{(n,\zeta)\in \mathbf{e}} \rng{\zeta}$.
%
%
%
%In what follows, we focus on logs that are $\E$-complete. Intuitively, $\E$-completeness guarantees that a log contains at least one event per event signature, thus guaranteeing that all the relations between object names are witnessed in the log.\footnote{Notice that object names cannot be related to themselves due to the type uniqueness assumption.}
%
%\begin{definition}[$\E$-completeness]
%	Let $L$ be a log over a set of event signatures $\E$.
%	Then $L$ is \emph{$\E$-complete} iff for every signature $(n,O)\in\E$, it holds that
%	there is a trace $\mathbf{e}\in L$ and an event $(n,\zeta)$ s.t $(n,\zeta)\in\mathbf{e}$. %s.t. $\zeta(o)$ is defined for each $o\in O$.
%\end{definition}
%%\andy{On top of being $\E$-complete, our logs must comply to the type-variable uniqueness assumption (one value for one type within one case). Probably, it would be redundant to require that within one case we cannot have values change for bindings in a firing sequence induced by a transitive closure of directly follows relations.}
%
%%In what follows, we focus on logs that are relationally complete. Intuitively, relational completeness guarantees that a log contains enough of distinct identifier values per object type in order to extract unambiguous relations between object types.\footnote{Notice that object types cannot be related to themselves due to the type uniqueness assumption.}
%
%%\begin{definition}[Relational witness, valid relation]
%%Let $L$ be a log over a set of event signatures $\E$. 
%%Function $\zeta:O\to\I$ is called a \emph{relational witness} iff there is an event $e\in L$ s.t. $e=(n,\zeta)$ of signature $(n,O)$.% and there are at least $o_1,o_2\in O$ s.t. $\zeta(o_1)$ and $\zeta(o_2)$ are defined.
%%A non-empty set $O\subseteq \O_\E$ is called a \emph{valid relation} iff $L$ contains a relational witness 
%%\end{definition}
%%\begin{definition}[Valid relation]
%%Let $L$ be a log over a set of event signatures $\E$. 
%%A non-empty set $O\subseteq \O_\E$ is called a \emph{valid relation} iff $L$ contains an event of signature $(n,O)$.
%%\end{definition}
%%\andy{order of elements in valid relations does not matter}
%
%
%
%%%%%%%%%%%%%%%%%%%%%
%%   PNIDs are not capable of capturing cardinalities. Thus, it does not make sense to consider relational completeness (commented out below) that preserves cardinalities. 
%%%%%%%%%%%%%%%%%%%%%
%%Using the concept of valid relations, we can now say when a log is relationally complete. In the nutshell, a log is relationally complete if each of its valid relations has corresponding events (that is, events of a signature with that containing all the identifiers present in the log. 
%%\begin{definition}[Relational completeness]%\andy{must quantify over all events as well + extend the definition with singletons}
%%%Let $L$ be a log over a set of event signatures $\E$. Then $L$ is \emph{relationally complete} iff
%%%for every two distinct object names $o_1,o_2\in \O_\E$, it holds that 
%%%for any $\cname{id_1},\cname{id_2}\in\id{\restr{L}{\set{o_1,o_2}}}$, where $\cname{id_1}\in I(type_\V(o_1))$ and $\cname{id_2}\in I(type_\V(o_2))$, there is a trace $\mathbf{e}\in \restr{L}{\set{o_1,o_2}}$ and an event $(n,\zeta)\in\mathbf{e}$ s.t. $\cname{id_1},\cname{id_2}\in\rng{\zeta}$.
%%Let $L$ be a log over a set of event signatures $\E$. Then $L$ is \emph{relationally complete} iff
%%for every valid relation $O=\set{o_1,\ldots,o_n}\subseteq \O_\E$, it holds that 
%%for any $\cname{id}_i\in\id{\restr{L}{O}}$, where $1\leq i\leq n$ and $\cname{id}_i\in I(type_\V(o_i                                                                                     ))$, there is a trace $\mathbf{e}\in \restr{L}{\O}$ and an event $(n,\zeta)\in\mathbf{e}$ s.t.
%% $\cname{id}_1,\cname{id}_2,\ldots,\cname{id}_{n}\in\rng{\zeta}$.
%%\end{definition}
%
%In the following we show a sample log and discuss both its $\E$-complete and -incomplete variants.
%\begin{example}
%	\label{ex:log}
%	Let $O=\set{x,y,z}$ be a set of object names s.t. $I(\type_\V(x))=\set{1,2}$, $I(\type_\V(y))=\set{A,B}$ and $I(\type_\V(z))=\set{\bigstar}$.
%	Consider then a set of event signatures
%	$\E 	= 		\set{
%			\tuple{a,\set{x}},
%			\tuple{b,\set{x}},
%			\tuple{c,\set{x,y,z}},
%			\tuple{d,\set{x,y,z}},
%			\tuple{e,\set{y}},
%			\tuple{f,\set{x,y,z}},
%			\tuple{g,\set{z}}
%		}$.
%	Using the above event signatures, we construct the following log:
%
%	\setlength{\tabcolsep}{5pt}
%	\begin{tabular}{rr*{3}{c}}
%		\textbf{Case ID} & Activity & x           & y           & z          \\
%		\hline
%		1                & a        & $\cname{1}$ &             &            \\
%		1                & c        & $\cname{1}$ & $\cname{A}$ & $\bigstar$ \\
%		1                & e        &             & $\cname{A}$ &            \\
%		1                & g        &             &             & $\bigstar$ \\
%		1                & d        & $\cname{1}$ & $\cname{A}$ & $\bigstar$ \\
%		1                & f        & $\cname{1}$ & $\cname{A}$ & $\bigstar$ \\
%		1                & b        & $\cname{1}$ &             &            \\[.3em]
%		2                & a        & $\cname{1}$ &             &            \\
%		2                & c        & $\cname{1}$ & $\cname{B}$ & $\bigstar$ \\
%		2                & e        &             & $\cname{B}$ &            \\
%		2                & g        &             &             & $\bigstar$ \\
%		2                & d        & $\cname{1}$ & $\cname{B}$ & $\bigstar$ \\
%		2                & f        & $\cname{1}$ & $\cname{B}$ & $\bigstar$ \\
%		2                & b        & $\cname{1}$ &             &            \\[.3em]
%		3                & a        & $\cname{2}$ &             &            \\
%		3                & c        & $\cname{2}$ & $\cname{B}$ & $\bigstar$ \\
%		3                & e        &             & $\cname{B}$ &            \\
%		3                & g        &             &             & $\bigstar$ \\
%		3                & d        & $\cname{2}$ & $\cname{B}$ & $\bigstar$ \\
%		3                & f        & $\cname{2}$ & $\cname{B}$ & $\bigstar$ \\
%		3                & b        & $\cname{2}$ &             &            \\[.3em]
%		4                & a        & $\cname{2}$ &             &            \\
%		4                & c        & $\cname{2}$ & $\cname{A}$ & $\bigstar$ \\
%		4                & e        &             & $\cname{A}$ &            \\
%		4                & g        &             &             & $\bigstar$ \\
%		4                & d        & $\cname{2}$ & $\cname{A}$ & $\bigstar$ \\
%		4                & f        & $\cname{2}$ & $\cname{A}$ & $\bigstar$ \\
%		4                & b        & $\cname{2}$ &             &            \\
%	\end{tabular}
%	%\begin{align*}
%	%L=\{ & \tuple{(a,\set{\cname{1}}),
%	%				(c,\set{\cname{1},\cname{A},\bigstar}),
%	%				(e,\set{\cname{A}}),
%	%				(g,\set{\bigstar}),
%	%				(d,\set{\cname{1},\cname{A},\bigstar}),
%	%				(b,\set{\cname{1}})}, \\
%	%		& \tuple{(a,\set{\cname{1}}),
%	%				(c,\set{\cname{1},\cname{B},\bigstar}),
%	%				(e,\set{\cname{B}}),
%	%				(g,\set{\bigstar}),
%	%				(d,\set{\cname{1},\cname{B},\bigstar}),
%	%				(b,\set{\cname{1}})}, \\
%	%		& \tuple{(a,\set{\cname{2}}),
%	%				(c,\set{\cname{2},\cname{B},\bigstar}),
%	%				(e,\set{\cname{B}}),
%	%				(g,\set{\bigstar}),
%	%				(d,\set{\cname{2},\cname{B},\bigstar}),
%	%				(b,\set{\cname{2}})}
%	%	\}
%	%\end{align*}
%	%
%	%It is easy to see that this log is relationally incomplete as it does not consider all possible combinations of values for signatures of events $c$ and $d$. 
%	%To complete it, we need to add the next trace: 
%	%$$
%	%		\tuple{(a,\set{\cname{2}}),
%	%				(c,\set{\cname{2},\cname{A},\bigstar}),
%	%				(e,\set{\cname{A}}),
%	%				(g,\set{\bigstar}),
%	%				(d,\set{\cname{2},\cname{A},\bigstar}),
%	%				(b,\set{\cname{2}})}
%	%$$
%
%
%	It is easy to see that this log is $\E$-complete. An incomplete variant of that log can be obtained by, for example, removing all the events $(b,\zeta)$.
%
%	%\begin{align*}
%	% L' = & \{ 
%	% 			\tuple{a,\set{\cname{1}}}, 
%	% 			\tuple{a,\set{\cname{2}}},
%	% 			\tuple{b,\set{\cname{1}}},
%	% 			\tuple{b,\set{\cname{2}}},
%	% 			\tuple{e,\set{\cname{A}}}, 
%	% 			\tuple{e,\set{\cname{B}}}, 
%	% 			\tuple{g,\set{\bigstar}},\\
%	% 		&  \tuple{c,\set{\cname{1},\cname{A},\bigstar}},
%	% 			\tuple{c,\set{\cname{2},\cname{A},\bigstar}},
%	% 			\tuple{c,\set{\cname{1},\cname{B},\bigstar}}
%	% 			\tuple{c,\set{\cname{2},\cname{B},\bigstar}},
%	%\}
%	%\end{align*}
%\end{example}
%
%
%%
%%Processes and data are highly intertwined: processes manipulate data objects.
%%These manipulations can be complex and involve multiple objects.
%%As an example, consider a retailer shop with three types of objects: \emph{products} that are sold through the shop, and \emph{customers} that can order these products, which is supported through an \emph{order} process.
%%%In such an information system, 
%%Here, object relations can be many-to-many: e.g., a product can be ordered for many customers and the same customer can order many products.
%%Relations can also be one-to-many, e.g., an order is always for a single customer, but a customer can have many orders.
%%In addition, objects may have their own life cycle, which can be considered to be a process itself. For example, a product may temporarily be unavailable, or customers may be blocked by the shop, disallowing them to order products.
%%%Products can be temporarily unavailable, or completely deleted from the system. 
%%
%%Different approaches have been studied to model and analyse such models that combine objects and processes.
%%For example, data-aware Proclets~\cite{Fahland2019} allow to describe the behavior of individual artifacts and their interactions.
%%%Other approaches rely on colored Petri nets~\cite{Jensen1996}, e.g., as proposed in~\cite{MontaliR17}.
%%Another approach is followed in $\nu$-PN~\cite{RosaVelardo2011}, in which tokens can carry a single identifier~\cite{RosaVelardo2006}.
%%%In their formalism, markings map each place to a bag of identifiers, indicating how many tokens in each place carry the same identifier.
%%These identifiers can be used to reference entities in an information model.
%%However, referencing a fact composed of multiple entities is not possible in $\nu$-PNs.
%%%
%%%\jmw{Present example of Fig. 1 in more detail, explaining the different lifecycles, and how the set of emitters and collectors are induced from the net (only presenting the ideas, not the formal defs), showing why t-PNIDs are a useful modeling paradigm~\cite{TEACHINGPAPER}. These models are already supported in the ISM Suite~\cite{WerfP20}}
%%%
