\section{Typed Jackson Nets to Model Interacting Processes} \seclabel{typed_jackson_nets_section}
%In this section, we show that Jackson Nets are equivalent models to represent block-structured workflow nets.
In this section, we introduce typed Jackson Nets as subclass of typed Petri nets with identifiers. 
%This class can be extended to typed Jackson Nets, a subclass of typed Petri nets with identifiers.
We show that this class is a natural extension to Jackson Nets, which are representations of block-structured workflow nets.
Typed Jackson Nets are identifier sound and live by construction.%, and can therefore be used to model systems of interacting processes.

\begin{figure}[t]
	\centering
	\begin{tikzpicture}[->,>=stealth',auto,x=10mm,y=1cm,node distance=11mm and 3mm,thick,  every node/.style={scale=0.8}]
		
		\node[pl,label = below:$p_1$]              (p1) {};
		\node[tr,right of = p1, label=center:$t_1$] (t1) {};
		\node[pl,right of = t1, label=below:$p_2$] (p2) {};
		
		\node[tr,right of = p2, label=center:$t_2$,yshift=1cm,xshift=4mm]  (t2) {};
		\node[tr,right of = p2, label=center:$t_3$,yshift=-1cm,xshift=4mm] (t3) {};
		\node[pl,right of = t2, label=below:$p_3$,yshift=-1cm,xshift=4mm] (p3) {};
		\node[tr,left  of = p3, label=center:$t_4$,xshift=-4mm] (t4) {};
		
		\node[tr,right of = p3, label=center:$t_5$] (t5) {};
		\node[pl,right of = t5, label=below:$p_4$] (p4) {};
		
		% Empty node to fix caption overlap
		% change yshift to LOWER value to make whitespace LESS
		\node[below of = t3,yshift=5mm] (a) {};
		
		\path[->]
		(p1) edge (t1)
		(t1) edge (p2)
		
		(p2) edge[bend left  = 20] (t2)
		(t2) edge[bend left = 20] (p3)
		
		(p2) edge[bend right = 20] (t3)
		(t3) edge[bend right = 20] (p3)
		
		(p3) edge (t4)
		(t4) edge (p2)

		(p3) edge (t5)
		(t5) edge (p4)
		;  
	\end{tikzpicture}
	\caption{%
		An example block-structured \wfnet. Each block corresponds to a node in the Jackson type
		$
		\jnsequence{
			p_1
		}{
			\jnsequence{
				t_1
			}{
				\jnsequence{
					\jnselfloop{
						\jnsequence{
							p_2
						}{
							\jnsequence{
								\jnchoice{t_2}{t_3}
							}{
								p_3
							}
						}
					}{
						t_4
					}
				}{
					\jnsequence{
						t_5
					}{
						p_4
					}
				}
			}
		}
		$. As example, the choice between transitions $t_2$ and $t_3$ corresponds to the node %
		$
		\jnsequence{p_2}{\jnsequence{\jnchoice{t_2}{t_3}}{p_3}}
		$
		.
	}
	\label{fig:example_wfnet}
\end{figure}

%\newcommand{\ptsequence}[1]{\ensuremath \rightarrow \left( #1 \right)}
%\newcommand{\ptselfloop}[2]{\ensuremath \circlearrowleft \left( #1 , #2 \right)}
%\newcommand{\ptparallel}[1]{\ensuremath \wedge \left( #1 \right)}
%\newcommand{\ptchoice}[1]{\ensuremath \times \left( \right)}


\subsection{Jackson Nets} \seclabel{jackson_nets}
% Hierarchical WFN
Whereas \wfnets do not put any restriction on the control flow of activities, block-structured \wfnets divide the control flow in logical blocks~\cite{KoppMWL15_DifferenceGraphBlockStructure}. Each ``block'' represents a single unit of work that can be performed, where this unit of work is either atomic (single transition), or one involving multiple steps (multiple transitions). 
An example block-structured \wfnet is shown in \figref{example_wfnet}.
The main advantage of block-structured \wfnets, is that the block-structure ensures that the \wfnet is sound by definition~\cite{KoppMWL15_DifferenceGraphBlockStructure,Leemans2013,vanHee2009}.
%An example block-structured \wfnet is shown in \figref{example_wfnet}. %
%Block-structured \wfnets can be represented by process trees~\cite{Leemans2013}. 
%A process tree is a rooted tree, where leaves represent activities and intermediate nodes represent operators. 
%Process trees describe a particular language, and its operators describe the semantics of how the languages of the subtrees (which are process trees) are to be combined.
%
%\begin{definition}[Process Tree~\cite{Leemans2013}] \deflabel{process_tree}
%	Let $\A$ be an alphabet of activities, and $\bigoplus = \set{\ptsequenceop, \ptparallelop,\ptchoiceop,\ptselfloopop}$ a set of operators, standing for sequences, parallelism, choices, and loops, respectively~\cite{Leemans2013}.
%	A \emph{process tree} is defined recursively: any $a \in \A$ is a process tree, and given  $M_1, \ldots, M_n$ for $n > 0$  process trees, and $\oplus \in \bigoplus$ an operator, then $\oplus\left(M_1, \ldots, M_n\right)$ is a process tree.
%\end{definition}
%
%\jmw{Add semantics of process trees}
%
%We consider the set of operators  This set of operators translates to well-structured, free-choice \pns~\cite{vanderAalst2000}.
%
%An example process tree, and its semantics as a Petri net is depicted in \figref{example_wfnet}. 
%The root of the process tree is the sequence operator ($\ptsequenceop$) on five sub trees, where $t_1$, $t_8$ and $t_{11}$ are leaves, and 
%$\ptselfloop{ 
%	\ptchoice{
%		\ptsequence{t_2, t_3 },
%		\ptsequence{t_4, t_5 }
%	}
%}{ t_6, t_7 }$
%and
%$\ptparallel{
%	t_9, t_{10}
%}$ 
%are two sub process trees inside the sequence operator.
%\db{Paragraph: explanation of example / Describe the example better; change figure to add something for the individual blocks}
%In the caption of \figreffull{example_wfnet}, we state directly its corresponding process tree. The construction of this process tree is relatively straightforward. When looking at the \wfnet, one can see that the first executed transition is $t_1$. Then, sequentially ($\rightarrow$), there is an entire block that is looped ($\circlearrowleft$); in the loop body a choice ($\times$) must be made between sequences $\rightarrow (t_2, t_3)$ or $\rightarrow (t_4, t_5)$, and looping itself can be achieved using either $t_6$ or $t_7$. After any number of loops (including 0), the process can (sequentially) continue with the execution of $t_8$, after which there is parallel ($\wedge$) execution of $t_9$ and $t_{10}$. The process ends with the final transition $t_{11}$. It is now easy to see that the process tree corresponding to the \wfnet from \figreffull{example_wfnet} is indeed $\rightarrow \left(t_1, \circlearrowleft \left(\times \left(\rightarrow \left(t_2, t_3\right), \rightarrow \left(t_4, t_5\right)\right), t_6, t_7\right), t_8, \wedge \left(t_9, t_{10}\right), t_{11}\right)$.
%As two process trees with different structures can express the same behavior, the following rewrite rules are used to define a normal forms, i.e., if two process trees have the same behavior, they have isomorphic normalized process tree.
%
%\begin{definition}[Normal Form for Process Trees~\cite{Leemans2013}] \proplabel{property_10_leemans}
%	Given a process tree, its normal form is derived by transforming it according to following identities:
%	\begin{eqnarray}
%		\oplus(M) & \equiv & M  \label{itm:pt1}\\
%		\times (\cdots_1, \times (\cdots_2), \cdots_3) & \equiv & \times(\cdots_1, \cdots_2, \cdots_3) \label{itm:pt2}\\
%		\rightarrow (\cdots_1, \rightarrow (\cdots_2), \cdots_3) & \equiv & \rightarrow(\cdots_1, \cdots_2, \cdots_3) \label{itm:pt3}\\
%		\wedge (\cdots_1, \wedge (\cdots_2), \cdots_3) & \equiv & \wedge(\cdots_1, \cdots_2, \cdots_3) \label{itm:pt4}\\
%		\circlearrowleft(\circlearrowleft(M, \cdots_1), \cdots_2) & \equiv & \circlearrowleft(M, \cdots_1, \cdots_2) \label{itm:pt5}\\
%		\circlearrowleft(M, \cdots_1, \times(\cdots_2), \cdots_3)  & \equiv & \circlearrowleft(M, \cdots_1,\cdots_2,\cdots_3)  \label{itm:pt6}
%	\end{eqnarray}
%%	Note that the underlying idea of these identities is to combine multiple nested subtrees with the same operator into a single node.
%\end{definition}
%
%\begin{example} \exlabel{example_wfnet_process_tree}
%	Process tree corresponding to the model shown in \figref{example_wfnet}.
%	$$
%	\rightarrow \left(t_1, \circlearrowleft \left(\times \left(\rightarrow \left(t_2, t_3\right), \rightarrow \left(t_4, t_5\right)\right), \times\left(t_6, t_7\right)\right), t_8, \wedge \left(t_9, t_{10}\right), t_{11}\right)
%	$$
%	Note that we have made explicit the choice in loopback paths by applying \propref{property_10_leemans}.
%\end{example}
%
%Different notations exist to represent block-structured \wfnets.
In this paper, we consider Jackson Types and Jackson Nets~\cite{vanHee2009}. 
A Jackson Type is a data structure used to capture all information involved in a single execution of a \wfnet. 

%\begin{definition}[Jackson Types~\cite{vanHee2009}] A \emph{Jackson type} \J is defined recursively by $\J ::= \mathscr A \mid (\J;\J) \mid {(\J||\J)} \mid (\J+\J) \mid (\J\#\J)$, where $\mathscr{A} = \mathscr{ A}^{p} \cup \mathscr{A}^{t} = \left\{a, b, c, \ldots \right\}$ denotes two disjoint sets of atomic types for places and transitions, resp., and symbols $;, ||, +, \#$ stand for types in sequence, parallelism, choices, and loops
%\end{definition}

\begin{definition}[Jackson Type~\cite{vanHee2009}]
	The set of \emph{Jackson Types} $\J$ is recursively defined by the following grammar: %recursively as:
	\begin{align*}
		\J & ::= \mathscr A ^p \mid 
		\jnsequence{\mathscr A^p}{\jnsequence{\J^t}{\mathscr A^p}}
		\\
		\J^t & ::= \mathscr A ^t \mid 
		\jnsequence{\J^t}{\jnsequence{\J^p}{\J^t}}
		\mid \jnchoice{\J^t}{\J^t} \\
		\J^p & ::= \mathscr A ^p \mid 
		\jnsequence{\J^p}{\jnsequence{\J^t}{\J^p}} \mid 
		\jnparallel{\J^p}{\J^p} \mid 
		\jnselfloop{\J^p}{\J^t}
	\end{align*}
where $\mathscr{A} = \mathscr{A}^{p} \cup \mathscr{A}^{t} = \left\{a, b, c, \ldots \right\}$ denotes two disjoint sets of atomic types for places and transitions, resp., and symbols $\jnsequenceop, \jnparallelop, \jnchoiceop, \jnselfloopop$ stand for sequence, parallelism, choices, and loops.
%Note how these correspond with the allowed graphical constructs of block-structured \wfnets.
\end{definition}

%As the operators in Jackson Types are all binary, an algebraic equivalence relation is defined to rewrite types into a normal form. \dbtodo{Some extra text explaining what this normal form is/does and why it's there? ; different types that represent the same model (also proved in paper Kees), but they have same behaviour. So: normal form to reason about a single thing.}
Multiple Jackson Types may exist for the same \wfnet.
For example, the Jackson Type
$
\jnsequence
{
	\jnsequence{p_1}{t_1}
}
{
	\jnsequence
	{
		\jnselfloop{
			\jnsequence{
				p_2
			}{
				\jnsequence{
					\jnchoice{t_2}{t_3}
				}{
					p_3
				}
			}
		}{
			t_4
		}
	}
	{
		\jnsequence{t_5}{p_4}
	}
}
$
describes the \wfnet of \figref{example_wfnet} as well.
%Since a \wfnet may have multiple Jackson types, we use a normal form.
Each net has a unique representation~\cite{vanHee2009}, called its normal form.
We define an algebraic equivalence between types to allow rewriting into the normal form.
%The normalized Jackson type essentially pushes all parentheses to the right by employing the identities from \defref{algebraic_equivalence}.
\begin{definition}[Algebraic equivalence, normal form~\cite{vanHee2009}] \deflabel{algebraic_equivalence}
The \emph{algebraic\\ equivalence} $\algequiv$ is the smallest equivalence relation on the set of Jackson Types that satisfies the following six rules:
\begin{equation*}\begin{array}{rclcrcl}                                                                                 %
	\jnsequence{\jnsequence{J_0}{J_1}}{J_2} & \algequiv & \jnsequence{J_0}{\jnsequence{J_1}{J_2}} &\  &  %
\jnchoice{\jnchoice{J_0}{J_1}}{J_2} & \algequiv & \jnchoice{J_0}{\jnchoice{J_1}{J_2}} \\                 %
\jnparallel{\jnparallel{J_0}{J_1}}{J_2} & \algequiv & \jnparallel{J_0}{\jnparallel{J_1}{J_2}} &\  &      %
\jnchoice{J_0}{J_1} & \algequiv & \jnchoice{J_1}{J_0} \\                                                 %
\jnparallel{J_0}{J_1} & \algequiv & \jnparallel{J_1}{J_0} & \  &                                          %
\jnselfloop{\jnselfloop{J_0}{J_1}}{J_2} & \algequiv & \jnselfloop{J_0}{\jnselfloop{J_1}{J_2}}            %
\end{array}
\end{equation*}
with $J_0, J_1, J_2 \in \J$ three Jackson Types.

A Jackson Type is in \emph{normal form} iff all brackets are moved to the right using the above rules.
\end{definition}
%
%%\subsection{Jackson nets} \seclabel{jackson_nets}
%%JACKSON NET
%While process trees show nicely the relation between different activities, they are unable to represent any information regarding the data flow corresponding to the process. Jackson nets (\jns) -- a specific type of colored {\pn} -- make data information explicit. They are based upon the set of Jackson types, which rest upon the concept of a (data) type. A \emph{type} \J is defined as $\J ::= \mathscr A \mid (\J;\J) \mid {(\J||\J)} \mid (\J+\J) \mid (\J\#\J)$, where $\mathscr{A} = \mathscr{ A}^{p} \cup \mathscr{A}^{t} = \left\{a, b, c, \ldots \right\}$ denotes a set of atomic types for places and transitions, respectively, and symbols $;, ||, +, \#$ stand for types in sequence, parallelism, choices, and loops~\cite{vanHee2009}. 

%\begin{property}[Algebraic Equivalence on Types~\cite{vanHee2009}] \proplabel{algebraic_equivalence_types}
%	Two types are algebraic equivalent if they abide by the identity rules:
%	\begin{eqnarray}
%		(J_0 ; J_1) ; J_2 & \equiv_{alg} & J_0 ; (J_1 ; J_2) \label{itm:jn_identity1} \\ 
%		(J_0 {||} J_1) {||} J_2 & \equiv_{alg} & J_0 {||} (J_1 {||} J_2) \label{itm:jn_identity2}\\ 
%		J_0 {||} J_1 & \equiv_{alg} & J_1 {||} J_0 \label{itm:jn_identity3} \\ 
%		(J_0 + J_1) + J_2 & \equiv_{alg} & J_0 + (J_1 + J_2) \label{itm:jn_identity4} \\ 
%		J_0 + J_1 & \equiv_{alg} & J_1 + J_0  \label{itm:jn_identity5} \\ 
%		(J_0 \# J_1) \# J_2 & \equiv_{alg} & J_0 \# (J_1 + J_2) \label{itm:jn_identity6}
%	\end{eqnarray}
%	with $J_0, J_1, J_2 \in \J$ three (potentially identical) types.
%\end{property}




%Notice how these four constructs seem to correspond with the four operators $\set{\rightarrow, \wedge,\times,\circlearrowleft}$ from \defref{process_tree}. 

%\db{Two types (not Jackson types) are algebraic equivalent if following holds ...}

%As to obtain a type that is valid for a block-structured \wfnet, we constrain the allowed operators between types such that, among others, a type for a place is always followed by a type of a transition, and vice versa. The set of constrained types are the \emph{Jackson Types}. Realize that since the algebraic equivalence rules in \propref{algebraic_equivalence_types} are defined for arbitrary types, they hold for Jackson types as well.

%\db{Different notation from original paper: they use $\tau$ for a single Jackson type, but we want to use that for a silent step (? Do we?). So, I've decided to simply make all normal J's calligraphic, and then write single type with capital J.}

The class of Jackson Nets is obtained by recursively applying \emph{generation rules}, starting from a singleton net with only one place. 
These generation rules are similar to those defined by Murata~\cite{Murata1989} and preserve soundness~\cite{vanHee2009}. 
%Indeed, it is shown that the generation rules for \jns too preserve soundness, and as such \jns are sound by construction~\cite{vanHee2009}.
Thus, any Jackson Net is sound by construction. 

\begin{definition}[Jackson Net~\cite{vanHee2009}] \deflabel{jackson_net}
	A \wfnet $N = (\places, \transitions, \flow, \inp, \outp)$ is called a \emph{Jackson Net} if it can be generated from a single place $p$ by applying the following five generation rules recursively:
%	\begin{enumerate}[label=J\arabic*]%, wide = 0pt, leftmargin=\parindent]
%		\item \label{itm:jn_R1} Sequential place split: %$\ell(p_1) = \left(\ell (p_2) ; \left(\ell (t_1) ; \ell (p_3)\right)\right)$
%		$p \leftrightarrow \jnsequence{p_1}{\jnsequence{t}{p_2}}$
%		\item \label{itm:jn_R2} Sequential transition split: 
%		%$\ell(t_1) = \left(\ell (t_2) ; \left(\ell (p_1) ; \ell (t_3)\right)\right)$
%		$ t \leftrightarrow \jnsequence{t_1}{\jnsequence{p_1}{t_2}}$
%		\item \label{itm:jn_R3} Loop Addition: 
%		%$\ell(p_1) = \left( \ell(p_2)\# \ell(t_1)\right)$
%		$p \leftrightarrow \jnselfloop{p}{t}$
%		\item \label{itm:jn_R4} AND split:  
%		%$\ell(p_1) = \left( \ell(p_2) ||  \ell(p_3)\right)$
%		$p \leftrightarrow \jnparallel{p_1}{p_2}$
%		\item \label{itm:jn_R5} OR split: 
%		%$\ell(t_1) = \left( \ell(t_2) +  \ell(t_3)\right)$
%		$ t \leftrightarrow \jnchoice{t_1}{t_2}$
%	\end{enumerate}
\begin{equation*}
	\begin{array}{llcll}
\mbox{J1:} & p \leftrightarrow \jnsequence{p_1}{\jnsequence{t}{p_2}} & \ \  &
\mbox{J4:} & p \leftrightarrow \jnparallel{p_1}{p_2}\\
\mbox{J2:} & t \leftrightarrow \jnsequence{t_1}{\jnsequence{p_1}{t_2}} & &
\mbox{J5:} & t \leftrightarrow \jnchoice{t_1}{t_2} \\
\mbox{J3:} & p \leftrightarrow \jnselfloop{p}{t} & & & \\
\end{array}
\end{equation*}
We say that $N$ is generated by $p$.
\end{definition}

As shown in~\cite{vanHee2009}, Jackson Nets are completely determined by Jackson Types, and vice versa. 

\begin{theorem}[Jackson Nets and Jackson Types are equivalent~\cite{vanHee2009}]
Let $N_1$ and $N_2$ be two Jackson Nets that are generated by the Jackson Types $J_1$ and $J_2$, resp. Then $N_1$ and $N_2$ are isomorphic iff $J_1 \algequiv J_2$.
\end{theorem}
%\db{Change below paragrah: don't use example but let text flow; refer to the main image top right for the model itself; then explain shortly where this sequence part comes from. }
%It should be noted that these generation rules for Jackson nets can also be used for reduction. For example, 
%In the Jackson net in the top right of \figref{process_tree_to_jackson_net_overview} we observe  the structure $(t_2;p_3;t_3)$ as the leftmost child node of the loop body. Using \ref{itm:jn_R1} we can reduce the sequence to a single (new) transition $t$, obtaining a new (sound) Jackson Net.

%\begin{example} \exlabel{example_wfnet_jackson_net}
%	Jackson type corresponding to the model shown in \figref{example_wfnet}.%
%	\vspace{0.2em}
%	\begin{dmath*}
%		\left(\ell\left(p_1\right);\left(\ell\left(t_1\right);\left(\ell\left(p_2\right)\#\left(\left(\ell\left(t_2\right);\left(\ell\left(p_3\right);\ell\left(t_3\right)\right)\right)+\left(\ell\left(t_4\right);\left(\ell\left(p_4\right);\ell\left(t_5\right)\right)\right)\right)\right); \\
%		\left(\left(\ell\left(t_6\right)+\ell\left(t_7\right)\right);\left(\ell\left(p_5\right);\left(\ell\left(t_8\right);\left(\ell\left(p_6\right);\left(\ell\left(t_9\right);\ell\left(p_7\right)\right)\right)||\left(\ell\left(p_8\right);\left(\ell\left(t_{10}\right);\ell\left(p_9\right)\right)\right)\right); \\
%		\left(\ell\left(t_{11}\right);\ell\left(p_{10}\right)\right)\right)\right)\right)\right)
%	\end{dmath*}%
%	\vspace{0.2em}
%	% Note that to obtain this \jn we have applied the algebraic equivalence from \propref{algebraic_equivalence_vanhee}, to make the choice in loopback paths explicit.
%\end{example}


%\begin{property}[Definition 6 from~\cite{vanHee2009}] \proplabel{algebraic_equivalence_vanhee}
%	Let $a, b, c \in \mathscr{A}$ three atomic types. Then the following holds, where $\equiv_{alg}$ denotes algebraic equivalence.
%	$$
%	\left(a \# \left(b \# c \right) \right) \equiv_{alg} a \# \left(b + c\right)
%	$$
%\end{property}


%\subsection{Jackson Nets are Process Trees} \seclabel{jns_are_pts}

%.{\seqarr}  $t_1$ {\looparr} $t_8$ $\wedge$ $t_0$ $t_{10}$ $t_{11}$]
%\begin{figure}[t]
%	\centering
%	\begin{tikzpicture}[sibling distance=-2pt, level distance = 18pt,scale=0.7]
%		\begin{scope}
%			\node[yshift=4mm](N1){\textsf{\textbf{Process tree}}};
%			\Tree [.{\seqarr}  [.\node(T1a1){$t_1$}; ] [.{\looparr} [.$\times$ [.{\seqarr} $t_2$ $t_3$ ] [.{\seqarr}  $t_4$ $t_5$ ] ] $t_6$ $t_7$ ] [.$t_8$ ]  [.$\wedge$ $t_9$ $t_{10}$ ] [.\node(T1a2){$t_{11}$}; ]  ]
%			\node[above of = T1a1,yshift=-2mm](a1t1){};
%			\node[right of = T1a2,yshift=-18mm,xshift=.6cm](a2t1){};
%			\node[below of = N1,yshift=-13mm] (e1){};
%		\end{scope}
%		
%		
%		\begin{scope}[yshift=-6.2cm]
%			\node[yshift=4mm](N2){\textsf{\textbf{Explicit loopback paths}}};
%			\Tree [.{\seqarr}  [.\node(T2a1){$t_1$}; ] [.{\looparr} [.$\times$ [.{\seqarr} $t_2$ $t_3$ ] [.{\seqarr}  $t_4$ $t_5$ ] ] [.$\times$ $t_6$ $t_7$ ] ] [.$t_8$ ]  [.$\wedge$ $t_9$ $t_{10}$ ] [.\node(T2a2){$t_{11}$}; ]  ]
%			\node[above of = T2a1,yshift=-1mm,xshift=-1mm](a1t2){};
%			\node[right of = T2a2,yshift=24mm,xshift=8mm](a2t2){};
%			\node[above of = N2,yshift=-6mm] (e2){};
%			\node[below of = N2,xshift=19mm] (ee2){};
%		\end{scope}
%		
%		
%		\draw [Triangle-Triangle,thick,green1] (e1) --node[right]{(a)}++ (e2);
%		
%		\begin{scope}[xshift=10cm, level 1/.style={level distance=35pt}]
%			\node[yshift=4mm](N3){\textbf{\textsf{Jackson Type}}};
%			\Tree [.{;}  \node(T3a1){$p_1$};   $\hspace{3em}t_1\hspace{3em}$ [.$\hspace{-3em}\#\hspace{-3em}$ $\hspace{-6em}p_2\hspace{-6em}$ [.; [.$+$ [.; $t_2$ $p_3$ $t_3$ ] [.; $t_4$ $p_4$ $t_5$ ] ] [.$\hspace{-2em}+\hspace{-2em}$ $t_6$ $t_7$ ] $p_5$  ] ] $\hspace{-1em}t_8\hspace{-1em}$ [.||  [.; $p_6$ $t_9$ $p_7$ ] [.; $p_8$ $t_{10}$ $p_9$ ] ]   $\hspace{3em}t_{11}\hspace{3em}$ \node(T3a2){$p_{10}$}; ]
%			\node[above of = T3a1,yshift=3mm](a1t3){};
%			\node[right of = T3a2,yshift=-23mm,xshift=-37mm](a2t3){};
%			\node[below of = N3,yshift=-22mm] (e3){};
%		\end{scope}
%		
%		\begin{scope}[yshift=-6.2cm,xshift=10cm]
%			\node[yshift=4mm](N4){\textsf{\textbf{Reduced Normal Form}}};
%			\Tree [.{;}  \node(T4a1){$t_1$};  [.$\#$  [.$+$ [.; $t_2$ $t_3$ ] [.; $t_4$ $t_5$ ]  ]    [.$+$ $t_6$ $t_7$  ]  ] $t_8$ [.||   $t_9$  $t_{10}$  ]   \node(T4a2){$t_{11}$}; ]
%			\node[above of = T4a1,yshift=-1mm](a1t4){};
%			\node[right of = T4a2,yshift=24mm,xshift=-6.3cm](a2t4){};
%			\node[above of = N4,yshift=-6mm] (e4){};
%			\node[below of = N4,xshift=-18mm] (ee4){};
%		\end{scope}
%		
%		\draw [Triangle-Triangle,thick,byzantium] (e3) --node[right]{(b)}++ (e4);
%		\draw [Triangle-Triangle,thick,cadmiumorange] (ee2) --node[above]{(c)}++ (ee4);
%		
%		\begin{pgfonlayer}{background}
%			\filldraw [line width=4mm,join=round,cadmiumorange!20]
%			(a1t1.north west) rectangle ++(a2t1.south east)
%			(a1t2.north west) rectangle ++(a2t2.south east);
%			\filldraw [line width=4mm,join=round,blue-violet!20]
%			(a1t3.north west) rectangle ++(a2t3.south east)
%			(a1t4.north west) rectangle ++(a2t4.south east);
%		\end{pgfonlayer}
%		
%	\end{tikzpicture}
%	\caption{Visual illustration of the proof for \thmref{process_tree_is_jackson_net}: arrow \textcolor{green1}{\textbf{(a)}} normalizes the process tree, and makes loopback paths explicit. Arrow \textcolor{byzantium}{\textbf{(b)}} reduces and normalizes the Jackson type to its reduced normal form. Arrow \textcolor{cadmiumorange}{\textbf{(c)}} denotes the isomorphism.}
%	\label{fig:process_tree_to_jackson_net_overview}
%\end{figure}

%Process trees, Jackson Types and Jackson Nets are three representations for block-structured \wfnets. 
%In the remainder of this subsection, we prove that these representations are algebraic equivalent.
%The idea of the proof is visualised in \figref{process_tree_to_jackson_net_overview}.



%Here, the process tree (top left) has implicit loopback paths. In step \textcolor{BurntOrange}{\textbf{(a)}} these are made explicit by applying \propref{property_10_leemans}. The Jackson type (top right) has been constructed to also show the explicit choice in loopback paths by application of \propref{algebraic_equivalence_vanhee}. Step \textcolor{OliveGreen}{\textbf{(b)}} is a reduction operation defined on Jackson types, and \textcolor{Fuchsia}{\textbf{(c)}} denotes the relation between symbols. In other words, these are (in practice) the three required steps necessary to show that a process tree is equivalent to the Jackson type of a \jn.

%\begin{enumerate}[label=(\alph*)]
%	\item Make choices of loopback paths explicit for the loop operator.
%	\item Reduce the Jackson type (ensure that loopback paths are explicit) to its reduced form, while keeping control flow actions.
%	\item Map operators from process trees to those used by Jackson types and vice versa.
%\end{enumerate}

%\begin{figure}
%	\centering
%	\includegraphics[width=0.9\linewidth]{figs/process_tree_to_jackson_net_overview}
%	\caption{Illustration of steps taken to show that process trees are equivalent to Jackson nets.}
%	\label{fig:process_tree_to_jackson_net_overview}
%\end{figure}

%\dbtodo{Fix "equivalent" here; what do we consider to be equivalent? -> The underlying workflow nets are isomorphic}
%We argue that process trees are equivalent to the Jackson type of a \jn. The equivalence relation we consider is isomorphism between the underlying \wfnets of the process tree and the Jackson type. This is best demonstrated by the running example in \figreffull{process_tree_to_jackson_net_overview}. The process tree in the top left shows \textit{implicit loopback paths} in the loop block $\circlearrowleft(\cdots, t_6, t_7)$: either path $t_6$ or path $t_7$ is chosen. Clearly, there is a choice ($\times$) between these two loopback paths. By applying identity \ref{itm:pt6} from \propref{property_10_leemans} one can rewrite such that this choice is made explicit: $\circlearrowleft(\cdots, t_6, t_7)$ becomes $\circlearrowleft(\cdots, \times (t_6, t_7))$. We make the loopback paths explicit after transforming the process tree to the normal form, indicated by the arrow annotated with \textcolor{green1}{\textbf{(a)}}. As such, the resulting process tree in the bottom left is thus the normal form with explicit loopback paths.
%We also normalize the Jackson type in the top right. The Jackson type is first normalized, and then reduced to its reduced normal form. This normalization and reduction is denoted by the arrow annotated with \textcolor{byzantium}{\textbf{(b)}}.
%After transorming the top models into the bottom ones, it becomes clear that, for this example, the process tree and Jackson type on the bottom of the figure are indeed equivalent; the only difference is the symbols used for the (same) operations. The equivalence relation is denoted by \textcolor{cadmiumorange}{\textbf{(c)}}. We formalize this idea into \thmreffull{process_tree_is_jackson_net}, where we proof that, indeed, after transformations process trees and Jackson types are equivalent.




%REDUCED TYPE FROM VANHEE
%Jackson types are used to derive case trees fully describing the data attributes at each atomic action taken in a workflow. To derive a case tree, the original Jackson type is modified -- reduced -- to remove nodes that refer to places. After places are removed, the reduced Jackson type is simplified by removing superfluous sequence operator nodes. Note that control flow steps are usually also removed when creating a reduced Jackson type, as these do not have corresponding steps in the data flow. For our purpose, we keep actions that are solely describing control flow. The reduction of the Jackson type corresponds to the \textcolor{OliveGreen}{\textbf{green}} arrow labeled \textcolor{OliveGreen}{\textbf{(b)}} in \figreffull{process_tree_to_jackson_net_overview}.

%CREATE FUNCTION THAT MAPS OPERATORS
%\begin{definition} \deflabel{process_tree_to_jackson_net_relation}
%	Let $G$ be a relation such that $\set{(\rightarrow, ;), (\times, +), (\circlearrowleft, \#), (\wedge, ||)} \subseteq G$.
%\end{definition}

%When comparing the reduced Jackson type (with kept control flow actions) to the process tree showing the explicit choice between loopback paths, it becomes clear that these models are identical. As such, we propose \thmref{process_tree_is_jackson_net}.
%This is formalized by means of relation $F$ from \defreffull{process_tree_to_jackson_net_relation}: each operator used in process trees maps one-to-one with an operator used in the Jackson type. By exchanging the operators from one model to another, again a valid model is obtained, either as reduced Jackson type or as process tree with explicit loopback paths. The application of $G$ from either side corresponds to the \textcolor{Fuchsia}{\textbf{purple}} arrow labeled  \textcolor{Fuchsia}{\textbf{(c)}} in \figreffull{process_tree_to_jackson_net_overview}.

%\db{How to formalize this as a proof?}

%\begin{theorem}
%Process trees are a subclass of Jackson nets.
%\end{theorem}
%\andy{\textbf{we need to rewrite the theorem}\\ 
%the main idea: given a process tree, we can construct a jackson net that is equivalent to it\\
%translate process trees to jackson types}

%\db{Some connecting text here?}

%We formalize the above example into \thmreffull{process_tree_is_jackson_net}. Essentially, we take identical steps to those from \figreffull{process_tree_to_jackson_net_overview}, and show that the arrow denoted by \textcolor{cadmiumorange}{\textbf{(c)}} is an isomorphic equivalence (on the underlying \wfnets of the respective models).

%\begin{theorem} \thmlabel{process_tree_is_jackson_net}
%	Two process trees 
%	Given a process tree $\mathcal T$, we can construct a Jackson Net $N$ such that the underlying \wfnets of $\mathcal T$ and $N$ are isomorphic.
%	Process trees and Jackson nets are algebraic equivalent: let $\T$ a process tree, then we can construct a Jackson Net $N$ such that $\T \equiv_{alg} N$.
%\end{theorem}

%Algebraic equivalence means that the normal forms of process trees and Jackson types are isomorphic. You can rewrite A into B according to some rules, and the rules necessary here is just the mapping of operators.

%\db{Connecting paragraph sketching the proof?}
%\begin{proof}
%%	\dbtodo{TODO: Proof; see commented latex for previous attempt.}
%	Let $\T$ be a process tree. We define a \emph{place-fusing operator} as follows. Let $N = (\places_N, \transitions_N, \flow_N)$ and $M = (\places_M, \transitions_M, \flow_M)$ be two \emph{disjoint} \pns, and let $r: \places_N \to \places_M$ an injective function. Then $N \bowtie_{r} = (\places, \transitions, \flow)$ is their \emph{place-fused} \pn with $\places = \left(\places_N \union \places_M \right) \setminus \dom{r}$, $\transitions = \transitions_N \union \transitions_M$, and $\flow = \left(\flow_N\union \flow_M\right) \setminus \Union_{q \in \dom{r}} \left( \left( \set{q} \times \post{q} \right) \union \left( \pre {q}\times \set{q} \right) \right) \union \Union_{(p, q) \in r} \left( \left( \set{p} \times \post{q} \right) \union \left( \pre {p}\times \set{q} \right) \right) $.
%	We now show that, given $\T$,  we can construct an algebraic equivalent Jackson type, where algebraic equivalence means that we can ``rewrite'' the process tree to the Jackson type using the identities from \propref{property_10_leemans} (process trees) and \propref{algebraic_equivalence_types} (Jackson types). In fact, we only have to show equivalence between the process tree and the \emph{reduced} Jackson type, as the we can always invert the reduction back to its original Jackson type.
%	We consider following five cases:
%	\begin{case} \textbf{Single activity}.\\
%		In this case, $\T = t$, with $t$ some activity. Then trivially a reduced Jackson type exists that is algebraic equivalent: $t$.
%	\end{case}
%	\begin{case} \textbf{Sequence}. \\
%		In this case, $\T = {\rightarrow \left(\T_1, \T_2\right)}$ a sequence of sub-blocks \dbtodo{subtrees?} $\T_1$ and $\T_2$. By induction, there exist \jns $N$ and $M$ for $\T_1$ and $\T_2$ respectively. Then, place-fused $N \bowtie_{\{(out_N, in_M)\}\}} M$ has as corresponding reduced Jackson type $\J = (\T_1 ; \T_2)$. Clearly $\T$ and $\J$ are algebraically equivalent, their only differences laying in infix/prefix notation, and the symbol used for denoting sequences.
%	\end{case}
%	\begin{case} \textbf{Choice}. \\
%		\dbtodo{should come before loops since we use choices in the loops}
%	\end{case}
%	\begin{case} \textbf{Loop}. \\
%		In this case, $\T = {\circlearrowleft \left(\T_1, \T_2\right)}$, that is, the structured loop of the sub-block $\T_1$ with (potentially multiple) loopback path(s) $\T_2$. By induction, there exist \jns $N$ and $M$ for $\T_1$ and $\T_2$ respectively. Then, place-fused $N \bowtie_{\{(in_N, out_M), (out_N, in_M)\}\}} M$ has as corresponding Jackson type $\J = (\T_1\#\T_2)$. If $\T_2$ consists of a single activity, then clearly $\J$ and $\T$ are algebraically equivalent. Otherwise, when $\T_2$ consists of more than one activity, one must make loopback paths explicit by introducing the choice. However, since we have already shown algebraic equivalence for the choice operator in previous case, there again must exist an algebraic equivalent reduced Jackson type.
%	\end{case}
%\end{proof}

%To prove \thmreffull{process_tree_is_jackson_net}, we define a \textit{place-fusing operation} that takes two PNs, and returns a new PN with places fused according to an injective function $r$. 
 
%\begin{definition} \deflabel{merge_operator}
%	Let $N = (\places_N, \transitions_N, \flow_N)$ and $M = (\places_M, \transitions_M, \flow_M)$ be two \emph{disjoint} \pns,
%	and let $r: \places_N \to \places_M$ an injective function. Then $N \bowtie_{r} = (\places, \transitions, \flow)$
%	is their \emph{place-fused} \pn with $\places = \left(\places_N \union \places_M \right) \setminus \dom{r}$, $\transitions = \transitions_N \union \transitions_M$, and $\flow = \left(\flow_N\union \flow_M\right) \setminus \Union_{q \in \dom{r}} \left( \left( \set{q} \times \post{q} \right) \union \left( \pre {q}\times \set{q} \right) \right) \union \Union_{(p, q) \in r} \left( \left( \set{p} \times \post{q} \right) \union \left( \pre {p}\times \set{q} \right) \right) $.
%\end{definition}

%\db{Proof sketch of inductive proof:
%- briefly discuss single activity for PT and JN
%- are they the same: yes
%- repeat for sequence, choice, loop, parallel}
%\db{Is the proof just the same as the above paragraph, but then "in general"? So, first make loopback paths explicit, if they are present, by applying the property. Then, define function that maps symbols from process trees to jackson nets. How do we then get to "this is a reduced Jackson type"?}
%\dbtodo{Rewrite of proof still required}
%\begin{proof}
%	Let \T be a process tree corresponding to \wfnet $M_\T = (\places, \transitions, \flow, in, out)$. We can construct Jackson Net $N$ such that its underlying \wfnet $M_N$ is isomorphic to $M_\T$. 
%	% Single activity
%	\begin{case} \textbf{Single activity}. \\
%		In this case, $\T = a$, that is, a single activity $a$. Then $(\set{i, o}, \set{a}, \set{(i, a), (a, o)}, i, o, \ell)$ is the corresponding \jn, with $\ell(in);\ell(a);\ell(out)$ its Jackson type.
%	\end{case}
%	\begin{case} \textbf{Sequence}. \\
%		In this case, $\T = {\rightarrow \left(\T_1, \T_2\right)}$, that is, a sequence of process trees $\T_1$ and $\T_2$. By induction, there exist \jns $N$ and $M$ for $\T_1$ and $\T_2$ respectively. Then, place-fused $N \bowtie_{\{(out_N, in_M)\}\}} M$ is the Jackson type of its corresponding \jn. Bisimilarity follows directly from \defref{merge_operator}.
%	\end{case}
%	\begin{case} \textbf{Choice}. \\
%		In this case, $\T = {\times \left(\T_1, \T_2\right)}$, that is, the choice of process trees $\T_1$ and $\T_2$. By induction, there exist \jns $N$ and $M$ for $\T_1$ and $\T_2$ respectively. Then, place-fused $N \bowtie_{\{(in_N, in_M), (out_N, out_M)\}\}} M$ is the Jackson type of its corresponding \jn. Bisimilarity follows directly from \defref{merge_operator}.
%	\end{case}
%	\begin{case} \textbf{Loop}. \\
%		In this case, $\T = {\circlearrowleft \left(\T_1, \T_2\right)}$, that is, the structured loop of process tree $\T_1$ with (potentially multiple) loopback path(s) $\T_2$. By induction, there exist \jns $N$ and $M$ for $\T_1$ and $\T_2$ respectively. Then, place-fused $N \bowtie_{\{(in_N, out_M), (out_N, in_M)\}\}} M$ is the Jackson type of its corresponding \jn. Bisimilarity follows directly from \defref{merge_operator}.
%	\end{case}
%	\begin{case} \textbf{Parallel}. \\
%		In this case, $\T = {\wedge \left(\T_1, \T_2\right)}$, that is, the interleaved execution of process trees $\T_1$ and $\T_2$. By induction, there exist \jns $M$ and $O$ for $\T_1$ and $\T_2$ respectively. \dbtodo{This needs to be written properly.}
%		% Construct new Nackson net; this is a workflow net.
%		We construct Jackson net $N = (\places_N, \transitions_N, \flow_N, in_N, out_N)$ from $N_1$ and $N_2$ such that $\places_N = \places_M \union \places_O \union \set{in_N, out_N}$, $\transitions_N = \transitions_M \union \transitions_O \union \set{\tau_1, \tau_2}$ where $\tau_1$ and $\tau_2$ are silent steps, and $\flow_N = \flow_M \union \flow_O \union \set{(in_N, \tau_1), (\tau_1, in_M), (\tau_1, in_O), (out_M, \tau_2), (out_O, \tau_2), (\tau_2, out_N)}$. \dbtodo{We need to define what a marking is, what the firing rule is, and what enabledness is, for \jns; for now I'm just assuming I can use these.}
%		% Define relation for bisimulation
%		We define $Q \subseteq \markings{\T} \times \markings{N}$ such that $(m_\T, m_N) \in Q \implies \forall p \in P: m_\T(p) = m_N(p)$ \dbtodo{perhaps we need a slightly different notion here due to types of places; depends on what a marking is for jackson nets}.
%		% State what we want to show
%		Let $(m_\T, m_N) \in Q$, and $\fire{(\T, m_\T)}{t}{(\T, m_\T')}$ for some arbitrary $t \in \transitions$.
%		We need to show that there exists some $m_N'$ such that $\fire{(N, m_N)}{t}{(N, m_N')}$, and that $(m_\T', m_N') \in Q$.
%		% Actual proof
%		Since $(m_\T, m_N) \in Q$, and $\fire{(\T, m_\T)}{t}{(\T, m_\T')}$, by definition of $Q$ there must exist some $m_N'$ obtained after firing $t$ from $m_N$ \dbtodo{Is this true?}. As such, $\fire{(N, m_N)}{t}{(N, m_N')}$.
%		That $(m_\T', m_N') \in Q$ follows directly from the firing rules and the definition of $Q$ \dbtodo{probably need some more argumentation here}.
%		\dbtodo{This proves one direction; still need to do the other one where there is no longer strong bisim due to $\tau$.}
%	\end{case}
%\end{proof}

\subsection{Petri Nets with Identifiers} \seclabel{petrinets_identifiers}
% Systems as petri nets with identifiers
Whereas \wfnets describe all possible executions for a single case, 
systems typically consist of many interacting processes.
The latter can be modeled using typed Petri nets with identifiers (\tpnids for short)~\cite{vanderWerf2022}.
In this formalism, each object is typed and has a unique identifier to be able to refer to it.
Tokens carry vectors of identifiers, which are used to relate objects.
Variables on the arcs are used to manipulate the identifiers.
% Sentence below is already too verbose?
%\dbtodo{We define sets of identifiers, type labels, and variables in \defref{identifier_types}.}

\begin{definition}[Identifiers, Types and Variables] \deflabel{identifier_types}
	Let \idset, \labelset, and \varset denote countably infinite sets of identifiers, type labels, and variables, respectively. We define:
	\begin{compactitem}
			\item the \emph{domain assignment} function $I : \labelset \rightarrow \powerset{\idset}$, such that $I(\lambda_1)$ is an infinite set, and $I(\lambda_1) \cap I(\lambda_2) \neq \emptyset$ implies $\lambda_1 = \lambda_2$ for all $\lambda_1, \lambda_2 \in \labelset$;
			\item the \emph{id typing} function $\type_{\idset}:\idset\to\labelset$ s.t.\ if $\type_{\idset}(\cname{id})=\lambda$, then $\cname{id}\in I(\lambda)$;
			\item a \emph{variable typing} function $\type_{\varset}:\varset\to\labelset$, prescribing that $x\in\varset$ can be substituted only by values from $I(\type_{\varset}(x))$.
		\end{compactitem}
	When clear from the context, we omit the subscripts of $\type$.
	We lift the $\type$ functions to sets, vectors, and sequences by applying the function on each of its constituents.
\end{definition}

In a \tpnid, each place is annotated with a label, called the \emph{place type}.
A place type is a vector of types, indicating types of identifier tokens the place can carry. Similar to Jackson Types, we use $\jnplace{p}{\lambda}$ to denote that place $p$ has type $\alpha(p) = \lambda$.
%\dbtodo{We use $[p, \lambda]$ to denote a place $p$ with $\alpha(p) = \lambda$.}
%Using $\alpha$, places are annotated with its place type.
%We write $\jnplace{p}{\lambda}$ for place $p$ with place type $\lambda$.
%A place with an empty place type, represented by the empty vector, is a classical Petri net place carrying indistinguishable (black) tokens.
Each arc is inscribed with a multiset of vectors of identifiers, such that the type of each variable coincides with the place types.
%This allows to model situations in which a transition may require multiple tokens with different identifiers from the same place.
%Using $\beta$, arcs are annotated with vectors of variables called \emph{inscriptions}. 
If the inscription is empty or contains a single element, we omit the brackets. 

\begin{definition}[Typed Petri net with identifiers] \deflabel{tpnids}
	A \emph{typed Petri net with identifiers} (\tpnid) $N$ is a tuple $(\places,\transitions,\flow,\alpha,\beta)$, where:
	\begin{compactitem}
			\item $(\places,\transitions,\flow)$ is a classical Petri net;
			\item $\alpha: \places \to \labelset^*$ is the \emph{place typing function};%, if $\alpha(p) = \emptysequence$, place $p$ can only carry black, i.e., uncolored, tokens;
			\item $\beta : \flow \to \setmult{(\varset^*)}$ defines for each arc a multiset of \emph{variable vectors} s.t.\ $\alpha(p) = \type(x)$ for any $x \in \setsupp{\beta((p,t))}$ and $\type(y)=\alpha(p')$ for any $y \in \setsupp{\beta((t,p'))}$ where $t\in\transitions$, $p\in\pre{t}$, $p'\in\post{t}$.
		\end{compactitem}
\end{definition}

%In the remainder of the paper we assume there exists a bijection on variables ($\varset$) and types ($\labelset$), and that there are no `classical' places: $\size{\alpha(p)} > 0$ for all $p \in P$.
%If an event log does not specify a type corresponding to a variable, then we say that these are equal.
%Since an event log is a sequence of events for a certain object type, we need to make the above assumptions to avoid undefined sequences without object type.
%We assign a GÃ¶del-like number $\godelsymb$ to each type to impose an ordering on arc inscriptions: if $\lambda = \sequence{x, y, z}$, then $\godel{x} < \godel{y} < \godel{z}$. 
%The induced total order is required to extend the notion of a normal form for Jackson nets to typed Jackson nets.
%Since the order of a type can be deduced by $\godelsymb$, we can use sequence and set notation interchangeably for arc inscriptions.

% TPNID semantics
A marking of a \tpnid is the configuration of tokens over the set of places.
Each token in a place should be of the correct type, i.e., the vector of identifiers carried by a token in a place should match the corresponding place type.
The set $\colset(\place)$ defines all possible vectors of identifiers a place $p$ may carry.

\begin{definition}[Marking] \deflabel{marking}
	Given a \tpnid $N = (\places, \transitions, \flow, \alpha, \beta)$, and place $\place \in \places$, its \emph{id set} is $\colset(\place) = \prod_{1 \leq i \leq |\alpha(\place)|} I(\alpha(\place)(i))$.
	A \emph{marking} is a function $\marking \in \markings{N}$, with $\markings{N} = \places \to \setmult{(\seq{\labelset})}$, such that $\marking(\place) \in \setmult{\colset(p)}$, for each place $\place \in \places$. The set of identifiers used in $\marking$ is denoted by $\Id(\marking) = \Union_{\place \in \places} \rng{\setsupp{\marking(\place)}}$
	The pair \markednet{N}{\marking} is called a \emph{marked \tpnid}.
\end{definition}

To define the semantics of a \tpnid, the variables need to be valuated with identifiers.

\begin{definition}[Variable sets~\cite{vanderWerf2022}] \deflabel{variable_sets}
	Given a \tpnid $N=(\places,\transitions,\flow,\alpha,\beta)$, $t\in \transitions$ and $\lambda \in \Lambda$, we define the following sets of variables:
	\begin{compactitem}
		\item \emph{input variables} as $\smash{\invar{t} = \bigcup_{x \in \beta((p,t)), p\in\pre{t}} \rng{\setsupp{x}}}$;
		\item \emph{output variables} as $\smash{\outvar{t} = \bigcup_{x \in \beta((t,p)),p \in\post{t}} \rng{\setsupp{x}}}$;
		\item \emph{variables} as $\var{t} = \invar{t} \cup \outvar{t}$;
		\item \emph{emitting variables} as $\newvar{t} = \outvar{t}\setminus\invar{t}$;
		\item \emph{collecting variables} as $\delvar{t} = \invar{t} \setminus \outvar{t}$;
		\item \emph{emitting transitions} as $E_N(\lambda) = \{ t \mid \exists x \in \newvar{t} \wedge \type(x) = \lambda \}$;
		\item \emph{collecting transitions} as $C_N(\lambda) = \{ t \mid \exists x \in \delvar{t} \wedge \type(x) = \lambda \}$;
		\item \emph{types in $N$} as \smash{$\type(N) = \{ \vec\lambda \mid \exists p \in P : \vec\lambda\in\alpha(p)\}$}.
	\end{compactitem}
\end{definition}

%As customary in colored Petri nets, the firing of a transition requires a \emph{binding} that valuates variables to identifiers.
A valuation of variables to identifiers is called a \emph{binding}.
Bindings are used to inject new fresh data into the net via variables that emit identifiers, i.e., via variables that appear only on the output arcs of that transition.
%We require bindings to be an injection, i.e., no two variables within a binding may refer to the same identifier.
Note that in this definition, freshness of identifiers is local to the marking, i.e., disappeared identifiers (those fully removed from the net through collecting transitions) may be reused, as it does not hamper the semantics of the \tpnid.
%Our semantics allow the use of well-ordered sets of identifiers, such as the natural numbers, as used in~\cite{Polyvyanyy2019,RosaVelardo2006} to ensure that identifiers are globally new.
%Here we assume local freshness over global freshness.

\begin{definition}[Firing rule for \tpnids]
 	Given a marked \tpnid $(N,m)$ with $N=(\places,\transitions,\flow,\alpha,\beta)$, a \emph{binding} for  transition $t\in T$ is an injective function  $\psi:\V\rightarrow \I$ such that
 	$\type(v) = \type(\psi(v))$
 	and
 	$\psi(v)\not\in \Id(m)$ iff $v\in\newvar{t}$.
 	Transition $t$ is \emph{enabled} in $(N,m)$ under binding $\psi$, denoted by $\pnenabled{(N,m)}{t,\psi}$ iff $\rho_\psi(\beta(p,t)) \leq m(p)$ for all $p\in\pre{t}$.
 	Its firing results in marking $m'$, denoted by $\fire{(N,m)}{t,\psi}{(N, m')}$, such that $m'(p) + \rho_\psi(\beta(p,t)) = m(p) + \rho_\psi(\beta(t,p))$. %for %$p \in \places$.%, for every $p\in\pre{t}\cup\post{t}$.
% 	The set of all finite firing sequences 
\end{definition}
The firing rule is inductively extended to sequences.
A marking $m'$ is \emph{reachable} from $m$ if there exists $\eta\in (\transitions\times(\V\rightarrow \I))^*$ such that $\fire{(N,m)}{\eta}{(N,m')}$.
 %For a marked \tpnid $(N,M)$, we denote with $\reachable{N}{M}$  the set of all markings reachable from $M$.
We denote with $\pnreachable{N}{m}$ the set of all markings reachable from $m$ for $\markednet{N}{m}$.
%\db{New text from here to def 10.}
We use $\L\markednet{N}{m}$ to denote all possible firing sequences of \markednet{N}{m}, i.e., $\L\markednet{N}{m} = \{\eta \mid \pnenabled{(N,m)}{\eta}{}\}$ and $\Id(\eta) = \bigcup_{(t,\psi) \in \eta} \rng{\psi}$ for the set of identifiers used in $\eta$.
The execution semantics of a \tpnid is defined as an LTS that accounts for all possible executions starting from a given initial marking.
We say two \tpnids are bisimilar if their induced transition systems are.

 \begin{definition}
	     Given a marked \tpnid $(N,m_0 )$ with $N=(P,T,F,\alpha,\beta)$, its induced transition system  is $\transitionsystem{N,m_0} = (\mathbb{M}(N),(T\times(\V\to\I)),m_0 , \to)$ with $m\xrightarrow{(t,\psi)} m'$ iff  $\fire{\markednet{N}{m}}{t,\psi}{\markednet{N}{m'}}$.
%	     \begin{compactitem}
%	     	 \item $S=\pnreachable{N}{m_0 }$ and $s_0=m_0 $,
%	     	 \item for $M,M^\prime\in S$ it holds that: 
%	     	 	$M\xrightarrow{(t,\psi)} M^\prime$ iff  $\fire{\marking}{t,\psi}{\marking^\prime}$. %for $t\in\transitions$ and binding $\sigma$. 
%	     \end{compactitem}
\end{definition}


%\dbtodo{Paragraph on indentifier soundness and why we care; make link with Jackson Nets as final note.}
Soundness properties for \wfnets typically consist of proper completion, weak termination, and quasi-liveness~\cite{AalstHHS11_soundness}. 
Extending soundness to \tpnids gives \emph{identifier soundness}~\cite{vanderWerf2022}.
%By extending to \tpnids, proper completion becomes proper type completion, and weak termination becomes weak type termination.
%The first intuitively means that objects of type $\lambda$ are created by emitters, and once consumed by a collector all objects with the same type should be consumed.
%Proper type completion intuitively means that the life-cycle of each type is proper completing: an object of a given type ``enters'' the system through an emitting transition, binding it to a unique identifier.
%Once a collecting transition fires, there should be no remaining tokens referring to the removed object.
%Weak type termination intuitively means that it should always be possible to eventually remove a type by firing a collecting transition.
In \tpnids, each object of a given type ``enters'' the system through an emitting transition, binding it to a unique identifier.
Identifier soundness intuitively states that it should always be possible to remove objects (weak type termination), and that once a collecting transition fires for an object, there should be no remaining tokens referring to the removed object (proper type completion). 

%\begin{definition}[Identifier Soundness~\cite{vanderWerf2022}]
%	Let $\markednet{N}{m_0}$ a marked \tpnid and $\lambda \in \Lambda$ some type.
%	$\markednet{N}{m_0}$ is \emph{$\lambda$-sound} iff it is
%	\begin{inparaenum}[\it (i)]
%		\item proper $\lambda$-completing, i.e., for all $t \in C_N(\lambda)$, bindings $\psi : \V\to\I$ and markings $m, m'\in\pnreachable{N}{m_0}$, if $\fire{m}{t,\psi}{m'}$, then for all identifiers $\cname{id} \in \rng{\restr{\psi}{\delvar{t}}} \cap \Id(m)$ and $\type(\cname{id})=\lambda$, it holds that $\cname{id}\not\in\Id(m')$\footnote{Here, we constrain $\psi$ only to objects of type $\lambda$ that are only consumed.};
%		\item weakly $\lambda$-terminating, i.e.,  for every $m \in \pnreachable{N}{m_0}$ and identifier $\cname{id} \in I(\lambda)$ such that $\cname{id} \in \Id(m)$, there exists a marking $m' \in \pnreachable{N}{m}$ with $\cname{id} \not\in \Id(m')$.
%	\end{inparaenum}
%	If it is $\lambda$-sound for all $\lambda\in \type(N)$, then it is \emph{identifier sound}.
%\end{definition}

\begin{definition}[Identifier Soundness~\cite{vanderWerf2022}]
	Let $\markednet{N}{m_0}$ a marked \tpnid and $\lambda \in \Lambda$ some type.
	$\markednet{N}{m_0}$ is \emph{$\lambda$-sound} iff it is
	\begin{compactitem}
		\item Proper $\lambda$-completing, i.e., for all $t \in C_N(\lambda)$, bindings $\psi : \V\to\I$ and markings $m, m'\in\pnreachable{N}{m_0}$, if $\fire{m}{t,\psi}{m'}$, then for all identifiers $\cname{id} \in \rng{\restr{\psi}{\delvar{t}}} \cap \Id(m)$ and $\type(\cname{id})=\lambda$, it holds that $\cname{id}\not\in\Id(m')$ \footnote{Here, we constrain $\psi$ only to objects of type $\lambda$ that are only consumed.};
		\item Weakly $\lambda$-terminating, i.e.,  for every $m \in \pnreachable{N}{m_0}$ and identifier $\cname{id} \in I(\lambda)$ such that $\cname{id} \in \Id(m)$, there exists a marking $m' \in \pnreachable{N}{m}$ with $\cname{id} \not\in \Id(m')$.
	\end{compactitem}
	If it is $\lambda$-sound for all $\lambda\in \type(N)$, then it is \emph{identifier sound}.
\end{definition}

	% \begin{definition}[Weak type termination]
		%     \label{def:termination}
		%     Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{weakly $\lambda$-terminating} iff
		%     for every $M \in \reachable{N}{M_0}$ and identifier $\cname{id} \in I(\lambda)$ such that $\cname{id} \in \id{M}$, there exists a marking $M' \in \reachable{N}{M}$ with $\cname{id} \not\in \id{M'}$.
		% \end{definition}
	
%	Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{proper $\lambda$-completing} iff for all $t \in C_N(\lambda)$, bindings $\psi : \V\to\I$ and markings $M, M'\in\reachable{N}{M_0}$, if $\fire{M}{t,\psi}{M'}$, then for all identifiers $\cname{id} \in \rng{\restr{\psi}{\delvar{t}}} \cap \id{M}$ and $\type(\cname{id})=\lambda$, it holds that $\cname{id}\not\in\id{M'}$.\footnote{Here, we constrain $\psi$ only to objects of type $\lambda$ that are only consumed.}
	
%	A marked \tpnid $(N,M_0)$ is \emph{$\lambda$-sound} iff it properly $\lambda$-completes and weakly $\lambda$-terminates.
%	It is \emph{identifier sound} iff it is $\lambda$-sound for every $\lambda\in \type(N)$.
	


% Each type has a life-cycle.
% Intuitively, an object of a given type ``enters'' the system via an emitter that creates a unique identifier that refers to the object.
% The identifier remains in the system, until the object ``leaves'' the system by firing a collecting transition (that binds to the identifier and consumes it).
% Hence, once that transition fires, there should be no remaining tokens referring to the removed object.
% The process of a type is a model that describes all possible paths allowed for a type.
% It can be represented as a transition-bordered WF-net~\cite{HeeSW13}.
% Instead of a sink and source place, a transition-bordered WF-net has transitions that represent the start and finish of a process.
% A transition-bordered WF-net is sound, if its closure is sound.
% As shown in Fig.~\ref{fig:tBorderedNet}, its closure is constructed by creating a new source place $i$ s.t. each emitting transition consumes from $i$, and a new sink place $f$ s.t. each collecting transition produces in $f$.
% Consider in \tpnid $N_{\mathit{rs}}$ of Fig~\ref{fig:overallModel}, identifier type $\mathit{order}$. Its life cycle starts with transition $G$. Transitions $K$ and~$V$ are two transitions that may remove the last reference to an $\mathit{order}$. Soundness of a transition-bordered WF-net would require that firing transition $K$ or transition $V$ would result in the final marking.
% In the remainder of this section, we develop this intuition into the concept of identifier soundness.


% Soundness constitutes three properties: proper completion, weak termination and quasi-liveness.
% Similarly to~\cite{HeeSV03}, we focus on the first two properties.
% \emph{Proper completion} states that if a marking covers the final marking, it is the final marking. In other words, as soon as a token is produced in the final place, all other places are empty.
% Following the idea of transition-bordered WF-nets, identifiers should have a similar behavioral property: once an identifier is consumed by a collector, the identifier should be removed from the marking.

% \begin{definition}[Proper type completion]
	%     Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{proper $\lambda$-completing} iff for all $t \in C_N(\lambda)$, bindings $\psi : \V\to\I$ and markings $M, M'\in\reachable{N}{M_0}$, if $\fire{M}{t,\psi}{M'}$, then for all identifiers $\cname{id} \in \rng{\restr{\psi}{\delvar{t}}} \cap \id{M}$ and $\type(\cname{id})=\lambda$, it holds that $\cname{id}\not\in\id{M'}$.\footnote{Here, we constrain $\psi$ only to objects of type $\lambda$ that are only consumed.}
	% \end{definition}
% %we restrict identifiers to Collect(t) so as to admit situations with subnets where a transition has two input places p1 and p2, both of the same type, F={(p1,t),(p2,t),(t,p2)} and beta(p1,t)=x and beta(p2,t)=y (obviously, y shouldn't be touched in that case)

% As an example, consider \tpnid $N_{\mathit{rs}}$ in Fig.~\ref{fig:overallModel}.
% For type $\mathit{customer}$, %the set of collecting transitions is 
% we have $C_{N_{\mathit{rs}}}(\mathit{customer}) = \{K, V\}$.
% In the current -- empty -- marking, transition $T$ is enabled with binding  $\psi = \{y\mapsto \cname{o}, z\mapsto \cname{c}\}$, which results in marking $M$ with $M(\textit{customer}) = [\cname{c}]$.
% Next, transitions $G$, $H$, $J$, $L$ and $N$ can fire, all using the same binding,
% producing marking $M'$ with $M'(p) = [\cname{o},\cname{c}]$, $M'(\mathit{customer}) =[\cname{c}]$ and $M'(q) = M'(r) = [\cname{c}]$.
% Hence, transition $K$ is enabled with binding $\psi$.
% %As $K \in \C_{N_{rs}}(\mathit{customer})$, it is a collector for type $\mathit{customer}$. 
% However, firing $K$ with $\psi$ results in marking $M''$ with $M''(\mathit{customer}) = [\cname{c}]$, while $\psi(z) = \cname{c}$.
% Hence, $N_{\mathit{rs}}$ is not properly $\mathit{customer}$-completing.

% %\medskip
% \emph{Weak termination} for a WF-net signifies that from any reachable marking, the final marking can be reached.
% Translated to identifiers, it should always eventually be possible to remove an identifier from a marking.

% \begin{definition}[Weak type termination]
	%     \label{def:termination}
	%     Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{weakly $\lambda$-terminating} iff
	%     for every $M \in \reachable{N}{M_0}$ and identifier $\cname{id} \in I(\lambda)$ such that $\cname{id} \in \id{M}$, there exists a marking $M' \in \reachable{N}{M}$ with $\cname{id} \not\in \id{M'}$.
	% \end{definition}

% %\medskip
% \emph{Identifier soundness} combines the two properties of proper type completion and weak type termination: the former ensures that as soon a collector fires for an identifier, the identifier is removed, whereas the latter ensures that it is always eventually possible to remove that identifier.

% %By joining together the previous definitions we obtain the one of identifier soundness.
% \begin{definition}
	%     \label{def:soundness}
	%     A marked \tpnid $(N,M_0)$ is \emph{$\lambda$-sound} iff it properly $\lambda$-completes and weakly $\lambda$-terminates. It is \emph{identifier sound} iff it is $\lambda$-sound for every $\lambda\in \type(N)$.
	% \end{definition}

% There are two interesting observations that one can make about the identifier soundness property. First, identifier soundness does not imply soundness in the classical sense: any classical net $N$ without types, i.e., $\type(N) = \emptyset$, is identifier sound, independently of the properties of $N$.

%As we use \tpnids to model interacting processes, we assume in the remainder of this paper that each place corresponds to at least one process, i.e., $\alpha(p) \neq \emptyset$ for any place $p \in P$, 

\subsection{Typed Jackson Nets} \seclabel{typed_jackson_nets}
%\dbtodo{Needs different text! We don't look at process trees anymore.}
%Now that we have established that \jns are equivalent to process trees, we argue that \emph{typed} Jackson nets (\tjns) are a natural extension to \jns by adding identifiers $\cname{id} \in \I$, and thus are a natural extension to process trees. We show the extension of \jns explicitly in \defref{typed_jackson_net} by relating the generation rules for \jns to the generation rules for \tjns. 
In general, identifier soundness is undecidable for \tpnids~\cite{vanderWerf2022}.
Similar as Jackson Nets restrict \wfnets to blocks, \emph{typed Jackson Nets} (\tjns) restrict \tpnids to blocks, while guaranteeing identifier soundness and liveness. 
%A \emph{typed} Jackson net (\tjn) is a \tpnid that is sound and live by construction~\cite{vanderWerf2022}.
For \tjns, we disallow multiplicity on arcs and variables, i.e., $\beta(f)(v) \le 1$ for all $f \in F$ and $v \in \V$, and imply a bijection on variables and identifier types.
This prevents place types like $\lambda = \sequence{x, x}$.
Assuming a G\"odel-like number on types (cf.~\cite{vanHee2009}), place types and arc inscriptions can be represented as sets.
Similar as Jackson Types describe Jackson Nets, we apply a notation based on Jackson Types to denote typed Jackson Nets.

%We argue that \tjns are a natural extension to \jns by adding identifiers $\cname{id} \in \I$.
%We show the extension of \jns explicitly in \defref{typed_jackson_net} by relating the generation rules for \jns to the generation rules for \tjns.

%\andy{we need to be specific on how arc inscriptions relate to each other (no need in elaborating on types due to the bijection assumption)}
\begin{definition}[Typed Jackson Net] \deflabel{typed_jackson_net}
	A \tpnid $N$ is a \emph{typed Jackson Net} if it can be generated from a set of transitions $T'$ by applying any of the following six generation rules recursively. If $N$ is generated from a singleton set of transitions (i.e., $\length{T'} = 1$), $N$ is called \emph{atomic}. 
	
	\begin{enumerate}[label=R\arabic*, wide = 0pt, leftmargin=\parindent]
		\item \label{itm:tjn_R1} Place Expansion:
		$
		\jnplace{p}{\lambda} \leftrightarrow
		\jnsequence{
			\jnplace{p_1}{\lambda}
		}{
			\jnsequence{
				t_1
			}{
				\jnplace{p_2}{\lambda}
			}
		}$
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm,thick,  every node/.style={scale=0.7}]
				
				\node[pl,label = below:$p$] (p){};
				\node[left of = p,yshift=8mm](in1){};
				\node[left of = p,yshift=-8mm](in2){};
				\node[right of = p,yshift=8mm](out1){};
				\node[right of = p,yshift=-8mm](out2){};
				
				\path[->] 
				(in1) edge node[above]{$\nu$} (p)
				(in2) edge node[above]{$\nu$} (p)
				(p) edge node[above]{$\nu$} (out1)
				(p) edge node[above]{$\nu$} (out2)
				;  
				
				\node[pl,right of = p, xshift=2.7cm, label = below:$p_1$] (p1){};
				\node[tr,right of = p1, label = center:$t$] (t){};
				\node[pl,right of = t, label = below:$p_2$] (p2){};
				\node[left of = p1,yshift=8mm](in1){};
				\node[left of = p1,yshift=-8mm](in2){};
				\node[right of = p2,yshift=8mm](out1){};
				\node[right of = p2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu$} (p1)
				(in2) edge node[above]{$\nu$} (p1)
				(p1) edge node[above]{$\mu$} (t)
				(t) edge node[above]{$\mu$} (p2)
				(p2) edge node[above]{$\nu$} (out1)
				(p2) edge node[above]{$\nu$} (out2)
				;  
				
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]p.east) -- ([xshift=-7.5mm]p1.west) ;
				
			\end{tikzpicture}
		\end{center}
	
		\item \label{itm:tjn_R2} Transition Expansion:
		$
		t \leftrightarrow
		\jnsequence{
			t_1
		}{
			\jnsequence{
				\jnplace{p}{\lambda}
			}{
				t_2
			}
		}
		$%
		, with $\var{t} \subseteq \lambda$
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm, thick,  every node/.style={scale=0.7}]
				\node[tr,label = center:$t$] (t){};
				\node[left of = t,yshift=8mm](in1){};
				\node[left of = t,yshift=-8mm](in2){};
				\node[right of = t,yshift=8mm](out1){};
				\node[right of = t,yshift=-8mm](out2){};
				
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (t)
				(in2) edge node[above]{$\nu_2$} (t)
				(t) edge node[above]{$\nu_3$} (out1)
				(t) edge node[above]{$\nu_4$} (out2)
				;  
				
				\node[tr,right of = t, xshift=2.7cm, label = center:$t_1$] (t1){};
				\node[pl,right of = t1, label = below:$p$] (p){};
				\node[tr,right of = p, label = center:$t_2$] (t2){};
				\node[left of = t1,yshift=8mm](in1){};
				\node[left of = t1,yshift=-8mm](in2){};
				\node[right of = t2,yshift=8mm](out1){};
				\node[right of = t2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (t1)
				(in2) edge node[above]{$\nu_2$} (t1)
				(t1) edge node[above]{$\mu$} (p)
				(p) edge node[above]{$\mu$} (t2)
				(t2) edge node[above]{$\nu_3$} (out1)
				(t2) edge node[above]{$\nu_4$} (out2)
				;  
				
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]t.east) -- ([xshift=-7.5mm]t1.west) ;		
			\end{tikzpicture}
		\end{center}
	
		\item \label{itm:tjn_R3} Place Duplication:
		$
		\jnsequence{t_1}{\jnsequence{\jnplace{p}{\lambda}}{t_2}} \leftrightarrow
		\jnsequence{t_1}{\jnsequence{\jnparallel{\jnplace{p}{\lambda}}{\jnplace{p'}{\lambda'}}}{t_2}}
		$%
		, \\with $\lambda' \cap \newvar{\post{p}} = \emptyset$\\ 
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm, thick,  every node/.style={scale=0.7}]
				\node[tr, label = center:$t_1$] (t1){};
				\node[pl,right of = t1, label = below:$p$] (p){};
				\node[tr,right of = p, label = center:$t_2$] (t2){};
				\node[left of = t1,yshift=8mm](in1){};
				\node[left of = t1,yshift=-8mm](in2){};
				\node[right of = t2,yshift=8mm](out1){};
				\node[right of = t2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (t1)
				(in2) edge node[above]{$\nu_2$} (t1)
				(t1) edge node[above]{$\mu_1$} (p)
				(p) edge node[above]{$\mu_2$} (t2)
				(t2) edge node[above]{$\nu_3$} (out1)
				(t2) edge node[above]{$\nu_4$} (out2)
				;  
				
				
				
				\node[tr,right of = t2, xshift=2.7cm, label = center:$t_1$] (tt1){};
				\node[pl,right of = tt1, label = below:$p$,yshift=8mm] (p1){};
				\node[pl,right of = tt1, label = below:$p'$,yshift=-8mm] (p2){};
				\node[tr,right of = p1, label = center:$t_2$,yshift=-8mm] (tt2){};
				\node[left of = tt1,yshift=8mm](in1){};
				\node[left of = tt1,yshift=-8mm](in2){};
				\node[right of = tt2,yshift=8mm](out1){};
				\node[right of = tt2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (tt1)
				(in2) edge node[above]{$\nu_2$} (tt1)
				(tt1) edge node[above]{$\mu_1$} (p1)
				(p1) edge node[above]{$\mu_2$} (tt2)
				(tt1) edge node[above]{$\mu_3$} (p2)
				(p2) edge node[above]{$\mu_4$} (tt2)
				(tt2) edge node[above]{$\nu_3$} (out1)
				(tt2) edge node[above]{$\nu_4$} (out2)
				;  
				
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]t2.east) -- ([xshift=-5.5mm]tt1.west) ;		
			\end{tikzpicture}
		\end{center}
	
		\item \label{itm:tjn_R4} Transition Duplication:
		$
		t \leftrightarrow 
		\jnchoice{t}{t'}
		$
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm, thick,  every node/.style={scale=0.7}]
				\node[pl] (p1){};
				\node[tr,right of = p1, label = center:$t$] (t){};
				\node[pl,right of = t, ] (p2){};
				\node[left of = p1,yshift=8mm](in1){};
				\node[left of = p1,yshift=-8mm](in2){};
				\node[right of = p2,yshift=8mm](out1){};
				\node[right of = p2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (p1)
				(in2) edge node[above]{$\nu_2$} (p1)
				(p1) edge node[above]{$\mu_1$} (t)
				(t) edge node[above]{$\mu_2$} (p2)
				(p2) edge node[above]{$\nu_3$} (out1)
				(p2) edge node[above]{$\nu_4$} (out2)
				;  
				
				\node[pl,right of = p2, xshift=2.7cm,] (pp1){};
				\node[tr,right of = pp1, label = center:$t$,yshift=8mm] (t1){};
				\node[tr,right of = pp1, label = center:$t'$,yshift=-8mm] (t2){};
				\node[pl,right of = t1,yshift=-8mm ] (pp2){};
				\node[left of = pp1,yshift=8mm](in1){};
				\node[left of = pp1,yshift=-8mm](in2){};
				\node[right of = pp2,yshift=8mm](out1){};
				\node[right of = pp2,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[above]{$\nu_1$} (pp1)
				(in2) edge node[above]{$\nu_2$} (pp1)
				(pp1) edge node[above]{$\mu_1$} (t1)
				(t1) edge node[above]{$\mu_2$} (pp2)
				(pp1) edge node[above]{$\mu_1$} (t2)
				(t2) edge node[above]{$\mu_2$} (pp2)
				(pp2) edge node[above]{$\nu_3$} (out1)
				(pp2) edge node[above]{$\nu_4$} (out2)
				;  
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]p2.east) -- ([xshift=-7.5mm]pp1.west) ;
			\end{tikzpicture}
		\end{center}
	
		\item \label{itm:tjn_R5} Self Loop Addition:
		$
		\jnplace{p}{\lambda} \leftrightarrow
		\jnselfloop{
			\jnplace{p}{\lambda}
		}{
			t
		}
		$
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm,thick,  every node/.style={scale=0.7}]
				
				\node[pl,label = below:$p$] (p){};
				\node[left of = p,yshift=8mm](in1){};
				\node[left of = p,yshift=-8mm](in2){};
				\node[right of = p,yshift=8mm](out1){};
				\node[right of = p,yshift=-8mm](out2){};
				
				\path[->] 
				(in1) edge node[below]{$\nu$} (p)
				(in2) edge node[above]{$\nu$} (p)
				(p) edge node[below]{$\nu$} (out1)
				(p) edge node[above]{$\nu$} (out2)
				;  
				
				\node[pl,right of = p, xshift=2.7cm, label = below:$p$] (p1){};
				\node[tr,above of = p1, label = center:$t$,yshift=2mm] (t){};
				\node[left of = p1,yshift=8mm](in1){};
				\node[left of = p1,yshift=-8mm](in2){};
				\node[right of = p1,yshift=8mm](out1){};
				\node[right of = p1,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[below]{$\nu$} (p1)
				(in2) edge node[above]{$\nu$} (p1)
				(p1) edge[bend left=20] node[left]{$\mu$} (t)
				(t) edge[bend left=20] node[right]{$\mu$} (p1)
				(p1) edge node[below]{$\nu$} (out1)
				(p1) edge node[above]{$\nu$} (out2)
				;  
				
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]p.east) -- ([xshift=-7.5mm]p1.west) ;
				
			\end{tikzpicture}
		\end{center}
	
		\item \label{itm:tjn_R6} Identifier Introduction:
		$t \leftrightarrow
		\jnnewidentifier{t}{N_1}{\jnplace{p}{\lambda}}{N_2}
		$%
		, with
		$
		\jnsequence{N_1}{\jnsequence{\jnplace{p}{\lambda}}{N_2}}
		$ a \tjn and $\lambda \cap \var{t} = \emptyset$
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',auto,x=17mm,y=1.3cm,node distance=15mm and 15mm,thick,  every node/.style={scale=0.7}]
				\node[tr,label = center:$t$] (t){};
				\node[left of = t,yshift=8mm](in1){};
				\node[left of = t,yshift=-8mm](in2){};
				\node[right of = t,yshift=8mm](out1){};
				\node[right of = t,yshift=-8mm](out2){};
				
				\path[->] 
				(in1) edge node[below]{$\nu_1$} (t)
				(in2) edge node[above]{$\nu_2$} (t)
				(t) edge node[below]{$\nu_3$} (out1)
				(t) edge node[above]{$\nu_4$} (out2)
				;  
				
				\node[tr,right of = p, xshift=2.7cm, label = center:$t$] (t1){};
				\node[pl,above of = t1, label = above:$p$,yshift=2mm] (p1){};
				\node[tr,left of = p1,label = center:$t_1$] (t2){};
				\node[tr,right of = p1,label = center:$t_2$] (t3){};
				\node[left of = t1,yshift=8mm](in1){};
				\node[left of = t1,yshift=-8mm](in2){};
				\node[right of = t1,yshift=8mm](out1){};
				\node[right of = t1,yshift=-8mm](out2){};
				\path[->] 
				(in1) edge node[below]{$\nu_1$} (t1)
				(in2) edge node[above]{$\nu_2$} (t1)
				(t1) edge[bend left=20] node[left]{$\mu$} (p1)
				(p1) edge[bend left=20] node[right]{$\mu$} (t1)
				(t2) edge node[above]{$\mu$} (p1)
				(p1) edge node[above]{$\mu$} (t3)
				(t1) edge node[below]{$\nu_3$} (out1)
				(t1) edge node[above]{$\nu_4$} (out2)
				;  
				
				\draw[{Triangle[open]}-{Triangle[open]}] ([xshift=7.5mm]t.east) -- ([xshift=-7.5mm]t1.west) ;
			\end{tikzpicture}
		\end{center}
	\end{enumerate}
\end{definition}

An example t-JN is given in \figref{runningexample}. 
Starting with the product process, transitions $C$ and $D$ can be reduced using rule $R2$. 
The resulting transition is a self-loop transition, and can be reduced using $R5$, resulting in the block $\jnnewidentifier{E}{A}{\mathit{product}}{B}$.
This block can be reduced using $R6$, leaving transition $E$.
Transition $E$ is again a self-loop, and can be reduced using $R5$.
The block containing transitions $H$, $J$, $L$ $O$, $N$ and $K$ can be reduced to a single place by applying rules $R1$, $R2$ and $R5$ repeatedly. 
The remaining place is a duplicate place with respect to place $p$, and can be reduced using $R3$.
Applying $R2$ on $G$ and $Z$ results in the block $\jnnewidentifier{G}{T}{\mathit{customer}}{V}$, 
which can be reduced to the transition $G$. 
Hence, the net in \figref{runningexample} is an atomic \tjn.
%\db{Paragraph on that rules R1-R5 are trivially the same as J1-J5 for jackson nets; then explain why we need to use the triple for R6 (example in PDF by JM)}

\begin{theorem}[Identifier Soundness of typed Jackson Nets \cite{vanderWerf2022}] \thmlabel{tjn-is-identifier-sound}
	Given a \tjn $N$, then $N$ is \emph{identifier sound} and \emph{live}.
\end{theorem}

%\db{Give example of reduction, based on the running example Jackson net}
%It should be noted that these generation rules for \tjns can also be used for reduction, as is the case with \jns.

%The generation rules for \tjns can also be used for reduction, as is the case with \jns.
%For instance, in the \tjn depicted in \figref{tjn_example}, we observe the structure
%$\jnsequence{t_1}{\jnsequence{\jnplace{p_3}{\lambda}}{t_4}}$.
%By applying \ref{itm:tjn_R2} we can reduce this sequence to a single (new) transition obtaining a new \tjn, hence it is atomic.
%
%\begin{figure}[H]
%	\centering
%	\begin{tikzpicture}[->,>=stealth',auto,x=10mm,y=1cm,node distance=11mm and 3mm,thick,  every node/.style={scale=0.8}]
%		\node[tr,label = center:$t_1$]               (t1) {};
%		\node[pl,right of = t1, label=below:$p_3$]  (p3) {};
%		\node[tr,right of = p3, label=center:$t_4$] (t4) {};
%		\node[pl,right of = t4, label=below:$p_1$]  (p1) {};
%		\node[tr,right of = p1, label=center:$t_3$,yshift=1cm, xshift=0.2cm] (t3) {};
%		\node[tr,below of = t3, label=center:$t$,yshift=-1cm]   (t)  {};
%		\node[pl,right of = t3, label=below:$p_1$,yshift=-1cm, xshift=0.2cm]  (p2) {};
%		\node[tr,right of = p2, label=center:$t_2$] (t2) {};
%		
%		% Empty node to fix caption overlap
%		% change yshift to LOWER value to make whitespace LESS
%		\node[below of = t,yshift=5mm] (a) {};
%		
%		\path[->]
%		(t1) edge node[above]{$x$} (p3)
%		(p3) edge node[above]{$x$} (t4)
%		(t4) edge node[above]{$x$} (p1)	
%		
%		(p1) edge[bend left = 20] node[below]{$x$} (t3)
%		(t3) edge[bend left = 20] node[below]{$x$} (p2)
%		(p2) edge[bend left = 20] node[above]{$x$} (t)
%		(t)  edge[bend left = 20] node[above]{$x$} (p1)
%		(p2) edge node[above]{$x$} (t2)
%		;
%	\end{tikzpicture}
%	\caption{An example \tjn, notated as
%		$
%		\jnnewidentifier{
%			t
%		}{
%			\jnsequence{
%				t_1
%			}{
%				\jnsequence{
%					\jnplace{p_3}{\lambda}
%				}{
%					t_4
%				}
%			}
%		}{
%			\jnplace{p_1}{\lambda}
%		}{
%			\jnsequence{
%				t_3
%			}{
%				\jnsequence{
%					\jnplace{p_2}{\lambda}
%				}{
%					t_2
%				}
%			}
%		}
%	$.}
%	\figlabel{tjn_example}
%\end{figure}

%TODO:
%\jmw{Add the text in comments below in the journal extension}
%It is trivial to see that rules \ref{itm:tjn_R1} to \ref{itm:tjn_R5} correspond directly with rules \textit{J1} to \textit{J5} from \defref{jackson_net}. 
%Hence, we state that \tjns are a natural extension to the \jns due to the addition of \ref{itm:tjn_R6}. 
%%By adding \ref{itm:tjn_R6}, we have transformed Murata rules~\cite{Murata1989} to object-centric process mining.
%This new rule, however, cannot use ``simple notation'' $t \leftrightarrow \left(t \triangleleft \left( t_1; [p, \lambda]; t_2\right)\right)$, since it then becomes unclear to which place transition $t$ is connected. 
%We demonstrate this issue by using (wrong) ``simple notation'' in following example.
%Consider the \tjn $\left(t \triangleleft \left( t_1; [p, \lambda]; t_2\right)\right)$, where we have just applied \ref{itm:tjn_R6} on transition $t$.
%Applying \ref{itm:tjn_R1} on $p$, followed by \ref{itm:tjn_R2} on $t_1$ we obtain $\left(t \triangleleft \left(t_1 ; \left( \left[p_3, \lambda\right] ; t_2 \right) ; \left( \left[p_1, \lambda\right] ; \left( t_3; \left[p_2, \lambda\right]\right);t_2\right)\right)\right)$ as shown in \figreffull{tjn_example}.
%When rewriting to its normal form $\left(t \triangleleft \left(t_1 ; \left( \left[ p_3, \lambda \right] ; \left( t_4 ; \left( \left[p_1, \lambda\right] ; \left( t_3 ; \left( \left[p_2, \lambda\right] ; t_2 \right)\right)\right)\right)\right)\right)\right)$ it is no longer clear to which place transition $t$ is connected to.
%As such, the notation is defined with a triple as shown in \ref{itm:tjn_R6}, which avoids this ambiguity.

% it is trivial to see that any JN can be transformed to a tJN by simply not using R6 and a mapping of lambdas}

%\db{Final paragraph; nice link with Murata (also has 6 rules), easy (trivial) to make sound models, good mathematical foundation.}

%\dbtodo{Maybe a corollary stating that tJN are a natural extension to JN?}


%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.99\textwidth]{figs/new_notation_for_typed_jackson_nets.png}
%	\caption{Extending Jackson net notation to typed Jackson Nets}
%	\label{fig:tjn_extends_jn_notation}
%\end{figure}
%




%
%\db{Anything below here is old}
%
%
%\db{To introduce t-JNs we have to talk about t-PNIDs; TYPED PNIDs; Note: lots of copy paste happens here; this should be rewritten to avoid plagiarism}
%
%\db{FLOW: Jackson nets -> typed JN}
%The class of typed Jackson nets (\tjns) are a subset of all typed \pns with identifiers (\tpnids), constructed in such a way that they are identifier sound~\cite{Werf2022}. A typed \pn with identifers itself extends the $\nu$-PNs~\cite{RVFE11} by allowing tokens to carry vectors of identifiers. Identifiers are typed: the countable, infinite set of identifiers is partitioned into a set of types, such that each type contains a countable, infinite set of identifiers. Variables are typed as well and can only refer to identifiers of the associated type.
%

%
%TYPED-JACKSON Nets
%
%PROOF: TYPED JACKSON NETS ARE A NATURAL EXTENSION OF PROCESS TREES:
%EVERY PROCESS TREE IS A TYPED JACKSON NET
%\db{Proof: process tree -> Jackson net -> typed Jackson net}
%



% %%%%%%%%%%% EVERYTHING BELOW THIS LINE IS COPY PASTED
% As customary in colored Petri nets, the firing of a transition requires a \emph{binding} that valuates variables to identifiers.
% The binding is used to inject new fresh data into the net via variables that emit identifiers, i.e., via variables that appear only on the output arcs of that transition.
% We require bindings to be an injection, i.e., no two variables within a binding may refer to the same identifier.
% Note that in this definition, freshness of identifiers is local to the marking, i.e., disappeared identifiers may be reused, as it does not hamper the semantics of the \tpnid.
% Our semantics allow the use of well-ordered sets of identifiers, such as the natural numbers, as used in~\cite{PolyvyanyyWOB19,RosaMF06} to ensure that identifiers are globally new.
% Here we assume local freshness over global freshness.

% \begin{definition}[Firing rule]
%     Given a marked \tpnid $(N,M)$ with $N=(\places,\transitions,\flow,\alpha,\beta)$, a \emph{binding} for  transition $t\in T$ is an injective function  $\psi:\V\rightarrow \I$ such that
%     $\type(v) =\type(\psi(v))$ and
%     $\sigma(v)\not\in \id{M}$ iff $v\in\newvar{t}$.
%     Transition $t$ is \emph{enabled} in $(N,M)$ under binding
%     %\footnote{We assume that $\sigma$ element-wise extends to vectors and bags.} 
%     $\psi$, denoted by $\enabled{(N,M)}{t,\psi}$ iff $\rho_\psi(\beta(p,t)) \leq M(p)$ for all $p\in\pre{t}$.
%     Its firing results in marking $M'$, denoted by $\fire{(N,M)}{t,\psi}{(N, M')}$, such that $M'(p) + \rho_\psi(\beta(p,t)) = M(p) + \rho_\psi(\beta(t,p))$. %for %$p \in \places$.%, for every $p\in\pre{t}\cup\post{t}$.
% \end{definition}

% Again, the firing rule is inductively extended to sequences $\eta\in (\transitions\times(\V\rightarrow \I))^*$.
% A marking $M'$ is \emph{reachable} from $M$ if there exists $\eta\in (\transitions\times(\V\rightarrow \I))^*$ s.t. $\fire{M}{\eta}{M'}$.
% %For a marked \tpnid $(N,M)$, we denote with $\reachable{N}{M}$  the set of all markings reachable from $M$.
% We denote with $\reachable{N}{M}$ the set of all markings reachable from $M$ for $(N,M)$.

% The execution semantics of a \tpnid is defined as an LTS that accounts for all possible executions starting from a given initial marking.

% \begin{definition}
%     Given a marked \tpnid $(N,M_0)$ with $N=(P,T,F,\alpha,\beta)$, its induced transition system  is $\transitionsystem{N,M_0} = (\mathbb{M}(N),(T\times(\V\to\I)),M_0, \to)$ with $M\xrightarrow{(t,\sigma)} M^\prime$ iff  $\fire{\marking}{t,\sigma}{\marking^\prime}$.

%     %\begin{compactitem}
%     %	 \item $S=\reachable{N}{M_0}$ and $s_0=M_0$,
%     %	 \item for $M,M^\prime\in S$ it holds that: 
%     %	 	$M\xrightarrow{(t,\sigma)} M^\prime$ iff  $\fire{\marking}{t,\sigma}{\marking^\prime}$. %for $t\in\transitions$ and binding $\sigma$. 
%     %\end{compactitem}
% \end{definition}

% \tpnids are a vector-based extension of $\nu$-PNs.
% In other words, a $\nu$-PN can be translated into a strongly bisimilar \tpnid with a single type, and all place types are of length of at most $1$.
% %The following lemma sets up a formal connection between these two formalisms.

% \begin{lemma}
%     \label{lemma:nupn}
%     For any $\nu$-PN there exists a single-typed \tpnid  such that the two nets are strongly rooted bisimilar.
% \end{lemma}

% %\noindent
% %As a result, decidability of reachability for $\nu$-PNs transfers to \tpnids~\cite{RVFE11}. 
% %
% %\begin{proposition}\label{prop:reachabilityundecidable}
% %Reachability is undecidable for \tpnids.
% %\end{proposition}


% \subsection{Soundness}\andy{to shrink}
% Each type has a life-cycle.
% Intuitively, an object of a given type ``enters'' the system via an emitter that creates a unique identifier that refers to the object.
% The identifier remains in the system, until the object ``leaves'' the system by firing a collecting transition (that binds to the identifier and consumes it).
% Hence, once that transition fires, there should be no remaining tokens referring to the removed object.
% The process of a type is a model that describes all possible paths allowed for a type.
% It can be represented as a transition-bordered WF-net~\cite{HeeSW13}.
% Instead of a sink and source place, a transition-bordered WF-net has transitions that represent the start and finish of a process.
% A transition-bordered WF-net is sound, if its closure is sound.
% As shown in Fig.~\ref{fig:tBorderedNet}, its closure is constructed by creating a new source place $i$ s.t. each emitting transition consumes from $i$, and a new sink place $f$ s.t. each collecting transition produces in $f$.
% Consider in \tpnid $N_{\mathit{rs}}$ of Fig~\ref{fig:overallModel}, identifier type $\mathit{order}$. Its life cycle starts with transition $G$. Transitions $K$ and~$V$ are two transitions that may remove the last reference to an $\mathit{order}$. Soundness of a transition-bordered WF-net would require that firing transition $K$ or transition $V$ would result in the final marking.
% In the remainder of this section, we develop this intuition into the concept of identifier soundness.


% Soundness constitutes three properties: proper completion, weak termination and quasi-liveness.
% Similarly to~\cite{HeeSV03}, we focus on the first two properties.
% \emph{Proper completion} states that if a marking covers the final marking, it is the final marking. In other words, as soon as a token is produced in the final place, all other places are empty.
% Following the idea of transition-bordered WF-nets, identifiers should have a similar behavioral property: once an identifier is consumed by a collector, the identifier should be removed from the marking.

% \begin{definition}[Proper type completion]
%     Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{proper $\lambda$-completing} iff for all $t \in C_N(\lambda)$, bindings $\psi : \V\to\I$ and markings $M, M'\in\reachable{N}{M_0}$, if $\fire{M}{t,\psi}{M'}$, then for all identifiers $\cname{id} \in \rng{\restr{\psi}{\delvar{t}}} \cap \id{M}$ and $\type(\cname{id})=\lambda$, it holds that $\cname{id}\not\in\id{M'}$.\footnote{Here, we constrain $\psi$ only to objects of type $\lambda$ that are only consumed.}
% \end{definition}
% %we restrict identifiers to Collect(t) so as to admit situations with subnets where a transition has two input places p1 and p2, both of the same type, F={(p1,t),(p2,t),(t,p2)} and beta(p1,t)=x and beta(p2,t)=y (obviously, y shouldn't be touched in that case)

% As an example, consider \tpnid $N_{\mathit{rs}}$ in Fig.~\ref{fig:overallModel}.
% For type $\mathit{customer}$, %the set of collecting transitions is 
% we have $C_{N_{\mathit{rs}}}(\mathit{customer}) = \{K, V\}$.
% In the current -- empty -- marking, transition $T$ is enabled with binding  $\psi = \{y\mapsto \cname{o}, z\mapsto \cname{c}\}$, which results in marking $M$ with $M(\textit{customer}) = [\cname{c}]$.
% Next, transitions $G$, $H$, $J$, $L$ and $N$ can fire, all using the same binding,
% producing marking $M'$ with $M'(p) = [\cname{o},\cname{c}]$, $M'(\mathit{customer}) =[\cname{c}]$ and $M'(q) = M'(r) = [\cname{c}]$.
% Hence, transition $K$ is enabled with binding $\psi$.
% %As $K \in \C_{N_{rs}}(\mathit{customer})$, it is a collector for type $\mathit{customer}$. 
% However, firing $K$ with $\psi$ results in marking $M''$ with $M''(\mathit{customer}) = [\cname{c}]$, while $\psi(z) = \cname{c}$.
% Hence, $N_{\mathit{rs}}$ is not properly $\mathit{customer}$-completing.

% %\medskip
% \emph{Weak termination} for a WF-net signifies that from any reachable marking, the final marking can be reached.
% Translated to identifiers, it should always eventually be possible to remove an identifier from a marking.

% \begin{definition}[Weak type termination]
%     \label{def:termination}
%     Given type $\lambda\in\Lambda$, a marked \tpnid $(N, M_0)$ is called \emph{weakly $\lambda$-terminating} iff
%     for every $M \in \reachable{N}{M_0}$ and identifier $\cname{id} \in I(\lambda)$ such that $\cname{id} \in \id{M}$, there exists a marking $M' \in \reachable{N}{M}$ with $\cname{id} \not\in \id{M'}$.
% \end{definition}

% %\medskip
% \emph{Identifier soundness} combines the two properties of proper type completion and weak type termination: the former ensures that as soon a collector fires for an identifier, the identifier is removed, whereas the latter ensures that it is always eventually possible to remove that identifier.

% %By joining together the previous definitions we obtain the one of identifier soundness.
% \begin{definition}
%     \label{def:soundness}
%     A marked \tpnid $(N,M_0)$ is \emph{$\lambda$-sound} iff it properly $\lambda$-completes and weakly $\lambda$-terminates. It is \emph{identifier sound} iff it is $\lambda$-sound for every $\lambda\in \type(N)$.
% \end{definition}

% There are two interesting observations that one can make about the identifier soundness property. First, identifier soundness does not imply soundness in the classical sense: any classical net $N$ without types, i.e., $\type(N) = \emptyset$, is identifier sound, independently of the properties of $N$.
% Second, identifier soundness implies depth-boundedness. In other words, if a \tpnid is identifier sound for all types, it cannot accumulate infinitely many tokens carrying the same identifier.


% \begin{theorem}
%     Identifier soundness is undecidable for \tpnids.
% \end{theorem}

% %When talking about the boundedness of \tpnids, we use definitions similar to those in~\cite{RosaF11}, helping to account for two main sources of unboundedness: accumulation of unboundedly many identifiers in a marking and accumulation of unboundedly many tokens with the same identifier.
% %
% %\begin{definition}
% %\label{def:boundedness}
% %A marked \tpnid $(N,M_0)$ is:
% %\begin{compactitem}
% %\item \emph{width-bounded} if there is $n \in \naturals$ such that $|\id{M}| \leq n$ for every $M \in \reachable{N}{M_0}$;
% %\item \emph{depth-bounded} if there is $n \in \naturals$ such that $M(p)(\vec{id}) \leq n$  for every $M \in \mathbb{M}(N)$, $p \in \places$,  $\vec{id}\in \colset(p)$ and  $\cname{id} \in \id{M}$, where $\cname{id}\in\vec{id}$.
% %\end{compactitem}
% %\end{definition}
% %
% %\jmw{How about:}
% %\begin{definition}
% %Given a marked \tpnid $((\places, \transitions,\flow,\alpha,\beta),M_0)$, place $p \in P$ is called:
% %\begin{compactitem}
% %	\item \emph{bounded} if there is $k\in\naturals$ such that $|M(p)| \leq k$ for every $M \in \reachable{N}{M_0}$;
% %	\item \emph{width-bounded} if a $k\in\naturals$ exists with $|\id{M}| \leq k$ for every  $M \in \reachable{N}{M_0}$;
% %	\item \emph{depth-bounded} if a $k\in\naturals$ exists with $M(p)(\vec{id}) \leq k$  for all $M \in \reachable{N}{M_0}$, $\vec{id}\in \colset(p)$ and  $\cname{id} \in \id{M}$ where $\cname{id}\in\vec{id}$.
% %\end{compactitem}
% %If all places in $(N,M_0)$ are bounded (width-bounded, depth-bounded), $(N,M_0)$ is called bounded (width-bounded, depth-bounded).
% %\end{definition}
% %
% %\andy{proposition: every typed PNID can be represented with untyped PNID, and vice versa (which is trivial)}
% %
% %\jmw{Add that depth-bounded means that the `projection' of a marking on any given identifier is bounded.}


% \section{Typed Jackson Nets}

% \subsection{Reduction rules}

% \label{sec:typedJN}
% \andy{shrink the rules}
% \andy{we should mention in this section that the rules are applied only for expansion; however, same rules can be used in the reduction context (and later on we will demonstrate it on one of the rules)}
% A well-studied class of processes that guarantee soundness are block-structured nets.
% Examples include Process Trees~\cite{Leemans13}, Refined Process Structure Trees~\cite{Weidlich11} and Jackson Nets~\cite{HeeHHPT09}.
% Each of the techniques have a set of rules in common from which a class of nets can be constructed that guarantees properties like soundness.
% In this section, we introduce Typed Jackson Nets (t-JNs), extending the ideas of Jackson Nets~\cite{HeeHHPT09,HeeSW13} to \tpnids, that guarantee both identifier soundness and liveness.
% The six reduction rules presented by Murata in~\cite{Murata89} form the basis of this class of nets.
% The rules for t-JNs are depicted in Figure~\ref{fig:constructionrulestJN}.



% \begin{figure}[t]
%     \subfloat[Place Expansion\label{fig:placeExpansion}]{%
%         \includegraphics[width=.3\textwidth]{figures/PlaceExpansion}
%     }\hfil
%     \subfloat[Transition Expansion\label{fig:transitionExpansion}]{%
%         \includegraphics[width=.3\textwidth]{figures/TransitionExpansion}
%     }\hfil
%     \subfloat[Place Duplication\label{fig:placeDuplication}]{%
%         \includegraphics[width=.3\textwidth]{figures/PlaceDuplication}
%     }\hfil
%     \subfloat[Transition Duplication\label{fig:transitionDuplication}]{%
%         \includegraphics[width=.3\textwidth]{figures/TransitionDuplication}
%     }\hfil
%     \subfloat[Self-loop Addition\label{fig:selfLoopAddition}]{%
%         \includegraphics[width=.3\textwidth]{figures/SelfLoopAddition}
%     }\hfil
%     \subfloat[Identifier Creation\label{fig:identifierCreation}]{%
%         \includegraphics[width=.3\textwidth]{figures/IdentifierCreation}
%     }
%     \vspace{10pt}
%     \caption{Construction rules of the typed Jackson Nets.}\label{fig:constructionrulestJN}
% \end{figure}

% \newcounter{tjncount}
% \newcommand{\ruletitle}[1]{\medskip	\noindent\textbf{\fbox{Rule \addtocounter{tjncount}{1}\thetjncount:} #1}}

% %\subsubsection{Place Expansion}
% \ruletitle{Place Expansion.}
% The first rule is based on \emph{fusion of a series of places}.
% As shown in Figure~\ref{fig:placeExpansion}, a single place $p$ is replaced by two places $p_i$ and $p_f$ that are connected via transition $t$.
% All transitions that originally produced in $p$, produce in $p_i$ in the place expansion, and similarly, the transitions that consumed from place $p$, now consume from place $p_f$.
% In fact, transition $t$ can be seen as a transfer transition: it needs to move tokens from place $p_i$ to place $p_f$, before the original process can continue.
% This is also reflected in the labeling of the places: both places have the same place type, and all arcs of transition $t$ are inscripted with $[\vec\mu]$, i.e., only consuming and producing a single token in a firing.

% \begin{definition}[Place expansion]
%     \label{def:place-expansion}
%     Let $(N,M)$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, $p \in \places$ be a place and $\vec\mu \in \V^*$ be a variable vector s.t. $\type(\vec\mu) = \alpha(p)$.
%     %
%     The \emph{place expanded \tpnid} is defined by $R_{p,\vec\mu}(N,M) = ((\places', \transitions',\flow', \alpha',\beta'),M')$, where:
%     \begin{compactitem}
%         \item $\places' = (\places \setminus \{p\}) \cup \{p_i, p_f\}$ with $p_i, p_f \not\in \places$; and
%         %\item 
%         $\transitions' = \transitions \cup \{t\}$ with $t \not\in \transitions$;
%         %\item 
%         %%$\flow' = (\flow \setminus ((\pre{p} \times \{p\}) 
%         %$\flow' = (\flow \setminus ((\{p\} \times \post{p})\cup (\pre{t} \times \{p\}) )
%         %\cup\bigcup_{u\in\pre{p}} \{(u,p_i)\} \cup \{(p_i,t),(t,p_f)\} \cup \bigcup_{u\in\post{p}} \{(p_f,u)\}$;
%         \item
%         $\flow' = (\flow \setminus ((\{p\} \times \post{p})\cup (\pre{t} \times \{p\}) )
%             \cup
%             (\pre{p} \times \{p_i\})
%             \cup \{(p_i,t),(t,p_f)\} \cup
%             (\{p_f\} \times \post{p})$;

%         % \cup \{(u,p_i) \mid u \in \pre{p}\} \cup \{(p_i,t),(t,p_f)\} \cup \{(p_f,u)\mid u \in \post{p}\}$; 
%         %$\flow' = (\flow \setminus ((\{p\} \times \post{p})\cup (\pre{t} \times \{p\}) ) \cup \{ (p_f,u) \mid u \in\post{p} \} \cup \{ (u,p_i) \mid u \in\pre{p} \} \cup \{ (p_i,t), (t,p_f) \}$;
%         \item %$\alpha' = \proj{\alpha}{\places'} \cup \{ (p_i, \alpha(p)), (p_f, \alpha(p)) \}$;
%         $\alpha'(q) = \alpha(p)$, if $q \in \{p_i, p_f\}$, and $\alpha'(q) = \alpha(q)$, otherwise.
%         \item %$\beta' = 
%         %\proj{\beta}{\flow'}
%         %\cup \{ (p_i,u) \mapsto \beta((p,u)) \mid u \in \post{p} \}
%         %\cup \{ (p,t) \mapsto [\mu], (t,p)\mapsto [\mu] \}$.
%         %$\beta'$ is defined by
%         $\beta'(f) = [\vec\mu]$, if $f \in \{(p_i,t),(t,p_f)\}$, $\beta'((u,p_i))=\beta((u,p))$, if  $u \in \pre{p}$, $\beta'((p_f,u))=\beta((p,u))$, if $u \in \post{p}$, and $\beta'(f) = \beta(f)$, otherwise.
%         \item $M'(q) = M(q)$ for all $q \in P\setminus\{p\}$, $M'(p_f) = 0$, and $M'(p_i) = M(p)$.
%     \end{compactitem}
% \end{definition}

% Inscription $\vec\mu$ cannot alter the vector identifier on the tokens, as the type of $\vec\mu$ should correspond to both place types $\alpha(p)$ and $\alpha(q)$.
% Hence, the transition is enabled with the same bindings as any other transition that consumes a token from place $p$, modulo variable renaming.
% As such, transition $t$ only ``transfers'' tokens from place $p_i$ to place $p_f$.
% Hence, as the next lemma shows, place expansion yields a weakly bisimilar \tpnid.

% \medskip
% \ruletitle{Transition Expansion.}
% %Rule 2: Transition expansion (Murata's fusion of series transitions)
% The second rule is transition expansion, which corresponds to Murata's \emph{fusion of series transitions}.
% As shown in Fig.~\ref{fig:transitionExpansion}, transition $t$ is divided into two transitions, $t_c$ that consumes the tokens, and a second transition $t_p$ that produces the tokens.
% The two transitions are connected with a single, fresh place $p$.
% This place can have any type, as long as it does not hamper firing the post transition $t_p$, i.e., place $p$ should ensure that all variables consumed by $t_c$, and that are required by $t_e$ are passed.
% Transition $t_c$ is allowed to emit new identifiers, as long as these are not already produced by $t_p$.

% \begin{definition}[Transition expansion]
%     Let $(N,M)$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, let $t \in \transitions$, and let $\lambda \subseteq \Lambda^*$ and $\mu \in (\V\setminus \newvar{t})^*$ such that $\type(x) \in \lambda$ and $x\in\mu$, for all $x\in \invar{t}$, and $\type(\mu) = \lambda$.
%     %
%     The \emph{transition expanded \tpnid} is defined by $R_{t,\lambda,\mu}(N,M) = ((\places', \transitions',\flow', \alpha',\beta'),M)$, where:
%     \begin{compactitem}
%         \item $\places' = \places \cup \{p\}$ with $p \not\in \places$; and
%         %\item 
%         $\transitions' = (\transitions \setminus \{t\}) \cup \{t_e, t_c\}$ with $t_e, t_c \not\in \transitions$;
%         %	\item 
%         %	$\flow' = (\flow \setminus ((\pre{t} \times \{t\}) \cup (\{t\}\times\post{t}) )) \cup \bigcup_{q \in \pre{t}} ((q,t_e)) \cup \{(t_e,p),(p,t_c)\} \cup \bigcup_{q \in \post{t}} (t_c,q)$;
%         \item
%         $\flow' = (\flow \setminus ((\pre{t} \times \{t\}) \cup (\{t\}\times\post{t}) )) \cup
%             (\pre{t} \times \{t_e\})
%             \cup \{(t_e,p),(p,t_c)\}
%             \cup
%             (\{t_c\} \times \post{t})$;
%         \item
%         $\alpha'(p) = \lambda$ and $\alpha'(q) = \alpha(q)$ for all $q \in \places$;
%         \item
%         $\beta'(f) = [\mu]$ if $f \in \{(t_e,p),(p,t_c)\}$, $\beta'((q,t_e))=\beta((q,t))$ for $q \in \pre{t}$, $\beta'((t_c,q))=\beta((t,q))$ for $q \in \post{t}$, and $
%             \beta'(f) = \beta(f)$ otherwise.
%     \end{compactitem}
% \end{definition}

% Transition $t_e$ is allowed to introduce new variables, but key is that inscription $\mu$ contains all input variables of transition $t$. Consequently, $\mu$ encodes the binding of transition $t$.
% We use this to prove weak bisimulation between a \tpnid and it transition expanded net.
% The idea behind the simulation relation $Q$ is that the firing of $t_e$ is postponed until $t_c$ fires.
% In other words, $Q$ encodes that tokens remain in place $q$ until transition $t_c$ fires.

% %\subsubsection{Place Duplication}
% \ruletitle{Place Duplication.}
% Whereas the previous two rules only introduced ways to create sequences, the third rule introduces parallelism by duplicating a place, as shown in Figure~\ref{fig:placeDuplication}. It is based on the \emph{fusion of parallel transitions} reduction rule of Murata.
% For \tpnids, duplicating a place has an additional advantage: as all information required for passing the identifiers is already guaranteed, the duplicated place can have any place type.

% \begin{definition}[Duplicate place]
%     Let $(N,M)$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, let $p \in \places$, such that $M(p) = \emptyset$, and some transitions $t, u\in \transitions$ exist with $\pre{p} =\{t\}$ and $\post{p} = \{u\}$. Let $\lambda \in \Lambda^*$ and $\mu \in (\V\setminus \newvar{u})^*$ such that $\type(\mu) = \lambda$.
%     %
%     Its \emph{duplicated place \tpnid} is defined by $D_{p,\lambda,\mu}(N,M) = ((\places', \transitions,\flow', \alpha',\beta'),M)$, where:
%     \begin{compactitem}
%         \item $\places' = \places \cup \{ q \}$, with $q\not\in P$, and $\flow' = \flow \cup \{ (t, q), (q, u) \}$;
%         \item $\alpha' = \alpha\cup \{ q \mapsto \lambda \}$ and $\beta' = \beta \cup \{ (t,q) \mapsto [\mu], (q,u) \mapsto [\mu] \}$.
%     \end{compactitem}
% \end{definition}


% %\subsubsection{Transition Duplication}
% \medskip
% \ruletitle{Transition Duplication.}
% As already recognized by Berthelot~\cite{Berthelot78}, if two transitions have an identical preset and postset, one of these transitions can be removed while preserving liveness and boundedness. Murata's fusion of parallel places is a special case of this rule, requiring that the preset and postset are singletons.
% For t-JNs, this results in the duplicate transition rule: any transition may be duplicated, as shown in Figure~\ref{fig:transitionDuplication}.

% \begin{definition}[Duplicate place]
%     Let $(N,M)$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, and let $t \in \transitions$ such that some places $p, q\in \places$ exist with $\pre{t} =\{p\}$ and $\post{t} = \{q\}$.
%     %
%     Its \emph{duplicated transition \tpnid} is defined by $D_{t}(N,M) = ((\places, \transitions',\flow', \alpha,\beta'),M)$, where:
%     \begin{compactitem}
%         \item $\transitions' = \transitions \cup \{u \}$, with $t'\not\in \transitions$, and $\flow' = \flow \cup \{ (p, u), (u, q) \}$;
%         \item $\beta'((p,u)) = \beta((p,t))$, $\beta((u,q)) = \beta((t,q))$ and $\beta'(f) = \beta(f)$ for all $f\in \flow$.
%     \end{compactitem}
% \end{definition}

% \medskip
% \ruletitle{Adding Identity Transitions.}
% In \cite{Berthelot78}, Berthelot classified a transition $t$ with an identical preset and postset, i.e., $\pre{t} = \post{t}$ as irrelevant, as its firing does not change the marking. The reduction rule \emph{elimination of self-loop transitions} is a special case, as Murata required these sets to be singletons.
% For t-JNs, adding a self-loop transition is the fifth rule, as shown in Figure~\ref{fig:selfLoopAddition}.

% \begin{definition}[Self-loop addition]
%     Let $(N,M$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, and let $p \in \places$.
%     %
%     Its \emph{Self-loop Added \tpnid} is defined by $A_{p}(N,M) = ((\places, \transitions',\flow', \alpha,\beta'), M)$, where:
%     \begin{compactitem}
%         \item $\transitions' = \transitions \cup \{ t \}$, with $t\not\in \transitions$, and
%         $\flow' = \flow \cup \{ (p, t), (t, p) \}$;
%         \item $\beta'((p,t')) = \beta'((p,t')) = [\vec\mu]$ with $\vec\mu \in \V^*$ such that $\type(\mu) = \alpha(p)$, and $\beta'(f) = \beta(f)$ otherwise.
%     \end{compactitem}
% \end{definition}

% \medskip
% \ruletitle{Identifier Introduction.}
% The first five  rules preserve the criteria of block-structured WF-nets.
% Murata's %reduction rule 
% \emph{elimination of self-loop places} states that adding or removing a marked place with identical preset and postset does preserve liveness and boundedness.
% This rule is often used to introduce a fixed resource to a net, i.e., the number of resources is determined in the initial marking.
% %The last rule, \emph{identifier introduction} is based on this idea. 
% Instead, identifier introduction adds dynamic resources, as shown in Figure~\ref{fig:identifierCreation}:
% transition $t_e$ emits new identifiers as its inscription uses only ``new''  variables (i.e., those that have not been used in the net), and place $p$ works like a storage of the available resources, which can be removed by firing transition
% $t_c$.

% \begin{definition}[Identifier Introduction]
%     Let $(N,M)$ be a marked \tpnid with $N = (\places, \transitions, \flow, \alpha, \beta)$, let $t \in \transitions$, let $\vec\lambda \in (\Lambda\setminus \type(N))^*$ and $\vec\mu \in \V^*$ such that $\type(\vec\mu) = \vec\lambda$.
%     %
%     The \emph{Identifier introducing \tpnid} is defined by $A_{t,\vec\lambda,\vec\mu}(N,M) = ((\places', \transitions',\flow', \alpha',\beta'), M)$, where:
%     \begin{compactitem}
%         \item $\places' = \places' \cup \{ p \}$ and $\transitions' = \transitions \cup \{ t_e, t_c \}$, for $p \not\in \places$ and $t_e, t_c \not\in \transitions$, and
%         $\flow' = \flow \cup \{ (p, t), (t, p), (t_e,p), (p, t_c) \}$;
%         \item $\alpha' = \alpha \cup \{ p \mapsto \vec\lambda \}$ and $\beta' = \beta \cup \{ (p,t) \mapsto [\vec\mu], (t,p) \mapsto [\vec\mu], (t_e, p) \mapsto [\vec\mu], (p, t_c) \mapsto [\vec\mu] \}$;
%     \end{compactitem}
% \end{definition}



% As shown in~\cite{RVFE11}, unbounded places are width-bounded, i.e., can contain an infinite number of identifiers, or depth-bounded, i.e., for each identifier, the number of tokens carrying that identifier is bounded, or both.
% The place added by the identifier creation rule is by definition width-unbounded, as it has an empty preset. However, it is identifier sound, and thus depth-bounded.



% \smallskip
% Any net that can be reduced to a net with a single transition using these rules is called a typed Jackson Net (t-JN).

% %JMW, added for layout purpose (new page)
% %\medskip

% \begin{definition}
%     The class of \emph{typed Jackson Nets} $\mathcal{T}$ is inductively defined  by:
%     \begin{compactitem}
%         \item $((\emptyset,\{t\},\emptyset,\emptyset,\emptyset),\emptyset) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $R_{p,\vec\mu}(N,M) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $R_{t,\vec\lambda,\vec\mu}(N,M) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $D_{p,\vec\lambda,\vec\mu}(N,M_0) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $D_{t}(N,M) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $A_{p}(N,M) \in \mathcal{T}$;
%         \item if $(N,M) \in \mathcal{T}$, then $A_{t,\vec\lambda,\vec\mu}(N,M) \in \mathcal{T}$.
%     \end{compactitem}
% \end{definition}

% As any t-JN reduces to a single transition, and each construction rule goes hand in hand with a bisimulation relation, any liveness property is preserved. Consequently, any t-JN is identifier sound and live.

% \begin{theorem}\label{thm:tJNisSound}
%     Any typed Jackson Net is identifier sound and live.
% \end{theorem}


