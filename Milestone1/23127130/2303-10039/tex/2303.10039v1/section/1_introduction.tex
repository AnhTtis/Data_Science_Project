%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\seclabel{introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PROCESSES AND MODELS
% 2023-03-17: Artem
% 2023-01-28: Artem
%Processes are fundamental to a wide range of systems, from the brain development of children to the transformation of a caterpillar into a butterfly. 
%In this work, business processes are in focus, where a business process is a collection of activities that, when performed, aim to achieve a business objective at an organization.
Business processes are fundamental to a wide range of systems.
A business process is a collection of activities that, when performed, aims to achieve a business objective at an organization. 
Examples of business processes are an order-to-cash process at a retailer, a medical assessment process at a hospital, or a credit check process at a bank.
Business processes are modeled using process modeling languages, such as Petri nets, and used for communication and analysis purposes~\cite{vanderAalst2000}. 
Petri nets provide a graphical representation of the flow of activities within a process and can be used to model various types of concurrent and sequential behavior~\cite{Murata1989}. 
%Petri nets, however, have a limitation in that they do not capture information about data objects involved in the process.
%Although extensions like Colored Petri nets~\cite{Jensen2009}, $\nu$-Petri nets~\cite{RosaVelardo2011}, and Petri nets with Identifiers~\cite{Polyvyanyy2019} allow for the modeling of data objects, they come with a cost, as many analysis techniques become undecidable.

% PROCESS DISCOVERY
% 2023-01-27: Artem
A process discovery algorithm aims to automatically construct a model from data generated by historical process executions captured in an event log of the system, such that the model describes the system well.
A desired property of a discovery algorithm is \emph{rediscoverability}.
This property states that if a system $S$, expressed as a model $M$, generates an event log $L$, then a discovery algorithm with the rediscoverability property should construct $M$ from $L$. 
In other words, the algorithm can reverse engineer the model of the system from the data the model has generated. 
Only a few existing algorithms guarantee this property.
For example, if the model is a block-structured workflow net, and the event log is directly-follows complete, then the $\alpha$-Miner algorithm~\cite{AalstWM04} can rediscover the net that generated the event log.
Similarly, again under the assumption that the event log is directly-follows complete, Inductive Miner~\cite{Leemans2013} can rediscover process trees without duplicate transitions, self-loops, or silent transitions.

\begin{figure}[t]
\vspace{-2mm}
\centering
\includegraphics[width=\textwidth]{figs/runningexample2}
\vspace{-1mm}
\caption{A retailer system of three interacting processes.}
\figlabel{runningexample}
\vspace{-10mm}
\end{figure}

% ONE VS MULTIPLE PROCESSES
% 2023-01-27: Artem
Most existing process discovery algorithms assume that a system executes a single process~\cite{aalst22_foundations}.
Consequently, an event log is defined as a collection of sequences where a sequence describes the execution of a single process instance.
However, many information systems, such as enterprise resource planning systems, do not satisfy this assumption.
A system often executes multiple interacting processes~\cite{Fahland2019,vanderWerf2022}.
For example, consider a retailer system that executes three processes: an order, product, and customer management process, as depicted in~\figref{runningexample}.
These processes are intertwined.
Specifically, only available products may be ordered, and customers can only have one order at a time.
Consequently, events do not belong to a single process but relate to several processes.
For instance, consider an event $e$ in some event log that occurred as transition $G$ was executed for some customer $c$ and created a new order $o$ in the system.
Event $e$ relates to the customer process instance $c$ and the order process instance $o$.
Traditional process discovery techniques require event $e$ to be stored in multiple event logs and generate multiple models, one for each process~\cite{adams22_extractingfeatures}. 

% OBJECT-CENTRIC PROCESS DISCOVERY AND AGENT SYSTEM DISCOVERY
% 2023-03-17: Artem
% 2023-01-28: Artem
A different approach is taken in artifact or object-centric process discovery~\cite{aalstB20_discovering,LuNWF15} and agent system discovery~\cite{TourPK21,TourPKS2022agentdiscovery}.
In object-centric process discovery, instead of linking each event to a single object, events can be linked to multiple objects stored in object-centric event logs~\cite{Berti2022}.
Existing object-centric discovery algorithms project the input event log on each object type to create a set of ``flattened'' event logs.
For each event log, a model is discovered, after which these models are combined into a single model~\cite{aalstB20_discovering}.
In general, flattening is lossy~\cite{adams22_extractingfeatures}, as in this step, events can disappear~\cite{aalstB20_discovering}, be duplicated (convergence)~\cite{aalst19_divergence}, or lead to wrong event orders (divergence)~\cite{aalst19_divergence}.
In agent system discovery, instead of interacting objects, a system is viewed as composed of multiple autonomous agents, each driving its processes that interact to achieve an overall objective of the system~\cite{TourPK21}.
An agent system discovery algorithm proceeds by decomposing the input event log into multiple event logs, each composed of events performed by one agent (type) and an event log of interactions, and then discovering agent and interaction models and composing them into the resulting system~\cite{TourPKS2022agentdiscovery}.

\begin{figure}[t]
	\centering
	\begin{tikzpicture}[->,>=stealth',auto,x=10mm,y=1cm,node distance=15mm and 3mm,thick,  every node/.style={scale=1.2}]
		% Rectangles.
		\node[rectangle,draw=lightgray, minimum width=8.5cm, minimum height=2.5cm] (r) at  (3.55,0.3) {};
		\node[rectangle,draw=lightgray, minimum width=8.5cm, minimum height=2.25cm] (r) at (3.55,-2.55) {};
			
		% Top: Models
		\node[tr, label=center:$M$] (M) {};
		\node[tr, right of = M, label=center:$M_1$, yshift=0.5cm, xshift=1.75cm]  (M1) {}; 
		\node[below of = M1,rotate=90,xshift=10mm] () {$\cdots$};
		\node[tr, right of = M, label=center:$M_n$, yshift=-0.5cm, xshift=1.75cm]  (Mn) {}; 
		\node[tr, right of = M, label=center:$M'$, xshift=5cm]  (M') {};
		
		% Bot: Logs+Discovered Models
		\node[tr, below of = M, label=center:$L$, yshift=-0.5cm]    (L) {}; 
		\node[tr, right of = L, label=center:$L_1$, yshift=0.5cm]   (L1) {}; 
		\node[below of = L1,rotate=90,xshift=10mm] () {$\cdots$};
		\node[tr, right of = L, label=center:$L_n$, yshift=-0.5cm]  (Ln) {};
		
		\node[tr, right of = L1, label=center:$D_1$, xshift=2cm] (D1) {};
		\node[below of = D1,rotate=90,xshift=10mm] () {$\cdots$};
		\node[tr, right of = Ln, label=center:$D_n$, xshift=2cm] (Dn) {};
		\node[tr, below of = M', label=center:$D'$, yshift=-0.5cm]  (D') {};
		
		% Text
		\node[right of = M, label=center:{\tiny{project}}, xshift=-0.4cm] () {};
		\node[right of = L, label=center:{\tiny{project}}, xshift=-0.6cm] () {};
		
		\node[left of = M', label=center:{\tiny{compose}},xshift=0.2cm] () {};
		\node[left of = D', label=center:{\tiny{compose}},xshift=0.6cm] () {};
		
		\node[right of = D', label=left:{\tiny{Section 4}}, yshift=3.25cm, xshift=-0.7cm] () {};
		\node[right of = D', label=left:{\tiny{Section 5}}, yshift=-1cm, xshift=-0.7cm] () {};
		
		% Whitespace fix
		\node[below of = Dn, yshift=7mm] () {};
		
		% Normal
		% use \path[->, thin, draw=color] to change colors.
		\path[->, thin]
			(M) edge (M1)
			(M) edge (Mn)
			
			(L) edge (L1)
			(L) edge (Ln)
			
			(M1) edge (M')
			(Mn) edge (M')
			
			(D1) edge (D')
			(Dn) edge (D')
		;
		
		%Solid Generates
		\path[->, draw=blue-violet]
		(M) edge node[anchor=center, xshift=-0.6cm, yshift=0.2cm]{\textcolor{blue-violet}{\tiny{generates}}} (L);
		
		% Dotted Generates:
		\path[<->, draw=blue-violet,dotted]
			(M1) edge node[anchor=center, xshift=1.8mm, yshift=-0.5mm]{\textcolor{blue-violet}{\tiny{(?)}}} (L1)
			(Mn) edge node[anchor=center, xshift=0.3mm, yshift=-2.5mm]{\textcolor{blue-violet}{\tiny{(?)}}} (Ln)
		;
		% Orange (?)
		\path[<->, draw=cadmiumorange, dotted]
			(M)  edge[bend left=30] node[anchor=center, yshift=1.5mm]{\textcolor{cadmiumorange}{\tiny{(?)}}}                (M')
			(M') edge               node[anchor=center, yshift=1.8mm, xshift=2.0mm]{\textcolor{cadmiumorange}{\tiny{(?)}}}  (D')
		;
		% Discovery
		\path[->, thin]
			(L1) edge node[anchor=center, yshift=1.5mm]{\tiny{discover}} (D1)
			(Ln) edge node[anchor=center, yshift=1.5mm]{\tiny{discover}} (Dn)
		;
		% Isomorphism
		\path[<->, draw=green1, dotted]
			(M1) edge node[anchor=center, yshift=-2mm, xshift=4mm]{\textcolor{green1}{\tiny{(?)}}} (D1)
			(Mn) edge node[anchor=center, xshift=-0.4mm, yshift=-2.5mm]{\textcolor{green1}{\tiny{(?)}}} (Dn)
		;
	\end{tikzpicture}
	\vspace{3mm}
	\caption{The framework for rediscoverability of systems of interacting processes.}
	\figlabel{principleIdea}
	\vspace{-10mm}
\end{figure}
%\begin{figure}[H]
%\vspace{-2mm}
%\centering
%\includegraphics[width=.9\textwidth]{figs/principleIdea}
%\caption{The framework for rediscoverability of systems of interacting processes.}
%\figlabel{principleIdea}
%\vspace{-10mm}
%\end{figure}
%
%\newpage

% WHAN WE DO...
% 2023-03-17: Artem
% 2023-01-28: Artem
In this paper, we study under what conditions projections in event logs can guarantee rediscoverability for interacting processes, represented as typed Jackson Nets, a subclass of typed Petri nets with identifiers~\cite{PolyvyanyyWOB19ISM,vanderWerf2022}.
%The approach consists of two parts. 
%The type of models we study typed are Jackson Nets (\tjns), a subclass of \tpnids. %, in which objects ``behave well'' imposed by the structure of the nets. 
The class of typed Jackson Nets is inspired by Box Algebra~\cite{Best2002} and Jackson Nets~\cite{vanHee2009}, which are (representations of) block-structured workflow nets that are \emph{sound}~\cite{Aalst1997} by construction~\cite{Leemans2013}. 
%As we show, the class of process trees~\cite{Leemans2013} used in process mining are equivalent to Jackson Nets. 
%As the class of Jackson Nets is enclosed in the class of typed Jackson Nets, they form a natural class to study in the context of process discovery.
As we demonstrate, typed Jackson Nets exhibit a special property: they are \emph{reconstructable}.
Composing the projections of each type is insufficient for reconstructing a typed Jackson Net. 
Instead, if the subset-closed set of all type combinations is considered, the composition returns the original model of the system.
We show how the reconstructability property can be used to develop a framework for rediscoverability of typed Jackson Nets using traditional process discovery algorithms.
The framework builds upon a divide and conquer strategy, as depicted in \figref{principleIdea}. 
The principle idea of this strategy is to project an event log $L$ generated by some model $M$ of the system onto logs $L_1, \ldots, L_n$. 
Then, if these projected event logs satisfy the conditions of a process discovery algorithm, composition of the resulting models $D_1, \ldots, D_n$ into model $D'$ should rediscover the original model of the system.
In this framework, we show that every projected event log is also an event log of the corresponding projected model.
Consequently, if a process discovery algorithm guarantees the rediscoverability of projected models, then the composition operator for typed Jackson Nets can be used to ensure the rediscoverability of the original system.

% PAPER STRUCTURE
% 2023-01-28: Artem
The next section presents the basic notions. 
In \secref{typed_jackson_nets_section}, we introduce typed Jackson Nets, which, as shown in \secref{decomposability}, are reconstructable.
We define a framework for developing discovery algorithms that guarantee rediscoverability 
% The latter will be an ICPM paper ;-)
% and present one instance algorithm of this framework based on Inductive Miner 
in \secref{framework}.
We conclude the paper in \secref{discussion_conclusion}. 
%Full proofs of the lemmata and theorems can be found in~\cite{Arxiv2023}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
