\section{A Framework for Rediscoverability} \seclabel{framework}
%In the previous section, we showed that \tjns are reconstructable by decomposing the net into projections for all possible combinations of types present in the net. 
In the previous section, we showed that \tjns enjoy the reconstructability property: given a \tjn, a composition of \emph{all} its (proper) type projections yields a \tjn that is strongly bisimilar to the original one.\footnote{Such nets are also isomorphic if minor places of the composition are removed by consecutively applying the reduction rules from \defref{typed_jackson_net}.}

In this section, we propose a framework to rediscover systems of interacting processes that rely on this property.
The framework builds upon a divide and conquer strategy~\cite{TourPKS2022agentdiscovery}.
The first step of the approach is to divide the event logs over all possible projections.
For this, we translate the notion of event logs to event logs of interacting systems, and show that if these event logs are generated by a \tjn, projections on these event logs have a special property: the projected event log can be replayed by the projected net. 
In other words, there is no distinction between the projection on the event log, or that the projected net generated the event log. 
This observation forms the basis of the proposed framework for rediscoverability.
In the second step, we conquer the discoverability problem of the system of interacting processes by first discovering a model for each of the projections, and then composing these projections into the original system.
If the event log and discovery algorithm guarantee the defined properties, composition yields rediscoverability.

\subsection{Event Logs and Execution Traces}
In process discovery, an event log is represented as a (multi)set of sequences of events (called traces), where each sequence represents an execution history of a process instance. 
Traditional process discovery assumes the process to be a \wfnet. 
Consequently, each trace in an event log should correspond to a sequence of transition firings of the workflow net.
If this is the case, the event log is said to be generated by the \wfnet. 
We generalize this notion to marked Petri nets.

\begin{definition}[Event Log]
Given a set of transitions $T$, a set of traces $L \subseteq \seq{T}$ is called an \emph{event log}.
An event log $L$ \emph{is generated by} a marked Petri net $(N,m)$ if $\pnenabled{(N,m)}{\sigma}{}$ for all $\sigma \in L$, i.e., $L \subseteq \mathcal{L}(N,m_0)$.
\end{definition}


\begin{table}[t]
	\caption{Firing sequence for the \tpnid in \figref{runningexample}}\tbllabel{sequencerunningexample}
	\begin{minipage}{.3\textwidth}
		\begin{tabular}{l|c|c|c}
			\textbf{transition} & \textbf{x} & \textbf{y} & \textbf{z} \\\hline
			$A$      &     $p1$ &            &             \\
			$A$      &     $p2$ &            &             \\
			$T$      &          &            &   $c1$      \\
			$G$      &          &   $o1$     &   $c1$      \\
			$C$      &     $p1$ &            &             \\
			$E$      &     $p2$ &   $o1$     &             \\
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}{.3\textwidth}
		\begin{tabular}{l|c|c|c}
			\textbf{transition} 
			& \textbf{x} & \textbf{y} & \textbf{z} \\\hline
			$T$      &          &            &   $c2$ \\
			$H$      &          &  $o1$      &        \\
			$L$      &          &  $o1$      &        \\ 
			$J$      &          &  $o1$      &        \\ 
			$B$      &  $p2$    &            &        \\ 
			$O$      &          &  $o1$      &        \\
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}{.3\textwidth}
		\begin{tabular}{l|c|c|c}
			\textbf{transition} & \textbf{x} & \textbf{y} & \textbf{z} \\\hline
			$D$      &   $p1$   &            &        \\ 
			$V$      &          &            &$c2$    \\ 
			$K$      &          &   $o1$     &        \\ 
			$Z$      &          &   $o1$     & $c1$   \\ 
			$V$      &          &            & $c1$   \\ 
			$B$      &  $p1$    &            &        \\
		\end{tabular}
	\end{minipage}
\end{table}

Each sequence in a single process event log assumes to start from the initial marking of the \wfnet. 
A marked \tpnid, instead, represents a continuously executing system, for which, given a concrete identifier, exists a single observable execution that can be recorder in an event log. 
%In other words, the system is running, and has a single execution from which events of a given identifier can be observed and recorded in an event log. 
Thus, event logs are partial observations of a larger execution within the system: an event log for a certain type captures only the relevant events that contain identifiers of that type, and stores these in order of their execution.
Since each transition firing consists of a transition and a binding,  a \tpnid firing sequence induces an event log for each set of types $\Upsilon$. 
Intuitively, this induced event log is constructed by a filtering process. 
For each possible identifier vector for $\Upsilon$ we keep a firing sequence. 
Each transition firing is inspected, and if its binding satisfies an identifier vector of $\Upsilon$, it is added to the corresponding sequence.

\begin{definition}[Induced Event Log]
	Let $(N,m_0)$ be a marked \tpnid. Given a non-empty set of types $\Upsilon \subseteq \type_{\Lambda}(N)$, the \emph{$\Upsilon$-induced event log} of a firing sequence $\eta \in \L(N,m_0)$ is defined by:
%	\begin{equation*}
$		\mathit{Log}_\Upsilon(\eta) = \{ \proj{\eta}{i} \mid i \in (\Id(\eta) \intersect I(\Upsilon))^{\length{\Upsilon}} \} 
$,%	\end{equation*}
	where $\proj{\eta}{i}$ is inductively defined by
	\begin{inparaenum}[\it (1)]
		\item $\proj{\emptysequence}{i} = \emptysequence$, 
		\item $\proj{(\sequence{(t,\psi)}\concat \eta )}{i} = \sequence{(t,\psi)}\concat\proj{\eta}{i}$ if $\setsuppp{i}\subseteq \rng{\psi}$, and
		\item $\proj{(\sequence{(t,\psi)}\concat \eta )}{i} = \proj{\eta}{i}$ otherwise.
		\end{inparaenum}
\end{definition}

Different event logs can be induced from a firing sequence.
Consider, for example, the firing sequence of the net from \figref{runningexample} represented as table in \tblref{sequencerunningexample}.
As we cannot deduce the types for each of the variables from the firing sequences in \tblref{sequencerunningexample}, we assume that there is a bijection between variables and types, i.e., that each variable is uniquely identified by its type, and vice-versa.
Like that, we can create an induced log for each variable, as the type and variable name are interchangeable. %\andy{shall we say that with a slight abuse of notation, we use variable names instead of variable types (or that, given the assumption on the existence of such bijection, we use variable names and types interchangeably)?}
For example, the $x$-induced event log is $\mathit{Log}_{\{x\}} = \{\sequence{A,E,B},\sequence{A,C,D,B}\}$, and the $z$-induced event log is $\mathit{Log}_{\{z\}} = \{\sequence{T,G,Z,V},\sequence{T,V}\}$.
Similarly, event logs can be also induced for combinations of types.
In this example, the only non-empty induced event logs on combined types are $\mathit{Log}_{\{y,z\}} = \{\sequence{G,Z}\}$ and $\mathit{Log}_{\{x,y\}} = \{\sequence{E}\}$.

As the firing sequence in \tblref{sequencerunningexample} shows, 
transition firings (and thus also events) only show bindings of variables to identifiers.
For example, for firing $G$ with binding $y \mapsto o1$ and $z \mapsto c1$, it is not possible to derive the token types of the consumed and produced tokens directly from the table. 
Therefore, we make the following assumptions for process discovery on \tpnids:
\begin{enumerate}
	\item There are no ``black'' tokens: all places carry tokens with at least one type, and all types occur at most once in a place type, i.e., all places refer to at least one process instance.
	\item There is a bijection between variables and types, i.e., for each type exactly one variable is used.
	\item A G\"odel-like number $\mathscr G$ is used to order the types in place types, i.e., for any place $p$, we have $\mathscr G(\alpha(p)(i)) < \mathscr G(\alpha(p)(j))$ for $1 \leq i < j \leq \length{\alpha(p)}$ and $p \in P$.
	%\andy{why don't we assume that types are totally ordered? and say that $\alpha(p)(i) < \alpha(p)(j)$ for $1 \leq i < j \leq \length{\alpha(p)}$ and $p \in P$\\
	%\textbf{JMW}: Since the total order does not match a concept in real life, but is only a trick to get the mathematics simpler}
\end{enumerate}

%
%As shown in~\cite{vanderWerf2022}, any \wfnet can be transformed into a \tpnid. 
%Hence, we can assign a single object type to represent the process instance, say $c$.
%Each place is assigned with this object type $c$.
%An emitter transition ensures that new identifiers of type $c$ are produced in the initial place, and a collector transition removes finished process instances.
%
%\begin{definition}[EC-Closure~\cite{vanderWerf2022}]
%Given a \wfnet $N$, place type $\vec{\lambda} \in \seq{\Lambda}$, and variable vector $\vec{v} \in \seq{\varset}$, such that $\type_{\varset}(\vec{v}) = \vec{\lambda}$, its EC-closure is a \tpnid $\W(N,\vec{\lambda},\vec{v}) = (P_N, T_N, \union \{t_E, t_C\}, F_N \union \{(t_E,i_N),(f_N,t_C)\}, \alpha, \beta)$ with $\alpha(p) = \vec{\lambda}$ and $\beta(f) = \vec{v}$ for all $p \in P_N$ and $f \in F_N$.
%\end{definition}



\subsection{Rediscoverability of Typed Jackson Nets}
Whereas traditional process discovery approaches relate events in an event log to a single object: the process instance, object-centric approaches can relate events to many objects~\cite{GhahfarokhiPBA21}.
Most object-centric process discovery algorithms (e.g., \cite{aalstB20_discovering,LuNWF15}) use a divide and conquer approach, where ``flattening'' is the default implementation to divide the event data in smaller event logs. 
The flattening operation creates a trace for each object in the data set, and combines the traces of objects of the same type in an event log. 
As we have shown in \secref{decomposability}, singleton projections, i.e., those just considering types in isolation, are insufficient to reconstruct the \tjn that induced the object-centric event log. 
A similar observation is made for object-centric process discovery (cf.~\cite{aalst19_divergence,aalstB20_discovering,adams22_extractingfeatures}): flattening the event data into event logs generates inaccurate models.
Instead, reconstructability can only be achieved if all possible combinations of types are considered. 
Hence, for a divide and conquer strategy, the divide step should involve all possible combinations of types, i.e., each interaction between processes requires their own event log.
In the remainder of this section, we show that if all combinations of types are considered, flattening is possible, and traditional process discovery algorithms can be used to rediscover a system of interacting processes.

For a system of interacting processes, we consider execution traces, i.e., a firing sequence from the initial marking. 
Like that, event logs for specific types or combinations of types are induced from the firing sequence. 
The projection of the system on a type or combinations of types, results again in a \tjn. 
Similarly, if we project a firing sequence of a \tjn $N$ on a set of types~$\Upsilon$, then this projection is a firing sequence of the $\Upsilon$-projection on~$N$.
The property follows directly from the result that \tjn $N$ is weakly simulated by its $\Upsilon$-projection.

\begin{lemma}
Let $N$ be a \tjn, and let $\Upsilon \subseteq \type_{\Lambda}(N)$. Then 
$\hide{U}{\transitionsystem{N,\emptybag}}\preccurlyeq^r \transitionsystem{\project{\Upsilon}{N},\emptybag}$, with $U = T_N \setminus T_\Upsilon$.
\end{lemma}
\begin{proof} (sketch)
Let $N_\Upsilon = \proj{\Upsilon}{N} = (P_\Upsilon, T_\Upsilon, F_\Upsilon,\alpha_\Upsilon, \beta_\Upsilon)$.
We can define a relation $Q \subseteq \markings{N} \times \markings{\project{\Upsilon}{N}}$ s.t. $Q(m)(p)(\proj{a}{I(\Upsilon)}) = m(p)(a)$ if $p \in P_\Upsilon$ and $Q(m)(p) = m(p)$ otherwise. 
The rooted weak bisimulation of $Q$ follows directly from the firing rule of \tpnids.
\end{proof}

As the lemma shows, projecting a firing sequence yields a firing sequence for the projected net.
A direct consequence of the simulation relation is that, no matter whether we induce an event log from a firing sequence on the original net, or induce it from the projected firing sequence, the resulting event logs are the same.

\begin{corollary}
%	Let $N$ be a \tjn, and let $\eta \in \mathcal{L}(N, \emptybag)$. For $\Upsilon \subseteq \type_{\Lambda}(N)$ we have $\project{\Gamma}{\eta} \in \mathcal{L}(\project{\Upsilon}{N},\emptybag)$.
Let $(N,m_0)$ be a marked \tpnid. Given a set of types $\Upsilon \subseteq \type_{\Lambda}(N)$. 
Then $\mathit{Log}_\Upsilon(\eta) = \mathit{Log}_\Upsilon(\project{\Upsilon}{\eta})$.
\end{corollary}

Hence, it is not possible to observe whether an induced event log stems from the original model, or from its projection. 
Note that the projection may exhibit more behavior, so the reverse does not hold. 
In general, not any induced event log from the projection can be induced from the original model. 

In general, a projection does not need to be an atomic \tjn (that is, a \tjn that can be reduced by applying rules from \defref{typed_jackson_net} to a single transition). 
However, if the projection is atomic, then its structure is a transition-bordered \wfnet: 
a \wfnet that, instead of having source and sink places, has a set of start and finish transitions, such that pre-sets (resp., post-sets) of start (resp., finish) transitions are empty.
The closure of a transition-bordered \wfnet is constructed by adding a new source place $i$ so that each start transition consumes from $i$, and a new sink place $f$ so that each finish transition produces in $f$.


\begin{figure}[t]
	\centering
	\begin{tikzpicture}[->,>=stealth',auto,x=10mm,y=1cm,node distance=15mm and 3mm,thick,  every node/.style={scale=.9}]
		% Top: Models
		\node[tr, label=center:$M$] (M) {};
		\node[tr, right of = M, label=center:$M_1$, yshift=0.5cm, xshift=1.75cm]  (M1) {}; 
		\node[below of = M1,rotate=90,xshift=10mm] (d1) {$\cdots$};
		\node[tr, right of = M, label=center:$M_n$, yshift=-0.5cm, xshift=1.75cm]  (Mn) {}; 
		\node[tr, right of = M, label=center:$M'$, xshift=5cm]  (M') {};
		
		% Bot: Logs+Discovered Models
		\node[tr, below of = M, label=center:$L$, yshift=-0.5cm]    (L) {}; 
		\node[tr, right of = L, label=center:$L_1$, yshift=0.5cm]   (L1) {}; 
		\node[below of = L1,rotate=90,xshift=10mm] (d2) {$\cdots$};
		\node[tr, right of = L, label=center:$L_n$, yshift=-0.5cm]  (Ln) {};
		
		\node[tr, right of = L1, label=center:$D_1$, xshift=2cm] (D1) {};
		\node[below of = D1,rotate=90,xshift=10mm] (d3) {$\cdots$};
		\node[tr, right of = Ln, label=center:$D_n$, xshift=2cm] (Dn) {};
		\node[tr, below of = M', label=center:$D'$, yshift=-0.5cm]  (D') {};
		
		% "Text"
		\node[right of = M, xshift=-0.8cm] () {$\pi$};
		\node[right of = L, xshift=-0.8cm] () {$\pi$};
		
		\node[left of = M', xshift=0.8cm] () {$\uplus$};
		\node[left of = D',xshift=0.8cm] () {$\uplus$};	
		
		%		% Hacking in the legend
		%		\node[below of = L, label=right:{\textcolor{cadmiumorange}{$\longleftrightarrow$ bisimulation}}, yshift=0.2cm, xshift=-0.6cm]	(a) {};
		%		\node[below of = L, label=right:{\textcolor{blue-violet}{$\longrightarrow$~ generates}}, yshift=-0.2cm, xshift=-0.6cm]	(b) {};
		%		\node[right of = a, label=right:{\textcolor{red}{$\longrightarrow$ discovery}}, yshift=-0.2mm, xshift=1.5cm]	() {};
		%		\node[right of = b, label=right:{\textcolor{green1}{$\longrightarrow$ isomorphism}},xshift=1.5cm]	() {};
		% Empty node to fix caption overlap
		\node[below of = Ln,yshift=1.2cm] (a) {};
		
		%%% If we want to add text next to the arrow, use:
		%%  \path[->, draw=blue-violet] (M) edge node[anchor=center, xshift=-1cm]{\textcolor{blue-violet}{generates}} (L);
		
		% Normal
		\path[->, thin]
		($(M.east)+(0,.8mm)$) edge (M1)
		($(M.east)-(0,.8mm)$) edge (Mn)
		
		(L) edge (L1)
		(L) edge (Ln)
		
		(M1) edge ($(M'.west)+(0,.8mm)$)
		(Mn) edge ($(M'.west)-(0,.8mm)$)
		
		(D1) edge (D')
		(Dn) edge (D')
		;
		% Generates:
		\path[->, draw=blue-violet]
		(M) edge (L)
		(M1) edge (L1)
		(Mn) edge (Ln)
		;
		% Bisimulation
		\path[<->, draw=cadmiumorange]
		(M) edge[bend left=30] node[above,cadmiumorange,yshift=-.5mm]{$\sim^r$} (M')
		;
		% Discovery
		\path[->, draw=red]
		(L1) edge node[above,red]{$\overline{\mathit{disc}}$} (D1)
		(Ln) edge node[above,red]{$\overline{\mathit{disc}}$} (Dn)
		;
		% Isomorphism
		\path[<->, draw=green1]
		(M1) edge (D1)
		(Mn) edge (Dn)
		(M') edge (D')
		;
	\end{tikzpicture}
	
	%	\includegraphics[width=.8\textwidth]{figs/framework}
	\caption{Framework for rediscoverability of typed Jackson Nets. Model $M$ generates an event log $L$. Log projections $L_1 \ldots L_n$ are generated from projected nets $M_1 \ldots M_n$. %(\textcolor{blue-violet}{purple} arrows). 
		Discovery algorithm $\mathit{disc}$ results in nets $D_1 \ldots D_n$, isomorphic to $M_1 \ldots M_n$, 
		%(\textcolor{red}{red} arrows), 
		which can be composed in $D'$.
		$D'$ is isomorphic to $M'$ and thus to $M$.
%		\dbtodo{Rewrite later; should be a ``small story''.}
%		\textcolor{blue-violet}{Purple} arrows indicate that model $M$ generates log $L$.
%		Black arrows denote projections ($\pi$) and compositions ($\composeOperator$).
%		The \textcolor{cadmiumorange}{orange} arrow indicates bisimilarity.
%		Discovery is denoted with \textcolor{red}{red} arrows.
%		Finally, \textcolor{green1}{green} arrows imply isomorphism.
	}
	\figlabel{framework}
\end{figure}


\begin{lemma}
	Let $N$ be a \tjn and $\project{\Upsilon}{N} = (P_\Upsilon, T_\Upsilon, F_\Upsilon, \alpha_\Upsilon, \beta_\Upsilon)$ for some $\Upsilon \subseteq \type_{\Lambda}(N)$ such that $\project{\Upsilon}{N}$ is atomic. 
	Let $\eta \in \mathcal{L}(N, \emptybag)$ be a firing sequence. 
	Then $\mathit{Log}_\Upsilon(\eta)$ is generated by $(N_\Upsilon, \emptybag)$ with $N_\Upsilon = (P_\Upsilon \union \{i, f\},T_\Upsilon,F_\Upsilon \{ (i,t) 
	\mid \pre{t}=\emptyset \} \union \{(t,f) \mid \post{t} = \emptyset\})$.
\end{lemma}
\begin{proof} (sketch)
Let $\sigma \in \mathit{Log}_\Upsilon(\eta)$.
By construction, each firing sequence in $\mathit{Log}_\Upsilon(\eta)$ has some corresponding identifier vector that generated the sequence.
Assume $\vec\upsilon \in \idset^{|\Upsilon|}$ is such a vector for $\sigma$. 

Observe that for any transition $t \in T$ if $\pre{t} = \emptyset$, $\newvar{t} \intersect \Upsilon \neq \emptyset$, and similarly, if $\post{t} = \emptyset$, $\delvar{t} \intersect \Upsilon \neq \emptyset$. As $N$ is identifier sound, only $\pre{\sigma(1)} = \emptyset$ and $\post{\sigma(\length{\sigma})} = \emptyset$.
Define relation $R = \{(M,m) \mid \forall p \in P : M(p)(\upsilon)= m(p) \}$ and  $U = \{ (t,\psi) \mid \upsilon \not\subseteq \rng{\psi} \}$, i.e., $U$ contains all transitions that do not belong to $\sigma$. Then $R$ is a weak simulation, i.e., $\hide{U}{\transitionsystem{N,\emptybag}} \preccurlyeq^r_R \transitionsystem{N_\Upsilon,\emptybag}$ and thus $\pnenabled{(N_\Upsilon,\emptybag)}{\sigma}$.
\end{proof}

Given a set of types $\Upsilon$, if its projection is atomic, the projection can be transformed into a workflow net, and for any firing sequence of the original net, this \wfnet can generate the $\Upsilon$-induced event log.
Suppose we have a discovery algorithm $\mathit{disc}$ that can rediscover models, i.e., given an event log $L$ that was generated by some model $M$, then $\mathit{disc}$ returns the original model. 
Rediscoverability of an algorithm requires some property $P_{\mathit{disc}}(M)$ on the generating model $M$, and some property $Q_{\mathit{disc}}(L, M)$ on the quality of event log $L$ with respect to the generating model $M$. 
In other words, $P(M)$ and $Q(L,M)$ are premises to conclude rediscoverability for discovery algorithm $\mathit{disc}$.
For example, $\alpha$-miner~\cite{AalstWM04} requires for $P(M)$ that model $M$ is well-structured, and for $Q(L,M)$ that event log $L$ is directly-follows complete with respect to model $M$. 
Similarly, Inductive Miner~\cite{Leemans2013} requires the generating model $M$ to be a process tree  without silent actions or self-loops ($P(M)$), and that event log $L$ is directly-follows complete with respect to the original model $M$ ($Q(L,M)$).

\begin{definition}[Rediscovery]\deflabel{rediscovery}
An algorithm $\mathit{disc}$ can \emph{rediscover} \wfnet $W=(P,T,F,in,out)$ from event log $L \subseteq \seq{T}$ if $P_{\mathit{disc}}(W)$ and $Q_{\mathit{disc}}(L,W)$ imply $\mathit{disc}(L) \leftrightsquigarrow W$.
\end{definition}

Thus, suppose there exists a discovery algorithm $\mathit{disc}$ that is -- under conditions $P$ and $Q$ -- able to reconstruct a workflow model given an event log. 
In other words, given an event log $L$ generated by some model $M$, $\mathit{disc}$ returns a model that is isomorphic to the generating model. 
Now, suppose we have a firing sequence $\eta$ of some \tjn $N$, and some projection $\Upsilon$. Then, if $P(\project{\Upsilon}{N})$, and $Q(\mathit{Log}_\Upsilon(\eta),\project{\Upsilon}{N})$, then $\mathit{disc}$ returns a model that is isomorphic to the closure of $\project{\Upsilon}{N}$, as $\mathit{disc}$ only returns \wfnets. 
With $\overline{\mathit{disc}}$ we denote the model where the source and sink places are removed, i.e., $\overline{\mathit{disc}} \leftrightsquigarrow \project{\Upsilon}{N}$.
Then, as shown in \figref{framework}, if we discover for every possible combination of types, i.e., the subset-closed set of all type combinations, 
a model that is isomorphic to the type-projected model, then the composition results in a model that is bisimilar to the original model. 


\begin{theorem}[Rediscoverability of typed Jackson Nets]
Let $N$ be a \tjn, and let $\eta \in \mathcal{L}(N,\emptyset)$ without minor places. 
Let $\mathit{disc}$ be a discovery algorithm with properties $P$ and $Q$ that satisfy \defref{rediscovery}. 
If for all $\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)$ 
	the $\Upsilon$-projection is atomic and 
	satisfies conditions $P(\project{\Upsilon}{N})$ and $Q(\mathit{Log}_{\Upsilon}(\eta)), \project{\Upsilon}{N})$,
then $\transitionsystem{N,\emptyset} 
%\sim^r 
\leftrightsquigarrow
\transitionsystem{N',\emptyset}$ with $N' = \biguplus_{\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)} \overline{\mathit{disc}}(\mathit{Log}_\Upsilon(\eta))$.

%
%\begin{equation*}
%	\transitionsystem{N,\emptyset} \sim^r \biguplus_{\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)} \overline{\mathit{disc}}(\mathit{Log}_\Upsilon(\eta))
%\end{equation*}
\end{theorem}
\begin{proof} (sketch)
Let $\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)$ be a set of types in $N$. 
Since $P(\project{\Upsilon}{N})$ and $Q(\mathit{Log}_{\Upsilon}(\eta)), \project{\Upsilon}{N})$%
%, we have $\project{\Upsilon}{N} \leftrightsquigarrow \mathit{disc}(\mathit{Log}_{\Upsilon}(\eta))$. 
the closure of $\project{\Upsilon}{N}$ and $\mathit{disc}(\mathit{Log}_{\Upsilon}(\eta))$ are isomorphic.
From the closure, places $\inp$ and $\outp$ exist with $\pre{\inp} = \emptyset = \post{\outp{}}$. As the nets are isomorphic, we have $\proj{\Upsilon}{N} \leftrightsquigarrow \overline{\mathit{disc}}(\mathit{Log}_{\Upsilon}(\eta))$.
Combining the results gives
$\biguplus_{\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)} \overline{\mathit{disc}}(\mathit{Log}_\Upsilon(\eta)) \leftrightsquigarrow
\biguplus_{\emptyset \subset \Upsilon \subseteq \type_{\Lambda}(N)} \project{\Upsilon}{N}$.
The statement then follows directly from \corref{reconstructability}.
%The isomorphism implies that if the right hand side is rooted bisimilar to $(N,\emptyset)$, the left hand side is rooted bisimilar to $(N,\emptyset)$ as well, which proves the statement.
\end{proof}


%
%We propose a framework for rediscoverability based on the reconstructability of \tjns. In a nutshell, we project the event log $L$ onto each type to obtain $n$ sublogs $L_1, \cdots, L_n$, assuming a total of $n$ types in $L$. Similarly, we project model $M$ onto all types to obtain $n$ models $M_1, \cdots, M_n$. We show that if $M$ generates $L$, then by projecting as explained, each $M_i$ also generates $L_i$. For each of these sublogs, we apply some discovery algorithm $D$ obtaining new models $D_1, \cdots, D_n$. We show that each $M_i$ and $D_i$ are equivalent, given that $D$ has \dbtodo{this property}. Furthermore, the composition of all $M_i$ is isomorphic to original net $M$, and isomorphic to the composition of all $D_i$.
%
%%\db{This should eventually be made in TIKZ probably}
%\begin{figure}[h]%[!t]
%    \centering
%    \includegraphics[width=\linewidth]{figs/nu-miner-overview-illustration.pdf}
%    \caption{\dbtodo{Make in Tikz?} Illustration of the framework. Model $M$ generates log $L$ \dbtodo{make caption stand-alone.}}
%    \label{fig:framework_overview}
%\end{figure}
%
%Given a \tjn $N$, we consider an event log to be a firing sequence of $N$. As such, we do not distinguish cases or process instances, as these are indirectly given through the \dbtodo{mode (undefined for now)} of each firing transition. 
%
%\begin{definition}[Event Log]
%	An \emph{event log} $L$ is a tuple $(E, <, act, bind)$, where:
%	\begin{compactitem}
%		\item $(E, <)$ is a total order on events $E$,
%		\item $act: E \rightarrow T$ maps events to transitions, and
%		\item $bind: E \rightarrow ( \V \rightarrow \I \cup \set{\bot})$ is a function associating valuations to events.
%	\end{compactitem}
%\end{definition}
%
%In other words, we consider an event log to be a totally ordered set of events $E$, and each event has an associated action (represented by a transition $t$), as well as valuation that assigns an identifier to variables. We use $\bot$ if the variable is undefined.
%
%Given an event log $L = (E, <, act, bind)$, we define following sets:
%\begin{compactitem}
%	\item $var(e) = \set{v \in \V | bind(e)(v) \neq \bot}$
%	\item $type(e) = \set{\lambda \in \Lambda | \exists v \in var(e) : type_{\V} = \lambda}$
%	\item $types(L) = \Union_{e \in E} type(e)$
%\end{compactitem}
%
%Notice that, since $(E, <)$ is a total order, there is a unique sequence that characterizes the event log $L$. 
%
%$seq(L)$ is the firing sequence induced by $(E, <)$:
%$$
%\forall 1 \le i < j < \size{E} : seq(L)(i) < seq(L)(j)
%$$
%
%We say that an event log $L$ is \emph{generated} by a \tpnid if it is a firing sequence of that net.
%
%\begin{definition}[Generated Log] \deflabel{generated_by}
%	Let $N=(P, T, F,\alpha, \beta)$ a \tpnid, and $L = (E, <, act, bind)$. Given two markings $m, m'\in \markings{N}$, we define
%	$$
%	\fires{N}{m}{e}{m'} \iff \fires{N}{m}{(act(e), bind(e))}{m'}
%	$$
%	We say $L$ \emph{is generated by} $\markednet{N}{m_0}$ if markings $m_1, \cdots, m_{\size{E}}$ exist such that:
%	$$
%	\left(
%		N : m_1
%		\overset{{seq(l)(1)}}{\longrightarrow}
%		m_2
%		\overset{{seq(l)(2)}}{\longrightarrow}
%		\cdots
%		\overset{{seq(l)(\size{E})}}{\longrightarrow}
%		m_{\size{E}}
%	\right)
%	$$
%\end{definition}
%
%
%To construct an event log for a given set of identifiers, we use type projection on logs.
%
%\begin{definition} [Log Projection]
%	\dbtodo{def here}
%\end{definition}
%
%Notice that \defref{generated_by} implies that the event log can be replayed by a marked \tpnid. For \tjns it holds that, given a set of types, the projected logs can be replayed by the projected nets.
%
%\begin{lemma}
%	Let $N = (P, T, F, \alpha, \beta)$ a \tjn, and let $L$ an event log generated by $\markednet{N}{\emptyset}$. Then $\project{\L}{L}$ is generated by $\markednet{\project{\L}{N}}{\emptyset}$, for any $\L \subseteq types(n)$.
%\end{lemma}
%\begin{proof}
%	\dbtodo{the proof here}
%\end{proof}
%
%\begin{property}[\dbtodo{rediscoverability?}]
%	Let $M$ be a \tjn that generated log $L$. Suppose some discovery algorithm uses $L$ to discover new model $D$, then $M$ and $D$ are isomorphic. We write this as $Q(L, M)$, where relation $Q$ defines the isomorphism.
%\end{property}
%
%\begin{corollary}
%	M' is isomorphic to D' after removing minor places.
%\end{corollary}
%
%
%WE BUILD A DISCOVERY FRAMEWORK BASED ON THE DECOMPOSABILITY OF TYPED JACKSON NETS: PROJECT THE EVENT LOG SUCH THAT FOR EACH TYPE WE OBTAIN ITS LIFE CYCLE. NEXT, PROJECT ALSO ON ALL OF THE POSSIBLE ``INTERACTION LIFE CYCLES'', AND USE THE COMPOSITION OPERATOR OF TYPED JACKSON NETS TO OBTAIN A NET THAT DESCRIBES THE OBSERVED BEHAVIOR.
%
%THAT'S THE IDEA. WHEN AND HOW DOES IT WORK?
%
%WHAT ARE THE REQUIRED ASSUMPTIONS ON THE EVENT LOG?
%
%- EVENT LOG GENERATED BY A PROCESS THAT CAN BE REPRESENTED BY A TYPED JACKSON NET.
%
%- IDENTIFIER COMPLETENESS, I.E., THE DIRECTLY-FOLLOWS RELATION IS COMPLETE FOR EACH TYPE.
%
%- INTERACTION COMPLETENESS, I.E., THE DIRECTLY-FOLLOWS RELATION FOR EACH SET OF TYPES IS COMPLETE
%
%THEN, THE IDEA IS THAT IF A DISCOVERY ALGORITHM GUARANTEES SOME PROPERTY $\B$ ON EACH OF THE PROJECTED SUB LOGS, THEN THE COMPOSITION OPERATOR RETURNS A MODEL THAT IS BISIMILAR TO THE NET THAT ``GENERATED THE EVENT LOG''
%
%WHAT ARE THE REQUIREMENTS FOR \B?
%%
%
%Here we present a parametric approach for compositional discovery of t-JNs. \todo{shall we call it compositional?}
%In the nutshell, given a log $L$ over a set of event signatures $\E$ and a discovery algorithm $\D$,
%the approach first discovers a set of process models, each of which is obtained for a log projection $\restr{L}{O}$, for each $(n,O)\in\E$.
%Then, all the log projections are brought together using the composition operator $\bigoplus$.
%Conceptually, the approach is similar to the one discussed for the discovery of object-centric nets in~\cite{berti}. At the same time, it does not only work for a different class of process models in which identifiers (as well as relations between them) are explicit, but also comes with formal guarantees regarding the rediscoverability.\andy{rewrite the above paragraph}
%
%
%\begin{algorithm}
%    \caption{TJN-miner $\D_{id}$}\label{alg:cap}
%    \begin{algorithmic}
%        \Require a log $L$ over a set of event signatures $\E$, discovery algorithm $\D$
%        \Ensure a t-JN $N'$
%        \State $\N \gets \emptyset$
%        \For{$O\in \set{O\mid (n,O)\in\E}$}
%        \State $\N \gets \N\cup\D(\restr{L}{O})$
%        \EndFor
%        \State $N'=\bigoplus_{N\in\N} N$
%    \end{algorithmic}
%\end{algorithm}
%Here, $\D$ is the discovery algorithm for low-level Petri nets. %\todo{what are the properties of $\D$?}
%It is easy to see that while taking a projection over some $O$, then values provided by $\zeta$ in each event $(n,\zeta)$ (with $\dom{\zeta}=O$)  essentially create a case identifier.
%%\andy{Is the synchronization operator $\oplus$ always the same?}
%
%Notice that, if the input log $L$ is over a set of event signatures $\E$ such that $|\E|=1$, then the discovered t-JN should contain one single type.
%This also means that, in that case, it suffices to use any traditional discovery algorithm for P/T-nets.  %and the net discovered with $\D_{id}$ is topologically equivalent to the one discovered with $\D$ (i.e., their net graphs coincide)\todo{isomorphism?}
%
%\begin{proposition}
%    Let $L$ be a log. Then if $|\E|=1$, then $\D_{id}(L)=\D(L)$.
%    \andy{is that formulation even correct?}
%\end{proposition}
%
%
%% %\andy{if we consider dominant places (that is, places that have non-singleton types and that dominate over other single-typed places for cases when identical behaviors are discovered for both single types and those derived from valid relations), do we get isomorphism as well?}
%
%In the next sections we show how this framework can be instantiated with concrete discovery algorithms for $\D$ and demonstrate related rediscoverability results. For all the further instantiations we will be interested in t-JN logs, that is, logs logs composed of traces produced by t-JNs. The next definition sets up formally the main properties of t-JN logs.
%
%\begin{definition}[T-JN log]
%    A t-JN log over a set of signatures $\E$ is such a $\E$-complete log $L$ for which the following holds:
%    \begin{itemize}
%        \item every case starts with firing one of the emitters and ends by firing the last collector;
%        \item for every $t\in T$, there is a trace in $L$ that contains $t$ as an activity name;
%        \item every $O$-typed projection of the log is complete with respect to the non-typed directly follows relation.
%    \end{itemize}
%    \andy{make a proper definition that starts with a log formed by all traces produced by a t-JN (PNID traces should be defined Section 3 )}
%\end{definition}
%
%
%After having defined a particular type of logs we will be interested in, we would like to define a generic property of $\D_{id}$ discovery algorithm. This property will prove itself useful when studying theoretical properties of concrete instantiations of $\D_{id}$.
%
%\begin{definition}[Typed discovery property]\label{def:discovery-property}
%    this property should be defined similarly to the one of Inductive Miner
%\end{definition}
%
%
%Further on, for every instantiation of our parametric algorithm, we will be interested in the classical property of discovery algorithm known as \emph{rediscoverability}.
%In the nutshell, given a marked identifier sound typed Jackson net $(N,M_0)$ and a discovery algorithm $\D_{id}$ that discovers from a log induced by $N$ a typed Jackson net that is identifier sound, we say that $\D_{id}$ \emph{rediscovers} $N$ if for every log induced by $N$, $\D_{id}$ returns $N'$ that is equivalent to $N$ (modulo renaming of places).
%
%% \andy{Do we have any generic basic property of the algorithm? For example, we could say that $\D$ must be such that $\D(\restr{L_N}{O})\sim\restr{N}{O}$, for every $O\in\set{O\mid (n,O)\in\E}$. This, on the one hand, doesn't affect the algorithm. On the other hand, we might limit the ``admissible'' algorithms for out framework.}
%
%
%





% \endinput

% \subsection{Rediscoverability}
% %\andy{Can we say something about the compositionality here? Why can we rediscover the original net while taking its ``propositionalized'' projections? Is it a property that comes from Jackson nets? Or from the composition operator? Or is it just a coincidence? }
% Let us first recall the classical property of discovery algorithm known as \emph{rediscoverability}.
% Given a marked identifier sound typed Jackson net $(N,M_0)$, we say that a discovery algorithm $\mathtt{DA}$ that discovers from a log induced by $N$ typed Jackson nets that are identifier sound. Then, if for every log  induced by $N$, $\mathtt{DA}$ returns $N'$ that is equivalent to $N$ (modulo renaming of places), then $\mathtt{DA}$ \emph{rediscovers} $N$.





% %\andy{if we do a projection on log for a single variable, then we obtain ``plain'' logs on which $\alpha$-miner can be executed (a la Berti)}




% \subsection{Curious example}

% Consider the following net $N$:


% \begin{center}
%     \begin{tikzpicture}[->,>=stealth',auto,x=15mm,y=1.0cm,node distance=15mm and 7mm,thick, scale=0.8, every node/.style={scale=0.8}]

%         \node[tr] (a) {$a$};
%         \node[pl,right of = a,xshift =8mm] (p1) {};
%         \node[tr,right of = p1,xshift =8mm] (d) {$d$};

%         \node[pl,below of = a,xshift =8mm] (p2) {};
%         \node[tr,right of = p2] (c) {$c$};
%         \node[pl,right of = c]  (p3) {};

%         \node[tr,below of = p2,xshift=-8mm] (b) {$b$};
%         \node[pl,right of = b,xshift =8mm] (p4) {};
%         \node[tr,right of = p4,xshift =8mm] (e) {$e$};


%         \path[->]
%         (a) edge (p1)
%         (p1) edge (d)
%         (a) edge (p2)
%         (p2) edge (c)
%         (c) edge (p3)
%         (b) edge (p2)
%         (p3) edge (d)
%         (p3) edge (e)
%         (b) edge (p4)
%         (p4) edge (e)
%         ;
%     \end{tikzpicture}
% \end{center}

% Consider $L_N$. Then the rediscovered net with $\alpha$-miner looks as follows:
% \begin{center}
%     \begin{tikzpicture}[->,>=stealth',auto,x=15mm,y=1.0cm,node distance=15mm and 7mm,thick, scale=0.8, every node/.style={scale=0.8}]

%         \node[tr] (a) {$a$};
%         \node[pl,right of = a,xshift =8mm,draw=none] (p1) {};
%         \node[tr,right of = p1,xshift =8mm] (d) {$d$};

%         \node[pl,below of = a,xshift =8mm] (p2) {};
%         \node[pl,left of = p2,xshift=-3mm] (p5) {};
%         \node[tr,right of = p2] (c) {$c$};
%         \node[pl,right of = c]  (p3) {};

%         \node[tr,below of = p2,xshift=-8mm] (b) {$b$};
%         \node[pl,right of = b,xshift =8mm,draw=none] (p4) {};
%         \node[pl,right of = p3,xshift=3mm] (p6) {};
%         \node[tr,right of = p4,xshift =8mm] (e) {$e$};


%         \path[->]

%         (a) edge (p2)
%         (p2) edge (c)
%         (c) edge (p3)
%         (b) edge (p2)
%         (p3) edge (d)
%         (p3) edge (e)

%         (d) edge (p6)
%         (e) edge (p6)
%         (p5) edge (a)
%         (p5) edge (b)
%         ;
%     \end{tikzpicture}
% \end{center}

% This demonstrates one of the limitation of $\alpha$-miner: it cannot discover non-local dependencies. Indeed, for the given example the miner does not discover the place between $a$ and $d$, and the place between $b$ and $e$.

% Now, let us consider $N'$ -- a typed version of $N$:

% \begin{center}
%     \begin{tikzpicture}[->,>=stealth',auto,x=15mm,y=1.0cm,node distance=15mm and 7mm,thick, scale=0.8, every node/.style={scale=0.8}]

%         \node[tr] (a) {$a$};
%         \node[pl,right of = a,xshift =8mm] (p1) {};
%         \node[tr,right of = p1,xshift =8mm] (d) {$d$};

%         \node[pl,below of = a,xshift =8mm] (p2) {};
%         \node[tr,right of = p2] (c) {$c$};
%         \node[pl,right of = c]  (p3) {};

%         \node[tr,below of = p2,xshift=-8mm] (b) {$b$};
%         \node[pl,right of = b,xshift =8mm] (p4) {};
%         \node[tr,right of = p4,xshift =8mm] (e) {$e$};


%         \path[->]
%         (a) edge node{$x$} (p1)
%         (p1) edge node{$x$} (d)
%         (a) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p2)
%         (p2) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (c)
%         (c) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p3)
%         (b) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p2)
%         (p3) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (d)
%         (p3) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (e)
%         (b) edge node{$x$} (p4)
%         (p4) edge node{$x$} (e)
%         ;
%     \end{tikzpicture}
% \end{center}
% Let us now apply $\D_{id}$ to $N'$.
% We start by discovering nets for log projections.
% For the type of $x$, we get $\D(\restr{L_{N'}}{x})$:
% \begin{center}
%     \begin{tikzpicture}[->,>=stealth',auto,x=15mm,y=1.0cm,node distance=15mm and 7mm,thick, scale=0.8, every node/.style={scale=0.8}]

%         \node[tr] (a) {$a$};
%         \node[pl,right of = a,xshift =8mm] (p1) {};
%         \node[tr,right of = p1,xshift =8mm] (d) {$d$};


%         \node[tr,below of = a] (b) {$b$};
%         \node[pl,right of = b,xshift =8mm] (p4) {};
%         \node[tr,right of = p4,xshift =8mm] (e) {$e$};

%         \node[pl,left of = a,yshift=-8mm] (p5) {};
%         \node[pl,right of = d,yshift=-8mm] (p6) {};


%         \path[->]
%         (a) edge node{$x$} (p1)
%         (p1) edge node{$x$} (d)
%         (b) edge node{$x$} (p4)
%         (p4) edge node{$x$} (e)
%         (p5) edge node{$x$} (a)
%         (p5) edge node{$x$}  (b)
%         (d) edge node{$x$}  (p6)
%         (e) edge node{$x$}  (p6)
%         ;
%     \end{tikzpicture}
% \end{center}

% For $y$ we obtain the following net  $\D(\restr{L_{N'}}{y})$:
% \begin{center}
%     \begin{tikzpicture}[->,>=stealth',auto,x=15mm,y=1.0cm,node distance=15mm and 7mm,thick, scale=0.8, every node/.style={scale=0.8}]

%         \node[tr] (a) {$a$};
%         \node[pl,right of = a,xshift =8mm,draw=none] (p1) {};
%         \node[tr,right of = p1,xshift =8mm] (d) {$d$};

%         \node[pl,below of = a,xshift =8mm] (p2) {};
%         \node[pl,left of = p2,xshift=-3mm] (p5) {};
%         \node[tr,right of = p2] (c) {$c$};
%         \node[pl,right of = c]  (p3) {};

%         \node[tr,below of = p2,xshift=-8mm] (b) {$b$};
%         \node[pl,right of = b,xshift =8mm,draw=none] (p4) {};
%         \node[pl,right of = p3,xshift=3mm] (p6) {};
%         \node[tr,right of = p4,xshift =8mm] (e) {$e$};


%         \path[->]

%         (a) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p2)
%         (p2) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (c)
%         (c) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p3)
%         (b) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p2)
%         (p3) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (d)
%         (p3) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (e)

%         (d) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p6)
%         (e) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (p6)
%         (p5) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (a)
%         (p5) edge node{$y$}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (b)
%         ;
%     \end{tikzpicture}
% \end{center}


% By merging $\D(\restr{L_{N'}}{x})$ and $\D(\restr{L_{N'}}{y})$, we obtain the original $N'$. Notice  that  the discovery algorithm here identifies non-local dependencies between actions.
% \endinput

% \subsection{Discovering directly-follows relations between objects}

% %
% %\begin{definition}
% %Let $L$ be a log. Then $G(L)=(V,E)$ is the \emph{identifier graph} it induces, where $V=\id{L}$ and $E=\set{(\cname{id_1},\cname{id_2})\mid \exists\trace\in L \land \exists (n,\zeta)\in \trace:  \cname{id_1}\in\rng{\zeta} \land \cname{id_2}\in\rng{\zeta}}$.
% %\end{definition}
% %It is easy to see that $G(L)$ is constructed by taking all the object identifiers appearing in the log and creating links only between those that appear in the same event payload.
% %
% %\begin{example}
% %Consider the complete log $L$ from Example~\ref{ex:log}.
% %Then we can construct $G(L)$ that looks as follows:
% %
% %\begin{center}
% %\begin{tikzpicture}[every node/.style={thick}]
% %	\node (1) {$\cname{1}$};
% %	\node[below of = 1] (2) {$\cname{2}$};
% %	\node[right of = 1] (A) {$\cname{A}$};
% %	\node[right of = 2] (B) {$\cname{B}$};
% %	\node[right of = B,yshift = 5mm] (st) {$\bigstar$};
% %	\path[-] 
% %			(1) edge (A) edge (B)  edge (st)
% %			(A) edge (st)
% %			(2) edge (A) edge (B) edge (st)
% %			(B) edge (st);
% %\end{tikzpicture}
% %\end{center}
% %\end{example}
% %
% %With that graph $(V,E)$ at hand, we can proceed by defining relations between object types together with their related multiplicities. 
% %To this end, given two names $o_1,o_2\in\O_\E$ as well as values $\cname{id_1},\cname{id_1'}\in V\cap I(type_{\V}(o_1))$ and $\cname{id_2},\cname{id_2'}\in V\cap I(type_{\V}(o_2))$, we define the following relations:
% %\begin{itemize}
% %\item $(o_1,o_2)\in R_{\mathtt{m,1}}$ iff if $(\cname{id_1},\cname{id_2}),(\cname{id_1},\cname{id_2'})\in E$, then $\cname{id_2}=\cname{id_2'}$;
% %\item $(o_1, o_2)\in R_{\mathtt{1,1}}$ iff if $(\cname{id_1},\cname{id_2}),(\cname{id_1'},\cname{id_2'})\in E$, then  $\cname{id_1}=\cname{id_1'}$ and $\cname{id_2}=\cname{id_2'}$;
% %\item $(o_1, o_2)\in R_{\mathtt{m,m}}$ otherwise.
% %\end{itemize}


% Now we can proceed with generating directly follows relations for each signature in $\E$. The main idea here is to
% We start by projecting the log on one object name at a time (notice that like that the identifier value is identical to a case identifier). Then the procedure for extracting directly follows relation is identical to the one used in $\alpha$-miner.

% \begin{definition}[Typed ordering relations]
%     Let $L$ be a log over a set of event signatures $\E$, $o\in \O_\E$ be an object name and $a_1,a_2\in \N_\E$ two activity names.
%     \begin{enumerate}
%         \item $>_L^o\subseteq \N_\E\times \N_\E$ is an $o$-typed directly follows relation s.t.
%               $a_1 >_L^o a_2$ iff there is a trace $\tup{e_1\cdots e_m}\in \restr{L}{\set{o}}$ s.t. $e_i=(a_1,o)$ and $e_{i+1}=(a_2,o)$, for some $1\leq i \leq m-1$.
%         \item $\to_L^o\subseteq \N_\E\times \N_\E$ is an $o$-typed  causality relation s.t. $a_1 \to_L^o a_2$ iff $a_1 >_L^o a_2$ and $a_2 \not>_L^o a_1$.
%         \item $\#_L^o\subseteq \N_\E\times \N_\E$ is an $o$-typed  conflict relation s.t. $a_1 \#L^o a_2$ iff $a_1 \not>_L^o a_2$ and $a_2 \not>_L^o a_1$.
%         \item $||_L^o\subseteq \N_\E\times \N_\E$ is an $o$-typed  concurrency relation s.t. $a_1 ||_L^o a_2$ iff $a_1 >_L^o a_2$ and $a_2 >_L^o a_1$.
%     \end{enumerate}
% \end{definition}


% Since the above relations can be derived from $>_L^o$ , we assume the log to be complete with respect to $>_L^o$.








% %
% %
% %
% %An algorithm/heuristic is said to rediscover a workflow net if this algorithm is
% %able to regenerate the exact net structure of the original net, abstracting from
% %the place labels (see Definition 2.4). The -algorithm is proved to (re)discover all
% %SWF-nets if the SWF-net does not contain short-loops. That means that short
% %loops are a first limitation of the -algorithm. However, if the notion of ability to
% %rediscover is relaxed to behaviorally equivalent (i.e. both generate the same log
% %traces), then the -algorithm is able to mine other sound WF-nets, like the one
% %in Figure 3. This net is not an SWF-net because transition G can be enabled
% %without the firing of transitions E and F. However, even with this relaxed notion
% %of ability to rediscover and the restriction on short-loops, the -algorithm cannot
% %be proved to correctly mine all sound WF-nets.