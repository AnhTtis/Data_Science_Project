sycl::event event = queue.submit([&](sycl::handler& h) {
     /* insert SYCL dependencies */
     h.parallel_for(num_items, [=](auto i) {
                /* insert numeric code here */ });/
});
// Call HPX-SYCL integration
hpx::future<void> my_future =
   hpx::sycl::experimental::detail::get_future(event);
// Add task to be executed once the event is done
hpx::future<void> continuation_future =
   my_future.then([&continuation_triggered](auto&& fut) {
     /* insert CPU work/communication/post-processing */
   });
/* Suspend the current HPX task if kernel and continuation 
are not yet done. This does not block the worker thread,
it merely moves to work on another available task*/
continuation_future.get()