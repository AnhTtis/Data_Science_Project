\section{Preliminaries}

A graph \(G = (V, E)\) is a set of nodes \(V\)
with a relation \(E \subseteq V \times V\) defining edges between the nodes.
We say that \(G\) is connected if there is a path within \(G\) between any two nodes.
If \(E\) is symmetric, then we say \(G\) is undirected; otherwise, \(G\) is directed.
We say that \(G\) is node-labeled if we have a function \(\lambda: V \to L\)
that assigns a label from \(L\) to each node in \(G\).
If we have two such node-labeling functions, we call the graph doubly-node-labeled.
We say that \(G\) is edge-weighted
if we have a function \(\omega: E \to W\) assigning each edge in the graph
some weight from \(W\).
If these weights are natural numbers,
then we say \(G\) is a multigraph,
whose edge multiplicities are given by \(\omega\).

There are two common ways to model temporality for graphs:
as continuous streams of (hyper-)edges, and as discrete sequences of graph snapshots~\cite{holme2012survey}.
In the present work, we consider the latter form of dynamic graph,
which we represent as a (finite) sequence
\(\left\langle G_t \right\rangle_{t = 0}^{T} = \left\langle G_0, \dots G_T \right\rangle\)
of graphs \(G_t = (V_t, E_t)\).%, each having its own, possibly distinct, node and edge sets.



\subsection{Context-Free Grammars.}
A context-free grammar (CFG) on strings is determined by
a finite set of nonterminal symbols \(N\) with a distinguished starting symbol \(S \in N\)
and finite a set of terminal symbols \(T\),
along with a finite set of production rules \(R \subseteq N \times (N \union T)^*\).
Each rule \(P_i \in R\) represents a transition from a left-hand side (LHS) nonterminal
to a finite sequence of symbols on the right-hand side (RHS),
each of which is either terminal or nonterminal.
We say $P_i$ is terminal if it only contains terminal symbols;
otherwise, $P_i$ is nonterminal.

Given a string \(\Sigma = \sigma_1 \dots \sigma_i \dots \sigma_n \in (N \union T)^*\),
the application of a production rule \(P_i\)
to a particular nonterminal symbol \(\sigma_i \in N\) from \(\Sigma\)
involves replacing the symbol \(\sigma_i\) with the string on the RHS of \(P_i\).
Formally, the result of applying \(P_i = (\sigma_i, \pi_{P_i})\) to \(\sigma_i\) in \(\Sigma\)
is a new string \(\tilde{\Sigma} = \left( \sigma_1 \dots \sigma_{i - 1} \right) \cdot \pi_{P_i} \cdot \left( \sigma_{i + 1} \dots \sigma_n \right)\),
where \(\cdot\) represents the string-concatenation operation.
% TODO: maybe include a figure here describing the rule-application process for a CFG?
%TW: nah$


\subsection{Vertex-Replacement Graph Grammars.}
A natural way to generalize CFGs would be to think of the characters in a string like nodes in a graph.
We can then think of CFG rules as producing graphs whose nodes are arranged in a path,
with attributes given by the different characters in the language
and boundary conditions specifying whether or not additional characters can be added at the beginning
or end of the string.
Clearly, changing the connectivity structure and boundary conditions
will lead to rules with more expressive RHS structures.

There are many specific formalisms and nuances, but generally a vertex-replacement grammar (VRG)
% are a generalization of CFGs
% where the rules now produce graphs instead of strings.
% Formally, a VRG is given by a finite set of natural-number nonterminal symbols \(N \subseteq \mathbb{N}\)
is given by a finite set of nonterminal symbols \(N \subseteq \mathbb{N}\)
with the distinguished starting symbol \(0 \in N\)
along with a set of terminal symbols \(T \subseteq V_G\) representing nodes in a graph.
% corresponding to nodes in a graph \(G = (V_G, E_G)\).
The production rules \(P_i\) for a VRG then look like transitions from a nonterminal symbol \(n \in N\)
to a doubly-node-labeled multigraph \(\left( H, \lambda_H, \delta_H \right)\)
whose first node-labeling function \(\lambda_H: V_{H} \to N \union T\)
distinguishes between terminal and nonterminal symbols,
and whose second node-labeling function \(\delta_H: V_{H} \to \mathbb{N}\) assigns
a natural number \emph{boundary degree} to each node of \(G\).

As was the case with CFGs,
we apply rules at nonterminals by replacing those symbols
with the structure on the RHS of a suitable production rule,
while accounting for VRG rules' nontrivial boundary conditions (\textit{i.e.,} the boundary degrees).
% With VRGs, we apply production rules at nonterminal symbols analogously as with CFGs.
Given a connected, node-labeled multigraph \(G = (V_G, E_G, \lambda_G)\)
with a node \(v \in V_G\) having nonterminal label \(\lambda_G(v) \in N\),
the application of a rule \(P_i = (\lambda_G(v), (H, \lambda_H, \delta_H))\) at \(v\)
consists of replacing \(v\) with the graph \(H\) and rewiring the
\emph{broken edges}---those edges previously connected to $v$---to those nodes in $H$
such that the number of broken edges incident on a node $v_H$ of $H$
does not exceed its boundary degree $\delta(v_H)$. 
%randomly vs deterministically rewiring is the difference between many types of VRGs.

Random rewiring is the most rudimentary way to address the boundary condition.
If our data were augmented with node labels,
we could guide the rewiring process using an estimated assortativity mixing matrix,
or by minimizing a loss function computed over the nodes~\cite{sikdar2022attributed}.
Even without node labels,
we could consider greedy rewiring strategies that try to reduce discrepancy
along some measured statistic of the data%
---\textit{e.g.,} modularity, average local clustering coefficient, graphlet distribution.
For simplicity, we consider only the random approach in the present work.
% For simplicity, we restrict our rewiring policy to the uniform random approach described in the preceding paragraph.

Formally, we will say that a production rule \(P_i = (s, (H, \lambda_H, \delta_H))\) is suitable
for a node \(v \in V_G\) if \(\lambda_G(v) = s\) and \(\deg(v) = \sum_{v_H \in V_H}\delta_H(v_H)\).
This means that the label associated with \(v\) is the same as the nonterminal symbol \(P_i\) is expecting,
and that the number of broken edges \(v\) will leave behind is the same as the
total number of boundary edge slots \(H\) has available.
With these conditions, the application of a suitable \(P_i\) at a node \(v\) results in a well-defined,
though not necessarily deterministic, vertex-to-subgraph substitution.

Typically, we only distinguish between the rules in a grammar
% (whether it is a CFG, VRG, or some other formalism)
\emph{up to isomorphism} once an appropriate notion of isomorphism for production rules is specified.
We say two rules
$\dot{P} = \left( \dot{s}, (\dot{H}, \dot{\lambda}, \dot{\delta}) \right)$
and $\ddot{P} = \left( \ddot{s}, (\ddot{H}, \ddot{\lambda}, \ddot{\delta}) \right)$
from a VRG are rule-isomorphic \textit{if and only if} $\dot{s} = \ddot{s}$ and
there is a graph isomorphism $\dot{H} \cong \ddot{H}$
that preserves the labels from $\dot{\lambda}$ and $\ddot{\lambda}$
(but not necessarily $\dot{\delta}$ and $\ddot{\delta}$).
% TODO: definitely include a figure here describing the rule-application process for a VRG



\subsection{Filtrations.}
% A hierarchical decomposition of a graph is a filtration $F = \langle F_i \rangle_{i = 1}^{n}$,
A filtration of a graph $G = (V, E)$ is a sequence of node partitions
$\mathcal{F} = \langle F_i \rangle_{i = 1}^{n}$,
where each $F_i$ partitions the node set $V$ into mutually-disjoint subsets---called \emph{covers}---%
% such that every node cover in $F_i$ is contained in a cover from $F_{i + 1}$.
so that each $F_i$ is a refinement of $F_{i + 1}$.
When mining real-world networks,
filtrations are often the result of
hierarchical node clusterings~\cite{gao2021hydrogen,bateni2017affinity},
%(\textit{a.k.a.} dendrograms),
$k$-core decompositions~\cite{dorogovtsev2006kcore,shin2016corescope},
and, more recently,
methods~\cite{rieck2021filtration,rieck2023curvature}
inspired by persistent homology~\cite{cohensteiner2005persistence}
and topological data analysis~\cite{bubenik2015tda}.
The aforementioned methods usually produce filtrations as an intermediate result
for an analysis of a network involving, for example,
community detection~\cite{zhang2007clustering},
representation learning~\cite{ying2018hierarchical},
or visualization~\cite{clemencon2012visualization}.
Filtrations lend themselves well to generative approaches to network structures
since they can highlight salient hierarchical and recursive patterns.
Vertex-replacement graph grammars can induce filtrations
(\textit{cf.} \autoref{sec:extract}) suitable for dynamic graph modeling.
% We describe the correspondence between graphs, filtrations, and VRGs in the proceeding sections.
