\noindent\textbf{Simulator.} In the ideal world, $\mathcal{S}$ receives $\lambda$ and $1^n$ from $\mathcal{F}$ and executes the following steps:

\begin{enumerate}[itemsep=0mm]
    \item $\mathcal{S}$ chooses a uniformly distributed random tape $r$.
    \item $\mathcal{S}$ runs the key generation function to sample $pk$: $(pk, sk) \leftarrow \mathit{HE}.KeyGen(\lambda)$.
    \item For a chosen $i$th learner, $\mathcal{S}$ runs the encryption function to sample: $(c_i) \leftarrow \mathit{HE}.Enc(pk, r^{\left|\mathbf{W}_i\right|})$.
    \item $\mathcal{S}$ repeats Step $3$ for all other learners to obtain $\vec{c}$, and runs the federated aggregation function $f$ to sample: $(c_\text{glob}) \leftarrow \mathit{HE}.Eval(\vec{\mathbf{c}}, f)$.
\end{enumerate}

The execution of $\mathcal{S}$ implies that:

$\left\{\left(c_i, c_\text{glob}\right)\right\} \stackrel{\mathrm{s}}{\equiv}\left\{\left(\mathit{HE}.Enc(pk, \mathbf{W}_i), \mathit{HE}.Eval(\vec{\mathbf{W}}, f)\right)\right\}$



Thus, we conclude that $\mathcal{S}$'s output in the ideal world is computationally indistinguishable from the view of $\mathcal{A}$ in a real world execution:

$\left\{\mathcal{S}\left(1^n,\left(\lambda\right)\right)\right\} \stackrel{\mathrm{s}}{\equiv}\left\{\operatorname{view}^\pi\left(\lambda\right)\right\}$,

where $\operatorname{view}$ is the view of $\mathcal{A}$ in the real execution of $\pi$.