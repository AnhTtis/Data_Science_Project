\section{Overview of the FP VDM Model of Chess}
\label{sec:coremodel}

%\fbox{9 pages}

The model described in this section follows the FP architecture as shown in \cref{sec:paradigms}, where a bottom-up approach will be taken of the most interesting parts of the model.

\subsection{PieceModule}
The PieceModule (\texttt{PM}) class has the responsibility of defining the types necessary to describe a Chess piece and providing the functions necessary to describe their basic movement patterns.

The piece type can be modelled as a union of quote types with the following options: \texttt{<pawn>|<rook>|<knight>|<bishop>|<queen>|<king>}. A composite type is used to define the \texttt{Coordinate}s which consists of two \texttt{nat1} to describe the x- and y-coordinates of a piece. The convention of annotating the x-axis through letters is abstracted away to make the two axes consistent. An invariant is put on \texttt{Coordinate} to ensure that the position is legal, i.e., the values are less than nine.

A data structure for the \texttt{Piece}s could now be established as a composite type containing the attributes \texttt{type : PieceType}, \texttt{square : Coordinate}, and \texttt{colour : Colour}.

The simple moves, i.e., excluding special moves, can be found for a given \texttt{Piece} using the \texttt{type\_based\_moves} function that takes \texttt{Piece * ObstacleSet} as parameters and returns a \texttt{set of Coordinates} containing the valid \texttt{Coordinate}s that the \texttt{Piece} can move to.
An \texttt{ObstacleSet} is needed to filter out the moves that are invalid due to the \texttt{Piece}'s path being blocked by an \texttt{Obstacle}. An \texttt{Obstacle} contains a \texttt{Coordinate} and \texttt{Colour} where the \texttt{Colour} is needed to indicate if the \texttt{Obstacle} is capturable or not.
Alternatively, one could have modelled the function without the \texttt{ObstacleSet} by returning the collection of legal \texttt{Coordinate}s assuming the board was empty since this would decouple the \texttt{PieceModule} further from the state of the board. However, it would require the \texttt{BoardModule} to be more closely coupled to the \texttt{PieceType} as it would need a special case for handling the movements of a pawn, as the pawn moves forward but attacks diagonally.

The \texttt{type\_based\_moves} function is written using a cases expression to pattern-match the \texttt{PieceType} to a function defining the specific movement pattern of the piece. The movement pattern of the knight and king can be modelled using a common helper function, \texttt{possible\_move\_direction}, as seen in the snippet below. Among the \texttt{Piece} and \texttt{ObstacleSet}, a pair of ints are provided as parameters to indicate the direction where the possible moves are to be considered. A new \texttt{[Coordinate]} is generated based on the \texttt{dir} through \texttt{coordinate\_factory} that returns \texttt{nil} if the provided inputs result in an invalid \texttt{Coordinate}. \texttt{possible\_move\_direction} evaluates to \texttt{nil} if the generated \texttt{Coordinate} is invalid or occupied by a friendly piece. Otherwise, the new \texttt{Coordinate} is returned.

\begin{lstlisting}
possible_move_direction: Piece * ObstacleSet * (int * int) -> [Coordinate]
possible_move_direction(p, os, dir) ==
let new_c = coordinate_factory(p.square.x + dir.#1, p.square.y + dir.#2) 
in
  if (new_c = nil) or 
     exists piece in set os &
      (piece.square = new_c) and (piece.colour = p.colour) 
  then nil
  else new_c;
\end{lstlisting}

Having now defined \texttt{possible\_move\_direction} the movement pattern of the knight can be defined as below.

\begin{lstlisting}
knight_move_pattern : Piece * ObstacleSet -> set of Coordinate
knight_move_pattern(p, os) ==
  {possible_move_direction(p, os, mk_(1, 2)), -- 2Up1Right
   possible_move_direction(p, os, mk_(-1, 2)), -- 2Up1Left
   possible_move_direction(p, os, mk_(1, -2)), -- 2Down1Right
   possible_move_direction(p, os, mk_(-1, -2)), -- 2Down1Left
   possible_move_direction(p, os, mk_(2, 1)), -- 1Up2Right
   possible_move_direction(p, os, mk_(-2, 1)), -- 1Up2Left
   possible_move_direction(p, os, mk_(2, -1)), -- 1Down2Right
   possible_move_direction(p, os, mk_(-2, -1)) -- 1Down2Left
    } \ {nil} 
pre p.type = <knight>;
\end{lstlisting}

Similarly, the other piece types rook, bishop and queen has been modelled using the \texttt{possible\_moves\_direction} as seen in the snippet below. This time recursion is needed as these can continue in a direction they are blocked or can capture a piece.
Once again a new \texttt{[Coordinate]} is generated.
The first conditional is identical to the one in \texttt{possible\_move\_direction} but the empty set is returned in this case. A check is then made to determine if an opponent is on the square that is being evaluated, where the recursion is terminated and a set containing the \texttt{Coordinate} is returned. At last, the recursive case is defined where a union between the set containing the \texttt{Coordinate} and the result of recursively calling the function in the same direction is returned.

\begin{lstlisting}
possible_moves_direction: Piece * ObstacleSet * (int * int) -> set of Coordinate
possible_moves_direction(p, os, dir) ==
  let new_c = coordinate_factory(p.square.x + dir.#1, p.square.y + dir.#2) 
  in
     if (new_c = nil) or 
        exists piece in set os &
                (piece.square = new_c) and (piece.colour = p.colour) 
    then {}
    elseif exists piece in set os &
                (piece.square = new_c) and (piece.colour = opposite_color(p.colour))
     then {new_c}
     else {new_c} union 
            possible_moves_direction(mk_Piece(p.type, new_c, p.colour), os, dir);
\end{lstlisting}

\noindent In principle this recursive function should have a proper \texttt{measure} ensuring the termination but it is not straightforward.

The movement pattern of the queen can then be defined as seen below.

\begin{lstlisting}
queen_move_pattern : Piece * ObstacleSet -> set of Coordinate
queen_move_pattern(p, os) ==
  dunion {possible_moves_direction(p, os, mk_(0, 1)),
          possible_moves_direction(p, os, mk_(0, -1)),
          possible_moves_direction(p, os, mk_(1, 0)),
          possible_moves_direction(p, os, mk_(-1, 0)),
          possible_moves_direction(p, os, mk_(1, 1)),
          possible_moves_direction(p, os, mk_(-1, -1)),
          possible_moves_direction(p, os, mk_(-1, 1)),
          possible_moves_direction(p, os, mk_(1, -1))}
pre p.type = <queen>;
\end{lstlisting}

\subsection{BoardModule}
The BoardModule (\texttt{BM}) class has the responsibility of defining and updating the state of a chessboard. Furthermore, it determines whether or not the special rule moves are possible.

The first type defined in the BM class is the composite type \texttt{Move}. Initially, \texttt{Move} was modelled as a product type consisting of a \texttt{Piece * Coordinate}\footnote{\texttt{Move} was changed from a product type to a composite type as the intent is clearer when the fields are named compared to referencing them through ''.\#1'' and ''.\#2''.}. This structure made sense up until the point where promotion was implemented since promotion allows for the \texttt{PieceType} to be changed, which could not be captured with the old definition.
Instead, \texttt{Move} was modelled with the attributes \texttt{from\_} and \texttt{to\_} that are both of type \texttt{Piece}. An invariant was placed upon \texttt{Move} that states the following: \texttt{m.from\_.colour = m.to\_.colour and m.from\_.square <> m.to\_.square} \\since a \texttt{Move} cannot change the colour and must update the position of the \texttt{Piece}.

It was then possible to define \texttt{History} as a sequence of \texttt{Move}s. A sequence was chosen since the ordering of the moves matters and there might be duplicates if a player moves a piece back and forth.

A \texttt{BoardState} could then be defined as a \texttt{set1 of Piece}, where a set was chosen since the ordering does not matter and duplicates are not allowed as that would indicate two pieces of the same colour and type being placed on the same square. To restrict two \texttt{Piece}s from sharing a position the following invariant was written: \texttt{forall p1, p2 in set b \& p1 <> p2 => p1.square <> p2.square}.
Finally, a \texttt{Board} type was introduced as a composite type containing a \texttt{BoardState} and a \texttt{History}.

The function \texttt{possible\_moves} is responsible for finding the set of valid moves for a \texttt{Piece} where both the simple- and special movement patterns are considered. The function finds the set of simple type-based moves, the set of stateful special moves, and the set of illegal stateful moves. It then evaluates to the union between the former two with the set difference of the latter. The logic can essentially be boiled down to ``find the entire set of possible moves and remove the impossible ones''. Here a set comprehension is used to convert the \texttt{Coordinate}s from \texttt{simple\_moves} to \texttt{Move}s through the helper function \texttt{piece\_coord\_to\_move}.

\begin{lstlisting}
public possible_moves : Board * PM`Piece -> set of Move
possible_moves (board, piece) == (
  let state_p_moves = stateful_possible_moves(board, piece),
      state_imp_moves = stateful_impossible_moves(board, piece),
      simple_moves = PM`type_based_moves(piece,
          PM`pieces_to_obstacles(board.board_state)) in
          ({piece_coord_to_move(piece, c) | c in set simple_moves} union
              state_p_moves) \ state_imp_moves
)
pre piece in set board.board_state;
\end{lstlisting}

The function \texttt{stateful\_impossible\_moves} yields the \texttt{set of Move} containing \texttt{Move}s that result in the player losing, as the rules of Chess disallow such a move from being performed. Thus it contains the moves that put the player in check and if the player already is in check it filters out moves that do not put them out of check.
Furthermore, if the \texttt{PieceType} is \texttt{<pawn>} and promotion is possible then it also contains the \texttt{Move} where the pawn moves to a square on the last rank without changing the \texttt{PieceType}, as it is illegal to not promote the \texttt{Piece}.

\texttt{stateful\_possible\_moves} is a dispatcher that considers the special rules of the pieces, i.e., castling, promotion, en passant and the option for a pawn to move two squares on its first move.

\begin{lstlisting}
stateful_possible_moves: Board * PM`Piece -> set of Move
stateful_possible_moves(board, piece) == (
  cases piece.type:
      <pawn> -> dunion {
          pawn_move_two(board.board_state, piece),
          en_passant(board, piece),
          pawn_promotion(board.board_state, piece)},
      <king> -> castling_possible(board, piece),
      others -> {}
  end
);
\end{lstlisting}

An example of how a special move can be implemented is seen in the snippet below where promotion is modelled. First, the local definitions \texttt{last\_y} and \texttt{promotable} \texttt{\_types} are defined. A set containing the \texttt{promotion\_squares} is constructed, which is simply the set containing the \texttt{Coordinate}s that the pawn could normally move to that are also placed on the last rank. The polymorphic helper function \texttt{sets\_combine\_} \texttt{tuple} is finally used to generate a set of tuples with combinations of \texttt{promotable\_types} and \texttt{promotion\_squares}, which can be used to return the set of promotion \texttt{Move}s.

\begin{lstlisting}
pawn_promotion: BoardState * PM`Piece -> set of Move
pawn_promotion(board_state, pawn) == (
    let last_y = if pawn.color = <white> then 8 else 1,
        promotable_types = {<knight>, <bishop>, <rook>, <queen>} in
        let promotion_squares = {coord | coord in set
          PM`type_based_moves(pawn, PM`pieces_to_obstacles(board_state))
            & coord.y = last_y} in
            {mk_Move(pawn, mk_PM`Piece(t_c_tuple.#1, t_c_tuple.#2, pawn.color)) |
              t_c_tuple in set sets_combine_tuple[PM`PieceType, PM`Coordinate]
              (promotable_types, promotion_squares)}
)
pre pawn.type = <pawn> and pawn in set board_state;
\end{lstlisting}

So far the functions have focused on how the valid moves could be determined. Performing a move is done similarly through the function \texttt{move} where it is necessary to have different behaviour for castling and en passant as the former changes the \texttt{PieceType} and the latter captures a \texttt{Piece} without moving to the square. The other types of moves can be modelled through \texttt{move\_other}. The precondition specifies that the \texttt{Move} must be valid and the postcondition specifies that the returned \texttt{Board} has a different \texttt{BoardState} and a longer \texttt{History}.

\begin{lstlisting}
public move: Board * Move -> Board
move(board, mov) == 
  if mov.from_.type = <king> and iss_castling(board, mov) 
  then move_castling(board, mov)
  elseif (mov.from_.type = <pawn> and iss_en_passant(board, mov)) 
  then move_en_passant(board, mov)
  else move_other(board, mov)
pre mov in set possible_moves(board, mov.from_)
  and mov.from_ in set board.board_state
post len board.history < len RESULT.history
  and board.board_state <> RESULT.board_state;
\end{lstlisting}

The definition of \texttt{move\_other} is seen below. First, the potentially captured piece is found which is defined in the local definition \texttt{dead\_piece}. Due to the invariant on \texttt{BoardState} it is guaranteed to contain a single \texttt{Piece} or be the empty set. The new \texttt{BoardState} can then be defined in \texttt{new\_state} as the previous state without the \texttt{dead\_piece} and with an updated version of the moved \texttt{Piece}. Finally, the new \texttt{Board} is returned.

\begin{lstlisting}
move_other: Board * Move -> Board
move_other(board, mov) == (
  let dead_piece = {p | p in set board.board_state & p.square = mov.to_.square} in
      let new_state = (board.board_state \
        (dead_piece union {mov.from_})) union {mov.to_} in
          mk_Board(new_state, [mov] ^ board.history)
)
pre pre_move(board, mov)
post post_move(board, mov, RESULT);
\end{lstlisting}

Additionally, a helper function \texttt{default\_board} can be made that defines a board with the initial position as seen in \cref{fig:coremodel:board_initial} and an empty \texttt{History}. This is used as the starting point for new games.

\begin{lstlisting}
public default_board : () -> Board
default_board() ==
(
    let board_state : BoardState = dunion {
      {mk_PM`Piece(<pawn>, mk_PM`Coordinate(x, 2), <white>) | x in set {1,...,8}},
      {mk_PM`Piece(<pawn>, mk_PM`Coordinate(x, 7), <black>) | x in set {1,...,8}}
      -- Repeat for other PieceTypes
    } in
        mk_Board(board_state, [])
);
\end{lstlisting}

\subsection{GameModule}
The GameModule (\texttt{GM}) class has the responsibility of controlling who has the current turn and declaring the game-winner. The module defines the optional union of quote types \texttt{Winner} with the values \texttt{[PM`Color | <remis>]} where \texttt{nil} indicates that the game is ongoing. Furthermore, the module defines the composite type \texttt{Game} which contains a \texttt{Board} and a \texttt{PM`Color} indicating the turn.

The function \texttt{move} is used to perform a \texttt{Move} on the \texttt{Board} and potentially determine the winner. First, the \texttt{Move} is performed through \texttt{BM`move} and saved in the local definition \texttt{new\_board}. Then it is checked whether the opponent has any valid \texttt{Move}s for the next turn. If not then the \texttt{Game} is either won by the player or ended in remis, depending on whether the opponent is in check.

\begin{lstlisting}
public move : Game * BM`Move -> (Game * Winner)
move(game, mov) == (
  let new_board = BM`move(game.board, mov),
    opposite_c = PM`opposite_color(game.turn) in
    if forall p in set new_board.board_state &
      p.color = opposite_c => BM`possible_moves(new_board, p) = {} then
      if BM`in_check(new_board.board_state, opposite_c) then
        mk_(game, game.turn)
      else
        mk_(game, <remis>)
    else
      mk_(mk_Game(new_board, opposite_c), nil)
)
pre mov.from.color = game.turn and
  mov in set BM`possible_moves(game.board, mov.from)
post len game.board.history < len RESULT.#1.board.history
    and game.board.board_state <> RESULT.#1.board.board_state;
\end{lstlisting}

\subsection{Runner}
The last part of the model consists of a class, \texttt{Runner}, that reads the contents of a PGN file (\cref{sec:PGN}), converts it to \texttt{Move}s through the PGN module, and iteratively performs the moves.

From a \texttt{Runner} perspective it could also potentially be interesting to create a graphical rendering of the Chess board itself. This could potentially be achieved using either VDMPad \cite{Oda&15a} or ViennaTalk \cite{Oda&16a}. In an Overture context this kind of visualisation was also enabled when it was based on Eclipse but this has not yet been fully incorporated in the VSC version \cite{Nielsen&12}.