\section{Alternative Paradigms for Modelling the Game of Chess}
\label{sec:paradigms}
%\fbox{1 page}

The different VDM dialects generally encourage following a Functional Paradigm (FP), but the VDM++ dialect introduces the possibility of using Object-Oriented Paradigm (OOP) for structuring the models. In an OOP setting, there is typically a need to have instance variables inside classes to represent state, and to access and adjust these there is typically a need for operations that need to use the imperative paradigm with assignments to such instance variables. The question of whether or not to use such features arise.

When determining a paradigm to follow, one must consider if it is easier to encapsulate the moving parts or to minimise them. In the case of the game of Chess both OOP and FP paradigms may look appealing as many of the rules of chess generally are stateless and therefore without moving parts. However, the special rules in particular introduce statefulness to the game. This includes example moves such as en passant and castling, where the validity of the moves depends on previous moves.

\subsection{Considering the Functional and Object-Oriented Paradigms}

Two architectures following OOP and FP were considered. The first follows a typical OOP structure with a base class \texttt{Piece} that defines basic methods for determining possible moves. Each piece type then has a subclass implementation defining its unique movement pattern and potential attributes. The special moves would be modelled through \texttt{Board\`{}possible\_moves} as the \texttt{Board} class knows the state of the game. A simplified class diagram of such an architecture can be seen in \cref{fig:par:op_arch}.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.5\textwidth]{figs/arch_general_oop.pdf}
    \caption{UML class diagram of the basis for an object-oriented architecture for chess.}
    \label{fig:par:op_arch}
\end{figure}

The second architecture was written following the FP where only immutable variables were used. In VDM++ this meant defining all data structures as composite types. The benefit of this is that one only has values in the specification which means that the model is stateless. When writing VDM++ in a functional style, one should consider the classes as modules that encapsulate functionalities together in a namespace (it would thus look more like a VDM-SL model but we have kept it as a VDM++ model in order to ease the comparison). An example of such an architecture can be seen in \cref{fig:par:fp_arch}. In this architecture, all pieces share a common data structure containing their colour, position and type. 

\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.5\textwidth]{figs/arch_general_fp.pdf}
    \caption{UML class diagram of the basis for a functional-style architecture for Chess.}
    \label{fig:par:fp_arch}
\end{figure}

One benefit of following the FP architecture relates to reasoning about the model. Generally speaking, it can be more difficult to reason about imperative models as their functionality may depend on a global model state. In order to formally verify the behaviour of a function inside an imperative model, one must consider all the methods that can also manipulate the global state. In contrast, a purely functional model consists of referentially transparent functions. 

Another benefit relates to testing and verification of the model. When states are introduced to a model the complexity increases significantly as there are more moving parts and thereby more test combinations to be written if the model is to be tested exhaustively. In practice, this means that a model following the FP requires fewer tests to be written as one does not need to consider all the states the model may appear in.

However, modelling Chess through an FP architecture also has some limitations, in particular related to the stateful aspects of the game e.g., when modelling castling one needs knowledge of whether the involved king and rook have moved. To determine this with FP one must know the previous moves made in the game and determine if the pieces were involved. With OOP one can simply introduce a boolean attribute on the rooks and kings indicating whether they have moved. While this is also possible following the FP, it implicates all the pieces as inheritance is not available.

At this point, it should be clear that there are benefits to both types of architecture. One should consider whether it is more important to minimise or encapsulate the moving parts when writing the architecture, as this decision may greatly impact the difficulty of the implementation. Finally, one must also consider how exhaustively the model is to be tested as a stateless model should contain less testing combinatorics compared to a stateful model.

An example of how FP can be more elegant than OOP can be found when moving pieces. It is to be assumed that a \texttt{Move} is modelled as a composite type of two \texttt{Piece}s, one indicating which \texttt{Piece} is being moved and the other indicating where it is moved to\footnote{The latter must be a \texttt{Piece} over a \texttt{Coordinate} to account for promotion.}, and that the \texttt{BoardState} is a \texttt{set of Piece}s.
In the OOP case, one would need to find the \texttt{Piece} in the current \texttt{BoardState} with similar attributes as \texttt{Move.from\_}, check if a \texttt{Piece} is occupying the same square as \texttt{Move.to\_}, potentially remove that \texttt{Piece}, and update the found \texttt{Piece} to match the new \texttt{Coordinate}. In the case of promotion, one would need to add a new \texttt{Piece} of the promoted type and remove the original.
When following FP one can simply update the \texttt{BoardState} by filtering out the \texttt{Piece}s with the \texttt{Coordinate}s in the \texttt{Move} and making a union with \texttt{Move.to\_}.

\subsection{Invariants on Compound Types in VDM++}

During the early stages of development where the OOP architecture was used, an issue within the VDM tool ``VDMJ'' \cite{Battle09} lead to an interesting discussion, that at its core relates to the choice of paradigm. The issue relates to the model snippet seen below where a \texttt{Piece} is moved on to a given \texttt{Coordinate}. The operation updates the state of the \texttt{Board} by first removing the captured \texttt{Piece} and then updating the position of the moved \texttt{Piece}. Since class instances are reference types in VDM++ the latter can be done through the assignment operator directly on the \texttt{Piece} as the \texttt{board\_state} has a reference to the instance. The \texttt{board\_state} is a \texttt{set of Piece} with an invariant stating that the positions of the \texttt{Piece}s inside the set must be unique.

\begin{lstlisting}
public move: Piece * Piece`Coordinate ==> ()
move(piece, coord) == (
    let current_coords = state_to_coords_set(board_state) in
        if coord in set current_coords then
            let dead_piece = {p | p in set board_state & p.position = coord} in
                board_state := board_state \ dead_piece;
    piece.position := coord
)
pre piece in set board_state and dead_piece in set board_state;
\end{lstlisting}

The logic of the model seemed sound but in practice, the interpreter would report an invariant violation when a \texttt{Piece} was captured. When debugging the operation it was shown that the invariant was correctly checked when updating the position of the \texttt{Piece}, but it was checked against an old \texttt{board\_state} still containing the \texttt{dead\_piece}, which caused the invariant to be violated.
In short, the issue was caused by an ``invariant listener'' on the \texttt{piece} object that was not correctly updated when the \texttt{board\_state} was modified\footnote{A link to the issue can be found here:\\\url{https://github.com/overturetool/vdm-vscode/issues/197}}. While the exact issue is not a concern of this paper, the complexity of having invariants on compound types containing references is an interesting topic that showcases some of the issues mutability brings. 

Since VDM++ objects are references they bring aliasing to the language, i.e., an object like \texttt{piece} can be accessed and modified in several places in the specification. If such an object reference is also a member of a compound type instance with an invariant, e.g., \texttt{board\_state}, the invariant for the compound type must be checked whenever the object is modified. The invariant must also be checked when the compound type instance itself is modified.
Furthermore, an object like \texttt{piece} could potentially be placed in multiple instances of different compound types with different invariants, which would mean modifying \texttt{piece} would result in several invariants being checked. In the case of Chess this might not be an issue as the data structures are relatively flat but in complex industrial cases it may not be the case. The reason for this issue showing up is that in order to make the VDM interpreter efficient while still ensuring that invariants are not violated it only tests the invariants whenever changes are made where the invariants are used. In order for this to work in the presence of aliasing this essentially requires checking the transitive closure of instances connected. This is obviously not efficient so the VDM interpreter ignores such invariants going across instances and thus this is a challenge for the OOP model presented here. 

Had the specification been written using immutable datatypes like composite types, the invariant issue would not have been a concern, as the \texttt{BoardState} would then be a set containing immutable values instead of references. This means that the invariant would only need to be checked when the \texttt{board\_state} was changed (or following an entirely FP, when a new \texttt{BoardState} was created).

While the writer of a specification should not typically concern themselves with the details of the tools, we believe this example makes a strong argument of why following the OOP may introduce unnecessary complexity to a specification. If one was to reason about a specification following the OOP with an instance of a compound type, one would need to consider all the places where the instance was modified but also all the places where the members of the instance could be modified. All of this is without considering more complex OOP concepts such as inheritance that only strengthens the point.

