\documentclass[twoside,11pt]{article}

% Any additional packages needed should be included after jmlr2e.
% Note that jmlr2e.sty includes epsfig, amssymb, natbib and graphicx,
% and defines many common macros, such as 'proof' and 'example'.
%
% It also sets the bibliographystyle to plainnat; for more information on
% natbib citation styles, see the natbib documentation, a copy of which
% is archived at http://www.jmlr.org/format/natbib.pdf

% Available options for package jmlr2e are:
%
%   - abbrvbib : use abbrvnat for the bibliography style
%   - nohyperref : do not load the hyperref package
%   - preprint : remove JMLR specific information from the template,
%         useful for example for posting to preprint servers.
%
% Example of using the package with custom options:
%
% \usepackage[abbrvbib, preprint]{jmlr2e}

%\usepackage{jmlr2e}
\usepackage{jmlr_to_arxiv}

% Definitions of handy macros can go here

\newcommand{\dataset}{{\cal D}}
\newcommand{\fracpartial}[2]{\frac{\partial #1}{\partial  #2}}

\usepackage{hyperref}       % hyperlinks
\hypersetup{hidelinks}
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{csquotes}

%\usepackage{amsthm}
\usepackage{paralist, amsmath, amssymb, graphicx}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{mathtools}
\usepackage{nccmath}
\usepackage{xcolor}

\usepackage{nicefrac}
\usepackage{stmaryrd}
\usepackage{bm}
\usepackage{cancel}
\usepackage{multirow}

\usepackage{xfrac}
\usepackage{mathrsfs}%fancy fonts like mscr
\usepackage{amscd}%simple commutative diagrams
\usepackage{dsfont}
\usepackage{tikz}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{enumerate}
\usepackage{bm}
\usepackage{chngcntr} 
\usepackage{makecell}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage[colorinlistoftodos]{todonotes}

%\usepackage{algcompatible}
%\usepackage[noend]{algpseudocode}

%% to cite the supplement 
%\usepackage{xr}
%% \externaldocument{supplement}
%
%% the following are just for overleaf 
%\makeatletter
%\newcommand*{\addFileDependency}[1]{% argument=file name and extension
%  \typeout{(#1)}
%  \@addtofilelist{#1}
%  \IfFileExists{#1}{}{\typeout{No file #1.}}
%}
%\makeatother
%\newcommand*{\myexternaldocument}[1]{%
%    \externaldocument{#1}%
%    \addFileDependency{#1.tex}%
%    \addFileDependency{#1.aux}%
%}
%\myexternaldocument{supplement}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  New commands and shortcuts
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\newcommand{\mscr}[1]{\mathcal{#1}}
\newcommand{\mfrk}[1]{\mathfrak{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\twid}[1]{\widetilde{#1}}

\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\HH}{\mathbb H}
\newcommand{\YY}{\mathbb Y}
\newcommand{\XX}{\mathbb X}
\newcommand{\LL}{\mathbb L}
\newcommand{\WW}{\mathbb W}

\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\epsilon}
\newcommand{\ta}{\theta}
\newcommand{\Ta}{\Theta}
\newcommand{\la}{\lambda}
\newcommand{\sa}{\sigma}
\newcommand{\sas}{\sigma^2}
\newcommand{\data}[2]{#1_1,\ldots,#1_{#2}}
\newcommand{\De}{\Delta}
\newcommand{\xx}{\textbf{x}}
\renewcommand{\l}{\left}
\renewcommand{\r}{\right}

\newcommand{\ulx}{\ul x}
\newcommand{\olx} {\ol x}

\newcommand{\ol}{\overline}
\newcommand{\ul}{\underline}
\newcommand{\ds}{\displaystyle}
\renewcommand{\ni}{\noindent}
\newcommand{\del}{\setminus}
\newcommand{\deriv}[1]{\frac{\partial}{\partial #1}}
\newcommand{\inner}[2]{\langle #1,#2\rangle}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\normbig}[1]{\big\lVert#1\big\rVert}
%\newcommand{\comment}[1]{\%\%\%  #1\\}
\newcommand{\abs}[1]{\l|#1\r|}

\newcommand{\red}{\color{red}}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Math operators
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\newcommand{\ONE}{\mathds{1}}
\DeclareMathOperator{\rk}{rk}
\DeclareMathOperator{\nul}{null}
\newcommand{\orient}[1]{\overleftrightarrow #1}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\iid}{\overset{\text{iid}}{\sim}}
\newcommand{\Id}{\textrm{Id}}
\newcommand{\blank}{\phantom{i}}
\newcommand{\farg}{(\cdot)}
\newcommand{\given}{\phantom{i} \mid \phantom{i}}

\DeclareMathOperator{\one}{\textbf{1}}
\DeclareMathOperator{\lub}{lub}
\DeclareMathOperator{\glb}{glb}
\DeclareMathOperator{\cov}{Cov}
\DeclareMathOperator{\corr}{Corr}
\DeclareMathOperator{\var}{Var}
\DeclareMathOperator{\ee}{\textrm{e}}
\DeclareMathOperator{\vv}{\textrm{v}}
\DeclareMathOperator{\comp}{\textrm{c}}
\newcommand{\surj}{\textrm{surj}}
\DeclareMathOperator{\prox}{prox}
\DeclareMathOperator{\vect}{vec}
\DeclareMathOperator{\sign}{sign}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% Theorems and Definitions 
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

% \theoremstyle{plain}
% \newtheorem{thm}{Theorem}[section] % reset theorem numbering for each section
% \newtheorem{lem}[thm]{Lemma}
% \newtheorem{prop}[thm]{Proposition}
% \newtheorem{cor}[thm]{Corollary}
% \newtheorem{lemma}[thm]{Lemma}
%\theoremstyle{plain}
%\newtheorem{theorem}{Theorem}
%\newtheorem{prop}{Proposition}
%\newtheorem{example}{Example}
%\newtheorem{definition}{Definition}



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% Heading arguments
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

% Heading arguments are {volume}{year}{pages}{date submitted}{date published}{paper id}{author-full-names}

\jmlrheading{1}{x}{1-48}{4/00}{10/00}{xxx}{xxx xxx}

% Short headings should be running head and authors last names

\ShortHeadings{FAStEN}{Boschi et al.}
\firstpageno{1}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  BEGIN DOCUMENT 
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\begin{document}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Title 
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\title{FAStEN: an efficient adaptive method for feature selection and estimation in high-dimensional functional regressions}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Authors 
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\author{\name Tobia Boschi \email tobia.boschi@ibm.com \\
       \addr Department of Statistics, Penn State University\\
       \addr IBM Research Europe, Dublin
       \AND
       \name Lorenzo Testa \email l.testa@sssup.it \\
       \addr  EMbeDS, Sant'Anna School of Advanced Studies 
       \AND 
       \name Francesca Chiaromonte \email fxc11@psu.edu \\
       \addr Department of Statistics, Penn State University\\
       \addr EMbeDS, Sant'Anna School of Advanced Studies
       \AND
       \name Matthew Reimherr \email mlr36@psu.edu \\
       \addr Department of Statistics, Penn State University\\
       \addr Amazon Research
       }

\editor{xxxx}

\maketitle

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Abstract
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\begin{abstract}%   <- trailing '%' for backward compatibility of .sty file
Functional regression analysis is an established tool 
%an active and research topic with a growing impact in
for many contemporary scientific applications. Regression problems involving large and complex data sets are ubiquitous, and feature selection is crucial for avoiding overfitting and achieving accurate predictions. We propose a new, flexible and ultra-efficient approach to perform feature selection in a sparse high dimensional function-on-function regression problem, and we show how to extend it to the scalar-on-function framework.
% and concurrent regression frameworks. 
Our method combines functional data, optimization, and machine learning techniques to perform feature selection and parameter estimation simultaneously. We exploit the properties of Functional Principal Components and the sparsity inherent to the Dual Augmented Lagrangian problem to significantly reduce
%the 
computational cost,
%significantly, 
and we introduce an adaptive scheme to improve 
%the 
selection accuracy.
Through an extensive simulation study, we benchmark our approach to the best existing competitors and demonstrate a massive gain in terms of CPU time and selection performance, without sacrificing the quality of the coefficients' estimation. Finally, we present an application to brain fMRI data from the AOMIC PIOP1 study.
\end{abstract}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Keywords
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\begin{keywords}
  {Functional Data Analysis, Regression, Optimization, Dual Augmented Lagrangian, Feature Selection, Ultra-high dimension}
\end{keywords}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  Introduction
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{Introduction}
\label{sec:intro}

In contemporary scientific applications, high-dimensional regressions are often handled by imposing sparsity constraints, motivated by the assumption that the explanation of complex phenomena is often reducible to a small number of underlying ``active'' features. In this framework, feature selection methods have a crucial role in 
% accurately 
pinpointing such features. Among many approaches to feature selection, the most famous and broadly used is the LASSO \citep{tibshirani1996regression}. 
% \textcolor{red}{[maybe add back a couple of phrases and references to elastic net, group lasso, adaptive lasso? These are critical for our developments]}
The LASSO induces sparsity by adding an $l_1$ regularization constraint to the least squares loss function and has proven effective in a variety of scenarios. However, in situations where features exhibit strong linear associations the LASSO may fail to produce statistically consistent selections \citep{zhao2006model}. 
To deal with such scenarios, extensions have been proposed, such as the Elastic Net \citep{zou2005regularization}, which combines the LASSO $l_1$ regularization with a Ridge $l_2$ regularization. Moreover, in cases where prior knowledge exists on a group structure among the features, such structure can be exploited through a group penalty \citep{yuan2006model}. 

Functional data analysis (FDA) is a different, perhaps less well known but fast growing field of statistics that deals with structured data in the form of curves and surfaces. The integration between feature selection methods and FDA has received increasing attention in recent years, due to the growing availability of data sets comprising large numbers of functional objects. Indeed, \cite{matsui2011variable, fan2015functional}
% \cite{gertheiss2013variable} 
study feature selection in scalar-on-function regression settings, where the response is a scalar and the features are functional.
%; 
\cite{chen2016variable, fan2016high, barber2017function, parodi2018simultaneous}
%, 
study the function-on-scalar case, where the response is functional and the features are scalars.
Notably, less attention has been paid to the more complex case of function-on-function regression \citep{qi2018function, wang2020sparse, centofanti2022smooth}, despite the fact that this type of regression has immediate and important applications in several scientific domains -- from ecology \citep{luo2021restricted}, to epidemiology \citep{boschi2021functional}, to the neurosciences \citep{qi2018function}. The function-on-function feature selection problem is computationally intricate, as it deals with data whose nature is over a continuum and does not assume any lag structure on the relationship between features and response (thus, each regression coefficient is a surface). However, by exploiting recent advances in optimization, we extend
%the
%our
state-of-the-art 
%method 
methodology for feature selection in function-on-scalar regressions \citep{boschi2021highly} 
%as 
to tackle the function-on-function case, even in high- and ultra high-dimensional settings. 
The function-on-function regression model with $n$ observations and $p$ features takes the form \citep{ramsay2005, kokoszka2017introduction}:
%
\begin{align}
\small
\begin{split}
\label{eq:fof_problem}
    \mathcal{Y}_i(t) = \sum_{j=1}^p\int_\mathcal{S}\mathcal{B}_j(t,s)\mathcal{X}_{ij}(s)ds + \epsilon_i(t) \qquad i = 1, \dots, n
\end{split}
\end{align}
%
where the $\mathcal{Y}_i$ are centered functional responses 
%(i.e. $n^{-1}\sum_{i=1}^n\mathcal{Y}_i(t)=0$)
(with $0$ mean function), the $\mathcal{X}_{ij}$ are standardized functional features 
%(i.e.~they have zero mean function and unit variance operator)
(with $0$ mean function and standard deviaxtion equal to 1), the $\mathcal{B}_j$ are 
%the 
coefficient surfaces to be estimated, and the $\epsilon_i$ are i.i.d.
% ~Gaussian 
~errors, independent of the $\mathcal{X}$'s, with $0$ mean function and a common variance operator.

Let $\mathcal T = [a,b]$ and $\mathcal S = [a',b']$ be two closed bounded intervals. 
% Let $\mathcal T$ be a closed sub-space of $\mathbb{L}^2([a,b])$ and $\mathcal S$ a closed sub-space of $\mathbb{L}^2([a',b'])$. 
We assume that $\mathcal{Y}_i \in \mathbb{L}^2(\mathcal T)$, $\mathcal X_{ij} \in
%\mathcal \mathbb{L}^2(\mathcal S)
\mathbb{L}^2(\mathcal S)$, 
and $\mathcal{B}_j \in \mathbb{L}^2(\mathcal T) \times \mathbb{L}^2(\mathcal S)$. Without loss of generality, we consider $\mathcal T$ = $\mathcal S$ = $[0,1]$.
We use the notation $\mathcal{Y} = \left[\mathcal{Y}_1 ~ | ~ \dots ~ | ~ \mathcal{Y}_n \right]^T$ to indicate the set of 
%the 
$n$ 
%functional responses 
response curves and $\mathcal{X}_j = \left[\mathcal{X}_{1j} ~ | ~ \dots ~ | ~ \mathcal{X}_{nj} \right]^T$ to indicate the set of $n$ curves of the $j$-th feature. Similarly, we define $\mathcal{B}_j\mathcal{X}_j = \left[\mathcal{B}_j\mathcal{X}_{1j} ~ | ~ \dots ~ | ~ \mathcal{B}_j\mathcal{X}_{nj} \right]^T$.

In this paper, we propose a novel
%methodology to solve a 
method to perform feature selection for %\ref{eq:fof_problem}
(\ref{eq:fof_problem}), which we call Functional Adaptive feature SelecTion with Elastic Net 
%kind 
penalty (\texttt{FAStEN}).
For a generic function $f \in \mathbb L^2(\mathcal{T})$ and surface $g \in \mathbb L^2(\mathcal{T}) \times \mathbb L^2(\mathcal{S})$, let us define the squared $\mathbb{L}^2$-norms as
$\lVert f\rVert_{\mathbb{L}^2}^2= \langle f, f\rangle_{\mathbb{L}^2} = \int_\mathcal{T} f^2$ and 
$\lVert g\rVert_{\mathbb{L}^2 \times \mathbb{L}^2}^2= \langle g, g\rangle_{\mathbb{L}^2 \times \mathbb{L}^2} = \int_\mathcal{S}\int_\mathcal{T} g^2$, respectively. Then, the \texttt{FAStEN} optimization problem is given by
%:
%
\begin{align}
\small
\begin{split}
    % \small
    \label{eq:functional_minimization_problem}
    \min_{\mathcal{B}_1, \dots, \mathcal{B}_p} ~ \Bigg[ 
    \frac{1}{2} \Big\lVert~\mathcal{Y}-\sum_{j=1}^p\int_\mathcal{S}\mathcal{B}_j(t,s)\mathcal{X}_j(s)ds~\Big\rVert_{\mathbb{L}^2}^2 +
    \sum_{j=1}^{p} \omega_j \left(
     \lambda_1 \lVert \mathcal{B}_j\rVert_{\mathbb{L}^2 \times \mathbb{L}^2}+ 
     \frac{\lambda_2}{2}\lVert \mathcal{B}_j \rVert_{\mathbb{L}^2 \times \mathbb{L}^2}^2 
    \right)  \Bigg]
\end{split}
\end{align}
%
%where 
with two different penalties
%are 
added to the least squares loss. 
%The 
% positive 
Here, the 
parameters $\lambda_1$ and $\lambda_2$ control the importance of the 
%two 
penalties with respect to the least squares loss,
%. The 
and the weights $\omega_j$ extend the \textit{adaptive} LASSO \citep{zou2006adaptive} to the function-on-function regression setting, improving selection and estimation of coefficient surfaces.

To solve \eqref{eq:functional_minimization_problem}, first we approximate the functional variables by a matrix representation, then we develop a new, very efficient method to carry out the minimization. 
The matrix representation 
% \cite{ramsay2005} 
is achieved through the \textit{Functional Principal Components} (FPC)  \citep[see e.g.][]{horvath2012inference};
% kokoszka2017introduction
response and features curves are replaced by $k$ FPC scores. 
The minimization is performed through a \emph{Dual Augmented Lagrangian} (DAL) algorithm 
which exploits the sparsity of the problem and the sparsity induced by the \emph{Hessian matrix} information to greatly reduce computational cost.
% {\red -- which depends just on the number of non-zeros features, and not on the total number of features $p$.} 
% DAL was first introduced by \cite{tomioka2009dual, li2018} to solve the regular LASSO. \cite{boschi2021functional} presented a version of DAL to solve the Group Elastic Net and tackle the function-on-scalar case.
DAL was first introduced by \cite{tomioka2009dual, li2018} to solve the LASSO problem and by \cite{tomioka2011super, boschi2020efficient} to solve the 
%Elastic-Net 
Elastic Net problem. \cite{boschi2021highly} presented a version of DAL to solve the Group Elastic Net problem and perform
%tackle the 
feature selection in function-on-scalar regressions.
%case.
In the main text of this paper, we introduce a new adaptive version of DAL to 
%solve the 
perform feature selection in function-on-function 
%feature selection problem 
regressions -- which requires that we carefully 
%adapt 
modify and expand a set of mathematical operators to deal with a larger and more complex optimization. 
In the Appendix, we also provide details on how to implement DAL in the \emph{scalar-on-function} framework.
% and the \emph{concurrent regression} frameworks 
\citep[see e.g.][]{kokoszka2017introduction}.
% ramsay2005
%frameworks. 
%This work, 
The work presented here, together with \cite{boschi2021highly}, outlines a novel and highly efficient 
%methodology to perform 
feature selection methodology applicable to
%in 
all the most common functional regression settings.   

We implement an efficient version of \texttt{FAStEN}, written in \texttt{python}, and benchmark it against \texttt{FRegSigCom} \citep{qi2018function}, written in \texttt{R} with backend in \texttt{C++}.
%(since 
Since 
%the 
function-on-function feature selection 
%problem 
has not yet been intensively studied, this was the only existing method with publicly available code we were able to identify.
%). 
Our simulations demonstrate that \texttt{FAStEN} is at least three orders of magnitude faster and more accurate in terms of false positives than \texttt{FRegSigCom}, while possessing similar accuracy in terms of coefficient estimation and out-of-sample prediction error.
%while possessing similar equivalent accuracy in terms of coefficient estimation. 
We also apply \texttt{FAStEN} to data from the Amsterdam Open MRI Collection (AOMIC) PIOP1 study \citep{snoek2021amsterdam}, which investigates activation of brain voxels in response to external stimuli. Specifically, we examine the association between the activation functions of tens of thousands of brain voxels and heart rate variability functions 
%of 
recorded on the study subjects
%. measured 
while dealing with the external stimuli of the so-called anticipation task.
% 

The remainder of the paper is organized as follows. In Section \ref{sec:method}, we describe how to approximate the functional optimization problem via FPCs and how to solve it with our DAL-based approach. In Section \ref{sec:sim_and_application}, we illustrate the performance of our proposal through an extensive simulation study and we apply \texttt{FAStEN} to the AOMIC PIOP1 data. Finally, in Section \ref{sec:conclusion}, we provide final remarks and discuss future developments. 
%Proofs and extensions of theoretical results, additional simulation results and additional analyses concerning the AOMIC PIOP1 application can be found in the Appendix Material. 
Complete \texttt{FAStEN} code is available on \texttt{GitHub} at: \href{https://github.com/tobiaboschi/FASTEN}{\texttt{https://github.com/tobiaboschi/FASTEN}}.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  Methodology
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\section{Methodology}
\label{sec:method}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Coefficients representations
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Matrix representation through Functional Principal Components}
\label{subsec:coeff_representation}

One of the most common methods to work with model \eqref{eq:fof_problem}
is to use a matrix representation obtained expressing functional variables as linear combinations of basis functions \citep{ramsay2005, horvath2012inference, beyaztas2020function}. 
Even if the design of \texttt{FAStEN} allows one to work with different basis for the $\mathcal X's$ and the $\mathcal Y$, in our applications, we represent all the functional variables using the first $k$ FPCs of the response $\mathcal Y$. 
Thus, unlike the standard FPC regression \citep{reiss2007functional} -- where each functional feature $\mathcal X_j$ is represented according to its own principal components -- we use the FPC of $\mathcal Y$ to express all the features. 
% As we will see in Section~\ref{sec:sim_and_application}, using the basis expansion, which captures the most significant modes of the response variability, allows us to boost the importance of the features most related to the response itself.  
%
%The following proposition shows how one can use the FPCs of $\mathcal Y(t)$ in order to obtain a matrix representation of Equation \eqref{eq:functional_minimization_problem}.
%% 
%\begin{proposition}
%Let $e(t) = \left[e_1(t) ~ | ~ \dots ~ | ~ e_k(t) \right]$ be the matrix containing the first $k$ FPCs of $\mathcal Y(t)$, and $Y \in \mathbb{R}^{n \times k}$ be the matrix of the scores of $\mathcal Y(t)$ with respect to $e(t)$, i.e. $Y_{ij} = \langle \mathcal Y_i, e_j \rangle_{\mathbb{L}^2}$.
%% 
%Similarly, let $X_{[j]} \in \mathbb{R}^{n \times k}$ and $B_{[j]} \in \mathbb{R}^{k \times k}$ be the matrices restricted to
%the scores of the j-th feature $\mathcal X_j$ and the j-th coefficient surface $\mathcal B_j$ with respect to $e(t)$ and  $e(s)e(t)^T$, respectively, for $j = 1, \dots, p$. 
%In particular, we have $X_{[j](im)} = \langle \mathcal X_{ji}, e_m \rangle_{\mathbb{L}^2}$ and $B_{[j](im)} = \big\langle \langle \mathcal B_j, e_i \rangle_{\mathbb{L}^2}, e_m \big\rangle_{\mathbb{L}^2} = \int\int \mathcal B_j(s, t)e_i(s)e_m(t)~ds~dt$. 
%% 
%Let us define the design matrix containing all the features and the complete coefficient matrix as $X = \left[X_{[1]} | \dots | X_{[p]} \right] \in \mathbb{R}^{n \times pk}$ and $B = \left[B_{[1]} | \dots | B_{[p]} \right]^T \in \mathbb{R}^{pk\times k}$, respectively.
%% $X_{[j]}\in \mathbb{R}^{n \times k}$ and $B_{[j]}\in \mathbb{R}^{k \times k}$ are the matrices restricted to the scores of the $j$-th feature and the $j$-th coefficient surface, respectively. 
%Then, we can express \eqref{eq:functional_minimization_problem} in the following matrix form: 
%%
%\begin{equation}
%\small
%    \label{eq:matrix_minimization_problem}
%    \min_{B} \frac{1}{2}\lVert Y-XB\rVert_{2}^2 + \sum_{j=1}^{p} \omega_j \left( \lambda_1 \lVert B_{[j]}\rVert_{2}+\frac{\lambda_2}{2} \lVert B_{[j]}\rVert_{2}^2 \right) \ .
%\end{equation}
%%
%\end{proposition}
%
 We now show how one can use the FPCs of $\mathcal Y$ in order to obtain a matrix representation of 
 %Equation
 the objective function in \eqref{eq:functional_minimization_problem}. 
 
 First, let us consider the simple case with just one feature, $\mathcal X_1$.
 Let $e = \left[e_1 ~ | ~ \dots ~ | ~ e_k \right]$ be the matrix containing the first $k$ FPCs of $\mathcal Y$, and $Y \in \mathbb{R}^{n \times k}$ be the matrix of the scores of $\mathcal Y$ with respect to $e$, i.e. $Y_{ij} = \langle \mathcal Y_i, e_j \rangle_{\mathbb{L}^2}$. Similarly, let $X_{[1]} \in \mathbb{R}^{n \times k}$ and $B_{[1]} \in \mathbb{R}^{k \times k}$ be the scores matrices of $\mathcal X_1$ and $\mathcal B_1$ with respect to $e$ and  $ee^T$, respectively. 
 In particular, we have $X_{[1](ij)} = \langle \mathcal X_{1i}, e_j \rangle_{\mathbb{L}^2}$ and $B_{[1](ij)} = 
 \langle \mathcal B_1, e_i \otimes  e_j \rangle_{\mathbb{L}^2 \times \mathbb{L}^2} = \int\int \mathcal B_1(s, t)e_i(s)e_j(t)~ds~dt$. 
 Then, we can approximate $\mathcal Y(t) \approx Ye(t)^T, ~ \mathcal X_1(s) \approx X_{[1]}e(s)^T, ~ \mathcal B_1(s, t) \approx e(s)B_{[1]}e(t)^T$ and thus rewrite
 %Equation
 model~\eqref{eq:fof_problem} as
 %:
 %
 \begin{align*}
 \small
 \begin{split}
     Ye(t)^T \approx X_{[1]} \left(\int_{\mathcal{S}} e(s)^Te(s)~ds\right) B_{[1]}e(t)^T \ .
 \end{split}
 \end{align*}
 %
 %Now, multiply 
 Next, we multiply both sides of the equation 
 %for 
 by $e$ and integrate over $t$.
 %Furthermore, note that 
 Since 
 %$e$ is a FPC basis, 
 for an orthonormal basis $\int e(t)^Te(t)dt = I_k$, the identity matrix of order $k$ \citep{kokoszka2017introduction},
 %. This 
 this leads us to
 %: 
 $Y \approx X_{[1]} B_{[1]}$.
 %\\
 The extension to $p$ predictors is straightforward.
 
 Let us 
 %define 
 indicate the design matrix
 %containing all the features and the complete coefficient matrix 
 as $X = \left[X_{[1]} | \dots | X_{[p]} \right] \in \mathbb{R}^{n \times pk}$,
 %and 
 the coefficient matrix as $B = \left[B_{[1]} | \dots | B_{[p]} \right]^T \in \mathbb{R}^{pk\times k}$, and the matrices restricted to the scores of the $j$-th feature and the $j$-th coefficient surface as
 %, respectively. 
 $X_{[j]}\in \mathbb{R}^{n \times k}$ and $B_{[j]}\in \mathbb{R}^{k \times k}$, 
 %are the matrices restricted to the scores of the $j$-th feature and the $j$-th coefficient surface,
 respectively.  
 The function-on-function linear model in \eqref{eq:fof_problem} can be approximated as
 %: 
 $ Y \approx X B $.
 %
 To provide a matrix representation of the objective function in~\eqref{eq:functional_minimization_problem}, we need to relate the ${\mathbb{L}^2}$ functional norm and the standard $l_2$ matrix norm, i.e.~the Frobenius norm -- which we indicate with $\lVert \cdot \rVert_2$. 
 %Since 
 Because $e$ is 
 %an 
 orthonormal,
 %basis, the following equations hold 
 for a generic function $f \in \mathbb L^2([0,1])$ and a generic surface $g \in \mathbb L^2([0,1])\times \mathbb L^2([0,1])$ one has
 %: 
 %
 \begin{align}
 \small
 \begin{split}
 \label{eq:fpca_prop}
     &\lVert f \rVert_{\mathbb{L}^2}^2 = 
     \sum_{i=1}^\infty \langle f, e_i\rangle_{\mathbb{L}^2} \ , \ \ 
     \lVert g \rVert_{\mathbb{L}^2 \times \mathbb{L}^2}^2 = \sum_{i=1}^\infty \sum_{j=1}^\infty  \big\langle \langle g, e_j\rangle_{\mathbb{L}^2}, e_i \big\rangle_{\mathbb{L}^2} \ .
 \end{split}
 \end{align}
 %
 These equations allow us to approximate the ${\mathbb{L}^2}$ functional norm with the $l_2$ Frobenius
 %of 
 norm for both vectors and matrices. 
 We are now ready to express \eqref{eq:functional_minimization_problem} in matrix form as
 %: 
 %
 \begin{equation}
 \small
     \label{eq:matrix_minimization_problem}
     \min_{B} \frac{1}{2}\lVert Y-XB\rVert_{2}^2 + \sum_{j=1}^{p} \omega_j \left( \lambda_1 \lVert B_{[j]}\rVert_{2}+\frac{\lambda_2}{2} \lVert B_{[j]}\rVert_{2}^2 \right) \ .
 \end{equation}
%
Like in an Elastic Net \citep{zou2005regularization}, the optimization combines two penalties; the first is non-differentiable and creates sparsity, and the second (Ridge-like) is differentiable and controls variance inflation due to multicollinearity. 
% The introduction of a Ridge-like term increases the computational efficiency of the algorithm; as we will see in the next sections, the differentiable term 
The introduction of a Ridge-like term leads to differentiable operators which speed up the convergence of the optimization algorithm.
%The aim of
Once an estimate $\hat B$ of the score matrix is obtained from~\eqref{eq:matrix_minimization_problem},
%is to estimate the scores matrix $B$. Given the estimated $\hat B$, 
one can recover the 
%functional 
coefficient surfaces 
%$\mathcal B$ through $e$ as:
as
% 
\begin{equation*}
\small
\label{eq:from_B_to_funB}
\hat{\mathcal B}_j(t,s) = e(t)\hat B_{[j]}e(s)^T \ \ \ j=1,\dots,p \ .
\end{equation*}
% $\hat{\mathcal B}_j(t,s) = e(t)\hat B_{[j]}e(s)^T$ for $j=1,\dots,p$.
% 
The choice of $k$ determines how well problem \eqref{eq:matrix_minimization_problem} approximates problem \eqref{eq:functional_minimization_problem}. 
In many cases, since the FPCs are the most parsimonious orthonormal basis system, just a few components suffice to capture more than 90\% of the ${\mathbb{L}^2}$ norm of the response $\mathcal{Y}$. 
In general, FPCs are a means to control, and appropriately calibrate, the dimension of the problem. On the one hand, a low $k$ may make the approximation too coarse, leading to the loss of important signals and reducing the quality of results. On the other hand, a high $k$ may retain too much noise, leading to less accurate estimated surfaces. 
%
FPCs are also a means to compute integrals more efficiently, as they can be decomposed in sums over the squares of the FPC scores -- see~\eqref{eq:fpca_prop}. %Finally, 
We note that by 
%representing 
choosing to represent features through the 
%response 
FPCs of the response, i.e.~through the modes most relevant to the response variability, we dramatically reduce the computational burden of computing 
%number of FPCs to be calculated (
FPCs, as the feature selection problem comprises one response and a potentially very large number of features.
%), and we introduce 
Moreover, this choice induces a sort of implicit screening,
%procedure (
as features that are not well represented by the response FPCs are less likely to be highly predictive.
%).


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Dual Formulation  
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Dual formulation}
\label{subsec:dual}

Here, we introduce the \emph{dual formulation} of the objective function in~\eqref{eq:matrix_minimization_problem}. 
%Indeed, the 
The core idea behind the DAL is to minimize the \emph{Augmented Lagrangian} function associated to the \emph{dual} problem in order to find 
%the 
its optimal solution.
%of \eqref{eq:matrix_minimization_problem}. 
%
First, notice that \eqref{eq:matrix_minimization_problem} can be written as
%:
%
\begin{equation}
\small
    \label{eq:primal}
    \tag{P}
    \min_B h(XB) + \pi(B)
\end{equation}
%
where 
$h(XB)= \frac{1}{2}\lVert Y-XB\rVert_{2}^2$ 
is the least squares loss function and 
$\pi(B) = \sum_{j=1}^{p} \omega_j 
%\left( 
( \lambda_1 \lVert B_{[j]}\rVert_{2}$
%
$+\frac{\lambda_2}{2} \lVert B_{[j]}\rVert_{2}^2 )
%\right)
$ 
is the adaptive Elastic Net-type penalty. A possible dual formulation of the primal 
% problem 
\eqref{eq:primal} is given by \citep{boyd2004convex}
%:
%
\begin{equation}
\small
    \label{eq:dual}
    \tag{D}
    \min_{V,Z} h^*(V) + \pi^*(Z)\quad s.t.\quad X^TV+Z=0 \ \ 
    %.
\end{equation}
%
%Here 
where $V\in\mathbb{R}^{n\times k}$ and $Z\in\mathbb{R}^{pk\times k}$ are the matrix dual variables. 
%Following 
Using the same notation 
%we use 
introduced for $B$, we can write $Z = \left[Z_{[1]} | \dots | Z_{[p]} \right]^T$, where 
$Z_{[j]}\in \mathbb{R}^{k \times k}$ is the sub-matrix of $Z$ associated with the $j$-th feature. 
$h^*$ and $\pi^*$ are the Fenchel-conjugate functions \citep{fenchel1949conjugate} of $h$ and $p$, respectively. The form of $h^*$ is known in the literature; specifically,  $h^*(V) = \frac{1}{2}\lVert V\rVert_2^2 + \langle Y, V\rangle$ \citep{dunner2016primal}, where $\langle \cdot, \cdot \rangle$ is the Frobenius inner product for matrices. The form of $p^*$ is given in the next Proposition, which extends 
%the work of
results in \cite{boschi2021highly} from the case of vectors to the case of matrices (see Appendix Section \ref{subsec:proof_prop1} for a proof).
%
\begin{proposition}
\label{prop:p_star}
    Given the problem in~\eqref{eq:dual}, the function $\pi^*$ has the form 
    % 
    \begin{align}
    \small
    \begin{split}
    	\label{eq:p_star}
        	\pi^*(Z) = \sum_{j=1}^p \pi^*(Z_{[j]}) = \sum_{j=1}^p (2\omega_j\la_2)^{-1} \left(\big[\norm{Z_{[j]}}_2 - \omega_j\la_1\big]_{+}\right)^2
    \end{split}
    \end{align}
    %
    where $[~\cdot~]_{+}$ is the positive part operator; $[s]_{+} = s$ if $s>0$ and $0$ otherwise. 
\end{proposition}
%
Notably,  $\pi^* : \mathbb{R}^{pk \times k} \rightarrow \mathbb{R}$ is a differentiable and separable function despite the fact that the objective function in~\eqref{eq:matrix_minimization_problem} is not separable. As we will see in Section~\ref{subsec:dal},
%These 
these two properties 
% together 
are crucial for preserving the sparsity structure of the DAL-based optimization.
%as we will see
% in the next section. 
%in Section~\ref{subsec:dal}.

%The 
Primal and dual optimality 
%of the primal and dual problems 
% and the convergence to the optimal solution 
can be investigated 
%by introducing 
through the \textit{Karush-Kuhn-Tucker} (KKT) conditions associated with the dual problem in~\eqref{eq:dual}; namely
%: 
% \citep{boyd2004convex}: 
%
\begin{equation}
\small
    \label{eq:kkt}
    % letterine belle separate come piacciono a Tobia
    %ma ci vogliono le virgole...
    \nabla h^*(V) - XB = 0 
    \ \ , \ \ 
    %\qquad 
    \nabla \pi^*(Z) - B = 0 
    \ \ , \ \ 
    %\qquad 
    X^T V + Z = 0
    \ \ .
\end{equation}
%
It can be shown that the tuple $(V^{opt}, Z^{opt}, B^{opt})$ solves 
%the KKT 
these conditions
%in~\eqref{eq:kkt} 
if and only if $(V^{opt}, Z^{opt})$ is the optimal solution of \eqref{eq:dual}
% the dual problem 
and $B^{opt}$ is the optimal solution of \eqref{eq:primal}
% the primal problem 
\citep{boyd2004convex}. 

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  ADAL method  
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%\subsection{DAL algorithm}
%\label{subsec:dal}

\begin{algorithm}[t!]
\caption{\textbf{DAL Method}}
\label{alg:dal}
\small
\begin{algorithmic}

\vspace{0.2cm}
\STATE \textbf{GOAL:} minimize  $\mathcal{L}_\sigma (V,Z,B)$. Start from the initial values $V^0, Z^0, B^0, \sa^0$ \\

\vspace{0.2cm}
\STATE \texttt{WHILE NOT CONVERGED:}
\begin{itemize}
    
    % \vspace{0.1cm}
    \item[\textbf{(1)}] Given $B^s$, find $V^{s+1}$ and $Z^{s+1}$ which approximately solve:
    \begin{equation}
%		\small
        \label{eq:inner_subproblem}
         	 \big(V^{s+1}, Z^{s+1}\big) \approx \arg \min_{V,Z} \mathcal{L}_\sa \big(V, Z ~|~ B^s\big)
    \end{equation}
    \vspace{-0.5cm}
    
    \fbox{\begin{minipage}{35em}
    
        \vspace{0.2cm}
        ~ ~ \textbf{Inner sub-problem:} to find $(V^{s+1}$, $Z^{s+1})$ update V, Z \emph{independently}: \\
        
        \vspace{-0.1cm}
        ~ ~ \texttt{WHILE NOT CONVERGED}   
        
        \begin{itemize}
            
            \vspace{0.1cm}
            \item[]  $V^{m+1} = \arg\min_V \mathcal{L}_\sigma (V\,|\,Z^m,B^s)~ \longrightarrow~$ 
            {\footnotesize \textbf{Newton method} (Theorem \ref{th:v_update})}
            
            \vspace{0.1cm}
            \item[] $Z^{m+1} = \arg\min_Z \mathcal{L}_\sigma (Z,|\,V^{m+1},B^s)~ \longrightarrow~$ 
            {\footnotesize \textbf{closed form} (Proposition \ref{prop:z_update})}
            \vspace{0.2cm}
        
        \end{itemize}
    
    \end{minipage}}
    
    \vspace{0.1cm}
    \item[\textbf{(2)}] Update the Lagrangian multiplier $B$ and the parameter $\sa$:
    
    \vspace*{-0.1cm}
    \begin{align}
    \label{eq:update_x}
    \begin{split}
                        &B^{s+1} = B^s - \sa_k \big(X^T V^{s+1} + Z^{s+1}\big) \\
                        &\sa^{s+1} \uparrow \sa^{\infty} \le \infty
    \end{split}
    \end{align}
\end{itemize}
\vspace*{-0.4cm}
\end{algorithmic}
\end{algorithm}
%
%
\subsection{DAL algorithm}
\label{subsec:dal}

In this section, we present the \emph{Dual Augmented Lagrangian} (DAL) algorithm, which efficiently solves the optimization problem in \eqref{eq:matrix_minimization_problem}. 
% DAL was first introduced by \cite{tomioka2009dual, li2018} to solve the LASSO problem and by \cite{tomioka2011super, boschi2020efficient} to solve the Elastic-Net problem. \cite{boschi2021highly} implemented DAL for the Group-Elastic-Net and applied it for feature selection in function-on-scalar regression.
% In this paper, we extend DAL to tackle feature selection in all functional regression settings; 
Specifically, we describe here the DAL implementation for function-on-function regression,
%in the main text, 
in Appendix Section 
% \ref{sec:supp_concurrent} and 
\ref{sec:supp_scalar} that for scalar-on-function regression
% and concurrent regressions 
\citep{reiss2017methods}.


We note that the proposed extension 
%proposed here 
targets 
%a new 
an optimization problem
different from those
%; the minimization function in \eqref{eq:matrix_minimization_problem} has not been 
studied in previous literature. In particular, considering functional variables both as response and as predictors
%further 
increases the dimension and the computational complexity of the problem with respect to the function-on-scalar case \citep{boschi2021highly}. We need to carefully redefine all the mathematical operators in larger dimensions and, at the same time, preserve the DAL sparsity structure and computational efficiency. 
Moreover, by incorporating weights (the $\omega$'s) in the objective function in \eqref{eq:matrix_minimization_problem}, we create a novel, \emph{adaptive} version of DAL which improves both selection and estimation performance \citep{zhao2006model, parodi2018simultaneous}, as we will see in 
% our simulation study.
Section \ref{sec:sim_and_application}.

Our implementation, summarized in \textbf{Algorithm \ref{alg:dal}}, minimizes the \textit{Dual Augmented Lagrangian} function
%
\begin{align}
\small
\begin{split}
    \label{eq:augmented_lagrangian}
    \mathcal{L}_\sigma (V,Z,B) =  h^*(V) + \pi^*(Z) - 
     \sum_{j=1}^p \langle B_{[j]}, V^TX_{[j]} + Z_{[j]} \rangle + 
    \frac{\sigma}{2} \sum_{j=1}^p \lVert V^TX_{[j]} + Z_{[j]}\rVert_2^2
\end{split}
\end{align}
%
where $\sigma>0$. $B$ is both the primal variable in 
%problem 
\eqref{eq:primal} and the Lagrangian multiplier in
%Equation
\eqref{eq:augmented_lagrangian}, weighting the importance of a violation of the constraint. 

The core of the algorithm is the routine to solve the inner sub-problem \eqref{eq:inner_subproblem}, while the updates of $B$ and $\sigma$ follow standard optimization rules \citep{li2018}. \cite{tomioka2009dual} show that an approximate solution $(\Bar{V},\Bar{Z})$ of \eqref{eq:inner_subproblem} can be found independently for V and Z, as
%:
%
\begin{equation*}
\small
    \Bar{V} = \arg\min_V \mathcal{L}_\sigma (V\,|\,\Bar{Z},B)
    \ \ , \ \ 
    \Bar{Z} = \arg\min_Z \mathcal{L}_\sigma (Z\,|\,\Bar{V},B)
\end{equation*}
%
where, with a slight abuse of notation, we indicate by $\mathcal{L}_\sigma(V\,|\,Z,B)$ and $\mathcal{L}_\sigma(Z\,|\,V,B)$ the functions obtained from $\mathcal{L}_\sigma(V,Z,B)$ fixing the parameters $Z$ and $B$, or $V$ and $B$, respectively. 

\vspace{0.1in}
\noindent
{\textbf{Z update.}} 
The following proposition extends the findings of \cite{boschi2021highly} on the \emph{proximal operator} \citep{rockafellar1976, rockafellar1976augmented} of $\pi$ and 
%gives 
provides a closed form for $\Bar{Z}$ (see Appendix Section \ref{subsec:proof_prop2} for a proof).
%
\begin{proposition}
\label{prop:z_update}
%Given the penalty function $\pi$ defined in \eqref{eq:primal}:
    %\begin{itemize}
        %\item[(i)] The proximal operator of $\pi(B)$ is: $\prox_{\sigma \pi}(B) = \big(\prox_{\sigma \pi}(B_{[1]}), \dots, \prox_{\sigma \pi}(B_{[p]}) \big)^T$, where   
        %
        %\begin{equation}
        	%\label{eq:prox_op}
		    %\prox_{\sigma \pi}(B_{[j]}) =  (1 + \sa \omega_j \la_2)^{-1} \left[1- \norm{B_{[j]}}_2^{-1} \sa \omega_j \la_1  \right]_{+} B_{[j]}.
	    %\end{equation}
        %
        %\item[(ii)] $ \Bar{Z} = \prox_{\pi^*/\sa} \left(B/\sa - X^T\Bar{V} \right) = B/\sa - X^T\Bar{V} - \prox_{\sa p}\left(B - \sa X^T\Bar{V}\right)/\sa$.
 %   \end{itemize}
    
The proximal operator of the penalty function $\pi(B)$ defined in \eqref{eq:primal} is given by 
$\prox_{\sigma \pi}(B) = \big(\prox_{\sigma \pi}(B_{[1]}), \dots, \prox_{\sigma \pi}(B_{[p]}) \big)^T$, 
where for each $j$  
        %
        \begin{equation}
        \small
        	\label{eq:prox_op}
		    \prox_{\sigma \pi}(B_{[j]}) =  (1 + \sa \omega_j \la_2)^{-1} \left[1- \norm{B_{[j]}}_2^{-1} \sa \omega_j \la_1  \right]_{+} B_{[j]}.
	    \end{equation}
Thus, we have
        $ \Bar{Z} = \prox_{\pi^*/\sa} \left(B/\sa - X^T\Bar{V} \right) = B/\sa - X^T\Bar{V} - \prox_{\sa p}\left(B - \sa X^T\Bar{V}\right)/\sa$.
\end{proposition}
%
Note that $\prox_{\sigma \pi}(B) : \mathbb{R}^{pk \times k} \rightarrow\mathbb{R}^{pk \times k}$. The input argument has a larger dimension than the one in the function-on-scalar case, which deals with ${p \times k}$ matrices.

\vspace{0.1in}
\noindent
{\textbf{V update.}} 
We do not have a closed form for $\bar V$. 
%Thus, 
Therefore, we update $V$ with one step of the classical Newton Method \citep{nocedal1999numerical}. 
If $\psi(V) = \mathcal{L}_\sigma (V\,|\,\Bar{Z},B)$ indicates the function we want to minimize with respect to $V$, the Newton method update has the form 
% $V^{m+1} = V^{j} + D$, 
%
%\begin{equation*}
%\small
%\label{eq:v_update}
    $V^{m+1} = V^{m} + D$,  
%\end{equation*}
%
where $D \in \mathbb{R}^{n \times k}$ is the descent direction computed by solving the linear system
%
\begin{equation}
\small
\label{eq:newton_direction}
    H_{\psi}(V) \vect(D) = -\vect\big(\nabla \psi (V)\big) \ .
\end{equation}
%
Here, $H_{\psi} \in \mathbb R^{nk \times nk}$ is the Hessian matrix, 
$\nabla \psi \in \mathbb R^{n \times k}$ is the gradient matrix, and 
$\vect \big(\nabla \psi \big) \in \mathbb R^{nk}$ is the gradient vector obtained stacking all the columns of $\nabla \psi$ (similarly for $D$ and $\vect(D)$).
The largest computational burden in DAL comes from solving the linear system in \eqref{eq:newton_direction}. 
The following theorem allows us to reduce such burden by greatly reducing the dimension of the system (see Appendix Section \ref{subsec:proof_theorem1} for a proof).
% 
\begin{theorem}
\label{th:v_update}
Let $T=B-\sa X^T V$, $T_{[j]}=B_{[j]} - \sa V^T X_{[j]}$, $\mathcal{J} = \big\{ j~:~ \lVert T_{[j]} \rVert_2  \ge \sa \omega_j \la_1 \big\}$, and $r = |\mathcal{J}|$ be the cardinality of $\mathcal{J}$.
Next, let $ X_\mathcal{J} \in \mathbb{R}^{n \times rk}$ be the sub-matrix of $X$ restricted to the blocks $X_{[j]}$, 
%and  
$j \in \mathcal{J}$, and $\hat X_\mathcal{J} = X_\mathcal{J} \otimes_{Kron} I_k$ be the $nk \times rk^2$ Kronecker product between $X_\mathcal{J}$ and the $k \times k$ identity matrix.
Next, consider the $k^2 \times k^2$ outer product $\hat T_{[j]} = \vect\left(T_{[j]}\right) \otimes_{outer} \vect\left(T_{[j]}\right)$ and define the squared $k^2 \times k^2$ matrix 
    \begin{equation*}
    \small
    \label{eq:P_j}
        P_{[j]} = (1 + \sa \omega_j \la_2)^{-1} \left( \left(1 -
        \frac{\sa \omega_j \la_1}{ \norm{T_{[j]}}_2} \right) I_{k^2} +
        \frac{\sa \omega_j \la_1}{ \norm{T_{[j]}}_2^3} 
        \hat T_{[j]} \right) \ .
    \end{equation*}
Finally, let $Q_\mathcal{J} \in \mathbb{R}^{rk^2 \times rk^2}$ be the block-diagonal matrix formed by the blocks $P_{[j]}$, $j \in \mathcal{J}$.
%
Then
%:
  \begin{align*}
    \small
    \label{eq:psi_y_z_bar}
    \begin{split}
        &(i)~ \  \ \psi(V) = h^*(V) + \frac{1}{2\sa}  \sum_{j=1}^p 
        \left( \left( 1 + \sa \omega_j \la_2 \right) \normbig{\prox_{\sa \pi}\big(T_{[j]}\big) }_2^2 - \norm{B_{[j]}}_2^2 \right) \\ 
        &(ii)~ \ \nabla \psi(V) = V + Y - X \prox_{\sa \pi}(T) \\
        &(iii)~H_{\psi}(V) = I_{nk} + \sa \hat X_\mathcal{J} Q_\mathcal{J} \hat X_\mathcal{J}^T \ .
    \end{split}
    \end{align*}
\end{theorem}
% 

\vspace{0.1in}
\noindent
{\textbf{Computational cost.}}
To reduce the dimension of the problem, and thus the computational burden, our theorem exploits the sparsity structure inherent to the second order information 
%of 
in the Augmented Lagrangian function. At each iteration, DAL selects a subset of active features $\mathcal{J}$ with cardinality $r$, reducing the total cost of solving the linear system (matrix multiplication and \emph{Cholesky} factorization) from $\mathcal{O} \l( nk^4(n^2 + p^2 + np) \r)$ to $\mathcal{O} \l( nk^4(n^2 + r^2 + nr) \r)$.
%
The number of active features $r$ decreases along the iterations of the algorithm, and in sparse scenarios $r$ is usually much smaller than $n$. Therefore, the cost of the system can be further reduced performing the inversion through the \emph{Sherman-Morrison-Woodbury} formula \citep{van1983matrix},
%: 
whereby {\small $\left(I_{nk} + \sa \hat X_\mathcal{J} Q_\mathcal{J} \hat X_\mathcal{J}^T \right)^{-1}$} is equivalent to
%:
%
%\begin{equation*}
%\label{eq:smw_formula}
{\small
%\begin{split}
	   %\left(I_{nk} + \sa \hat X_\mathcal{J} Q_\mathcal{J} \hat X_\mathcal{J}^T \right)^{-1} = 
	   $I_{nk} -  \hat  X_\mathcal{J}  \left( \l( \sa Q_\mathcal{J} \r)^{-1} + \hat X_\mathcal{J}^T \hat X_\mathcal{J} \right)^{-1} \hat X_\mathcal{J}^T$},
%\end{split}. 
%\end{equation*} 
% 
which allows one to factorize an $rk \times rk$ matrix. The total cost is now $\mathcal{O} \l( rk^4(k^2 + r^2 + n^2 + rnk) \r)$.
Notably, this cost does not depend on the total number of features $p$, but just on the number of active features $r$. 
% If we ignore the space complexity of the problem \textcolor{red}{[what is the space complexity?][should we specify how many gigabytes are the data?]}, 
$p$ can increase without affecting the efficiency of the algorithm, as long as sparsity holds, i.e.~$r$ is small. 
Panel left of Figure \ref{fig:complexity_adaptive} illustrates this property;
%: 
the CPU time does not increase with $p$, it increases with $r$.

Also notably, both the gradient and the Hessian matrix of $\psi(V)$ are well defined. The proximal operator associated to the 
%Elastic-Net 
Elastic Net penalty is differentiable, while the one associated with the classical
%Lasso 
LASSO is not. 
Thus, we can implement a full Newton method \citep{ypma1995historical} 
% atkinson2008introduction
to update $V$, which is more efficient with respect to the Semi-smooth Newton method proposed by \cite{tomioka2009dual, li2018}. 
Indeed, we do not have to implement a line-search and evaluate the gradient several times at each iteration to determine the step size; we can simply set it to 1. 

Finally, comparing the computational cost between the function-on-function case presented here and the function-on-scalar one presented in \cite{boschi2021highly}, the main difference is that solving the linear system depends on $k^6$ and not on $k^3$. 
This makes a small $k$ even more crucial for efficiency, and supports our choice of using the 
%FPC's 
FPCs of the response to represent all functional variables; 
%(
we reconstruct the response curves with a small number of basis and at the same time project the predictors onto the subspace which explains the biggest portion of the response variability.
%).  

\vspace{0.1in}
\noindent
{\textbf{Convergence.}} DAL convergence has been already explored in previous literature \citep{tomioka2009dual, li2018, boschi2020efficient}. 
The convergence analysis for DAL with an 
%Elastic-Net type 
Elastic Net penalty relies on the differentiability of $\pi^*$. 
% and on some theoretical results in optimization \citet{rockafellar1976augmented, rockafellar1976, luque1984asymptotic}. 
Both the algorithm as a whole and the routine for the inner sub-problem have a super-linear convergence rate;
\texttt{FAStEN} convergences in very few iterations. 
Following previous literature, to determine the convergence of the algorithm and of the inner sub-problem routine, we check the standardized residuals of the third and first KKT equations in \eqref{eq:kkt}, respectively. 
%(
Using $i$ 
%is used 
to index the rows of a matrix,
%):
these are
%
\begin{align*}
\small
\begin{split}
% \label{eq:kkt_res}
    \text{res}(\text{kkt}_3) = \frac{ \sum_{j=1}^p\norm{V^T X_{[j]} + Z_{[j]}}_2} {1 +  \sum_{i=1}^n \norm{V_{i}}_2 +  \sum_{j=1}^p \norm{Z_{[j]}}_2}
    \ \ \ , \ \ \
    %\quad  
    \text{res}(\text{kkt}_1) = \frac{ \sum_{i=1}^n\norm{(V + Y - XB)_{i}}_2} {1 +  \sum_{i=1}^n \norm{Y_{i}}_2 + \sum_{j=1}^p \norm{X_{[j]}}_2} \ \ .
    %,
\end{split}
\end{align*}
%
%where we use the subscript $i$ to indicate the $i$-th row of a matrix.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Path and adaptive implementation 
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Path and adaptive implementation}
\label{subsec:path_adaptive}

\begin{figure}[!t]
    % \centering
    \hspace*{-1.5cm}
    \includegraphics[width=1.2\textwidth]{figure1.pdf}
    \vspace*{-0.7cm}
    \caption{
    Left panel: computational time comparison under different simulation scenarios for \texttt{FAStEN} with adaptive step and cross-validation ({\it cv}) criterion.
    %as metric. 
    Simulations are run 10 times, with parameters
    %$m=600$,
    $n=600$;
    %and different values of $n\in\{500,1000,2000,8000\}$ 
    $p = 500,1000,2000,8000$ (x-axis); 
    %signal-to-noise ratio equal to 1,
%different numbers of active features (5, 10, 20, 40) 
$p_0=5,10,20,40$ (colors)
%\textcolor{red}{[correct?]}
;
%= 5, 10, 20, 40$;x
$snr=1$
%and 
and ``difficult'' coefficients
(see Section \ref{sec:sim_and_application}). 
%regime of coefficient complexity.
%The centre dots and the vertical bars represent the interval given by adding and subtracting the standard deviation to the average computational time across the 10 replications. 
Dashed lines join average computational times for various $n$'s and vertical bars represent $\pm 1$ standard deviation intervals across the 10 replications. 
Right panel: 
%adaptive path 
an instance of coefficient surface estimates at 
%different 
adaptive path search iterations
%(
5, 10
%, 
and 20 (red), 
%), along 
and 
%with 
true coefficient surface (blue). 
%(simulation parameter $seed=1$, 
%The 
Simulation parameters are $n=600$; $p=8000$; 
$p_0=5$; $snr=10$
%;
and ``easy'' coefficients. 
%For a description of each parameter see Section \ref{sec:sim_and_application}.
% \textcolor{red}{[we don't need to report the seed as a simulation parameter, do we?]}
%).
}
    \label{fig:complexity_adaptive}
\end{figure}
% 

%\textbf{Path-search.}
\textbf{Path search.}
We implement an efficient
%path-search solution 
path search to evaluate different values of the penalty parameter $\lambda_1$.
We compute 
%the solution 
solutions for a decreasing sequence of $\lambda_1$ values, starting from $\lambda_{max} = \max_j\lVert (X^TY)_{[j]}/\omega_j\rVert$, which selects $0$ active features. We use the solution obtained at the previous value of $\lambda_1$ to initialize the solver for the next step in the path (\textit{warm start}). At this stage, the 
%weights 
$w_j$'s in 
%Equation
\eqref{eq:matrix_minimization_problem} are all set to $1$, so that features are all weighted in the same fashion. We also allow the user to specify a maximum number of selected features; when this number is reached the path search is stopped, further reducing computation. 

To guide the choice of
$\lambda_1$ along the path, and potentially also that of $\lambda_2$,
%{\red ($\lambda_1$, $\lambda_2$)}  
%\textcolor{red}{[or is it only $\lambda_1$? in the simulation section we fix one value of $\alpha$, correct?]}
%\textcolor{red}{[Yes correct, we do not investigate $\lambda_2$, but one could use the same criteria to tune also $\lambda_2$]}.
we consider two quantitative criteria; namely, the \textit{generalized cross-validation} (\textit{gcv}) and \textit{k-fold cross-validation} (\textit{cv}) mean squared errors. The former is obtained through the formula \citep{jansen2015generalized}
%: 
$gcv = \text{rss}(\hat{B})/(n - k\nu)^2$, where 
$\text{rss}(\hat{B})$ is the residual sum of squares, and $\nu = \text{tr} \big( X_\mathcal{J}  \big( X_\mathcal{J}^T X_\mathcal{J} + \la_2 I_{rk} \big) ^{-1} X_\mathcal{J}^T \big)$
are the degrees of freedom computed as in \cite{tibshirani2012degrees}.
%
This can be obtained from the original solution and is of course much less computationally expensive than the 
%Notice that 
\textit{cv}, 
%is more computationally expensive than \textit{gcv} because it 
which requires that
%to run 
\texttt{FAStEN} be run multiple times (one per fold) for each value of $\lambda_1$. 
%Instead, \textit{gcv} can be computed directly from the original solution. 
Before evaluating both criteria, we de-bias \texttt{FAStEN} estimates fitting a standard least squares on the selected features only. We 
%refer to this 
indicated these estimates as $\hat B^R$. This approach is known in the literature as \emph{relaxation} \citep{meinshausen2007relaxed, belloni2014debiasedols, zhao2021defense}.
% following the approach suggested by \cite{belloni2014debiasedols, zhao2017debiasedols}: first, we run \texttt{FAStEN}; then, we fit a standard least squares on the selected features. We refer to this de-bias technique as \textit{relaxation} \citep{meinshausen2007relaxed}.

\vspace{0.1in}
\noindent
\textbf{Adaptive 
%scheme.
step.}
The adaptive step starts from the features selected by the best solution of the path described above, i.e.~the path with all 
%the 
weights 
%equal to 1
set to $1$. 
Next, we perform
%A 
a 
%new path-search is performed,
new path search, this time with weights set to $\omega_j=1/\lVert \hat{B}^R_{[j]}\rVert_2$. 
To choose the best $\lambda_1$ in 
%the 
this adaptive path, the criteria are evaluated without relaxation; this is because using weights already mitigates the bias of the estimates. \cite{zou2006adaptive, zou2009adaptive} first introduced 
%developed 
%the adaptive scheme for the 
%Lasso and the Elastic-Net
adaptive paths for the LASSO and the Elastic Net problems, 
showing how weights can improve feature selection, possibly
%lowering 
reducing the size of the active set, and achieving the oracle property. Such improvements were investigated also by \cite{parodi2018simultaneous} in a function-on-scalar regression context, where the authors also demonstrated that weights can enhance coefficient estimation.
Similarly, through an extensive simulation study (see below), we show that in our proposal the adaptive step improves both selection performance and estimation of
coefficient surfaces.
% 
In the right panel of Figure \ref{fig:complexity_adaptive}, one can see how the quality of the estimates increases with the number of iterations along the adaptive path: considering different values of $\lambda_1$ combined with weights 
reduces estimation bias. Adding weights to the minimization in \eqref{eq:matrix_minimization_problem} is a significant novelty with respect to previous DAL implementations; it allows \texttt{FASTeN} to perform feature selection and low-bias coefficient estimation
%at the same time.
simultaneously.

Since investigating a full adaptive path may be computational expensive, \texttt{FAStEN} provides the user an option to perform the adaptive step just for one specific value of $\la_1$ (the one associated to the best solution of the unweighted
%path-search
path search). In this case, we set $\omega_j=\text{sd}_B/\lVert \hat{B}^R_{[j]}\rVert_2$, where $\text{sd}_B$ is the standard deviation of  {\small $\left( \lVert\hat{B}^R_{[1]}\rVert_2, \dots , \lVert\hat{B}^R_{[p]}\rVert_2 \right)$}. We call this single adaptive step
%\emph{soft-adaptive}
\emph{soft adaptive} strategy. 
%
In our experience, this strategy still helps with selection, reducing the number of false positive, but does not produce the improvements in coefficient surface estimation afforded by the full adaptive path. 
To enhance estimation, we combine our 
%soft-adaptive 
soft adaptive strategy with a \emph{relaxation} where we allow the $k$ used for estimation to be larger with respect to the one used for selection. In practice, while we choose $k$ based on a percentage of variance explained (e.g., $90\%$) for selection, for estimation here 
%for estimation, 
we choose the $k$ that minimizes a 5-fold $cv$. 
%\textcolor{red}{[is this the number of FPCs used? then this is not consistent with what we say in the simulation section][for selection we use k that explains more than 90 percent of variability. With this specific adaptive-step, we allow k to change during the estimation. This k is chosen using a 5-fold $cv$.]} 


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  Simulation 
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\section{Simulation study}
\label{sec:sim_and_application}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Simulation settings  
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\begin{figure}[!t]
    % \centering
    \hspace*{-1.5cm}
    \includegraphics[width=1.2\textwidth]{figure2.pdf}
    \vspace*{-0.5cm}
    \caption{ 
    Simulated data example (simulation parameters
    %$seed=1$, 
    $n=600$; $p=8000$; $p_0=5$; $snr=10$ and ``easy'' coefficients).
    The top left panel shows a 
    %test 
    sample of 5 true signal curves
    (i.e.~responses before adding errors), the top center panel shows error curves
    (note the different vertical axis) and the top right panel shows the resulting response curves (true signal + error; dashed) along with the predictions obtained with \texttt{FAStEN} (solid).
    The bottom panel shows the 5 non-zero true coefficient surfaces (blue) and, 
    %right 
    above each, the corresponding \texttt{FAStEN} estimates (red). Both prediction and estimation performance appear strong in this illustration.
    % Simulated data example (simulation parameters $seed=20$, $n=600$, $p=8000$, $p_0=5$, $snr=10$, ``easy'' coefficients).
    % The left panel shows a test sample of 5 true observed response curves (true signal + error; dashed) along with the predictions obtained with \texttt{FAStEN} (solid).
    % The right panel shows a sample of 2 non-zero true coefficient surfaces (blue) and, right above each, the corresponding \texttt{FAStEN} estimates (red). 
    % All the 5 surfaces are displayed in Appendix Figure \ref{fig:5betas}. 
    % Both prediction and estimation performance appear strong in this illustration.
    }
    \label{fig:sim}
\end{figure}
% 
% 
% \textbf{Simulation settings}. We now employ synthetic data to investigate performance and computational efficiency of \texttt{FAStEN}. 
% We also compare it with \texttt{FRegSigCom} \citep{qi2018function}, which is implemented in \texttt{R} with backend in \texttt{C++}
% (since the function-on-function feature selection problem has not yet been intensively studied, this was the only existing method with publicly available code we were able to identify to date). 
% % We also compare it with the only competitor we found in the literature, implemented in the \texttt{R package FRegSigCom} \citep{qi2018function}, in all scenarios in which the computational burden of the latter allows us to run it. 
% For each simulation setting, we consider different values of $p_0$ and $snr$. 
% $p_0$ indicates the number of active features, i.e.~non-zero regression coefficient surfaces. We generate these surfaces from a mixture of bivariate Gaussian distributions under two regimes of complexity, which we denote as \emph{easy} (single peak with large standard deviation) and \emph{difficult} (2 or 3 peaks with small standard deviations).
% $snr$ indicates the \emph{signal-to-noise ratio} and is defined as $\text{var}(\mathcal Y_{true})/\text{var}(\epsilon)$, where $\text{var}(\mathcal Y_{true})$ and $\text{var}(\epsilon)$ are the global variances of the response $\mathcal Y$ and the error $\epsilon$, respectively. 
% We consider $snr$ = $1, 10, 100$. Scenarios are harder, from the perspective of both selection and estimation, the smaller their $\text{snr}$.
% % 
% The data generation process and all the other simulation parameters are described in detail in Appendix Section \ref{sec:simulation_settings_supp}.
% % Figure \ref{fig:sim} shows some instances of response and error curves, as well as the true and estimated non-zero coefficient surfaces, for one specific scenario (the underlying simulation parameters are reported in the caption). 
% Figure \ref{fig:sim} shows some instances of observed and predicted response curves, as well as a sample of 2 true and estimated non-zero coefficient surfaces, for one specific scenario.
% % (the underlying simulation parameters are reported in the caption). 
% % 
\textbf{Simulation settings}. We now employ synthetic data to investigate performance and computational efficiency of \texttt{FAStEN}. We also compare it with the only competitor we found in the literature, implemented in the \texttt{R package FRegSigCom} \citep{qi2018function}, in all scenarios in which the computational burden of the latter allows us to run it. 

We generate the response additively according to model \eqref{eq:fof_problem}. Each feature $\mathcal{X}_{j}$, as well as the error $\epsilon$, are drawn from a $0$ mean Gaussian process with a Matern covariance function \citep{cressie1999classes} of the form
%
\begin{equation*}
\small
\begin{split}
        C(t,s) = \frac{\eta^2}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} \lvert t-s \rvert\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} \lvert t-s \rvert \Bigg)
\end{split}
\end{equation*}
%
where $K_\nu$ is a modified Bessel function. For the $\mathcal X$'s we use point-wise variance $\eta^2=1$, range $l=0.25$ and smoothness parameter $\nu=3.5$. 
For $\epsilon$ we use $l=0.25$, $\nu=2.5$, and assume the variance $\eta^2_\epsilon$ to be the same across the entire time domain. The value of $\eta^2_\epsilon$ is set as a function of the \emph{signal-to-noise ratio (snr)} we define for different simulation scenarios. Specifically, we take $\eta^2_\epsilon = \text{var}(\mathcal Y_{true}))/
%\text{snr}
snr$, where $\text{var}(\mathcal Y_{true})$ is the global variance of the response $\mathcal Y$, and consider $snr$ = $1, 10, 100$. Scenarios are harder, from the perspective of both selection and estimation, the smaller their 
%$\text{snr}$
$snr$.

For each scenario, $p_0$ indicates the number of active features, i.e.~non-zero regression coefficient surfaces. We generate these surfaces from a mixture of bivariate Gaussian distributions under two regimes of complexity. The \enquote{easy} regime is characterized by a single peak with standard deviation randomly drawn from a uniform distribution on $[0.2,0.3]$. The \enquote{difficult} regime is characterized by 2 or 3 peaks with standard deviations randomly drawn from a uniform on $[0.01,0.15]$.
% Figure \ref{fig:sim} shows some instances of response and error curves, as well as the true and estimated non-zero coefficient surfaces, for one specific scenario (the underlying simulation parameters are reported in the caption). 
Figure \ref{fig:sim} shows some instances of observed and predicted response curves, as well as 
%a sample of 2 
true and estimated non-zero coefficient surfaces, for one specific scenario
%.
(the underlying simulation parameters are reported in the caption). 
In all scenarios, \texttt{FAStEN} is run with tolerances set to $10^{-6}$, starting from $\sigma^0=p_0/p$ and increasing by a factor of 5 at each iteration. 
Following standard practice in the literature \citep{friedman2010regularization, pedregosa2011scikit} we write $\lambda_1=\alpha c_\lambda\lambda_{max}$ and $\lambda_2=(1-\alpha)c_\lambda\lambda_{max}$, with $c_\lambda\in(0, 1]$ and $\alpha\in(0, 1)$. $c_\lambda$ determines the reduction with respect of $\lambda_{max}$, while $\alpha$ controls the relative weight of the two penalties. We set $\alpha=0.2$. Finally, regarding $k$, we chose the smallest number of
%FPC's 
FPCs which explains over $90\%$ of variability of the response $\mathcal Y$. For all scenario considered, the selected $k$
is either 3 or 4.

Before running \texttt{FAStEN} we standardize the response and each feature individually. For
%any 
each instance of 
%any 
each functional variable, say $\mathcal V$ for simplicity, we create a standardized version as $\left(\mathcal V(t) - \text{ave}(t) \right) / \text{sd}(t)$, where $\text{ave}(t)$ and $\text{sd}(t)$ are the point-wise average and standard deviation of all 
%the 
instances computed at 
%each 
$t$.

In each scenario, we evaluate performance 
%with several metrics; namely,
with respect to \emph{selection, estimation, prediction,} and \emph{computational efficiency}. The numbers of 
%\emph{false positives} and \emph{false negatives} 
false positives and false negatives 
%tracks 
track selection performance; the standardized mean square error of the coefficient surfaces ($\text{mse}(\mathcal B)$) measures the quality of estimation; the out-of-sample standardized mean square error of the responses ($\text{mse}_{out}(\mathcal Y)$) quantifies prediction performance; and CPU time in seconds measures computational efficiency. $\text{mse}(\mathcal B)$ and $\text{mse}_{out}(\mathcal Y)$ are defined as 
%
\begin{align*}
\small
\begin{split}
\label{eq:eval_criteria}
    \text{mse}(\mathcal B) = \frac{1}{r} \sum_{j=1}^{r} \frac{\norm{\mathcal B_j - \hat{\mathcal B}_j}_{\mathbb L^2 \times \mathbb L^2}}{\norm{\mathcal B_j}_{\mathbb L^2 \times \mathbb L^2}}
    \ \ \ , \ \ \
    %, \quad 
    \text{mse}_{out}(\mathcal Y) = \frac{1}{n_{test}} \sum_{i=1}^{n_{test}} \frac{\norm{\mathcal Y_i - \hat{\mathcal Y}_i}_{\mathbb L^2} }{\norm{\mathcal Y_i}_{\mathbb L^2}} 
    \ \ \ .
\end{split}
\end{align*}
%
Note that $\text{mse}(\mathcal B)$ is evaluated only on 
% the $r$ 
%\textcolor{red}{[$p_o$?][here is $r$: $r$ number of selected features (estimated non-zero), $p_o$ true value of non-zero coefficients]}
% true non-zero estimated surfaces, i.e.~on the selected features 
% \textcolor{red}{which belong to the true active set [maybe this needs to be removed? are we considering ALL selected features, including false positives?]}. 
the selected features which belong to the true non-zero coefficients set. 
Concerning $\text{mse}_{out}(\mathcal Y)$, we evaluate it simulating a separate and independent \emph{test set} with size $n_{test} = n/3$ for each simulation run. We standardize both criteria to easily compare results across different simulation settings. 
% {\red why standardized}
% 
% \begin{figure*}[t!]
%     \centering
%     \includegraphics[width=\linewidth]{gfx/cv_no_adaptive.pdf}
%     \caption{Performance comparison 
%     %under different metrics
%     between fully adaptive \texttt{FAStEN} 
%     %with full adaptive 
%     and basic, non-adaptive
%     %(no adaptive)
%     \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion.
%     %metric. 
%     %Several metrics are shown evaluating selection, estimation, prediction and computational burden.
%     Simulations are run 10 times, with $n=600$, $n=8000$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20, 40) and coefficient complexity regimes (easy, difficult). %Each of the ten panels shows results for an evaluation metric (left to right; selection as false negatives and false positives, estimation, prediction and computational burden) and a coefficient complexity regime (top, easy; bottom difficult). Within the cells of each panel, the first and second rows contain average scores (across simulations) for fully adaptive \texttt{FAStEN} and non-adaptive \texttt{FAStEN}. 
%     % Those scores are rimmed in cyan if the absolute value of their difference exceeds a threshold (3 for false negatives and false positives, 0.05 for estimation and prediction {\red MSE's [FIX TO INDICATE NORMALIZATION]}, and 5 seconds for time). 
%     % The background of each cell color-codes the difference between fully adaptive and non-adaptive \texttt{FAStEN} average scores, divided by the standard deviation of the latter -- the color scale is provided on the right of each panel.
%     % The scales differ across panels, but in general a color associated to the negative part of the scale represents a better performance for fully adaptive \texttt{FAStEN}. The estimation task here is performed only on true positive features, i.e. we don't measure estimation quality on potential false positives.
%     }
%     \label{fig:cv_no_adaptive}
% \end{figure*}
% 
% \begin{figure*}[t!]
%     \centering
%     \includegraphics[width=\linewidth]{gfx/cv_gcv.pdf}
%     \caption{Performance comparison 
%     %under different metrics
%     between fully adaptive \texttt{FAStEN} 
%     %with full adaptive 
%     with cross-validation (\textit{cv}) and with generalized cross validation (\textit{gcv}) as 
%     %metrics. 
%     criterion. Simulation parameters, and structure and interpretation of panels and colors
%     %color legend and interpretation 
%     are the same as 
%     %those 
%     in Figure \ref{fig:cv_no_adaptive}. 
%     % Each of the ten panels shows results for an evaluation metric (left to right; selection as false negatives and false positives, estimation, prediction and computational burden) and a coefficient complexity regime (top, easy; bottom difficult). Within the cells of each panel, the first and second rows contain average scores (across simulations) for fully adaptive \texttt{FAStEN} and non-adaptive \texttt{FAStEN}. 
%     % Those scores are rimmed in cyan if the absolute value of their difference exceeds a threshold (3 for false negatives and false positives, 0.05 for estimation and prediction {\red MSE's [FIX TO INDICATE NORMALIZATION]}, and 5 seconds for time). 
%     % The background of each cell color-codes the difference between fully adaptive and non-adaptive \texttt{FAStEN} average scores, divided by the standard deviation of the latter -- the color scale is provided on the right of each panel.
%     % The scales differ across panels, but in general a color associated to the negative part of the scale represents a better performance for fully adaptive \texttt{FAStEN}. The estimation task here is performed only on true positive features, i.e. we don't measure estimation quality on potential false positives.
%     }
%     \label{fig:cv_gcv}
% \end{figure*}
% 
\begin{figure*}[t!]
    % \centering
    \hspace*{-1.5cm}
    \includegraphics[width=1.2\linewidth]{figure3.pdf}
    \vspace*{-0.5cm}
    \caption{Performance comparison between fully adaptive \texttt{FAStEN} with cross-validation (\textit{cv}) as criterion, and \texttt{FRegSigCom}. Due to the computational burden of the latter, simulations are run only 3 times with $n=300$, 
    %$n=500$, 
    $p=500$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20) and coefficient complexity regimes (``easy'', ``difficult'').
    Each of the ten 
    %panels 
    tables shows results for an evaluation metric (left to right; selection as false negatives and false positives, estimation error, prediction error and computational burden) and a coefficient complexity regime (top, ``easy''; bottom, ``difficult''). Within the cells of each
    %panel, 
    table, the first and second rows contain average scores (across simulations) for fully adaptive \texttt{FAStEN} and \texttt{FRegSigCom}. 
    Those scores are rimmed in cyan if the absolute value of their difference exceeds a threshold (3 for false negatives and false positives, 0.05 for estimation and prediction standardized 
    %MSE's
    MSEs, and 5 seconds for time). 
    The background of each cell color-codes the difference between fully adaptive \texttt{FAStEN} and \texttt{FRegSigCom} average scores, divided by the standard deviation of the latter -- the color scale is provided on the right of each panel.
    The scales differ across panels, but in general a color associated to the negative part of the scale represents a better performance for \texttt{FAStEN}. 
    %The 
    Estimation 
    %task 
    here is performed only on true positive features
    %, i.e. 
    (we
    %don't 
    do not measure estimation quality on
    %potential 
    false positives).
    }
    \label{fig:cv_competitor}
\end{figure*}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Simulation results  
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \subsection{Simulation results}
% \label{subsec:sim_res}

\vspace{0.1in}
\noindent
\textbf{Simulation results}. 
First, we study the performance of \texttt{FAStEN} with and without the adaptive 
%scheme 
step in 
%a simulation setting 
simulations with $n=600$ and $p=8000$.
In both cases, we use cross-validation (\textit{cv}) as criterion to 
%select the best model
tune the penalties. Results are shown in Appendix Figure \ref{fig:all_sim_supp}, panel $a$. 
The adaptive 
%version 
step improves selection performance reducing the number of false 
%positive, 
positives, especially in scenarios with larger active sets (less sparsity). 
As expected, the two approaches are identical in terms of false negatives, since the adaptive
%scheme 
step can only reduce the original active set. 
Adaptive \texttt{FAStEN} drastically improves also estimation and prediction performance in all scenarios considered. 
Finally, as expected, the adaptive version is more computationally expensive,
%: 
as we need to run a 
%path-search 
path search twice. The larger is $p_0$, the larger is the cost of performing an adaptive step.

We use 
%the same setting 
again $n=600$ and $p=8000$ to compare 
%the two model selection criteria, 
cross-validation (\textit{cv}) and generalized cross validation (\textit{gcv}) criteria used as part of the adaptive version of \texttt{FAStEN}. 
Results are shown in Appendix Figure \ref{fig:all_sim_supp}, panel $b$.
% \ref{fig:cv_gcv}.
$cv$ outperforms $gcv$ both in terms of estimation and prediction, at the cost of selecting less parsimonious models. Indeed, \textit{cv} performs better in terms of false negatives, but worse in terms of false positives, especially in scenarios with large $p_0$. 
Finally, as expected, $cv$ is more computationally expensive. In the hardest scenario ($snr=100$, $p_0=40$, and ``difficult'' coefficients), \textit{cv} requires 28 seconds and $gcv$ less than 2 seconds, on average.

Next, we compare the adaptive version of \texttt{FAStEN} with \texttt{FRegSigCom}. Results are shown in Figure \ref{fig:cv_competitor}. Due to the computational burden of \texttt{FRegSigCom}, considering very high-dimensional settings is unfeasible. Thus, we restrict our comparison to settings with $n=300$ and 
%$n=500$
$p=500$, and use fewer simulation runs for each setting. In terms of false negatives, the two methods perform similarly, while in terms of false positives \texttt{FAStEN} drastically outperforms \texttt{FRegSigCom} in every scenario, with an improvement in the range of two orders of magnitude. \texttt{FRegSigCom} does not explore meticulously the hyper-parameter
%s 
space and always selects 
%many more features 
a number of active features much larger than $p_0$.
In terms of estimation, \texttt{FAStEN} performs better in the hardest scenarios, characterized by 
low signal-to-noise ratio (especially so in the ``difficult'' coefficients regime). In high $snr$ scenarios \texttt{FAStEN} performs worse than \texttt{FRegSigCom} in terms of estimation, but the absolute difference between the two average $\text{mse}(\mathcal B)$ is small; \texttt{FAStEN} still produces very accurate estimates.
Prediction performances follow a similar pattern: \texttt{FRegSigCom} performs slightly better when the signal-to-noise ratio is high, while \texttt{FAStEN} dominates in other scenarios.
As expected, the better performances in terms of selection reflects in a better prediction. 
Finally, \texttt{FAStEN} is significantly more computationally efficient than its competitor, with extreme cases where we have a speed up of $\approx2500$ times (e.g.,~in the scenario with $snr=1$, $p_0=5$ and ``easy'' coefficients).
In conclusion, \texttt{FAStEN} drastically outperforms \texttt{FRegSigCom} in terms of selection and CPU time, improves the estimation of ``difficult'' 
%coefficients 
coefficient surfaces in noisy instances, and 
%it 
is slightly worse in terms of prediction when the problem is not very sparse and the signals are 
%not very noisy
strong.

% Additional simulation results for different scenarios ($n=600$, $p=2000$), which further support our findings, are provided in the Appendix Material -- see Section \ref{sec:supp_additional_sim_res}. 
Lastly, Appendix Figure \ref{fig:all_sim_supp}, panel $c$
% \ref{fig:cv_tobia} 
shows a comparison between the standard adaptive implementation of \texttt{FAStEN} and the \emph{soft adaptive} scheme, in a scenario with $n=600$ and $p=8000$. While the full adaptive implementation leads to better results in estimation and prediction, the soft adaptive scheme performs better in terms of false positives (selection) and computational burden.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  AOMIC data
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{AOMIC PIOP1 application}
\label{subsec:application}

\begin{figure}[!t]
    % \centering
    \hspace*{-1.5cm}
    \includegraphics[width=1.2\linewidth]{figure4.pdf}
    \vspace{-0.6cm}
    \caption{ 
    AOMIC PIOP1 data.
    Top left: heart rate curves (used as response) for a selection of 20 subjects in the study.
    Bottom left: histogram of $R^2$s from the marginal regressions of heart rate on each of the voxels. The threshold at 0.02 (dashed vertical line) is used to screen voxels. 
    Right panel: voxels selected at least 30 times applying FAStEN to 100 bootstrap samples from the original data, using the \textit{cv} (left) or \textit{gcv} (right) 
    %for model selection,
    criteria and $k = 2, 3, 4$ (top, centre, bottom, respectively). 
    For each 3D coordinate in the brain, the voxels are projected on (from left to right) the Coronal, Sagittal, and Horixontal axis.
    Dot colors represent frequency of selection (out of 100, see color scales).
    % AOMIC PIOP1 data results.
    % AOMIC PIOP1 data results for $k=2$ (left panel) and $k=4$ (right panel). Voxels selected at least 30 times by $cv$ (top row) and at least 20 times (bottom row) by $gcv$ applying FAStEN to 100 bootstrap samples from the original data.
    % For each 3D coordinate in the brain, the voxels are projected on (from left to right) the Coronal, Sagittal, and Horixontal axis.
    }
    \label{fig:brain_app}
\end{figure}
%
%
AOMIC PIOP1 comprises brain fMRI raw and pre-processed data collected during various task-based experiments on a sample of 216 university students \citep{snoek2021amsterdam}. We analyze data relative to the emotion anticipation task, which measures processes related to emotional anticipation and curiosity.
Specifically, 30 unique images were shown to each subject at regular intervals in a time span of 200 seconds. Each image was preceded by a cue. The cue could be valid, i.e.~describe correctly the subsequent image, or invalid, i.e.~not related to the image. 
The order of the images and the pairing with a valid or invalid cue was randomly selected for each subject. For all the subjects, $80\%$ of cues were valid 
%(
-- see \citep{snoek2021amsterdam} for more details.
%). 

In addition to activation at each voxel (i.e., roughly, location of the brain in 3D coordinates), various measurements were taken on the subjects along the 200 seconds duration of the experiment. We focus on heart-rate variability (HRV), which is a convolution of the cardiac trace with a cardiac response function \citep{chang2009influence}; 
%(
a selection of 20 HRV curves is plotted in the top left panel of Figure \ref{fig:brain_app}.
%).
The goal of our analysis is to understand which are the voxels (features) whose activation is associated with HRV (response). 
We overlap brain masks of different subjects in order to get an homogeneous brain model, also removing scanned space outside brain. 
This leads to a data set of 188 subjects and 55,551 voxels, whose activity is evaluated 
%in 200
at $200$ time points. 
Curves are smoothed using as smoothing spline, i.e. cubic \textit{B-splines} with knots at each time point and a roughness penalty on the
%curve 
second derivative \citep{ramsay2005}. For each voxel activity, and for HRV, the smoothing parameter is selected by minimizing the average generalized cross-validation error (\textit{gcv}) \citep{craven1978smoothing} across the curves of the 188 individuals. These pre-processing steps are performed with the \texttt{R package fda} \citep{ramsayfdapackage}. 

Given the computational efficiency of \texttt{FAStEN}, we are able to run it on the full data set comprising 55,551 voxels. To the best of our knowledge, data of this size has not been explored through function-on-function regression to date. Notably, the number of selected voxels remains rather stable as we vary $k$ and the selection criterion ($cv$ and $gcv$). 
As another way to gauge stability, we perform a different analysis in which \texttt{FAStEN} is preceded by a preliminary screen of the features.
We marginally regress HRV against the activation of individual voxels, and we identify the 26,682 voxels 
for which the marginal regression has a coefficient of determination $R^2>0.02$ 
% (the histogram of such $R^2$'s is displayed in the left panel of Appendix Figure \ref{fig:hrv_r2_marginal}).
(the histogram of such $R^2$'s is displayed in the bottom left panel of Figure \ref{fig:brain_app}). 
Running \texttt{FAStEN} (with \textit{gcv} and $k=3$) on the full and on the screened set of features produces exactly the same selection of 48 active voxels.
%
This suggests that, even in complex real data sets, \texttt{FAStEN} can indeed pinpoint relevant signals, parsimoniously and stably, regardless of the number of irrelevant signals among which they are interspersed. 

Finally, and again favoring a stability perspective, we use the 26,682 screened voxels to run \texttt{FAStEN} on 100 bootstrap samples of individuals, 
%for each combination of $k\in[2,4]$ and selection criterion (\textit{cv} and \textit{gcv}), 
varying $k$ and the selection criterion, and counting the number of times each voxel is selected. 
The right panel of Figure \ref{fig:brain_app}
% The top (\textit{cv}) and bottom (\textit{gcv}) right panels of Figure \ref{fig:brain_app} 
shows the voxels selected at least 30 times (out of 100) by \texttt{FAStEN} with $k=2,3,4$ and considering \textit{cv} and \textit{gcv} 
%as selection criteria
%.
($\alpha$ is fixed to $0.2$).
% results for $k=2$ and $k=4$ are shown in Appendix Figure \ref{fig:brain_app_k2_k4}).
% \textcolor{red}{We note that computation time would {\em not} be an issue in repeating this analysis for the entire set of 55, 551 voxels, but memory space would for larger $k$ values -- which is why we restrict it to screened voxels. [WE MAY KEEP OR OMIT THE RED PHRASE]}
%
We obtain remarkably consistent results across values of $k$ and selection criteria -- with $gcv$ being slightly more conservative than $cv$. Specifically, two areas of persistent association with the response appear to emerge. The first area 
%is 
is the mesencephalon
%, 
(shown in the center of the Horizontal axis in Figure \ref{fig:brain_app})
%. The mesencephalon 
which is critical to the regulation of vital tasks, such as respiration and heart rate control. The second area is the orbitofrontal cortex (shown in the upper right of the Horizontal axis in Figure \ref{fig:brain_app})
%. The orbitofrontal cortex 
which is involved in the reward and punishment system, and may thus be associated with emotion anticipation. Hence, while drawing strong domain conclusion is beyond the scope of this paper, we do have some evidence that the brain locations pinpointed by our analysis may indeed be related to heart rate variability patterns during the emotion anticipation task under consideration \citep{rolls2008orbitofrontal, holstege2014periaqueductal}.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  World Bank data
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%\subsection{World Bank data}
%The World Bank provides access to the WB Data Catalog \citep{wbdatacatalog} containing statistics concerning the development of countries. We retrieve five data sets regarding jobs, education, development, health and poverty indicators, measured at most yearly for 25 years, from 1992 to 2016. We drop variables that have more than 20\% of missing values, that are highly collinear or that are duplicates over different data sets. Moreover, we also focus on the first 100 countries in terms of data availability (see {\red Appendix Material} for details on the screening procedure). We end up with 124 features observed for 25 years. We build smooth curves for each country and feature, allowing us both to capture information along the entire time domain and to mitigate the effect of outliers or anomalous raw measurements, and then we evaluate each of them in 100 points of their domain. Our goal is to explain the variability in the number of mobile cellular subscriptions per 100 people (shown in Figure \ref{fig:wb_app}, left panel) over countries and time, by employing few other features. By varying $\alpha\in\{0.5,0.8\}$, we run different configurations of \texttt{FAStEN} on 100 bootstrapped samples from our data, and keep track of the selected features for each criterion. Figure \ref{fig:wb_app}, center panel, displays the ranking of the most selected features across model configurations and bootstrapped samples. We find that the response seems to be mostly related to the GDP per capita measured in current US\$ and fixed telephone subscriptions per 100 people. Figure \ref{fig:wb_app}, right panel, shows the coefficient surfaces estimated through a function-on-function regression model on the original sample, where the two features are jointly considered. By considering the main diagonal of a surface, which captures the concurrent (without lags) relationship between response and regressor, we notice that, while the effect of GDP per capita on the number of mobile cellular subscription per 100 people seems to be increasing in the first part of the time domain (until 2005 approximately), it later starts decreasing at a steeper rate in the second part of the domain. This may be due to the fact that the diffusion of mobile phones happened first in richer countries, and only later in poorer ones. We also notice that the relationship between mobile and fixed phone subscriptions is U-shaped, being decreasing in the first part of the time domain (until 1997 approximately) and later slowly increasing. This may indicate that countries with higher subscriptions to fixed phones have not immediately adopted mobile phones, only later subscribing to mobile cellulars (probably in transitioning from the former to the latter) in a sustained way. Without drawing any strong domain conclusion, we highlight that the features selected by \texttt{FAStEN} have been also investigated by previous literature (see \cite{lum2011mobile} and \cite{mcdonough2012fixed}). 

%\subsection{EEG-fMRI data}
%We also replicate the application of \cite{qi2018function} on a simultaneous EEG-fMRI data set from the Auditory and Visual Oddball EEG-fMRI project. The study concerns the association between the activity of brain voxels and EEG responses. Data are preprocessed as in \cite{qi2018function}, thus obtaining two families of functional regressors. The first is composed of 55 regions of interest (ROI), which are divisions of the brain based on Brodmann areas {\red REF}. The second is finer, being composed of 8529 pre-screened brain voxels. We run \texttt{FAStEN} on both the families, and results only partially reflect those of \cite{qi2018function}.

%{\red LT: NOT MUCH TO SAY WITHOUT MASKS, BUT OUR FRIENDS DO NOT SHARE THEM...}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  Conclusions
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\section{Conclusions}
\label{sec:conclusion}

In this paper we proposed \texttt{FAStEN}, a very efficient methodology to simultaneously perform feature selection and estimation in functional regression. 
While we focused on the most complex 
%setting case, 
context, i.e.~the 
function-on-function case 
where both the response and the features are curves, additional information provided in the Appendix (scalar-on-function 
% and concurrent 
case) and prior work from our own group (function-on scalar case) cover the whole spectrum of regressions comprising functional data. Function-on-function feature selection has not been extensively studied to date, perhaps because of the challenges posed by the complexity and the dimension of the problem. 
\texttt{FAStEN} exploits the properties of FPC (functional principal components) -- which allow us to represent the functions in finite spaces; specifically, we utilize the finite space capturing dominant modes of variability of the response. 
\texttt{FAStEN} also exploits a novel adaptive version of the DAL (Dual Augmented Lagrangian) to minimize a 
newly defined, Elastic Net type objective function comprising two different penalties.
The DAL algorithm is very efficient in sparse scenarios, where it leverages the structure of the Augmented Lagrangian second order derivative to significantly reduce the dimension of the problem and the computational cost. 
%Moreover, by introducing 
Finally, \texttt{FAStEN} comprises two different adaptive schemes
%, we 
which can be used enhance both selection and estimation performance. 

Our simulation study demonstrates that \texttt{FAStEN} leads to dramatic improvements in feature selection and computational time, without compromising estimation or prediction accuracy.
%Finally, we 
We also applied \texttt{FAStEN} to a brain fMRI data set, exploring more than 55,000 voxel activation curves for potential associations with variation in heart rates. Thanks to \texttt{FAStEN}'s computational efficiency, we were in a position to perform analyses involving multiple runs of the procedure (e.g.,~with different parameter specifications and on numerous bootstrap samples) and thus reach stable and enlightening results.
These outline an association between two well identified brain regions and heart rate variability during emotion anticipation.  

We plan to further expand 
%this 
an approach which, we believe, provides significant methodological novelty in the arena of functional regression. In particular, we plan to investigate more complex penalties and incorporate both scalar and functional features in the same selection problem.
Other interesting developments concern the choice of basis system and the number of components ($k$) used to approximate functional observations.
Formulating a quantitative criterion to determine a different and specific $k$ for each variable and for each task (selection and estimation) would allow one to represent each feature more accurately and may improve the overall performance of the algorithm.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%   Acknowledgements 
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

% Acknowledgements should go at the end, before appendices and references

% \acks{% The work of Tobia Boschi is partially supported by the Huck Institutes of the Life Sciences at Penn State; the work of Lorenzo Testa is partially supported by the Sant'Anna School of Advanced Studies; 
% \noindent The work of Francesca Chiaromonte is partially supported by the Huck Institutes of the Life Sciences at Penn State and by the Sant'Anna School of Advanced Studies; the work of Matthew Reimherr is partially supported by the Grant NSF SES-1853209. Tobia Boschi gratefully acknowledges Dr. Ludovica Delpopolo Carciopolo for
% %the fruitful 
% useful discussions about the development and the coding implementation of the optimization algorithm.
% }

% Manual newpage inserted to improve layout of sample file - not
% needed in general before appendices/bibliography.



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%  Appendix  
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\appendix

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=
%
%  Proofs
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{Appendix A. Proofs}
\label{sec:supp_proofs}
% \setcounter{equation}{0}

%%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%%  Proposition 1 
%%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%\subsection{Proposition 1}
%\label{subsec:proof_prop1}
%
%We now show how one can use the FPCs of $\mathcal Y(t)$ in order to obtain a matrix representation of Equation \eqref{eq:functional_minimization_problem}. First, let us consider the simple case with just one feature $\mathcal X_1(s)$.
%Let $e(t) = \left[e_1(t) ~ | ~ \dots ~ | ~ e_k(t) \right]$ be the matrix containing the first $k$ FPCs of $\mathcal Y(t)$, and $Y \in \mathbb{R}^{n \times k}$ be the matrix of the scores of $\mathcal Y(t)$ with respect to $e(t)$, i.e. $Y_{ij} = \langle \mathcal Y_i, e_j \rangle_{\mathbb{L}^2}$. Similarly, let $X_{[1]} \in \mathbb{R}^{n \times k}$ and $B_{[1]} \in \mathbb{R}^{k \times k}$ be the scores matrices of $\mathcal X_1(s)$ and $\mathcal B_1(s, t)$ with respect to $e(t)$ and  $e(s)e(t)^T$, respectively. 
%In particular, we have $X_{[1](ij)} = \langle \mathcal X_{1i}, e_j \rangle_{\mathbb{L}^2}$ and $B_{[1](ij)} = \big\langle \langle \mathcal B_1, e_i \rangle_{\mathbb{L}^2}, e_j \big\rangle_{\mathbb{L}^2} = \int\int \mathcal B_1(s, t)e_i(s)e_j(t)~ds~dt$. 
%Then, we can approximate $\mathcal Y(t) \approx Ye(t)^T, ~ \mathcal X_1(s) \approx X_{[1]}e(s)^T, ~ \mathcal B_1(s, t) \approx e(s)B_{[1]}e(t)^T$ and thus rewrite Equation~\eqref{eq:fof_problem} as:
%%
%\begin{align*}
%\small
%\begin{split}
%    Ye(t)^T \approx X_{[1]} \left(\int_{\mathcal{S}} e(s)^Te(s)~ds\right) B_{[1]}e(t)^T \ .
%\end{split}
%\end{align*}
%%
%Now, multiply both sides of the equation for $e$ and integrate over $t$. {\red for what purpose?} Furthermore, note that since $e$ is a FPC basis, $\int e(t)^Te(t)dt = I_k$, the identity matrix of order $k$ \citep{kokoszka2017introduction}. This leads us to
%%: 
%$Y \approx X_{[1]} B_{[1]}$.
%%\\
%The extension to $p$ predictors is straightforward. Let us define the design matrix containing all the features and the complete coefficient matrix as $X = \left[X_{[1]} | \dots | X_{[p]} \right] \in \mathbb{R}^{n \times pk}$ and $B = \left[B_{[1]} | \dots | B_{[p]} \right]^T \in \mathbb{R}^{pk\times k}$, respectively. $X_{[j]}\in \mathbb{R}^{n \times k}$ and $B_{[j]}\in \mathbb{R}^{k \times k}$ are the matrices restricted to the scores of the $j$-th feature and the $j$-th coefficient surface, respectively.  
%The function-on-function linear model in \eqref{eq:fof_problem} can be approximated as
%%: 
%$ Y \approx X B $.
%%
%To provide a matrix representation of the objective function in~\eqref{eq:functional_minimization_problem}, we need to relate the ${\mathbb{L}^2}$ functional norm and the standard $l_2$ matrix norm, i.e.~the Frobenius norm -- which we indicate with $\lVert \cdot \rVert_2$. Since $e(t)$ is an orthonormal basis, the following equations hold for a generic function $f(t) \in \mathbb L^2([0,1])$ and a generic surface $g(t,s) \in \mathbb L^2([0,1])\times \mathbb L^2([0,1])$: 
%%
%\begin{align}
%\small
%\begin{split}
%\label{eq:fpca_prop}
%    &\lVert f(t) \rVert_{\mathbb{L}^2}^2 = 
%    \sum_{i=1}^\infty \langle f(t), e_i(t)\rangle_{\mathbb{L}^2} \ , \\ 
%    &\lVert g(t,s) \rVert_{\mathbb{L}^2 \times \mathbb{L}^2}^2 = \sum_{i=1}^\infty \sum_{j=1}^\infty  \big\langle \langle g(t,s), e_j(s)\rangle_{\mathbb{L}^2}, e_i(t) \big\rangle_{\mathbb{L}^2} \ .
%\end{split}
%\end{align}
%%
%These allow us to approximate the ${\mathbb{L}^2}$ functional norm with the $l_2$ Frobenius of norm for both vectors and matrices. 
%We are now ready to express \eqref{eq:functional_minimization_problem} in matrix form as: 
%%
%\begin{equation}
%\small
%    \label{eq:matrix_minimization_problem_supp}
%    \min_{B} \frac{1}{2}\lVert Y-XB\rVert_{2}^2 + \sum_{j=1}^{p} \omega_j \left( \lambda_1 \lVert B_{[j]}\rVert_{2}+\frac{\lambda_2}{2} \lVert B_{[j]}\rVert_{2}^2 \right) \ .
%\end{equation}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Proposition 1
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Proposition 1}
\label{subsec:proof_prop1}

First, note that $\pi(B) = \sum_{j=1}^p \pi (B_{[j]})$ is a separable sum: from \citet{boyd2004convex} we have $\pi^*(Z) = \sum_{j=1}^p \pi^* (Z_{[j]})$. Then, note that $\norm{B_{[j]}}_2 = \norm{\text{vec}(B_{[j]})}_2$, where $\text{vec}(B_{[j]}) \in \mathbb{R}^{k^2}$ is the vector obtained by stacking all the elements of $B_{[j]}$ in one column. 
Since $\pi (B_{[j]})$ depends just on $\norm{B_{[j]}}_2$, it is possible to compute its conjugate function starting from $\text{vec}(B_{[j]})$. Now, we can use the result in \emph{Proposition 1} of \cite{boschi2021highly}, where the authors compute the elastic-net penalty conjugate function for a vector of dimension $k$. Following their proof, and incorporating the adaptive weights $\omega$'s in the penalty parameters $\la_1$ and $\la_2$, we obtain:
% 
\begin{equation*}
\small
%	p^*(Z) =  (2\la_2)^{-1} \sum_{i=1}^p  \left(\big[\norm{Z_i}_2 - \la_1\big]_{+}\right)^2 
	\pi^*(Z) =  \sum_{j=1}^p (2\omega_j\la_2)^{-1}
		\begin{cases}
			\big(\norm{\text{vec}(Z_{[j]})}_2 - \omega_j\la_1\big)^2  & \norm{\text{vec}(Z_{[j]})}_2 > \omega_j\la_1 \\
			0  & o.w.
		\end{cases} \ .
\end{equation*}
% 
This concludes the proof since, once again, we have $\norm{\text{vec}(Z_{[j]})}_2 = \norm{Z_{[j]}}_2$.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Proposition 2
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Proposition 2}
\label{subsec:proof_prop2}

$\pi(B) = \sum_{j=1}^p \pi (B_{[j]})$ is a separable sum, then 
$\prox_{\sa \pi}(B) =  \big(\prox_{\sa \pi}(B_{[1]}), 	\dots, \prox_{\sa \pi}(B_{[p]}) \big)^T$ \citep{beck2017first} (Remark~6.7).
For a generic vector $a$, we have $\prox_{\sa \la_1 \norm{\cdot}_2}(a) = \big[ 1 - \norm{a}_2^{-1} \sa \la_1 \big]_+ a$ \citep{fan2016high}, and $\prox_{(\sa \la_2/2)\norm{\cdot}_2^2}(a) = (1 + \sa \la_2)^{-1}a$ \citep{beck2017first} (6.2.3). Following the same reasoning of the previous proof, it is possible to extend these results to a generic matrix $A$ and including the weights $\omega$'s in the penalty parameters $\la_1$ and $\la_2$.
Next, note $\norm{\cdot}_2^2$ is a proper closed and convex function. Thus, we can compose $\prox_{(\sa \omega_j \la_2/2)\norm{\cdot}_2^2}$ and $\prox_{\sa \omega_j \la_1\norm{\cdot}_2}$ as described in \citet{parikh2014proximal}, obtaining:
%
\begin{equation*}
\small
% \label{eq:prox_final_result}
	\prox_{\sigma \pi}(B_{[j]}) =  (1 + \sa \omega_j \la_2)^{-1} \left[1- \norm{B_{[j]}}_2^{-1} \sa \omega_j \la_1  \right]_{+} B_{[j]}  \ .	
\end{equation*}
% 
Next, we prove $\bar Z =  \prox_{\pi^*/\sa} \big( B/\sa - X^T \bar V \big)$.
Computing the derivative of $\mathcal{L}_\sa \left(\bar Z, \bar V, B \right)$ as defined in \eqref{eq:augmented_lagrangian} with respect to $Z_{[j]}$, and setting it equal to 0, we have: 
%
\begin{equation*}
\small
% \label{eq:grad_L_Z}
	B_{[j]} / \sa - \bar V^T X_{[j]} - \bar Z_{[j]} = \nabla \pi^*(\bar Z_{[j]}) / \sa
\end{equation*}
%
Setting $t = B_{[j]} / \sa - \bar V^T X_{[j]} $, $u = \bar Z_{[j]}$, and $f = \pi^* / \sa$, we have $t - u = \nabla f(u)$. By the sub-gradient proximal operators characterization \citep{correa1992subcharacterization}, we can state $u = \prox_f(t)$, i.e.: $\bar Z_{[j]} =  \prox_{\pi^*/\sa} \big( B_{[j]}/\sa - X_{[j]}^T \bar V \big)$. Next, note $\bar Z = (\bar Z_{[1]}, \dots, \bar Z_{[p]})^T$.

The last equality of \emph{Proposition 2} follows by the \emph{Moreau decomposition}. Indeed, for a generic matrix $A$, we have:
$A = \prox_{\sa p}(A) + \sa \prox_{\pi^*/\sa}(A/ \sa)$, $\sa > 0$.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Theorem 1 
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Theorem 3}
\label{subsec:proof_theorem1}

Recall $T=B-\sa X^T V$, which means $T_{[j]} = B_{[j]} - \sa V^T X_{[j]}$, and $\Bar{Z} = T/\sa - \prox_{\sa p}\left(T \right)/\sa$. \\

\noindent 
\textbf{\emph{(i)}}~~ We need to compute $\psi(V) = \mathcal{L}_\sigma (V\,|\,\Bar{Z},B)$.
Plugging $\Bar{Z}$ in \eqref{eq:augmented_lagrangian}, we get: 
% 
\begin{align}
    \small
    \label{eq:psi_medium}
    \begin{split}
        \psi(V) &= h^*(V) + \pi^*(\bar Z) - 
        \frac{1}{\sa} \sum_{j=1}^p \langle B_{[j]}, B_{[j]} \rangle 
        +  \frac{1}{\sa} \sum_{j=1}^p \langle B_{[j]}, \prox_{\sa \pi}\big( T_{[J]} \big) \rangle +
        \frac{1}{2\sa} \sum_{j=1}^p \lVert B_{[j]} -\prox_{\sa \pi}\big( T_{[J]}\big) \rVert_2^2 = \\
        & = h^*(V) + \pi^*(\bar Z) + \frac{1}{2 \sa} \sum_{j=1}^p \normbig{\prox_{\sa \pi}\big(T_{[j]} \big)}_2^2 - \frac{1}{2\sa} \sum_{j=1}^p\norm{B_{[j]}}_2^2 \ .
    \end{split}
\end{align}
% 
Next, we compute $\pi^*(\bar Z) = \sum_{j=1}^p \pi^* (\bar Z_{[j]})$. Note, the explicit form of $\bar Z_{[j]}$ is:
% 
\begin{equation*}
\small
% \label{eq:prox_star_explicit}
	\bar Z_{[j]} = T_{[j]}/\sa - \prox_{\sa \pi} \big(T_{[j]} \big) /\sa =  
		\begin{cases}
			(1 + \sa \omega_j \la_2)^{-1} \big(\omega_j \la_2 + \norm{T_{[j]}}_2^{-1} \omega_j \la_1 \big) T_{[j]} & \norm{T_{[j]}}_2 > \sa \omega_j \la_1 \\
			T_{[j]}/\sa & o.w.
		\end{cases} \ .
\end{equation*}
% 
We focus on the case $\norm{\bar Z_{[j]}}_2 > \omega_j\la_1$, i.e. where $\pi^* (\bar Z_{[j]}) \neq 0$. Note, this implies $\norm{ T_{[j]}}_2 > \sa \omega_j\la_1$, i.e.~$\prox_{\sa \pi} \big(T_{[j]} \big) \neq 0$. Plugging the explicit form of $\bar Z_{[j]}$ in the definition of $\pi^*$ given in \eqref{eq:p_star}, we have:
\begin{align*}
\small
    % \label{eq:psi_y_z_bar}
    \begin{split}
        \pi^* (\bar Z_{[j]}) & = (2\omega_j\la_2)^{-1} \left((1 + \sa \omega_j \la_2)^{-1} \big(\omega_j \la_2 + \norm{T_{[j]}}_2^{-1} \omega_j \la_1 \big) \normbig{T_{[j]}}_2 - \omega_j\la_1 \right)^2 = \\
        & = (\omega_j\la_2 / 2) \left((1 + \sa \omega_j \la_2)^{-1} \left(\norm{ T_{[j]}}_2 - \sa \omega_j \la_1 \right) \right)^2 
    \end{split}
\end{align*}
Furthermore, starting from the definition of $\prox_{\sa \pi}$ given in \eqref{eq:prox_op}, we have: 
\begin{align*}
\small
    % \label{eq:psi_y_z_bar}
    \begin{split}
        \norm{\prox_{\sa \pi}\left(T_{[j]}\right)}_2^2 & = \left( (1 + \sa \omega_j \la_2)^{-1} \left(1- \norm{T_{[j]}}_2^{-1} \sa \omega_j \la_1 \right) \norm{T_{[j]}}_2 \right)^2 = \\
        & = \left((1 + \sa \omega_j \la_2)^{-1} \left(\norm{ T_{[j]}}_2 - \sa \omega_j \la_1 \right) \right)^2
    \end{split}
\end{align*}
%
Thus, we have $\pi^* (\bar Z_{[j]}) = (\omega_j\la_2 / 2) \norm{\prox_{\sa \pi}\left(T_{[j]}\right)}_2^2$, which leads to $\pi^* (\bar Z) = \sum_{j=1}^p (\omega_j\la_2 / 2) \norm{\prox_{\sa \pi}\left(T_{[j]}\right)}_2^2$. Plugging $\pi^* (\bar Z)$ in \eqref{eq:psi_medium} concludes the proof. \\

\noindent 
\textbf{\emph{(ii)}}~~ We have $\nabla h^*(V) = Y + V$. Thus, to prove \emph{(ii)}, it is sufficient to show: 
{\small 
$$\nabla_V \left(\frac{1}{2\sa} \sum_{j=1}^p \left( 1 + \sa \omega_j \la_2 \right) \normbig{\prox_{\sa \pi}\big(T_{[j]}\big) }_2^2\right) = - X \prox_{\sa \pi}(T)$$
}
Before, proceeding note that: 
% \begin{itemize}
%     \item $\nicefrac{\partial \prox_{\sa \pi}\left(T_{[j]}\right)}{\partial T_{[j]}} =  (1 + \sa \omega_j \la_2)^{-1}, \ $ since $\nicefrac{\partial \prox_{\sa \pi}\left(\norm{T_{[j]}}_2^{-1} T_{[j]}\right)}{\partial T_{[j]}} = 0$
%     \item $\nicefrac{\partial T_{[j]}}{\partial V} = -\sa X_{[j]}$
% \end{itemize}
\begin{equation*}
    \nicefrac{\partial T_{[j]}}{\partial V} = -\sa X_{[j]} \text{~~and~~} \nicefrac{\partial \prox_{\sa \pi}\left(T_{[j]}\right)}{\partial T_{[j]}} =  (1 + \sa \omega_j \la_2)^{-1} 
\end{equation*}
% 
The second equality holds because $\nicefrac{\partial \prox_{\sa \pi}\left(\norm{T_{[j]}}_2^{-1} T_{[j]}\right)}{\partial T_{[j]}} = 0$. We can now apply the chain rule for derivatives: 
\begin{align*}
\small
    % \label{eq:psi_y_z_bar}
    \begin{split}
        \nabla_V & \left(\frac{1}{2\sa} \sum_{j=1}^p \left( 1 + \sa \omega_j \la_2 \right) \normbig{\prox_{\sa \pi}\big(T_{[j]}\big) }_2^2\right) = 
        \\
        & = \frac{1}{\sa} \sum_{j=1}^p \left( 1 + \sa \omega_j \la_2 \right)
        \nicefrac{\partial \norm{\prox_{\sa \pi}\left(T_{[j]}\right)}_2^2}{\partial \prox_{\sa \pi}\left(T_{[j]}\right)} \cdot
        \nicefrac{\partial \prox_{\sa \pi}\left(T_{[j]}\right)}{\partial T_{[j]}}\cdot
        \nicefrac{\partial T_{[j]}}{\partial V} = \\
        & = - \sum_{j=1}^p X_{[j]} \prox_{\sa \pi}\left(T_{[j]}\right) = 
        - X \prox_{\sa \pi}\left(T\right)
    \end{split}
\end{align*}
% 
where the last equality holds because $X$ and $T$ are both block matrices. \\

\noindent 
\textbf{\emph{(iii)}}~~ To prove \emph{(iii)} we need to find $H_\psi (V)$. We can compute it as follows: 
{\small
$$ H_\psi (V) = \nabla_V\big( \nabla \psi (V) \big) = I_{nk} + \nabla_V \big(-X \prox_{\sa \pi} (T) \big).$$
}
We just need to show $\nabla_V \big(-X \prox_{\sa \pi} (T) \big) = \sa \hat X_\mathcal{J} Q_\mathcal{J} \hat X_\mathcal{J}^T$. Before proceeding, note that: 
\begin{equation*}
\small
    \nabla_{\prox_\sa \pi (T)}\big(X \prox_{\sa \pi} (T) \big) = \left( X_\mathcal{J} \otimes_{Kron} I_k \right) \text{~~and~~} \nabla_{V}\big(X^T V\big) = \left( X \otimes_{Kron} I_k \right)^T.
\end{equation*}
Both equalities are a special case of the result $T4.6$ in \cite{brewer1978kronecker}. Applying the chain rule of derivative, we obtain:
\begin{align*}
\small
    % \label{eq:psi_y_z_bar}
    \begin{split}
       \nabla_V \big(-X \prox_{\sa \pi} (T) \big) & = - \nabla_{\prox_\sa \pi (T)}\big(X \prox_{\sa \pi} (T) \big) \cdot \nabla_{T} \big(\prox_{\sa \pi} (T) \big) \cdot
       \nabla_{V} \big(T\big) = \\
       & = \sa \left( X_\mathcal{J} \otimes_{Kron} I_k \right) \nabla_{T} \big(\prox_{\sa \pi} (T) \big) \left( X_\mathcal{J} \otimes_{Kron} I_k \right)^T.
    \end{split}
\end{align*}
% 
Note $\nabla_{T} \big(\prox_{\sa \pi} (T) \big) \in \mathbb{R}^{pk^2 \times pk^2}$ is a block diagonal matrix. Indeed, the blocks, each of dimension $k^2 \times k^2$, are given by $ \nabla_{T_{[s]}} \left(\prox_{\sa \pi}\left(T_{[j]} \right)\right)$ for $s,j = 1, \dots, p$ and are $0$ if $s\neq j$. \\

Consider the case $s=j=1$. If $\norm{T_{[1]}}_2 \leq \sa\omega_1\la_1$, then $ \nabla_{T_{[1]}} \left(\prox_{\sa \pi}\left(T_{[1]} \right)\right) = 0$. Otherwise, let $\vec T_1 = \text{vec}\left( T_{[1]} \right)$ be the gradient vectorization with elements $t_i, \dots, t_{k^2}$. Moreover, note that $\frac{\partial \norm{T_{[1]}}_2} {\partial t_i} = \norm{T_{[1]}}_2^{-1} t_i$.
Then, the element in position $(i,j)$ of $\nabla_{\vec T_1} \big(\prox_{\sa \pi}\big(\vec T_1 \big)\big)$ is given by:   
% 
\begin{equation*}
\small
\label{eq:delta_prox}
	\frac{ \partial \prox_{\sa \pi}(t_i)} {\partial t_j} = (1 + \sa \omega 1 \la_2)^{-1}
	\begin{cases}
		  1 - \sa \omega_1 \la_1 \norm{T_{[1]}}_2^{-1} + \sa \omega_1 \la_1 \norm{T_{[1]}}_2^{-3}  t_i^2   &  i = j \\
		  \sa \omega_1 \la_1 \norm{T_{[1]}}_2^{-3} t_i t_j &  i \ne j
	\end{cases} \ .
\end{equation*}
%
The last equations shows $\nabla_{T_{[1]}} \left(\prox_{\sa \pi}\left(T_{[1]} \right)\right) = P_{[1]}$. Without loss of generality, we have $\nabla_{T_{[j]}} \left(\prox_{\sa \pi}\left(T_{[j]} \right)\right) = P_{[j]}$, for $j = 1,\dots, p$.
Let $Q$ be the $pk^2 \times pk^2$ block diagonal matrix such that each block $Q_{[j]}$ is equal to $P_{[j]}$ if $j \in \mathcal{J} = \big\{ j~:~ \lVert T_{[j]} \rVert_2  \ge \sa \omega_j \la_1 \big\}$ and $0$ otherwise. We have $\nabla_{T} \big(\prox_{\sa \pi} (T) \big) = Q$ and
{\small
$$ H_{\psi}(V) = I_{nk} + \sa \left( X \otimes_{Kron} I_k \right) 
Q
\left( X \otimes_{Kron} I_k \right)^T \ . $$}
% 
Finally, we just note that given the form of $Q$ only the blocks in $\mathcal{J}$ are selected and involved in the matrix multiplication; therefore: 
{\small
$$
\sa \left( X \otimes_{Kron} I_k \right) 
Q
\left( X \otimes_{Kron} I_k \right)^T = \sa \hat X_\mathcal{J} Q_\mathcal{J} \hat X_\mathcal{J}^T \ .
$$
}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=
%
%  Scalar-on-Fucntion Model  
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{Appendix B. FASTeN extension to scalar-on-function regression}
\label{sec:supp_scalar}
% \setcounter{equation}{0}

The scalar-on-function regression model \citep{ramsay2005, kokoszka2017introduction} describes a scenario where the response is a scalar variable, while the features are curves.
Using the same notation introduced in Section \ref{sec:intro}, 
the scalar-on-function model with $n$ observations and $p$ features takes the following form:
% 
\begin{align}
\small
\label{eq:scalar_model}
\begin{split}
    Y_i = \sum_{j=1}^p \int_{\mathcal{T}} \mathcal{B}_j(t)\mathcal{X}_{ij}(t)~dt + \epsilon_i(t) \qquad i = 1, \dots, n \ .
\end{split}
\end{align}
% 
The model assumes that each feature $\mathcal{X}_j$ can affect the response vector $Y \in \mathbb{R}^n$ in a different way along the time domain. The coefficients $\mathcal{B}_j$ are curves and not surfaces as in the function-on-function framework. 
The \texttt{FAStEN} optimization problem has the form
%
\begin{align}
\small
\begin{split}
    % \small
    \label{eq:functional_minimization_problem_scalar}
    \min_{\mathcal{B}_1, \dots, \mathcal{B}_p} ~ \Bigg[ 
    \frac{1}{2} \Big\lVert~Y-\sum_{j=1}^p \int_{\mathcal{T}} \mathcal{B}_j(t)\mathcal{X}_{j}(t)~dt~\Big\rVert^2_2 +
    \sum_{j=1}^{p} \omega_j \left(
     \lambda_1 \lVert \mathcal{B}_j\rVert_{\mathbb{L}^2}+ 
     \frac{\lambda_2}{2}\lVert \mathcal{B}_j \rVert_{\mathbb{L}^2}^2 
    \right)  \Bigg] \ .
\end{split}
\end{align} 
% 
Note, the first loss of the minimization problem is the Euclidean-vector norm and not the functional $\mathbb{L}^2$ norm. 

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  Matrix representation
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{Matrix representation}
\label{subsec:matrix_scala_on_function}

One can use the FPCs of each feature $\mathcal X_j$ in order to obtain a matrix representation of \eqref{eq:functional_minimization_problem_scalar}.
Following the steps described in Section \ref{subsec:coeff_representation}, let us consider the simple case with just one feature $\mathcal{X}_1$. Let $e^1 = \left[e_1 ~ | ~ \dots ~ | ~ e_k \right]$ be the matrix containing the first $k$ FPCs of $\mathcal{X}_1$.
Let $X_{[1]} \in \mathbb{R}^{n \times k}$ be the score matrix of $\mathcal X_1$ with respect to $e^1$, and $B_{1} \in \mathbb{R}^{k}$ be the score vector of $\mathcal B_1$ with respect to the same basis system $e^1$. 
Then, we can approximate $\mathcal X_1(t) \approx X_{[1]}e^1(t)^T, ~ \mathcal B_1(t) \approx e^1(t)B_{1}$, and \eqref{eq:scalar_model} as
 %
 \begin{align*}
 \small
 \begin{split}
     Y \approx X_{[1]} \left(\int_{\mathcal{T}} e^1(t)^Te^1(t)~dt\right) B_{1} \ ,
 \end{split}
 \end{align*}
 %
Recalling that $\int e^1(t)^Te^1(t)dt = I_k$, this gives us
$Y \approx X_{[1]} B_{1}$. The extension to $p$ predictors is straightforward. 
Let us indicate the design matrix as $X = \left[X_{[1]} | \dots | X_{[p]} \right] \in \mathbb{R}^{n \times pk}$,
the coefficient vector as $B = \left(B_{1}^T, \dots , B_{p}^T \right)^T \in \mathbb{R}^{pk}$. Thus, model  \eqref{eq:scalar_model} can be approximated as $ Y \approx X B $, and the matrix representation of the minimization problem \eqref{eq:functional_minimization_problem_scalar} is:
%
 \begin{equation}
 \small
     \label{eq:matrix_minimization_problem_scalar}
     \min_{B} \frac{1}{2}\lVert Y-XB\rVert_{2}^2 + \sum_{j=1}^{p} \omega_j \left( \lambda_1 \lVert B_{j}\rVert_{2}+\frac{\lambda_2}{2} \lVert B_{j}\rVert_{2}^2 \right) \ .
 \end{equation}
%
The only differences with respect to the matrix representation of the function-on-function scenario \eqref{eq:matrix_minimization_problem} are the dimensions of $Y$ and $B$. Once an estimate $\hat B$ of the score vector is obtained, one can recover the coefficient curves as
% 
\begin{equation*}
\small
\label{eq:from_B_to_funB_scalar}
\hat{\mathcal B}_j(t) = e^j(t)\hat B_j(t) \ \ \ j=1,\dots,p \ .
\end{equation*}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%  FAStEN implementation
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\subsection{FAStEN implementation}

Here we describe how to implement the \texttt{FAStEN} algorithm for the scalar-on-function minimization problem. \\

\noindent
\emph{Primal and Dual formulation.} The primal and dual formulation of the minimization problem \eqref{eq:matrix_minimization_problem_scalar} are 
% 
\begin{align*}
 \small
 \begin{split}
       \min_B h(XB) + \pi(B) \ \ \ \ \text{and} \ \ \ \ \min_{V,Z} h^*(V) + \pi^*(Z) \ \ s.t. \ \ X^TV+Z=0 \ ,
 \end{split}
 \end{align*}
%  
respectively. $h(XB)= \frac{1}{2}\lVert Y-XB\rVert_{2}^2$, $ \ \pi(B) = \sum_{j=1}^{p} \omega_j 
\left( \lambda_1 \lVert B_{j}\rVert_{2} +\frac{\lambda_2}{2} \lVert B_{j}\rVert_{2}^2 \right)$. $ \ V\in\mathbb{R}^{n}$ and $Z\in\mathbb{R}^{pk}$ are the vector dual variables. Using the same notation introduced for $B$, we can write $Z = \left(Z_1^T, \dots , Z_{p}^T \right)^T$, where $Z_{j}\in \mathbb{R}^{k}$ is the sub-vector of $Z$ associated with the $j$-th feature. The conjugate function $h^*$ has the form $h^*(V) = \frac{1}{2}\lVert V\rVert_2^2 + Y^T V$, while the from of $\pi^*$ is given in the next paragraph. \\

\noindent
\emph{Conjugate function and proximal operator.} Both the conjugate function $\pi^*$ and the proximal operator $\prox_{\sa \pi}$ depends on the sub-vectors $Z_j$ and $B_j$, respectively. Thus, we can use the results in \cite{boschi2021highly}, where these mathematical operators have been computed for vectors in the case of the function-on-scalar regression model. Specifically, we can incorporate the weights $\omega$'s in the penalty parameters $\la_1$ and $\la_2$, and obtain: 
%
\begin{align*}
 \small
 \begin{split}
       \pi^*(Z) = \sum_{j=1}^p \pi^*(Z_j) =  \sum_{i=1}^p  (2 \omega_j \la_2)^{-1} \left(\big[\norm{Z_j}_2 - \omega_j\la_1\big]_{+}\right)^2 \ ,
 \end{split}
 \end{align*}
%
and $\prox_{\sigma \pi}(B) = \big(\prox_{\sigma \pi}(B_1)^T, \dots, \prox_{\sigma \pi}(B_p)^T \big)^T$, where     
%
\begin{align*}
 \small
 \begin{split}
      \prox_{\sigma \pi}(B_j) =  (1 + \sa \omega_j \la_2)^{-1} \left[1- \norm{B_j}_2^{-1} \sa \omega_j \la_1  \right]_{+} B_j.
 \end{split}
 \end{align*}
% 
Note, $\pi^* : \mathbb{R}^{pk} \rightarrow \mathbb{R}$ and  $\prox_{\sigma \pi}(B) : \mathbb{R}^{pk} \rightarrow\mathbb{R}^{pk}$. To compute $\prox_{\pi^*/\sa}(B)$, one can use the {Moreau decomposition}:
$\prox_{\pi^*/\sa} \left(B\right) = B/\sa - \prox_{\sa p}\left(B\right)/\sa$. \\

\noindent
\emph{Dual Augmented Lagrangian and KKT.} The Dual Augmented Lagrangian is 
% 
\begin{align*}
\small
\begin{split}
    % \label{eq:augmented_lagrangian}
    \mathcal{L}_\sigma (V,Z,B) =  h^*(V) + \pi^*(Z) - 
     \sum_{j=1}^p \langle B_{j}, X_{[j]}^T V + Z_{j} \rangle + 
    \frac{\sigma}{2} \sum_{j=1}^p \lVert X_{[j]}^T V + Z_{j}\rVert_2^2
\end{split}
\end{align*}
% 
The KKT equations have the same form of \eqref{eq:kkt} but the arguments have different dimensions. \\

\noindent
\emph{Z update}. Following the same steps of Proposition \ref{prop:z_update} proof, it is possible to show that: 
%  
\begin{align*}
\small
\begin{split}
    % \label{eq:augmented_lagrangian}
    \Bar{Z} = \arg\min_Z \mathcal{L}_\sigma (Z\,|\,\Bar{V},B) = \prox_{\pi^*/\sa} \left(B/\sa - X^T\Bar{V} \right).
\end{split}
\end{align*} 
% 

\noindent
\emph{V update}. To update V, we perform the Newton method: $V^{m+1} = V^m + D$, where $D \in \mathbb{R}^{n}$ is the descent direction computed by solving the linear system
%
\begin{equation*}
\small
% \label{eq:newton_direction}
    H_{\psi}(V) D = -\nabla \psi (V) \ .
\end{equation*}
%
$H_{\psi} \in \mathbb R^{n \times n}$ is the Hessian matrix, 
$\nabla \psi \in \mathbb R^{n}$ is the gradient vector. Note that, differently from function-on-function case, the the dimension of the Hessian and the gradient does not depend on $k$. The following result is the equivalent of Theorem \ref{th:v_update}. The proof follows the same steps, but in this case we are dealing with lower order tensors and operators. 
% 
\begin{proposition}
% \label{th:v_update}
Let $T=B-\sa X^T V$, $T_{j}=B_{j} - X_{[j]}^T V$, $\mathcal{J} = \big\{ j~:~ \lVert T_{j} \rVert_2  \ge \sa \omega_j \la_1 \big\}$, and $r = |\mathcal{J}|$ be the cardinality of $\mathcal{J}$.
Next, let $ X_\mathcal{J} \in \mathbb{R}^{n \times rk}$ be the sub-matrix of $X$ restricted to the blocks $X_{j}$, 
%and  
$j \in \mathcal{J}$.
Define the squared $k \times k$ matrix 
    \begin{equation*}
    \small
    % \label{eq:P_j}
        P_{[j]} = (1 + \sa \omega_j \la_2)^{-1} \left( \left(1 -
        \frac{\sa \omega_j \la_1}{ \norm{T_{[j]}}_2} \right) I_{k^2} +
        \frac{\sa \omega_j \la_1}{ \norm{T_{j}}_2^3} 
        T_{j}T_{j}^T \right) \ .
    \end{equation*}
Finally, let $Q_\mathcal{J} \in \mathbb{R}^{rk \times rk}$ be the block-diagonal matrix formed by the blocks $P_{[j]}$, $j \in \mathcal{J}$.
%
Then
%:
  \begin{align*}
    \small
    % \label{eq:psi_y_z_bar}
    \begin{split}
        &(i)~ \  \ \psi(V) = h^*(V) + \frac{1}{2\sa}  \sum_{j=1}^p 
        \left( \left( 1 + \sa \omega_j \la_2 \right) \normbig{\prox_{\sa \pi}\big(T_{j}\big) }_2^2 - \norm{B_{j}}_2^2 \right) \\ 
        &(ii)~ \ \nabla \psi(V) = V + Y - X \prox_{\sa \pi}(T) \\
        &(iii)~H_{\psi}(V) = I_{n} + \sa X_\mathcal{J} Q_\mathcal{J} X_\mathcal{J}^T \ .
    \end{split}
    \end{align*}
\end{proposition}
% 
\vspace{0.4cm}
\noindent
\emph{Computational cost.} Selecting a subset of active $r$ features at each iteration reduces the total cost of solving the linear system from $\mathcal{O} \l( n(n^2 + npk + p^2k^2) \r)$ to $\mathcal{O} \l( n(n^2 + nrk + r^2k^2) \r)$.
When $r$ is smaller than $n$, one can perform the inversion through the \emph{Sherman-Morrison-Woodbury} formula:
\begin{align*}
    \small
    \begin{split}
       \left(I_{n} + \sa X_\mathcal{J} Q_\mathcal{J} X_\mathcal{J}^T \right)^{-1} = 
       I_{n} -  X_\mathcal{J}  \left( \l( \sa Q_\mathcal{J} \r)^{-1} + X_\mathcal{J}^T X_\mathcal{J} \right)^{-1} X_\mathcal{J}^T
    \end{split}
\end{align*}
which allows one to factorize an $rk \times rk$ matrix. The total cost is now $\mathcal{O} \l( rk(k^2 + nrk + r^2k^2 + n^2) \r)$.



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=
%
%  Concurrent Model  
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \section{Appendix C. FASTeN extension to concurrent functional regression}
% \label{sec:supp_concurrent}
% % \setcounter{equation}{0}

% The functional concurrent regression model \citep{ramsay2005, kokoszka2017introduction} can be seen as a special case of the varying coefficient model \citep{fan1999statistical, fan2008statistical}. It tackles a scenario where both the response and the features are functions. Differently from the function-on-function model, it implies that each feature at time $t$ affects the response just at time $t$ -- and not on its whole domain. 
% The concurrent regression model with $n$ observations and $p$ features takes the form:
% % 
% \begin{align}
% \small
% \label{eq:concurrent_model}
% \begin{split}
%     \mathcal{Y}_i(t) = \sum_{j=1}^p \mathcal{B}_j(t)\mathcal{X}_{ij}(t) + \epsilon_i(t) \qquad i = 1, \dots, n \ .
% \end{split}
% \end{align}
% % 
% The main difference with respect to the function-on-function model concerns the form of the estimated coefficients. Here, the coefficients are curves and not surfaces. We assume $\mathcal{B}_j \in \mathbb{L}^2(\mathcal T)$. 
% For this model, the \texttt{FAStEN} optimization problem is given by
% %
% \begin{align}
% \small
% \begin{split}
%     % \small
%     \label{eq:functional_minimization_problem_concurrent}
%     \min_{\mathcal{B}_1, \dots, \mathcal{B}_p} ~ \Bigg[ 
%     \frac{1}{2} \Big\lVert~\int_{\mathcal T} \Big(\mathcal{Y}-\sum_{j=1}^p \mathcal{B}_j\mathcal{X}_j\Big)~dt~\Big\rVert_{2}^2 +
%     \sum_{j=1}^{p} \omega_j \left(
%      \lambda_1 \lVert \mathcal{B}_j\rVert_{\mathbb{L}^2}+ 
%      \frac{\lambda_2}{2}\lVert \mathcal{B}_j \rVert_{\mathbb{L}^2}^2 
%     \right)  \Bigg] \ .
% \end{split}
% \end{align} 
% % 
% Note that we are replacing the standard $\mathbb{L}^2$ least square regression loss with the euclidean norm of the integral loss between the response function and its prediction. This specific loss leads to a matrix representation easily tractable by \texttt{FAStEN} -- as we will see in the following subsection. 

% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% %  Matrix representation
% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \subsection{Matrix representation}

% Once more, let us consider the simple case with just one feature $\mathcal{X}_1$. Let $e = \left[e_1 ~ | ~ \dots ~ | ~ e_k \right]$, $X_{[1]} \in \mathbb{R}^{n \times k}$, and $B_{1} \in \mathbb{R}^{k}$ be defined exactly as in Section \ref{subsec:matrix_scala_on_function}.
% Again, we can approximate $\mathcal X_1(t) \approx X_{[1]}e(t)^T, ~ \mathcal B_1(t) \approx e(t)B_{1}$. We can rewrite the new-defined regression loss as
%  %
%  \begin{align*}
%  \small
%  \begin{split}
%      \int_{\mathcal{T}} \mathcal Y(t)~dt \approx \int_ {\mathcal{T}} \left( X_{[1]} e(t)^Te(t)\ B_{1} \right)~dt \ .
%  \end{split}
%  \end{align*}
%  %
% Let us define $Y = \int_{\mathcal{T}} \mathcal Y(t)dt$. Note, $Y\in \mathbb{R}^n$.
% Since $\int e(t)^Te(t)dt = I_k$, this leads us to
% $Y \approx X_{[1]} B_{1}$. 
% In case of $p$ predictors, $X$ and $B$ are defined as in Section \ref{subsec:matrix_scala_on_function} for the scalar-on-function case. Thus, the matrix expression of \eqref{eq:functional_minimization_problem_concurrent} is given by \eqref{eq:matrix_minimization_problem_scalar} and, similarly, one can recover the coefficient curves as $\hat{\mathcal B}_j(t) = e(t)\hat B_j, \ j=1,\dots,p \ $.

% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% %  FAStEN implementation
% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \subsection{FAStEN implementation}

% Note that the concurrent model with the integral loss and the scalar-on-function model share the same matrix representation of the minimization problem. Therefore, the \texttt{FAStEN} implementation of the two models is the same.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%   Simulation and AOMIC appendix 
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \newpage
% \section{Appendix D. Additional Simulation results}
% \label{sec:supp_additional_sim_res}
% \setcounter{equation}{0}

% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% %   Simulation settings
% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \subsection{Simulation settings}
% \label{sec:simulation_settings_supp}

% We generate the response additively according to \eqref{eq:fof_problem}. Each feature $\mathcal{X}_{j}$, as well as the error $\epsilon$, are drawn from a $0$ mean Gaussian process with a Matrn covariance function \citep{cressie1999classes} of the form
% %
% \begin{equation*}
% \small
% \begin{split}
%         C(t,s) = \frac{\eta^2}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} \lvert t-s \rvert\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} \lvert t-s \rvert \Bigg)
% \end{split}
% \end{equation*}
% %
% where $K_\nu$ is a modified Bessel function. For the $\mathcal X$'s we use point-wise variance $\eta^2=1$, range $l=0.25$ and smoothness parameter $\nu=3.5$. 
% For $\epsilon$ we use $l=0.25$, $\nu=2.5$, and assume the variance $\eta^2_\epsilon$ to be the same across the entire time domain. The value of $\eta^2_\epsilon$ is set as a function of the \emph{signal-to-noise ratio (snr)} we define for different simulation scenarios. Specifically, we take $\eta^2_\epsilon = \text{var}(\mathcal Y_{true}))/\text{snr}$, where $\text{var}(\mathcal Y_{true})$ is the global variance of the response $\mathcal Y$, and consider $snr$ = $1, 10, 100$. Scenarios are harder, from the perspective of both selection and estimation, the smaller their $\text{snr}$.

% For each scenario, $p_0$ indicates the number of active features, i.e.~non-zero regression coefficient surfaces. We generate these surfaces from a mixture of bivariate Gaussian distributions under two regimes of complexity. The \emph{easy} regime is characterized by a single peak with standard deviation randomly drawn from a uniform distribution on $[0.2,0.3]$. The \emph{difficult} regime is characterized by 2 or 3 peaks with standard deviations randomly drawn from a uniform on $[0.01,0.15]$.
% In all scenarios, \texttt{FAStEN} is run with tolerances set to $10^{-6}$, starting from $\sigma^0=p_0/p$ and increasing by a factor of 5 at each iteration. 
% Following standard practice in the literature \citep{friedman2010regularization, pedregosa2011scikit} we write $\lambda_1=\alpha c_\lambda\lambda_{max}$ and $\lambda_2=(1-\alpha)c_\lambda\lambda_{max}$, with $c_\lambda\in(0, 1]$ and $\alpha\in(0, 1)$. $c_\lambda$ determines the reduction with respect of $\lambda_{max}$, while $\alpha$ controls the relative weight of the two penalties. We set $\alpha=0.2$. Finally, regarding $k$, we chose the smallest number of FPC's which explains over $90\%$ of variability of the response $\mathcal Y(t)$. For all scenario considered, the selected $k$
% is either 3 or 4.

% Before running \texttt{FAStEN} we standardize the response and each feature individually. For any instance of any functional variable, say $\mathcal V(t)$ for simplicity, we create a standardized version as $\left(\mathcal V(t) - \text{ave}(t) \right) / \text{sd}(t)$, where $\text{ave}(t)$ and ${sd}(t)$ are the point-wise average and standard deviation of all the instances computed at each $t$.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%   Extra plots
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

% \begin{figure}[h]
%     % \centering
%     \hspace*{-2.1cm}
%     \includegraphics[width=1.3\textwidth]{gfx/time_adaptive.pdf}
%     \vspace*{-0.2cm}
%     \caption{
%     Time comparison under different simulation scenarios for \texttt{FAStEN} with adaptive step and cross-validation (cv) as metric. Simulations are run 10 times, with $m=600$ and different values of $n\in\{500,1000,2000,8000\}$, signal-to-noise ratio equal to 1, different numbers of active features (5, 10, 20, 40) and difficult regime of coefficient complexity}
%     \label{fig:time_by_n_supplement}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.9\textwidth]{gfx/5betas.pdf}
%     \caption{
%     {\red FOR LORENZO: ADD RIGHT SIMULATIONS SETTINGS AND UPDATE FIGURE}
%     True (bottom row) and estimated (top row) coefficient surfaces {\red (simulation parameters $seed=20$, $n=600$, $p=8000$, $p_0=5$, $snr=10$, ``easy'' coefficients).}
%     }
%     \label{fig:5betas}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{gfx/adaptive_path_coef_estimation.pdf}
%     \caption{Adaptive path coefficient estimates at different iterations (5,10,20), along with true coefficient surface. Simulation settings: }
%     \label{fig:adaptive_path_coef_estimation}
% \end{figure}

%\begin{figure*}[h]
 %   \centering
  %  \includegraphics[width=\linewidth]{gfx/cv_no_adaptive.pdf}
   % \caption{Performance comparison between fully adaptive \texttt{FAStEN} and basic, non-adaptive \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion. Simulations are run 10 times, with $m=600$, $n=8000$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20, 40) and coefficient complexity regimes (easy, difficult). Each of the ten panels shows results for an evaluation metric (left to right; selection as false negatives and false positives, estimation, prediction and computational burden) and a coefficient complexity regime (top, easy; bottom difficult). Within the cells of each panel, the first and second rows contain average scores (across simulations) for fully adaptive \texttt{FAStEN} and non-adaptive \texttt{FAStEN}. Those scores are rimmed in cyan if the absolute value of their difference exceeds a threshold (3 for false negatives and false positives, 0.05 for estimation and prediction standardized MSE's, and 5 seconds for time). The background of each cell color-codes the difference between fully adaptive and non-adaptive \texttt{FAStEN} average scores, divided by the standard deviation of the latter -- the color scale is provided on the right of each panel. The scales differ across panels, but in general a color associated to the negative part of the scale represents a better performance for fully adaptive \texttt{FAStEN}. The estimation task here is performed only on true positive features, i.e. we don't measure estimation quality on potential false positives.
%    }
%    \label{fig:cv_no_adaptive}
%\end{figure*}

%\begin{figure*}[h]
%    \centering
%    \includegraphics[width=\linewidth]{gfx/cv_gcv.pdf}
%    \caption{Performance comparison between fully adaptive \texttt{FAStEN} with cross-validation (\textit{cv}) and with generalized cross validation (\textit{gcv}) as criterion. Simulation parameters, and structure and interpretation of panels and colors   are the same as in Figure \ref{fig:cv_no_adaptive}. 
%    }
%    \label{fig:cv_gcv}
%\end{figure*}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{gfx/cv_no_adaptive_supplement.pdf}
%     \caption{
%     Performance comparison between fully adaptive \texttt{FAStEN} and basic, non-adaptive \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion. Simulation parameters, and structure and interpretation of panels and colors   are the same as in Figure \ref{fig:cv_no_adaptive}. {\red TO FIX!!!}
%     % Performance comparison under different metrics between \texttt{FAStEN} with adaptive step and basic (no adaptive) \texttt{FAStEN}, both with cross-validation (cv) as metric. Simulations are run 10 times, with $m=600$, $n=2000$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20, 40) and coefficient complexity regimes (easy, difficult). Each of the ten outer boxes shows the results for a metric and a coefficient complexity regime. The first row in each inner square indicates the average score across simulations for \texttt{FAStEN} with adaptive step, while the second row indicates the average score across simulations for basic no adaptive \texttt{FAStEN}. The edgecolor of the white boxes containing those two numbers is cyan if the absolute value of the difference among those scores is greater than a given quantity, which clearly depends on the metric under analysis. For false negatives and false positives the threshold quantity is 3, for MSE of beta and of response the threshold quantity is 0.05, for time it is 5 seconds. Each inner square is further filled by a color depending on the difference between the average score across simulations for \texttt{FAStEN} with adaptive step and the average score across simulations for basic no adaptive \texttt{FAStEN}, divided by the standard deviation of the latter. The scale of this z score is represented on the right of each outer box. Notice that scales differ across outer boxes, and in general a color associated to the negative part of the colormap represents a better performance for \texttt{FAStEN} with adaptive step. The estimation task is performed only on true positive features, i.e. it does not account for eventual false positives.
%     }
%     \label{fig:cv_no_adaptive_supplement}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{gfx/cv_gcv_supplement.pdf}
%     \caption{
%     Performance comparison between fully adaptive \texttt{FAStEN} with cross-validation (\textit{cv}) and with generalized cross validation (\textit{gcv}) as criterion. Simulation parameters, and structure and interpretation of panels and colors   are the same as in Figure \ref{fig:cv_no_adaptive}. {\red TO FIX IT!}
%     % Performance comparison under different metrics between \texttt{FAStEN} with adaptive step with cross-validation (cv) and generalized cross validation (gcv) as metrics. Simulations are run 10 times, with $m=600$, $n=2000$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20, 40) and coefficient complexity regimes (easy, difficult). Each of the ten outer boxes shows the results for a metric and a coefficient complexity regime. The first row in each inner square indicates the average score across simulations for \texttt{FAStEN} evaluated by cv, while the second row indicates the average score across simulations for \texttt{FAStEN} evaluated by gcv. The edgecolor of the white boxes containing those two numbers is cyan if the absolute value of the difference among those scores is greater than a given quantity, which clearly depends on the metric under analysis. For false negatives and false positives the threshold quantity is 3, for MSE of beta and of response the threshold quantity is 0.05, for time it is 5 seconds. Each inner square is further filled by a color depending on the difference between the average score across simulations for \texttt{FAStEN} evaluated by cv and the average score across simulations for \texttt{FAStEN} evaluated by gcv, divided by the standard deviation of the latter. The scale of this z score is represented on the right of each outer box. Notice that scales differ across outer boxes, and in general a color associated to the negative part of the colormap represents a better performance for \texttt{FAStEN} evaluated by cv. The estimation task is performed only on true positive features, i.e. it does not account for eventual false positives.
%     }
%     \label{fig:cv_gcv_supplement}
% \end{figure}

%\begin{figure}[h]
%    \centering
%    \includegraphics[width=\textwidth]{gfx/cv_tobia.pdf}
%    \caption{
%    Performance comparison between fully adaptive \texttt{FAStEN} and soft adaptive \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion.
%    Simulation parameters, and structure and interpretation of panels and colors are the same as in Figure \ref{fig:cv_no_adaptive}. 
    % Performance comparison under different metrics between \texttt{FAStEN} with full adaptive and soft adaptive with cross-validation (cv) as metric. Simulations are run 10 times, with $m=600$, $n=8000$, different signal-to-noise ratios (1, 10, 100), number of active features (5, 10, 20, 40) and coefficient complexity regimes (easy, difficult). Each of the ten outer boxes shows the results for a metric and a coefficient complexity regime. The first row in each inner square indicates the average score across simulations for \texttt{FAStEN} with full adaptive, while the second row indicates the average score across simulations for \texttt{FAStEN} with soft adaptive. The edgecolor of the white boxes containing those two numbers is cyan if the absolute value of the difference among those scores is greater than a given quantity, which clearly depends on the metric under analysis. For false negatives and false positives the threshold quantity is 3, for MSE of beta and of response the threshold quantity is 0.05, for time it is 5 seconds. Each inner square is further filled by a color depending on the difference between the average score across simulations for \texttt{FAStEN} with full adaptive and the average score across simulations for \texttt{FAStEN} with soft adaptive, divided by the standard deviation of the latter. The scale of this z score is represented on the right of each outer box. Notice that scales differ across outer boxes, and in general a color associated to the negative part of the colormap represents a better performance for \texttt{FAStEN} with full adaptive. The estimation task is performed only on true positive features, i.e. it does not account for eventual false positives.
%    }
%    \label{fig:cv_tobia}
%\end{figure}

\begin{figure}[h]
    \centering
    \vspace*{-1.3cm}
    \includegraphics[width=1\linewidth]{figure5.pdf}
    \vspace*{-0.6cm}
    \caption{Performance comparison between: fully adaptive \texttt{FAStEN} and basic, non-adaptive \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion (panel A); fully adaptive \texttt{FAStEN} with cross-validation (\textit{cv}) and with generalized cross validation (\textit{gcv}) as criterion (panel B); fully adaptive \texttt{FAStEN} and soft adaptive \texttt{FAStEN}, both with cross-validation (\textit{cv}) as criterion (panel C). Simulation parameters, and structure and interpretation of
    %panels 
    tables and colors are the same as in Figure \ref{fig:cv_competitor}.
    }
    \label{fig:all_sim_supp}
\end{figure}


% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=
% %
% %  AOMIC APPENDIX
% %
% %-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
% \newpage
% \section{AOMIC PIOP1 appendix}
% \label{sec:supp_aomic}
% \setcounter{equation}{0}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.8\linewidth]{gfx/hrv.pdf}
%     \caption{
%     Left panel: heart rate curves (used as response) for a selection of 20 subjects in the study. 
%     Right panel: histogram of $R^2$s from the marginal regressions of heart rate on each of the voxels. The threshold at 0.02 is used to screen voxels. 
%     }
%     \label{fig:hrv_r2_marginal}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{gfx/braink2k4.pdf}
%     \caption{
%     AOMIC PIOP1 data results for $k=2$ (left panel) and $k=4$ (right panel). Voxels selected at least 30 times by $cv$ (top row) and at least 20 times (bottom row) by $gcv$ applying FAStEN to 100 bootstrap samples from the original data.
%     For each 3D coordinate in the brain, the voxels are projected on (from left to right) the Coronal, Sagittal, and Horixontal axis.
%     Dot colors represent frequency of selection (out of 100, see color scales).
%     % $k=2$, minimum for \textit{gcv} is 20; minimum for \textit{cv} is 30
%     }
%     \label{fig:brain_app_k2_k4}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{gfx/brain_app_k4.pdf}
%     \caption{$k=4$, minimum for \textit{gcv} is 20; minimum for \textit{cv} is 30}
%     \label{fig:brain_app_k4}
% \end{figure}





%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%
%   References 
%
%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

\clearpage
\vskip 0.2in
\bibliography{bib}

\end{document}
