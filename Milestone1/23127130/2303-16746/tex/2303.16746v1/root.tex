%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX convrsion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org
\usepackage{ourpackages}
\usepackage{tabstackengine}
\input{notesmacros.tex}
\input{ourmacros.tex}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]

\title{\LARGE \bf
\pkg{Fatrop}: A Fast Constrained Optimal Control Problem Solver for Robot Trajectory Optimization and Control
} 


\author{Lander Vanroye, Ajay Sathya, Joris De Schutter and Wilm Decr\'e% <-this % stops a space
% \thanks{This result is part of a project that has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (Grant agreement: ROBOTGENSKILL No. 788298) and from the Research Foundation Flanders (FWO) (Grant agreement No. G0D1119N).}% <-this % stops a space
\thanks{All authors are with the Department of Mechanical Engineering, KU Leuven, and with Flanders Make@KU Leuven, Leuven, Belgium.
%        {\tt\small lander.vanroye@kuleuven.be}, {\tt\small ajay.sathya@kuleuven.be}, {\tt\small joris.deschutter@kuleuven.be}, {\tt\small wilm.decre@kuleuven.be}.}%
{\tt\small \{lander.vanroye, ajay.sathya, joris.deschutter, wilm.decre\}@kuleuven.be}.}%
}
% \renewcommand{\arraystretch}{0.1} % because \baselinestretch is 1.6667
\begin{document}

% \renewcommand{\ALG@name}{Algorithm Sketch}
\maketitle
\thispagestyle{empty}
\pagestyle{empty}
\setcounter{MaxMatrixCols}{30}  %<<<<<<<<<<<<<<<<<<<


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% suggestions for abstract by chatgpt
%"This work presents an efficient algorithm for solving constrained nonlinear optimal control problems. 
% The algorithm is versatile and can be applied to a wide range of problems, including trajectory optimization. 
% It combines advanced numerical techniques from nonlinear optimization and model predictive control solvers to achieve a high level of numerical robustness while maintaining the speed of a model predictive control solver. 
% To demonstrate the potential of the proposed algorithm, we apply it to a set of problems that are malchallenging from a numerical perspective, including problems with a minimal time objective and obstacle avoidance constraints. 
% We find that the algorithm performs significantly faster than the general-purpose nonlinear optimization solver IPOPT. 
% The algorithm is also provided as open source software, released under the X license called FATROP."
\begin{abstract}
        Trajectory optimization is a powerful tool for robot motion planning and control.
        % The trajectory optimization solver should offer the following properties:
        % the ability to deal with constraints in their full generality,
        % a high computational efficiency and a
        % high numerical robustness to cope with the strong nonlinear nature of the optimization problems at hand.
        State-of-the-art general-purpose nonlinear programming solvers are versatile, handle constraints in an effective way and provide a high numerical robustness, but they are slow because they do not fully exploit the optimal control problem structure at hand.
        % Existing specialized solvers are either foicussed on model predictive control or based on differential dynamic programming.
        % Model predictive control solvers are not suitable for trajectory optimization because they do not support stagewise equality constraints and they lack a high numerical robustness, since these are typically not requirements for their target applications.
        % Techniques from general-purpose nonlinear optimization solvers cannot be directly translated into implementations in differentiable dynamic programming solvers.
        % Existing differentiable dynamic programming based solvers rely on penalty methods to enforce stagewise (in)equality constraints or are not able to cope with exact Hessian information.
        % Existing structure-exploiting solvers, on the other hand, are fast but they are either oriented at model predictive control or based on differentiable dynamic programming.
        % The former class of solvers are not suitable for trajectory optimization because they do not support equality constraints and lack advanced techniques to deal with nonlinearity, since these are not model predictive control requirements.
        % Available differential dynamic programming frameworks are not able to enforce constraints `directly' and rely on penalty methods for this purpose.
        Existing structure-exploiting solvers are fast but they often lack techniques to deal with nonlinearity or rely on penalty methods to enforce (equality or inequality) path constraints.
        % This work presents FATROP: a trajectory optimization algorithm that implements inequality constraints using a primal-dual interior point method to a direct multiple shooting trajectory optimization formulation.
        % It is heavily inspired on the IPOPT algorithm but it is tailored for trajectory optimiziaton problems.
        This works presents \pkg{fatrop}: a trajectory optimization solver that is fast and benefits from the salient features of general-purpose nonlinear optimization solvers.
        The speed-up is mainly achieved through the use of a specialized linear solver, based on a Riccati recursion that is generalized to also support stagewise equality constraints.
        % The result is a solver that benefits from the salient features of general-purpose nonlinear optimization solvers while achieving close to model predictive control solver speeds.
        To demonstrate the algorithm's potential, it is benchmarked on a set of robot problems that are challenging from a numerical perspective, including problems with a minimum-time objective and no-collision constraints.
        The solver is shown to solve problems for trajectory generation of a quadrotor, a robot manipulator and a truck-trailer problem in a few tens of milliseconds.
        % A significant speed-up of about a factor five is achieved with respect to the general-purpose nonlinear optimization solver Ipopt.
        % We also show that, when solving MPC problems the algorithm is almost as fast as the state-of-the-art model predictive control solver ACADOS.
        The algorithm's \cpluspluslogo-code implementation accompanies this work as open source software, released under the GNU Lesser General Public License (LGPL).
        This software framework may encourage and enable the robotics community to use trajectory optimization in more challenging applications.
\end{abstract}
\section{Introduction}
% motivation
Nonlinear optimal control problems (OCP) are used in a wide range of engineering applications. 
In robotics, they provide a powerful tool for optimizing robot trajectories and controlling robotic systems.
Trajectory optimization involves finding a control and state trajectory that is (locally) optimal in some metric while satisfying certain equality and inequality path constraints.
This metric, or objective, can, for example, be related to total execution time, safety, energy use or user comfort, while the stagewise path constraints can enforce state and control limits, as well as encode a robot task, such as a path-following task with bounded allowable deviation for a robot end effector.
Trajectory optimization has been applied to many robotics applications such as drone racing \cite{foehn2021time,bos2022multistage}, airborne wind energy systems \cite{horn2013numerical}, legged locomotion \cite{mastalliquadruped} and collision-free robot motion planning \cite{schulman2014motion}.
Apart from trajectory optimization, nonlinear OCPs are building blocks of model predictive control (MPC), which is a control strategy that has gained widespread popularity in the robotics community because of its ability to control complex, underactuated and highly-dynamical systems.
%The idea of MPC is using a dynamic model of the system to predict its future behavior over a certain horizon, and then uses this information to compute a control action that optimizes a performance criterion over this horizon.
MPC's potential in robotics has been demonstrated in, for example, the control of autonomous racing cars \cite{liniger2015racing} and legged robots \cite{GrandiaMPClegged}.

% Computational efficiency of the nonlinear OCP solver is critically important in robotics applications for many reasons.
% Firstly, reactive sensor-based robot controllers have to rapidly adapt their actions to respond to disturbances or unpredictable changes in the environment, for e.g. while interacting with a human or controlling an autonomous vehicle.
% %Unpredictable environments are prevalent in, for example, human-robot interaction and autonomous vehicle applications.
% Secondly, deploying the solver on low-cost and low-power embedded platforms with limited computing power is a common requirement in robotics. % computational efficiency can be important because of hardware limitations.
% Often the available computing power is limited by low-cost or low-power system requirements.
% Finally, apart from online applications, fast solvers can benefit offline application as well, for e.g. data driven learning approaches that leverage a large dataset of OCP-based ``expert''-trajectories for learning.
% In addition to speed, the solver also has to be robust due to the numerically challenging nature of the problems.
%These approaches perform better with large data sets, which have to be generated using efficient trajectory generation methods
The computational efficiency of the nonlinear OCP solver is of critical importance for many applications, particularly in reactive sensor-based control applications, where robots have to rapidly adapt their actions to respond to disturbances or unpredictable changes in environment,
% Unpredictable environments are prevalent in, for example, human-robot interaction and autonomous vehicle applications.
% and applications with hardware limitations, where the available computing power is limited by low-cost or low-power requirements.
% Finally, apart from online applications, fast solvers are useful in offline applications as well, for example in data driven learning approaches where ``expert''-trajectories are generated are increasingly popular.
% These approaches perform better with large data sets, which have to be generated using efficient trajectory generation methods.
Apart from being fast, the solver should also provide a high robustness due to the numerically challenging nature of the considered optimization problems.

We formulate the constrained optimal control problem (COCP) as follows:
\begin{subequations} \label{eq:COCP} 
        \begin{align}
                \minimize_{\substack{\mathbf{x}_k, \mathbf{u}_k,\mathbf{x}_K}} \quad & l_K(\mathbf{x}_K) + \sum_{k=0}^{K-1} l_k(\mathbf{u}_k, \mathbf{x}_k)          \\
                \text{subject to} \quad
                                                                                     & \mathbf{x}_{k+1} = \mathbf{f}_k(\mathbf{u}_k, \mathbf{x}_k),                  \\
                                                                                     & \mathbf{L}_k \leq \mathbf{g}_k(\mathbf{u}_k, \mathbf{x}_k) \leq \mathbf{U}_k, \\
                                                                                     & \mathbf{L}_K\leq \mathbf{g}_K(\mathbf{x}_{K})  \leq \mathbf{U}_K,             \\ \label{eq:COCPeq1}
                                                                                     & \mathbf{h}_k(\mathbf{u}_k, \mathbf{x}_k) =\mathbf{0},                         \\ \label{eq:COCPeq2}
                                                                                     & \mathbf{h}_K(\mathbf{x}_K) = \mathbf{0},
        \end{align}
\end{subequations}
for $k = 0, 1, \dots, K-1$, with $K$ the horizon length, $\mathbf{x}_k$ the state variables, $\mathbf{u}_k$ the control or input variables, $l_k$, $\mathbf{f}_k$, $\mathbf{g}_k$ and $\mathbf{h}_k$ the functions representing the stage cost, the discrete dynamics, the inequality and equality path constraints, respectively.
Note that, because of the general stagewise equality constraints \eqref{eq:COCPeq1}-\eqref{eq:COCPeq2}, this is a broader formulation than common in MPC where, usually, only one stagewise equality constraint is used, namely a constraint at the first time step that fixes the full state vector.
An important problem class, incorporated by this COCP formulation is the boundary value problem where the initial and terminal states are fixed.
The formulation \eqref{eq:COCP} also directly supports moving horizon estimation problems and
furthermore, using helper states, the formulation can encode OCPs with minimum total time objective, multi-stage problems with unknown stage durations as well as periodic systems.

% how to solve this problem?
% ipopt robust, few iterations but general purpose and thus slow
Apart from a difference in formulation, nonlinear MPC and trajectory optimization problems have different solver requirements.
In MPC, approximately optimal control inputs have to be computed within a specified sampling time, due to hard real-time requirements.
An estimate of the solution is available from the previous control step, and only a local neighborhood of this approximate solution has to be explored, which is exploited in MPC-solvers to achieve higher sampling times \cite{verschueren2022acados}.
In trajectory optimization, in contrast, the optimization problem has to be solved to a high accuracy and an estimate of the solution is often not available.
This requires advanced nonlinear programming techniques that provide robustness to cope with the numerically challenging nature of these problems.
General-purpose nonlinear optimization algorithms, such as \pkg{Ipopt} \cite{wachter2006implementation}, \pkg{SNOPT} \cite{gill2005snopt} and \pkg{KNITRO} \cite{knitro} provide this numerical robustness but they are slow because they do not fully exploit the COCP problem structure at hand.

\subsection{Related Work}
Numerous algorithms tailored for solving nonlinear optimal control problems have been developed, which can be divided into two families: methods that are based on techniques from numerical optimization, such as Sequential Quadratic Programming (SQP), and methods inspired by numerical optimal control, namely  Differential Dynamic Programming (DDP).
For the former family of algorithms techniques that can be employed to exploit the OCP structure include the Riccati Recursion \cite{frison2020hpipm} and specialized condensing approaches \cite{frison2013fast,andersson2013condensing,frison2016pcond}.
A collection of structure-exploiting SQP-based algorithms are implemented in the state-of-the-art MPC framework \pkg{acados} \cite{verschueren2022acados}.
% Gradient methods, oriented at MPC, are implemented in frameworks like \pkg{GRAMPC} \cite{englert2019grampc}, \pkg{VIATOC} \cite{kalmari2015toolkit} and \pkg{FalcOPT} \cite{torrisi2018projected}.
% The aforementioned solvers are not suitable for trajectory optimization as they do not support stagewise equality constraints or lack advanced techniques to cope with nonlinearity, since these are typically not requirements for their target applications.
% The aforementioned solvers have proven to be very effective at MPC applications but they are not suitable for trajectory optimization as they do not meet the solver requirements and general formulation.
DDP methods, the second family of algorithms, are inspired by the Linear Quadratic Regulator (LQR), which is a well-known concept in linear control.
The computation of the search direction consists of two passes.
In the backward pass, the nonlinear OCP is approximated around the current iterate by a linear quadratic approximation.
This OCP approximation is then used to build an LQR that computes the locally optimal feedback law for each time step.
In the forward pass, the obtained optimal (state) feedback laws and discrete dynamics are used alternately to compute the next iterate.
This procedure is repeated until the problem is solved to the specified precision.
Commonly, these methods use a sum-of-squares objective and neglect the second-order effects of the dynamics and path constraints in the Lagrangian Hessian function.
This results in a Gauss-Newton DDP variant which is referred to as the iterative Linear Quadratic Regulator (iLQR) \cite{giftthaler2018family, todorov2005generalized}.
State-of-the-art trajectory optimization frameworks, for example \pkg{Crocoddyl} \cite{mastalli20crocoddyl} and \pkg{ALTRO} \cite{howell2019altro}, implement modified versions of iLQR called feasibility-driven differential dynamic programming (FDDP) and Augmented Lagrangian iLQR (AL-iLQR), respectively. These modifications permit initializing the solver with dynamically infeasible trajectories similarly to the multiple shooting method and improve numerical robustness compared to the vanilla iLQR \cite{todorov2005generalized}.
A concise overview of the salient features of the mentioned frameworks is given in Table \ref{tabel:solver_comparison}.
Numerical optimization algorithms have a well-developed set of strategies to solve nonlinear optimization problems with a high robustness.
A difficulty with DDP-based algorithms is that many of these strategies cannot be straightforwardly applied to these methods, and handling nonlinear path constraints robustly is still a developing area \cite{jallet2022constrained}.
A number of challenges that arise in developing DDP-based methods for trajectory optimization have been addressed in prior work.
A first challenge is the treatment of exact Hessian information.
While iLQR methods avoid the, possibly costly, evaluation of second-order derivatives of the dynamics and path constraints, it is often useful to incorporate exact Hessian information.
This is because Gauss-Newton approximations are limited to sum-of-squares objectives and exact Hessian information can drastically lower the number of required iterations and increase the solver's numerical robustness.
A difficulty is that line-search algorithms based on exact Hessian DDP, as opposed to iLQR, require Hessian regularization to ensure some a descent properties for the filter line search method.
% This is a necessary algorithm feature for global convergence.
Hessian regularization in exact Hessian DDP was addressed by adding a scaled identity matrix to the full space Hessian \cite{liao1991convergence,pavlov2021interior}.
A second challenge is the treatment of stagewise equality and inequality constraints.
Many DDP methods rely on penalty methods such as quadratic penalty methods (quad pen), augmented Lagrangian methods (ALM) \cite{howell2019altro} and relaxed barrier methods \cite{hauser2006barrier}.
Penalty methods convert constrained OCPs into unconstrained ones, which can be solved with conventional DDP methods.
Some drawbacks of penalty methods are that they require hand tuning, not all are exact, possibly return a local minimizer that does not satisfy the constraints, can suffer from ill-conditioning or can require many iterations.
Inequality constraints that explicitly depend on control variables were implemented with active-set based methods \cite{murray1979constrained,yakowitz1986stagewise,xie2017differential,lin1991differential}.
Inequality constraints were implemented `directly' using a primal-dual interior-point method \cite{pavlov2021interior}.
For state equality constraints with a relative degree of one, a projection method was proposed \cite{giftthaler2017projection}.
% A major shortcoming nonlinear interior-point method implementation for specialized for OCP's an other shortcoming is a solver that can directly implement equality constraints, without imposing any restrictive regularity assumptions.
A major shortcoming is the lack of existence of a nonlinear optimization solver, tailored for trajectory optimization, that supports arbitrary path constraints, without using penalty methods.
% Another shortcoming is that most specialized OCP solvers are oriented at MPC and lack advanced techniques to cope with nonlinearity.
% often, one has to trade off numerical robustness for computation speed when choosing between a general-purpose and a specialized solver.
% The goal of this work is to take steps towards a solver that achieves both fast computation speeds and a high numerical robustness.
%  between speed, reliability and generality when choosing a solver, this work tries to take steps towards...
\begin{table}[h]
        \centering
        \Scale[0.9]{ % \setlength{\tabcolsep}{3pt}
                \begin{tabular}{|l|cccc|}
                        \hline
                                             & \pkg{fatrop}  & \pkg{crocoddyl} & \pkg{altro} & \makecell{\pkg{acados}\&\\\pkg{hpipm}}  \\
                        \hline
                        license              & LGPL                     & BSD3            & MIT         & BSD2          \\
                        implementation lang  & C++                      & C++             & \pkg{julia} & C++           \\
                        linear algebra       & \pkg{blasfeo}            & \pkg{eigen}     & \pkg{julia} & \pkg{blasfeo} \\
                        dynamics handling    & direct MS                & FDDP            & AL-iLQR     & direct MS     \\
                        stagewise inequality & yes                      & box             & yes         & yes           \\
                        stagewise equality   & yes                      & yes & yes       & no                          \\
                        inequality handling  & NLP-IP                   & quad pen        & ALM         & SQP\&QP-IP    \\
                        equality handling    & \makecell{Newton-\\Lagrange}  & quad pen        & ALM         &  -\\
                        \hline
                \end{tabular}
        }
        \caption{\small Qualitative comparison of different structure-exploiting OCP solvers \pkg{fatrop}, \pkg{acados}, \pkg{altro} and \pkg{crocoddyl}.}
        \label{tabel:solver_comparison}
\end{table}

\subsection{Contribution}
The major contribution of this work is the development of 
a constrained optimal control solver that is fast by exploiting the COCP's structure and that achieves a high numerical robustness by implementing advanced nonlinear programming techniques.
The algorithm is inspired \pkg{Ipopt} and handles equality and inequality path constraints in the same way.
% The most important features are that it is able to cope with exact Hessian information, handles inequalities directly with a nonlinear primal-dual interior-point method, handles stagewise equality constraints directly in a Newton-based fashion. 
The approach uses the multiple shooting formulation which naturally makes it able to initialize from any, possibly infeasible, solution estimate.
% The main speed-up with respect to existing general-purpose solvers is obtained by the use of a specialized linear solver.
% and has advanced regularization and globalization strategies inspired by Ipopt.
% It borrows advanced techniques from state-of-the-art general-purpose nonlinear programming solvers to achieve a high numerical robustness.
Furthermore, the the potential of the approach is demonstrated on a number of benchmark problems from a varying challenging nature.
Finally, the \pkg{fatrop} open source software package that provides an efficient \cpluspluslogo-implementation of the proposed algorithm is released under LGPL-license.
\subsection{Outline}
The remainder of this paper is organized as follows.
Section \ref{sec:notation} introduces the notation used throughout this paper.
and discusses preliminaries on nonlinear primal-dual interior point algorithms and direct shooting formulations.
Section \ref{sec:implementation} describes the implementation of the proposed algorithm and how the optimal control problem structure is exploited.
Section \ref{sec:benchmarks} introduces the considered benchmark problems.
Section \ref{sec:implementationdetails} deals with some details on how these problems are translated into optimal control problems and how the benchmark is performed.
Finally, Section \ref{sec:results} presents the results of the benchmark while Section \ref{sec:conclusion} concludes the paper.
Readers who are less familiar with or less interested in the details of the numerical algorithms can skip Sections I-III and jump immediately to Section IV to appreciate the improved performance of the presented solver compared to existing solvers when applied to trajectory optimization problems in robot motion planning and control.
\section{Notation and Preliminaries} \label{sec:notation}
\subsection{Notation}
Vectors are denoted by bold lower case characters, matrices by bold capital characters and scalars by lower case characters.
The symbol $\identm{}$ represents an identity matrix, $\mathbf{0}$ a vector of zeroes and $\mathbf{e}$ a vector of ones,
A diagonal matrix of a vector $\mathbf{x}$ is denoted by $\mathbf{X} = \text{diag}(\mathbf{x})$.
The transpose of matrix $\mathbf{A}$ is denoted by $\mathbf{A} \transpose$.
The following notation represents a linear system $\mathbf{A} \mathbf{x} = -\mathbf{b}$:
% \begin{equation}
       $$  
        \begin{aligned}
                \begin{bNiceMatrix}[first-row]
                        \mathbf{x}                                                            \\
                        \mathbf{A}  & \mathbf{b} \\
                        \CodeAfter
                        \tikz \draw[densely dotted] (1-|2)--(2-|2) ;
                \end{bNiceMatrix}
        \end{aligned}.
       $$ 
% \end{equation}
The gradient and Hessian of a scalar function $f$ with respect to $\mathbf{x}$ are denoted by $\nabla _\mathbf{x}f$ and $\nabla^2_{\mathbf{xx}}f$, respectively. 
The Jacobian of a vector function $\mathbf{g}$ is denoted by $\mathbf{J}_\mathbf{g}$.
The indices $i$, $k$, and $j$ refer to a specific inequality, time step and interior point outer iteration, respectively.
Blank submatrices in a matrix are structurally zero.
% \subsection{Preliminaries} \label{sec:preliminaries}
\subsection{Primal-Dual interior-point algorithm}
In this section a concise introduction to primal-dual interior-point methods is given.
\begin{algorithm}[h]\small \label{alg}
        \renewcommand{\thealgorithm}{}
        \begin{algorithmic}[1]
                \While{no convergence of full problem}
                \While{no convergence of barrier subproblem}
                \State compute PD system at current iterate
                \If{not reduced Hessian positive definite}
                \State modify full space Hessian by adding scaled identity matrix
                \EndIf
                \State find search direction (solve primal-dual system)
                \State find step size (line search) and compute next iterate
                \EndWhile
                \State decrease barrier parameter $\mu_j$
                \EndWhile
        \end{algorithmic}
        \caption{\small sketch of the primal-dual-interior-point method}
\end{algorithm}

Without loss of generality we consider a slack variable formulation optimization problem of the form:
\begin{subequations} \label{eq:general_opt} 
        \begin{align}
                \minimize_{\mathbf{x}, \mathbf{s}} & \quad {f}(\mathbf{x})                                  \\
                \text{subject to}                   & \quad \mathbf{h}(\mathbf{x}) = \mathbf{0},             \\
                                              & \quad \mathbf{g}(\mathbf{x}) - \mathbf{s} = \mathbf{0}, \\
                                              & \quad  \mathbf{s} \geq \mathbf{0},                      
        \end{align}
\end{subequations}
where $\mathbf{x}$ and $\mathbf{s}$ are the decision and slack variables, respectively.
The slack inequality constraint is implemented by introducing a barrier term to the objective function:
\begin{subequations} \label{eq:general_barrier} 
        \begin{align}
                \minimize_{\mathbf{x}, \mathbf{s}} & \quad {f}(\mathbf{x}) -\mu_j \sum_i \log(s_i)            \\
                \text{subject to}                   & \quad \mathbf{h}(\mathbf{x}) = \mathbf{0},              \\
                                              & \quad \mathbf{g}(\mathbf{x}) - \mathbf{s} = \mathbf{0}. 
        \end{align}
\end{subequations}
After introduction of the additional variables $z_i = \mu_j/s_i$ and some straightforward algebraic manipulation, the first-order necessary optimality conditions associated with \eqref{eq:general_barrier} are:
\begin{subequations}\label{eq:primal_dual_eqs} 
        \begin{align}  
                \nabla_{\mathbf{x}} \mathcal{L} = \mathbf{0}, \\
                \nabla_{\mathbf{s}} \mathcal{L} = \mathbf{0}, \\
                \mathbf{h}(\mathbf{x}) = \mathbf{0},                      \\
                \mathbf{g}(\mathbf{x}) - \mathbf{s} = \mathbf{0},         \\
                \text{diag}(\mathbf{z}) \mathbf{s} = \mu_j  \mathbf{e},       \label{eq:primal_dual_eqs_centering}
        \end{align}
\end{subequations}
where the Lagrangian $\mathcal{L}$ is defined as:
\begin{equation}  
        \mathcal{L} := f(\mathbf{x}) + \boldsymbol{\lambda}_\mathbf{h}\transpose \mathbf{h}(\mathbf{x}) + \boldsymbol{\lambda}_\mathbf{g}\transpose (\mathbf{g}(\mathbf{x}) - \mathbf{s}) - \mathbf{z}\transpose \mathbf{s}.
\end{equation}
% Note that except the complementarity condition, is replaced by a centering term resulting in a primal-dual system in the form:
Note that these conditions match the first-order optimality conditions of the original problem \eqref{eq:general_opt} as the barrier parameter $\mu_j$ decreases to zero.
The last equation \eqref{eq:primal_dual_eqs_centering}, the centering equation, is a perturbed version of the original problem's complementarity condition.
This means that the method can be viewed effectively as a homotopy method.
The primal-dual interior-point method proceeds by applying Newton's method to this nonlinear system of equations.
This results in a linear system, referred to as the primal-dual system, of the form:
\begin{equation} 
        \begin{aligned}  
                \begin{bNiceMatrix}[first-row]
                        \Delta \mathbf{x}                           & \Delta \mathbf{s} & \Delta \boldsymbol{\lambda_\mathbf{h}} & \Delta \boldsymbol{\lambda_\mathbf{g}} & \Delta \mathbf{z}                                \\
                        \nabla ^2_{\mathbf{x}\mathbf{x}} \mathcal{L} &                  & \mathbf{J_h}\transpose            & \mathbf{J_g}\transpose            &                  & \nabla_\mathbf{x}\mathcal{L} \\
                                                                    &                  &                          & -\identm{}                         & -\identm{}                & \nabla_\mathbf{s}\mathcal{L} \\
                        \mathbf{J_h}                                 &                  &                          &                          &                  & \mathbf{h}                   \\
                        \mathbf{J_g}                                 & -\identm{}                 &                          &                          &                  & \mathbf{g} -\mathbf{s}       \\
                                                                    & \mathbf{Z}                 &                          &                          & \mathbf{S}                & \mathbf{S} \mathbf{z} - \mu_j \mathbf{e}
                        \CodeAfter
                        \tikz \draw[densely dotted] (1-|6)--(6-|6) ;
                \end{bNiceMatrix}
        \end{aligned}.
\end{equation}
Elimination of $\Delta \mathbf{s}$, $\Delta \boldsymbol{\lambda_g}$ and $\Delta \mathbf{z}$ results in a symmetric indefinite linear system of the form:
\begin{equation} \label{eq:reduced_system}
        \begin{aligned}
                \begin{bNiceMatrix}[first-row]
                        \Delta \mathbf{x}                                                                  & \Delta \boldsymbol{\lambda_h}                                                                      \\
                        \nabla ^2_{\mathbf{x}\mathbf{x}}\mathcal{L} + \mathbf{J_g} \transpose \mathbf{S}^{-1} \mathbf{Z} \mathbf{J_g} & \mathbf{J_h} \transpose            & \boldsymbol{\gamma} \\
                        \mathbf{J_h}                                                                       &                          & \mathbf{h}
                        \CodeAfter
                        \tikz \draw[densely dotted] (1-|3)--(3-|3) ;
                \end{bNiceMatrix}
        \end{aligned},
\end{equation}
with $\boldsymbol{\gamma} =  \nabla_\mathbf{x}\mathcal{L} + \mathbf{J}_\mathbf{g} \transpose(-\lambda_\mathbf{g} -\mathbf{S}^{-1}\left(\mu_j \mathbf{e}  - \mathbf{Z}(\mathbf{g}-\mathbf{s})\right))$.
We will refer to this system as the \textit{reduced primal-dual system} throughout the remainder of this paper.
The iteration steps $\Delta \mathbf{s}$, $\Delta \boldsymbol{\lambda_g}$ and $\Delta \mathbf{z}$ can than be retrieved by the following expressions:
\begin{subequations}
        \begin{align}
                 & \Delta \mathbf{s} = \mathbf{J_g} \Delta \mathbf{x} + \mathbf{g} - \mathbf{s},                        \\
                 & \Delta \boldsymbol{\lambda_g} = - \boldsymbol{\lambda_g} -\mathbf{S}^{-1}(\mu_j \mathbf{e} - \mathbf{Z}\Delta \mathbf{s}), \\
                 & \Delta \mathbf{z} = -\mathbf{z} + \mathbf{S}^{-1} (\mu_j \mathbf{e} - \mathbf{Z} \Delta \mathbf{s}).             
        \end{align}
\end{subequations}
The maximum primal and dual step size is chosen in such a way that the fraction-to-boundary rule is satisfied for every slack and dual bound variable, i.e. $s_{i} + \alpha_{\text{primal}}^{\text{max}} \Delta s_i \geq (1-\mu_j) s_{i}$ and $z_{i} + \alpha_{\text{dual}}^{\text{max}} \Delta z_i \geq (1-\mu_j) z_{i}$.
For a more detailed introduction and analysis of primal-dual interior-point methods we refer to the textbook of \textit{Nocedal \& Wright} \cite{nocedal2006numerical}.
\subsection{Direct Multiple Shooting Formulation}
In direct single shooting, all but the first state variable are eliminated by substituting the (discrete-time) dynamics equations.
Multiple shooting, on the other hand, retains all state variables as decision variables, maintaining the dynamics equations as constraints of the nonlinear program.
The latter approach is known to have superior convergence properties over the former in Newton-type optimization algorithms \cite{albersmeyer2010lifted,giftthaler2018family}.
Additionally, multiple shooting allows for initialization from a dynamically infeasible guess, unlike single shooting.
The block-sparse structure of the primal-dual system, arising from the multiple shooting formulation, is exploited in the algorithm's linear solver.
\section{Implementation} \label{sec:implementation}
The nonlinear programming algorithm is heavily inspired by the primal-dual interior-point algorithm \pkg{Ipopt} \cite{wachter2006implementation}, applied to the multiple shooting problem formulation.
In this section an overview of the main implementation features of the proposed algorithm is given.
% \subsection*{Primal-Dual Interior-Point}
% Primal-Dual interior-point methods involve applying Newton's method to a perturbed version of the KKT system.
% Resulting in the following linear system for finding the search direction:
% Interior-point methods apply the Newton method directly to a perturbation of the KKT sytem.
% Inequality constraints are treated directly, using a primal-dual interior-point method.
% The method solves a sequence of perturbed versions of the KKT system for a decreasing perturbation parameter \cite{nocedal2006numerical} until the specified precision is reached.
\subsection*{Filter Line Search Globalization}
A filter line search procedure is used to promote global convergence \cite{fletcher2002nonlinear}.
% The filter criterion accepts a step if it reduces either the objective function or the constraint violation.
% The filter criterion accepts a trial step if the objective function and constraint violation pair is not dominated by a previous pair.
The advantage of using a filter over a merit function acceptance criterion is that the filter's performance is not heavily dependent on the choice of algorithm parameters, such as the merit function's constraint violation penalty parameter.
% This is the parameter weights the relative importance of the decrease in objective value and constraint violation.
\subsection*{Exact Hessian Information and Hessian Regularization}
Exact Hessian information represents a problem better locally than Hessian approximations, hence it can drastically lower the number of required iterations and improve the numerical robustness.
A difficulty with using exact Hessian information over Hessian approximation methods like Gauss-Newton and BFGS is that the exact Hessian is not guaranteed to be positive definite.
It is common in line-search methods to require the reduced Hessian approximation, used for the computation of the search direction, to be positive definite.
This guarantees that the computed search direction satisfies some descent properties for the filter line search criterion.
Note that \pkg{fatrop} requires the \textit{reduced} Hessian, this is the full space Hessian projected on the null-space of the constraint Jacobian, to be positive definite.
This is a weaker requirement than positive definiteness of the full space Hessian.
If the reduced Hessian is not positive definite, the full space Hessian is regularized by adding a multiple of the identity matrix.
% The local convergence rate of exact Hessian DDP is quadratic, whereas for iLQR this is only linear.
% reduced Hessian is positive in neighborhood optimum, optimality conditions
% explain reduced Hessian!!
% superlinear convergence
% inertia correction when reduced Hessian is not positive definite
% this is necessary to guarantee a descent direction of the line search in step.
\subsection*{Structure-Exploiting Linear Solver}
At each iteration, the search direction is computed by solving the reduced primal-dual system \eqref{eq:reduced_system}.
Usually this is the most time consuming step of the algorithm.
The stagewise structure of the COCP \eqref{eq:COCP} results in a block-sparse structure in the reduced primal-dual system.
This block-sparse structure is the same as the KKT system of an equality-constrained OCP and can be exploited by a Riccati recursion that is generalized to also support stagewise equality constraints \cite{generalizationriccati}.
% If no equality stagewise constraints are present, this system can be solved using a Riccati recursion \cite{gianluca_efficient}.
% But because we want to allow stagewise equalities a generalization of the Riccati recursion is used (ref).
The reduced primal-dual system structure for a horizon length of two $(K=2)$ is shown below:
\begin{equation*}
        \label{eq:blockKKT}
        \Scale[0.8]{
                \begin{bNiceMatrix}[first-row]
                        \mathbf{x}_2        & \mathbf{v}_2           & \boldsymbol{\pi}_2         & \mathbf{u}_1     & \mathbf{x}_1           & \boldsymbol{\lambda}_1         & \boldsymbol{\pi}_1         & \mathbf{u}_0     & \mathbf{x}_0           & \boldsymbol{\lambda}_0         &     \\
                        \mathbf{Q}_2        & \mathbf{H}_2\transpose & -\identm{}    &         &               &                   &               &         &               &                   & \mathbf{q}_2 \\
                        \mathbf{H}_2        &               &               &         &               &                   &               &         &               &                   & \mathbf{h}_2 \\
                        -\identm{} &               &               & \mathbf{B}_1     & \mathbf{A}_1           &                   &               &         &               &                   & \mathbf{b}_1 \\
                                   &               & \mathbf{B}_1\transpose & \mathbf{R}_1     & \mathbf{S}_1\transpose & \mathbf{H}_{1,u}\transpose &               &         &               &                   & \mathbf{r}_1 \\
                                   &               & \mathbf{A}_1\transpose & \mathbf{S}_1     & \mathbf{Q}_1           & \mathbf{H}_{1,x}\transpose & -\identm{}    &         &               &                   & \mathbf{q}_1 \\
                                   &               &               & \mathbf{H}_{1,u} & \mathbf{H}_{1,x}       &                   &               &         &               &                   & \mathbf{h}_1 \\
                                   &               &               &         & -\identm{}    &                   &               & \mathbf{B}_0     & \mathbf{A}_0           &                   & \mathbf{b}_0 \\
                                   &               &               &         &               &                   & \mathbf{B}_0\transpose & \mathbf{R}_0     & \mathbf{S}_0\transpose & \mathbf{H}_{0,u}\transpose & \mathbf{r}_0 \\
                                   &               &               &         &               &                   & \mathbf{A}_0\transpose & \mathbf{S}_0     & \mathbf{Q}_0           & \mathbf{H}_{0,x}\transpose & \mathbf{q}_0 \\
                                   &               &               &         &               &                   &               & \mathbf{H}_{0,u} & \mathbf{H}_{0,x}       &                   & \mathbf{h}_0 \\
                        \CodeAfter
                        \tikz \draw[densely dotted] (1-|11)--(11-|11) ;
                \end{bNiceMatrix}
        },
\end{equation*}
where $\mathbf{x}_k$ and $\mathbf{u}_k$ represent state and input variables, respectively, $\boldsymbol{\pi}_{k}$ represents the dual variables of the discretized dynamics equality constraints, while $\mathbf{v}_K$ and $\boldsymbol{\lambda}_k$ are the dual variables of the stagewise equality constraints.
The block subvectors and matrices appearing in this equation represent the following quantities:
\begin{subequations} \label{eq:blockwise_quantities} \small
        \begin{align}
                 & \begin{bmatrix}
                           \mathbf{H}_{K}
                           \\
                           \mathbf{G}_K
                   \end{bmatrix}
                = \frac{\partial }{\partial \mathbf{x}_K} \begin{bmatrix}
                                                                  \mathbf{h}_K \\ \mathbf{g}_K
                                                          \end{bmatrix},                                                                                                                                   \\
                 &
                \mathbf{Q}_K
                = \frac{\partial ^2  \mathcal{L}}{\partial \mathbf{x}_K \partial \mathbf{x}_K}  + \mathbf{G}_K \mathbf{S}_K^{-1} \mathbf{Z}_K \mathbf{G}_K\transpose,                                                   \\ & \mathbf{q}_K = \nabla \mathbf{x}_K \mathcal{L} + \mathbf{G}_K\transpose(-\boldsymbol{\lambda}_{\mathbf{g}_K} - \mathbf{S}_K^{-1}(\mu_j \mathbf{e} -\mathbf{Z}_K(\mathbf{g}_K-\mathbf{s}_K))),  \\
                 & \begin{bmatrix}
                           \begin{array}{cc}
                                \mathbf{B}_k     & \mathbf{A}_k     \\
                                \mathbf{H}_{k,u} & \mathbf{H}_{k,x}
                        \end{array}
                           \\
                           \mathbf{G}_k
                   \end{bmatrix}
                = \frac{\partial }{\partial \mathbf{w}_k} \begin{bmatrix}
                                                                  \mathbf{f}_k \\ \mathbf{h}_k \\ \mathbf{g}_k
                                                          \end{bmatrix},                                                                                                                   \\
                 & \begin{bmatrix}
                           \mathbf{R}_k & \mathbf{S}_k \transpose \\
                           \mathbf{S}_k & \mathbf{Q}_k            \\
                   \end{bmatrix}
                = \frac{\partial ^2  \mathcal{L}}{\partial \mathbf{w}_k \partial \mathbf{w}_k}  + \mathbf{G}_k \mathbf{S}_k^{-1} \mathbf{Z}_k \mathbf{G}_k \transpose,                                                  \\
                 & \begin{bmatrix} \mathbf{r}_k   \\ \mathbf{q}_k  \end{bmatrix} =  \nabla_{\mathbf{w}_k} \mathcal{L} + \mathbf{G}_k \transpose (-\boldsymbol{\lambda}_{\mathbf{g}_k} - \mathbf{S}_k^{-1}(\mu_j \mathbf{e} - \mathbf{Z}_k(\mathbf{g}_k-\mathbf{s}_k))), 
        \end{align}
\end{subequations}
where $\mathbf{w}_k$ is the concatenation of $\mathbf{u}_k$ and $\mathbf{x}_k$ while $\mathbf{S}_k$ and $\mathbf{Z}_k$ represent the diagonal matrices of the slack variables and dual bound multipliers related to time step $k$.
The used solution scheme only requires a full-rank constraint Jacobian and positive definite reduced Hessian.
These conditions are required by the filter line search anyway.
Moreover, the recursion is used as well to test the positive definiteness of the reduced Hessian at no extra cost, see Step 4 of the Algorithm Sketch.
The computational complexity is linear in the horizon length.
To achieve a high numerical accuracy, iterative refinement is deployed.
For a more detailed overview we refer the reader to \cite{generalizationriccati}.
The \pkg{blasfeo} \cite{frison2018blasfeo} library is used for the linear algebra operations in the algorithm.
This library is optimized for the small-scale matrices that fit in cache memory, appearing in the proposed algorithm.
The kernel routines of this library are optimized for many relevant target CPU architectures and use available CPU capabilities such as \texttt{SIMD} and \texttt{FMA} instruction set extensions.
% + iterative refinement
\subsection*{Stagewise Function Evaluation}
The stagewise quantities of the primal-dual system are the same functions for every time step.
This means that the code to evaluate these quantities can be re-used.
This way the algorithm has a smaller instruction memory footprint, resulting in a better instruction locality.
Because the code is kept small, it is feasible to apply aggressive compiler optimization levels.
Furthermore, since all block submatrices are independent, they can be evaluated in parallel.
This can be beneficial for problems with expensive function evaluation, for example multi-body problems with forward dynamics.
A preliminary implementation using \pkg{OpenMP} is available in \pkg{fatrop}.
\subsection*{Other Algorithm Features}
Other nonlinear programming features coming from \pkg{Ipopt} that are currently implemented in the algorithm are: (1) initialization procedure for the dual and the slack variables, (2) second-order corrections, (3) handling of degenerate constraint Jacobian, (4) watchdog procedure, (5) filter reset heuristic, (6) handling of lower and upper bounds, (7) handling of problems without a strict relative interior and (8) handling of very small search directions.
We refer to the \pkg{Ipopt} implementation paper \cite{wachter2006implementation} for a detailed description of these features.
% An algorithm feature that is implemented in Ipopt but, at moment of writing, not in the current implementation is the feasibility restoration phase.
% In our experiments we found that the feasibility restoration phase is not necessary for the problems we considered.
\section{Benchmark problems} \label{sec:benchmarks}
% for each problem: description, controls, states, eqs, ineqs, dynamics, underactuated, objective
Several dynamical systems are considered for which we set up different optimal control problems.
The benchmark problems are of varying dimensions and complexity.
Every problem of the benchmark can be classified either as a model predictive control or as a minimum-time problem.
% All problems can be divided into two categories: MPC problems and minimum-time problems, from which the latter are more challenging from a numerical point of view.
\subsection{Cart pendulum}
An unactuated pendulum is mounted on a cart, which is controlled by a horizontal force, with bounds on the
cart position, velocity and control force.
\begin{figure}
        \includegraphics[width=0.80\linewidth]{cart_pendulum.png} \centering
        \caption{\small Cart pendulum swing-up task, the initial and terminal configuration are colorized}
        \label{fig:cartpendulum}
\end{figure}
\subsubsection*{Model Predictive Control Problem}
A disturbance is applied while the pendulum is in the upward equilibrium position.
A quadratic objective encodes the task of stabilizing the pendulum while minimizing the total force input over the control horizon.
\subsubsection*{Swing Minimum Total Time Problem}
The pendulum starts in the downward configuration at a given cart position.
The goal is to swing the pendulum to an upward position in minimum total time.
Apart from the goal angle, also the translational velocity of the cart and the angular velocity of the pendulum are constrained to be zero at the beginning and end.
This task is visualized in Figure \ref{fig:cartpendulum}.
\subsection{Hanging Chain}
This nonlinear model predictive control benchmark problem was introduced in \cite{wirsching2006fast}.
The dynamical system consists of a hanging chain of six masses that are connected by springs.
The leftmost mass is rigidly attached to the world and the velocity of the rightmost mass is controlled.
The objective enforces stabilization of the system and the control inputs are limited. We consider both a 2D and a 3D version of this problem.
\subsection{Quadrotor}
% include the drone figure from drone.png
\begin{figure}
        \includegraphics[width=0.80\linewidth]{drone.png} \centering
        \caption{\small Quadrotor no-collision minimum total time problem with three obstacles.}
        \label{fig:drone}
\end{figure}
The orientation is represented by Euler angles. The control inputs are the acceleration in the upward direction of the drone and the Euler angle rates.
The control inputs are limited.
\subsubsection*{Model Predictive Control Problem}
The quadrotor starts in horizontal equilibrium position. It is disturbed by a velocity and change in orientation.
The quadratic objective encodes the task to stabilize the quadrotor and go back to the reference position and orientation.
% \subsubsection*{Tracking Problem}
% The quadratic objectives encodes a tracking task. The tracking trajectory is a circle in the horizontal plane. The initial position and orientation are given.
\subsubsection*{Point-to-point Minimum Total Time Problem}
The task is to move the quadrotor from a given initial position and orientation to a given final position and orientation in minimum total time.
The quadrotor has to start and end in equilibrium position.
\subsubsection*{No-collision Minimum Total Time Problem}
The task is the same as the point-to-point minimum total time problem, but now the quadrotor has to avoid cylindrical obstacles.
There is a variant with a single obstacle and a variant with three obstacles. The latter task is shown in Figure \ref{fig:drone}.
\subsection*{Seven Degree of Freedom Robot Manipulator}
The control inputs are the (seven) joint velocity setpoints of the robot.
The robot's joint position and joint velocity limits are taken into account.
\begin{figure}
        \includegraphics[width=0.80\linewidth]{robottraj_cut.png} \centering
        \caption{\small Seven degree of freedom robot manipulator with a spherical obstacle.}
        \label{fig:robot}
\end{figure}
% \subsubsection*{No-Collision Minimum Time Problem}
The robot has to move from a given position in joint space to a target XYZ position of the end effector in minimum-time.
The robot should avoid collision with a spherical object as shown in Figure \ref{fig:robot}.
The collision model is based on a capsule-based collision model provided by the robot manufacturer.
\subsection*{Truck with Two Trailers}
\begin{figure}
\includegraphics[width=0.75\linewidth]{truck_trailer.png} \centering
        \caption{\small Optimal trajectory for truck with two trailers task, the truck and trailer are drawn in the terminal position. The colored lines indicate the trajectory of the coupling of truck and trailers.}
        \label{fig:truck_trailer}
\end{figure}
As indicated in Figure \ref{fig:truck_trailer}, the task involves a truck with two trailers that starts with truck and trailer horizontally aligned and has to park truck and trailer aligned vertically at a given target location in minimum-time.
A kinematic model is used with the control inputs being the steering angular velocities and the velocity of front wheels.
% The control inputs are limited to a maximum velocity.
% \subsection*{Moonlander}
% \subsection*{Shape-Preserving Trajectory Generation}
% A 3D Cartesian trajectory is recorded from a demonstration. 
% The goal is to generate a trajectory that is similar in shape to the demonstration, between a new initial and terminal position.
% Invariant shape descriptors are used as a measure of shape similarity between the demonstrated and the newly generated trajectory.
% The OCP formulation is borrowed from Vochten et al. REF.


% as depicted in Figure ...

\section{Implementation Details}\label{sec:implementationdetails}
\begin{table}[h]
        \centering
        \Scale[0.9]{ % \setlength{\tabcolsep}{3pt}
                \begin{tabular}{|l|cccccc|}
                        \hline
                        problem                  & $K$ & $n_x$ & $n_u$ & $n_i$ & $n_e[0]$ & $n_e[K]$ \\
                        \hline
                        cart-pendulum mpc        & 25  & 4     & 1     & 0     & 4        & 0        \\
                        cart-pendulum swing*     & 100 & 5     & 1     & 3     & 4        & 3        \\
                        hanging chain 2D mpc     & 25  & 26    & 2     & 2     & 26       & 0        \\
                        hanging chain 2D mpc     & 25  & 39    & 3     & 3     & 39       & 0        \\
                        quadrotor mpc            & 25  & 10    & 4     & 6     & 10       & 0        \\
                        quadrotor p2p*           & 25  & 11    & 4     & 6     & 10       & 8        \\
                        quadrotor one obs*       & 25  & 11    & 5     & 8     & 10       & 8        \\
                        quadrotor three obs*     & 100 & 11    & 7     & 12    & 10       & 8        \\
                        robot manipulator obs*   & 50  & 8     & 18    & 37    & 7        & 3        \\
                        truck with two trailers* & 50  & 8     & 2     & 6     & 5        & 5        \\
                        \hline
                \end{tabular}
        }
        \caption{\small Overview of problems dimensions. The problems with an asterisk (*) are minimum-time problems. Furthermore, $K$ is the control horizon, $n_x$ the number of states, $n_u$ the number of controls, $n_i$ the number of inequality constraints, $n_e[0]$ and $n_e[K]$ the number initial and the terminal equality constraints, respectively}
        \label{tab:probdims}
\end{table}
In Table \ref{tab:probdims} the dimensions of each problem are given.
Below, we discuss how no-collision constraints and minimum-time problems were handled. 
% For more details about problems specification and implementation we refer to the benchmark code available at \url{https://gitlab.kuleuven.be/robotgenskill/fatrop/fatrop_benchmarks}.
\subsubsection*{No-collision constraints}
In contrast to all other inequality constraints considered in this benchmark set, the no-collision constraints of the Quadrotor and Robot Manipulator were not implemented directly.
This was because we observed in our experiments that the no-collision constraints had difficulties with the combination of the interior points method's strictly feasibility requirements of the slack variables and the nonconvex nature of the considered inequality constraints.
Sometimes the feasibility restoration phase of \pkg{Ipopt} was able to overcome this issue but, it sometimes required many iterations, converged to spurious local minima or even failed.
At the moment of writing, \pkg{fatrop} does not implement the feasibility restoration phase, which makes the solver often fail if no-collision constraints are implemented as hard constraints.
As a remedy, we formulated the no-collision constraints as L1-penalized soft constraints (for all solvers), using a smooth reformulation similarly to \pkg{TrajOpt} \cite{schulman2014motion}.
% The inequality constraints introduced by this formulation were implemented directly, like all other inequality constraints.
We observed that, in our experiments with the \pkg{Ipopt} solver, this formulation was more stable and faster than the direct hard constraints implementation of the no-collision constraints.
Because of exactness of the L1-penalty method, the no-collision constraints were always satisfied to specified precision when a large enough penalty parameter was chosen.
\subsubsection*{Minimum Total Time Problems}
To formulate the minimum-time problems in the COCP \eqref{eq:COCP} form, we added the total time variable $T_k$ to the state vector. 
This state was constant over the whole control horizon $(T_{k+1} = T_k)$ and positiveness was enforced by adding the constraint $T_0 \geq 0$.
\subsubsection*{Transcription}
Transcription from continuous to discrete time was done using a Runge-Kutta 4 integrator.
\subsubsection*{Rockit}
We used \pkg{rockit} \cite{gillis2020effortless} to formulate the OCPs, this is an optimal control problem framework, built on top of \pkg{CasADi} \cite{andersson2019casadi}.
\pkg{Rockit} is interfaced to different solvers, including \pkg{fatrop}, \pkg{ipopt} and \pkg{acados}.
Installation instructions, examples and the code for reproducing the results of the benchmark of this paper is available at \url{https://gitlab.kuleuven.be/robotgenskill/fatrop/fatrop_benchmarks}.
\subsubsection*{Benchmarking configuration} \label{sec:setup}
\pkg{Fatrop} was compared to \pkg{Ipopt} and, if the problem formulation allowed it, to the \pkg{acados} SQP algorithm.
\pkg{Ipopt} is a state-of-the-art general-purpose nonlinear optimization solver while \pkg{Acados} is an OCP framework that implements a variety of algorithms with a strong focus on computation speed.
It has some similarities to \pkg{fatrop} as both use \pkg{blasfeo} for linear algebra operations, are able to incorporate exact Hessian information and implement algorithms based on the direct multiple shooting formulation.
The framework's SQP algorithm implements a line search globalization technique.
The problem structure supported by the \pkg{acados} framework is less  general (at the time of this writing) than \pkg{fatrop} (and \pkg{ipopt}) as equality path constraints are not supported, except for constraints that fix the initial state. 
% algorithmic quantities 
All quantities needed by the algorithms were evaluated from compiled C-code, that was generated using \pkg{CasADi} \cite{andersson2019casadi} SX functions.
We used \pkg{GCC} 9.4.0 with compiler flags \texttt{-Ofast -march=native} for this purpose.
Parallel function evaluation was not implemented for \pkg{ipopt}, so for fairness of comparison, this feature was turned off for both \pkg{acados} and \pkg{fatrop}.
% stopping criterion
\pkg{Ipopt} and \pkg{fatrop} used the same stopping criterion with a tolerance parameter \texttt{tol} of \num{1e-8}. 
We used the default stopping criterion for \pkg{acados}.
% \pkg{Acados} \texttt{SQP\_RTI} only takes one SQP iteration by design.
% linear algebra
\pkg{Ipopt} was configured to use the \pkg{ma57} linear solver (sequential), compiled with \pkg{metis} and \pkg{intel mkl}.
\pkg{Blasfeo}, the linear algebra library used by \pkg{fatrop} and \pkg{acados}, was compiled with \texttt{X64\_INTEL\_HASWELL - HP} target.
% default options
For \pkg{fatrop} and \pkg{Ipopt} we changed the default values of the algorithm parameters \texttt{mu\_init} to \num{1e2} and \texttt{gamma\_theta} to \num{1e-12}, because it benefited the time optimal problems for both solvers.
For \pkg{acados}, \pkg{hpipm} was used as inner QP solver with \texttt{EXACT\_HESSIAN} and \texttt{CONVEXIFY} presets. % for the SQP algorithm and the \texttt{GAUSS\_NEWTON} and \texttt{NO\_REGULARIZE} preset for the \texttt{SQP\_RTI} algorithm.
We tried out different numbers of partial condensing steps and took the results for the best performing setting.
We provided discrete-time \pkg{CasADi} integrator expressions, because it resulted in function evaluation that was roughly two to three times faster than providing the continuous-time dynamics differential equations and using the built-in integrator.
% test machine 
Our test machine was a notebook computer equipped with an Intel\textregistered~ Core\texttrademark~ i7-10850H Processor, running Ubuntu 20.04, with  Intel\textregistered~ Turbo Boost\texttrademark~ disabled.
% computer specs
\section{Numerical Results} \label{sec:results}
\pkg{Fatrop} and \pkg{Ipopt} were able to solve all minimum-time benchmark problems to the specified accuracy, even though no initial solution guess was provided.
A concern might be that the reduced system can become ill-conditioned when iterates come close to the inequality barriers.
We did not observe that this led to numerical issues in our experiments, although many inequality constraints were active at the solution of the minimum-time problems.
The benchmark results for the minimum-time problems are shown in Table \ref{tab:walltimeipopt}. 
\pkg{Fatrop} always outperformed \pkg{ipopt}, solving all problems in a few tens of milliseconds to about a hundred milliseconds.
\begin{table}[h] % \scriptsize
        \centering
        % \setlength{\tabcolsep}{2pt}
        \Scale[0.8]{       % \setlength{\tabcolsep}{3pt}
                \begin{tabular}{|l|rrr|rrr|} \hline
                        \multirow{2}{*}{problem name} & \multicolumn{3}{c|}{\pkg{fatrop}} & \multicolumn{3}{c|}{\pkg{ipopt}}                                                                                                                                               \\ % & \multicolumn{1}{c}{sqp}  & \multicolumn{1}{c|}{rti}  \\ \hline
                                                      & \multicolumn{1}{c}{\#it}          & \multicolumn{1}{c}{$t_{\text{tot}}$} & \multicolumn{1}{c|}{$t_\text{FE}$} & \multicolumn{1}{c}{\#it} & \multicolumn{1}{c}{$t_\text{tot}$} & \multicolumn{1}{c|}{$t_\text{FE}$} \\ \hline % & \multicolumn{1}{c}{sqp}  & \multicolumn{1}{c|}{rti}  \\ \hline
                        cart pendulum swing           & 88                                &  \textbf{35.37}                      &  8.33                              & 81                       &  125.29                            &   11.63                          \\ % &                          &                           \\
                        quadcopter p2p                & 63                                &  \textbf{10.44}                      &  1.94                              & 63                       &  79.96                             &   3.58                           \\ % &                          &                           \\
                        quadcopter one obs            & 86                                &  \textbf{17.02}                      &  3.02                              & 79                       &  100.70                            &   3.94                           \\ % &                          &                           \\
                        quadcopter three obs          & 170                               &  \textbf{135.11}                     &  26.64                             & 169                      &  706.28                            &   34.74                          \\ % &                          &                           \\
                        robot manipulator obs         & 38                                &  \textbf{35.51}                      &  11.88                             & 38                       &  136.65                            &   54.23                          \\ % &                          &                           \\
                        truck with two trailers       & 91                                &  \textbf{30.32}                      &  11.80                             & 83                       &  135.63                            &  16.39                           \\ \hline % &                          &                           \\ \hline
                \end{tabular}
        }
        \caption{\small Number of iterations, total and function evaluation wall time in milliseconds (ms) for the minimum time problems with \pkg{fatrop} and \pkg{Ipopt}.}
        \label{tab:walltimeipopt}
\end{table}
Only the problems with an MPC formulation were benchmarked with \pkg{acados}, because this solver did not allow the problem formulation of the minimum time problems due to the presence of terminal (or path) equality constraints.
The results for these problems are shown in Table \ref{tab:walltimeipopt}.
\begin{table}[h] % \scriptsize
        \centering
        \Scale[0.8]{        \setlength{\tabcolsep}{2pt}
                \begin{tabular}{|l|rrr|rrr|rrr|} \hline
                        \multirow{2}{*}{problem name} & \multicolumn{3}{c|}{\pkg{fatrop}} & \multicolumn{3}{c|}{\pkg{acados}}    & \multicolumn{3}{c|}{\pkg{ipopt}}                                                                                                                                                                                                             \\ % & \multicolumn{0}{c}{sqp}  & \multicolumn{1}{c|}{rti}  \\ \hline
                                                      & \multicolumn{1}{c}{\#it}          & \multicolumn{1}{c}{$t_{\text{tot}}$} & \multicolumn{1}{c|}{$t_\text{FE}$} & \multicolumn{1}{c}{\#it} & \multicolumn{1}{c}{$t_\text{tot}$} & \multicolumn{1}{c|}{$t_\text{FE}$} & \multicolumn{1}{c}{\#it} & \multicolumn{1}{c}{$t_\text{tot}$} & \multicolumn{1}{c|}{$t_\text{FE}$} \\ \hline % & \multicolumn{1}{c}{sqp}  & \multicolumn{1}{c|}{rti}  \\ \hline
                        cart pendulum mpc             & 6                                 & $\textbf{0.54} $                     & 0.15                               & 2                        & 0.59                               & 0.10                               & 6                        & 3.31                               & 0.23                               \\ % & 0.99                     & 0.37                      \\
                        quadcopter mpc                & 12                                & $\textbf{1.71} $                     & 0.41                               & 5                        & 5.31                               & 0.39                               & 12                       & 9.61                               & 0.65                               \\ % & 7.11                     & 1.24                      \\
                        hanging chain 2D mpc          & 14                                & 7.61                                 & 4.02                               & 4                        & $\textbf{5.22}$                    & 1.93                               & 14                       & 60.48                              & *                                  \\ % & 10.14                    & 1.42                      \\
                        hanging chain 3D mpc          & 14                                & 17.62                                & 10.29                              & 3                        & $\textbf{9.76}$                    & 4.51                               & 14                       & 83.96                              & *                                  \\ \hline % & 20.08                    & 2.79                      \\
                \end{tabular}
        }
        \caption{\small Number of iterations, total and function evaluation wall time in milliseconds (ms) for the MPC problems with \pkg{fatrop}, \pkg{acados} and \pkg{ipopt}.
                For the results with an asterisk (*), function evaluation time is excluded from the total time because the CasADi virtual machine was used instead of compiled generated C-code.
                For these problems compilation failed due to insufficient available memory on the test machine.} \label{tabel:walltimempc}
\end{table}
\pkg{Fatrop} and \pkg{acados} were always faster than \pkg{Ipopt}, solving all problems in a few milliseconds. 
The \pkg{acados} algorithm always converged in fewer iterations than \pkg{fatrop}, which explains why its function evaluation time was always lower than \pkg{fatrop}.
The SQP algorithm of \pkg{acados} solves a QP at every (outer) iteration which is computationally more expensive than solving the primal-dual system in a \pkg{fatrop} iteration.
This explains why \pkg{fatrop} was faster for the cart pendulum and quadcopter MPC problems, despite the higher number of iterations.
\pkg{acados}'s inner QP solver \pkg{hpipm} benefits from partial condensing \cite{frison2016pcond}, as the condensed quantities only have to be computed for every outer iteration.
Partial condensing is most beneficial for problems with a large number of states compared to the number of controls ($n_x \gg n_u$).
This, together with the lower number of function evaluations, explains why \pkg{acados} is faster than \pkg{fatrop} for the hanging chain problems.


% Using a partial condensing approach for \pkg{fatrop} would not improve the computation time because the condensed quantities would have to computed for every iteration.
\section{Conclusion} \label{sec:conclusion}
\pkg{Fatrop} is a novel trajectory optimization framework that is heavily inspired by the Ipopt algorithm, but achieves a speed-up by exploiting the optimal control structure at hand.
We demonstrated its versatility, numerical robustness and efficiency by solving a variety of benchmark problems.
The \pkg{fatrop} software is available at \url{https://gitlab.kuleuven.be/robotgenskill/fatrop/fatrop} under the GNU Lesser General Public License (LGPL).
Future work includes direct handling of no-collision constraints, by means of a specialized feasibility restoration phase, and optimization over Lie manifolds.
Additionally, at this moment the \pkg{fatrop}-\pkg{rockit} interface is limited to single stage problems. Another part of future work is the ability to transcribe multi-stage \pkg{rockit} problems to \pkg{fatrop}.
% \pagebreak
\section*{\small Acknowledgements}
\small
This result is part of a project that has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (Grant agreement: ROBOTGENSKILL No. 788298) and from the Research Foundation Flanders (FWO) (Grant agreement No. G0D1119N).
The authors would like to thank Bastiaan Vandewal and Mathias Bos for providing the dynamical models used for the truck-trailer and quadrotor benchmark problems, respectively.
% A special thanks to Ajay Sathya for helping with the development \pkg{fatrop}-\pkg{rockit} (\pkg{CasADi}) interface and all insightful discussions while developing this work.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{IEEEtran}
\bibliography{references}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}