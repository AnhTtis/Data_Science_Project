%!TEX root = ../main.tex

\begin{table}[b]
    \caption{SVCB records for one service with symbolic query names and concrete record data.}
    \label{tab:someipsdsvcbrecords}
    \centering
    \normalsize
    \setlength{\tabcolsep}{4pt}        % distance between table columns
    \renewcommand{\arraystretch}{0.85}  % distance between rows
    \begin{tabularx}{\linewidth}{ll} \toprule
        QNAME & RDATA (SVCB) \\
        \midrule
        \_someip.minor.major.instance.id.service.& \multirow{8}{\linewidth}{\parbox{3.0cm}{
                                                                        port=30509\\
                                                                        ipv4hint=10.0.0.5\\
                                                                        protocol=UDP
                                                                        instance=2\\
                                                                        major=1\\
                                                                        minor=2
                                                                        }}\\
        \_someip.major.instance.id.service.&\\
        \textcolor{lightgray}{\_someip.minor.instance.id.service.}&\\
        \_someip.minor.major.id.service.&\\
        \_someip.instance.id.service.&\\
        \_someip.major.id.service.&\\
        \textcolor{lightgray}{\_someip.minor.id.service.}&\\
        \_someip.id.service.&\\
        \bottomrule
    \end{tabularx}
\end{table}

\section{DNSSEC in SOME/IP Service Discovery}\label{sec:concept}
Our approach transforms \ac{SOME/IP} \ac{SD} to utilize the established Internet technologies \ac{DNSSEC} and \ac{DANE} for secure service discovery and authentication.
Therefor we first map \ac{SOME/IP} \ac{SD} data fields to DNS names and record data.
Second, we bind \ac{DANE} certificates to the service names to verify the authenticity.
Our prototype implementation is based on the \textit{vsomeip}~\cite{vsomeip-git} reference implementation, which dictates our architecture and naming.

\subsection{Designing a DNS Namespace for SOME/IP Services}
The main challenges in designing a suitable \ac{DNS} namespace for automotive services are to avoid collisions with existing query names, remain compatible with DNS naming conventions, and simultaneously preserve all \ac{SOME/IP} \ac{SD} query properties.
Four fields specify a service: service ID, instance ID, major version, and minor version.
In a \codeword{find} message, a subscriber must specify at least a service ID, and the other fields can be wildcarded.
For example, not specifying an instance ID results in receiving all running instances of a service.
In total, a service can be requested in $2^3$ ways.

Table~\ref{tab:someipsdsvcbrecords} shows DNS entries for a service based on \ac{SOME/IP} \codeword{find} parameters, using symbolic names for simplicity.
We use \textit{service} as the parent domain, which can be customized, for example, to an OEM or tier-X supplier.
More specifically, adding \textit{tier-x.oem} as the parent domain would enable a hierarchy that passes down the rights to maintain and certify service records in each subdomain.
The four data fields are prepended to the query name in the same order as in the \codeword{find} message service description. 
An unspecified field in a \codeword{find} message corresponds to the absence of that field in the query name.
The arrangement of the four fields is arbitrary, but must be followed consistently as they determine valid query names.
We prepend \textit{\_someip} to each branch, following the semantic scope of the attribute leaf name pattern.

We consider the two gray-marked query names specifying a minor version without a major version impractical and therefore invalid. 
Even though the \ac{SOME/IP} \ac{SD} specification does not object to such queries, the number of valid query names per service is reduced to six.

To prevent ambiguity when wildcarding different fields, we include the symbolic name before the data field value making records uniquely distinguishable. 
As per our namespace design, a service with ID 1, instance ID 2, major version 1, and minor version 2 has this concrete query name:
\smallskip

\centerline{\_someip.minor0x00000002.major0x01.instance0x0002.}
\centerline{id0x0001.service.}
% \medskip

\subsection{Choosing a Record Type for SOME/IP Endpoints}

The IETF specifies various record types for storing data in the \ac{DNS}.
To ensure interoperability between \ac{SOME/IP} \ac{SD} and \ac{DNSSEC}, we need a DNS record that can contain all information originally provided in \codeword{offer} messages.
This includes the service description (Figure~\ref{fig:find-offer-entry}) and additional endpoint options (Figure~\ref{fig:endpointoption}), specifying how to connect to a service using an IP address, L4-protocol, and port number.

\input{tex/tikz-drawings/someipsd-find-offer-entry}
\input{tex/tikz-drawings/someipsd-endpoint-option}

The main \ac{DNS} service record candidates are SRV and SVCB.
The SRV record~\cite{RFC-2782} specifies a service endpoint location, including a transport port and domain name data fields.
SRV record names should follow attribute leaf naming~\cite{RFC-8552}, using underscored names prepended to the parent domain for semantic classification of services, for example, including the transport protocol in the name (e.g., \mbox{\_ldap.\_tcp.example.com}). 
This does not comply with \ac{SOME/IP} \ac{SD} as the transport protocol is not specified in \codeword{find} messages.
Next, the SRV record does not provide a data field for the IP address of a service, but holds a domain name referencing an address record instead, which requires additional queries as a detour to obtain an address and available transport protocols.
The SVCB record~\cite{sbnsbpJR22} stores general purpose service bindings and is still an active IETF Internet-Draft in the converging phase to become a standard.
SVCB data includes fields for port number, IP address and 255 other fields for private use to store service parameters, making it our preferred option.

Table~\ref{tab:someipsdsvcbrecords} shows the SVCB record data uniform for all query names of a single service, with \codeword{offer} message fields and endpoint options mapped accordingly.
The record data refers to an UDP-accessible service at port 30509 and IP address 10.0.0.5 stored as ipv4hint, with instance ID 2, major version 1, and minor version 2 specified in case wildcards were used in the query name.
The instance ID, major version, minor version and layer 4 protocol are each mapped to one of the 255 fields for private use.


\subsection{Integrating the SOME/IP SD for using DNSSEC}
\ac{DNSSEC} ensures records are unchanged and correct when the subscriber receives them.
This is already an advantage over the \ac{SOME/IP} \ac{SD}, where anyone can send conflicting offers~\cite{zlkkassJR21}.
Our approach showcases the adaptation of a \ac{SOME/IP} stack for \ac{DNSSEC}-based service discovery using the open source reference implementation \textit{vsomeip}~\cite{vsomeip-git}.

Figure~\ref{fig:someipsddnsmod} depicts the conceptual architecture inherited from the \textit{vsomeip} stack, comprising an application, routing manager, and service discovery used by both the client and server.
The routing manager handles the local transport-specific endpoints for the applications and forwards messages between them. 

Our modifications to enable \ac{DNSSEC} during \ac{SOME/IP} \ac{SD} are also illustrated in Figure~\ref{fig:someipsddnsmod}.
Instead of the original \codeword{offer}/\codeword{find} procedure, the client retrieves the publisher endpoint description via a \ac{DNSSEC} resolver.
With that, publisher services no longer announce themselves, and we gain secure service discovery through the implicit trust established by \ac{DNSSEC} records.
Clients can subscribe to the service and receive published data after obtaining the service record.

\input{tex/tikz-drawings/someipsd-dns-modification}

\subsection{Ensuring Publisher Authenticity with DANE}
\ac{DNSSEC} verifies subscription parameters used to access the endpoint.
Nevertheless, attackers can still mimic this endpoint, for example, using IP spoofing.
\ac{DANE} validates publisher authenticity to ensure that the subscriber connects to the correct publisher.

Figure~\ref{fig:someipsdaugdns} shows our secure service discovery and invocation process.
After the subscriber has resolved the service endpoint through a DNS \codeword{query}, it subscribes to the service with the information from the SVCB record.
At the same time, the subscriber queries the DNS for the DANE TLSA record containing the public certificate of the service, which is again protected with \ac{DNSSEC}.
With this the subscriber can validate the signature of the publisher.

We employ a challenge-response scheme to ensure that the publisher endpoint is authentic and indeed the owner of the corresponding private key.
With the \codeword{subscribe} message, the subscriber sends a random 32-bit nonce in a \ac{SOME/IP} configuration option as a challenge to the publisher. 
The publisher signs the challenge with its private key and sends the subscription acknowledgement with the signed random nonce back to the subscriber, also utilizing a configuration option.
The subscriber validates the signature with the public certificate of the publisher, providing assurance of authenticity.
With a future extension, the subscriber and publisher could agree on a session key during the challenge-response process to enable message encryption for confidentiality.

\input{tex/tikz-drawings/someipsd-dns-augmented-sequence}

\subsection{Operating DNS-based Automotive Service Discovery}
In operation, we foresee that a car has a local \ac{DNSSEC} recursive resolver that caches verified records as soon as the car has Internet connectivity.
Each time a record is retrieved, the \ac{DNSSEC} recursive resolver ensures the chain of trust before caching it, eliminating the need for \ac{DNSSEC} validation during \ac{SD}.
This ensures that the service discovery is still operational when the vehicle is disconnected from the Internet.
Cached records are refreshed before they expire, and it shall be part of future experimentally driven research to determine appropriate cache lifetimes in real deployments.
In this way, our approach exploits the benefits of a well-established standard infrastructure for obtaining data integrity, authenticity, and a robust procedure for certificate management.
