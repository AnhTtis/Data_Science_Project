\newcommand{\NcoNTIME}{(N\cap\textit{coN})\textit{TIME}}


\subsection{Co-Nondeterministic Algorithms for Counting Problems with Integer Inputs}
\label{sec:nondet-int}

First, we show how to modify the co-nondeterministic algorithms in \cite{carmosino2016nondeterministic} to work for the counting versions of \AEExactTri{}, \AENegTri{} and \AllThreeSUM{}. 

Before we show these algorithms, we start with the following simple observation.
\begin{claim}
\label{cl:sumof3neg}
For any integers $a, b, c$, $a+b+c \le 0$ if and only if one of the followings is true: 
\begin{itemize}
    \item $\lceil \frac{a}{2} \rceil + \lceil \frac{b}{2} \rceil  + \lceil \frac{c}{2} \rceil \le 0$;  
    \item At least $2$ of $a,b,c$ are odd and $\lceil \frac{a}{2} \rceil + \lceil \frac{b}{2} \rceil  + \lceil \frac{c}{2} \rceil = 1$. 
\end{itemize}
\end{claim}

It has the following immediate consequence:
\begin{lemma}
\label{lem:negtri_to_exacttri}
Given a \AENegTriCount{} instance on an $n$-node tripartite graph $G$ with node partitions $A$, $B$, and $C$ and with edge weights in $[\pm n^{O(1)}]$, we can reduce it to $O(\log n)$ instances of \AEExactTriCount{} on graphs with the same vertex set and with edge weights in  $[\pm n^{O(1)}]$ deterministically in $\OO(n^2)$ time. Furthermore, the count for an edge in the original \AENegTriCount{}  instance can be written as a sum of the count for the corresponding edge among the \AEExactTriCount{} instances (if this edge does not exist in a certain instance, then the count is simply $0$). 
\end{lemma}
\begin{proof}
Without loss of generality, we assume that the instance $G$ has weight function $w$ and  we would like to compute for every $a\in A,c\in C$, the number of $b\in B$ such that $w(a,b)+w(b,c)+w(a,c)<0$. Then we add $1$ to the weight of every edge $(a, c) \in A \times C$. Now we need to count the number of number of $b\in B$ such that $w(a,b)+w(b,c)+w(a,c)\le 0$.

Consider recursing with respect to the bound $[\pm W]$ on the edge weights, initially $W = n^{O(1)}$. 
\begin{enumerate}
    \item If $W = O(1)$. Then we enumerate all possible combinations of $3$ weights $w_1, w_2, w_3 \in [\pm W]$ such that $w_1 + w_2 + w_3 \le 0$, and for each combination, we create an \AEExactTriCount{} instance with all edges $(a, b) \in A \times B$ s.t. $w(a, b) = w_1$, all edges $(b, c) \in B \times C$ s.t. $w(b, c) = w_2$ and all edges $(c, a) \in C \times A$ s.t. $w(c, a) = w_3$. In these instances, we make all edge weights $0$, so that all triangles have weights $0$. Thus, the total number of exact triangles through edge $(a, c)$ in these $O(1)$ instances is exactly the number of non-positive-weight triangles through edge $(a, c)$ in the original instance. 
    \item Otherwise, consider Claim~\ref{cl:sumof3neg}. A triangle $(a, b, c)$ has $w(a, b) + w(b, c) + w(c, a) \le 0$ if and only if $\lceil \frac{w(a, b)}{2} \rceil + \lceil \frac{w(b, c)}{2} \rceil  + \lceil \frac{w(c, a)}{2} \rceil \le 0$ or at least $2$ of $w(a, b),w(b, c), w(c, a)$ are odd and $\lceil \frac{w(a, b)}{2} \rceil + \lceil \frac{w(b, c)}{2} \rceil  + \lceil \frac{w(c, a)}{2} \rceil = 1$. Note that these two cases are disjoint, so we can separately consider them and sum up the counts. For the first case, we can create a graph $G'$ by replacing the  weight $w(u, v)$ of each edge with $\lceil \frac{w(u, v)}{2}\rceil$ and recursively solve the problem on $G'$. For the second case, we enumerate which subset of  $w(a, b), w(b, c)$ and $w(c, a)$ are odd (there should be at least two of them) and keep the corresponding edges in $G'$ only if they meet the parity condition. This way, we will create $4$ sub-problems, where each sub-problem is an exact triangle instance with target value $1$. 
\end{enumerate}
Overall, we will create $O(\log n)$ \AEExactTriCount{} instances as initially $W=n^{O(1)}$. 
\end{proof}
\begin{remark}\rm
Lemma~\ref{lem:negtri_to_exacttri} implies that \AENegTriCount{} subcubically reduces to \AEExactTriCount{}. As shown in~\cite{AbboudFW20}, \ExactTriCount{} reduces to \NegTriCount{}, and the same reduction works from  \AEExactTriCount{} to \AENegTriCount{}. Thus, \AENegTriCount{} and \AEExactTriCount{} are subcubically equivalent. By Theorem~\ref{thm:exact-tri-count}, they are also subcubically equivalent to \AEExactTri{}. 
\end{remark}

\begin{theorem}
\label{thm:nondet-int-exacttri-count}
\AEExactTriCount{} for graphs with integer weights in $[\pm n^\alpha]$ for any constant $\alpha$ is in $\NcoNTIME[\OO(n^{(3+\omega)/2})]$. The same bound holds for \AENegTriCount{}. 
\end{theorem}
\begin{proof}

Suppose we are given an instance of \AEExactTriCount{}. Without loss of generality, we assume the instance is a weighted graph $G$ with node partitions $A$, $B$, and $C$ and weight function $w$, and  we would like to compute for every $a\in A,c\in C$, the number of $b\in B$ such that $w(a,b)+w(b,c)+w(a,c)=0$. We will actually more generally count the number of negative-weight, zero-weight, and positive-weight triangles through each edge in $A \times C$. 

Both the prover and the verifier run the reduction in Lemma~\ref{lem:negtri_to_exacttri} on $G$ to get \AEExactTriCount{} instances $G_{<}^{(1)}, \ldots, G_{<}^{(O(\log n))}$. They also similarly run the reduction in Lemma~\ref{lem:negtri_to_exacttri} on $G$ but with all edge weights negated to  get \AEExactTriCount{} instances $G_{>}^{(1)}, \ldots, G_{>}^{(O(\log n))}$. Without loss of generality, we can assume these \AEExactTriCount{} instances all have target value  $0$. By construction in Lemma~\ref{lem:negtri_to_exacttri}, all these graphs have the same vertex set $A \cup B \cup C$.  Also, let $q$ be a constant to be fixed later. 

The prover provides the following for each of the graphs $G, G_{<}^{(1)}, \ldots, G_{<}^{(O(\log n))}, G_{>}^{(1)}, \ldots, G_{>}^{(O(\log n))}$ (we refer to it by $G'$):
\begin{itemize}
    \item A prime $p$ in the interval $[n^{1-q},Cn^{1-q}\log n]$ for a  large enough constant $C$.
    
    The prime $p$ is supposed to be such that the number of triangles in $G'$ that are zero mod $p$ but are nonzero otherwise is at most $O(n^{2+q})$. Such a prime is guaranteed to exist since each triangle that has nonzero weight in $[-n^\alpha,n^\alpha]$ is zero mod at most $\log(3n^\alpha)/\log(n^{1-q})$ primes in the interval $[n^{1-q},Cn^{1-q}\log n]$. The interval contains at least $n^{1-q}$ primes, so some prime must give rise to at most $\frac{n^3\log(3n^\alpha)}{\log(n^{1-q}) \cdot n^{1-q}} =O(n^{2+q})$ fake zero triangles.

    \item A set $R$ of $O(n^{2+q})$ triangles. These are supposed to be the triangles in $G'$ that are nonzero but are zero mod $p$.

\end{itemize}



The verifier first checks that $R$ contains only triangles whose weights are nonzero but are zero mod $p$. This takes $O(|R|) = O(n^{2+q})$ time.  Then it counts in $\tilde{O}(n^{1-q+\omega})$ time (using \cite{ALONGM1997}) the number of triangles that are zero mod $p$ through each edge $(a, c)$. Call it $t_{G'}(a, c)$. For each edge $(a, c)$, the  verifier subtracts the number of triangles through it in $R$ from $t_{G'}(a, c)$. Now, notice that $t_{G'}(a, c)$ must be an upper bound on the number of zero triangles through $(a, c)$; also, if $R$ contains all the triangles whose weights are nonzero but are zero mod $p$ as it is supposed to, $t_{G'}(a, c)$ will be equal to the number of zero triangles through $(a, c)$. 

Now, the verifier applies the second part of Lemma~\ref{lem:negtri_to_exacttri} to sum up the corresponding counts. For every edge $(a, c) \in A \times C$, it will get $T_{<}(a, c) = \sum_{i} t_{G_{<}^{(i)}}(a, c)$, which is supposed to be the number of negative-weight triangles through $(a, c)$; $T_{>}(a, c)=\sum_{i} t_{G_{>}^{(i)}}(a, c)$, which is supposed to be the number of positive-weight triangles through $(a, c)$; and $t_{G}(a, c)$, which is supposed to be the number of zero-weight triangles through $(a, c)$. 

Then the algorithm counts the number of triangles $s(a, c)$ through each edge $(a, c)$ in $\tO(n^\omega)$ time. 

Finally, the algorithm verifies $s(a, c) = T_{<}(a, c) + T_{>}(a, c) + t_{G}(a, c)$ and then outputs $t_G(a, c)$ for every edge $(a, c)$. 

The correctness of the algorithm relies on the following: Suppose $s_{<}(a, c), s_{=}(a, c), s_{>}(a, c)$ are the actual number of negative-weight, zero-weight, and positive-weight triangles through each edge $(a, c)$. Then by previous discussion, the algorithm is sure that $s_{<}(a, c) \le T_{<}(a, c), s_{=}(a, c) \le t_G(a, c)$ and $ s_{>}(a, c) \le T_{>}(a, c)$, and trivially $s(a, c) = s_{<}(a, c) + s_{=}(a, c) +s_{>}(a, c)$. These two combined with $s(a, c) = T_{<}(a, c) + T_{>}(a, c) + t_{G}(a, c)$ implies $s_{<}(a, c) = T_{<}(a, c), s_{=}(a, c) = t_G(a, c)$ and $s_{>}(a, c) = T_{>}(a, c)$. 

The running time is $\OO(n^{2+q}+n^{1-q+\omega})$ and is minimized for $q=(\omega-1)/2$.
The verifier's running time is thus $\OO(n^{(3+\omega)/2})$.

The above algorithm clearly also works for \AENegTriCount{}. 
\end{proof}

Similarly, we can design a sub-quadratic time co-nondeterministic algorithm for \AllThreeSUMCount{}. 

\begin{theorem}
\label{thm:nondet-int-3sum-count}
    \AllThreeSUMCount{} for size-$n$ sets $A, B, C$ of integers  in $[\pm n^\alpha]$ for any constant $\alpha$ is in $\NcoNTIME[\OO(n^{1.5})]$.
\end{theorem}
\begin{proof}[Proof sketch]
    The proof is essentially the same as the proof of Theorem~\ref{thm:nondet-int-exacttri-count}, with the following modifications. 

    Without loss of generality, we assume \AllThreeSUMCount{} asks to count the number of $(a, b) \in A \times B$ where $a + b + c = 0$ for every fixed $c \in C$. 
    
    Then, similar to Lemma~\ref{lem:negtri_to_exacttri}, we can reduce counting the number of $(a, b) \in A \times B$ where $a + b + c < 0$ and counting the number of $(a, b) \in A \times B$ where $a + b + c > 0$ to $O(\log n)$ instances of \AllThreeSUMCount{}. 

    For each of these instances on $(A', B', C')$, the prover provides a prime $p$ in the interval $[n^{1+q}, C n^{1+q} \log n]$ for a large enough constant $C$ and a constant $q$ to be fixed. It also provides a set of $R$ of $O(n^3 / n^{1+q}) = O(n^{2-q})$ triples $(a, b, c)$, which are supposed to be the triples in $A' \times B' \times C'$ whose sums are nonzero but are zero mod $p$. 

    For each of these instances, the verifier checks that $R$ contains only triples whose sum is nonzero but is zero mod $p$. Then it counts in $\OO(p) = \OO(n^{1+q})$ time (using FFT) the number of triples $(a, b, c)$ whose sum is zero mod $p$ for every $c \in C'$, and then subtracts the corresponding count in $R$ from this count. 

    Similar to Theorem~\ref{thm:nondet-int-exacttri-count}, by summing up the counts in all these instances for every $c \in C$, and checking whether that equals $|A||B|$, the verifier will be sure to get the correct count of zero-sum triples involving each $c \in C$. 

    The running time of the verifier is $\OO(n^{1+q}+n^{2-q})$, which is $\OO(n^{1.5})$ by setting $q=0.5$. 
    
\end{proof}

\subsection{Co-Nondeterministic Algorithms for Counting Problems with Real Inputs}
\label{sec:nondet-real}

The co-nondeterministic algorithms in Section~\ref{sec:nondet-int} heavily rely on the idea of modulo a prime $p$, which will no longer be possible if the input numbers are reals. In this section, we study algorithms for \AEExactTriCountReal{}, \AENegTriCountReal{} and \AllThreeSUMCountReal{}. 

For problems with real inputs in the nondeterministic model, we assume the verifier has access to a ``Reasonable'' Real RAM model, which was  discussed in \cite{CVXstoc22}. In such models, only a restricted subset of operations are allowed on the real-valued inputs, while any operations in the Word RAM model with $O(\log n)$-bit words are allowed for the integer parts of the computation. In particular, our algorithms work in the Real RAM with low-degree predicates model. Also, if we slightly change the definition of \ExactTri{} to finding a triangle $(a, b, c)$ such that $w(a, b) + w(b, c) = w(a, c)$ (and similarly for \NegTri{}), our algorithms will work in the Real RAM with 4-linear comparisons model. See \cite{CVXstoc22} for more details about ``Reasonable'' Real RAM models. 




Our ideas for proving equivalence between counting and detection problems can be used to obtain new nondeterministic algorithms for counting problems with real inputs, as we show in this subsection.

We start with the following co-nondeterministic algorithm for \Equality{} and \Dominance{}. 

\begin{lemma}
\label{lem:nondet-equality}
    \Equality{} between an $n_1 \times n_2$ matrix $A$ and an $n_2 \times n_3$ matrix $B$, where we only need to determine the results on a given subset $X \subseteq [n_1] \times [n_3]$, is in $$\NcoNTIME\left[\OO\left( |X|n_2^s +  M(n_1, n_2^{2-s}, n_3) \right)\right]$$ time for any $s \in [0, 1]$. The same bound holds for \Dominance{}. 
\end{lemma}
\begin{proof}
    Without loss of generality, we can assume all entries of $A$ and $B$ are integers in $O(n_1n_2 + n_2n_3)$, by replacing each entry by its rank. 

    For every $(i, j) \in [n_1] \times [n_3]$, we use $c_{=}(i, j)$ to denote the number of $k$ where $A_{i k} = B_{k j}$, $c_{<}(i, j)$ to denote the number of $k$ where $A_{i k} < B_{k j}$ and $c_{>}(i, j)$ to denote the number of $k$ where $A_{i k} > B_{k j}$. Instead of only computing $c_{=}(i, j)$ for $(i, j) \in X$, we will more generally compute $c_{<}(i, j)$ and $c_{>}(i, j)$ as well. 

    By known reductions from \Dominance{} to \Equality{} \cite{labib2019hamming,vnotes}, we can create $O(\log n)$ instances of \Equality{} on matrices of the same dimensions, and use the sum of resulting values on entry $(i, j)$ over these $O(\log n)$ instances to compute $c_{<}(i, j)$. It similarly holds for $c_{>}(i, j)$. 

    For each of the $O(\log n)$ instances of \Equality{} (the $O(\log n)$ instances generated above, and the original instance), the prover provides the following (say the instance is on matrices $A', B'$):
    \begin{itemize}
    \item A prime $p$ in the interval $[n_2^{1-s},Cn_2^{1-s}\log (n_2)]$ for a  large enough constant $C$.
    
    The prime $p$ is supposed to be such that the number of triples $(i, k, j)$ where $(i, j) \in X$, $k \in [n_2]$ and $A'_{i k} \ne B'_{k j}$ while $A'_{i k} \equiv B'_{k j} \pmod{p}$ is at most $\OO(|X|n_2^{s})$. Such a prime is guaranteed to exist since for every triple $(i, k, j)$ with $A'_{i k} \ne B'_{k j}$, $A'_{i k}$ and $B'_{k j}$ are congruent mod at most  $\OO(1)$ primes in the interval $[n_2^{1-s},Cn_2^{1-s}\log (n_2)]$. The interval contains at least $n_2^{1-s}$ primes, so some prime must give rise to at most $\OO\left(\frac{|X|n_2}{n_2^{1-s}}\right) = \OO(|X|n_2^s)$ fake zero triangles.

    \item A set $R$ of $\OO(|X|n_2^{s})$ triples $(i, k, j)$ where $(i, j) \in X$ and $k \in [n_2]$. These are supposed to be the triples where $A'_{i k} \ne B'_{k j}$ while $A'_{i k} \equiv B'_{k j} \pmod{p}$. 

\end{itemize}

The verifier is similar to the verifier in the proof of Theorem~\ref{thm:nondet-int-exacttri-count}. For each  \Equality{} instance, after checking that the set $R$ only contains triples $(i, k, j)$ where $(i, j) \in X$, $k \in [n_2]$ and $A'_{i k} \ne B'_{k j}$ while $A'_{i k} \equiv B'_{k j} \pmod{p}$ in $\OO(|R|)$ time, it computes $C'_{i j}$, the number of $k \in [n_2]$ such that   $A'_{i k} \equiv B'_{k j} \pmod{p}$, for each pair of $(i, j) \in [n_1] \times [n_3]$ in $\OO(M(n_1, p n_2, n_3))$ time, by packing $p$ instances of matrix multiplications of dimensions $n_1 \times n_2 \times n_3$ together. Similar as before, by subtracting the number of triples involving $(i, j)$ in $R$ from $C'_{i j}$, $C'_{i j}$ becomes an upper bound on the number of $k$ such that $A'_{i k} = B'_{k j}$. 

Finally, by checking that the sum of $C'_{i j}$ over all the \Equality{} instances equals $n_2$ for every $(i, j) \in X$, the verifier will be sure that $C'_{i j}$ equals exactly the number of $k$ such that $A'_{i k} = B'_{k j}$ in each of the instances. In particular,  it can compute $c_{=}(i, j), c_{<}(i, j)$ and $c_{>}(i, j)$ for every $(i, j) \in X$. 

The running time of the verifier is $\OO(|R|+M(n_1, p n_2, n_3)) = \OO(|X|n_2^s +  M(n_1, n_2^{2-s}, n_3))$, as desired. 

\end{proof}

Next, we are ready to present our co-nondeterministic algorithm for  \AEExactTriCountReal{} and \AENegTriCountReal{}. 

\begin{theorem}
\label{thm:nondet-real-exacttri-count}
\AEExactTriCountReal{} for $n$-node graphs is in $\NcoNTIME[\OO(n^{\frac{6+\omega}{3}})]$. The same bound holds for \AENegTriCountReal{}. 
\end{theorem}
\begin{proof}
    Without loss of generality, we assume the instance is a weighted graph $G$ with node partitions $A$, $B$, and $C$ and weight function $w$, and  we would like to compute for every $a\in A,c\in C$, the number of $b\in B$ such that $w(a,b)+w(b,c)+w(a,c)=0$.  Also, let $q$ be a constant to be fixed later. 

    The prover provides the following:

    \begin{itemize}
        \item A subset $R \subseteq [n]$ of size $\OO(n^q)$. 

        For every $(a, c) \in A\times C$, let $L_{a c} = \{w(a, b) + w(b, c) : b \in R\}$. Let $p_{a c}$ be the index of the predecessor of $-w(a, c)$ (including $-w(a, c)$) in $L_{a c}$, i.e., it is $\argmax_{b \in R, w(a, b) + w(b, c) \le -w(a, c)} (w(a, b) + w(b, c))$, and let $s_{a c}$ be the index of the successor of $-w(a, c)$ (excluding $-w(a, c)$) in $L_{a c}$, i.e., it is  $\argmin_{b \in R, w(a, b) + w(b, c) > -w(a, c)} (w(a, b) + w(b, c))$. The set $R$ is supposed to be that, if $-w(a, c) \not \in L_{a c}$, then the number of $b \in B$ where $w(a, p_{a c}) + w(p_{a c}, c) < w(a, b) + w(b, c) < w(a, s_{a c}) + w(s_{a c}, c)$ is $O(n^{1-q})$. Such $R$ exists because a random $R$ satisfies these properties with high probability. 

        \item For every $b_0 \in R$, the prover  uses the protocol in Lemma~\ref{lem:nondet-equality} to create outputs for the purpose of counting $\left| \left\{w(a, b) - w(a, b_0) = w(b_0, c) - w(b,c) : b \in B \right\}\right|$ and $\left| \left\{w(a, b) - w(a, b_0) \le w(b_0, c) - w(b,c) : b \in B \right\}\right|$, where $X$ is the set of $(a, c)$ such that $b_0 = p_{a c}$ or $b_0 = s_{a c }$. 

        \item Finally, for every $(a, c)$ with $-w(a, c) \not \in L_{a c}$, it provides a list $\ell_{a c} \subseteq [n]$, which is supposed to contain all indices $b$ with $w(a, p_{a c}) + w(p_{a c}, c) < w(a, b) + w(b, c) < w(a, s_{a c}) + w(s_{a c}, c)$. Note that $|\ell_{a c}|=O(n^{1-q})$ by the choice of $R$. 
    \end{itemize}

    The verifier does the following. First, it computes $L_{a c}, p_{a c}, s_{a c}$ in $\OO(n^2 |R|) = \OO(n^{2+q})$ time. 
    Next, it uses the algorithm in Lemma~\ref{lem:nondet-equality} to correctly count, for every $b_0 \in R$, the values of $$\left| \left\{w(a, b) - w(a, b_0) = w(b_0, c) - w(b,c) : b \in B \right\}\right|$$ and $$\left| \left\{w(a, b) - w(a, b_0) \le w(b_0, c) - w(b,c) : b \in B \right\}\right|$$ for  $(a, c)$ such that $b_0 = p_{a c}$ or $b_0 = s_{a c}$. Let $x_i$ be the size of $X$ for the $i$-th call of Lemma~\ref{lem:nondet-equality}. The running time of the $i$-th call of Lemma~\ref{lem:nondet-equality} can be bounded by
    $$\OO\left(|X|n^s +  M(n, n^{2-s}, n) \right) = \OO\left(|X| n^s + n^{1-s} n^\omega\right) = \OO(n^{\frac{\omega+1}{2}} \sqrt{x_i} + n^\omega), $$
    by setting $n^s = \min\left(n, \sqrt{\frac{n^{1+\omega}}{|X|}}\right)$. 
    Then we notice that $\sum_i x_i = O(n^2)$. Therefore, by convexity, the running time can be bounded as 
    \begin{align*}
        \sum_i \OO\left(n^{\frac{\omega+1}{2}}\sqrt{x_i} + n^\omega\right) 
        &= \OO \left( |R| \cdot n^{\frac{\omega+1}{2}}\sqrt{\frac{n^2}{|R|}} + |R| \cdot n^\omega\right)
        = \OO(n^{\frac{\omega+3+q}{2}} + n^{\omega+q}).
    \end{align*}

     For some $(a, c)$, if $w(a, p_{a c}) + w(p_{a c}, c) = -w(a, c)$, then by Fredman's trick, 
        \begin{align*}
            &\left| \left\{w(a, b) - w(a, b_0) = w(b_0, c) - w(b,c) : b \in B \right\}\right|\\
            =& \left| \left\{w(a, b) + w(b,c)  = w(a, b_0) + w(b_0, c) : b \in B \right\}\right|\\
            =& \left| \left\{w(a, b) + w(b,c)  + w(a, c) = 0 : b \in B \right\}\right|
        \end{align*}
    for $b_0 = p_{a c}$, which is exactly the count we seek. 
    Otherwise, the algorithm computes the number of $b$ where $w(a, p_{a c}) + w(p_{a c}, c) < w(a, b) + w(b, c) < w(a, s_{a c}) + w(s_{a c}, c)$ via
    \begin{align*}
        &\left| \left\{w(a, b) - w(a, s_{a c}) \le w(s_{a c}, c) - w(b,c) : b \in B \right\}\right|\\ 
        -& \left| \left\{w(a, b) - w(a, s_{a c}) = w(s_{a c}, c) - w(b,c) : b \in B \right\}\right|\\
        - & \left| \left\{w(a, b) - w(a, p_{a c}) \le w(p_{a c}, c) - w(b,c) : b \in B \right\}\right|, 
    \end{align*}  
    where all three counts are computed earlier. Next, the verifier checks that the length of $\ell_{a c}$ equals this count, and for every $b \in \ell_{a c}$, the verifier checks  $w(a, p_{a c}) + w(p_{a c}, c) < w(a, b) + w(b, c) < w(a, s_{a c}) + w(s_{a c}, c)$. If these checks pass, then $\ell_{a c}$ contains exactly the set of $b$ where $w(a, p_{a c}) + w(p_{a c}, c) < w(a, b) + w(b, c) < w(a, s_{a c}) + w(s_{a c}, c)$. By the definition of $p_{a c}$ and $s_{a c}$, it must be the case that $w(a, p_{a c}) + w(p_{a c}, c) < -w(a, c) < w(a, s_{a c}) + w(s_{a c}, c)$. Therefore, by reading the list $\ell_{a c}$ and count how many $b \in \ell_{a c}$ has $w(a, b) + w(b, c) = -w(a, c)$, the verifier can correctly compute the number of exact triangles through edge $(a, c)$. Overall, the cost of this step is the total length of $\ell_{a c}$, which is $O(n^{3-q})$. 
        
    The running time of the verifier is $\OO(n^{2+q} + n^{\frac{\omega+3+q}{2}} + n^{\omega+q}+n^{3-q})$. By setting $q = \frac{3-\omega}{3}$, it becomes $\OO(n^{\frac{6+\omega}{3}})$. 

    To adapt the algorithm to \AENegTriCountReal{}, for every $(a, c)$, we also count the number of $b$ such that $w(a, b) + w(b, c) < w(a, p_{ac}) + w(p_{ac}, c)$ via 
    \begin{align*}
       & \left| \left\{w(a, b) - w(a, p_{a c}) \le w(p_{a c}, c) - w(b,c) : b \in B \right\}\right| \\ 
       -& \left| \left\{w(a, b) - w(a, p_{a c}) = w(p_{a c}, c) - w(b,c) : b \in B \right\}\right|. 
    \end{align*} 
    If $-w(a, c) \in L_{ac}$, then $w(a, p_{ac}) + w(p_{ac}, c) = w(a, c)$, so the above count is exactly the number of negative triangles through $(a, c)$. Otherwise, every $b \in B$ with $w(a, b) + w(b, c) < w(a, p_{ac}) + w(p_{ac}, c) < -w(a, c)$ forms a negative triangle with $(a, c)$. All other negative triangles can be found via searching $\ell_{ac}$. 
\end{proof}

Before we present our co-nondeterministic algorithm for \AllThreeSUMCountReal{}, we first introduce the following lemma. 

\begin{lemma}
\label{lem:nondet-3sum-helper}
    Given an $n_1 \times n_2$ matrix $A$, an $n_3 \times n_2$ matrix $B$, and a  subset $X \subseteq [n_1] \times [n_3]$, counting the number of $(k, \ell)$ where $A_{i k} = B_{j \ell}$ for every $(i, j) \in X$ is in $$\NcoNTIME\left[\OO\left( |X|n_2^s +  M(n_1, n_2^{2-s}, n_3) \right)\right]$$ time for any $s \in [0, 1]$. Consequently, counting the number of $(k, \ell)$ where $A_{i k} \le B_{j \ell}$ for every $(i, j) \in X$ is also in $$\NcoNTIME\left[\OO\left( |X|n_2^s +  M(n_1, n_2^{2-s}, n_3) \right)\right]$$ time for any $s \in [0, 1]$.
\end{lemma}
\begin{proof}
    First, we can assume all entries of $A$ and $B$ are integers bounded by $O(n_1n_2 + n_2n_3)$, by replacing each entry by its rank. 
    
    We enumerate $b_1, b_2 \in  \{0\}\cup [\lfloor \log(n_2)\rfloor]$. If the occurrence of a number on the $i$-th row of $A$ has a $1$ in its binary representation on the bit corresponding to $2^{b_1}$, we keep one copy of this number on the $i$-th row of $A$; otherwise, we drop this number. Similarly, if the occurrence of a number on the $j$-th row of $B$ has a $1$ in its binary representation on the bit corresponding to $2^{b_2}$, we keep one copy of this number on the $j$-th row of $B$; otherwise, we drop this number. We then solve the original problem on these two modified matrices. Finally, we can sum up the results obtained on these modified matrices, weighted by $2^{b_1 + b_2}$. This way, we can assume all numbers on the $i$-th row of $A$ are distinct for any $i$, and all numbers on the $j$-th row of $B$ are distinct for any $j$. 

    The prover provides the following:
    \begin{itemize}
        \item A function $h: [O(n_1n_2 + n_2n_3)] \rightarrow [n_2]$. 

        The function is supposed to be that, for every $i \in [n_1]$, each value in $[n_2]$ matches at most $\tO(1)$ numbers in the multiset $\{h(A_{i k}): k \in [n_2]\}$. Similarly, for every $j \in [n_3]$, each value in $[n_2]$ matches at most $\tO(1)$ numbers in the multiset $\{h(B_{j k}): k \in [n_2]\}$. Such a function exists because a random function satisfies these constraints with high probability. 

        \item Two matrices $A', B'$. $A'$ is an $n_1 \times \tO(n_2)$ matrix, where the columns of it is indexed by $[n_2] \times [\tO(1)] \times [\tO(1)]$. For every $i \in [n_1], k \in [n_2], s_2 \in [\tO(1)]$, we set $A'_{i, (h(A_{i k}), s_1, s_2)}$ to $A_{i k}$, where $A_{i k}$ is the $s_1$-th number on row $i$ that get mapped to $h(A_{i k})$. Similarly, $B'$ is an $n_3 \times \tO(n_2)$ matrix, where the columns of it is indexed by $[n_2] \times [\tO(1)] \times [\tO(1)]$. For every $j \in [n_3], k \in [n_2], s_1 \in [\tO(1)]$, we set $B'_{j, (h(B_{j k}), s_1, s_2)}$ to $B_{j k}$, where $B_{jk}$ is the $s_2$-th number on row $j$ that get mapped to $h(B_{jk})$. All other entries of $A'$ and $B'$ are set to values distinct from any other values. 

        \item Use the protocol in Lemma~\ref{lem:nondet-equality} to create outputs for the purpose of computing the equality product between $A'$ and $B'^T$ with the output set $X$. 
    \end{itemize}

    The verifier does the following. First, it checks that $h, A', B'$ are valid. Then it runs the algorithm in Lemma~\ref{lem:nondet-equality} to compute, for every $(i, j) \in X$, the number of $(k, s_1, s_2)$ where $A'_{i, (k, s_1, s_2)} = B'_{j, (k, s_1, s_2)}$. Note that this is exactly the number of $(k, \ell)$ where $A_{i k} = B_{j \ell}$. The running time of the algorithm is same as that of Lemma~\ref{lem:nondet-equality}. 

    
    If we instead want to count the number of $(k, \ell)$ where $A_{i k} \le B_{j \ell}$ for every $(i, j) \in X$, we can use the idea that reduces \Dominance{} to \Equality{} \cite{labib2019hamming,vnotes} to create $\OO(1)$ instances of the previous problem, so it only incurs an additional $\OO(1)$ factor. 
\end{proof}

Given an \AllThreeSUM{} instance on size-$n$ sets $A, B, C$, we can first sort $A$ and $B$ and then divide  them to consecutive sub-lists  $A_1, \ldots, A_{n/d}$ and $B_1, \ldots, B_{n/d}$ of size $d$. It is a well-known observation that, in order to determine whether some $c \in C$ is in a 3SUM solution, it suffices to search for $c$ in $A_i + B_j$ for $O(n/d)$ pairs of $(i, j) \in [n/d]^2$. For \AllThreeSUMCountReal{}, the observation is still true: For every $c \in C$, it suffices to count the number of $c$ in $A_i + B_j$ for $O(n/d)$ pairs of $(i, j) \in [n/d]^2$. We can thus determinitically reduce \AllThreeSUMCountReal{} to the following problem (see its non-counting version in, e.g., \cite{chan3sum}). 

\begin{problem}
\label{prob:3sum-variant}
We are given two real $(n/d) \times d$ matrices $A$ and $B$, and a set $C_{ij}$ of real numbers for every $(i, j)$. For every $c \in C_{ij}$, we are asked to count the number of $(k, \ell)$ such that $A_{i,k} + B_{j, \ell} = c$. Additionally $\sum_{i, j} |C_{ij}| = O(n^2/d)$. 
\end{problem}
    
\begin{theorem}
\label{thm:nondet-real-3sum-count}
    \AllThreeSUMCountReal{} for size-$n$ sets is in $\NcoNTIME[\OO(n^{\frac{3\omega+3}{\omega + 3}})]$.
\end{theorem}
\begin{proof}
    We first deterministically reduce \AllThreeSUMCountReal{} to Problem~\ref{prob:3sum-variant}. The proof then proceeds similarly to the proof of Theorem~\ref{thm:nondet-real-exacttri-count}. 

    The prover provides the following:
    \begin{itemize}
        \item A subset $R \subseteq [d] \times [d]$ of size $\OO(r)$. 

        For every $i, j$, let $L_{i j} = \{A_{ik} + B_{j \ell}: (k, \ell) \in R\}$. Let $(pk_{ijc}, p\ell_{ijc})$ be the index of the predecessor of $c$ in $L_{ij}$ (including $c$) and let $(sk_{ijc}, s\ell_{ijc})$ be the index of the successor of $c$ in $L_{ij}$ (excluding $c$). The set  $R$ is supposed to be that, for some $c \in C_{ij}$ and $c \not \in L_{ij}$, the number of $(k, \ell)$ with $A_{i,pk_{ijc}} + B_{j, p\ell_{ijc}} < A_{i k} + B_{j \ell} < A_{i, sk_{ijc}} + B_{j, s\ell_{ijc}}$ is $O(d^2/r)$. Such a set exists because a random $R$ satisfies these properties with high probability. 

        \item For every $(k_0, \ell_0) \in R$, it uses the protocol in Lemma~\ref{lem:nondet-3sum-helper} to create outputs for the purpose of counting $\left| \left\{ A_{ik} - A_{ik_0} = B_{j\ell_0} - B_{j\ell}\right\}\right|$ and $\left| \left\{ A_{ik} - A_{ik_0} \le B_{j\ell_0} - B_{j\ell}\right\}\right|$, where $X$ is the set of $(i, j)$ such that there exists $c \in C_{ij}$ with $(pk_{ijc}, p\ell_{ijc}) = (k_0, \ell_0)$ or $(sk_{ijc}, s\ell_{ijc}) = (k_0, \ell_0)$. 

        \item Finally, for every $(i,j)$ and $c \in C_{ij}$ with $c \not \in L_{ij}$, it provides a list $\ell\ell_{ijc} \subseteq [d] \times [d]$, which is supposed to contain all pairs $(k, \ell)$ with $A_{i,pk_{ijc}} + B_{j, p\ell_{ijc}} < A_{i, k} + B_{j, \ell} < A_{i, sk_{ijc}} + B_{j, s\ell_{ijc}}$. Note that $|\ell\ell_{ijc}| = O(d^2/r)$ by the choice of $R$. 
        
    \end{itemize}
\end{proof}

The verifier is almost identical to the verifier in Theorem~\ref{thm:nondet-real-exacttri-count}, so we omit its details for conciseness. The running time of the verifier is 
\begin{align*}
    \OO\left(\frac{d^2}{r} \cdot \sum_{i, j} |C_{ij}| + \sum_i \left(x_i d^s + M\left(\frac{n}{d}, d^{2-s}, \frac{n}{d}\right) \right)\right), 
\end{align*}
where $x_i$ is the size of $X$ in the $i$-th call of  Lemma~\ref{lem:nondet-3sum-helper}. By picking $d = n^{\frac{1}{3-s}}$, the running time can be simplified to 
\begin{align*}
    \OO\left(\frac{n^{\frac{2}{3-s}}}{r} \cdot \sum_{i, j} |C_{ij}| + \sum_i \left(x_i n^{\frac{s}{3-s}} + n^{\frac{2-s}{3-s}\cdot \omega} \right)\right). 
\end{align*}
We know $\sum_i x_i = O(\sum_{i, j} |C_{ij}|) = O(n^2/d) = O(n^{\frac{5-2s}{3-s}})$, and we call  Lemma~\ref{lem:nondet-3sum-helper} a total of $O(|R|) = O(r)$ times. Thus, we can further upper bound the running time by 
\begin{align*}
    \OO\left(\frac{n^{\frac{7-2s}{3-s}}}{r} + n^{\frac{5-s}{3-s}} + r \cdot n^{\frac{2-s}{3-s}\cdot \omega}\right).
\end{align*}
By setting $s = \frac{2\omega-3}{\omega}$ and $r = n^{\frac{3}{\omega+3}}$, 
the running time becomes $\OO(n^{\frac{3\omega+3}{\omega + 3}})$.

\begin{remark}\rm 
The above approach also leads to new consequences in a certain
unrealistic model of computation: an \emph{unrestricted Real RAM}, 
supporting standard arithmetic operation on real numbers with
unbounded precision, but without the floor function.
With the floor function, it is known that the model 
enables PSPACE-hard problems to be solved in polynomial time~\cite{Schonhage79}.
In a recent paper \cite{CVXstoc22}, it was noted that even without
the floor function, the model may 
still be unreasonably powerful; for example, there is a truly subcubic time 
algorithm for APSP for \emph{integer} input under this model. But the question
of whether there are similarly subcubic algorithms for APSP 
and other related problems for \emph{real} input was not answered.

    Our proof of Theorem~\ref{thm:nondet-real-exacttri-count} implies a truly subcubic randomized time algorithm for \AEExactTriCountReal{} in this unrestricted Real RAM without the floor function. This is because we use nondeterminism mainly to generate all the witnesses.  But using large 
numbers, we can do standard matrix product and have all the witnesses 
represented as a long bit vector.  When witnesses are needed for an 
output entry, we can generate them one by one using a 
most-significant-bit operation, which can be simulated by binary search. Small adaptation of the proof also shows a truly subcubic randomized time algorithm for the real-valued version of \MinPlusCount{}. Similarly, Theorem~\ref{thm:nondet-real-3sum-count} implies a truly subquadratic randomized time algorithm for \AllThreeSUMCountReal{} in the unrestricted Real RAM without the floor function.

\end{remark}


























\subsection{Quantum Algorithms for Counting Problems}
\label{sec:quantum}
Our equivalences between counting and detection problems immediately imply faster quantum algorithms for counting problems. For instance, we obtain the following

\begin{corollary}
\label{cor:3sum-quantum}
There exists an $\OO(n^{2-\eps})$ time quantum algorithm for \ThreeSUMCount{}{} for some $\eps>0$.
\end{corollary}
\begin{proof}
It is known that \ThreeSUM{} can be solved in  $\OO(n)$ quantum time (see e.g. \cite{AmbainisL20}). Applying Theorem~\ref{thm:all-3sum-count} finishes the proof. 
\end{proof}


\subsection{Discussion}\label{sec:nondet:discuss}

{\sf \#CNF-SAT} asks to count the number of satisfying assignments to a CNF formula, and it is considered harder than {\sf CNF-SAT}: the counting version \#SETH of the Strong Exponential Time Hypothesis (SETH) \cite{ipz1,cip10} is considered even more believable than SETH (see~\cite{CurticapeanM16}). Williams' \cite{Williams05} reduction from {\sf CNF-SAT} to \OV{} preserves the counts, and thus is also a fine-grained reduction from {\sf \#CNF-SAT} to \OVCount{}. Similar to the situation for {\sf CNF-SAT}, there's no known fine-grained reduction from \OVCount{} to \OV{}.

Our techniques do not yet give equivalences between the decision and counting variants of {\sf CNF-SAT} and \OV{}. If such equivalences do not exist, this would indicate that \OV{} and {\sf CNF-SAT} are different from the other core problems in FGC. 

Such an indication was already observed by Carmosino et al.~\cite{carmosino2016nondeterministic} who studied the nondeterministic and co-nondeterministic complexity of fine-grained problems. They formulated NSETH that asserts that there is no $O((2-\eps)^n)$ time nondeterministic algorithm which can verify that a given CNF formula has no satisfying assignment.
They also exhibited nondeterministic algorithms for verifying the YES and NO solutions of \ExactTri, \APSP{} in truly subcubic time  and \ThreeSUM{} in truly subquadratic time, and concluded that if NSETH holds, then there can be no deterministic fine-grained reduction from {\sf CNF-SAT} or \OV{} to any of \ExactTri{}, \APSP{} or \ThreeSUM{}.


Because of our efficient nondeterministic algorithms for \ExactTriCount{}, \NegTriCount{} and \ThreeSUMCount,
we then get that under NSETH, there can be no deterministic fine-grained reductions from {\sf CNF-SAT} or \OV{} to \ExactTriCount{}, \APSPCount{} or \ThreeSUMCount. 

Recently, Akmal, Chen, Jin, Raj and Williams~\cite{Akmal0JR022} showed, among other things, that \ExactTriCount{} has an $\OO(n^2)$ time Merlin-Arthur protocol. Their protocol crucially uses polynomial identity testing, and hence it is not known how to derandomize it and make it nondeterministic. 
Our results yield
a truly subcubic nondeterministic protocol.

