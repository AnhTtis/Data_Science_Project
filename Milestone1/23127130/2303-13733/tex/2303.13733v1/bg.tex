\section{Background} 
\label{background}
This section describes the background of the Ethereum smart contract and the virtual machine environment to run it. 



\subsection{Smart Contract and License}
\PP{Smart Contract}
The term ``smart contract''~\cite{szabo_formalizing_1997} refers to a piece of programming code that is permanently stored and executed for processing transactions when predetermined conditions are met.
Smart contracts act as nodes or accounts on the blockchain by leveraging its tamper-resiliency, traceability, and transparency. %
Ethereum~\cite{wood2014ethereum} is one of the most popular and prominent blockchain-based smart contract platforms. The smart contracts on Ethereum are written in a high-level programming language such as Solidity. 
A Solidity code must be compiled into Ethereum bytecode~\cite{wood2014ethereum} to properly run on a blockchain, remaining immutable and indelible within a blockchain ledger. We design {\sys} by embedding a watermark into bytecodes (compiled from a smart contract written in Solidity at the Ethereum platform) and extracting it from the bytecodes. Therefore, {\sys} is agnostic to specific features of a high-level programming language.





\PP{License in Solidity} 
The Solidity compiler offers the means of a machine-readable SPDX license identifier~\cite{Ethereum2021Online} by default, which can be embedded into a bytecode as metadata (by inserting a specific license header into every source file). However, the license identifier differs from a digital watermark because it merely represents one of the standard licenses (\eg, MIT, Apache, BSD, Creative Commons) rather than specifying the actual ownership of a smart contract, being inappropriate for claiming a smart contract copyright.

\subsection{EVM and Bytecode}
\PP{Ethereum Virtual Machine (EVM)}
The Ethereum Virtual Machine (EVM) offers a stack-based runtime environment for smart contracts, where a chunk of bytecodes can be executed upon receiving a transaction. EVM maintains varying machine states that hold a data structure as an execution component, including accounts, balances, stack, memory, storage, and a program counter. EVM supports $150$ instructions~\cite{wackerow2021Online} where each comprises a single byte opcode (mnemonic) and zero or more operands.

\PP{Gas Cost} Ethereum introduces the notion of the execution fee, dubbed  \emph{gas}, for every EVM opcode (\eg, the opcode for multiplication consumes five units of gas) based on the computational and storage overheads of each opcode~\cite{wackerow2021Online}. This enables miners to obtain a reward for computational resources to store smart contracts and execute them. Besides, it can prevent denial-of-service (DoS) attacks that invoke a time-consuming function~\cite{2_Atzei}.

\PP{Bytecode for EVM}
Solidity emits two types of bytecode: \WC{1}~creation bytecode (\ie, \emph{init} bytecode) for initializing (\ie, constructor) and deploying a contract, and \WC{2}~runtime bytecode (\ie, \emph{deployment} bytecode) for executing the contract that is stored on a blockchain. The major difference in spending a cost is that a creation bytecode requires a gas once whereas a runtime bytecode consumes a gas in every transaction. Note that one can obtain runtime bytecodes on a blockchain and creation bytecode from a contract transaction log.%











