\section{Evaluation} 
\label{evaluation}
In this section, we present how well \sys meets the requirements of a smart contract watermark (Section~\ref{ss:requirements} with \textbf{RQ1}), and analyze its robustness from a security perspective (Section~\ref{ss:threatmodel} with \textbf{RQ2}).
We evaluate \sys{} on a 64-bit Ubuntu 18.04 system 
equipped with Intel(R) Xeon(R) Gold 6230 2.10 GHz 
and 567GB RAM.

\PP{Dataset}
We collected all fifteen
million blocks (mined during the period 30 July 2015 to 21 June 2022) from the Ethereum Mainnet, which incorporates $4,112,336$ smart contracts.
Then, we obtain $445,930$ unique runtime bytecodes 
($10.8\%$ of the whole) after eliminating 
all byte-level equivalent ones.
We leverage EtherSolve~\cite{4_EtherSolve}
to obtain CFGs for $284,344$ contracts, followed by
taking $178,119$ contracts ($62.6\%$) that
contain a unique watermarkable zone
(recall that operands and dispatcher blocks
are excluded for our scheme).
We indeed observe a high ratio of code duplication
in smart contracts, aligned with the
previous findings~\cite{chen2021understanding}.
We manually confirm that a considerable number of
code reuse cases arise from the 
standards~\cite{ethereum-standard} introduced by 
the Ethereum community such as 
ERC-20 (standard interface for fungible tokens) and
ERC-721 (standard interface for non-fungible tokens).
In this respect, we group analogous contracts together
to demonstrate the effectiveness of our watermarking scheme.
We perform DBSCAN
clustering~\cite{6_clustering} with the similarity metric
of $\text{max}(\frac{len(a \cap b)}{len(a)},\frac{len(a \cap b)}{len(b)}$) where $a$ and $b$ denote the CFG blocks 
for the two contracts, $A$ and $B$.
This is because \sys mainly targets 
disparate bytecodes (\ie, program logic), 
excluding a common component 
like ERC20 that causes an overlapping between contracts.
We finally obtain $27,824$ smart contracts
out of 178K ($15.6\%$)
distinguishing sample contracts for our experiment.
The average size of the smart contracts in 
our dataset is $5.8KB$ with the standard deviation
of $4.6KB$ (median: $4.5$ KB).


\subsection{Imperceptibility}
\label{ss:imperceptibility}
In \sys, a watermark is completely imperceptible as long as its WRO is privately kept by the smart contract owner. To embed a watermark into a smart contract, {\sys} does not add any additional code and data except a WRO MAC on its creation bytecode; the watermark is constructed with watermark bytes randomly elected from its runtime bytecode, resulting in that watermark bytes are indistinguishable from the other bytes in the runtime bytecode. Perhaps, a sophisticated adversary can identify the WRO MAC from the creation bytecode. However, we note that a WRO MAC is a cryptographic hash value that is irreversible. Therefore, one cannot obtain fruitful information about WRO from the WRO MAC.

\subsection{Spread}
\label{ss:spread}
Going back to Fig.~\ref{fig:4_CFG}, \sys
intentionally picks a single byte
from a byte stream per block,
resulting in a well-scattered watermark
across different blocks in a CFG.
In this example, five out of
$13$ blocks (around $38\%$) are covered
for a watermark, and a lengthier one
would be more dispersed.
Besides, by design, \sys allows
one to insert multiple watermarks so that
it could increase verifiability
even with a single watermark being survived.
Such a design choice makes \sys robust
against varying attacks by lowering
the possibility of damaging every
watermark simultaneously.
Oftentimes, it would be excessively costly for an adversary
to disrupt a well-distributed watermark, hampering
further transactions (Section~\ref{ss:resiliency}).


\subsection{Capacity}
\label{ss:capacity}
In practice, the total length (\ie, capacity) of a watermark
(or multiple watermarks) is bounded
by the number of blocks in a CFG because
our scheme relies on how to choose
opcode groups in a watermarkable zone.
In our experimental setting,
we elect one byte from a single block.
In general, the capacity of our watermarking scheme
is determined by the number of watermarkable blocks available
in a smart contract, rather than the size of the contract.







\subsection{Efficiency}


To demonstrate the efficiency of \sys,
we run experiments of
embedding and verification processes 10 times to measure CPU time.
Note that we exclude any smart contract
that does not conform to the code size limit
(\ie, EIP-170~\cite{eip170}) in our experiments.
Furthermore, we measure sub-phases
for watermarking operations (Table~\ref{table:5_Each_Phase}); 
the phase of electing watermark bytes dominates
the entire embedding time ($96.7\%$) whereas that of
creating (watermarkable) bytestream does the verification time ($70.1\%$).
A wide range of variations mainly arise from
processing time that largely depends on
the number of blocks pertaining to a watermark,
rather than the size of a smart contract.
We observe that a verification process (mean: $17,258$ milliseconds)
takes approximately 1.5 times longer
than an embedding process (mean: $11,088$ milliseconds),
but is still overall acceptable in practice
(\eg, within $20$ seconds).

\begin{table}[t]
    \caption{Breakdown of embedding and
        verification time on average. 
        Electing bytes for a watermark and
        creating a bytestream dominate
        embedding and verification time,
        respectively.
        }
    \begin{center}
    \resizebox{0.98\linewidth}{!}{

        \begin{tabular}{l|l|r|r}
        \hline
        \textbf{Process} & \textbf{Phase} & \textbf{Ratio (\%)} & \textbf{Time (ms)} \\
        \hline
        \multirow{3}{*}{\textbf{Embedding}} 
        & Opcode grouping 
        & 3.38 & $363.88 \pm 410.62$ \\
        & Watermark byte election & 96.69 & $10,720.59 \pm 13,083.91$ \\
        & WRO creation & 0.03 & $3.38 \pm 2.49$\\
        \hline
        \multirow{3}{*}{\textbf{Verification}} 
        & WRO verification & 0.01 & $0.71 \pm 0.70$\\
        & Bytestream creation & 70.06 & $12,089.79 \pm 14,421.60$\\
        & Hash discovery & 29.93 & $5,165.84 \pm 5,097.88$\\
        \hline
        \end{tabular}
    }
    \end{center}
    \label{table:5_Each_Phase}
\end{table} 



\subsection{Cost}
Recall that \sys does not introduce any
additional routine on a runtime bytecode,
staying the original execution gas intact.
Instead, \sys increases a (one-time) creation cost
due to a WRO MAC in a constructor (Listing~\ref{list:4_constructor} in Section~\ref{ss:embedding})
where its cost is closely proportional to the size of the WRO MAC.
In case of embedding a 256-bit WRO MAC using
Keccak-256 in our implementation, an additional
cost ranges from 48,540 to 53,100 gas.
Such cost variation mostly arises from varying opcodes 
depending on the original context of the constructor 
when inserting a WRO MAC.
Although a gas price frequently fluctuates, as of writing,
the additional gas consumption is around $4.27\sim4.67$
US dollars (USD) with the exchange rate of $90\sim100$ gas
per bit. %




\subsection{Credibility}
\label{ss:Credibility}

\begin{table}[t]
	\centering
	\caption{
	Ratio of unique watermarks 
	by the whole size ($L \times N$) of an embedded watermark.
	$L$ and $N$ denote the length of a watermark ($L$) 
	and the number ($N$) of watermarks, respectively.
	A watermarkable contract represents
	the contract that incorporates 
	a sufficient number of watermarkable zones.
	}
	\resizebox{0.85\linewidth}{!}{
		\begin{tabular}{ll|r|rr}
		\toprule
		\multirow{2}{*}{\textbf{L}} & \multirow{2}{*}{\textbf{N}} & \textbf{Watermark} & \textbf{\# Unique Watermarks} & \multirow{2}{*}{\textbf{Ratio}} \\ 
		& & \textbf{Size (bytes)} & \textbf{(Watermarkable Contracts)} & \\
		\midrule
		\multirow{4}{*}{10} & 1 & 10 & 27,704  (27,823) & 99.995\% \\ 
		& 3 & 30 & 23,062    (23,378) & 99.986\% \\
		& 5 & 50 & 18,098    (18,511) & 99.978\% \\
		& 7 & 70 & 15,140    (15,620) & 99.970\% \\ \midrule
		\multirow{4}{*}{15} & 1 & 15 & 27,764  (27,764) & 100.000\% \\ 
		& 3 & 45 & 19,482    (19,485) & 99.999\% \\
		& 5 & 75 & 15,144    (15,156) & 99.999\% \\
		& 7 & 105 & 13,009   (13,030) & 99.998\% \\ \midrule
		\multirow{4}{*}{20} & 1 & 20 & 26,679  (26,679) & 100.000\% \\ 
		& 3 & 60 & 16,874    (16,874) & 100.000\% \\
		& 5 & 100 & 13,311   (13,311) & 100.000\% \\
		& 7 & 140 & 11,646   (11,646) & 100.000\% \\
	    \bottomrule
		\end{tabular}
	}
	\label{table:5_FP}
\end{table}
Credibility is one of the essential requirements for a watermarking scheme, which ensures that it can be reliably extracted for proof of ownership. 
We assess \sys by confirming that a watermark from WRO must be unique, that is, the watermark cannot be present elsewhere
but the original contract.
Table~\ref{table:5_FP} summarizes the total bytes of the watermark(s) ($L \times N$) with the length ($L$) and the number ($N$) of the watermark(s) inserted into a smart contract, and the ratio of contracts that hold unique watermarks accordingly.
Due to the constraint of an embedding watermark size that relies on a smart contract size, we compute the ratio of uniqueness based on the number of watermarkable contracts where a certain size (\ie, $L \times N$ bytes) of a watermark can be embedded.
For example, a single 10-byte long watermark can possibly be inserted into $27,823$ ($99.999\%$) out of $27,824$ contracts in total, resulting in $27,704$ contracts holding unique values ($99.995\%$).
Empirically, the uniqueness ratio is proportional to the length of a watermark whereas inversely proportional to the number of the watermark. 
Hence, we advise striking a balance between the length and the number for fulfilling both capacity and spread properties (as well as credibility). 






\subsection{Resiliency}
\label{ss:resiliency}

In this section, we show how \sys can defend against the attacks presented in Section~\ref{ss:threatmodel}. Note that Section~\ref{ss:imperceptibility} covers \emph{unauthorized recognition}.



\subsubsection{Collusion} 
A collusive attack would help identify a smart contract's WRO MAC by analyzing the differences between the creation bytecodes of several smart contracts because all WRO MAC values always have the same fixed length, \eg, SHA-256 produces a 32 bytes hash value, and have a higher entropy than the other variable values. As mentioned in Section~{\ref{ss:imperceptibility}}, however, we note that the presence of a WRO MAC itself does not practically help recognize its corresponding watermark because a WRO MAC is a cryptographic hash value that is irreversible.

\subsubsection{Addition} 
We note that an adversary can embed a watermark $W_{a}$ of one's choice into a smart contract using {\sys} in the same manner even when a watermark $W_{o}$ is already present in a smart contract. In such a case, one can verify the presence of both watermarks ($W_{a}$ and $W_{o}$) with the original smart contract owner's own WRO and the adversary's own WRO, respectively. However, it is easily recognizable that $W_{o}$ was embedded prior to $W_{a}$ because transactions are permanently recorded on the Ethereum blockchain network in chronological order; checking if the WRO MAC of an early-deployed watermark will do. %

\subsubsection{Deletion} 
With our scheme, a watermark is constructed with existing opcodes in an original smart contract. %
In theory, a watermark deletion may be possible when
an adversary could replace one or more opcodes used for the watermark with others, however, such
semantic-preserving code transformation that
maintains a reasonable cost would be quite challenging.




\subsubsection{Distortion}
\label{sss:6_distortive}
One of plausible and powerful attacks to corrupt
our watermark scheme is a distortion attack
with arbitrary transformations.
We randomly choose 2,500 smart contracts whose
source code have been publicly available.
In this experiment, we set
the length of a watermark ($L$) to be 15,
and the number of watermarks ($N$) to be 3.

\PP{Empirical Results} 
We conduct various distortion experiments
for thwarting an embedded watermark
with the following five different types of transformations
as suggested by Chen et al.~\cite{chen2021understanding}:
\WC{1}~adjusting a function visibility (\eg, access modifier alters \cc{public} to \cc{private}, or the other way around), \WC{2}~updating an inheritance relationship (\eg,  arbitrary subcontract is added and inherited), \WC{3}~introducing an additional state variable (\eg, original state variable refers to an arbitrary state variable), \WC{4}~defining a new event and function (\eg, additional function has been added to an original contract), and \WC{5}~adding a statement (\eg, arbitrary statement is added to an original function).
Table~\ref{tab:credibility_exp02} summarizes the 
results of the above distortion attempts against
our scheme.
\sys shows the robustness of an individual attack
(\ie, 99\% or above), and applying all transformations
barely drops the ratio of appropriate verification 
(\ie, $98.9\%$).


\begin{table}[t]
	\centering
	\caption{
	Experimental results of varying distortion attacks against an embedded watermark on 2,500 smart contracts, which 
	shows the robustness of the \sys scheme.
	}
	\resizebox{0.98\linewidth}{!}{
		\begin{tabular}{l|r|rr}
		\toprule
		\textbf{Transformation Type (Distortion)} & \textbf{\# Verified Contracts} & \textbf{Ratio} \\
		\midrule
		{\WC{1}} Adjusting a function visibility & 2,490 & 99.60\% \\
		{\WC{2}} Updating an inheritance & 2,495 & 99.80\% \\
		{\WC{3}} Introducing an additional state variable & 2,489 & 99.56\% \\
		{\WC{4}} Defining an event \& function & 2,500 & 100.00\% \\
		{\WC{5}} Adding a statement & 2,475 & 99.00\% \\
		{\WC{+}} Applying all the above & 2,472 & 98.88\% \\
	    \bottomrule
		\end{tabular}
	}
	\label{tab:credibility_exp02}
\end{table}

\PP{Theoretical Analysis}
As presented in Section~{\ref{ss:imperceptibility}}, an adversary cannot distinguish watermark bytes from other bytes in a smart contract.
Therefore, for each block in the CFG of a target contract containing a watermark byte, the best distortion strategy at the bytecode level would be guessing an opcode group used for the watermark and adding it to the block.
If the adversary's guess is correct, the newly added opcode group would be used to form a watermarkable byte stream with the existing opcode groups for the watermark to compute the CFG block hash.
Consequently, the valid block hash contained in the WRO would not match the new block hash, leading a watermark corruption.

Given a smart contract of $s$, the probability of an attack success ($P_{attack}$ $(L, B_s, M_s)$) with a distortion can be computed by Equation~\eqref{eq: distortive1} where $L$, $B_s$, and $M_s$ represent the length of the watermark, the number of candidate blocks (in a watermarkable zone) for $s$, and the number of candidate blocks (in a watermarkable zone) that has been modified by an adversary against $s$, respectively. Figure~\ref{fig:Visual illustration of the parameters} concisely illustrates those parameters. Watermark bytes are scattered in candidate blocks in a watermarkable zone. Suppose that an adversary was able to modify the block(s) of one's choice where some of which could contain a watermark byte. %

\vspace{-0.3cm}
\begin{center}
\begin{equation}
P_{attack}(L, B_s, M_s) =\frac{\sum_{i=1}^{min(L, M_s)}\binom{B_s}{M_s}\binom{M_s}{i}\binom{B_s-M_s}{L-i}}{\binom{B_s}{L}\binom{B_s}{M_s}}
\label{eq: distortive1}
\end{equation}
\end{center}

In Equation~\eqref{eq: distortive1}, the denominator represents the number of all possible ways by choosing \WC{1}~$L$ blocks from $B_s$ blocks disallowing duplicates, and \WC{2}~$M_s$ blocks from $B_s$ blocks disallowing duplicates, respectively. The numerator represents the number of successful distortion attacks. When an adversary modifies $M_s$ blocks from $B_s$ blocks, the distortion attack would be successfully performed if those modified blocks contain at least one block that contains watermark bytes. In Equation~\eqref{eq: distortive1}, $i$ represents the number of blocks that contains actual watermark bytes out of $M_s$ blocks modified by an adversary. In this scenario, the number of successful distortion attacks can be interpreted as the number of possible ways to choose $M_s$ blocks from $B_s$ blocks, $i$ blocks from those $M_s$ blocks, and $L-i$ blocks from the remaining $B_s-M_s$ blocks disallowing duplicates. Finally, $\binom{B_s}{M_s}$ can be canceled out in the numerator and the denominator.


\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/6_distortion_equation.pdf}
    \caption{Illustrative parameters to compute 
    the probability of an attack success,
    $P_{attack}(L, B_s, M_s)$. 
    An empty rectangle represents a candidate block
    in a watermarkable zone, where the rectangle with
    a dark box contains a watermark byte.
    The dotted circle represents an area that
    includes the candidate block(s) modified by an adversary.
    }
    \label{fig:Visual illustration of the parameters}
\end{figure}



To enhance the resiliency of \sys against distortion attacks, we can insert $N$ watermarks that do not overlap each other where $N > 1$. In this case, an adversary needs to corrupt all $N$ watermarks for a successful attack. We presume that all watermarks have the same length for simplicity of analysis. With the notation of $P_{attack}(L, B_s, M_s, N)$, the probability of an attack success with $N$ watermarks on a smart contract $s$. $P_{attack}(L, B_s, M_s, N)$ can be simply expanded from $P_{attack}(L, B_s, M_s)$ as in Equation~\eqref{eq: distortive5}.
\vspace{-0.3cm}
\begin{center}
\begin{equation}
P_{attack}(L, B_s, M_s, N) = P_{attack}(L, B_s, M_s)^N
\label{eq: distortive5}
\end{equation}
\end{center}

We compute $P_{attack}(L, B_s, M_s, N)$ for each smart contract in the 27,824 smart contracts with varying parameters such as $L$, $N$, and $\alpha$ where $\alpha$ represents the ratio of the maximum allowable gas cost for the opcodes added by an adversary (hereafter referred to as ``attack budget'') to the total gas cost to execute a target smart contract.  
To compute $P_{attack}(L, B_s, M_s, N)$, we need to concretely obtain $B_s$ and $M_s$ from the smart contract $s$. With the hyperparameters of $T = 9$, $W = 1$, $G = 5$, and $R = 0.2$, as watermarkable blocks for $s$ are determined by our \sys implementation, we can empirically obtain $B_s$. 
However, $M_s$ cannot be determined by \sys because $M_s$ depends on an adversary's choice -- an adversary needs to correctly guess an opcode group for a candidate block containing watermark bytes and add it to the block. Therefore, given a smart contract $s$, we compute the expected value of $M_s$ ($E(M_s)$) with specific parameter values for $s$. The attack budget can be computed as $\alpha \cdot \Psi_s$ where $\Psi_s$ represents the total gas cost to execute the smart contract $s$. For example, when $\Psi_s = 1,000$ and $\alpha = 0.5$, the attack budget would be 500. In other words, 50\% of the gas cost ($\alpha=0.5$) is more needed to run a clone DApp. From the attack budget $\alpha \cdot \Psi_s$, we can compute the maximum number of opcode groups added to $s$ for a distortion attack as $\lfloor\alpha \cdot \Psi_s / T\rfloor$ because the gas cost for each opcode group, which corrupts a watermark byte effectively, is greater than or equal to $T$. In the previous example, when $T=9$, the maximum number of opcode groups added to $s$ is 55. We assume that an adversary knows $T$ used for \sys for simplicity of analysis. Then, the adversary's best attack strategy is to select $\lfloor\alpha \cdot \Psi_s / T\rfloor$ blocks out of $C_s$ blocks and add an opcode group to each block one by one where $C_s$ represents the number of the blocks that contains opcode groups, which requires a gas cost greater than or equal to $T$. With this strategy, the probability of selecting a candidate block in a watermarkable zone is $B_s / C_s$ whenever an adversary modifies a block. Thus, $E(M_s)$ can be computed by multiplying $\lfloor\alpha \cdot \Psi_s / T\rfloor$ by $B_s / C_s$ as follow:

\vspace{-0.1cm}
\begin{equation}
\begin{aligned}
E(M_s) = \left\lfloor\frac{\alpha \cdot \Psi_s}{T}\right\rfloor \cdot \frac{B_s}{C_s}
\label{eq: distortive3}
\end{aligned}
\end{equation}

\begin{figure}[t]
     \centering
     \subfigure[$\alpha=0.2$ with $L=10$ (left) and $L=20$ (right)]{
         \includegraphics[width=.45\linewidth]{figures/5_distortive/0.2_10_new.pdf}
         \par\medskip
         \includegraphics[width=.45\linewidth]{figures/5_distortive/0.2_20_new.pdf}
    }
     \subfigure[$\alpha=0.3$ with $L=10$ (left) and $L=20$ (right)]{
         \includegraphics[width=.45\linewidth]{figures/5_distortive/0.3_10_new.pdf}
         \par\medskip
         \includegraphics[width=.45\linewidth]{figures/5_distortive/0.3_20_new.pdf}
    }
     \caption{Cumulative distribution functions (CDFs) of $P_{attack}(L, B, M, N)$ with $L$ = \{10, 20\} and $N$ = \{1, 3, 5, 7\} for 2,738 smart contracts. 
     }
     \label{fig:5_distortive_150}
\end{figure}

Figure~\ref{fig:5_distortive_150} shows the cumulative distribution functions (CDFs) when computing $P_{attack}(L, B, M, N)$ with $\alpha$ = \{0.2, 0.3\}, $L$ = \{10, 20\}, and $N$ = \{1, 3, 5, 7\} with the selected 11,646 
smart contracts 
for fair comparison (recall that the number of watermarkable contracts may be different depending on $L$ and $N$). 

Overall, choosing either a smaller $L$ or a larger $N$ raises the bar by requiring a higher execution cost for successful attacks, confirming our intuition on the resiliency of {\sys} against distortion attacks. With $L=10$, $N=7$, and $\alpha=0.2$, only $0.7\%$ of the smart contracts would be thwarted with the attack success probability of 0.05 or higher. Even when $\alpha$ increases 0.3 with the same configuration, only $8.9\%$ would be thwarted, being still effective. On the contrary, with $L=20$, $N=7$, and $\alpha=0.2$, the attack success probability significantly increases; $25.3\%$ would be thwarted with the attack success probability of 0.05 or higher. Based on these results, we advise not to utilize $L=20$ despite its superiority in credibility (Section~\ref{ss:Credibility}). Likewise, a single watermark (when $N$ = 1) would be ineffective against distortion attacks, indicating that multiple watermarks are recommended for \sys. It is noted that an adversary cannot increase $\alpha$ unreasonably because generated smart contracts with a large $\alpha$ are not competitive at all against the original smart contract in terms of execution cost. In a competitive DApp market, it is typical that a user avoids choosing a DApp that consumes an additional gas cost if there is an alternative to provide same/similar features. Likewise, Ethereum users are no difference~\cite{disc_usersensitive}.
