\section{\sys Design}
\label{design}

This section sketches the design of \sys that considers both the requirements for generic watermarks and the smart contract's idiosyncratic properties.
Notably, our scheme does not introduce additional runtime bytecode 
because implanting bytes would be revealed by a sophisticated attack as well as increasing an undesirable gas cost.

\subsection{Design Overview}


Fig.~\ref{fig:4_SmartMark} depicts
the overall process of \sys for embedding
and verifying a watermark for a smart contract.
First, the Solidity compiler generates both creation bytecodes
(\ie, contract constructor) and runtime bytecodes
(\ie, actual execution code under EVM).
For embedding a watermark, our scheme harnesses both creation and runtime bytecodes for watermarking over smart contracts.   
We first construct a CFG from a runtime bytecode (\BC{1} in Fig.~\ref{fig:4_SmartMark}), followed by electing a series of bytes that incorporates a watermark (\BC{2}). 
Then, we explicitly define a structure (dubbed \emph{watermark reference object}; WRO) that contains essential information to represent the watermark, which must be privately maintained by the owner of a smart contract (\BC{3}).
We compute the hash value of the WRO (\BC{4}) and insert it into a creation bytecode (\BC{5}) for further validating a watermark.
For brevity, hereinafter, we call such a hash value a \emph{WRO MAC} that represents a message authentication code for WRO. 
Once the creation bytecode is complete, it is deployed to the Ethereum network (\BC{6}).
It is worth noting that all bytecodes are publicly available in a tamper-proof fashion after deployment, which indicates that a WRO MAC is publicly accessible and immutable.
To verify the presence of a watermark in a target smart contract, a verifier (e.g., the owner of the original smart contract) uses the WRO containing the information about the watermark. For the validity of the WRO, the verifier first computes the hash value of the WRO and compares it with the WRO MAC extracted from a creation bytecode of the target contract (\BC{7}, \BC{8}). If the two values are matched, the WRO is valid.
Therefore, the verifier reconstructs a CFG from a target smart contract (\BC{9}), and confirms the presence of a watermark in the CFG with the information in the WRO (\BC{10}).

\subsection{Watermark Embedding for Smart Contracts}
\label{ss:embedding}
This section portrays \sys's watermark embedding for 
smart contracts under the hood.

\subsubsection{Design Choice}
\sys carefully considers the two types of bytecode with different properties; a runtime bytecode for electing the bytes that form a watermark and a creation bytecode for ensuring the integrity of a WRO. {\sys} does not introduce any extra code within a runtime bytecode since the execution of a smart contract inevitably requires a gas cost. Alternatively, we store a 32-byte WRO MAC as a variable in the creation bytecode because it only incurs a one-time cost during deployment.
Besides, we embed multiple ($N$) watermarks,
enabling a robust recovery in case of partial damage
(Section~\ref{ss:verification}). 


\subsubsection{Strategic Byte Election}
\label{ss:strategy}
As illustrated in Fig.~\ref{fig:4_SmartMark},
we begin with constructing a CFG from a runtime bytecode.
However, not every byte accounts for a watermark in \sys because strategic insertion of a (cheap) dummy byte into every block within a target CFG can disturb watermark construction.
Therefore, we carry out two processes; 
choosing a set of candidate bytes that contribute to 
forming a watermark, and
randomly electing watermark bytes from the candidates. %

\begin{figure*}[h!]
    \centering
    \includegraphics[width=.81\linewidth]{figures/4_CFG.pdf}
    \caption{
    Example of strategic byte election
    with the \cc{ERC20} runtime bytecode
    for a five-byte watermark.
    Once CFG construction is completed, we randomly
    elect a series of opcode groups 
    (\ie, vertical lines in the block tables)
    from a watermarkble zone
    (Section~\ref{ss:embedding}), forming
    a final watermarkable byte stream.
    This example illustrates five blocks (\ie, dotted
    blocks; \protect\BC{1}-\protect\BC{5}) where three of them demonstrate
    how each byte of the watermark values (on the top right table) 
    has been distributed (\eg, red nibbles)
    across separate blocks. %
    The table on the bottom shows a block hash and
    a nibble offset in each byte stream for a block
    (value corresponding to the watermark),
    being recorded in a WRO.
    }
    \label{fig:4_CFG}
\end{figure*}


\PP{Watermarkable Zone}
We determine a code region that embraces a set of candidate bytes for a watermark, that is, a \emph{watermarkable zone} by excluding bytes unsuitable for watermarking.
First, we rule out a byte if it falls into a dispatcher function\footnote{The dispatcher is a built-in
function that points to user-defined (public) functions,
which should be invoked at the beginning
of runtime bytecode (\eg, the start function
in Fig.~\ref{fig:4_CFG}).} because it is commonly used for all smart contracts.
Second, we exclude all operands 
since they can be more fragile
to a watermark corruption
(\eg, modifying jumping destinations, 
immediate values on the stack).


\PP{Opcode Group}
From a collection of all bytes (\ie, list of opcodes) in
the above watermarkable zone, 
we group a sequence of opcodes together by
taking gas consumption into consideration.
An \emph{opcode group} can be determined with
three factors; \WC{1}~a cost threshold ($T$)
that represents the aggregate of gas costs
for consecutive opcodes,
\WC{2}~the size of a sliding window ($W$), and
\WC{3}~the maximum size of a group ($G$) or
the number of opcodes.
To exemplify, in Fig.~\ref{fig:4_CFG},
the first four consecutive bytes 
(\eg, \cc{0x5B, 0x82, 0x01, 0x91})
at the first block table 
(\BC{1}) can form a group
because the gas sum (1+3+3+3=10) exceeds
$T = 9$ in case of $G = 5$ and $W = 1$.
In the same vein, the next five consecutive bytes
(\eg, \cc{0x5B, 0x82, 0x01, 0x91, 0x90})
can hold another group as it meets
the requirements of the gas sum of 13
when the group size is 5.
Next, we move forward (\eg, starting from \cc{0x82})
to seek the next group candidates
until all blocks are covered.
The reasoning behind this process is that
we desire to generate as many opcode group
candidates (to choose from)
as possible while avoiding a fully overlapped group
under the distribution of opcode costs ($3$ as a mean value)\footnote{The most frequently appeared 
opcode is \text{PUSH1} in our dataset, whose cost is three. 
Note that more than three out of four
opcodes (76.2\%; 98,137,334 of 128,819,501)
consume a gas cost of three.},
the number of blocks per smart contract ($108.8$ on average),
and the number of opcode per block ($21.7$ on average).

\PP{Watermark Byte Election}
Concisely, once every opcode group in a watermarkable zone
is set up, we randomly subset all opcode groups,
followed by electing bytes for a watermark.
First, we randomly choose $R\%$ of all opcode groups.
The elected groups may be partially overlapped or consecutive,
forming a \emph{byte stream per block}.
Notably, the byte stream serves a basis
for further watermark verification.
Second, we elect $L$ bytes at random
so that each byte
can be present in a different block 
for a better spread
where $L$ is the number of distinguishing bytes
that a watermark demands.
As a concrete example, 
 Fig.~\ref{fig:4_CFG} illustrates 
the whole process of byte election with
the \cc{ERC20} smart contract~\cite{jdourlens2020Online}.
In this example, we show
three watermark bytes (\eg, \cc{0x52, 0x15, 0x06})
that are elected across eight opcode groups 
from three blocks
(\eg, 2, 3 and 3 per block) in case of $L$ = 5.
We adopt a unit of nibble ($4$ bits) 
to increase the likelihood of having the 
number of unique bytes from the byte stream
(one may want to use more fine-grained unit like a bit).
As an example, the second watermark byte of \cc{0x15}
in Fig.~\ref{fig:4_CFG} has been taken from
the second nibble at \cc{0x81} and 
the first nibble at \cc{0x54} (red letters).
Finally, a nibble offset is required
within a block for every elected watermark byte.
Then we bookkeep the information of 
a watermark including
opcode groups, block hashes, and nibble offsets
in a pre-defined structure 
(Figure~\ref{fig:4_WRO}).

\subsubsection{Watermark Reference Object (WRO)}
\label{ss:wro}
\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/4_WRO.pdf} 
    \caption{Structure of a WRO. The grey fields represent fixed-length values while others are not.}
    \label{fig:4_WRO}
\end{figure}

We define a structure, dubbed WRO, which records crucial information to validate a smart contract watermark, including block identifiers, nibble offsets within each block, opcode groups, the length of a watermark as well as the watermark itself.
Note that a block identifier is a hash value of a byte stream
(\ie, subset of all opcodes), not of an entire block.
Similarly, an offset represents
a distance within a byte stream 
for better resiliency.
Fig.~\ref{fig:4_WRO} shows the structure of the object in detail.
Additionally, it contains a CFG generation tool identifier\footnote{\sys predominantly relies on deterministic CFG construction from a CFG generator (e.g., EtherSolve), regardless of its correctness. Hence, verifying the presence of a watermark should be feasible as long as extracting the identical CFG from a certain contract. In this regard, a WRO contains a CFG tool identifier, including a specific version.}, a block hash algorithm (each block takes the first four bytes of the byte stream's hash for identification), the number of
a watermark (multiple watermarks are embedded for robustness against partial corruptions), and a contract address. 
As presented in Section~{\ref{ss:embedding}}, we compute the hash of the WRO (\ie, WRO MAC), and store it to a variable in a constructor (Listing~\ref{list:4_constructor}).
\lstset{style=solidity, label=list:4_constructor, frame=tb,
	caption=Example of inserting a WRO MAC in Solidity. 
	A constructor holds a variable for the MAC
	that resides in a creation bytecode 
	after deployment.}
\begin{lstlisting}
contract Watermark {
    bytes WRO_MAC;
    constructor() {
        // WRO MAC with Keccak-256
        WRO_MAC = "cc860417...fc6b";
    }
}
\end{lstlisting}

















	



























\subsection{Watermark Verification}
\label{ss:verification}


A watermark verification entails three main phases as follow.
First, given a WRO, we can compute the hash of the WRO and compare it with the stored WRO MAC extracted from the creation bytecode to ensure the integrity of the WRO.
Second, given a target runtime bytecode, 
watermark verification reconstructs
a CFG with the same CFG generator during an embedding process,
followed by creating a byte stream (per block)  with a list of opcode groups in the WRO.
The way to seek a certain byte stream in a CFG is through a series of byte-level searches at every target block.
Third, a verifier can compute every block hash
with that byte stream, and find watermark bytes from each block with nibble offset information. The verifier can successfully recover a watermark unless an adversary corrupts one of the byte streams contributing to the watermark. Note that multiple watermarks are inserted to enhance \sys's resilience against corruptions. 

