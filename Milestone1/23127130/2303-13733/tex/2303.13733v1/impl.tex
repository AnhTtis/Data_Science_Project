\section{Implementation}
Our \sys prototype is written in Python 3.9. We leverage EtherSolve~\cite{4_EtherSolve} into disassembling a smart contract bytecode and generating a CFG. If the CFG holds multiple blocks having the same bytecode, we consider only one block so that all blocks are uniquely different for \sys. 



\PP{Hash Algorithm}
The case that \sys employs a hash algorithm
is twofold (Section~\ref{ss:embedding}): one for generating the hashes of all blocks in a CFG, and one for creating a WRO MAC.
In both cases, we utilize the Keccak-256 hash algorithm
whose output is a fixed length of $256$ bits.
Note that we take the first four bytes 
of a Keccak-256 digest to represent a block hash,
which is equivalent to generating an identifier 
for a user-defined function when compiling a smart contract into bytecode in EVM. 

\PP{Hyperparameters}
We deliberately leave a handful of hyperparameters
to be able to be adjusted (Section~\ref{ss:embedding}) 
in need for \sys.
For determining opcode groups, we introduce a gas threshold ($T$) with the size of a sliding window ($W$) and that of an opcode group ($G$), which assists in electing bytes to meet the requirements (Section~\ref{ss:requirements}). %
The ratio of elected opcode groups is set to $R\%$, which forms a byte stream per block.
\
The length of a watermark is set to $L$ bytes, and
the current \sys implementation elects $L$ blocks
accordingly (\ie, electing a single byte per block).
Lastly, the number of embedded watermarks ($N$) is  
for robust verification where
multiple watermarks may hold different values.
It is possible to insert a different length for each watermark, however, we use the same lengths for a straightforward security analysis.
The following enumerates concrete hyperparameters
in our experiment for \sys:
$T = 9$, $W = 1$, $G = 5$, $R = 0.2$, 
$N$ = $\{1, 3, 5, 7\}$, 
and $L$ = $\{10, 20\}$.
In general, care must be taken in setting parameters
as follows:
\WC{1}~$N$ and $L$ rely on the number of blocks 
in a smart contract,
\WC{2}~$R$ strikes a balance between the probability
of successful attacks (\eg, too high $R$ may increase
a distortion attack with a higher chance of choosing
precise opcode groups)
and the number of opcode group candidates
available (\eg, too low $R$ may fail to 
have sufficient candidates), and
\WC{3}~we empirically advise $T = 9$ and $G = 5$
for both effectiveness and efficiency.

