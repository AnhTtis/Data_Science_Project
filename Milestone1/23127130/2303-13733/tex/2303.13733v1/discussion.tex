\section{Discussions and Limitations} 

This section covers in-depth discussions and limitations of our approach, and future research.




\PP{Reversing EVM Bytecode}
EVM is a Turing complete virtual machine
based on the stack, which does not
follow the Von Neumann architecture
(\eg, no registers).
Besides, Solidity even complicates
bytecodes by introducing built-in functions and applying various optimizations.
In this regard, reverse engineering of an EVM bytecode and understanding underlying semantics (\ie, decompilation) are non-trivial~\cite{reversing-bytecode1, reversing-bytecode2, reversing-bytecode3}. This would make distortion attacks without source code quite challenging on a smart contract.






\PP{EVM Bytecode Diversification}
Having the identical source code, a runtime EVM bytecode may be diversified with the rapid evolution of the Solidity compiler~\cite{liu2019enabling}. However, the current design of {\sys} targets bytecode generation with the same compiler version. We conduct an additional experiment to confirm the robustness of {\sys} against different compiler versions (from 0.4.0 to 0.8.17). Our empirical results demonstrate {\WC{1}}~successful watermark detection with a minor version difference; of the total 5,028 contracts, only 6\% was undetected (L=15, N=3), and {\WC{2}}~cross-compilation failure with a different major version mostly due to unsupported syntaxes; {\sys} may be extended to support multiple compiler versions by creating an individual WRO per version, which we leave part of our future work. As a final note, recall that WROs are added to off-chain storage (rather than in a smart contract itself) without incurring an additional gas cost.





\PP{Threats to Validity}
The threats to the validity of this work mainly come from two aspects. 
A possible threat is whether we used representative smart contracts for evaluation. Even though we collected 4,112,336 smart contracts from all Ethereum blocks,
our experiments include only 27,824 smart contracts based on the DBSCAN clustering results for distinct
smart contracts. 
Before clustering, we exclude 7,422 (4.17\%) small-sized smart contracts because those contracts do not have a sufficient number of CFG blocks for embedding watermarks.
However, it would not be problematic with considerably complex business logic in most cases, which increases the size (and the number of blocks accordingly) of a smart contract.
Another threat to validity is the generalizability of \sys. Because the current implementation of \sys relies on EtherSolve~\cite{4_EtherSolve} to generate CFGs from smart contracts, our evaluation may not be applicable with a different CFG generator. Supporting additional CFG generators is part of our future work.

