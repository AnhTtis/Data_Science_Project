We make experiments in order to answer the following questions. 
Q1: we evaluate the effectiveness of our proposal; how largely our proposal improves the workload latency compared to NoSE, which optimizes the schema design by approximating a time-depended workload with an average static workload (Section \ref{sec:evalLatency}).  
Q2: we evaluate the effectiveness of workload summary tree, that is how largely the optimization execution time is reduced using workload summary tree (Section \ref{sec:evalOptRunningTime}). 
Q3: 
%この章では，提案手法の性能を評価するために3つの問いを設けて，それぞれ評価する．
%1つ目の問いとして，提案手法がスキーマのマイグレーションを実行することで，NoSE を用いたスキーマよりも応答時間を低減しているかを確認する (\ref{sec:evalLatency}節)．
% 2つ目の問いとして，抽象化による候補削減手法によって，最適化の実行時間を低減していることを確認する (\ref{sec:evalOptRunningTime}節)．
そして，3つ目の問いとして，提案手法の効率的な CF，クエリプラン列挙手法を用いることで，NoSE に比べてスキーマ最適化の実行時間を低減しているかを確認する (\ref{sec:evalCFEnumerationTime}節)．

All experiments were performed on a single server with two Intel(R) Xeon(R) Gold 6130 CPU (2.10GHz processors, 64 logical cores) and 1.5TB main memory using Docker vXXXXXX with Ubuntu XX.XX.
We use Apache Cassandra (version 3.11.8) as an extensible record store. 
% 本稿の性能評価では，extensible record store の一つである Apache Cassandra（バージョンは 3.11.8）を利用し， CPU に 2.10GHz の Intel(R) Xeon(R) Gold 6130 CPU を2つ搭載し，1.5TB のメモリを持つサーバを使用した\todo{ストレージも確認．NoSE くらいの粒度で説明したい}．
We make experiments using a Docker container of five nodes of Apache Cassandra on the single server
and evaluate workload latency.  
1台のサーバ上で5つのノードを持つ Apache Cassandra を Docker コンテナで構築し，クライアントとマイグレータも同一のサーバ上で動作させて応答時間を計測した．
本稿で提案するコストモデルは Cache の影響を考慮していないため，Cassandra でのキャッシュは全て無効化した．
また，ILP のソルバはバージョン 10.0.1 の Gurobi~\footnote{https://www.gurobi.com/} を用いた．

\subsection{Experimental Setting}\label{sec:setting}

{\bf Workload: } 
Since there are not open real-world time-dependent workloads, we generate two synthetic time-dependent workloads by modifying two static benchmarks, TPC-H~\footnote{http://www.tpc.org/tpch/} and RUBiS~\cite{Cecchet2002};
We change the query frequencies by following the typical time-depended settings summarized in prior study~\cite{Ma2018}.
We use three types of ratio changes:
\begin{itemize}
    \item Periodical: The query ratios periodically increase and decrease. 各時刻のユーザ行動の傾向によって問い合わせが変化するサービスでは，一日毎に周期的に問い合わせの頻度が変化する場合がある．このような頻度変化において，企業が経験則から頻度変化を予測しスキーマをマイグレーションする場合を想定する．
    \item Spike:時刻変化においてスパイクが発生する場合を模した頻度変化である．
この頻度変化は，サービスにおいて，情報公開等による急激なアクセス増加を企業が予測し，スキーマをマイグレーションする場合を想定する．
    \item Linear: ある処理の実行頻度が単調に変化する場合を模した頻度変化である．
これは，期限のある手続きに対して期限前に近づくほど単調に問い合わせ回数が増加するような場合を想定している．
\end{itemize}
各ワークロードのそれぞれのグループの実行頻度の変化を図~\ref{eval:FreqChange} に示す．
%本実験では，意思決定支援システムを模したベンチマークである TPC-H~\footnote{http://www.tpc.org/tpch/} に時刻変化を加えたワークロードを用いる．
%\footnote{NoSQL データベースのベンチマークとして YCSB~\cite{Cooper2010}やRUBiS~\cite{Cecchet2002}が使用されている．しかし，YCSB は限定的なスキーマのみを用いておりスキーマ設計の性能評価には適さない．RUBiS はシンプルなクエリのみを持つため，スキーマの選択肢が十分に無く，マイグレーションの性能評価には適していない．}
% ここで，提案手法の対応するクエリ言語は NoSE のクエリ言語に集約処理等の機能を追加したものであり，SQL に比べて限定的な機能のみを持つ．
% そのため，主に以下の3つの変更を加えることで，TPC-H のクエリを処理可能なクエリへ変換した．
% 1つ目の変更として，NoSE と同様に，等号条件を持たないクエリに対応していないため一部のクエリを削除した．
% 2つ目の変更として，提案手法のクエリ言語は LIKE や BETWEEN などをサポートしていないため，それぞれ等号条件や範囲条件に変更した．
% 3つ目の変更として，入れ子クエリも個別のクエリへ分解して，等号条件を持つクエリのみワークロードに個別のクエリとして追加した
TPC-H のレコードは，スケールファクタが 1 のレコードを作成して用いた．
% \par
% TPC-H は静的なベンチマークであり時刻変化しないため，本実験では3種類の頻度変化を加えてベンチマークに用いた．
% これらの頻度変化は，Ma ら~\cite{Ma2018} の用いたワークロードを模したものである．
%ただし，Ma らの用いた実データは公開されていないため，簡単化した頻度変化を生成して用いた．
% 1つ目の頻度変化は，周期的に実行頻度が変化する場合を模した頻度変化である．


% 2つ目の頻度変化は，
% 3つ目の頻度変化は，
% また，本稿で対象とする時刻変化は頻度変化のみを対象とするため，ワークロードのクエリに含まれるクエリは一定とした．

\par
\begin{figure}[t]
    \begin{minipage}[b]{0.5\linewidth}
        \includegraphics[scale = 0.31, bb = 0 0 726 275]{figs/cyclic.pdf}
    \end{minipage} \\
    \begin{minipage}[b]{0.5\linewidth}
        \includegraphics[scale = 0.31, bb = 0 0 726 275]{figs/spike.pdf}
    \end{minipage} \\
    \begin{minipage}[b]{0.5\linewidth}
        \includegraphics[scale = 0.31, bb = 0 0  726 275]{figs/growth.pdf}
    \end{minipage}
    \caption{各時刻変化するワークロードのクエリグループの実行頻度の変化．}
    \label{eval:FreqChange}
\end{figure}

時刻変化するワークロードにおいて，全てのクエリの実行頻度が同様に変化した場合，マイグレーションの必要性は小さく，性能評価に適さない．
そこで，オリジナルの TPC-H のクエリを持つグループと，複製した TPC-H のクエリを持つグループの2グループを持つワークロードを作成した．
そして，これらのグループに異なる周期変化の周期，ピークの時刻，単調変化の増減を割り当てて，各時刻において重要となる問い合わせが変化するワークロードを作成した．
各ワークロードのそれぞれのグループの実行頻度の変化を図~\ref{eval:FreqChange} に示す．

{\bf Comparison: } 
提案手法の比較手法として，5つの手法を実装した．
\begin{itemize}
\item \textbf{平均実行頻度に対する最適化}: 
各時刻の実行頻度の平均値を実行頻度として用いる最適化である．
\item \textbf{最小時刻実行頻度に対する最適化}: ワークロードの最小時刻の実行頻度を用いる最適化である．
\item \textbf{最大時刻実行頻度に対する最適化}: ワークロードの最大時刻の実行頻度を用いる最適化である．
\item \textbf{候補削減無しの提案手法}: 提案手法の抽象化による候補削減を無効化し，全ての候補について一括で最適化する．
この手法では最適化の実行時間は増加するが，より精度の高いスキーマを期待できる．
\item \textbf{理想的な最適化}:マイグレーションを考慮せず各時刻のスキーマを独立に最適化することで，各時刻のワークロードに最も適したスキーマを推薦する．
しかし，マイグレーションを想定していないため更新処理の結果等を引き継ぐことができない．
さらに，マイグレーションが出来ないため，各時刻のスキーマを他の時刻でも保持しなければならず，ストレージを圧迫する．
したがって，実際にデータベースを運用する際にこの手法を用いることは困難であるが，提案手法の性能の上限値の目安として用いる．
\end{itemize}
平均，最小，最大時刻実行頻度に対する最適化は全ての時刻において同じスキーマを使用する静的な最適化手法であり，NoSEに相当する．
NoSEを直接利用する場合，TPC-H の複雑なクエリに対してスキーマ決定が困難であったため，CF列挙・クエリプラン列挙・コストモデル・目的関数は提案手法と同様の手法を使用した．

{\bf Metrics and parameters: } 
本稿の実験では各クエリをその実行頻度によらず，全ての時刻で同一の回数実行する．
そして，本来の実行頻度に応じて重みを付けてその平均値を求めることで，各時刻の実行頻度による応答時間の変化を考慮する．

本実験で用いるワークロードは，更新処理を持たない TPC-H をベースとしているためストレージサイズの制約を設ける．
ストレージサイズの制約を設けることで，全てのクエリに対して MV プランを推薦できず，最適なスキーマ設計が困難となる場合において提案手法の性能を確認する．
ストレージサイズの制約の値を決定するために，制約を設けず平均実行頻度に対する最適化を実行し，そのストレージサイズの推定値を取得する．
そして，その推定値から一定の割合削減したサイズをストレージサイズの推定値の制約値として用いる\footnote{ストレージサイズの制約は，スキーマが正規化されるという点において，更新処理を考慮すると同様の影響を持つ．}．

\subsection{ワークロードの応答時間の評価}\label{sec:evalLatency}
本節では，時刻変化するワークロードに対して提案手法が適切にマイグレーションを実行して，応答時間を低減するかを確認する．

\subsubsection{実行頻度が周期的に変化するワークロードでの実験}\label{sec:periodical_latency}
図~\ref{eval:FreqChange}の実行頻度が Periodical に変化するワークロードに対して，各手法の推薦するスキーマの応答時間を計測した結果を図~\ref{eval:cyclic_latency} に示す．
ストレージ容量の制約値は，ストレージ制約の無い平均実行頻度の最適化のストレージ値の 80\% のサイズを用いた．
提案手法はマイグレーションを活用することで，ワークロードの実行頻度が Periodical に変化する場合でも低い応答時間を維持することを確認した．
また，時刻 0,1,2,6,7,8 では理想的な最適化と同程度の応答時間を達成した．
提案手法の実行頻度による加重応答時間平均は，最小時刻実行頻度に対する最適化に比べて40.2\%，最大時刻実行頻度に対する最適化に比べて 40.0\%, 平均実行頻度に対する最適化に比べて 35.7\%削減していることを確認した．
また，理想的な最適化に比べると実行頻度による加重応答時間平均は22.9\% 増加した．
候補削減無しの提案手法は提案手法に比べてより多くの最適化候補を用いて最適化する．
そのため，提案手法よりも候補削減無しの提案手法の方がより応答時間を低減すると想定される．
しかし実験では，候補削減無しの提案手法に比べ，実行頻度による加重応答時間平均を2.3\%低減した．
これは，提案手法は候補削減によって，限定的な最適化候補のみを用いるため，提案手法の応答時間の方が候補削減無しの提案手法よりも応答時間が大きくなるという想定に反する．
原因としては，提案手法のシンプルなコストモデルでは，各属性のカーディナリティが十分な精度で推定できず応答時間に差異が生じている可能性が考えられる．

各比較手法について，最小時刻実行頻度に対する最適化や最大時刻実行頻度に対する最適化は，それぞれ時刻0や時刻11で応答時間を低減している．
一方で，最適化対象とした時刻と実行頻度が異なる時刻においては応答時間が大幅に増加している．
平均実行頻度に対する最適化では，最小時刻実行頻度に対する最適化と最大時刻実行頻度に対する最適化に比べて低い応答時間を維持しているが，実行頻度の変化に応じて応答時間が増加している時刻がある．

\todo{最大時刻実行頻度に対する最適化が時刻11に理想的な最適化に負けている理由を考察する．表\ref{eval:periodical_mig_plans} に示したマイグレーションプランについての考察に1段落分割く}

\begin{figure}[t]
    \includegraphics[scale = 0.62, bb= 0 0 409 256]{eval_figs/obsolete_cyclic_80per.pdf}
    \caption{実行頻度が周期的に変化するワークロードでの応答時間の推移．横軸が各時刻，縦軸が応答時間の実行頻度による加重平均．静的な最適化手法では実行頻度の変化に追従できず，応答時間の加重平均値が増加しているが，提案手法は低い応答時間の加重平均値を維持している．}
    \label{eval:cyclic_latency}
\end{figure}

\begin{table}[]
\begin{tabular}{l|l|l}
time step & cf migration plan type & query \\ \hline
                                     & MV Plan $\rightarrow$ Join Plan  & Q3-dup, Q5-dup, Q7-dup, Q9-dup \\ \cline{2-3} 
\multirow{-2}{*}{2 $\rightarrow$ 3}  & Join Plan $\rightarrow$  MV Plan & Q3, Q5, Q7, Q9                 \\ \hline
                                     & MV Plan $\rightarrow$ Join Plan  & Q3, Q5, Q7, Q9                 \\ \cline{2-3} 
\multirow{-2}{*}{5 $\rightarrow$ 6}  & Join Plan $\rightarrow$ MV Plan  & Q3-dup, Q5-dup, Q7-dup, Q9-dup \\ \hline
                                     & MV Plan $\rightarrow$ Join Plan  & Q3-dup, Q5-dup, Q7-dup, Q9-dup \\ \cline{2-3} 
\multirow{-2}{*}{8 $\rightarrow$ 9}  & Join Plan $\rightarrow$ MV Plan  & Q3, Q5, Q7, Q9                
\end{tabular}
\caption{容量制約80\%下で Periodical に実行頻度が変化するワークロードを最適化した際に提案手法が推薦した cf migration plan}
\label{eval:periodical_mig_plans}
\end{table}

\begin{table}[]
\begin{tabular}{l|l|l}
time step & cf migration plan type & query \\ \hline
                                     & MV Plan $\rightarrow$ Join Plan  & Q3-dup, Q5-dup, Q7-dup, Q9-dup \\ \cline{2-3} 
\multirow{-2}{*}{5 $\rightarrow$ 6}  & Join Plan $\rightarrow$ MV Plan  & Q3, Q5, Q7, Q9 \\ \hline
\end{tabular}
\caption{容量制約80\%下で Linear に実行頻度が変化するワークロードを最適化した際に提案手法が推薦した cf migration plan}
\label{eval:Linear_mig_plans}
\end{table}


\begin{figure}[t]
    \includegraphics[scale = 0.62, bb = 0 0 409 256]{eval_figs/linear_80per.pdf}
    \caption{Linear, 80per, }
    \label{eval:monotonic_latency}
\end{figure}
\begin{figure}[t]
    \includegraphics[scale = 0.62, bb = 0 0 409 256]{eval_figs/spike_80per.pdf}
    \caption{spike, 80per．この実験結果は加重平均の計算方法に修正が必要なため，参考図．修正した場合，時刻0,1,2,5,6,9,10 の全て最適化結果の応答時間が5倍で計算される見込み}
    \label{eval:spike_latency}
\end{figure}

\begin{figure}[t]
    \includegraphics[scale = 0.31, bb = 0 0 831 683]{eval_figs/obsolete_latencies_on_storage_constraints.pdf}
    \caption{容量制約を変化させた際の各最適化手法の実行頻度による加重応答時間平均の総和の推移}
    \label{eval:latencies_under_various_space}
\end{figure}

\subsubsection{実行頻度が単調に変化するワークロードでの実験}



\subsubsection{実行頻度にピークを持つワークロードでの実験}

\todo{high priority}

\subsection{容量制約を変化させた際の応答時間の評価}

提案手法がマイグレーションを適切に推薦することで，容量制約の厳しい環境下でも応答時間の増加を低減することを確認するために，容量制約の値を変化させ実行頻度による加重応答時間平均の総和を計測した．
ただし，容量制約90\%での候補削減無しの提案手法は 24 時間最適化を実行しても最適化が完了しなかったため，本実験では対象外とした．
実験結果を図~\ref{eval:latencies_under_various_space} に示す．
ワークロードは実験~\ref{sec:periodical_latency}と同様に Periodical な頻度変化をする 12 時刻のワークロードを用いた．
また，平均実行頻度に対する最適化を容量制約無しで実行した最適化結果のストレージサイズを 100\% の値として用いた．
そのため，容量制約が100\% の環境が最も制約が緩く，容量制約が70\% の環境が最も制約が厳しい．
一般に，容量制約が厳しい場合ではストレージサイズを削減するためにスキーマを正規化する必要がある．
そして，スキーマを正規化すると，各クエリの実行計画としてジョインプランを選択する場合が増加するため，容量制約が厳しいほど応答時間が増加する．
ここで，提案手法ではマイグレーションを活用することで，各時刻で実行頻度の高いクエリに応答時間の短いクエリプランを推薦し，実行頻度による応答時間の加重平均の総和を削減する．
図~\ref{eval:latencies_under_various_space} の実験結果から，最小時刻実行頻度に対する最適化と最大時刻実行頻度に対する最適化の応答時間が容量制約85\%の場合に容量制約 90\% の場合に比べて大幅に増加している一方で、提案手法は応答時間の増加幅を低減していることを確認した．
また，容量制約80\% の場合では，平均実行頻度に対する最適化の応答時間が容量制約85\%の場合と比べて大幅に増加している一方で，提案手法は応答時間の増加を低減していることを確認した．
ただし，容量制約 75\% の場合では提案手法でも大幅な応答時間の増加を確認した．
これは，容量制約が厳しい場合では各クエリに対して提案可能な MV プランの総数が減少し，提案手法でもジョインプランを推薦する場合が増加するためと考えられる．
同様に，容量制約 70\% の場合では容量制約が厳しいため，提案手法はマイグレーションプランを推薦できず，他の手法と同等の応答時間となっている．

図~\ref{eval:latencies_under_various_space} において，コストモデルの精度が不十分なことが原因と考えられる3つの傾向が見られた．
これらの傾向の原因は，コストモデルの推定する実行コストと実際の応答時間の差異と考えられる．
1つ目は，理想的な最適化において，容量制約 90\% 下での実行頻度による加重平均応答時間が容量制約 95\% 下の実行頻度による加重平均応答時間に比べて小さい点である．
これは，容量制約が厳しくなるほど応答時間が増加する想定と異なる．
ここで，最適化の目的関数~\eqref{baseObjective:Objective} の最適化結果の値では，容量制約90\%の目的関数の値は，容量制約95\%の目的関数の値に対して，3.45\% 増加していた．
したがって，コストの最適化の結果では，容量制約が厳しくなるほど推定される実行コストは増加しており，想定と一致している．
2つ目は，提案手法と候補削減無しの提案手法の応答時間を比較すると，容量制約85\%, 80\%, 75\% において提案手法の応答時間が僅かに小さい点である．
これは提案手法が候補削減無しの提案手法に比べて限定された候補のみに対して最適化していることと矛盾する．
ここで，目的関数~\eqref{baseObjective:Objective} の値を比較すると，85\%, 80\%, 75\% の容量制約において目的関数の値の差異は 0.001\% 未満であった．
したがって，コスト最適化の結果では，提案手法と候補削減無しの提案手法の差異は僅かである．
3つ目は，容量制約 70\% の場合に提案手法の応答時間が最も大きくなっている点である．
ここで，目的関数~\eqref{baseObjective:Objective}の値を比較すると，各比較手法との目的関数の値の差は 0.1\% 未満であった．

提案手法は属性のカーディナリティや属性のフィールドサイズに基づくシンプルなコストモデルを使用している．
しかし，このコストモデルの精度が不十分であるため，目的関数の値と実際の応答時間の傾向に差異が生じたと考えられる．
各属性のカーディナリティやレコードサイズのより高精度な推定は今後の課題である．

\subsection{抽象化による候補削減による最適化実行時間の評価}\label{sec:evalOptRunningTime}



\begin{figure*}[t]
    \includegraphics[scale = 0.4, bb = 0 0 1234 521]{eval_figs/obsolete_RunningTimes.pdf}
    \caption{\todo{系列の名前を with pruning, without pruning に変更する．このキャプションで全て提案手法の実行時間を計測したものであることを明記する．また時刻毎に棒グラフを寄せて，他の時刻との間にスペースを追加することで，グラフを見やすくする}}
    \label{eval:latencies}
\end{figure*}

%\subsection{CF 列挙効率化による実行時間の評価}\label{sec:evalCFEnumerationTime}
