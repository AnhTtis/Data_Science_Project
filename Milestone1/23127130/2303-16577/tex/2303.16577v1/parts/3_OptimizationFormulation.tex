We formulate the problem of time-series workload optimization using a single integer linear program (ILP) and output an optimized time-series schema, query plans at every time step, and migration plans between adjacent time steps.
The benefit of this approach is that it formulates the total cost of time-dependent workload execution and database migration using a single ILP, so it can handle the trade-off between the cost of time-dependent workload and database migration.
%the dependencies between query plans and migration plans are naturally handled in the single ILP.
%That is, we can not optimize the workload cost (query plans) and migration cost independently but we need to optimize both at the same time,
%because migration plans depend on the current schema at time $t$ and next schema at time $t+1$ and also query plans depend on the current schema, which is generated from migration plans.

For a given time-dependent workload consisting of queries $Q$ and update operations $U$, 
we obtain an optimized time-series schema $(S_1, ..., S_T)$ from time step $t = 1$ to $T$ by minimizing the following objective function using three constraints for query plans, migration plans, and storage size.

\noindent\\
{\bf{Objective function:}}
The objective of optimizing time-series physical schema ($S_1,\ldots, S_T$) is to minimize the total cost of time-dependent workload execution and database migration.
\begin{equation}
        \min_{S_1,\ldots, S_T} \; \sum_{t = 1}^{T} \mathit{workload}(S_{t}) + \sum_{t = 1}^{T - 1}\mathit{migrate}(S_{t}, S_{t + 1})\label{baseObjective:Objective}
\end{equation}
where $\mathit{workload}(S_{t})$ indicates the workload execution cost on schema  $S_{t}$ at time step $t$, and
$\mathit{migrate}(S_{t}, S_{t+1})$ indicates the migration cost from schema $S_{t}$ to $S_{t + 1}$.
If there is no migration ($S_{t}$ = $S_{t+1}$), then $\mathit{migrate}(S_{t}, S_{t + 1})$ = 0.

\subsection{Workload execution cost}
Workload execution cost is defined as the total cost of all queries and update operations in the workload;
each query/update operation cost is computed as the product of its frequency and its estimated execution cost. 
In detail, we define the workload execution cost at time step $t$ as follows:
\begin{equation}
    \begin{split}
        \mathit{workload}(S_t) &= \sum_{q_i \in Q} \sum_{cf_j \in CF(P(q_i))} f_{i}(t) C_{ij} \delta_{ijt} \\ 
                      &+ \sum_{u_u \in U} \sum_{cf_n \in S(t)} f_{u}(t) C^{\prime}_{un} \delta_{nt} \label{WorkloadCost}
    \end{split}
\end{equation}
where $P(q_i)$ is a query plan group enumerated from $q_i$ and $CF(P(q_i))$ is a set of column families enumerated from $q_i$ used in query plan group $P(q_i)$\footnote{See Section~\ref{sec:proposal} for the detail of column family enumeration.}.
The first and the second terms on the right-hand side express query cost and update operation cost, respectively. 
The first term, $f_{i}(t)$ is the frequency of query $i$ at time step $t$ and $C_{ij}$ is the coefficient that represents the cost of query $i$ using column family $cf_j$.
$\delta_{ijt}$ is a binary decision variable which expresses whether query $q_i$ uses column family $cf_j$ at time step $t$.
Thus, the query cost is the summation of $f_{i}(t) C_{ij} \delta_{ijt}$ for all combinations of queries and column families.
The second term, $f_{u}(t)$ is the frequency of update operation $u$ at time step $t$ and $C^{\prime}_{un}$ is the coefficient that represents the cost of update operation $u$ for column family $cf_n$.
$\delta_{nt}$ is a binary decision variable which expresses whether column family $n$ exists in schema $S_t$ at time step $t$.
Thus, the update cost is the summation of $f_{u}(t) C^{\prime}_{un} \delta_{nt}$ for all combinations of update operation $u$ and column family $n$.

\subsection{Migration cost}
Remember that we choose a single optimized migration plan among multiple migration plan groups obtained from migration queries.
We define the database migration cost from old schema $S_{t}$ to new schema $S_{t + 1}$ using multiple migration queries as follows:
\begin{equation}
    \begin{split}
        migrate&(S_{t}, S_{t + 1}) =  \\
            &\sum_{cf_g \in S_{t + 1}}\sum_{cf_h \in CF(P(q_{o}^{\prime})), q_{o}^{\prime} \in M(cf_g)}  C^{E}_{h} \delta^{E}_{goht} \\
            & + \sum_{cf_g \in S_{t + 1}} C^{L}_{g} \delta^{L}_{g(t + 1)} \\ 
            & + \sum_{u_u \in U} \sum_{cf_g \in S_{t + 1}} C^{U}_{ug} \delta^{L}_{g(t + 1)}
        \label{migrateCost}
    \end{split}
\end{equation}
where $M(cf_g)$ is migration queries for target column family $cf_g \in S_{t + 1}$,
migration plan group $P(q_{o}^{\prime})$ and set of column families $CF(P(q_{o}^{\prime}))$
for migration query $q_{o}^{\prime}$ are similarly defined in the workload execution cost (Equation~\eqref{WorkloadCost}).
\par
The first term on the right-hand side expresses the cost of collecting records from old schema using migration plans.
$C^{E}_{h}$ is the coefficient that represents the cost of data collection from each column family $cf_h$.
$\delta^{E}_{goht}$ is a binary decision variable\footnote{$\delta^{E}_{goht}=0$ when $cf_g$ is not newly generated at time step $t$ for all $cf_h$.} that expresses whether migration query $q_{o}^{\prime}$ uses old column family $cf_h$ for generating new column family $cf_g$ at time step $t$.
Thus, the cost of collecting records from the old schema is the summation of $C^{E}_{h} \delta^{E}_{goht}$ for all combinations of column family $cf_g$, migration query $q_{o}^{\prime}$, and column family $cf_h$.

The second term expresses the cost of inserting the collected records into a new schema.
$C^{L}_{g}$ is the coefficient that represents the cost of inserting the collected records into new column family $cf_g$.
$\delta^{L}_{g(t + 1)}$ is a binary decision variable that expresses whether database migration to column family $cf_g$ is made between time step $t$ and $t + 1$. 
If $\delta^{L}_{g(t + 1)}=1$ then column family $cf_g$ does not exist at time step $t$ and exists at $t + 1$, so we introduce the following constraint~\eqref{Eq:CFMigration}: 
\begin{align} \label{Eq:CFMigration}
    \delta_{g(t + 1)} - \delta_{gt} \leq \delta^{L}_{g(t + 1)}
\end{align}

The third term expresses the cost of maintaining the new schema for ongoing update operations $U$ in workload.
$C^{U}_{ug}$ is the coefficient that represents the cost of update operation $u\in U$ for new column family $cf_g$ during the migration process.

\subsection{Constraints} \label{Section:Constraint}
We introduce three constraints for query plans, migration plans, and storage size
in order to choose column families required for optimized query/migration plans and avoid generating unused column families.

\subsubsection{Constraints for query plans}
Constraints for query plans ensure that 
for each query $q_i\in Q$ at every time step $t$, 
1) we choose a single optimized query plan $p_t$ among query plan group $P(q_i)$  (constraint~(\ref{const:ensureParentGeneral}, ~\ref{const:ensureOnePlanGeneral})), and 
2) all column families used in optimized query plan $p_t$ should exist in schema $S_{t}$ (constraint~\eqref{const:ensureExistenceGeneral}).
A decision variable is appropriately assigned to each $\delta_{ijt}$ and $\delta_{nt}$ in Equation~\eqref{WorkloadCost} using these constraints.

The first constraint~\eqref{const:ensureParentGeneral} ensures that if column family $cf_j$ is used in query plan $p_t$, any other column family $cf_l$ that precedes ($\prec$) $cf_j$ in the same query plan needs to be chosen.
\begin{equation}
    \forall cf_j, cf_l \in CF(P(q_i)). \:\: cf_l \prec_{p_t} cf_j \rightarrow \delta_{ilt} \geq \delta_{ijt}\label{const:ensureParentGeneral}
\end{equation}
where $\delta_{ijt}$ expresses whether query $q_i$ uses column family $cf_j$ at time step $t$ (introduced in Equation~\eqref{WorkloadCost}).

The second constraint~\eqref{const:ensureOnePlanGeneral} ensures that we produce a single unique query plan that joins all adjacent entities in a query graph.
\begin{equation}
    \begin{split}
        &\forall e, e^{\prime} \in \mathit{Entity}(q_i). \\ 
        &\quad \sum_{\substack{\{cf_j \in \mathit{CF}(P(q_i)) |\ e, e^{\prime} \in \mathit{Entity}(cf_j)\}}} \delta_{ijt} = 1 \label{const:ensureOnePlanGeneral}
    \end{split}
\end{equation}
where $\mathit{Entity}(q_i)$ is an entity set used in query $q_i$, $e$ and $e^{\prime}$ are entities that are adjacent in $q_i$'s query graph\footnote{The query graph expresses a partial schema relating to a given query extracted from the entity graph. Our current implementation is restricted to acyclic query graphs as in the implementation of NoSE~\cite{Mior2017}.}~\cite{Mior2017}, and
$\mathit{Entity}(cf_j)$ is a entity set from which column family $cf_j$ is generated.
The constraint~\eqref{const:ensureOnePlanGeneral} ensures that only single column family $cf_j$ is chosen from $CF(P(q_i))$ for partial columns of each adjacent entity pair $e, e^{\prime}$ used in $q_i$ at every time step $t$ (specified by $\sum{\delta_{ijt} = 1}$)\footnote{We permit generating a single column family for a leaf entity in the query graph\label{footnote_6}.}.

The third constraint~\eqref{const:ensureExistenceGeneral} ensures that if query plan $p_t$ is chosen as the optimized plan for $q_i$ at time step $t$, all column families ($cf_j$) used in $p_t$ should exist at the same time step.
\begin{equation}
    \forall cf_j \in CF(P(q_i)). \ \delta_{jt} \geq \delta_{ijt} \label{const:ensureExistenceGeneral}
\end{equation}
That is, if $\delta_{ijt}=1$ then $\delta_{jt}=1$ (remember that $\delta_{jt}$ was introduced in Equation~\eqref{WorkloadCost}).

As an example, we give the following constraints for $q_2$ at time step $t$ in Figure~\ref{TdQueryPlanExample}.
\begin{subequations}\label{Eq:OneTimeConstraint}
    \begin{align}
        \delta_{2,5,t} &\geq \delta_{2,3,t} \label{const:ensureParent}\\
        \delta_{2,4,t} + \delta_{2,5,t} &= 1, \delta_{2,3,t} + \delta_{2,4,t} = 1 \label{const:ensureOnePlan} \\
        \delta_{j,t}  &\geq \delta_{2,j,t} \;\;\; \forall j \in \{3, 4, 5\} \label{const:ensureExistence}
    \end{align}
\end{subequations}
where \eqref{const:ensureParent}, \eqref{const:ensureOnePlan}, and \eqref{const:ensureExistence} are instantiated from general constraints \eqref{const:ensureParentGeneral}, \eqref{const:ensureOnePlanGeneral}, and \eqref{const:ensureExistenceGeneral}, respectively.
Constraint~\eqref{const:ensureParent} ensures that $\mathit{CF}5$ is chosen whenever $\mathit{CF}3$ is used. 
The left-hand side of Constraint~\eqref{const:ensureOnePlan} specifies choosing either $\mathit{CF4}$ or $\mathit{CF}5$ for partial columns of an adjacent entity pair (\emph{Item} and \emph{User}), and the right-hand side specifies choosing either $\mathit{CF}3$ or $\mathit{CF}4$ for partial columns of a leaf entity (\emph{User}, see footnote\footref{footnote_6}).
Finally, constraint~\eqref{const:ensureExistence} ensures that $S_{t}$ contains $\mathit{CF}3, \mathit{CF}4, \mathit{CF}5$ if they are used in the optimized query plan of $q_2$.

\subsubsection{Constraints for migration plans}
\todo{The content is quite similar to the constraints for query plans. So, we may move this part to Appendix and give a short summary instead.}
Constraints for migration plans ensure that 
for each target column family $cf_g\in S_{t + 1}$ (specified by $\delta^{L}_{g(t + 1)} = 1$),
1) we choose a single migration plan based on the migration queries for the target column family $cf_g$ (constraints \eqref{const:ensureMigParentGeneral},\eqref{const:ensureMigOnePlanTreeGeneral},\eqref{const:ensureMigOnePlanGeneral}) and
2) all column families used in the chosen migration plan should exist in $S_{t}$ (constraint~\eqref{const:ensureMigExistenceGeneral}).
A decision variable is appropriately assigned to each $\delta^{E}_{goht}$ and $\delta^{L}_{g(t + 1)}$ in Equation~\eqref{migrateCost} using theses constraints.

Similarly to the constraint~\eqref{const:ensureParentGeneral} for query plans, 
the first constraint~\eqref{const:ensureMigParentGeneral} ensures that if the previous column family $cf_h$ is used in a migration plan, any other column family $cf_l$ that precedes ($\prec$) $cf_h$ in the same migration plan needs to be chosen.
\begin{equation}
    \begin{split}
        &\forall q^{\prime}_{o} \in M(cf_g), \; \forall cf_h, cf_l \in CF(P(q^{\prime}_{o})). \\ 
        &\qquad cf_l \prec cf_h \rightarrow \delta^{E}_{golt} \geq \delta^{E}_{goht}\label{const:ensureMigParentGeneral}
    \end{split}
\end{equation}
where $\delta^{E}_{golt}$ and $\delta^{E}_{goht}$ express whether old column family $cf_l$ and $cf_h$ exists in schema $S_t$, respectively.

We choose a single migration plan from migration queries for target column family $cf_g$ in two steps as follows.
In the first step, we choose single migration query $q^{\prime}_o$ from the migration queries $M(cf_g)$ (specified by $\sum\delta^{T}_{got}=1$) when target column family $cf_g$ is generated at time step $t+1$ (specified by $\delta^{L}_{g(t + 1)}=1$) using the second constraint~\eqref{const:ensureMigOnePlanTreeGeneral}.
\begin{equation}
    \sum_{q^{\prime}_{o} \in M(cf_g)} \delta^{T}_{got} = \delta^{L}_{g(t + 1)}
    \label{const:ensureMigOnePlanTreeGeneral}
\end{equation}

In the second step, we choose a single migration plan for the migration query chosen in the first step.
Similarly to the constraint~\eqref{const:ensureOnePlanGeneral} for query plans, the third constraint~\eqref{const:ensureMigOnePlanGeneral} ensures that only a single column family is chosen (specified by $\sum{\delta^{E}_{gomt} = \delta^{T}_{got}}$) for partial columns of adjacent entity pair $e, e^{\prime}$ in the migration query graph from each migration plan group transformed from $q_{o}^{\prime}$ at every time step $t$.
\begin{equation}
    \begin{split}
        &\forall e, e^{\prime} \in \mathit{Entity}(cf_g). \\
        &\qquad \sum_{\substack{\{cf_m \in \mathit{CF}(M(cf_g)) |\ e, e^{\prime} \in \mathit{Entity}(cf_m) \}}} \delta^{E}_{gomt} = \delta^{T}_{got} \label{const:ensureMigOnePlanGeneral}
    \end{split}
\end{equation}
where $\delta^{T}_{got}$ is a binary decision variable that expresses whether an optimized migration plan for the target column family $cf_g$ is chosen from migration plan group $P^{M}_o$ at time step $t$. 

Similarly to the constraint~\eqref{const:ensureExistenceGeneral}, the fourth constraint~\eqref{const:ensureMigExistenceGeneral} ensures that
if a migration plan is chosen as the optimized plan for generating $cf_g$ at time step $t$, all column families ($cf_h$) used in the optimized migration plan should exist at the same time step.
\begin{equation}
    \forall q^{\prime}_{o} \in M(cf_g), \forall cf_h \in \mathit{CF}(P(q^{\prime}_{o})). \:\: \delta_{ht} \geq \delta_{goh(t + 1)}^{E}\label{const:ensureMigExistenceGeneral}
\end{equation}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale = 0.97,bb = 0 0 212.88 101.04]{./figs/migration_plan_example.pdf}
        \caption{An example of enumerated migration plans for collecting data of $\mathit{CF}3$ in Fig.~\ref{TdQueryPlanExample}. In order to collect data for $\mathit{CF}3$, we generate migration query $q^{\prime}_1$, $q^{\prime}_2$ and $q^{\prime}_{a}$ and enumerate their migration plan groups using our proposed method (described in Section~\ref{Section:EnumerateMirgatePlan}). \todo{crop the figure}}
        \label{Fig:MigrationPlanExample}
    \end{center}
\end{figure}

Figure~\ref{Fig:MigrationPlanExample} depicts an example of a migration plan that generates a new column family $\mathit{CF}4$ in Figure~\ref{TdQueryPlanExample}.
The constraints to generate a single migration plan for $\mathit{CF}4$ are described as follows.
\begin{subequations}\label{Eq:PlanInMigPlanTree}
    \begin{align}
        \delta^{E}_{4,2,5,t} &\geq \delta^{E}_{4,2,3,t} \label{const:ensureMigParent} \\ 
        \delta^{T}_{4,a,t} &+ \delta^{T}_{4,2,t} = \delta^{L}_{4, t} \label{const:ensureMigOneTree} \\
        \delta^{E}_{4,2,5,t} = \delta^{T}_{4,2,t}&, \; \delta^{E}_{4,2,3,t} = \delta^{T}_{4,2,t}, \; \delta^{E}_{4,a,6,t} = \delta^{T}_{4,a,t} \label{const:ensureMigOnePlan} \\
        \delta_{3, t} \geq \delta^{E}_{4,2,3,t},\;& \delta_{5, t} \geq \delta^{E}_{4,2,5,t},\;
        \delta_{6, t} \geq \delta^{E}_{4,a,6,t} \label{const:ensureMigExistence}
    \end{align}
\end{subequations}
where \eqref{const:ensureMigParent}, \eqref{const:ensureMigOneTree}, 
 \eqref{const:ensureMigOnePlan}, \eqref{const:ensureMigExistence}, are instantiated from general constraints \eqref{const:ensureMigParentGeneral}, 
 \eqref{const:ensureMigOnePlanTreeGeneral}, \eqref{const:ensureMigOnePlanGeneral}, \eqref{const:ensureMigExistenceGeneral}, respectively.
Constraint~\eqref{const:ensureMigParent} ensures that the preceding $\mathit{CF}5$ is also chosen when $\mathit{CF}3$ is used in migration plan group 2. 
Constraint~\eqref{const:ensureMigOneTree} ensures that a single migration query is chosen among migration queries ($q^{\prime}_{a}$ and $q^{\prime}_{2}$).
Constraint~\eqref{const:ensureMigOnePlan} ensures that a single migration plan is chosen for $q^{\prime}_{a}$ and $q^{\prime}_{2}$, respectively.
Finally, constraint~\eqref{const:ensureMigExistence} ensures that $S_{t}$ contains all column families used in the optimized migration plan.

\subsubsection{Constraint for storage size} 

The storage size constraint~\eqref{baseObjective:spaceConst} ensures that the storage size of all column families should be smaller than $B$ at every time step $t$.
\begin{equation}
    \forall t \in [1, T]. \; \sum_j size(cf_j) \delta_{jt} \leq B \label{baseObjective:spaceConst}
\end{equation}
where $size(cf)$ is the storage size of column family $cf$. We ignore the size change of column families even when workload contains update operations, since the change in size is usually quite small compared to the whole database size.