\appendix
In the appendices, we first give a brief introduction to the optimal control problem in Appendix~\ref{app:a}. It is within this context that the rollout scheme, as well as Newton's step interpretation of the method, is developed. Then we show in Appendix~\ref{app:b} how the mixed integer program considered here can be transformed as an equivalent optimal control problem involving only discrete variables, thus proving Prop.~\ref{prop:rollout_mixed_int}. Next, we provide additional variants of the proposed scheme and connect it to a classical method within the optimal control context in Appendices~\ref{app:c} and \ref{app:d}. The majority of the proof arguments and transformation are modified from \cite{bertsekas2005rollout} and \cite[Section~3.4]{bertsekas2020rollout}. In Appendices~\ref{app:e} and \ref{app:f}, we provide further details on our optimal control problem, including the sufficient conditions for its feasibility and a procedure through which the bilinear constraints of our problem can be linearized.

\subsection{Optimal Control Problems and Rollout}\label{app:a}
We consider optimal control problems involving dynamics 
$$x_{k+1}=f_k(x_k,u_k),\quad k=0,\dots,N\!-\!1,$$
where $x_k$ and $u_k$ are the state and control at time $k$, which belong to some sets $X_k$ and $U_k$ that contain finite elements, respectively, and $f_k$ is some function. Each control must be chosen from a finite constraint set $U_k(x_k)$ that depends on the current state $x_k$. We are interested in the policy $\pi\!=\!\{\mu_0,\mu_1,\dots,\mu_N\}$, which is a sequence of functions $\mu_k:X_k\mapsto U_k$ such that $\mu_k(x_k)\in U_k(x_k)$ for all $x_k$. The set of all the policies is denoted as $\Pi$. 

When at $x_k$ and applying $u_k\!\in\! U_k(x_k)$, there is a stage cost $g_k(x_k,u_k)\!\in\! \Re\cup\{\infty\}$. In addition, there is a terminal cost $g_N(x_N)\in \Re\cup\{\infty\}$ for being $x_N$ at $N$th stage. For a policy $\pi$, starting from $x_k$, the total cost accumulated over $N-k$ stages plus the terminal cost are denoted as $J_{k,\pi}(x_0)$, i.e.,
$$J_{k,\pi}(x_k)=g_N(x_N)+\sum_{i=k}^{N-1}g_i\big(x_i,\mu_i(x_i)\big),$$
where $x_{i+1}\!=\!f_i\big(x_i,\mu_i(x_i)\big)$ for $i\!=\!k,\dots,N\!-\!1$. For brevity, we denote $J_{0,\pi}$ as $J_\pi$. Within this context, one hopes to find the optimal cost $J^*$ such that
$$J^*(x_0)=\min_{\pi\in \Pi}J_{\pi}(x_0).$$

For many problems, computing the optimal policy is impractical. In those cases, rollout is a simple yet reliable approximate solution method. Based upon a known policy $\Bar{\pi}=\{\Bar{\mu}_0,\dots,\Bar{\mu}_{N-1}\}$, referred to as the \emph{base policy}, rollout scheme computes a new policy $\Tilde{\pi}=\{\Tilde{\mu}_0,\dots,\Tilde{\mu}_{N-1}\}$, referred to as the \emph{rollout policy}, through computations
\begin{equation}
    \label{eq:rollout_op}
    \Tilde{\mu}_k(x_k)\in\arg\min_{u_k\in U_k(x_k)}\Big\{g_k(x_k,u_k)+J_{\Bar{\pi},k+1}\big(f_k(x_k,u_k)\big)\Big\},
\end{equation}
where $x_{k+1}\!=\!f_{k}\big(x_k,\Tilde{\mu}_k(x_k)\big)$, $k\!=\!0,\dots,N\!-\!1$. The rollout policy computed above is no worse than the base policy, as is given in the following proposition, which is adopted from \cite[Prop.~3.3.1]{bertsekas2020rollout}.
\begin{proposition}\label{prop:rollout_original}
Let $\Bar{\pi}\!\in\!\Pi$ and consider $\Tilde{\pi}$ obtained via \eqref{eq:rollout_op}. Then we have that
\begin{equation}
    \label{eq:rollout_bound_general}
    J_{k,\Tilde{\pi}}(x_k)\leq J_{k,\Bar{\pi}}(x_k),
\end{equation}
for $k\!=\!0,1,\dots,N\!-\!1$ and $x_k\!\in\! X_k$.
\end{proposition}

In fact, rollout can be interpreted as one step of Newton's method for computing $J^*(x_0)$ with its starting point provided by the base policy. Extensive discussions on rollout that go well beyond the context considered here can be found in \cite{bertsekas2020rollout,bertsekas2022lessons}. 

\subsection{Mixed Integer Problem and Rollout}\label{app:b}
We now show that the mixed integer problem formulated in \eqref{eq:mixed_int} can be transformed into the equivalent optimal control problem discussed above, and the algorithm described in Section~\ref{Section IV} is the rollout method applied to this equivalent problem. Based upon this transformation and Prop.~\ref{prop:rollout_original}, Prop.~\ref{prop:rollout_mixed_int} can be proved.

\begin{proof}[Proof of Prop.~\ref{prop:rollout_mixed_int}]
We define a fictitious state `null' as the initial state $x_0$ so that $X_0$ is the singleton $\{\text{`null'}\}$. The set $X_1$ is defined as $U_0$, and for $k\!=\!1,\dots,N\!-\!1$, the sets $X_{k+1}$ are defined recursively as $X_{k+1}\!=\!X_k\!\times\! U_k$. As a result, the set $X_N$ containing all terminal states equals $U$. The control constraint sets are independent of states, i.e., $U_k(x_k)=U_k$ for all $x_k\in X_k$ and $k$.

Given the current state $x_k$ and the control $u_k\in U_k(x_k)$, the dynamics $f_k$ takes the form
$$x_{k+1}=(x_k,u_k),\quad k=0,1,\dots,N\!-\!1;$$
namely concatenating the control $u_k$ to the current state $x_k$. The stage costs associated with all the state-control pair $(x_k,u_k)$ are $g_k(x_k,u_k)\equiv 0$, while the terminal cost is
$$g_N(x_N)=\min_{(x_N,v)\in \overline{C}}G(x_N,v).$$
In particular, $g_N(x_N)\!=\!\infty$ for $x_N\!\not\in\!C$. Therefore, given some $u\!=\!(u_0,\dots,u_{N-1})\!\in\!U$, we can implicitly define a policy $\pi\!=\!\{\mu_0,\dots,\mu_{N-1}\}$ so that $\mu_k(x_k)\equiv u_k$ and
$$J_\pi(x_0)=\min_{(u,v)\in \overline{C}}G(u,v).$$

With the equivalent optimal control problem in mind, we can see that the sequence of minimization \eqref{eq:rollout_mixed_int_0}-\eqref{eq:rollout_mixed_int_end} is the computations \eqref{eq:rollout_op} for $k\!=\!0,\dots,N\!-\!1$, and the bound \eqref{eq:rollout_bound} in Prop.~\ref{prop:rollout_mixed_int} is equivalent to \eqref{eq:rollout_bound_general}. In particular, $\Bar{u}\!\in\! C$ implies that $J_{\Bar{\pi}}(x_0)\!<\!\infty$. As a result, $J_{\Tilde{\pi}}(x_0)\!\leq\! J_{\Bar{\pi}}(x_0)$, which means that $\Tilde{u}\in C$.
\end{proof}

Based upon the transformation introduced above, the other variant of the proposed scheme discussed in Section~\ref{Section IV} can be interpreted accordingly within the context of the equivalent optimal control problem. 

\subsection{Variant Based on On-Line Policy Iteration}\label{app:c}
The rollout scheme can be repeated to further enhance the performance. In particular, given a policy $\Tilde{\pi}^0$, we can obtain a new policy $\Tilde{\pi}^1\!=\!\{\Tilde{\mu}_0^1,\dots,\Tilde{\mu}_{N-1}^1\}$ through computations similar to \eqref{eq:rollout_op} with $\Tilde{\pi}^0$ and $\Tilde{\mu}_k^1$ in place of $\Bar{\pi}$ and $\Tilde{\mu}_k$. After obtaining $\Tilde{\pi}^i$, we may proceed to compute $\Tilde{\pi}^{i+1}$ in a similar manner. This scheme can be considered as the on-line policy iteration algorithm \cite{bertsekas2021line} adapted to the optimal control problem of concern. If computational resource permits, the policies obtained would converge in the sense that for some finite $\Bar{k}$, starting from the same $x_0$, the trajectories generated under $\Tilde{\pi}^{\Bar{k}}$
and $\Tilde{\pi}^{\Bar{k}+1}$ are identical. Note that the obtained policy $\Tilde{\pi}^{\Bar{k}}$ upon convergence need not be optimal. Instead, it is optimal for a modified problem; see \cite[Definition~2.1]{bertsekas2021line}.

For the mixed integer program \eqref{eq:mixed_int} considered here, given a base solution $\Tilde{u}^0$, we may compute its corresponding rollout solution $\Tilde{u}^1$ through the sequence of minimization \eqref{eq:rollout_mixed_int_0}-\eqref{eq:rollout_mixed_int_end} with $\Tilde{u}^0$ and $\Tilde{u}^1$ in place of $\Bar{u}$ and $\Tilde{u}$, which is equivalent to the rollout scheme applied to its equivalent optimal control problem. Then the repeated application of rollout also applies. In particular, treating the current solution $\Tilde{u}^i$ as the base solution, we can obtain the corresponding rollout solution $\Tilde{u}^{i+1}$ through similar computations.  

\subsection{Additional Variants of the Rollout Scheme}\label{app:d}

First, from the description of the scheme, it is clear that we can change the order in which the elements of $u$ are optimized. The validity of our scheme, as well as the corresponding performance guarantees stated in Prop.~\ref{prop:rollout_mixed_int} remains intact. For example, we can reverse the order and start by computing $\Tilde{u}_{N-1}$ with other elements fixed at $\Bar{u}_k$, $k=0,\dots,N-2$, and proceed backward.


Moreover, assume that after obtaining $\Tilde{u}_{k-1}$, the computational budget runs out. Then the tentative best solution $(\Tilde{u}_0,\dots,\Tilde{u}_{k-1},\Bar{u}_k,\dots,\Bar{u}_{N-1})$, which we denote as $\hat{u}^{k-1}$, is feasible in the sense that $\hat{u}^{k-1}\in U$. In addition, for the corresponding optimizer denoted as $\hat{v}^{k-1}$, we have the performance bound
$$G(\Tilde{u},\Tilde{v})\leq G(\hat{u}^{k-1},\hat{v}^{k-1})\leq \min_{(\Bar{u},v)\in \overline{C}}G(\Bar{u},v).$$
Therefore, our scheme has the character of an anytime algorithm. However, in the case where $k\!<\!N$, Newton's step interpretation described in Section~\ref{Section I} is not valid anymore.

\subsection{Sufficient Conditions for the Feasibility of Charging Problem}\label{app:e}
We provide a set of conditions under which a feasible solution can be obtained analytically. Some of the conditions discussed here are restrictive. Still, they may be taken as a starting point for the construction of the base solution.

For the battery parameters, it is natural to assume that 
\begin{align*}
e_{\text{ini}}\geq& e_s+\Bar{P}(\tau_0+d_0),\\
e_f\geq& e_s+\Bar{P}(d_{k-1}+\tau_k+d_k),~\;k=1,\dots,N\!-\!1,\\
e_f\geq& e_s+\Bar{P}\tau_N,
\end{align*}
which means that the initial energy suffices for the trip to the first station, and the fully charged battery can cover the trip connecting two stations.

Similarly, we may expect that the duration of the trips connecting two stations is less than $T_d$, i.e.,
\begin{align*}
\tau_0+d_0\leq& T_d,\\
d_{k-1}+\tau_k+d_k\leq& T_d,~\;k=1,\dots,N\!-\!1,\\
d_{N-1}+\tau_N\leq& T_d.
\end{align*}
When there are limited numbers of $S_k$, the total driving time involving all detours can be no more than $\Bar{T}_d$, i.e.,
\begin{equation}
    \label{eq:sufficient_Td_constraint}
    \sum_{k=0}^{N}\tau_k+\sum_{k=0}^{N-1}2d_k\leq{\bar{T}_d}.
\end{equation}
Regarding the delivery deadline, we may require that
\begin{equation}
    \label{eq:sufficient_deadline}
    \sum_{k=0}^{N-1}\max\Big\{b_k\big(2d_k+p_k+\Bar{t}_k\big), \tilde{b}_k\big(2d_k+T_r\big)\Big\}\leq \Delta T,
\end{equation}
where 
$$\Bar{t}_k=\frac{e_f-e_s}{\min\big\{P_k,P_{\max}\big\}},$$
which is the maximum charging time needed at each station. 

When the above inequalities hold, we obtain a feasible base solution by setting $b_k\!=\!\Tilde{b}_k\!=\!1$ for all $k$. Note that conditions \eqref{eq:sufficient_Td_constraint} and \eqref{eq:sufficient_deadline} are likely to be restrictive, as they imply that constraints \eqref{eq:total_Td_constraint} and \eqref{eq:deadline} are never active. Still, the other conditions stated here may be used for the construction of a feasible base solution.

\subsection{Linearization of Bilinear Constraints}\label{app:f}
The bilinear terms $b_k\Delta e_k$, $k\!=\!0,\dots,N\!-\!1$ appear in the battery dynamics \eqref{eq:battery_energy}. They can be linearized by introducing additional variables $\Delta \hat{e}_k$ with constraints
\begin{align*}
    0\leq&\Delta \hat{e}_k\leq b_k\overline{\delta},\\
    0\leq& \Delta e_k-\Delta\hat{e}_k \leq \overline{\delta}(1-b_k),
\end{align*}
where $\overline{\delta}$ is a large positive constant used to approximate the unboundedness above, as in \eqref{eq:battery_energy}. The bilinear terms $b_kt_k$ appeared in the HoS regulation constraint \eqref{eq:Tr_constraint} and the deadline constraint \eqref{eq:deadline}, as well as the cost \eqref{Eq.14} can be linearized via an identical procedure. See, e.g., \cite[p.~176]{williams2013model} for further discussions.

For the product terms $\Tilde{b}_kb_k$ appeared in \eqref{Eq.2b}, we can introduce binary variables $\hat{b}_k\!\in\!\{0,1\}$ with constraints
$$\hat{b}_k\leq \Tilde{b}_k,\;\hat{b}_k\leq b_k,\;\hat{b}_k\geq \Tilde{b}_k+b_k-1,\quad k\!=\!0,\dots,N\!-\!1.$$
As for the constraints $\bar{b}_k\!=\!b_k\!\lor\!\tilde{b}_k$, they can be described in linear forms as
$$\bar{b}_k\geq \Tilde{b}_k,\;\bar{b}_k\geq b_k,\;\bar{b}_k\leq \Tilde{b}_k+b_k,\quad k\!=\!0,\dots,N\!-\!1.$$

With the above transformation, the mixed integer optimal charging problem becomes one with linear constraints and costs. However, even for the mixed integer linear program, the iterations needed for the exact solution may still grow exponentially with the problem scale. Moreover, if the linear approximation \eqref{eq:charging} for charging process $\Delta e_k$ is replaced by more accurate functions that are nonlinear in $t_k$, such a transformation does not lead to any simplifications. 