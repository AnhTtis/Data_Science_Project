%!TEX root = ../main.tex

\section{SDN-Supported SOME/IP Service Discovery}
\label{sec:concept}
Our concept applies the SDN paradigm to service-oriented in-vehicle communication using the \ac{SOME/IP} protocol.
First, we introduce the \ac{SOME/IP} \ac{SD} mechanism, next our methodology to support automotive \acp{SOA} with \ac{SDN}, and finally cover \ac{SOME/IP} message handling in a controller application.

\subsection{The \acs{SOME/IP} Service Discovery}
\label{subsec:someip}
The AUTOSAR \ac{SOME/IP} protocol~\cite{autosar-someip-22} includes a \acf{SD} protocol~\cite{autosar-someip-sd-22} with an offline-defined endpoint (IP multicast group / UDP port) on each device.
Fig.~\ref{fig:someip_uml} shows a sequence with \ac{SOME/IP} \ac{SD} and service communication.

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{someip_uml.pdf}
    \caption{\acs{SOME/IP} service discovery and communication.}
    \label{fig:someip_uml}
    \vspace{-2pt}
\end{figure}

\ac{SOME/IP} has two message types for service discovery: \codeword{find} to request a service, and \codeword{offer} to announce a service.
Providers send an \codeword{offer} to the \ac{SD} multicast group upon service activation or as a cyclic refresh.
A consumer can initiate a \codeword{find}-request for a service as a \ac{SD} multicast.
Multiple instances of the same service can coexist in a vehicle.
All providers of the requested service respond with an unicast \codeword{offer}.
A \ac{SOME/IP} service identifies with service ID, instance ID, and major/minor version.
The instance ID, major/minor version can be wildcarded in the \codeword{find}-request if any instance of the specified service ID is applicable.

Discovered services can communicate following a publish-subscribe or a request-response model.
For the latter, a consumer requests a data field or method from a provider via unicast each time the data is needed and awaits the response.
In the publish-subscribe model, a consumer subscribes once to a service instance via unicast to be notified repeatedly. 
The provider acknowledges the subscription and communication endpoints are created. 
The provider can then send initial events and thereafter publish updates on-change or periodically.

A \ac{TTL} field is used to limit the lifetime of an \codeword{offer}, \codeword{find}, or \codeword{subscribe}.
To withdraw an offered service or subscription, the message is sent with identical service ID and instance ID, but with the \ac{TTL} set to 0.

\subsection{Architecture of an SDN-Supported Automotive SOA} 
We integrate the \ac{SOME/IP} service management with \ac{SDN}, enabling the SDN controller to gather information about \ac{SOME/IP} services and exploit it for network optimization. 
Fig.~\ref{fig:sdn_concept} gives an architectural overview of the proposed concept.

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth,trim={0.7cm 0.8cm 0.9cm 0.8cm},clip=true]{sdn_concept.pdf}
    \caption{Concept for an SDN-supported automotive SOA. Components in red are added, others remain unaltered.}
    \label{fig:sdn_concept}
    % \vspace{-5pt}
\end{figure}

The network is divided into control plane and data plane following the \ac{SDN} paradigm.
On the data plane, switches connect service providers and consumers and forward packets between endpoints based on their forwarding tables.
The \ac{SDN} controller on the control plane manages the network and the forwarding tables of network devices.

We add a specialized network application to the SDN controller that intercepts all \ac{SOME/IP} \ac{SD} messages and extracts information about the services. 
It stores  this information in three \ac{SD} tables:
(1) A service registry that contains all known service instances and their endpoints.
(2) A find cache stores all open \codeword{find}-requests which the controller can only answer after the service was discovered.
(3) A subscription registry tracks subscriptions and their status (e.g., active or subscription requested) for the publish-subscribe model.

\subsection{Controlling the SOME/IP Service Discovery with SDN}

\begin{table}
    \centering
    \caption{
        Handling SOME/IP service discovery messages on the control plane depending on the state -- \textit{known} when in the service registry, \textit{requested} when in the find cache, and \textit{subscribed} when in the subscription registry.
    }
    \label{tab:message_handling}
    \setlength{\tabcolsep}{3pt}
    \begin{tabularx}{\linewidth}{l l p{0.46\linewidth}}
        \toprule
        Message & State \texttt{\textcolor{CoreBlack}{(X)}} & Reaction \\
        \midrule 
        \multirow{2}{*}{\texttt{\textcolor{CoreBlack}{find(X)}}} & \textit{Known} & respond with \texttt{\textcolor{CoreBlack}{offer}} \\
         & Not \textit{known} & Send \texttt{\textcolor{CoreBlack}{find}} to multicast group \\
        \cmidrule(rl){1-3}
        \multirow{4}{*}{\texttt{\textcolor{CoreBlack}{offer(X)}}} & \textit{Requested} & Update service registry, forward to requester or multicast group \\
         & Not \textit{requested} & Update service registry, forward to multicast group  \\
        \cmidrule(rl){1-3}
        \multirow{3}{*}{\texttt{\textcolor{CoreBlack}{subscribe(X)}}} & \textit{Known} & Update subscription registry, forward to provider \\
         & Not \textit{known} & Send negative acknowledgement \\ % Send subscribe to multicast group \\
        \cmidrule(rl){1-3}
        \multirow{3}{*}{\texttt{\textcolor{CoreBlack}{subscribeAck(X)}}} & \textit{Subscribed} & Update subscription registry, install forwarding,  forward to subscriber \\
         & Not \textit{subscribed} & No handling \\
        \bottomrule
    \end{tabularx}
    % \vspace{-10pt}
\end{table}

Table~\ref{tab:message_handling} shows how the controller application handles \ac{SOME/IP} \ac{SD} messages depending on the state of the three \ac{SD} tables. 
The controller responds directly to \codeword{find} messages for registered services and sends all known instances of a service ID when the instance ID is a wildcard.
If the service instance is not yet known, the \codeword{find} is cached and forwarded to the multicast group.
On \codeword{offer} messages, the controller updates the service registry.
If the \codeword{offer} is sent as a direct reply to a cached \codeword{find} it is forwarded to the requester, otherwise to the multicast group.

All \codeword{subscribe} messages are forwarded to the provider.
If the service is known, they are added to the subscription registry.
When the controller receives a \codeword{subscribeAck} and the subscription is in the table, it installs a forwarding rule.
Then it forwards the message to the subscriber.
For subscriptions that are already active (e.g., in case of multicast), the controller updates existing rules along the path.

Withdrawn offers are updated in the subscription and service registry and forwarded to the multicast group.
Withdrawn subscriptions are updated in the subscription registry and forwarded to the service provider.
Previously installed rules must also be removed or updated in forwarding devices.

These mechanisms are fully transparent towards the endpoints and do not require any changes in the \ac{SOME/IP} \ac{SD} protocol implementation nor the applications 
Introducing a central network controller, however, impacts service discovery performance, since all \ac{SD} messages are forwarded to the controller, which we evaluate in Section~\ref{sec:eval}.

\subsection{Potentials of SDN-Supported Automotive SOA}

Further potentials emerge if the \ac{SDN} controller is aware of the \ac{SOME/IP} \ac{SD} protocol:
\subsubsection{Optimized service discovery}
The controller can automatically install flows and efficiently add new subscribers to multicast flows after receiving a \codeword{subscribeAck} message.
Furthermore, load on the data plane could be reduced by directly forwarding \ac{SD} messages to the known \ac{SOME/IP} endpoints, skipping links between forwarding devices.
With \ac{SDN}, any Ethernet topologies such as rings can be supported for \ac{SOME/IP} services, enabling load balancing and redundancy.

\subsubsection{Seamless service mobility}
The controller can seamlessly reconfigure publishers and subscribers, as they move from one device to another without disrupting communications.
In addition, it can hand over subscriptions from one publisher instance to another instance of the same service if the original publisher fails.
Other reconfiguration mechanisms could improve the robustness of the \ac{IVN}, such as the fast handover in case of a link failure.

\subsubsection{\acl{QoS} enforcement}
The \ac{IVN} has strict QoS requirements with particular real-time capabilities.
In traditional networks, it can be challenging to translate QoS requirements of application layer services onto the underlying link layer.
Already on host devices, preconfigured mapping from network layer QoS options to link layer QoS options is required.
Communicating such requirements to the network can be even more challenging. 
In the proposed approach, the controller can enforce QoS requirements of the subscriber in the network.
In previous work, we have shown how a central controller can configure the \ac{TSN}-scheduling of switches~\cite{hmks-stsnv-23}.

\subsubsection{Discovery protection}
While IVN security is imperative for ensuring vehicle safety, in-vehicle communication protocols and architectures often lack security mechanisms~\cite{mrfm-svcjr-21}.
In the case of \ac{SOME/IP}, end-to-end encryption can be used to protect the message payload. 
However, the discovery of \ac{SOME/IP} services is not protected, and malicious nodes could easily spoof the discovery messages, e.g., to announce conflicting publisher service instances or add additional subscriptions to increase the network load.
The controller can support security mechanisms for \ac{SOME/IP} \ac{SD} to verify the authenticity of discovery messages and control access policies for providers and consumers.
% The discovery of \ac{SOME/IP} services, however, is not protected.
% The controller can support security mechanisms for \ac{SOME/IP} \ac{SD} to verify the authenticity of discovery messages and control access policies for providers and consumers, protecting against malicious nodes spoofing discovery messages.
