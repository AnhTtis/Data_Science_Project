\section{Sionna RT}
Sionna RT is a ray tracing extension for radio propagation modeling that is built on top of Mitsuba~3 \cite{Mitsuba3} and TensorFlow \cite{tensorflow}. Like all of Sionna's components, it is differentiable, runs in a Jupyter notebook, is released under the Apache 2.0 license, and can be easily extended using high-level Python API calls that take full advantage of the available hardware, such as NVIDIA's GPUs. \Glspl{CIR} computed with Sionna RT can be immediately used for link-level simulations \textit{in-lieu} of a stochastic channel model.

\begin{figure}[t!]
    \centering
    \includegraphics[width=\columnwidth]{figures/munich.png}
    \caption{One of Sionna RT's example scenes. Data from \cite{osm}.}
    \label{fig:render_munich}
\end{figure}

Mitsuba~3 is a rendering system for forward and inverse light-transport simulation that makes use of the differentiable just-in-time compiler Dr.Jit \cite{Jakob2020DrJit}.
Sionna RT relies on Mitsuba~3 for the rendering and scene handling, e.g., its XML-file format, as well as the computation of ray intersections with scene primitives, i.e., triangles forming a mesh modeling a surface. The transformations of the polarized field components at each point of interaction between a ray and a scene object, e.g., reflections, are computed in TensorFlow, which is also used to combine the retained paths into (optionally) time-varying \glspl{CIR}. Thanks to TensorFlow's automatic gradient computation, \glspl{CIR} and functions thereof are differentiable with respect to many ray tracing parameters, including material properties, antenna patterns, orientations, and positions.

Scene files for Mitsuba~3 may be created, edited, and exported using the popular open-source 3D content creation suite Blender \cite{blender} and the Mitsuba-Blender add-on \cite{mitsuba-blender}. The Blender-OSM add-on \cite{blender-osm} allows one to rapidly create realistic scenes for almost any place in the world from OpenStreetMap \cite{osm}. In Sionna, scenes and radio propagation paths can be either rendered through the lens of configurable cameras via ray tracing or displayed with an integrated 3D viewer. For more detail on scene creation and rendering, we refer to Sionna's documentation\footnote{\url{https://nvlabs.github.io/sionna/api/rt.html}} and the video tutorial.\footnote{\url{https://youtu.be/7xHLDxUaQ7c}}

\begin{lstlisting}[language=Python, float, caption={Loading, rendering, and 3D preview of scenes in Sionna RT.}, label=lst:load_render, linewidth=245pt, belowskip=-0.8 \baselineskip]
import sionna
from sionna.rt import load_scene, Camera

# Load integrated scene
scene = load_scene(sionna.rt.scene.munich)

# Open 3D preview (only works in Jupyter notebook)
scene.preview()

# Render scene to file from preview viewpoint
scene.render_to_file(camera="preview",
                     filename="scene.png")

# Create new camera with different configuration
my_cam = Camera("my_cam", position=[0,-10,30])
scene.add(my_cam)

# Render scene with new camera
scene.render("my_cam")

# Render scene to file in high resolution
scene.render_to_file(camera="my_cam",
                     filename="scene2.png",
                     resolution=[1920, 1080])
\end{lstlisting}

Sionna RT allows for the definition of arbitrary radio materials which are characterized by their relative permittivity $\varepsilon_r$ and conductivity $\sigma$. Currently, only non-magnetic materials are supported, i.e., $\mu_r=1$. Radio materials can be defined by frequency-dependent functions, similar to the materials defined by the ITU in \cite{itu_p2040}, which are already integrated into Sionna.

An important design decision of Sionna RT is that all transmitters and all receivers in a scene have the same antenna array configurations. For example, all transmitters may be equipped with an $8\times 2$ dual-polarized array, while all receivers have a single cross-polarized antenna. Antenna arrays can be either explicitly modeled, i.e., paths are traced for every antenna element, or modeled synthetically after the ray tracing process by making a plane-wave assumption across the array. The former option is preferable for very large aperture arrays, where the plane-wave assumption does not hold. The latter option is significantly faster, especially in large setups. The antennas of an array can have arbitrary relative positions as well as user-defined and preconfigured radiation patterns.

\subsection{Code Examples}

Listing~\ref{lst:load_render} shows a code snippet that loads one of Sionna's integrated example scenes (line 5).
Once a \texttt{scene} is loaded, it can be visualized and explored within a Jupyter notebook using the \texttt{scene.preview()} function (line 8). A convenient feature is to render the current viewpoint of the preview into a file using \texttt{scene.render\_to\_file()} (line 11). The result is shown in Fig.~\ref{fig:render_munich}. Lines 15--16 show how a new \texttt{Camera} can be configured and added to the scene. By programmatically changing a camera's position and orientation, it is possible to generate images from different viewpoints, for example, as seen by a receiver navigating through the scene. As we will see later, also transmitter and receiver locations, coverage maps, and propagation paths can be easily visualized. 

\begin{figure}[t!]
    \centering
    \includegraphics[width=\columnwidth]{figures/cm_rays.png}
    \caption{Visualization of the coverage map (path gain~[dB]) and ray-traced paths in Sionna RT from Listing~\ref{lst:tx_rx_paths}.}
    \label{fig:paths_vis}
\end{figure}

Listing~\ref{lst:tx_rx_paths} shows how to configure transmitters and receivers prior to computing propagation paths between them. All transmitters and all receivers are equipped with the same antenna arrays which are defined by the \texttt{scene} properties \texttt{scene.tx\_array} (line 30) and \texttt{scene.rx\_array} (line 38), respectively. Antenna arrays are composed of multiple identical antennas. Antennas can have custom or predefined patterns and are either single- or dual-polarized. One may add multiple transmitters and receivers to a scene. Besides a unique name, a position and orientation need to be provided. The latter  is defined by yaw, pitch, and roll angles. Like cameras, transmitters and receivers must be added to a scene (lines 46 and 55). The transmitter in our example is configured to be oriented towards the receiver (line 57). The function \texttt{scene.compute\_paths()} (line 59) executes the ray tracing process and computes propagation paths between all transmitters and receivers. The parameter \texttt{max\_depth} determines the maximum number of interactions between a ray and scene objects. For example, with a \texttt{max\_depth} of one, only \gls{LOS} paths are considered.
When the property \texttt{scene.synthetic\_array} (line 58) is set to \texttt{True}, antenna arrays are explicitly modeled by finding paths between any pair of transmitting and receiving antennas in the scene. Otherwise, arrays are represented by a single antenna located at the center of the array.
Phase shifts related to the relative antenna positions will then be applied based on a plane-wave assumption when the \glspl{CIR} are computed. In line~64, a coverage map is generated which can be visualized together with the paths and radio devices in the preview (line 62). A rendered image is shown in Fig.~\ref{fig:paths_vis}.

\begin{lstlisting}[language=Python, float, caption={Configuration of radio devices, path and coverage map computation, and visualization in Sionna RT.}, label=lst:tx_rx_paths, firstnumber=26, belowskip=-0.8 \baselineskip]
from sionna.rt import Transmitter, Receiver, \
                      PlanarArray

# Configure antenna array for all transmitters
scene.tx_array = PlanarArray(num_rows=8,
                             num_cols=2,
                             vertical_spacing=0.7,
                             horizontal_spacing=0.5,
                             pattern="tr38901",
                             polarization="VH")

# Configure antenna array for all receivers
scene.rx_array = PlanarArray(num_rows=1,
                             num_cols=1,
                             vertical_spacing=0.5,
                             horizontal_spacing=0.5,
                             pattern="dipole",
                             polarization="cross")

# Create transmitter
tx = Transmitter(name="tx",
                 position=[8.5,21,27],
                 orientation=[0,0,0])
scene.add(tx)

# Create a receiver
rx = Receiver(name="rx",
              position=[45,90,1.5],
              orientation=[0,0,0])
scene.add(rx)

tx.look_at(rx) # TX points towards RX

# Compute propagation paths
scene.synthetic_array = True
paths = scene.compute_paths(max_depth=3)

# Compute coverage map
cm = scene.coverage_map()

# Visualize paths in the 3D preview
scene.preview(paths=paths, coverage_map=cm)
\end{lstlisting}

Once the paths are found, they can be transformed into \glspl{CIR} as shown in Listing~\ref{lst:cir}.
The \texttt{Paths2CIR} class (line 4) can simulate the temporal evolution of the \glspl{CIR} based on arbitrary velocity vectors of all transmitters and receivers. It allows for setting different transmit and receive antenna arrays than those configured in a scene to rapidly simulate multiple configurations without the need to execute the time-consuming path computation. The resulting \glspl{CIR} can then be used for link-level simulations in either time or frequency domains. Seamless end-to-end optimization of transceiver components~\cite{aiai} through the ray-traced channels is also possible.

\begin{lstlisting}[language=Python, float, caption={Generating channel impulse responses in Sionna RT.}, label=lst:cir, belowskip=-0.8 \baselineskip]
from sionna.rt import Paths2CIR

# Configure a Paths2CIR instance
p2c = Paths2CIR(sampling_frequency=1e6,
                tx_velocities = [3,0,0],
                num_time_steps=14,
                scene=scene)

# Transform paths into channel impulse responses
a, tau = p2c(paths.as_tuple())
\end{lstlisting}

\subsection{Current Features \& Planned Extensions}
Sionna RT supports only reflections in its first release. A detailed explanation of the involved computing steps is provided on the Sionna documentation website.\footnote{\url{https://nvlabs.github.io/sionna/em_primer.html}} Reflected paths are computed using the image method \cite{iskander_rt} by either exhaustive search, which does neither scale to large scenes nor to high reflection orders, or by a stochastic method. The stochastic method shoots a selected number of rays in random directions from the transmitter which then propagate through the scene until the maximum number of reflections has been reached. For each resulting candidate path, i.e., an ordered list of scene primitives, the image method is applied to find specular paths that follow the identical list of primitives and arrive at the exact receiver location. Duplicate paths are removed and a possible \gls{LOS} path is added.

For future releases, it is planned to add refraction, diffraction, scattering, as well as support for \glspl{RIS} while still ensuring differentiability of all involved processing steps.
