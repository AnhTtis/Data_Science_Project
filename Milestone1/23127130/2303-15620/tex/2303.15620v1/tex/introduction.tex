
\section{Introduction}\label{sec:introduction}
\subsection{Motivation}
For legged robots to successfully navigate in the real world, it's imperative to employ methods to predict the potential occurrence of a fall and, if possible, execute reflexive motions to either prevent the fall from happening or to make the ``landing'' less dangerous, to the robot or its surroundings. The infeasibility of accounting for all potential perturbations and uncertainties while operating autonomously in dynamic environments makes falling almost inevitable. Here, we focus on bipedal robots.

Fall detection and recovery algorithms often consist of two parts: fall detection and reflexive motions. The focus of this paper, however, is solely on fall detection. The objective is to reliably predict potential falls of bipedal robots with sufficient time  to deploy a recovery strategy. Bipedal robots are chosen because their smaller support polygon causes them to be inherently less stable in comparison to robots with more legs. To simplify the fall detection problem while providing a pathway to scale up to more complex dynamic motions and robots, the task of standing with a planar four-link biped is chosen. As our task of interest is standing we define a ``fall' as any link other than the feet coming in contact with the ground  \cite{ref:pratt2006velocity} or if the feet are off the ground . 

\subsection{Background}
In the following, the term falls will be associated with the term faults, which are defined as unacceptable deviations from expected behavior in at least one variable \cite{ref:ISERMANN19827}. Faults can be classified based on their time dependency, location, and underlying causal factors. Temporally, faults can either be abrupt (step-like or rapidly varying), incipient (drift-like or slowly varying), or intermittent (non-continuous). Faults can be caused by either internal or external disturbances and uncertainties \cite{ref:ISERMANN19827,ref:safaeipour2021survey,ref:renner2006instability}. Incipient faults arise from a gradual deviation from the robot's nominal states or assumed environment, while, as the name suggests, abrupt faults typically arise from shoves or unexpected impacts with the environment. Intermittent faults are non-continuous faults. We do not address intermittent faults in this paper.

% \begin{figure
%     \centering
%     \includegraphics[scale=0.6]{img/fall_detection/introduction/fault_time_dependency.png}
%     \caption{Time dependency of Faults\cite{ref:ISERMANN19827}}
%     \label{fig:fault_time_visualize}
% \end{figure}

In general, the states of the robot can be divided into three classes: safe/balanced, falling, and fallen \cite{ref:kalyanakrishnan2011learning}. The safe/balanced states are states where it is possible for the robot to avoid falling while under the influence of its nominal feedback controller. These states are therefore contained in a subset of the viability kernel \cite{ref:wieber2002stability,ref:hohn2009probabilistic,ref:wu2021falling}.
% We assume that all falling states of the robot will eventually progress to fallen states unless a recovery strategy is deployed, and that all fallen states begin as falling states. \eva{check and cite other papers with this assumption as well} 

% Fall detection can be viewed as an anomaly detection problem.  The objective of anomaly detection is to identify data points that significantly deviate from expected patterns\cite{ref:ml_chandola,ref:ml_ruff}. For fall detection, these anomalous or faulty data points are states that have the potential to lead to a fall (falling states) and states where the robot has fallen (fallen states). In general, the states of the robot can be divided into 3 classes safe/balanced, falling, and fallen  \cite{ref:kalyanakrishnan2011learning}. The safe/balanced states are states where it's possible for the robot to avoid falling while under the influence of the running controller. These states are therefore contained in a subset of the viability kernel. The size of this subset depends on the robot and the robustness of the chosen controller. The viability kernel is defined as the set of all states where there exists at least one control input sequence that can prevent the robot from falling. If the appropriate control input sequence is unknown the robot will exist the viability kernel and fall. \cite{ref:wieber2002stability}\cite{ref:hohn2009probabilistic}\cite{ref:wu2021falling}
% % We assume that all falling states of the robot will eventually progress to fallen states unless a recovery strategy is deployed, and that all fallen states begin as falling states. \eva{check and cite other papers with this assumption as well} 

\subsection{Literature Review} 
A fall detection algorithm have been implemented in the commercial bipedal robot, Digit \cite{ref:ar_digit}. However, this does not appear to be the norm. The objective of most bipedal fall detection algorithms found in literature is to reliably and promptly detect all abrupt faults. Incipient faults are not considered.

% However, focusing on abrupt faults does not accomplish the goal of preventing or mitigating the impact of all falls as falls can also be caused by either incipient or intermittent faults. For instance, a fall detection algorithm meant for abrupt faults, might not be able to detect incipient faults 'early' enough due to the crowding phenomenon. \cite{ref:safaeipour2021survey}\cite{ref:Chen2020}.

% for both open and closed loop systems. Note that early detection of faults for closed loop systems is more challenging than open loop systems due to the feedback controller's effort to mitigate the effects of the faults. \cite{ref:ISERMANN19827}. 

Fault detection reliability has been determined using a combination of evaluation terms from the confusion matrix, such as false positive and negative rates \cite{ref:renner2006instability, ref:kalyanakrishnan2011learning,  ref:wu2021falling, ref:subburaman, ref:kim, ref:hohn2009probabilistic, ref:gallego2010continuous,ref:marcolino2013detecting, ref:ruiz2010fall, ref:karssen2009fall}. Thresholds, based on factors such as center of mass height, have been proposed to minimize the percentage of false negative fault declarations in \cite{ref:kalyanakrishnan2011learning}, while the output of the fall detection algorithm is monitored for a certain number of windows ($N_{monitor}$) to reduce the false positive rate in \cite{ref:kalyanakrishnan2011learning,ref:subburaman,ref:khalastchi2015online}. Lead time, defined as the difference between the time of the actual fall and the predicted fall, is used to inform whether or not sufficient time is left for the implementation of recovery/reflexive motions. It is desirable to have a large lead time, however, maximizing lead time can increase false positive rates. The minimum amount of lead time needed depends on the chosen recovery algorithm and the robot's dynamics, as discussed in \cite{ref:renner2006instability,ref:kalyanakrishnan2011learning,ref:wu2021falling,ref:suetani2011nonlinear} 


Fall detection algorithms can either rely on physics-based \cite{ref:amri2018improved,ref:muender,ref:xinjilefu}  or data-based models \cite{ref:kalyanakrishnan2011learning, ref:wu2021falling, ref:subburaman, ref:hohn2009probabilistic, ref:ruiz2010fall,ref:karssen2009fall, ref:marcolino2013detecting}. Physics-based models can suffer from model inaccuracies while data-based models are limited by the amount of data available. For both physics-based and data-based models, the objective is to obtain either a model of the nominal (safe) states and/or of the  faulty (unsafe) states. However, this is not simple. In practice, it is infeasible to quantify all faults that can lead to a fall, and the faulty states in any given trajectory are irregular and rare. Both of these conditions make it nearly impossible to obtain an accurate model of the anomalies. It is also challenging to obtain a model that accounts for all the safe states of the robot. However, due to advances in the machine learning community, data-based algorithms are becoming more common.

Data-driven detection algorithms can be divided into two subsequent parts, feature engineering and the method used for detection. Feature engineering consists of selecting and transforming raw data into features that can differentiate between faulty and normal states.  Even though stability metrics are used to increase the robustness of controllers, they individually are not a sufficient condition for falling \cite{ref:subburaman}. A combination of stability metrics from bipedal control theory, such as the angular momentum about the center of mass $L_{com}$, and kinematic functions, such as the center of mass position, are typically chosen as features \cite{ref:kalyanakrishnan2011learning, ref:wu2021falling, ref:subburaman, ref:hohn2009probabilistic, ref:ruiz2010fall, ref:karssen2009fall, ref:marcolino2013detecting}.

Classification algorithms, such as that used by \cite{ref:kalyanakrishnan2011learning}, attempt to learn a model from labeled training data and then classify a data point into one of the classes based on the learned model. A disadvantage of classification algorithms is that they can output incorrect predictions if the input data is outside the training data parameters (outside distribution). Nearest-neighbor-based algorithms, such as \cite{ref:khalastchi2015online}, assume that normal data exist in highly dense spaces whereas the neighborhood of anomalous data is sparse. However, these algorithms can have high false positives if the normal instances do not exist in sufficiently dense neighborhoods. Threshold-based algorithms, such as \cite{ref:subburaman}, attempt to use a combination of features to derive a threshold that can be used to separate faulty and normal states.



\subsection{Objective of the Paper}

\textbf{For the task of standing} and for given \textbf{upper bounds on the false positive and false negative rates}, our objective is to detect potential falls caused by either \textbf{incipient or abrupt faults} while \textbf{maximizing the lead time}, that is, the time from fault declaration to the robot entering a fallen state. The objective is challenging due to the crowding phenomenon \cite{ref:safaeipour2021survey,ref:Chen2020}, masking effects of the controller as it tries to mitigate deviations from steady state \cite{ref:ISERMANN19827}, and the inverse relationship between lead time and false positive rate. The crowding phenomenon is the similarity between the normal and incipient faulty data which makes it difficult to separate normal data from faulty data \cite{ref:safaeipour2021survey,ref:Chen2020}.

% Given a \textbf{desired upper bound on the false positive and false negative rates}s, our objective is to develop a fall detection algorithm for the \textbf{task of standing} that can detect potential falls in a \textbf{closed-loop system} caused by either \textbf{incipient or abrupt faults} while \textbf{maximizing the lead time}.  Achieving the objective outlined is a challenging task due to the crowding phenomenon, and the inverse relation between escape time and false positive rates.

% An escape time of 0.2s is used as the minimum threshold in this paper. This value is based off of the time that \cite{ref:hohn2009probabilistic, ref:wu2021falling} reflex algorithm needed to operate.

To achieve this objective, we design a nearest-neighbor detection algorithm and  compare its performance to an existing classification-based detection algorithm. A threshold-based method was not chosen for comparison because it is difficult to find simple thresholds for systems as complex as bipedal robots.  

% \begin{itemize}
%     % \item The fall detection method to use (nearest-based algorithm or classification. We show that the nearest neighbor algorithm will perform worse when it comes to incipient faults)
%     \item Vary the training escape time, the number of times to monitor the output of the fall detection method before declaring a fall ($N_{monitor}$), and the amount of data in the window( $N_{window}$). Training escape time is defined as the time when the states in the falling phase start to be labeled as faulty. 
%     \item Explore the advantages and disadvantages of using a clustering or classification based detection algorithm. Note that threshold-based methods are not chosen for comparison due to the fact that it can be challenging to find simple thresholds for complex systems as bipedal robots. 
%     \item Evaluate the performance of the chosen detection method trained on both faults simultaneously or sequentially.
%     % \item Feature selection. We explore using a wrapper and filter based algorithms for feature selection. As expected, the filter based method performs poorly and the wrapper method is time consuming. As a result, given that deep neural networks have been shown to be good at extracting features from raw data, we propose their use in more complex bipedal robots such as Digit. We show that given a simple model, their performance matches that of the SVM classifier \eva{find a better way to say this. Or just get rid of this analysis}
% \end{itemize}

\subsection{Contributions} 
The major contributions of the paper are as follows:
\begin{itemize}
    \item An algorithm that maximizes lead time subject to bounds on false positive and negative rates;
    \item A method of identifying trajectories associated with incipient or abrupt faults;
    \item A way to label the data based on lead time is proposed;
    \item A nearest-neighbor classification-based fall detection algorithm that can detect both incipient and abrupt faults; and    
        \item A comparison of the nearest-neighbor algorithm and a classification algorithm.
\end{itemize}


