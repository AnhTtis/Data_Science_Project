\section{The DefGraspNets Model}
\begin{figure}
\centering
\includegraphics[width=\columnwidth]{figs/network_diagram.png}
\caption{Given a candidate grasp state $X$ consisting of an object mesh $M_o$, gripper mesh $M_g$, and grasp force $F_g$, DefGraspNets generates contact edges $E^C$ and predicts output $Y$ consisting of a stress field $\vec{\sigma}$ and deformation field $\vec{d}$ defined at each node of the object mesh.}
\label{fig:network_diagram}
\vspace{-18pt}
\end{figure}

Here, we explain the GNN structure of DefGraspNets, including the input and output representations.
We detail training data generation in Sec.~\ref{sec:training} and explain how we use DefGraspNets within a grasp planning algorithm in Sec.~\ref{sec:grasp-planning}.

\subsection{Summary of inputs and outputs}
DefGraspNets takes as input a \textit{candidate grasp state} $X = (M_o, M_g, F_g)$ comprising a mesh $M_o$ of a deformable object in its pre-contact state, a mesh $M_g$ of the gripper fingers upon initial contact\footnote{Although $M_g$ comprises two unconnected parts, we refer to it collectively as the ``gripper mesh."}, and a total normal grasp force scalar $F_g$. A mesh is a collection of vertices and undirected edges that connect them. For $M_o$, these vertices and edges form tetrahedral elements that define the volumetric geometry of the object. For $M_g$, the vertices and edges form triangular elements that define the surface geometries of the fingers.

DefGraspNets converts the candidate grasp state $X$ into a multigraph $G$ (Sec.~\ref{sec:multigraph}), mapping the gripper-object contact interactions onto a graph structure. The multigraph is fed into an \emph{Encode-Process-Decode} sequence~\cite{Pfaff2021ICLR,Sanchez020ICML,Battaglia2018arxiv}(Sec.~\ref{sec:encode}). DefGraspNets predicts the stress and deformation $Y = (\vec{\sigma}, \vec{d})$ at steady state, at all vertices of $M_o$ (Fig.~\ref{fig:network_diagram}). Please refer to Sec.~\ref{sec:training} for the formal definitions of these fields. 


\subsection{Multigraph representation}\label{sec:multigraph}
The multigraph representation $G = (V, E^M, E^C)$ has nodes $V$ and undirected edge sets $E^M$ and $E^C$; each edge stores the indices of its two connected nodes. We list their features, and mark those that differ from \cite{Pfaff2021ICLR} with a $\star$ bullet.

\noindent\textbf{Nodes.} The nodes $V$ correspond to the vertices of $M_o$ and $M_g$. Each node $v_i$ has a feature vector consisting of
\begin{itemize}[leftmargin=2ex]
    \item A 3-element one-hot vector for node type (i.e., part of $M_g$, $M_o$ surface, or $M_o$ interior)
    \item The 3D Cartesian position of the node
    \item[{\large$\star$}] A 3D unit vector in the gripper closing direction. This is nonzero only for gripper nodes and informs the network which direction the grippers are closing. 
\end{itemize}


\noindent\textbf{Mesh edges.}
The mesh edges $E^M$ correspond to the edges of $M_o$ and $M_g$. Each mesh edge $e^M_{ij}$ connects nodes $v_i$ and $v_j$ of the same type. Its feature vector consists of
\begin{itemize}[leftmargin=2ex]
    \item The 3D Cartesian displacement vector from $v_i$ to $v_j$
    \item The scalar Euclidean distance between $v_i$ and $v_j$
    \item[{\large$\star$}] The scalar elastic modulus $E$ of the deformable object. This is nonzero only for edges belonging to the object. 

\end{itemize}


\noindent\textbf{Contact edges.}
The contact edges $E^C$ connect object and gripper nodes and are computed based on proximity at initial contact. Each edge $e^C_{ij}$ is formed between a pair of nodes $v_i$ and $v_j$ that have different node types and are closer than hyperparameter $\epsilon$. The edge's feature vector comprises
\begin{itemize}[leftmargin=2ex]
    \item The 3D Cartesian displacement vector from $v_i$ to $v_j$
    \item The scalar Euclidean distance between $v_i$ and $v_j$
    \item[{\large$\star$}] The normalized grasp force $F_g^C$, which is the total grasp force $F_g$ divided by the number of contact edges $|E^C|$. 
    
\end{itemize}

 \subsection{Encoder, processor, \& decoder architectures}\label{sec:encode}
First, all feature vectors associated with the nodes $V$, mesh edges $E^M$, and contact edges $E^C$ are encoded into a common latent space with 3 respective multilayer perceptrons (MLPs). Then, $L$ message-passing blocks with 3 separate MLPs per block sequentially aggregate and process information from adjacent nodes and edges. Finally, a decoder MLP takes the processed nodal features in the latent space and jointly outputs the predicted stress and Cartesian displacement per node in real units ($\units{Pa}$ and $\units{m}$). Full details of the Encode-Process-Decode sequence can be found in \cite{Pfaff2021ICLR}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "root"
%%% End:
