\section{Measurement Methodology}

This section describes the measurement methodology we used to obtain our production FL stack's carbon emissions.

\subsection{End-user Device Resource Measurements}
\label{sec:client-measurement}
The FL software stack has a client runtime that executes on end-user devices for FL training tasks. To enable accurate measurement of compute time, upload, and download duration, we implemented a logger that records the vitals of the FL session, including the country from which the device is connected for the FL training, the model of the device, model download time, model upload time, and total duration of a single FL session. We use this information for power measurements of the devices. 

The logger records events happening on the production FL client runtime. The logger is based on a generic logging system used widely in our production client runtimes and has minimal resource footprint. The generic logging system guarantees that the events are defined, created, and processed consistently across all the apps and services. The logger runs in parallel with an FL session. The downstream of the logger is a server-side database to store the logs sent from the client runtime logger. 

\paragraph{Device training requirements.} 
It is a common practice in cross-device FL that training only takes place when the device is idle, charging, connected to an unmetered network (typically, Wi-Fi) \cite{fl_open_problems, google_fl, papaya}. 

\paragraph{Accounting for geography.} 
 Since the device is in the charging mode for FL, considering the source of energy for charging results in a more accurate carbon footprint estimate. To this end, we also consider the country where an end user connects from when the device is charging, since different countries have different carbon intensities. Carbon intensity reflects the amount of CO$_2$ emitted per unit of energy. We obtained country-level carbon intensities using the most recent reported year, e.g., 2020 or 2021, by Our World in Data~\cite{e2c_numbers}.

\paragraph{Optimization with regards to geography or heterogeneity.} 
One direction for reducing carbon impact of FL is to optimize carbon and performance with regards to the heterogeneity of clients (e.g., run more on clients with better power profile), or optimizing with respect to the carbon intensity of their location (e.g., run more on clients whose location has greener power source). These optimization strategies, although promising, may introduce bias and amplify unfairness due to the fact that clients with good energy profiles or with greener energy sources are underrepresented in the Global South. We encourage the community to study this direction further.

\paragraph{Power profile of phones.}
We acknowledge that power estimation of phones has been notoriously difficult \cite{oliner2013carat, couto2015greendroid}. Several methods exist to get the compute and communication power of end-user devices. One may try to approximate the power consumption of phones based on modeling different components, e.g., Wi-Fi units and TCP/IP layers~\cite{xiao2013modeling}, although these models may not be accurate. Another approach is to estimate the power drainage by looking at the phone's battery level over time. This method is a coarse-grained and noisy proxy to power consumption, as the battery life also depends on factors such as the age of the battery and ambient temperature. Moreover, the battery drain may differ for the same app usage across devices. Recent studies use collaborative methods for more accurate power measurements \cite{almeida2021smart, bustamante2022batterylab}. In this study, the main challenge for power estimation is the {\em diversity of devices} (see below). To address this challenge, we use Android phone's \emph{power profile}. The power profile is an XML file (typically named \verb|power_profile.xml|) that Android device manufacturers must provide to specify parameters of different electronic components and the approximate battery drainage caused by these components over time~\cite{android-power-profile}. This is the method we adopt as it provides accurate data for phone power consumption based on manufacturer information.

\paragraph{Diversity of Android devices.}
There are more than tens of thousands of distinct Android device models (also observed in \cite{wu2019machine, linkedin-fl}), and obtaining the power estimates for every device model that participated in our experiments would not be feasible. We instead focus on a subset of representative mobile phones---210 most commonly seen Android phones in the language modeling FL task in production. These devices represent more than 20\% of the total devices participating in the FL task in production. The power estimates for different components of these phones are measured by their manufacturers and are available from several sources~\cite{gh-pp-1, gh-pp-2, gh-pp-3, gh-pp-4}. %Obtaining the 20\% coverage, though may seem small, involves significant work and it is more than other efforts.

We extract from \verb|power_profile.xml| the power consumption of the CPU and Wi-Fi components. In \papaya FL training of a language model is done on device CPU at present. (GPU support by PyTorch Mobile is largely limited to inference.) The listing below illustrates a snippet of a \texttt{power\_profile.xml} for Google Pixel 7.
{\scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<device name="Android">
    ... [text] ...
    <item name="screen.on">98</item>
    <item name="screen.full">470</item>
    <item name="modem.controller.sleep">2.5</item>
    <item name="modem.controller.idle">4.5</item>
    <item name="modem.controller.rx">169</item>
    ... [more text] ...
</device>
\end{verbatim}}

% sampe is here: https://android.googlesource.com/platform/frameworks/base/+/master/core/res/res/xml/power_profile.xml. Can include later, when paper is accepted



We impute values for phones with missing \verb|power_profile.xml| files using corresponding numbers from devices with the same SoC or similar phones with comparable characteristics. 

\paragraph{Wi-Fi Power.}
From the \verb|power_profile.xml| file, we use the fields \verb|wifi.active|, \verb|wifi.controller.rx|, \verb|wifi.controller.tx|, and \\
\verb|wifi.controller.voltage| to determine the communication power of the Wi-Fi, as these fields report the current and voltage when transmitting or receiving data \cite{android-power-values}. The receiving power of an end-user phone would be
\begin{equation*}
\label{eq:wifi-power}
    P_{\text{user\_rx}} = (I_{wa} + I_{wrx})\times V_{w}~,
\end{equation*}
where $I_{wa}$, $I_{wrx}$, $V_{w}$ denote \verb|wifi.active|, \verb|wifi.controller.rx|, and \verb|wifi.controller.voltage|, respectively. The transmission power is computed similarly with \verb|wifi.controller.tx| as $P_{\text{user\_tx}} = (I_{wa} + I_{wtx})\times V_{w}$.

\paragraph{CPU Power.}
For estimating the CPU power of phones, we need to know the compute resource pattern of the language modeling task on the phones. We did a field study on a few phones running the FL language modeling task for this. We used the Perfetto tool for profiling and analyzing the resource usage trace and confirmed that the FL task runs when the device is idle, and it runs on the ``big'' cluster of the CPU. The following is a representative example. Google Pixel~3 based on the  Qualcomm SDM845 Snapdragon 845 SoC has two CPU clusters: a ``small'' cluster with four 1.8~GHz Kryo 385 cores for efficiency and a ``big'' cluster with four 2.8~GHz Kryo 385 cores for performance. Figure~\ref{fig:cpu-full} shows a snapshot of the 8 cores of the phone when running an FL task. Cores of the big cluster (cores 4 through 7) are running the FL task and are at the maximum frequency of 2.8GHz. Figure~\ref{fig:cpu-idle} confirms that when the phone is idle, the big cluster is idle and running at a lower frequency of 0.8GHz. 

\begin{figure}[t]
\centering
\includegraphics[width=1\columnwidth]{figures/cpufull.jpeg}
\vspace{-0.25cm}
\caption{A snapshot of the 8 cores of the phone when running an FL task. Cores of the big cluster (CPUs 4 through 7) are running the FL task and are at the maximum frequency of 2.8GHz.}
\label{fig:cpu-full}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=1\columnwidth]{figures/cpuidle.jpg}
\vspace{-0.25cm}
\caption{A snapshot of the 8 cores of the phone when it is idle. The cores of the big cluster are idle.}
\label{fig:cpu-idle}
\end{figure}

The \verb|power_profile.xml| file has currents for all CPU clusters running at different frequencies. We find the total current by adding these values (concretely, \verb|cpu.cluster_power.cluster|,\\ \verb|cpu.active|, and \verb|cpu.core_power.cluster|) corresponding to the highest frequency belonging to the ``big'' cluster. Hence for FL training on the device, the current for CPU is the addition of the values in these 3 fields. We use Watt's law to convert current to power and assume that the phones operate at 3.8V~\cite{phone-voltage}. 

By multiplying the power and the FL session duration obtained from the logger -- namely upload time, download time, and processing time -- we can get the energy consumption for an FL session on a phone. We additionally confirm that the values resulting from this methodology are consistent with those reported in previous studies~\cite{wu2022sustainable, halpern2016mobile, kim2020autoscale}. Our methodology also accounts for the clients that drop out or time out during training, as their session information is reported in the logger.
% and less than of the phone's thermal design power (TDP).

% We want a way to group devices into tiers of performance for the purpose of this study. There are some ways to categorize the Android devices. One could categorize them based on canonical metadata, such as the year they have been released or the manufacturer. Or one could categorize them based on performance-related metrics. We found that categorizing based on performance-related metrics is more relevant for our measurement study. We followed the best practices and used device RAM as a way to categorize devices into different tiers. 

\subsection{Server Resource Measurements}

% Most of the computation in FL is offloaded to the end-user devices, so it is expected that the carbon footprint of the server will be small compared to that of the clients. We verified this claim in the result. Nevertheless, we measured server carbon footprint of an FL task as follows.

We measure the carbon footprint of the server as follows. There are three main server components in the \papaya stack: Aggregator, Coordinator, and Selector. The most power-intensive computations happen in the Aggregator and Selector, while the Coordinator is responsible for matching FL tasks to clients and Aggregators and orchestration. To ensure accurate measurements of power consumption, we monitored the physical servers that run the FL task (Aggregator and Selector). We describe our methodology for measuring the carbon footprint of an individual task on these servers.

\paragraph{Aggregator.} To accurately estimate the carbon footprint of a single task on the physical servers, we measure the CPU utilization of the Aggregator during the execution of the language modeling FL task. We use the CPU utilization as a proxy for the power consumption specifically attributable to the FL task being executed on the server.

We consider the periods where the Aggregator runs only the language modeling FL task. First, we identify the Aggregator that runs a particular FL task. Next, we select a ``{\em stable}'' period when there is no failure, and the Aggregator is relatively underloaded. It is important to consider this period since the Coordinator reassigns FL tasks when it detects failed or overloaded Aggregators~\cite{papaya}, hence tracking an FL task would not be feasible. We observe that utilization of the Aggregator for the language modeling FL task is less than $1\%$, which also includes background processes. To get a conservative upper bound, we assume that server utilization is $1\%$ for the FL task. (Looking ahead, small errors in the estimate of the server utilization have a negligible impact on the results due to the small footprint of the server compute.)

Knowing the hardware specification of the physical servers running Aggregator, at $1\%$ utilization, we measured Aggregator's power consumption for running the language modeling FL task at $45$W. 
We multiply this number by the Power Usage Effectiveness (PUE) of our datacenters, 1.09, which accounts for the additional energy required to support the datacenter infrastructure (mainly cooling)~\cite{meta-pue}. 

%if anonymous submission: 1.XX (number redacted for anonymity). 

Load balancing and other techniques of \papaya may impact where the Aggregator and Selector run. However, for this study, we assume they run uniformly across different datacenters.  
We use the weighted average carbon intensity model to account for the carbon intensity of different Meta datacenters that reside in different locations and regions \cite{meta-datacenters}. We obtain the weighted average of the carbon intensities of the countries where Meta datacenters are located, and the weight is the number of datacenters in that country. 

\paragraph{Selector.} Since most of the processing happens in the Aggregator, the Aggregator's carbon footprint dominates that of the Selector. We conservatively assume the same carbon footprint value for the Selector as for the Aggregator.

\subsection{Networking Infrastructure Resource Measurements}

For the networking and infrastructure resources, we adopt the standard methodology that considers all hardware assets on the path between the end-user and the FL server, namely, access, metro, edge, and core networks~\cite{vishwanath2015energy, baliga2010green, jalali2014energy, wu2022sustainable}. The access network is the first network user connects to, and it typically includes ADSL Ethernet, Wi-Fi access point, or 3G/4G/5G access point. The metro and edge network aggregate traffic from several users' access points, regulate access and usage, and represent the gateway to the global Internet, which consists of an edge Ethernet switch, broadband network gateways (BNGs), and edge routers \cite{vishwanath2015energy}. The core network, consisting of core routers, is the backbone of the Internet, connecting the metro and edge network to the datacenter. Schematically for cross-device FL we can have: client $\rightarrow$ Wi-Fi access point $\rightarrow$ edge Ethernet switch $\rightarrow$ BNG $\rightarrow$ edge routers $\rightarrow$ core routers $\rightarrow$ edge routers $\rightarrow$ data center Ethernet switch $\rightarrow$ data center.

In this setting, power consumption of the networking infrastructure connecting the end-user to the FL server in the datacenter can be obtained using the energy-per-bit model, as \cite{jalali2014energy, vishwanath2015energy}:
\begin{equation*}
    P_{\text{network}} = (E_a+E_{\text{as}}+E_{\text{bng}}+n_eE_e+n_cE_c+E_{\text{ds}})\times B,
\end{equation*} where $B$ is the bandwidth usage of the FL session, $n_e$ is the number of edge routers, $n_c$ is the number of core routers, and $E_a, E_{\text{as}}, E_{\text{bng}}$, $E_e, E_c, E_{\text{ds}}$ denote the energy per bit of the Wi-Fi access point, the edge Ethernet switch, the BNG, an edge router, a core router, and data center Ethernet switch respectively \cite{vishwanath2015energy}. We adopt constants from Vishwanath et al. \cite{vishwanath2015energy}. The bandwidth usage of the session, $B$, can be calculated using the model size divided by the upload or the download time.