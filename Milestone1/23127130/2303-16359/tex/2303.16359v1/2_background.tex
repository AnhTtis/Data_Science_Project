% !TEX root =  main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Setup and Definitions}\label{sec:notation}
In this section, we formalize our objective and introduce important technical definitions.

% \vspace{-1mm}
\subsection{Problem Setup}\label{sec:notation.setup}
% \vspace{-1mm}

% \subsubsection{Task space.} 
\looseness-1\textbf{Task space.} We define the space of tasks as~\taskspace. A task $T \in \taskspace$ consists of a visual puzzle and a set of available types of code blocks (e.g.,~\DSLMove,~\DSLRepeatUntil) allowed in the solution code.
Additionally, the solution code must be within a certain size threshold in terms of the number of code blocks. We denote the current task that a student is solving as $T^\text{in} \in \taskspace$; see $T^\text{in}$ in Fig.~\ref{fig:intro}. In this work, we use tasks from \emph{Hour of Code: Maze Challenge}~\cite{hourofcode_maze} by Code.org~\cite{codeorg} and \emph{Intro to Programming with Karel}~\cite{intro_to_karel_codehs} by CodeHS.com~\cite{codehscom}; henceforth, we refer to them as HOC and Karel tasks, respectively.



% \vspace{1mm}
\looseness-1\textbf{Code space.} We define the space of all possible codes as \codespace~and represent them using a \emph{Domain Specific Language }(DSL)~\cite{gulwani2017program}. In particular, for codes relevant for HOC and Karel tasks, we use a DSL based on~\cite{DBLP:conf/nips/AhmedCEFGRS20}.
A code $C \in \codespace$ has the following attributes: $C_\text{blocks}$ is the set of types of code blocks used in $C$, $C_\text{size}$ is the number of blocks used, and $C_\text{depth}$ is the depth of the \emph{Abstract Syntax Tree} of $C$. We denote a distance metric in this space as $D_\codespace$. For a given $C \in \codespace$ and a positive integer $l$, we define a neighborhood function as $\mathcal{N}_\codespace(C,l) = \{ C'~| ~D_\codespace(C', C) \leq l\}$. The solution code $\solutioncode \in \codespace$ for the task $T^\text{in}$ solves the visual puzzle using the allowed types of code blocks within the specified size threshold. A student attempt for $T^\text{in}$ is denoted as~$\studentcode \in \codespace$.



% \vspace{1mm}
\looseness-1\textbf{Objective.} For an input task $T^\text{in}$ with solution code \solutioncode~and given the current student attempt \studentcode, our objective is to generate a pop quiz in form of a new task-code pair $(T^\text{quiz}, C^\text{quiz})$ designed on the basis of the following features: (i) \emph{Adaptive}, i.e., $C^\text{quiz}$ accounts for \solutioncode~and \studentcode, ensuring that $C^\text{quiz}$ is individualized to the student's current attempt; (ii) \emph{Comprehensible}, i.e., $C^\text{quiz}$ solves $T^\text{quiz}$ correctly and the pop quiz is easy to comprehend/solve without confusing the student; (iii) \emph{Concealing}, i.e., $D_\codespace(C^\text{quiz},\solutioncode)$ is high, ensuring that $C^\text{quiz}$ sufficiently conceals the solution code \solutioncode{} and does not directly reveal it in order to encourage problem-solving aspects.


% \vspace{-1mm}
\subsection{Technical Definitions}
 \label{sec:notation.definitions}
% \vspace{-1mm}

% \vspace{1mm}
\looseness-1\textbf{Sketch space.} We capture the key conceptual elements of a code using a higher level abstraction called a \textit{sketch}~\cite{DBLP:conf/aaai/SinghGR12,DBLP:conf/ijcai/AhmedGK13}. The sketch of a code preserves its important programming constructs. Similar to the code DSL, we define the sketch space~\sketchspace{} using a sketch DSL based on~\cite{DBLP:conf/nips/AhmedCEFGRS20}. 
Similar to the \emph{Abstract Syntax Tree} representation of a code, we represent a sketch as a tree having the programming constructs as its nodes. The mapping from the code space to the sketch space is captured by the many-to-one map, $\sketchmap\colon \codespace \rightarrow \sketchspace$, i.e., the representation of a code $C$ in \sketchspace~is given by \sketchmap($C$). As \sketchspace~is an abstraction of \codespace, multiple elements of \codespace~can correspond to a single element in~\sketchspace. Similar to $D_\codespace$ and $\mathcal{N}_\codespace$, we denote a distance metric in the sketch space as $D_\sketchspace$ and a neighborhood function as $\mathcal{N}_\sketchspace(S,l) = \{ S'~|~D_\sketchspace(S', S) \leq l\}$ for a given $S \in \sketchspace$ and a positive integer $l$.


% \vspace{1mm}
\looseness-1\textbf{Sketch substructures.} For a sketch $S$, we define a substructure as a sub-tree containing the nodes of $S$ up to a particular depth and sharing the same root node; note that a substructure of a sketch is also a sketch. We denote the set of all substructures of $S$ as $\substructures(S) \subseteq \sketchspace$; the size of the set $\substructures(S)$ is typically small.
%
For example, the sketch shown in Fig.~\ref{fig:pipeline.solsketch} has the following $4$ substructures: (i) \begin{small}{\{\DSLRun{}\}}\end{small}, (ii) \begin{small}{\{\DSLRun\{\DSLRepeatUntil{}(\DSLBoolGoal){}\}\}}\end{small}, (iii) \begin{small}{\{\DSLRun\{\DSLRepeatUntil{}(\DSLBoolGoal)\{\DSLIfElse(\SDSLBool){}\}\}\}}\end{small}, and (iv) \begin{small}{\{\DSLRun\{\DSLRepeatUntil{}(\DSLBoolGoal)\{\DSLIfElse(\SDSLBool)\{\{\}; \{\DSLIfElse(\SDSLBool){}\}\}\}\}\}}\end{small}. 



% \vspace{1mm}
\looseness-1\textbf{Code reductions.} For a code $C \in \codespace$ with sketch $S := \sketchmap(C)$, consider one of the sketches $S_\text{sub} \in \substructures(S)$. We define the set of code reductions of $C$ w.r.t. sketch $S_\text{sub}$ as all codes obtained by removing one or more nodes of $C$ while preserving the sketch $S_\text{sub}$; note that the reduction of a code is also a code.  We denote the set of all reductions as $\reducedcodes(C~|~S_\text{sub}) \subseteq \codespace$. 
For example, for \solutioncode~in Fig.~\ref{fig:intro} and \begin{small}$S_\text{sub} = \{\DSLRun\{\DSLRepeatUntil($\DSLBoolGoal{}$)\}\}$\end{small}, the set  $\reducedcodes(\solutioncode|~S_\text{sub})$ has the following $3$ codes: (i) \begin{small}{\{\DSLRun\{\DSLRepeatUntil{}(\DSLBoolGoal)\{\DSLMove{}\}\}\}}\end{small}, (ii) \begin{small}{\{\DSLRun{}\{\DSLRepeatUntil{}(\DSLBoolGoal)\{\DSLTurnRight{}\}\}\}}\end{small}, and (iii) \begin{small}\{\DSLRun{}\{\DSLRepeatUntil{}(\DSLBoolGoal)\{\DSLTurnLeft{}\}\}\}\end{small}.






