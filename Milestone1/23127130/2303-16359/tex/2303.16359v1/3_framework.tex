% !TEX root =  main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Our Algorithm \algmultihop} \label{sec:model}
In this section, we present our algorithm that generates pop quizzes via synthesizing new tasks. One might be tempted to synthesize tasks by first generating a new visual puzzle and then obtaining its solution code. As discussed in Section~\ref{sec:intro} and shown in~\cite{DBLP:conf/nips/AhmedCEFGRS20}, the mapping from the space of visual tasks to their solution codes is highly discontinuous and reasoning about desirable tasks directly in the task space is ineffective. 
However, the task synthesis algorithm from~\cite{DBLP:conf/nips/AhmedCEFGRS20} is not applicable to our work as we seek to generate tasks that also account for the student's current attempt. 
To this end, we develop a novel algorithm \algmultihop~(\emph{Programming Pop Quizzes via Synthesis}) that generates tasks adaptive to the student's current attempt. Our algorithm operates in three stages: (i) Stage 1 generates a sketch based on the task's solution code and the student's current attempt; (ii) Stage 2 instantiates this sketch in the form of a new task-code pair; (iii) Stage 3 generates the pop quiz from the new task-code pair. Fig.~\ref{fig:pipeline.abstract} illustrates these stages, and details are provided below. 
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Input figure here
\input{./fig/fig-approach_20220131}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \vspace{-1mm}
\subsection{Stage 1: Generating the Pop Quiz Sketch $S^\text{quiz}$}\label{sec:model.stage1}
% \vspace{-1mm}


\looseness-1We begin by describing Stage 1 of our algorithm as illustrated in Fig.~\ref{fig:pipeline.abstract}. In this stage, \hintpolicy{} routine returns a suitable sketch $S^\text{quiz}$ that is instantiated in the later stages. The input to the routine is the student sketch $S^{\text{in,stu}} := \sketchmap(\studentcode)$ and solution sketch $S^{\text{in,}\star} := \sketchmap(\solutioncode)$. By operating on the sketch space first, we can generate meaningful and adaptive codes in the later stages.
%
To generate pop quizzes based on the features mentioned in Section~\ref{sec:notation.setup}, we require the sketch of the pop quiz $S^\text{quiz}$ to have the following attributes: (i) $S^\text{quiz}$ should direct the student towards the solution sketch $S^{\text{in,}\star}$, i.e., $D_\sketchspace(S^\text{quiz}, S^{\text{in,}\star})$ should be low; (ii) $S^\text{quiz}$ should be adaptive w.r.t. the student's sketch $S^\text{in,stu}$, i.e., $S^\text{quiz} \in \mathcal{N}_\sketchspace(S^\text{in,stu},l)$ for a low value of $l$. While these conditions ensure that $S^\text{quiz}$ directs the student towards the solution sketch and is adaptive, it could potentially lead to a sketch that does not belong to the set of substructures of the solution sketch, i.e., $S^\text{quiz} \notin \substructures(S^{\text{in,}\star})$---in that case, there is no valid code reduction of \solutioncode~w.r.t. $S^\text{quiz}$ (see Section~\ref{sec:notation.definitions}) and this makes it challenging to instantiate sketches into desirable codes $C^\text{quiz}$ (see algorithm variant \alghintpolicystruct~in Section~\ref{sec:surveystudy} and Footnote~\ref{footnote:sec3}).
%
Hence, \hintpolicy~generates $S^\text{quiz}$ as follows (see Fig.~\ref{fig.approach.algmultihop}):
\begin{enumerate}[(i)]
    \item Pick $\hat{l}$ as $\min l \in \{1,2,\ldots\}$ s.t. $\mathcal{N}_\sketchspace(S^\text{in,stu},~l) \cap \substructures(S^{\text{in,}\star})$ is non-empty.
    %
    \item Generate $S^\text{quiz} \in \argmin_{S \in \mathcal{N}_\sketchspace(S^\text{in,stu}, ~\hat{l}) ~\cap~ \substructures(S^{\text{in,}\star})} D_\sketchspace(S, S^{\text{in,}\star})$.    
%
\end{enumerate}

% \vspace{-4mm}
\subsection{Stage 2: Synthesizing $(T^\text{quiz}, C^\text{quiz})$ from $S^\text{quiz}$}\label{sec:model.stage2}
% \vspace{-1mm}


\looseness-1Next, we describe Stage 2 of our algorithm. We first generate $C^\text{quiz}$ from $S^\text{quiz}$, as illustrated in Stage 2(i) of Fig.~\ref{fig:pipeline.abstract}. Specifically, for a sketch $S^\text{quiz}$ generated in Stage 1, 
we employ the \emph{code mutation} methodology proposed in~\cite{DBLP:conf/nips/AhmedCEFGRS20} to obtain a code $C^\text{quiz}$. However, this methodology requires a meaningful starting code $C^\text{seed}$. Since $S^\text{quiz} \in \substructures(S^{\text{in,}\star})$ by the design of Stage 1, we begin by picking $C^\text{seed}$ from the set \reducedcodes($\solutioncode|~S^\text{quiz}$).\footnote{When $S^\text{quiz} \notin \substructures(S^{\text{in,}\star})$, we set $C^\text{seed}$ as a random instantiation of $S^\text{quiz}$ -- see algorithm variant \alghintpolicystruct~in Section~\ref{sec:surveystudy}.\label{footnote:sec3}}
%
The methodology of~\cite{DBLP:conf/nips/AhmedCEFGRS20} provides us multiple code mutations of $C^\text{seed}$. The extent to which these code mutations differ from $C^\text{seed}$ and \solutioncode~is controlled by the constraints imposed based on the values of the boolean variables, conditionals, and action blocks (\begin{small}\DSLMove, \DSLTurnLeft, \DSLTurnRight, \DSLPickMarker, \DSLPutMarker{}\end{small}) of $C^\text{seed}$, as well as constraints on the size of the obtained code. Specifically, these mutations allow us to control the extent to which $D_\codespace(C^\text{quiz},\solutioncode)$ varies, which is a desired feature as stated in Section ~\ref{sec:notation.setup}. 
%

 
\looseness-1Next, we generate a new task $T^\text{quiz}$ from a code $C^\text{quiz}$ as illustrated in Stage 2(ii) of Fig.~\ref{fig:pipeline.abstract}.
Specifically, we generate $T^\text{quiz}$ such that its solution code is $C^\text{quiz}$. We achieve this using techniques of symbolic execution and best-first search, building on the task synthesis methodology presented in~\cite{DBLP:conf/nips/AhmedCEFGRS20}. 
% 

% \vspace{-1mm}
\subsection{Stage 3: Generating Multi-Choice Question from $(T^\text{quiz}, C^\text{quiz})$}
% \vspace{-1mm}
%
\looseness-1In this stage, we generate a pop quiz with a fixed set of answer choices; see Figs.~\ref{fig:intro}~and~\ref{fig:karel.illustration}. We pick a task-code pair $(T^\text{quiz}, C^\text{quiz})$, and expose only a part of $C^\text{quiz}$ determined by an exposure parameter $k$, i.e., $C^\text{quiz}$~contains $k$ blanks. These blanks must be filled out by the student from the set of answer choices in a manner that would solve $T^\text{quiz}$.
% 
Specifically, we generate the pop quiz with $\exposureparam = 1$ blanks. To obtain the blank for the quiz, we do an in-order traversal of $C^\text{quiz}$ and leave out the last leaf node as blank.
% 

