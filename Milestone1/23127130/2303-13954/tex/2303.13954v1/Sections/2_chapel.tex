%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% File: 2_chapel.tex
% Self-contained tex file for the Chapel overview
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of the Chapel Language}
\label{sec:2_chapel}
Chapel is a high-level language that implements the PGAS model and is designed for productive parallel computing at scale, providing constructs for distributed arrays, remote communication and both data and task parallelism.
In this section we provide a brief overview of Chapel, focusing on the features most relevant to our work.
For a more in-depth description of Chapel, we refer readers to the work by Chamberlain et al.~\cite{chamberlain2007parallel}.

%###############################################################################
\subsection{Terminology: Tasks, Threads and Locales}
\label{sec:2-1_terms}
Chapel enables parallelism through executing multiple \emph{tasks} in parallel, where a task is a set of computations that can conceptually be executed in parallel, but may or may not do so.
Tasks are implemented by a tasking layer, which provides threads on which Chapel tasks are scheduled.
For distributed-memory programming, Chapel introduces the concept of a \emph{locale}, which is defined as a unit of machine resources on which tasks can execute.
In practice, a locale is mapped to an entire compute node in a cluster and the number of locales on which a program runs is specified when launching the program.
Chapel programs initially start with a single task executing on locale 0.
Parallel loops and other constructs then create tasks that can execute across the locales, but ultimately join back to a single task on locale 0 when they are done.
This differs from other PGAS languages, such as UPC~\cite{el2005upc}, which use a single program multiple data (SPMD) model that defines the amount of parallelism at program startup.

%###############################################################################
\subsection{Domains and Arrays}
\label{sec:2-2_domsAndArrays}
Chapel splits an array into two first-class objects in the language: a \emph{domain} and the array itself.
A domain is a representation of an index set and can be used to define the indices in an array or the indices iterated over by a loop.
Once defined, a domain can then be used to declare an array.
Modifications to a domain (e.g., adding/removing indices) propagate to all arrays defined over the domain.
Lines 1--2 in Listing~\ref{lst:domains} present a simple example of defining a domain \texttt{D} that has indices 0 through 5 and then declaring an array of integers, \texttt{data}, over that domain.
Of particular relevance to our work is an \emph{associative} domain, which is similar to a dictionary.
Lines 4--7 in Listing~\ref{lst:domains} declare an associative domain \texttt{C} that stores strings and adds the key ``foo'' via the \texttt{+=} operator.
The associative array \texttt{dict} is declared over \texttt{C} and provides a mapping of strings to reals.
Associative domains also provide parallel-safe modifications by default.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code listing for domains, arrays and associative arrays
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{mdframed}[backgroundcolor=black!5,hidealllines=true,%
innerbottommargin=-0.85cm,innertopmargin=-0.10cm]
\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ChplStyle,label={lst:domains}, caption={Chapel domains and arrays},columns=flexible]
var D = {0..5}; // rectangular domain
var data : [D] int;

var C : domain(string); // associative domain
C += "foo";
var dict : [C] real;
dict["foo"] = 2.0;
\end{lstlisting}
\end{minipage}
\end{mdframed}
\vspace{-15pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code listing for distributed domains and arrays
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{mdframed}[backgroundcolor=black!5,hidealllines=true,%
innerbottommargin=-0.85cm,innertopmargin=-0.1cm]
\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ChplStyle,label={lst:dist}, caption={Block distributed domain/array in Chapel},columns=flexible]
var D = newBlockDom({0..15});
var arr : [D] int;

for i in 0..15 {
  arr[i] = here.id;
}
\end{lstlisting}
\end{minipage}
\end{mdframed}

%###############################################################################
The code in Listing \ref{lst:domains} only declares domains and arrays that are located on a single locale.
Our work focuses on \emph{distributed arrays}, whose data is spread across multiple locales according to some distribution policy.
Chapel provides several built-in distribution policies, such as block, cyclic and block-cyclic.
Listing~\ref{lst:dist} shows a simple example of declaring a block-distributed domain and then the corresponding distributed array.
The block distribution will partition the array into contiguous chunks and assign one chunk to each locale.
The underlying distribution implementation automatically handles the index remapping, allowing users to write \texttt{arr[i]} to access the $i^{th}$ element of the array, rather than having to specify which block the index is in.
Furthermore, Chapel performs implicit remote communication, which means that users can access the remote elements of a distributed array in the same way that they would access the local elements.
This can be seen on lines 4--6 in Listing~\ref{lst:dist}, which sets the value of \texttt{arr[i]} to be equal to the ID of the locale where the task is executing (\texttt{here.id}).
The loop will execute all iterations on locale 0, so any access to an element of \texttt{arr} that is not on locale 0 will result in communication.

%###############################################################################
\subsection{Forall Loops}
\label{sec:2-4_parallelLoops}
Chapel provides data parallelism via a \texttt{forall} loop, which allows the loop iterations to be parallelized and distributed across the system.
How the iterations are mapped to cores/locales depends on what the \texttt{forall} loop is iterating over, which is referred to as the \emph{iterand}.
Non-distributed arrays and domains have default \emph{iterators} defined, which partition the iterations into contiguous chunks and assign each chunk to a task.
The tasks then execute concurrently on a single locale.
For distributed arrays and domains, the default iterator provides both shared- and distributed-memory parallelism by executing a given iteration of the loop on the locale where that iteration's data element is mapped.
Consider the example in Listing~\ref{lst:loops}, which iterates over the domain of a distributed array \texttt{arr}.
This loop is similar to the non-parallel loop on lines 4--6 in Listing~\ref{lst:dist}, but it will execute the $i^{th}$ iteration on the locale on which \texttt{arr[i]} is stored.
Therefore, \texttt{here.id} will return the locale ID of where \texttt{arr[i]} is located.
This avoids the remote communication that would occur for the code in Listing~\ref{lst:dist}.
Therefore the iterand of a \texttt{forall} loop implicitly controls where the computation is performed.
We refer to this as controlling the \texttt{forall}'s \emph{locale affinity} and note that it is a feature of Chapel that differs from the more explicit affinity-controlling constructs of languages like UPC.
Furthermore, users can define their own custom iterators to alter the way in which a \texttt{forall} loop is parallelized.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code listing for loops
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{mdframed}[backgroundcolor=black!5,hidealllines=true,%
innerbottommargin=-0.85cm,innertopmargin=-0.10cm]
\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ChplStyle,label={lst:loops}, caption={\texttt{forall} loop in Chapel},columns=flexible]
var D = newBlockDom({0..15});
var arr : [D] int;
forall i in arr.domain {
    arr[i] = here.id;
}
\end{lstlisting}
\end{minipage}
\end{mdframed}


