%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% File: 3_optimization.tex
% Self-contained tex file for the optimization details
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compiler Optimization}
\label{sec:3_optimization}
In this section we describe the design and implementation of the inspector-executor compiler optimization for irregular memory accesses.
We focus specifically on read-only accesses with the form \textbf{A[B[i]]} found inside \texttt{forall} loops, where \textbf{A} and \textbf{B} are arrays and \textbf{A} is a distributed array.
However, we do support more complex non-affine expressions if certain conditions are met (see Section \ref{sec:3-3_static}).
The overall goal of the optimization is to selectively replicate remotely accessed elements of \textbf{A} so that they can be accessed locally during execution of the loop.
Full replication of \textbf{A} can be prohibitively expensive in terms of both memory consumption and communication overhead, but knowing which elements are accessed remotely requires knowledge only revealed when the loop is executed.
This motivates the design of our compiler optimization that creates an inspector to determine at runtime which accesses are remote.

The optimization targets \texttt{forall} loops that execute multiple times, which allows for the cost of the inspector phase to be amortized over multiple executions of the optimized loop (i.e., the executor).
Such patterns are commonly found in sparse iterative solvers~\cite{dongarra2016high}, molecular dynamics simulations~\cite{strout2003compile} and some graph analytics applications~\cite{bianchini2005inside}.
Figure~\ref{fig:compiler} presents a high-level overview of Chapel's compiler passes, where the shaded passes in the dotted box correspond to the passes where the optimization performs static analysis and code transformations.
There are roughly 40 passes in Chapel's compiler to date, but most are omitted in Figure~\ref{fig:compiler} to simplify the diagram.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Compiler flow chart
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[t]
\centering
\includegraphics[trim=0cm 6cm 0cm 0cm, scale=0.32]{Figures/compiler_flow_bw.pdf}
\caption{High-level overview of the Chapel compiler. The shaded passes within the dotted box represent those where our optimization performs code transformations and static analysis.}
\label{fig:compiler}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-level Overview}
\label{sec:3-1_overview}
Our optimization operates solely on Chapel's intermediate representation of the program, which we refer to as the abstract syntax tree (AST).
The optimization process begins during the normalize pass, at which point the AST has not been heavily modified, thus making the code transformation tasks easier to perform.
The optimization considers each \texttt{forall} loop that is present in the program and looks for accesses of the form \textbf{A[B[i]]}.
However, array accesses do not have their own syntax in the AST, meaning that \textbf{A[B[i]]} is represented as a call expression that is indistinguishable from a function call.
To address this issue, an irregular access candidate expression is replaced with a compiler primitive that will be acted on during the resolve pass, at which point the optimization can determine whether \textbf{A} and \textbf{B} are arrays.
If a \texttt{forall} loop has a candidate access, the optimization  clones the \texttt{forall} into the inspector and executor loops.

During the resolve pass of compilation, function calls and types are resolved, which allows the optimization to carry out much of the necessary static analysis to ensure the validity of the code transformations performed during the normalize pass.
If anything is found to invalidate the optimization then the code transformations are removed and replaced with the original \texttt{forall} loop.
Otherwise, the primitive that represents \textbf{A[B[i]]} is replaced with a library call to either ``inspect'' or ``execute'' the access, depending on whether the primitive is in the inspector or executor loop.
Determining which accesses are remote is performed at runtime via the inspector.
The static analysis performed by the optimization only determines that the access is of the form \textbf{A[B[i]]} and that \textbf{A} is a distributed array.

Finally, at the end of the cull-over references pass, the optimization performs the remaining analysis necessary to ensure the transformations are valid, which focuses on locating modifications (writes) to the relevant arrays and domains for the irregular accesses in the loop.
Such writes can change the \textbf{A[B[i]]} access pattern, which would require the inspector runtime analysis to be rerun to ensure that the executor has the correct elements replicated.
The cull-over references pass resolves the \emph{intents} of function arguments, where an argument's intent refers to whether it is passed by value or reference.
This pass statically sets the intent of the argument to different values depending on whether the procedure reads or writes to the argument.
Writes to arrays are performed via Chapel procedure calls where the array is passed in as an argument, which allows the optimization to check the intent of the array to determine whether it is written to.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code Transformations}
\label{sec:3-2_codeGen}
Listing~\ref{lst:codegen} presents code that is functionally equivalent to the output from our optimization's AST-level transformations when applied to the program in Listing~\ref{lst:ex}. 
We next describe the details of the code transformations and how they support selective data replication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code listing for example forall loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{mdframed}[backgroundcolor=black!5,hidealllines=true,%
innerbottommargin=-0.75cm,innertopmargin=-0.10cm]
\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ChplStyle,label={lst:ex}, caption={Example \texttt{forall} loop with an irregular memory access pattern},columns=flexible]
forall i in B.domain {
  C[i] = A[B[i]];
}
\end{lstlisting}
\end{minipage}
\end{mdframed}
\vspace{-10pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code listing for code-generated loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{mdframed}[backgroundcolor=black!5,hidealllines=true,%
innerbottommargin=-1.1cm,innertopmargin=-0.10cm]
\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ChplStyle,label={lst:codegen}, caption={Output of code transformations performed by the optimization for the code in Listing~\ref{lst:ex}},columns=flexible]
if doInspector(A, B) {
  inspectorPreamble(A);
  forall i in inspectorIterator(B.domain) {
    inspectAccess(A, B[i]);
  }
  inspectorOff(A,B);
}
executorPreamble(A);
forall i in B.domain {
  C[i] = executeAccess(A, B[i]);
}
\end{lstlisting}
\end{minipage}
\end{mdframed}

\textbf{Internal Chapel Data Structures:}
For a distributed array \textbf{A} in a \texttt{forall} loop that is being optimized, we add a Chapel record (i.e., C struct) for each locale that contains the remote communication information about \textbf{A[B[i]]} on that locale.
We refer to the complete set of these records as a \emph{communication schedule}.
A communication schedule is essentially a set of associative arrays that map \textbf{B[i]} to \textbf{A[B[i]]} when \textbf{A[B[i]]} is a remote access issued from a given locale.
If \textbf{A} is associated with multiple \texttt{forall} loops that are being optimized, the optimization will create different communication schedules for \textbf{A} that are linked to each \texttt{forall} loop.

% inspector loop
\textbf{Inspector Loop:}
The compiler optimization starts by cloning the original \texttt{forall} loop into two copies, one that will be transformed into the inspector and one that will be transformed into the executor.
For the inspector loop (lines 3--5), the optimization replaces the original \texttt{forall} loop's iterator with a custom one (\texttt{inspectorIterator}).
This custom iterator creates one task on each locale to execute that locale's portion of the original \texttt{forall} loop serially.
While this does reduce the total amount of parallelism that the default iterator provides, it enables turning off parallel-safety for the underlying associative arrays in the communication schedule, which generally provides performance improvements.
Once the loop structure is generated, the optimization replaces the original expression \texttt{C[i] = A[B[i]]} with a call to \texttt{inspectAccess}, which is a procedure we create to perform the memory access analysis.
Note that any code in the original loop that does not pertain to the \textbf{A[B[i]]} access is removed to keep the inspector as lightweight as possible.
Furthermore, the call to \texttt{inspectAccess} does not perform the actual access to \textbf{A}, but instead queries whether \textbf{B[i]} would be a remote access to \textbf{A}, since remote accesses are expensive.
Finally, the optimization inserts a call to \texttt{inspectorPreamble} (line 2) before the inspector loop, which initializes some of the communication schedule internal structures.

% doInspector and pre/post inspector
\textbf{Turning the Inspector On/off:}
One of the key steps of the optimization is determining when the inspector should execute.
After the inspector runs for the first time, it does not need to be run again unless the memory access pattern changes.
The static analysis phase (in Section~\ref{sec:3-3_static}) determines when such changes occur and the optimization inserts calls to a procedure that sets flags associated with \textbf{A} and \textbf{B} to indicate that the inspector should be executed.
The \texttt{doInspector} call on line 2 checks these flags and the \texttt{inspectorOff} call on line 6 turns off the flags.

% executor
\textbf{Executor Loop:}
For the executor loop, the optimization replaces the original \textbf{A[B[i]]} access with a call to \texttt{executeAccess} (line 10), which redirects remote accesses to the replicated copies.
The optimization also inserts a call to \texttt{executorPreamble} (line 8) just before the executor loop, which initializes the replicated elements with the current values in \textbf{A}, ensuring that up-to-date values will be used in the executor.
While this does perform remote communication, the optimization only communicates a remote element once, regardless of how many times it is accessed in the loop.
As a result, the cost of the remote access is amortized over multiple local accesses.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Static Analysis}
\label{sec:3-3_static}
There are two main goals of the static analysis: (1) to detect scenarios where the code transformations could lead to different program results compared to the original program and (2) to only apply the optimization when performance gains are likely.
Each goal imposes different requirements that must be resolved at compile-time, where violating any requirement will cause the optimization to revert to the original code.
We briefly describe the analysis that is performed to achieve these two goals.
We then discuss additional analyses that were developed to increase the generality of the optimization.

\textbf{Program Results:}
Since the optimization is applied automatically by the compiler, it must detect scenarios where the code transformations could produce program results that differ from the original code.
The primary scenario that could lead to different program results is not running the inspector when necessary, resulting in communication schedules that are out of date.
To determine when the inspector needs to execute, the optimization must be able to statically reason about the locale affinity of the \texttt{forall} loop and the source/destination locales of the remote accesses for \textbf{A[B[i]]}.
The following criteria summarize the static checks performed for these purposes:
\begin{enumerate}
    \item The \texttt{forall} loop must iterate over a distributed array or distributed domain.
    \item The \texttt{forall} loop cannot be nested inside of another \texttt{forall} or any other statement that could create multiple parallel tasks.
    \item The index \textbf{i} in \textbf{A[B[i]]} must be the loop index variable for the loop that contains \textbf{A[B[i]]}, and the loop must iterate over a domain or array.
    \item Neither \textbf{A} nor \textbf{B}, nor their domains, can be modified within the \texttt{forall} loop.
\end{enumerate}
Check (1) ensures that the optimization can reason about the \texttt{forall} loop's locale affinity (i.e., which locales the iterations will execute on).
Check (2) ensures that multiple tasks will not execute the entire \texttt{forall} loop at the same time, which would result in potential concurrent updates to the communication schedules. 
Check (3) ensures that the optimization can statically reason about
the index \textbf{i} into \textbf{B}, specifically when the values of \textbf{i} would change. 
Such changes would happen if the array/domain over which the loop iterates is modified.
Check (4) ensures that the values in \textbf{B} that are analyzed by the inspector will be the same as the values used within the executor (and the original loop).
When applied to \textbf{A}, this check avoids the complexities of writing to replicated elements of \textbf{A} and having to propagate those values back to the original elements.
If these checks are met, then the optimization will determine all modifications to \textbf{A}, \textbf{B}, their domains and the various other arrays/domains involved in the loop.
If these objects are modified, it indicates that \textbf{A[B[i]]} could exhibit an access pattern that differs from when the inspector was last performed, whether it be different indices used to access \textbf{A} or the accesses themselves being issued from different locales.
When modifications are found, the optimization will set the corresponding flags to rerun the inspector to update the communication schedule.

\textbf{Program Performance:}
The goal of the optimization is to improve the runtime performance of an input program.
Therefore the static analysis attempts to determine whether the optimization is likely to provide performance gains.
This analysis can be summarized as determining that the \texttt{forall} loop will execute multiple times without requiring the inspector to be executed each time, which would incur significant overhead.
The following criteria summarize the static checks performed for these purposes:
\begin{enumerate}[(a)]
    \item The \texttt{forall} loop must be nested in an outer serial loop (i.e., \texttt{for}, \texttt{while}, etc.).
    \item Neither \textbf{B} nor its domain can be modified within the outer loop that the \texttt{forall} is nested in.
    \item \textbf{A}'s domain cannot be modified within the outer loop that the \texttt{forall} is nested in.
\end{enumerate}
Check (a) ensures that the \texttt{forall} loop is likely to be executed multiple times, though it is not guaranteed to do so.
Checks (b) and (c) ensure that the inspector will not be executed each time the \texttt{forall} loop runs.
Recall that part of the code transformation phase is to ``turn on'' the inspector after modifications to \textbf{B}, its domain or \textbf{A}'s domain.
Such modifications have the potential to alter the memory access pattern of \textbf{A[B[i]]}, and therefore require the inspector to be executed again.
The array \textbf{A} is allowed to be modified within the outer loop, as any changes to its values will be propagated to the replicated copies via the \texttt{executorPreamble}.
However, modifying \textbf{A}'s domain could alter the access pattern \textbf{A[B[i]]} by adding/removing elements in \textbf{A}.

\textbf{Non-affine Expression Analysis:}
Thus far we have focused our discussion on accesses of the form \textbf{A[B[i]]}.
However, the optimization can support more complex non-affine expressions, such as \textbf{A[B[i*j]\%k+1]}, if certain conditions are met.
Specifically, the expressions must be binary operations between immediates or variables yielded by loops that iterate over arrays/domains.
This requirement is needed so that the optimization can statically reason about when/how the accesses to \textbf{A} and \textbf{B} could change.
This is accomplished by locating modifications to the arrays/domains that yield the variables used in the expressions.
Note that outside of our optimization, Chapel's current compiler does not perform affine/non-affine expression analysis.

\textbf{Interprocedural and Alias Analyses:}
The optimization performs interprocedural and alias analyses to support the static checks described previously.
The interprocedural analysis computes the call graph starting from the function that contains the \texttt{forall} and checks for any invalid call paths.
We deem a call path invalid if there is a lack of an outer serial loop or if there is an enclosing statement that creates multiple parallel tasks.
When an invalid call path is detected the compiler inserts flags that are set at runtime to ``turn off'' the optimization temporarily along the invalid path.
Also, the interprocedural analysis detects modifications to the arrays/domains of interest across arbitrarily nested function calls.
Alias analysis is necessary because Chapel allows users to create references to arrays/domains, which operate similarly to pointers in C.
To address this issue, we developed static checks to detect such references and determine the original array/domain.
This analysis works for arbitrarily long alias chains (e.g., \texttt{var arr = ...; ref a1 = arr; ref a2 = a1}), where the optimization will detect modifications to any of the references along the chain.