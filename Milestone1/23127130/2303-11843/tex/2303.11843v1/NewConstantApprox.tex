\section{Fully Dynamic $k$-Bounded MIS with Vertex Updates}
\label{sec:generalMetric}

Given the reduction from Section \ref{sec:kCenters}, the goal of this section will be to design an algorithm which maintains a top-$k$ LFMIS with leaders  (Definition \ref{def:LFMISLead}) under a graph which receives a fully dynamic sequence of \textit{vertex} insertions and deletions. As noted, maintaining a top-$(k+1)$ LFMIS immediately results in a solution to the $k$-Bounded MIS problem. We begin by formalizing the model of vertex-valued updates to dynamic graphs. 


\paragraph{Fully Dynamic Graphs with Vertex Updates}
 In the vertex-update fully dynamic setting, at each time step a vertex $v$ is either inserted into the current graph $G$, or deleted from $G$, along with all edges incident to $v$. This defines a sequence of graphs $G^1, G^2,\dots,G^M$, where $G^t= (V^t,E^t)$ is the state of the graph after the $t$-th update. Equivalently, we can think of there being an ``underlying'' graph $G = (V,E)$, where at the beginning all vertices are \textit{inactive}. At each time step, either an active vertex is made inactive, or vice-versa, and $G^{t}$ is defined as the subgraph induced by the active vertices at time $t$. The latter is the interpretation which will be used for this section. 

Since the degree of $v$ may be as large as the number of active vertices in $G$, our algorithm will be unable to read all of the edges incident to $v$ when it arrives. Instead, we require only query access to the adjacency matrix of the underlying graph $G$. Namely, we assume that we can test in constant time whether $(u,v) \in E$ for any two vertices $u,v$. 



For the purpose of $k$-center clustering, we will need to maintain a top-$k$ LFMIS with leaders $(\LFMIS_k(G,\pi),\ell)$, along with a Boolean value indicating whether 
$\LFMIS_k(G,\pi) = \LFMIS(G,\pi)$. To do this, we can instead attempt to maintain the set $\LFMIS_{k+1}(G,\pi)$, as well as a leader mapping function $\ell:V \to V \cup \{\bot\}$, with the relaxed property that if $\LFMIS_k(G,\pi) = \LFMIS(G,\pi)$, then $\ell(v) \in \LFMIS(G,\pi)$ for all $v \in V \setminus \LFMIS(G,\pi)$ and $\ell(v) = \bot$ for all $v \in \LFMIS(G,\pi)$. We call such a leader function $\ell$ with this relaxed property a \textit{modified} leader mapping. Thus, in what follows, we will focus on maintaining a top-$k$ LFMIS with this modified leader mapping. 



\subsection{The Data Structure}
We now describe the main data structure and algorithm which will maintain a top-$k$ LFMIS with leaders in the dynamic graph $G$.
We begin by fixing a random mapping $\pi:V \to [0,1]$, which we will use as the ranking for our lexicographical ordering over the vertices. It is easy to see that if $|V| = n$, then by discretizing $[0,1]$ so that $\pi(v)$ can be represented in $O(\log n)$ bits we will avoid collisions with high probability. At every time step, the algorithm will maintain an ordered set $\ALG $ of vertices in a linked list, sorted by the ranking $\pi$, with $|\ALG| \leq k+1$. We will prove that, after every update $t$, we have $\ALG = \LFMIS_{k+1}(G^t,\pi)$.\footnote{We use a separate notation $\ALG$, instead of $\LFMIS_{k+1}$, to represent the set maintained by the algorithm, until we have demonstrated that we indeed have $\ALG = \LFMIS_{k+1}(G^t,\pi)$ at all time steps $t$.}  We will also maintain a mapping $\ell:V \to V \cup \{\bot\}$ which will be our leader mapping function. Initially, we set $\ell(v) = \bot$ for all $v$. 
Lastly, we will maintain a (potentially empty) priority queue $\cQ$ of \textit{unclustered} vertices, where the priority is similarly given by $\pi$. 


Each vertex $v$ in $G_t$ will be classified as either a \textit{leader}, a \textit{follower}, or \textit{unclustered}. Intuitively, when $\LFMIS_k(G,\pi) = \LFMIS(G,\pi)$, the leaders will be exactly the points in $\LFMIS_k(G,\pi)$, the followers will be all other points $v$ which are mapped to some $\ell(v) \in \LFMIS_k(G,\pi)$ (in other words, $v$ ``follows'' $\ell(v)$), and there will be no unclustered points. At intermediate steps, however, when $|\LFMIS(G,\pi)| \geq k + 1$, we will be unable to maintain the entire set $\LFMIS(G,\pi)$ and, therefore, we will store the set of all vertices which are not in $\LFMIS_{k+1}$ in the priority queue $\cQ$ of unclustered vertices. The formal definitions of leaders, followers, and unclustered points follow.

Every vertex currently maintained in $\ALG$ is be a leader. Each leader $v$ may have a set of follower vertices, which are vertices $u$ with $\ell(u) = v$, in which case we say that $u$ follows $v$. By construction of the leader function $\ell$, every follower-leader pair $(u,\ell(u))$ will be an edge of $G$.  We write $\cF_v = \{u \in V : \ell(u) = v\}$ to denote the (possibly empty) set of followers of a leader $v$. For each leader, the set $\cF_v$ will be maintained as part of the data structure at the vertex $v$.

Now when the size of $\LFMIS$ exceeds $k+1$, we will have to remove the leader $v$ in $\LFMIS$ with the largest rank, so as to keep the size of $\ALG$ at most $k+1$. The vertex $v$ will then be moved to the queue $\cQ$, along with its priority $\pi(v)$. The set $\cF_v$ of followers of $v$ will continue to be followers of $v$ --- their status remains unchanged. In this case, the vertex $v$ is now said to be an \textit{inactive} leader, whereas each leader currently in $\ALG$ is called an \textit{active} leader. If, at a later time, we have $\pi(v) < \max_{u \in \ALG} \pi(u)$, then it is possible that $v$ may be part of $\LFMIS_{k+1}$, in which case we will attempt to reinsert the inactive leader $v$ from $\cQ$ back into $\ALG$. Note, importantly, that whenever $\pi(v) < \max_{u \in \ALG} \pi(u)$ occurs at a future time step for a vertex $v \in \cQ$, then either $v$ is part of $\LFMIS_{k+1}$, or it is a neighbor of some vertex $u \in \LFMIS_{k+1}$ of lower rank. In both cases, we can remove $v$ from $\cQ$ and attempt to reinsert it, with the guarantee that after this reinsertion $v$ will either be an active leader, or a follower of an active leader.

\paragraph{The Unclustered Queue.} We now describe the purpose and function of the priority queue $\cQ$. 
Whenever either a vertex $v$ is inserted into the stream, or it is a follower of a leader $\ell(v)$ who is removed from the $\LFMIS$, we must attempt to reinsert $v$, to see if it should be added to $\LFMIS_{k+1}$. However, if $|\ALG| = k+1$, then the only way that $v$ should be a part of $\LFMIS_{k+1}$ (and therefore added to $\ALG$) is if $\pi(v) < \max_{u \in \ALG} \pi(u)$. If this does not occur, then we do not need to insert $v$ right away, and instead can defer it to a later time when either $|\ALG| < k+1$ or $\pi(v) < \max_{u \in \ALG} \pi(u)$ holds. Moreover, by definition of the modified leader mapping $\ell$, we only need to set $\ell(v)$ when $|\LFMIS_{k+1}| < k+1$. We can therefore add $v$ to the priority queue $\cQ$. 

Every point in the priority queue is called an \textit{unclustered point}, as they are not currently part of a valid $k$-clustering in the graph. By checking the top of the priority queue at the end of processing each update, we can determine whenever either of the events $|\ALG| \leq k$ or $\pi(v) < \max_{u \in \ALG} \pi(u)$ holds; if either is true, we iteratively attempt to reinsert the top of the queue until the queue is empty or both events no longer hold. This will ensure that either all points are clustered (so $\cQ = \emptyset$), or $|\ALG| = k+1$ and $\ALG = \LFMIS_{k+1}$ (since no point in the queue could have been a part of $\LFMIS_{k+1}$).


\paragraph{The Leader Mapping.}  
Notice that given a top-$k$ LFMIS, a valid leader assignment is always given by $\ell(v) = \elim_{G,\pi}(v)$, where $\elim_{G,\pi}(v)$ is the eliminator of $v$ via $\pi$ as defined in Section \ref{sec:kCenters}; this is the case since if  $\LFMIS_k(G,\pi) = \LFMIS(G,\pi)$ then each vertex is either in $\LFMIS_k(G,\pi)$ or eliminated by one of the vertices in $\LFMIS_k(G,\pi)$.
Thus, intuitively, our goal should be to attempt to maintain that $\ell(v) = \elim_{G,\pi}(v)$ for all $v \notin \LFMIS_k(G,\pi)$.
However, the addition of a new vertex which enters $\LFMIS_{k}(G,\pi)$ can change the eliminators of many other vertices \textit{not} in $\LFMIS_k(G,\pi)$. Discovering which points have had their eliminator changed immediately on this time step would be expensive, as one would have to search through the followers of all active leaders to see if any of their eliminators changed. Instead, we note that at this moment, so long as the new vertex does not share an edge with any other active leader, we do not need to modify our leader mapping. Instead, we can \textit{defer} the reassignment of the leaders of vertices $v$ whose eliminator changed on this step, to a later step when their leaders are removed from $\LFMIS_{k+1}(G,\pi)$. Demonstrating that the number of changes to the leader mapping function $\ell$, defined in this way, is not too much larger than the number of changes to the eliminators of all vertices, will be a major component of our analysis. 


\paragraph{The Algorithm and Roadmap.} Our main algorithm is described in three routines: Algorithms \ref{alg:main}, \ref{alg:ins}, and \ref{alg:del}. Algorithm \ref{alg:main} handles the inital insertion or deletion of a vertex in the fully dynamic stream, and then calls at least one of Algorithms \ref{alg:ins} or \ref{alg:del}. Algorithm \ref{alg:ins} handles insertions of vertices in the data structure, and Algorithm \ref{alg:del} handles deletions of vertices from the data structure. We begin in Section \ref{sec:correctness} by proving that our algorithm does indeed solve the top-$k$ LFMIS problem with the desired modified leader mapping. Then, in Section \ref{sec:amortized}, we analyze the amortized runtime of the algorithm.




\begin{algorithm}[ht]
\DontPrintSemicolon
	\caption{Process Update}\label{alg:main}
	\KwData{An update $(v,\sigma)$, where $\sigma \in \{+,-\}$.}
 \If{$\sigma = +$ is an insertion of $v$}{
 Generate $\pi(v)$, and set $\ell(v) = \bot$.\;
 Call $\ins(v,\pi(v))$.\;}
\If{$\sigma = -$ is a deletion of $v$}{
Call $\delete(v)$.\;
}

\While{$|\cQ| \neq \emptyset \boldsymbol{\wedge} \left( |\ALG| \leq  k+1 \boldsymbol{\vee} \min_{w \in \cQ} \pi(w) < \max_{w \in \ALG} \pi(w)  \right)$}{ \label{line:whileMain}  
$u \leftarrow \arg \min_{w \in \cQ} \pi(w)$.\;
Delete $u$ from $\cQ$, and call $\ins(u,\pi(u))$. \;
}
\end{algorithm}

\begin{algorithm}[ht]
\DontPrintSemicolon
	\caption{$\ins(v,\pi(v))$} \label{alg:ins}
 \If{$|\ALG| = k+1$ $\boldsymbol{\wedge}$ $\pi(v) > \max_{u \in \ALG} \pi(u)$}{\label{line:firstIfIns}
 Insert $(v,\pi(v))$ into $\cQ$. \;}
\Else{
Compute $S =  \ALG \cap N(v)$\;
\If{$S = \emptyset$}{
Add $v$ to $\ALG$. \;
\If{ $|\ALG| = k+2$}{
Let $u = \arg \max_{u' \in \ALG} \pi(u') $. \;
Remove $u$ from $\ALG$, and insert $(u,\pi(u))$ into $\cQ$. \label{line:delOverflow} \;
}
}
\Else{
    $u^* = \arg \min_{u' \in S} \pi(u')$\;
    \If{$\pi(u^*) < \pi(v)$}{
    \If{$v$ is a leader}{
    For each $w \in \cF_v$, insert $(w,\pi(w))$ to $\cQ$, and set $\ell(w) = \bot$ \label{line:queue1Ins} \;
    Delete the list $\cF_v$. \;
    }
    Add $v$ to $\cF_{u^*}$ as a follower of $u^*$, set $\ell(v) = u^*$. \;
    }
    \Else{
    For each $w \in \cup_{u \in S} \cF_u$, add $(w,\pi(w))$ to $\cQ$, and set $\ell(w) = \bot$. \label{line:queue2Ins} \;
    For each $u \in S$, set $\ell(u) = v$ to be a follower of $v$, remove $u$ from $\ALG$, and delete the list $\cF_u$. \;
    }
 }  
}
\end{algorithm}

\begin{algorithm}[!ht]
\DontPrintSemicolon
	\caption{$\delete(v)$ }\label{alg:del}
	
	\If{$v$ is a follower}{
	Delete $v$ from $\cF_{\ell(v)}$, and remove $v$ from the set of vertices.  \; 
	}
	\ElseIf{$v \in \cQ$}{
	\If{$v$ is a leader}{
	 For each $w \in \cF_v$, insert $(w,\pi(w))$ to $\cQ$, and set $\ell(w) = \bot$ \label{line:queue1Del} \;
	 Delete the list $\cF_v$, and remove $v$ from $\cQ$ and the set of vertices. \;
	}
	\Else{
	Delete $v$ from $\cQ$ and the set of vertices. \;
	}
	}
	\Else(\tcc*[r]{Must have $v \in \ALG$}){
	 For each $w \in \cF_v$, insert $(w,\pi(w))$ to $\cQ$, and set $\ell(w) = \bot$\label{line:queue2Del} \;
	 	 Delete the list $\cF_v$, and remove $v$ from $\ALG$ and the set of vertices. \;
	}
\end{algorithm}


\subsection{Correctness of the Algorithm}\label{sec:correctness}
We will now demonstrate the correctness of the algorithm, by first proving two Propositions. 

\begin{proposition}\label{prop:IS}
After every time step $t$, the set $\ALG$ stored by the algorithm is an independent set in $G^{(t)}$.
\end{proposition}
\begin{proof}
Suppose otherwise, and let $v,u \in \ALG$ be vertices with $(v,u) \in E$. WLOG we have that $v$ is the vertex which entered $\ALG$ most recently of the two. Then we had $ u \in ALG$ at the moment that $\ins(v,\pi(v))$ was most recently called. Since on the step that $\ins(v,\pi(v))$ was most recently called the vertex $p$ was added to $\ALG$, it must have been that $\min_{w \in N(v) \cap \ALG} \pi(w) > \pi(v)$, thus, in particular,  we must have had $\pi(v) < \pi(u)$. However, in this case we would have made $u$ a follower of $v$ at this step and set $\ell(u) = v$, which could not have occurred since then $u$ would have been removed from $\ALG$, which completes the proof. 
\end{proof}

\begin{claim}\label{claim:1}
We always have $|\ALG| \leq k+1$ at all time steps.
\end{claim}
\begin{proof}
After the first insertion the result is clear. We demonstrate that the claim holds inductively after each insertion. Only a call to $\ins(v)$ can increase the size of $\ALG$, so consider any such call. If $N(v) \cap \ALG$ is empty, then we add $v$ to $\ALG$, which can possibly increase its size to $k+2$ if it previously had $k+1$ elements. In this case, we remove the element with largest rank and add it to $\cQ$, maintaining the invariant. If there exists a $u^* \in N(v) \cap \ALG$ with smaller rank than $v$, we make $v$ the follower of the vertex in $ N(v) \cap \ALG$ with smallest rank, in which case the size of $\ALG$ is unaffected. In the final case, all points in $N(v) \cap \ALG$ have larger rank than $v$, in which case all of $N(v) \cap \ALG$ (which is non-empty) is made a follower of $v$ and removed from $\ALG$, thereby decreasing or not affecting the size of $\ALG$, which completes the proof. 
\end{proof}

\begin{proposition}[Correctness of Leader Mapping]
At any time step, if $\ALG \leq k$ then every vertex $v \in V$ is either contained in $\ALG$, or has a leader $\ell(v) \in \ALG$ with $(v,\ell(v)) \in E$.
\end{proposition}
\begin{proof}
After processing any update, we first claim that if $\ALG \leq k$ we have $\cQ = \emptyset$. This follows from the fact that the while loop in Line \ref{line:whileMain} of Algorithm \ref{alg:main} does not terminate until one of these two conditions fails to hold. Thus if $\ALG \leq k$, every vertex $v \in V$ is either contained in $\ALG$ (i.e., an active leader), or is a follower of such an active leader, which completes the proof of the proposition, after noting that we only set $\ell(u) = v$ when $(u,v) \in E$ is an edge.
\end{proof}



\begin{lemma}[Correctness of the top-$k$ LFMIS]\label{lem:correctness}
After every time step, we have $\ALG = \LFMIS_{k+1}(G,\pi)$. 
\end{lemma}
\begin{proof}
Order the points in $\ALG = (v_1,\dots,v_r)$ and $\LFMIS_{k+1}(G,\pi) = (u_1,\dots,u_s)$ by rank. We prove inductively that $v_i = u_i$. Firstly, note that $u_1$ is the vertex with minimal rank in $G$. As a result, $u_1$ could not be a follower of any point, since we only set $\ell(u) = v$ when $\pi(v) < \pi(u)$. Thus $u_1$ must either be an inactive leader (as it cannot be equal to $v_j$ for $j > 1$) or an unclustered point. In both cases, one has $u_1 \in \cQ$, which we argue cannot occur. To see this, note that at the end of processing the update, the while loop in  Line \ref{line:whileMain} of Algorithm \ref{alg:main} would necessarily remove $u_1$ from $\cQ$ and insert it. It follows that we must have $u_1 = v_1$.

In general, suppose we have $v_i = u_i$ for all $i \leq j$ for some integer $j < s$. We will prove $v_{j+1} = u_{j+1}$. First suppose $r , s \geq j+1$.
Now by definition of the LSFMIS, the vertex $u_{j+1}$ is the smallest ranked vertex in $V \setminus  \cup_{i \leq j} N(v_i) \cup \{u_i\}$. Since we only set $\ell(u) = v$ when $(u,v) \in E$ is an edge, it follows that $u_{j+1}$ cannot be a follower of $u_{i} = v_i$ for any $i \leq j$. Moreover, since we only set $\ell(u) = v$ when $\pi(v) < \pi(u)$, it follows that $u_{j+1}$ cannot be a follower of $v_{i}$ for any $i > j$, since $\pi(v_i) \geq \pi(u_{j+1})$ for all $i > j$. 
Thus, if $v_{j+1} \neq u_{j+1}$, it follows that either $u_{j+1} \in \cQ$, or $u_{j+1}$ is a follower of some vertex $u' \in \cQ$ with smaller rank than $u_{j+1}$. Then, similarly as above, in both cases the while loop in  Line \ref{line:whileMain} of Algorithm \ref{alg:main} would necessarily remove $u_{j+1}$ (or $u'$ in the latter case) from $\cQ$ and insert it, because $\pi(u_{j+1}) < \pi(v_r)$, and in the latter case if such a $u'$ existed we would have $\pi(u') < \pi(u_{j+1}) < \pi(u_r)$. We conclude that $v_{j+1} = u_{j+1}$.

The only remaining possibility is $r \neq s$. First, if $r > s$, by Claim \ref{claim:1} we have $r \leq k+1$, and by  Proposition \ref{prop:IS} $\ALG$ forms a independent set. Thus $v_1,v_2,\dots,v_s,v_{s+1}$ is an independent set, but since $v_i = u_i$ for $i \leq s$ and $\LFMIS_{k+1}(G,\pi) = \{u_1,\dots,u_s\}$ is a maximal independent set whenever $s \leq k$, this yields a contradiction. Finally, if $r < s$, consider the vertex $u_{r+1}$. Since $u_i = v_i$ for all $i \leq r$, $u_{r+1}$ cannot be a follower of $v_i$ for any $i \in [r]$. As a result, it must be that either $u_{r+1} \in \cQ$ or $u_{r+1}$ is a follower of a vertex in $\cQ$. In both cases, 
at the end of the last update, we had $|\ALG| = r \leq k$ and $\cQ \neq \emptyset$, which cannot occur as the while loop in  Line \ref{line:whileMain} of Algorithm \ref{alg:main} would not have terminated. It follows that $r=s$, which completes the proof.
\end{proof}





\subsection{Amortized Update Time Analysis}\label{sec:amortized}
We now demonstrate that the above algorithm runs in amortized $\tilde{O}(k)$-time per update. We begin by proving a structural result about the behavior of our algorithm. In what follows, let $G^t$ be the state of the graph \textit{after} the $t$-th update. Similarly, let $\ell_t(v) \in V \cup \{\bot\}$ be the value of $\ell(v)$ after the $t$-th update. 

\begin{proposition}\label{prop:orderedPi}
Let $\ins(v_1,\pi(v_1)),\ins(v_2,\pi(v_2)),\dots,\ins(v_r,\pi(v_r))$ be the ordered sequence of calls to the $\ins$ function (Algorithm \ref{alg:ins}) which take places during the processing of any individual update in the stream. Then we have $\pi(v_1) < \pi(v_2) < \cdots < \pi(v_r)$. As a corollary, for any vertex $v$ the function $\ins(v,\pi(v))$ is called at most once per time step. 
\end{proposition}
\begin{proof}
Assume $r>1$, since otherwise the claim is trivial. 
To prove the proposition it will suffice to show two facts: $(1)$ whenever a call to $\ins(v_i,\pi(v_i))$ is made, $\pi(v_i)$ is smaller than the rank of all vertices in the queue $\cQ$, and $(2)$ a call to $\ins(v_i,\pi(v_i))$ can only result in vertices with larger rank being added to $\cQ$. 

To prove $(1)$, note that after the first call to $\ins(v_1,\pi(v_1))$, which may have been triggered directly as a result of $v_1$ being added to the stream at that time step, all subsequent calls to $\ins$ can only be made via the while loop of Line \ref{line:whileMain} in Algorithm \ref{alg:main}, where the point with smallest rank is iteratively removed from $\cQ$ and inserted. Thus, fact $(1)$ trivially holds for all calls to $\ins$ made in this while loop, and it suffices to prove it for  $\ins(v_1,\pi(v_1))$ in the case that $v_1$ is added to the stream at the current update (if $v_1$ was added from the queue, the result is again clear). Now if $\cQ \neq \emptyset$ at the moment $\ins(v_1,\pi(v_1))$ is called, it must be the case that $|\ALG| = k+1$ and $\min_{w \in \cQ} \pi(w) > \max_{w \in \ALG} \pi(w)$ (otherwise the queue would have been emptied at the end of the prior update). Thus, if it were in fact the case that $\pi(v_1) >\min_{w \in \cQ} \pi(w)$, then we also have $\pi(v_1) > \max_{w \in \ALG} \pi(w)$, and therefore the call to $\ins(v_1,\pi(v_1))$ would result in inserting $v_1$ into $\cQ$ on Line \ref{line:firstIfIns} of Algorithm \ref{alg:ins}. Such an update does not modify $\ALG$, and does not change the fact that $\min_{w \in \cQ} \pi(w) > \max_{w \in \ALG} \pi(w)$, thus the processing of the update will terminate after the call to $\ins(v_1,\pi(v_1))$ (contradicting the assumption that $r>1$), which completes the proof of $(1)$.

To prove $(2)$, note that there are only three ways for a call to $\ins(v_i,\pi(v_i))$ to result in a vertex $u$ being added to $\cQ$. In the first case, if $\ell(u)$ was an active leader which was made a follower of $v_i$ as a result of $\ins(v_i,\pi(v_i))$, then we have $\pi(u) < \pi(\ell(u)) < \pi(v_i)$. Next, we could have had $\ell(u) = v_i$ (in the event that $v_i$ was an inactive leader being reinserted from $\cQ$), in which case $\pi(u) < \pi(v_i)$. Finally, it could be the case that $u$ was the active leader in $\ALG$ prior to the call to $\ins(v_i,\pi(v_i))$, and was then removed from $\ALG$ as a result of the size of $\ALG$ exceeding $k+1$ and $u$ having the largest rank in $\ALG$. This can only occur if $v_i$ was added to $\ALG$ and had smaller rank than $u$, which completes the proof of $(2)$.

Since by $(1)$ every time $\ins(v_i,\pi(v_i))$ is called $\pi(v_i)$ is smaller than the rank of all vertices in the queue, and by $(2)$ the rank of all new vertices added to the queue as a result of $\ins(v_i,\pi(v_i))$ will continue to be larger than $\pi(v_i)$, it follows that $v_{i+1}$, which by construction must be the vertex with smallest rank in $\cQ$ after the call to $\ins(v_i,\pi(v_i))$, must have strictly larger rank than $v_i$, which completes the proof of the proposition. 
\end{proof}

The following proposition is more or less immediate. It implies, in particular, that a point can only be added to $\cQ$ once per time step (similarly, $v$ can be removed from $\cQ$ once per time step). 

\begin{proposition}\label{prop:afterQ}
Whenever a vertex $v$ in the queue $\cQ$ is removed and $\ins(v,\pi(v))$ is called, the vertex $v$ either becomes a follower of an active leader, or an active leader itself. 
\end{proposition}
\begin{proof}
If $v$ shares an edge with a vertex in $\ALG$ with smaller rank, it becomes a follower of such a vertex. Otherwise, all vertices in $N(v) \cap \ALG$ become followers of $v$, and $v$ becomes an active leader by construction (possibly resulting in an active leader of larger rank to be removed from $\ALG$ as a result of it no longer being contained in $\LFMIS_{k+1}$).
\end{proof}



Equipped with the prior structural propositions, our approach for bounding the amortized update time is to first observe that, on any time step $t$, our algorithm only attempts to insert a vertex~$v$, thereby spending $O(k)$ time to search for edges between $v$ and all members of $\ALG$, if either $v$ was the actual vertex added to the stream on step $t$, or when $v$ was added to $\cQ$ on step $t$ or before. Thus, it will suffice to bound the total number of vertices which are ever added into $\cQ$ --- by paying a cost $O(k + \log n)$ for each vertex $v$ which is added to the queue, we can afford both the initial $O(\log n)$ cost of adding it to the priority queue, as well as the $O(k)$ runtime cost of possibly later reinserting $v$ during the while loop in Line \ref{line:whileMain} of Algorithm \ref{alg:main}. We formalize this in the following proposition.

\begin{proposition}\label{prop:T}
Let $T$ be the total number of times that a vertex is inserted into the queue $\cQ$ over the entire execution of the algorithm, where two insertions of the same vertex $v$ on separate time steps are counted as distinct insertions.  Then the total runtime of the algorithm, over a sequence of $M$ insertions and deletions, is at most $O(T (k + \log n) + Mk)$, where $n$ is the maximum number of vertices active at any given time.
\end{proposition}
\begin{proof}
Note that the only actions taken by the algorithm consist of adding and removing vertices $v$ from $\cQ$ (modifying the value of $\ell(v)$ in the process, and possibly deleting $\cF_v$), and computing $\ALG \cap N(v)$ for some vertex $v$. The latter requires $O(k)$ time since we have $|\ALG| \leq k+1$ at all time steps. Given $O(\log n)$ time to insert or query from a priority queue with at most $n$ items, we have that $O(T \log n)$ upper bounds the cost of all insertions and deletions of points to $\cQ$. Moreover, all calls to compute $\ALG \cap N(v)$ for some vertex $v$ either occur when $v$ is the vertex added to the stream on that time step (of which there is at most one), or when $v$ is inserted after previously having been in $\cQ$. By paying each vertex $v$ a sum of $O(k)$ when it is added to $\cQ$, and paying $O(k)$ to each vertex when it is first added to the stream, it can afford the cost of later computing $\ALG \cap N(v)$  when it is removed. This results in a total cost of $O(T(k+\log n) + Mk)$, which completes the proof. 
\end{proof}


In what follows, we focus on bounding the quantity $T$. To accomplish this, observe that a vertex $v$ can be added to $\cQ$ on a given time step $t$ in one of three ways:
\begin{figure}[H]
    \centering
  
\begin{Frame}[Scenarios where $v$ is added to $\cQ$]
    \begin{enumerate}
\item The vertex $v$ was added in the stream on time step $t$. In this case, $v$ is added to $\cQ$ when the if statement on Line \ref{line:firstIfIns} of Algorithm \ref{alg:ins} executes. 
\item The vertex $v$ is added to $\cQ$ when it was previously led by $\ell_{t-1}(v) \in V$, and either $\ell_{t-1}(v)$ becomes a follower of another leader during time step $t$ (resulting in $v$ being added to $\cQ$), or $\ell_{t-1}(v)$ is deleted. This can occur in either Lines \ref{line:queue1Ins} or \ref{line:queue2Ins}  of Algorithm \ref{alg:ins} for the first case, or in Lines \ref{line:queue1Del} or \ref{line:queue2Del} of Algorithm \ref{alg:del} in the case of  $\ell_{t-1}(v)$  being deleted. 
\item The vertex $v$ was previously in $\LFMIS_{k+1}$, and subsequently left $\LFMIS_{k+1}$ because $|\LFMIS_{k+1}| = k+1$ and a new vertex $u$ was added to $\LFMIS_{k+1}$ with smaller rank. This occurs in Line \ref{line:delOverflow} of Algorithm \ref{alg:ins}. 
    \end{enumerate}
\end{Frame}

\end{figure}

Obviously, the first case can occur at most once per stream update, so we will focus on bounding the latter two types of additions to $\cQ$. For any step $t$, define $\cA_\pi^t$ to be the number of vertices that are added to $\cQ$ as a result of the second form of insertions above. Namely, $\cA_\pi^t = |\{v \in G^{t} : \ell_{t-1}(v) \in V, \text{ and } \ell_t(v) \neq \ell_{t-1}(v) \}|$. Next, define $\cB_\pi^t$ to be the number of leaders which were removed from $\ALG$ Line \ref{line:delOverflow} of Algorithm \ref{alg:ins} (i.e., insertions into $\cQ$ of the third kind above). Letting $T$ be as in Proposition \ref{prop:T}, we have $T \leq  M+  \sum_t \cA_\pi^t + \cB_\pi^t $.

To handle $\sum_t \cA_\pi^t$ and $\sum_t \cB_\pi^t$, we demonstrate that each quantity can be bounded by the total number of times that the \textit{eliminator} of a vertex changes. Recall from Section \ref{sec:kCenters} that, given a graph $G=(V,E)$, $v \in V$, and ranking $\pi:V \to [0,1]$, the eliminator of $v$, denoted $\elim_{G,\pi}(v)$, is defined as the vertex of smallest rank in the set $(N(v) \cup \{v\} ) \cap \LFMIS(G,\pi)$. Now define $\cC_\pi^t$ to be the number of vertices whose eliminator changes after time step $t$. Formally, for any two graphs $G,G'$ differing in at most once vertex, we define 
$\cC_\pi(G,G') = \{v \in V | \elim_{G,\pi}(v) \neq \elim_{G',\pi}(v)\}$, and set $\cC_\pi^t = |\cC_\pi(G^{t-1},G^{t})|$. %
We now demonstrate that $\sum_t \cC_\pi^t$ deterministically upper bounds both $\sum_t \cA_\pi^t$ and $\sum_t \cB_\pi^t$.

\begin{lemma}\label{lem:main}
Fix any ranking $\pi: V \to [0,1]$. Then we have $\sum_t \cA_\pi^t \leq 5 \sum_t \cC_\pi^t$, and moreover for any time step $t$ we have $\cB_\pi^t \leq \cC_\pi^t$.
\end{lemma}
\begin{proof}
We first prove the second statement. Fix any time step $t$, and let $v_1,\dots,v_r$ be the $r = |\cB_\pi^t|$ vertices which were removed from $\ALG$, ordered by the order in which they were removed from $\ALG$. For this to occur, we must have inserted at least $r$ vertices $u_1,\dots,u_r$ into $\ALG$ which were not previously in $\ALG$ on the prior step; in fact, Line \ref{line:delOverflow} of Algorithm \ref{alg:ins} induces a unique mapping from each $v_i$ to the vertex $u_i$ which forced it out of $\ALG$ during a call to $\ins(u_i,\pi(u_i))$. Note that, under this association, we have $\pi(u_i) < \pi(v_i)$ for each $i$. We claim that the eliminator of each such $u_i$ changed on time step $t$.

Now note that $\{u_1,\dots,u_r\}$ and $\{v_1,\dots,v_r\}$ are disjoint, since $u_i$ was inserted before $u_{i+1}$ during time step $t$ by the definition of the ordering, and so $\pi(u_1) < \pi(u_2) < \dots < \pi(u_r)$ by Proposition \ref{prop:orderedPi}, so no $u_i$ could be later kicked out of $\ALG$ by some $u_j$ with $j > i$. It follows that none of $u_1,\dots,u_r$ were contained in $\LFMIS_{k+1}(G^{t-1},\pi)$, but they are all in $\LFMIS_{k+1}(G^{t},\pi)$. Now note that it could not have been the case that $u_i \in \LFMIS(G^{t-1},\pi)$, since we had $v_i \in \LFMIS_{k+1}(G^{t-1},\pi)$ but $\pi(u_i) < \pi(v_i)$. Thus $u_i \notin \LFMIS(G^{t-1},\pi)$, and therefore the eliminator of $u_i$ changed on step $t$ from $\elim_{G^{t-1},\pi}(u_i) \neq u_i$ to $\elim_{G^t,\pi}(u_i) = u_i$, which completes the proof of the second statement.

We now prove the first claim that $\sum_t \cA_\pi^t \leq 5 \sum_t \cC_\pi^t$.  Because a vertex can be inserted into $\cQ$ at most once per time step (due to Proposition \ref{prop:afterQ}), each insertion $\cQ$ which contributes to $\sum_t \cA_\pi^t$ can be described as a  vertex-time step pair $(v,t)$, where we have $\ell_{t}(v) \neq \ell_{t-1}(v) \in V$ because either $\ell_{t-1}(v)$ became a follower of a vertex in $\LFMIS_{k+1}(G^t,\pi)$, or because $\ell_{t-1}(v)$ was deleted on time step $t$. %
We will now need two technical claims.

\begin{claim}\label{claim:2}
Consider any vertex-time step pair $(v,t)$ where $\ell_t(v) \in V$ and $\ell_{t-1}(v) \neq \ell_t(v)$. In other words, $v$ was made a follower of some vertex $\ell_t(v)$ during time step $t$. Then $\ell_t(v) = \elim_{G^t,\pi}(v)$.
\end{claim}
\begin{proof}
First note that the two statements of the claim are equivalent, since if $\ell(v)$ is set to $u \in V$ during time step $t$, then by Proposition \ref{prop:orderedPi} we have that $\ell(v)$ is not modified again during the processing of update $t$, so $u = \ell_{t}(v)$. Now the algorithm would only set $\ell_t(v) = u$ in one of two cases. In this first case, it occurs during a call to $\ins(v,\pi(v))$, in which case $\ell_t(v)$ is set to the vertex with smallest rank in $\LFMIS_{k+1}(G^t,\pi)\cap N(v)$, which by definition is $\elim_{G^t,\pi}(v)$. In the second case, $v$ was previously in $\LFMIS_{k+1}(G^{t-1},\pi)$, and $\ell(v)$ was changed to a vertex $w$ during a call to  $\ins(w,\pi(w))$, where $w \in N(v)$ and $\pi(w) < \pi(v)$. Since prior to this insertion $v$ was not a neighbor of any point in $\LFMIS_{k+1}(G^{t-1},\pi)$, and since by Proposition \ref{prop:orderedPi} the $\ins$ function will not be called again on time $t$ for a vertex with rank smaller than $w$, it follows that $w$ has the minimum rank of all neighbors of $v$ in $\LFMIS(G^{t},\pi)$, which completes the claim. 
\end{proof}

\begin{claim}\label{claim:3}
Consider any vertex-time step pair $(v,t)$ where $\ell_t(v) = \bot$ and $\ell_{t-1}(v) = \elim_{G^{t-1},\pi}(v) $. Then $\elim_{G^{t-1},\pi}(v) \neq \elim_{G^{t},\pi}(v) $.
\end{claim}
\begin{proof}
If $\ell_{t-1}(v) = \elim_{G^{t-1},\pi}(v)$, then $\elim_{G^{t-1},\pi}(v) \in v$  and $\ell_t(v)$ is changed to $\bot$ during time step $t$, then as in the prior claim, this can only occur if $\ell_{t-1}(v)$ is made a follower of another point in $\LFMIS_{k+1}(G^t,\pi)$, or if $\ell_{t-1}(v)$ is deleted on that time step. In both cases we have $\ell_{t-1}(v) \notin \LFMIS(G^t,\pi)$. Since $\elim_{G^{t},\pi}(v)$ is always in $\LFMIS(G^t,\pi)$, the claim follows.  
\end{proof}


Now fix any vertex $v$, and let $\sigma_1,\dots,\sigma_M$ be the sequence of eliminators of $v$, namely $\sigma_t = \elim_{G^t,\pi}(v)$ (note that $\sigma_t$ is either a vertex in $V$ or $\sigma_t = \emptyset$). Similarly define $\lambda_1,\dots,\lambda_M$ by $\lambda_t = \ell_t(v)$, and note that $\lambda_t \in V \cup \{\bot\}$. To summarize the prior two claims: each time $\lambda_{t-1} \neq \lambda_t$ and $\lambda_t \in V$, we have $\sigma_t = \lambda_t$; namely, the sequences become aligned at time step $t$. Moreover, whenever the two sequences are aligned at some time step $t$, namely $\sigma_t = \lambda_t$, and subsequently $\lambda_{t+1} = \bot$, we have that $\sigma_{t+1} \neq \sigma_t$. We now prove that every five subsequent changes in the value of $\lambda$ cause at least one unique change in $\sigma$.

To see this, let $t_1 < t_2 < t_3$ be three subsequent changes, so that $\lambda_{t_1} \neq \lambda_{t_1 - 1}$, $\lambda_{t_2} \neq \lambda_{t_2 - 1}$, $\lambda_{t_3} \neq \lambda_{t_3 - 1}$, and $\lambda_i$ does not change for all $i=t_1,\dots,t_2-1$ and $i= t_2,\dots,t_3-1$. First, if $\lambda_{t_1},\lambda_{t_2} \in V$, by Claim \ref{claim:2} we have $\sigma_{t_1} = \lambda_{t_1}$ and  $\sigma_{t_2} = \lambda_{t_2}$, and thus $\sigma_{t_1} \neq \sigma_{t_2}$, so $\sigma$ changes in the interval $[t_1,t_2]$. If $\lambda_{t_1} \in V$ and $\lambda_{t_2} = \bot$, we have $\sigma_{t_1} = \lambda_{t_1}$, and so if $\sigma$ does not change by time $t_2-1$ we have $\sigma_{t_2-1} = \lambda_{t_2-1}$, and thus $\sigma_{t_2} \neq \sigma_{t_2-1}$ by Claim \ref{claim:3}, so $\sigma$ changes in the interval $[t_1,t_2]$. Finally, if $\lambda_{t_1} = \bot$, then we must have $\lambda_{t_2} \in V$, and so $\lambda_{t_3} = \bot$. Then by the prior argument, $\sigma$ must change in the interval $[t_2,t_3]$. Thus, in each case, $\sigma$ must change in the interval $[t_1,t_3]$. To avoid double counting changes which occur on the boundary, letting $t_1,\dots,t_r$ be the sequence of all changes in $\lambda$, it follows that there is at least one change in $\sigma$ in each of the disjoint intervals $(t_{5i+1}, t_{5(i+1)})$ for $i=0,1,2,\dots,\lfloor r/5 \rfloor$. It follows that $\sum_t \cA_\pi^t \leq 5 \sum_t \cC_\pi^t$, which completes the proof. 
\end{proof}


The following theorem, due to \cite{behnezhad2019fully}, bounds the expected number of changes of eliminators which occur when a vertex is entirely removed or added to a graph. 


\begin{theorem}[Theorem 3 of \cite{behnezhad2019fully}]\label{thm:elimBound}
Let $G = (V,E)$ be any graph on $n$ vertices, and let $G' = (V',E')$ be obtained by removing a single vertex from $V$ along with all incident edges. Let $\pi: V \to [0,1]$ be a random mapping. Let $\cC_\pi(G,G') = \{v \in V | \elim_{G,\pi}(v) \neq \elim_{G',\pi}(v)\}$. Then we have $\mathbb{E}_\pi \left[|\cC_\pi(G,G')|\right] = O(\log n)$.
\end{theorem}



\begin{theorem} \label{thm:LFMISMain} There is a algorithm which, on a fully dynamic stream of insertions and deletions of vertices to a graph $G$, maintains at all time steps a top-$k$ LFMIS of $G$ with leaders (Definition \ref{def:LFMISLead}) under a random ranking $\pi: V \to [0,1]$. The expected amortized per-update time of the algorithm is $O(k \log n + \log^2 n)$, where $n$ is the maximum number active of vertices at any time. Moreover, the algorithm does not need to know $n$ in advance. 
\end{theorem}
\begin{proof}
By the above discussion, letting $T$ be as in Proposition \ref{prop:T}, we have $T \leq  M+  \sum_t \cA_\pi^t + \cB_\pi^t $. By the same proposition, the total update time of the algorithm over a sequence of $n$ updates is at most $O(T(k + \log n) + kM)$.  By Lemma \ref{lem:main}, we have $\sum_t \cA_\pi^t + \cB_\pi^t  \leq 6 \sum_t \cC^t_\pi$, and by Theorem \ref{thm:elimBound} we have $\mathbb{E}_\pi \left[\sum_t \cC^t_\pi\right] = O(M \log n)$. It follows that $\ex{T} = O(M \log n)$, therefore the total update time is $O(kM \log n + M \log^2 n)$, which completes the proof. 
\end{proof}

