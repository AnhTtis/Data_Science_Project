\subsection{Sketch of the BFGS-SQP algorithm in GRANSO}
\label{Sec:granso_summary} 
GRANSO is among the first optimization solvers targeting general non-smooth, non-convex problems with non-smooth constraints \cite{curtis2017bfgs}.

The key algorithm of the GRANSO package is a sequential quadratic programming (SQP) that employs a quasi-Newton algorithm, Broyden-Fletcher-Goldfarb-Shanno (BFGS) \cite{wright1999numerical}, and an exact penalty function (Penalty-SQP). 

The penalty-SQP calculates the search direction from the following quadratic programming (QP) problem:
\begin{align}
\label{penalty_sqp}
    \begin{split}
        \min_{\vd \in \RJU^n, \vs \in \RJU^p} \; & \mu \paren{f\paren{\vx_k} + \nabla f \paren{\vx_k}^{\TJU} \vd} \\
        + & \ve^{\TJU}\vs + \frac{1}{2} \vd^{\TJU} \mH_k \vd \\
        \st \; c \paren{\vx_k} + & \nabla c \paren{\vx_k}^{\TJU} \vd \leq \vs, \quad \vs \geq 0.
    \end{split}
\end{align}
Here, we abuse the notation $c(\cdot)$ to be the total constraints for simplicity (i.e., representing all $c$'s and $h$'s in \cref{eq:NO_form}).
The dual of problem (\cref{penalty_sqp}) is used in the GRANSO package:
\begin{align}
\label{penalty_sqp_dual}
    \begin{split}
        \max_{\vlambda\in\RJU^p} \; & \mu f (\vx_k) + c(\vx_k)^{\TJU}\vlambda \\
        & - \frac{1}{2} \paren{ \mu \nabla f (\vx_k) + \nabla c(\vx_k) \vlambda }^{\TJU} \mH_k^{-1} \\
        & \cdot \; \paren{ \mu \nabla f (\vx_k) + \nabla c(\vx_k) \vlambda } \\
        \st & \quad 0 \leq \vlambda \leq \ve,
    \end{split}
\end{align}
which has only simple box constraints that can be easily handled by many popular QP solvers such as OSQP (ADMM-based algorithm) \cite{osqp}.
Then the primal solution $\vd$ can be recovered from the dual solution $\vlambda$ by solving (\ref{penalty_sqp_dual}):
\begin{align}\label{searching_direction}
    \vd = - \mH_k^{-1} \paren{ \mu \nabla f (\vx_k) + \nabla c(\vx_k) \vlambda }.
\end{align}

The search direction calculated at each step controls the trade-off between minimizing the objective and moving towards the feasible region. To measure how much violence the current search direction will give, a linear model of constraint violation is used:
\begin{align}\label{contr_viol}
    l(\vd;\vx_k) \defeq \norm{\max\Brac{c(\vx_k)+\nabla c(\vx_k)^{\TJU}\vd,\bm{0}}}_{1}.
\end{align}

To dynamically set the penalty parameter, a steering strategy as \cref{alg:steering} is used:

\begin{algorithm}[!tb]
\caption{\\ \text{ } \quad \quad $\brac{\vd_k,{\mu}_{\text{new}}}= \texttt{sqp\_steering}(\vx_k,\mH_k,{\mu})$}
\label{alg:steering}
\begin{algorithmic}[1]
\Require $\vx_k, \mH_k,\mu$ at current iteration 
\Require constants $c_v\in(0,1),c_{\mu} \in (0,1)$ 
\State Calculate $\vd_k$ from \cref{searching_direction} and \formulation (\ref{penalty_sqp_dual}) with $\mu_{\text{new}} = \mu$
\If{$l_{\delta}(\vd_k;\vx_k)< c_v v(\vx_k)$}
\State Calculate $\tilde{\vd_k}$ from \cref{searching_direction} and \formulation (\ref{penalty_sqp_dual}) with $\mu=0$
\While{$l_{\delta}(\vd_k;\vx_k)< c_v l_{\delta}(\tilde{\vd_k};\vx_k)$}
\State $\mu_{new} \defeq c_{\mu} \mu_{\text{new} }$
\State Calculate $\vd_k$ from \cref{searching_direction} and \formulation (\ref{penalty_sqp_dual}) with $\mu=\mu_{\text{new}}$
\EndWhile
\EndIf 
\State \Return{$\vd_k,{\mu}_{\text{new}}$}
\end{algorithmic}
\end{algorithm}

For non-smooth problems, it is usually hard to find a reliable stopping criterion, as the norm of the gradient will not decrease when approaching a minimizer. GRANSO uses an alternative stopping strategy, which is based on the idea of gradient sampling \cite{lewis2013nonsmooth} \cite{burke2020gradient}.

Define the neighboring gradient information (from the $p$ most recent iterates) as:
\begin{align}
    \begin{split}
        & \mG \defeq \brac{\nabla f(\vx_{x_{k+1-l}})\hdots \nabla f(\vx_k)} \text{,}\\
    & \mJ_i \defeq \brac{\nabla c_i(\vx_{x_{k+1-l}})\hdots \nabla c_i (\vx_k)}\text{,} \\ & \; i \in \Brac{1,\hdots ,p}
    \end{split}
\end{align}

Augment \formulation (\ref{penalty_sqp}) and its dual \formulation (\ref{penalty_sqp_dual}) in the steering strategy, we can obtain the augmented dual problem:
\begin{align}\label{QP_termination}
    \begin{split}
        \max_{\vsigma\in \RJU^l, \vlambda\in \RJU^{pl}} 
        \sum_{i=1}^p & c_i(\vx_k)\ve^{\TJU} \vlambda_i  \\
        - \frac{1}{2} \begin{bmatrix} \vsigma \\ \vlambda \end{bmatrix}^{\TJU} \begin{bmatrix} \mG,\mJ_1,\hdots,\mJ_p \end{bmatrix}^{\TJU} & \mH_k^{-1} \begin{bmatrix} \mG,\mJ_1,\hdots,\mJ_p \end{bmatrix}\begin{bmatrix} \vsigma \\ \vlambda \end{bmatrix} \\
         \st \; \bm{0} \leq \vlambda_i \leq \ve, \quad & \ve^{\TJU}\vsigma = \mu, \quad \vsigma \geq \bm{0}
    \end{split}
\end{align}


By solving \cref{QP_termination}, we can obtain $\vd_{\diamond}$:
\begin{align}\label{d_diamond}
    \begin{split}
    &    \vd_{\diamond} = \mH_k^{-1} \begin{bmatrix} \mG,\mJ_1,\hdots,\mJ_p \end{bmatrix} \begin{bmatrix} \vsigma \\ \vlambda \end{bmatrix}
    \end{split}
\end{align}
If the norm of $\vd_{\diamond}$ is sufficiently small, the current iteration can be viewed as near a small neighborhood of a stationary point.

\begin{algorithm}[!tb]
\caption{$ \\ \text{ } \quad \quad \brac{ \vx_*,f_*,\vv_* } = \texttt{bfgs\_sqp}\paren{f(\cdot),\vc(\cdot), \vx_0, \mu_0})$ }
\label{alg:bfgs_sqp}
\begin{algorithmic}[1]
\Require $f,\vc,\vx_0,\mu_0$
\Require  constants $\tau_{\diamond},\tau_{v}$
\State $\mH_0 \defeq \mI,\ \mu \defeq \mu_0$
\State $\phi(\cdot) = \mu f(\cdot) + v(\cdot)$
\State $\nabla \phi(\cdot) = \mu \nabla f(\cdot) + \sum_{i \in \mathcal{P} } \nabla c_i(\cdot) $
\State $v(\cdot) = \norm{\max \Brac{c(\cdot),0}}_{1}$
\State  $\phi_0 \defeq \phi(\vx_0;\mu),\nabla \phi_0 \defeq \nabla \phi(\vx_0;\mu),v_0 \defeq v(\vx_0)$
\For {$k = 0,1,2,\hdots$}
\State $\brac{\vd_k,\hat{\mu}} \defeq \texttt{sqp\_steering}(\vx_k,\mH_k,\bm{\mu})$
\If{$\hat{\mu}< \mu$}
\State $\mu \defeq \hat{\mu}$
\State  $\phi_k \defeq \phi(\vx_k;\mu),\nabla \phi_k  \defeq \nabla \phi(\vx_k;\mu),v_k \defeq v(\vx_k)$
\EndIf
\State{$\brac{\vx_{k+1},\phi_{k+1}, \nabla \phi_{k+1}, v_{k+1} } \defeq \texttt{Armijo\_Wolfe}\paren{\vx_k,\phi_k,\nabla \phi_k, \phi(\cdot) , \nabla \phi(\cdot) } $}
\State Get $\vd_{\diamond}$ from \cref{d_diamond} and \formulation (\ref{QP_termination})
\If{$\norm{\vd_{\diamond}}_{2}< \tau_{\diamond}$ and $v_{k+1}<\tau_v$}
\State break
\EndIf
\State BFGS update $\mH_{k+1}$
\EndFor
\State \Return{$\vx_*,f_*,\vv_*$}
\end{algorithmic}
\end{algorithm}