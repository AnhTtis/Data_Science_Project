\begin{algorithmic}[1]
  \Statex \textbf{Given:} Mesh~$A$ and function $f^{(A)}(t)$ supported on
    mesh~$A$ at time $t$;
    time step length $\Delta t>0$,
    number of steps $n_\mathrm{adapt}\in\N_{+}$ for adaptivity intervals, and
    number of steps $n_\mathrm{pred}\in\N_{+}$ for prediction intervals.
  %
  \While {$t$ has not reached final time}
    \State $\Delta t_\mathrm{pred} = n_\mathrm{pred} \Delta t$
    \State $\Delta t_\mathrm{adapt} = n_\mathrm{adapt} \Delta t$
    %
    \State compute indicator $\indfn^{(A)}(t)$ from function $f^{(A)}(t)$ on mesh $A$
    \State leapfrog $\indfn^{(A)}(t)$ until $\indfn^{(A)}(t + \Delta t_\mathrm{pred})$
      \Comment \emph{(``fast'' scheme)}
    \State reduce $\indfn^{(A)}$ to predictive indicator
      $\indfn^{(A)}_\mathrm{pred}(t) =
        \max_{\tau\in[t, t+\Delta t_\mathrm{pred}]} \indfn^{(A)}(\tau)$
    \State create mesh $B$ by adapting mesh $A$ based on $\indfn^{(A)}_\mathrm{pred}(t)$
      \Comment \emph{(AMR)}
    \State interpolate $f^{(A)}(t)$ to $f^{(B)}(t)$ onto mesh $B$
    \State evolve $f^{(B)}(t)$ until $f^{(B)}(t + \Delta t_\mathrm{adapt})$
      \Comment \emph{(``accurate'' scheme)}
    \State update time step length $\Delta t$
      \Comment \emph{(adaptive time stepping)}
  \EndWhile
\end{algorithmic}
