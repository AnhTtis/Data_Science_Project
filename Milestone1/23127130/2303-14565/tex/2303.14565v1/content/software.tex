
\section{Software Description}
\label{sec: software description}
To execute analyses with Saihu, we roughly divide the tasks into 3 parts: describe a network to be analyzed; execute analyses with individual tools; and export reports back to the user. We will go through these 3 parts one by one.

\subsection{Network Description File}
\label{sec: network description file}
As mentioned in Section~\ref{sec: system model}, Saihu allows the user to write a network in either a \textit{physical network} or an \textit{output port network} format. While xTFA takes a physical network as an XML file and the others take an output port network as a JSON file, one can choose the format they prefer to define a network as Saihu automatically converts a file when needed. 

\subsubsection{Option 1: Defining Physical Network in XML}
\label{sec: physical network xml}
A physical network is written as an XML file according to the xTFA specification. It should at least contains 4 kinds of information: \textbf{General network information}, \textbf{Servers}, \textbf{Links}, and \textbf{Flows}.

Let's take the implementation of Figure \ref{fig: physical network} as an example. First, every entry should be enclosed in one element \texttt{<elements>} as shown in Listing~\ref{lst: xml elements}.

\begin{lstlisting}[language=XML,caption={Examples of XML file. All network entries must inside an element \texttt{<elements>}.},
label={lst: xml elements}]
<?xml version="1.0" encoding="UTF-8"?>
<elements>
    <!-- All entries -->
</elements>
\end{lstlisting}

A physical network must have exactly one \texttt{network} element to define general information across the network as its attributes, an example is shown in Listing~\ref{lst: xml network}. In this example, \texttt{name} is the name of the network, \texttt{technology} is a series of analysis parameters concatenated by the plus sign, and a default value of \texttt{minimum-packet-size}. 

\begin{lstlisting}[language=XML,caption={Example of general network information. Contains \texttt{name}, \texttt{technology} used, and default values for other elements.},label={lst: xml network}]
<network name="demo" technology="FIFO+IS" 
    minimum-packet-size="4B"/>
\end{lstlisting}

The attribute \texttt{technology} takes the following values. More may be found from~\cite{thoma2022analyse}.
\begin{itemize}[leftmargin=1em]
    \item \texttt{FIFO}: FIFO multiplexing. It can be \texttt{ARBITRARY} for arbitrary multiplexing or left blank for tool default.
    \item \texttt{IS}: Input shaping. Consider the shaping effect.
    \item \texttt{PK}: Packetizer.
    \item \texttt{CEIL}: Fix precision when calculating network with cyclic dependency (used only in xTFA.)
\end{itemize}
One can also define some default values that possibly appear in other elements. For example, a \texttt{minimum-packet-size} is usually defined as an attribute of a \texttt{flow} element, while this value defined in the \texttt{network} element will be used as the default value if it's not defined in a \texttt{flow} element.

Second, the servers of the network can be defined as either a \texttt{station} or a \texttt{switch}, as shown in Listing~\ref{lst: xml server}. Although they are very different physically, in our tools they both mean data processing units or possible sources/sinks of a data flow.

\begin{lstlisting}[language=XML,caption={Stations and switches. Name and possibly the default values to all its ports.},label={lst: xml server}]
<station name="src0"/>
<station name="src1"/>
<station name="src2"/>
<switch name="s0" service-latency="10us"
    service-rate="4Mbps"/>
<switch name="s1" service-latency="10us" 
    service-rate="4Mbps"/>
<station name="sink0"/>
<station name="sink1"/>
\end{lstlisting}

Both a station and a switch represent a physical node. The name of each node will be used to define flow paths and links. The \texttt{service-latency} and \texttt{service-rate} define a rate-latency service curve. The service parameters defined at this level serve as default values for all the links attached as outputs of this node.

Third, one must connect physical nodes with \texttt{link}s, as shown in Listing \ref{lst: xml link}. Saihu considers output ports as processing units, so the physical link \texttt{from} a physical node \texttt{to} another node has to be defined, along with the input/output ports used by the link. For example, the link \texttt{lk:s0-s1} connects from the output port \texttt{o0} of switch \texttt{s0} to the input port \texttt{i0} of switch \texttt{s1}.

\begin{lstlisting}[language=XML,caption={Links connecting ports.},label={lst: xml link}]
<link name="lk:src0-s0" from="src0" to="s0" 
    fromPort="o0" toPort="i0"/>
<link name="lk:src1-s0" from="src1" to="s0"
    fromPort="o0" toPort="i1"/>
<link name="lk:src2-s0" from="src2" to="s1" 
    fromPort="o0" toPort="i1"/>
<link name="lk:s0-s1" from="s0" to="s1"
    fromPort="o0" toPort="i0" 
    transmission-capacity="10Mbps"/>
<link name="lk:s1-sink0" from="s1" to="sink0" 
    fromPort="o0" toPort="i0" 
    transmission-capacity="10Mbps"/>
<link name="lk:s1-sink1" from="s1" to="sink1" 
    fromPort="o1" toPort="i0" 
    transmission-capacity="10Mbps"/>
\end{lstlisting}

If the service of an output port needs to be considered in an analysis, one must define the service curve at the link that is directly attached to the output port. The \texttt{transmission-capacity} of the link can also be specified to consider line shaping. If no values are defined, the system tries to apply the default values defined at the upper levels, i.e. \texttt{switch/station} and \texttt{network}. Furthermore, if no values are found across all levels, the link is considered a dummy one and the output port attached to it will not be considered.

Finally, one must define \texttt{flow}s for the network as shown in Listing \ref{lst: xml flow}. Each flow is defined by a \texttt{flow} element. The paths of a flow are defined by \texttt{target} elements, where each node it traverses is listed as \texttt{path} elements with its \texttt{node} attribute indicating the name of the physical node. In this format, multicast of a flow is possible by defining multiple \texttt{target} elements within the same flow.

\begin{lstlisting}[language=XML,caption={Flows. Must have a name and its arrival curve parameters along with its paths.},label={lst: xml flow}]
<flow name="f0" arrival-curve="leaky-bucket" 
    lb-burst="10B" lb-rate="10kbps" 
    maximum-packet-size="50B" source="src0">
    <target>
        <path node="s0"/>
        <path node="s1"/>
        <path node="sink0"/>
    </target>
</flow>
<flow name="f1" arrival-curve="leaky-bucket" 
    lb-burst="10B" lb-rate="10kbps" 
    maximum-packet-size="50B" source="src1">
    <target>
        <path node="s0"/>
        <path node="s1"/>
        <path node="sink1"/>
    </target>
</flow>
<flow name="f2" arrival-curve="leaky-bucket" 
    lb-burst="10B" lb-rate="10kbps" 
    maximum-packet-size="50B" source="src2">
    <target>
        <path node="s1"/>
        <path node="sink0"/>
    </target>
</flow>
\end{lstlisting}

A flow element must have \texttt{name} and the arrival curve specified as its attributes. The keywords \texttt{arrival-curve}, \texttt{lb-burst} and \texttt{lb-rate} define a leaky-bucket curve at the source of the flow. Other parameters like the \texttt{maximum-packet-size} and \texttt{minimum-packet-size} can be also defined to consider packetization. Furthermore, as the definition represents a physical network, each flow must have a data \texttt{source} that is an actual physical node. All the output ports involved in its path, including the output port of the source, will be analyzed by Saihu.


\subsubsection{Option 2: Defining Output Port Network in JSON}
While the XML file syntax is provided by xTFA, we design this JSON format ourselves in order to write an output port network in a concise way.
The file should at least contains 3 kinds of information: \textbf{General network information}, \textbf{Servers}, and \textbf{Flows}. Let's take the implementation of Figure \ref{fig: output port network} as an example. First, all entries must be enclosed as a single JSON object (one \{\} to enclose all attributes.)

A \texttt{network} object is required to define general network information but only the \texttt{name} attribute is necessary. An example is shown in Listing \ref{lst: json network}.


\begin{lstlisting}[language=json,caption={Network information. Contains some general information and default values or units used throughout the file.},label={lst: json network}]
"network": {
    "name": "demo",
    "packetizer": false,
    "multiplexing": "FIFO",
    "analysis_option": ["IS"],
    "time_unit": "us",
    "data_unit": "B",
    "rate_unit": "Mbps",
    "min_packet_length": "4B"
}
\end{lstlisting}
\lstsetblack

The 3 keywords \texttt{packetizer}, \texttt{multiplexing}, and \texttt{analysis\_option} are unique to the \texttt{network} object. \texttt{packetizer} is equivalent to the keyword \texttt{PK} in XML file; \texttt{multiplexing} can be either \texttt{FIFO} or \texttt{ARBITRARY}; and \texttt{analysis\_option} takes other keywords defined in \texttt{technology} mentioned in Section \ref{sec: physical network xml}.

Except for the network options, default values for servers and flows can also be defined at the network level. In the above example, we set the default time/data/rate units to be microsecond/byte/megabits-per-second across the file as well as the minimum packet length being 4 bytes.

Second, we need to define the \texttt{servers} for the network. Some may argue the term \textit{server} instead of \textit{output port} as we discussed in Section~\ref{sec: output port network}. The term \textit{server} is a general term for a processing unit, and one can treat it as a black box that provides service.

The \texttt{servers} is presented as a JSON array, each object in this array is a server. Each server must at least have a \texttt{name}, and its service curve can be missing only when there exists a default value in \texttt{network} attribute. 
The parameters can be expressed in either a \textit{string} or a \textit{number}. A string is written as a number followed by a unit. For example, \texttt{"10us"} means 10 microseconds, and \texttt{"50Mbps"} means 50 megabits per second. If it's directly written as a number, the unit defined in the closest level is used. For example, the time unit defined in server \texttt{s1-o0} is microsecond, so the latency 10 is read as 10 microseconds. 

The object \texttt{service\_curve} takes multiple rate-latency curves and uses the maximum among all these curves as its service curve. Rates and latencies are written as arrays, each pair of rate and latency values with the same index is a rate-latency curve. For example, in server \texttt{s0-o0}, the service curve has 2 segments defined by 2 rate-latency curves, one with a latency of 10 microseconds and a rate of 4 megabits per second, and the other with a latency of 1000 microseconds and a rate of 50 megabits per second.

Notice that in an output port network definition, we don't manually define links. The topology of the network is considered to be the \textit{graph induced by flows}, i.e. a connection from server \textit{A} to \textit{B} exists only when there is at least one flow travels through \textit{B} from \textit{A}. Therefore, the transmission capacity of the link attached to an output port is directly defined on a server with the keyword \texttt{capacity}.

\begin{lstlisting}[language=json,caption={Servers. A list that contains many servers, each with name and service parameters.},label={lst: json server}]
"servers": [
    {
        "name": "s0-o0",
        "service_curve": {
            "latencies": ["10us", 1000],
            "rates": [4, "50Mbps"]
        },
        "capacity": 100
    },
    {
        "name": "s1-o0",
        "service_curve": {
            "latencies": [10, "1ms"],
            "rates": [4, 50]
        },
        "capacity": 100,
        "time_unit": "us"
    },
    {
        "name": "s1-o1",
        "service_curve": {
            "latencies": [10],
            "rates": ["4Mbps"]
        },
        "capacity": 100
    }
]
\end{lstlisting}
\lstsetblack

Finally, the \texttt{flows} are defined in a similar manner as servers as shown in Listing~\ref{lst: json flow}. Each object must have at least a \texttt{name} and a \texttt{path}. A path is represented as an array of server names, and the order in the list represents the sequence that the flow visits.

The representation of values and units is the same as servers, either being a string of a number with units, or a number that uses the default unit.
The arrival curve at the source of a flow is defined by multiple token-bucket curves and taken as the minimum among all these curves. Similar to the service curve of a server, each pair of a burst and a rate value represent a token-bucket curve. For example, the arrival curve of \texttt{f0} has one token-bucket curve of burst 10 bytes and rate 10 kilobits per second, and the other curve of burst 2 kilobytes and rate 0.5 megabits per second.

\begin{lstlisting}[language=json,caption={Flows. A list contains many flows. Each flow contains name, path, and parameters of the arrival data.},label={lst: json flow}]
"flows": [
    {
        "name": "f0",
        "path": ["s0-o0", "s1-o0"],
        "arrival_curve": {
            "bursts": [10, "2kB"],
            "rates": ["10kbps", 0.5]
        },
        "max_packet_length": 50,
        "rate_unit": "kbps"
    },
    {
        "name": "f1",
        "path": ["s0-o0", "s1-o1"],
        "arrival_curve": {
            "bursts": ["10B"],
            "rates": ["10kbps"]
        },
        "max_packet_length": 50
    },
    {
        "name": "f2",
        "path": ["s1-o0"],
        "arrival_curve": {
            "bursts": [10],
            "rates": ["10kbps"]
        },
        "max_packet_length": "50B",
        "min_packet_length": "4B"
    }
]
\end{lstlisting}
\lstsetblack

\subsection{Tool Usage}
In this section, we briefly introduce how to use Saihu to execute analyses. One would only need to import one file, i.e. \textit{interface.py}, to use Saihu given that the project is installed correctly. 
The simplest way to use Saihu is shown in Listing~\ref{lst: simple example}. Once a network description file is available as either an XML or a JSON file, one can execute the following example to do the analysis.

\begin{lstlisting}[style=pythonstyling,caption={Simple example to use Saihu.},label={lst: simple example}]
from interface import TSN_Analyzer
analyzer = TSN_Analyzer("demo.json")
analyzer.analyze_all()
analyzer.export("demo")
\end{lstlisting}

The basic procedure to use Saihu is as follows: 1. initialize the analyzer with a target network description file; 2. execute the analysis with some tools; 3. export the results into reports. 

The supported tools and methods are listed in Figure~\ref{fig: supported methods}. 
To switch between different tools, one uses different functions with names like \texttt{analyze\_xxx}, where \texttt{analyze\_all} means to use all the available tools. To switch methods, one gives different input arguments to each analysis function. An example is provided in Listing~\ref{lst: switch tool and method}. One can execute multiple analyses and all the results will be stored in the internal buffer of the analyzer until the analyzer exports them into reports. 
% The default setting is to try to execute \textit{TFA, SFA} and \textit{PLP}.

\begin{lstlisting}[style=pythonstyling,caption={Execute different tools and methods.},label={lst: switch tool and method}]
analyzer.analyze_dnc()
analyzer.analyze_xtfa("TFA")
analyzer.analyze_panco(methods=["SFA", "PLP"])
\end{lstlisting}


\subsection{Analysis Reports}
\label{sec: analysis reports}

\begin{figure*}[tbh]
\centering
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{e2e_delay.png}
    \caption{Flow end-to-end delay}
    \label{fig: e2e delay}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{server_delay.png}
    \caption{Server delay}
    \label{fig: server delay}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=0.9\linewidth]{exec_time.png}
    \caption{Execution time}
    \label{fig: exec time}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=0.8\linewidth]{report_topo.png}
    \caption{Network topology}
    \label{fig: network topology}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=0.6\linewidth]{report_path.png}
    \caption{Flow paths}
    \label{fig: flow path}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[width=0.9\linewidth]{report_util.png}
    \caption{Link utilization}
    \label{fig: link utilization}
\end{subfigure}
\caption{Human-friendly report. It is written as a Markdown file. The analysis results include the flow end-to-end delay, server delay, and execution time. The values are listed in tables for each tool and method as shown in (a)(b)(c). The units are adjusted accordingly. It also contains input information like the network topology, paths of flows, and link utilization.}
\label{fig: human friendly report}
\end{figure*}

Saihu can generate 2 reports, a \textit{human-friendly report} and a \textit{machine-friendly report}. A human-friendly report is written as a Markdown file that lists all the essential information. An example is shown in Figure~\ref{fig: human friendly report}. The analysis results are listed in 3 sections: per-flow end-to-end delay, per-server delay, and execution time. The delay bounds are presented in tables where each row is a flow or a server, and each column is a method executed by a tool. The last column contains the minimum result obtained in the current round of analysis. The execution time of each method by each tool is also listed for comparison.

Other than the analysis results, the report also contains some information about the user inputs, but in a more formatted manner. They are network topology, flow paths, and link utilization. Network topology is shown as a graph induced by flows. i.e. It's a directed graph where each node is an output port, and an edge from node A to B exists if there's at least one flow traversing from A to B. Flow paths are the same as the network description file, it can serve as a reassurance of user's input. Link utilization is computed node-wise, it is defined as the ratio between the aggregated arrival rate at a node and its service rate. e.g. If 2 flows have arrival rates of $2kbps$ and $3kbps$ respectively filling into a node, which has a service rate of $10kbps$. The link utilization at the node is therefore $(2+3)/10=0.5$.

A \textit{machine-friendly report} stores only the execution outputs, namely the per-flow end-to-end delay, per-server delay, and execution time. It's written in JSON format for easy parsing from other programs. An example is presented in Listing \ref{lst: machine friendly report}.
\begin{lstlisting}[language=json,caption={Machine-friendly report. The flow end-to-end delays, server delays, and execution time are listed in pure numbers. The units these numbers use are also listed as one entry.},label={lst: machine friendly report}]
{
    "name": "demo",
    "flow_e2e_delay": {
        "f0": {
            "Panco_TFA": 100.12500000000001,
            "Panco_PLP": 80.05,
            "DNC_TFA": 100.00375,
            "xTFA_TFA": 99.32394489448944
        },
...
    "server_delay": {
        "s0-o0": {
            "Panco_TFA": 50.0,
            "DNC_TFA": 50.0,
            "xTFA_TFA": 50.0
        },
...
    "execution_time": {
        "Panco_TFA": 62.70909309387207,
        "Panco_PLP": 243.81709098815918,
        "DNC_TFA": 32.0,
        "xTFA_TFA": 81.46500587463379
    },
    "units": {
        "flow_delay": "us",
        "server_delay": "us",
        "execution_time": "ms"
    }
}
\end{lstlisting}
\lstsetblack

In order to let users parse the information easily, Saihu prints the results in numbers, accompanied by the units used in each section. Note that the human-friendly report always contains only 3 decimal digits according to the smallest value in the table, while there's no such rounding for the machine-friendly report. As a result, one should read the machine-friendly report if they require very precise results.


\subsection{Network Generation}
\label{sec: network generation}
Saihu provides a series of functions to allow users to generate certain types of networks into a network description file. Currently, Saihu supports the generation of interleave tandem, mesh, and ring network. They contain specific topologies and routing rules for the flow paths. Users have the freedom to choose the size of the network (number of servers), the service parameters of servers, and the flow parameters of data arrival. The way these parameters are used within each type of network is specified in the respective sections.

Other than the predetermined routing rules, Saihu also provides a function to generate an arbitrary number of flows with random routing. This is particularly suitable for testing the possible traffic with a specific topology. More details will be shown in Section~\ref{sec: fixed topology random}.

\subsubsection{Interleave Tandem Network}
Suppose we wish to generate a network of $n$ servers, indexed from $0$ to $n-1$.
An interleave tandem network has all its servers chained in a line. One flow $f_0$ goes through all servers from $s_0$ to $s_{n-1}$.  The flow $f_i$ is $s_{i-1} \rightarrow s_{i}$ for $i \in [1,n-1]$. Illustrated by Figure \ref{fig: interleave}. All the flows have identical arrival curves and maximum packet length at the source, defined by function arguments \texttt{burst}, \texttt{arrival\_rate}, and \texttt{max\_packet\_length}. Likewise, All the servers have identical service curves and transmission capacity, defined by \texttt{latency}, \texttt{service\_rate}, and \texttt{capacity}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/interleave.png}
    \caption{Interleave tandem network}
    \label{fig: interleave}
\end{figure}

\subsubsection{Ring Network}
A ring network is illustrated in Figure \ref{fig: ring}. There are $n$ flows and $n$ servers. The path of flow $i$ is $s_i \rightarrow s_{i+1} \rightarrow \cdots \rightarrow s_{i+n-1\mod n}$ for $0 \leq i \leq n-1$. A ring network is completely symmetrical with all its flows and servers being identical. All flows are defined by \texttt{burst}, \texttt{arrival\_rate}, and \texttt{max\_packet\_length}. Similarly, all servers are defined by \texttt{latency}, \texttt{service\_rate}, and \texttt{capacity}.

\begin{figure}
    \centering
    \includegraphics[width=0.6\linewidth]{images/ring.png}
    \caption{Ring network}
    \label{fig: ring}
\end{figure}

\subsubsection{Mesh Network}
A mesh network is illustrated in Figure~\ref{fig: mesh}. All flows start from either $s_0$ or $s_1$. The flows go through all $2^{(n-1)/2}$ possible combinations of servers towards the right. e.g. $s_0 \rightarrow s_2 \rightarrow \cdots$ and $s_1 \rightarrow s_2 \rightarrow \cdots$ are both in the network. All servers have the same service curve and capacity except $s_{n-1}$ has the doubled service rate. All flows have identical service curves and maximum packet length.

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{images/mesh.png}
    \caption{Mesh network. Only parts of the flows from $s_0$ are shown. There is a flow for every possible path from $s_0$ or $s_1$ to $s_{n-1}$.}
    \label{fig: mesh}
\end{figure}

\subsubsection{Fixed-Topology Random Routing Network}
\label{sec: fixed topology random}

It's also possible to randomly generate a network defined as a JSON file with a fixed topology of switches. Users have the freedom to decide the number of flows, the topology of switches, and the service/arrival parameters. Each flow randomly routes from one switch to another without repeating the visited switch. We will show more details and use it as an example in Section~\ref{sec: example}.

% A user provides a fixed number of flows to be generated and a connection table along with service parameters and data arrival parameters, then a possible configuration of the network will be generated. A user can also specify the parameters in a range so that they will be uniformly generated within the range.

% We use Figure \ref{fig: industrial network} as an example in Section \ref{sec: example}.

\subsection{Extension}
\label{sec: extension}

As we showed in Figure~\ref{fig: pipeline}, Saihu uses XML/JSON files as a common input and a general information container class as a common output for all the tools. This means to incorporate more tools into Saihu, one only needs to allow the new tool to parse one of the network description formats and feed the analysis results into the information container class. By doing so, they can keep other parts of Saihu untouched and only need to manage one tool at a time.

Moreover, it's also possible to include more network description formats. Because the two formats Saihu uses currently can convert to each other, one only has to make sure a new format can be converted to and from one of the formats Saihu supports. We believe this approach can help more people contribute to and expand Saihu in the future.