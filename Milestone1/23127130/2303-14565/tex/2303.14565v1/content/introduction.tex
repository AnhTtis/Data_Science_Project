\section{Introduction}
\label{sec: introduction}
The analysis of worst-case delay for a network is inherently crucial for many network applications, the metric is especially important to provide good Quality-of-Service (QoS) guarantees. One example to demonstrate the importance of network performance guarantee is the IEEE 802.1 standards on \textit{Time-Sensitive Networking} \cite{ieee2020tsn}.
Consequently, many models are proposed to capture the essence of a networked system. \textit{Network Calculus} \cite{ncbook2001leboudec} is one of the very powerful frameworks providing deterministic performance guarantees of a network.

Because of the effectiveness of network calculus, many methods are developed to derive service guarantees for many scenarios. Research teams around the globe have developed a series of analysis tools, i.e. software programs, to automate various analysis methods. 
To the best of the authors' knowledge\footnote{List from \url{https://en.wikipedia.org/wiki/Network_calculus}}, the existing research or industrial network analysis tools related to network calculus are DiscoDNC \cite{bondorf2014discodnc, scheffler2021fifo}, RTC Toolbox \cite{bouillard2009service, thiele2000realtime}, CyNC \cite{schioler2007cync}, RTaW-PEGASE \cite{migge2011pegase}, WoPANets \cite{mifdaoui2010wopanets}, DelayLyzer \cite{schmidt2014delaylyzer}, DEBORAH \cite{bisti2010deborah}, NetCalBounds \cite{bouillard2015exact, bouillard2016tight}, NCBounds \cite{bouillard2019stability}, Siemens Network Planner (SINETPLAN) \cite{kerschbaum2016profinet},
xTFA \cite{thoma2022analyse}, and Panco \cite{bouillard2022tradeoff}.

% For example, DNC \cite{bondorf2014discodnc, scheffler2021fifo}, DEBORAH \cite{bisti2010deborah}, xTFA \cite{thoma2022analyse}, Panco \cite{bouillard2022tradeoff}, etc. 

Each tool is implemented differently and possesses different strengths and weaknesses, so oftentimes researchers would like to compare the analysis results from individual tools as they may derive very different delay bounds for a network. We choose DNC, xTFA, and Panco as the first 3 tools included in Saihu. We choose DNC because it's already been used by many academic groups and includes several RTC functionalities, and it's also well-maintained and open-source. xTFA and Panco are chosen because they provide state-of-the-art methods to analyze a network with tighter bounds while being open-source at the same time. Meanwhile, we do not include tools like CyNC and DEBORAH as they are gradually out-of-date and lacking maintenance. RTaW-PEGASE, DelayLyzer, WoPANet, and SINETPLAN are private, so we don't have access to their tools. Finally, Panco should provide better or equal results when compared to NetCalBounds and NCBounds.

When multiple tools are used to analyze a network, they often come in different specifications and sometimes even in a different programming language. This causes great inconvenience for researchers as they need to constantly be aware of all the details of each tool and potentially switch programming environments to be able to use them. We believe most of the efforts spent here are mechanical and should not bother researchers.
% This causes great inconvenience for researchers to use these tools.
As a result, the purpose of Saihu is to simplify the whole process. Users can execute analyses and compare the results from each tool easily with a single interface and simple commands.


The name ``Saihu'' comes from ``\textbf{S}uperimposed worst-case delay \textbf{A}nalysis \textbf{I}nterface for \textbf{H}uman-friendly \textbf{U}sage.'' It's also inspired by the Taiwanese word \begin{CJK*}{UTF8}{bkai}師傅\end{CJK*} (sai-hū), which means a master, an expert, or a qualified worker. The idea behind the name is when someone uses Saihu, it provides them the sense of consulting an expert. One only needs to describe their problem intuitively, ``Saihu'' takes care of all the miscellanies for you and only provides the essential information.  


\subsection{Motivation}
Although there are abundant network analysis tools available for any potential network researchers, using these tools can still require quite some effort for the researchers.

First, learning to use a new tool can be troublesome. The level of complication varies by the complexity of the tool, one's familiarity with the programming language, and the quality of the tool's documentation. One may find themselves spending hours or days only to find the correct way to call the right commands.
Second, re-implementing the same network with different tools is not only tedious but also error-prone. No one surely likes to go through the learning and implementation process over and over again just to see if there's any difference given from other tools. Besides, one has to be careful when switching tools to make sure the implementations correspond to the same network and not accidentally obtain an incorrect result by misusing one command.

Previously, to analyze a network, one must install each tool individually; learn its specifications and syntax through many examples and long documentation; and format the analysis result to read. When switching to another tool, they would need to repeat the whole procedure. Moreover, because the input information of each tool, i.e. the way to define a network, varies significantly across tools, a user does not merely rewrite the same network in a different programming language but oftentimes has to redefine it in another network model.

% Take the 3 tools Saihu includes for example: to analyze with xTFA, one installs the Python package, defines their network as an XML file with respective syntax, implements their analysis in Python code, and calls the correct method to extract the delay bounds. To analyze with DNC, one sets up the correct Java version, defines their network and implements analysis in Java using DNC syntax, and extracts the result. To analyze with Panco, one install \textit{lpsolve} \cite{lpsolve} along with the Panco package in Python, defines the network and Implements using Panco syntax, and extracts the result. Then, if one would like to compare the results, one may need to format the results obtained from each tool by themself so that they are comparable.

Take the 3 tools Saihu includes for example: to analyze with xTFA, one installs the Python package, defines their network as an XML file with respective syntax, implements their analysis in Python code, and calls the correct method to extract the delay bounds. To analyze with DNC,  defines their network and implements analysis in Java using DNC syntax, and extracts the result. To analyze with Panco, one defines the network and Implements using Panco syntax, and extracts the result. Then, if one would like to compare the results, one may need to format the results obtained from each tool by themself so that they are comparable.

% Without Saihu, one must always get through such difficulty no matter how simple one's target network would be. Take xTFA and DNC for example, xTFA was implemented in Python, and DNC was implemented in Java. One has to learn to define a network, analyze it, and interpret the result with their respective syntax. Moreover, the documentation of each tool is already worth another paper. Not to mention you may end up reading a lot of detailed functions that you may not use.

% \TBD{We still need to install  Java to use DNC for example, perhaps we need to do a more precise link with previous paragraph and emphasize more on the input file than on the java installation}

Saihu aims at eliminating all the unnecessary complexities for network analysis. One only has to install and learn the interface once, define their network once, and implement their analysis with a very limited amount of code. Saihu also handles the analysis results and formats them to be easily readable.
We believe the excellent mind of network researchers should focus on the insight from the data instead of the minor details while using these tools.


\subsection{Contribution}

\begin{figure*}[tbh]
\centering
\includegraphics[width=0.7\linewidth]{pipeline.png}
\caption{Pipeline of Saihu. Red represents the user options; blue is for our contribution; green is for the existing tools; and yellow is for the potential extension of Saihu for more tools. Saihu automates all the programming details in the middle and demands only a few commands listed on the right.}
\label{fig: pipeline}
\end{figure*}


Our main contribution is that we built a common interface that can execute multiple analysis tools at once. Figure~\ref{fig: pipeline} demonstrate the pipeline of our work. In short, we encapsulate the originally separated inputs and outputs of each tool with extra layers, allowing a single interface to execute multiple tools. A common output for tools also allows Saihu to generate formatted reports automatically. Moreover, because we separate ``defining a network" from any specific programming language, we can simplify the definition and provide a more straightforward way to describe a network.

Let's follow Figure~\ref{fig: pipeline} from the bottom up. Let's say we have a network to be analyzed. First, we have 2 options. Because Saihu provides several network generation functions for certain types of networks, we can generate our network with a single command. If our network cannot be generated with any of the generation functions, we can choose to define our network as either an XML or a JSON file with respective syntax. Then Saihu takes care of the internal conversion and executes the tools. Saihu uses the XML file for xTFA if it's available or converts one from the JSON file. For DNC and Panco, Saihu reads the description from the JSON file and converts them into the original syntax required by DNC and Panco. If a JSON file is not available, it would be converted from the XML file. The execution of xTFA and Panco is direct Python commands, but since DNC is in Java, Saihu spawns a Java subprocess to execute DNC. After the tools execute their analyses internally, the analysis results are then automatically fed into a general \textit{result information container} class. Users can choose to either export a human-friendly report or a machine-friendly report, or both. We list the commands required to obtain analysis results on the right, one can see that all the programming details in the middle are handled automatically and a Saihu user only needs to give the essential commands.

Furthermore, as we provide the general inputs and outputs, it would be easy to include more tools for Saihu in the future. By providing methods to allow the new tool to read one of the network description formats and feeds the result into the result container, any new tool developer can fit their tool into the Saihu framework.

To sum up, Saihu accomplishes the following:
\begin{itemize}[leftmargin=1em]
\item Allow users to define a network regardless of the tools of their choice.
\item Allow easy generation of certain types of networks.
\item Automate conversion between network description files.
\item Translate network information and execute analyses for each tool.
\item Export the analysis results into formatted reports automatically.
\end{itemize}

%One can define their network in XML or JSON formats, which are independent of platform or programming language. This approach not only prevents users from re-implementing the same network multiple times but also allows us to provide a more intuitive way of defining a network. We also provide several network generation functions for certain types of networks to prevent users from writing all the details by themselves for trivial networks. We do this to reduce the required effort from users as much as possible.

%Moreover, Saihu is capable of automatically generating formatted reports. We provide 2 reports, one is easy for users to read directly and the other is easy for another program to parse if any further processing or analysis is required.
