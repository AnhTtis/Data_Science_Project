% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage[colorlinks=true,linkcolor=black,citecolor=blue,urlcolor=blue,]{hyperref}
\usepackage[doipre={doi:~}]{uri}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[table,xcdraw]{xcolor}
\usepackage{booktabs}
\usepackage[misc]{ifsym}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
% \title{Iteratively Coupled Patch Embedding and Bag Classification for Multiple Instance Learning on Whole Slide Images}
\title{Iteratively Coupled Multiple Instance Learning from Instance to Bag Classifier for Whole Slide Image Classification}
%
\titlerunning{Iteratively Coupled Multiple Instance Learning}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Hongyi Wang\inst{1} \and
Luyang Luo\inst{2} \and
Fang Wang\inst{3} \and
Ruofeng Tong\inst{1,4} \\
Yen-Wei Chen\inst{1,4,5} \and
Hongjie Hu\inst{3} \and
Lanfen Lin\inst{1} \and
Hao Chen\inst{2,6}$^{(\scriptsize\textrm{\Letter})}$}
%
\authorrunning{H Wang et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
\institute{College of Computer Science and Technology, Zhejiang University, Hangzhou, China \and
Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong, China \and
Department of Radiology, Sir Run Run Shaw Hospital, Hangzhou, China \and
Research Center for Healthcare Data Science, Zhejiang Lab, Hangzhou, China \and
College of Information Science and Engineering, Ritsumeikan University, Kusatsu, Japan \and
Department of Chemical and Biological Engineering, The Hong Kong University of Science and Technology, Hong Kong, China \\
\email{jhc@cse.ust.hk}
}

%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
% Whole slide image (WSI) classification is a challenging task due to their very high resolution and the lack of fine-grained labels. Currently, classification for WSIs is usually formatted as a Multiple Instance Learning (MIL) problem when only slide-level labels are available. 
% % To reduce the computational cost, existing MIL methods usually embed the patches (i.e., the instances) in a WSI (i.e., the bag) into feature vectors through a pre-trained feature extractor. Without patch-level labels, feature extractor cannot be fine-tuned and thus may generate imperfect representations for the instances.  
% MIL methods generally consists of a patch embedding process and a bag-level classification process, and they cannot be trained end-to-end due to high computational cost. Such training scheme blocks patch embedder's access to the slide-level labels, and brings inconsistency into the entire MIL pipeline. To address this problem, we propose to bridge the loss back-propagation process from the bag level classifier to the patch embedder with a novel framework called Iteratively Coupled Multiple Instance Learning (ICMIL). In ICMIL, we propose to use the category information in the bag-level classifier to guide the patch-level fine-tuning of the patch feature extractor. Then, the refined extractor can be used to generate better instance representations for achieving a better bag-level classifier in return. In this way, patch embedder and bag classifier can be coupled together at a low cost, and the entire MIL classification model can benefit from the information exchange between the two processes. We have tested our framework on two datasets with three different backbones. The experimental results show that our framework can consistently improve the performance of different MIL methods. 

% By ChatGPT:
Whole Slide Image (WSI) classification remains a challenge due to their extremely high resolution and the absence of fine-grained labels. Presently, WSIs are usually classified as a Multiple Instance Learning (MIL) problem when only slide-level labels are available. MIL methods involve a patch embedding process and a bag-level classification process, but they are prohibitively expensive to be trained end-to-end. Therefore, existing methods usually train them separately, or directly skip the training of the embedder. Such schemes hinder the patch embedder's access to slide-level labels, resulting in inconsistencies within the entire MIL pipeline. To overcome this issue, we propose a novel framework called Iteratively Coupled MIL (ICMIL), which bridges the loss back-propagation process from the bag-level classifier to the patch embedder.
In ICMIL, we use category information in the bag-level classifier to guide the patch-level fine-tuning of the patch feature extractor. The refined embedder then generates better instance representations for achieving a more accurate bag-level classifier. By coupling the patch embedder and bag classifier at a low cost, our proposed framework enables information exchange between the two processes, benefiting the entire MIL classification model. We tested our framework on two datasets using three different backbones, and our experimental results demonstrate consistent performance improvements over state-of-the-art MIL methods.
Code will be made available upon acceptance.

\keywords{Multiple Instance Learning \and Whole Slide Image \and Deep Learning.}
\end{abstract}
%
%
%
\section{Introduction}
% \subsection{A Subsection Sample}

% Nowadays, whole slide scanning is more and more widely used to visualize the tissue samples in disease diagnosis and pathological researches. Comapred with traditional microscope-based observation, whole slide scanning can convert glass slides into gigapixel digital images for convenient storage and further analysis. However, the high resolution of WSIs also makes the automated classification of them become very challenging. A common solution to this problem is patch-based classification \cite{cvpr2016em,chen2022deep}. Patch-based classification predicts the slide-level label by firstly predicting the labels of tiled small patches in a WSI. In this way, most existing image classification models can be directly applied, but at the cost of extra patch-level labeling. Unfortunately, patch-level labeling by histopathology experts is very expensive and time-consuming. Therefore, many weak-supervised \cite{cvpr2016em,zhang2018whole} and semi-supervised \cite{cheng2022deep,chen2022deep} methods have been proposed to generate patch-level pseudo labels at a low cost. However, the lack of reliable supervision directly hinders the performance of these methods, and there also can be serious class-imbalance problem since the tumor patches usually only account for a small portion of the entire WSI.

% By ChatGPT
Whole slide scanning is increasingly used in disease diagnosis and pathological research to visualize tissue samples. Compared to traditional microscope-based observation, whole slide scanning converts glass slides into gigapixel digital images that can be conveniently stored and analyzed. However, the high resolution of WSIs also makes their automated classification challenging \cite{lu2021ai}.
Patch-based classification is a common solution to this problem \cite{cvpr2016em,zhang2018whole,chen2022deep}. It predicts the slide-level label by first predicting the labels of small, tiled patches in a WSI. This approach allows for the direct application of existing image classification models, but requires additional patch-level labeling. Unfortunately, patch-level labeling by histopathology experts is expensive and time-consuming. Therefore, many weakly-supervised \cite{cvpr2016em,zhang2018whole} and semi-supervised \cite{cheng2022deep,chen2022deep} methods have been proposed to generate patch-level pseudo labels at a lower cost.
However, the lack of reliable supervision directly hinders the performance of these methods, and serious class-imbalance problems could arise, as tumor patches may only account for a small portion of the entire WSI \cite{dsmil}.

\begin{figure}[t]
\includegraphics[width=0.99\textwidth]{MIL2.pdf}
\caption{The typical pipeline of traditional MIL methods on WSIs. } 
% \vspace{-3mm}
\label{MIL}
\end{figure}

% In contrast, MIL-based methods are becoming more preferred nowadays due to their only demand for slide-level labels. The typical pipeline of MIL methods is presented in Fig.~\ref{MIL}. As shown, MIL methods view a WSI as a bag, and consider the tiled patches in it as instances. The goal is to predict whether there is a positive instance (i.e., tumor patch) in a bag, and if there is, the bag is considered as positive too. However, in practical use, image patch instances are too large for the limited GPU memory, so firstly they will be sent into a fixed ImageNet pre-trained feature extractor $g(x)$ to be converted into feature maps. The instance features will then be aggregated by $a(x)$ into a slide-level feature vector to be sent into a bag-level classifier $f(x)$ for MIL training. End-to-end training of the feature extractor and bag classifier is prohibitively expensive especially for high resolution WSIs, since they can be very large bags each containing over 50000 instances. Therefore, many methods tends to merely focus on improving $a(x)$ and $f(x)$, leaving $g(x)$ untrained on the WSI dataset (as shown in Fig.~\ref{Difference}(b)). Recently, there are also methods proposing to fine-tune the $g(x)$ with self-supervised \cite{srinidhi2022self,dsmil,hipt} or semi-supervised techniques\cite{liu2022multiple}, but since the two processes are still trained separately with different supervision signals, it will still result in inconsistency and lack of information exchange within the entire MIL processes (as shown in Fig.~\ref{Difference}(c)). 

% By ChatGPT
In contrast, MIL-based methods have become increasingly preferred due to their only demand for slide-level labels \cite{maron1997framework}. The typical pipeline of MIL methods is shown in Fig.~\ref{MIL}, where WSIs are treated as bags, and tiled patches are considered as instances. The aim is to predict whether there are positive instances, such as tumor patches, in a bag, and if so, the bag is considered positive as well. In practice, the large number of image patch instances requires a fixed ImageNet pre-trained feature extractor $g(x)$ to convert them into feature maps due to limited GPU memory. These instance features are then aggregated by $a(x)$ into a slide-level feature vector to be sent to the bag-level classifier $f(x)$ for MIL training.
Due to the high computational cost, end-to-end training of the feature extractor and bag classifier is prohibitive, especially for high-resolution WSIs. As a result, many methods focus solely on improving $a(x)$ and $f(x)$, leaving $g(x)$ untrained on the WSI dataset (as shown in Fig.\ref{Difference}(b)). However, the domain shift between WSI and natural images may lead to sub-optimal representations, so recently there have been methods proposed to fine-tune $g(x)$ using self-supervised techniques \cite{srinidhi2022self,dsmil,hipt} or weakly-supervised techniques \cite{liu2022multiple,wang2020ud} (as shown in Fig.\ref{Difference}(c)). Nevertheless, since these two processes are still trained separately with different supervision signals, they lack joint optimization and may still leads to inconsistencies within the entire MIL pipeline.

% Existing MIL methods fine-tune the $g(x)$ by self-supervised pre-training \cite{srinidhi2022self} or only updating the weights with a few high score patches \cite{dsmil}, so bag classifier $f(x)$ is considered as a completely

%================================================================
% Existing patch embedding methods cannot utilize the slide-level labels (But some methods that use attention scores to generate pseudo labels actually make some use of the slide-level label) but ours can (by freezing f(x) and back-propagate pseudo labels back to g(x)).


%================================================================

\begin{figure}[t]
\center
\includegraphics[width=0.97\textwidth]{ICMIL_difference_new.pdf}
\caption{Comparison between ICMIL and existing methods. (a) Ordinary end-to-end classification pipeline. (b) MIL methods that use fixed pretrained ResNet50 as $g(x)$. (c) MIL methods that introduce extra self-supervised fine-tuning of $g(x)$. (d) Our proposed ICMIL which can bridge the loss back-propagation process from $f(x)$ to $g(x)$ by iteratively coupling them during training. }
% \vspace{-5mm}
\label{Difference}
\end{figure}

% Hence, to address these problems, we propose a noval MIL framework called ICMIL, which can iteratively couple the patch feature embedding process and the bag-level classification process together for better MIL training (as shown in Fig.~\ref{Difference}(d)). Unlike most previous works that mainly focus on designing fancy instance aggregators $a(x)$ and bag classifiers $f(x)$ \cite{abmil,clam,dtfdmil}, we focus on bridging the loss back-propagation process from $f(x)$ to $g(x)$ to help $g(x)$ perceive the slide-level labels. Specifically, after achieving a bag-level classifier with the traditional MIL pipeline, we propose to use this bag-level classifier to initialize a instance-level classifier. Therefore, the bag-level classifier can use the category knowledge learned from the bag-level features to help decide each instance's category. For this part, we further propose a teacher-student alike method for efficiently generating pseudo labels and fine-tuning $g(x)$ at the same time. After fine-tuning, $g(x)$ can generate better patch representations for training bag-level classifier $f(x)$ again, who can then be used for the next round of iteration. 
% By ChatGPT
To address the challenges mentioned above, we propose a novel MIL framework called ICMIL, which can iteratively couple the patch feature embedding process with the bag-level classification process to enhance the effectiveness of MIL training (as illustrated in Fig.~\ref{Difference}(d)). Unlike previous works that mainly focused on designing sophisticated instance aggregators $a(x)$ \cite{dsmil,shao2021transmil,lu2021smile} and bag classifiers $f(x)$ \cite{abmil,clam,dtfdmil}, we aim to bridge the loss back-propagation process from $f(x)$ to $g(x)$ to improve $g(x)$'s ability to perceive slide-level labels. Specifically, we propose to use the bag-level classifier $f(x)$ to initialize an instance-level classifier $f'(x)$, enabling $f(x)$ to use the category knowledge learned from bag-level features to determine each instance's category.
In this regard, we further propose a teacher-student \cite{hinton2015distilling} approach to generate pseudo labels effectively and fine-tune $g(x)$ simultaneously. After fine-tuning, the domain shift problem is alleviated in $g(x)$, leading to better patch representations. The new representations can be used to train a better bag-level classifier in return for the next round of iteration.

% However, directly applying the pseudo labels generated by bag-level classifier on patch-level feature extractor fine-tuning only brings limited extra information, and may introduces some false supervision signals. To address this problem, we design a teacher-student alike method for high robustness feature extractor training. The teacher and student branches receive two different augmentations of a patch, and the student model will learn a better and robuster representation based on the soft label generated by the teacher.

% In summary, our contributions are three-folded. (1) We propose an iteratively coupled MIL framework that bridges the loss propagation from bag classifier to patch embedder. It can fine-tune the patch embeddings based on the bag-level classifier, and the new embeddings can in return help training a more accurate bag-level classifier. (2) We propose a teacher-student alike method for effective and robust knowledge learning from bag-level classifier $f(x)$ to instance-level representation embedder $g(x)$. (3) We conduct thorough experiments on two datasets with three different backbones and verify the effectiveness of our framework.
%By ChatGPT
In summary, our contributions are: (1) We propose ICMIL which bridges the loss propagation from the bag classifier to the patch embedder by iteratively coupling them during training. This framework fine-tunes the patch embedder based on the bag-level classifier, and the refined embeddings, in turn, help train a more accurate bag-level classifier. (2) We propose a teacher-student approach to achieve effective and robust knowledge transfer from the bag-level classifier $f(x)$ to the instance-level representation embedder $g(x)$. (3) We conduct extensive experiments on two datasets using three different backbones and demonstrate the effectiveness of our proposed framework.

% 
% Subsequent paragraphs, however, are indented.

% \subsubsection{Sample Heading (Third Level)} Only two levels of
% headings should be numbered. Lower level headings remain unnumbered;
% they are formatted as run-in headings.

% \paragraph{Sample Heading (Fourth Level)}
% The contribution should contain no more than four levels of
% headings. Table~\ref{tab1} gives a summary of all heading levels.

% \begin{table}
% \caption{Table captions should be placed above the
% tables.}\label{tab1}
% \begin{tabular}{|l|l|l|}
% \hline
% Heading level &  Example & Font size and style\\
% \hline
% Title (centered) &  {\Large\bfseries Lecture Notes} & 14 point, bold\\
% 1st-level heading &  {\large\bfseries 1 Introduction} & 12 point, bold\\
% 2nd-level heading & {\bfseries 2.1 Printing Area} & 10 point, bold\\
% 3rd-level heading & {\bfseries Run-in Heading in Bold.} Text follows & 10 point, bold\\
% 4th-level heading & {\itshape Lowest Level Heading.} Text follows & 10 point, italic\\
% \hline
% \end{tabular}
% \end{table}


% \noindent Displayed equations are centered and set on a separate
% line.
% \begin{equation}
% x + y = z
% \end{equation}
% Please try to avoid rasterized images for line-art diagrams and
% schemas. Whenever possible, use vector graphics instead (see
% Fig.~\ref{fig1}).

% \begin{figure}
% \includegraphics[width=\textwidth]{fig1.eps}
% \caption{A figure caption is always placed below the illustration.
% Please note that short captions are centered, while long ones are
% justified by the macro package automatically.} \label{fig1}
% \end{figure}

% \begin{theorem}
% This is a sample theorem. The run-in heading is set in bold, while
% the following text appears in italics. Definitions, lemmas,
% propositions, and corollaries are styled the same way.
% \end{theorem}
% %
% % the environments 'definition', 'lemma', 'proposition', 'corollary',
% % 'remark', and 'example' are defined in the LLNCS documentclass as well.
% %
% \begin{proof}
% Proofs, examples, and remarks have the initial word in italics,
% while the following text appears in normal font.
% \end{proof}
% For citations of references, we prefer the use of square brackets
% and consecutive numbers. Citations using labels or the author/year
% convention are also acceptable. The following bibliography provides
% a sample reference list with entries for journal
% articles~\cite{ref_article1}, an LNCS chapter~\cite{ref_lncs1}, a
% book~\cite{ref_book1}, proceedings without editors~\cite{ref_proc1},
% and a homepage~\cite{ref_url1}. Multiple citations are grouped
% \cite{ref_article1,ref_lncs1,ref_book1},
% \cite{ref_article1,ref_book1,ref_proc1,ref_url1}.

% \vspace{-1mm}
\section{Methodology}
% ICMIL is a MIL framework that aims to improve the patch feature embedding performance with the help of bag-level classifier. Despite the novel iterative optimization method in this framework, the main pipeline of ICMIL remains the same as ordinary MIL methods. This characteristic makes it able to bring about extra performance gain without modifying the existing model structures.
% \vspace{-1mm}
\subsection{Iterative Coupling of Embedder and Bag Classifier in ICMIL}
% \vspace{-1mm}
The general idea of ICMIL is shown in Fig.~\ref{general_idea}, which follows an Expectation-Maximization (EM) pattern. EM has been used with MIL in some previous works \cite{luo2020weakly,liu2022multiple,wang2017instance}, but it was only treated as an assisting tool for aiding the training of either $g(x)$ or $f(x)$ in the traditional MIL pipelines. In contrast, we are the first to consider the optimization of the entire MIL pipeline as an EM alike problem, utilizing EM for coupling $g(x)$ and $f(x)$ together iteratively.
% Unlike previous MIL works that conduct $g(x)$ and $f(x)$ separately, we manage to let them cooperate with each other in ICMIL. 
% For a given dataset, we first train a bag-level classifier in the traditional way with the patch embeddings generated by a fixed ResNet50 pretrained on ImageNet (step \textcircled{1} in Fig.~\ref{general_idea}(b)). Then, we can use this bag-level classifier to generate pseudo labels for each instance-level representation. Such operation is possible since the bag-level representations are essentially linear combinations of the instance-level representations, so they exist in the same hidden space; additionally, as shown in Fig.~\ref{general_idea}(a), the instance-level representations by max pooling on the bags proves that the instance- and bag-level decision boundaries can be very similar, proving the feasibility of using $f(x)$ for guiding each instance's pseudo label. Next, we freeze the weights of $f(x)$ and fine-tune $g(x)$ with these pseudo labels (step \textcircled{2} in Fig.~\ref{general_idea}(b)). To realize a robuster fine-tuning, we design a teacher-student alike method to introduce extra information to the supervisions and realize robuster knowledge distillation from $f(x)$ to $g(x)$. After that, $g(x)$ has been fine-tuned for the specific WSI dataset, and therefore can generate better representations for each instance, which can in return help in boosting the performance of $f(x)$. Furthermore, after having a better bag-level classifier $f(x)$ with these newly-generated instance representations, we can use it again for the next round of iterative coupling, and so on.
% ChatGPT
To begin with, we first employ a traditional approach to train a bag-level classifier $f(x)$ on a given dataset, with patch embeddings generated by a fixed ResNet50 \cite{resnet} pre-trained on ImageNet \cite{imagenet} (step \textcircled{1} in Fig.\ref{general_idea}). Subsequently, this $f(x)$ is considered as the initialization of a hidden instance classifer $f'(x)$, generating pseudo-labels for each instance-level representation. This operation is feasible when the bag-level representations aggregated by $a(x)$ are in the same hidden space as the instance representations'. Luckily, most aggregation methods (e.g., max pooling, attention-based) satisfy this condition since they essentially make linear combinations of instance-level representations. 
% Additionally, the instance- and bag-level decision boundaries are very similar after $a(x)$, making it possible for using $f(x)$ to guide each instance's pseudo label.

\begin{figure}[t]
\center
\includegraphics[width=\textwidth]{ICMIL_brief_idea.pdf}
\caption{The core idea of ICMIL: iteratively, \textcircled{1} fix the embedder $g(x)$ and train the bag classifier $f(x)$, \textcircled{2} fix the classifier $f(x)$ and fine-tune the instance embedder $g(x)$.}
% \vspace{-4mm}
\label{general_idea}
\end{figure}

Next, we freeze the weights of $f(x)$ and fine-tune $g(x)$ with the generated pseudo-labels (step \textcircled{2} in Fig.~\ref{general_idea}), of which the detailed implementation is presented in Section~\ref{tsfinetuning}.
% To ensure robust fine-tuning, we propose a teacher-student \cite{hinton2015distilling} approach to provide additional information to the supervisions and realize effective knowledge distillation from $f(x)$ to $g(x)$.
After this, $g(x)$ is fine-tuned for the specific WSI dataset, which allows it to generate improved representations for each instance, thereby enhancing the performance of $f(x)$. Moreover, with the better $f(x)$, we can use the iterative coupling technique again, resulting in further performance gains and mitigation to the distribution inconsistencies between instance- and bag-level embeddings.


% In ICMIL, a bag-level classifier can only be used for instance-level classification if the initial instance representations from the ImageNet pretrained ResNet50 can already project the positive instances and negative instances to different areas in the hidden space tentatively. Luckily, performance of the ImageNet pretrained ResNet50 has been proved in many previous max pooling based MIL methods. These methods choose to use one stand-out instance to represent the entire bag, and achieved acceptable results. This indicates that learning a bag classifier can also equal to learning a instance classifier, which is just the fundamental assumption of ICMIL. 
% \vspace{-1mm}
\subsection{Instance Aggregation Method in ICMIL}
% \vspace{-1mm}
Although most instance aggregators are compatible with ICMIL, they still have an impact on the efficiency and effectiveness of ICMIL. Besides that $a(x)$ has to project the bag representations to the same hidden space as the instance representations', it also should avoid being over-complicated. Otherwise, $a(x)$ may lead to larger difference between the decision boundaries of bag-level classifer $f(x)$ and instance-level classifier $f'(x)$, which may cause ICMIL taking more time to converge. 
% Luckily, most of the existing $a(x)$ are succinct enough and would not bring about such effects.
% Different from $g(x)$ and $f(x)$ only accepting one single instance- or slide-level representation at a time, instance aggregation process accepts several instance representations at a time, and output a slide-level representation. This difference makes $a(x)$ not suitable for iterative optimization with other MIL processes. Therefore, in ICMIL, $a(x)$ is optimized each time along with $f(x)$, but is not involved in the generation of instance-level pseudo labels. 

% The universal goal of most existing aggregating methods is to emphasis the positive instances and weakening the negative instances, and from another angle they can be viewed as converting a bag-level classification back into instance-level classification. Hence, it still all comes down to a good instance representation if we are trying to have a better bag-level classifier, and that is exactly what ICMIL is designed for.
Therefore, in our experiments, we choose to use the attention-based instance aggregation method \cite{abmil} which has been widely used in many of the existing MIL frameworks \cite{abmil,clam,dtfdmil}. For a bag that contains $K$ instances, attention-based aggregation method firstly learns an attention score for each instance. Then, the aggregated bag-level representation $H$ is defined as:

\begin{equation}
    H=\sum_{k=1}^Ka_kh_k,
\end{equation}
\begin{equation}
    a_k=\frac{{\rm exp}\{\omega^T(tanh(V_1h_k)\odot sigm(V_2h_k))\}}{\sum_{j=1}^K{\rm exp}\{ \omega^T(tanh(V_1h_j)\odot sigm(V_2h_j))\}},
\end{equation}

\noindent where $a_k$ is the attention score for the $k$-th instance $h_k$ in the bag, $\omega$, $V_1$ and $V_2$ are learnable matrices, $\odot$ is element-wise wise multiplication, and $tanh()$ and $sigm()$ are different activation functions. Obviously, $H$ and $h_k$ remains in the same hidden space, satisfying the prerequisite of ICMIL. 
% Specifically, the attention score $a_k$ for the $k$-th instance $h_k$ is defined as:

% \begin{equation}
%     a_k=\frac{{\rm exp}\{\omega^T(tanh(V_1h_k)\odot sigm(V_2h_k))\}}{\sum_{j=1}^K{\rm exp}\{ \omega^T(tanh(V_1h_j)\odot sigm(V_2h_j))\}},
% \end{equation}

% \noindent where $\omega$, $V_1$ and $V_2$ are learnable matrices, $\odot$ is element-wise wise multiplication, and $tanh()$ and $sigm()$ are different activation functions. 
% Nevertheless, it should be noted that $\omega$ is often used as a dimension reduction operator in practical implementation, and this may result in bag-level representations being projected to a different hidden space from the instance-level features. So, when using $f(x)$ to generate pseudo labels for the instances in ICMIL, $\omega$ should also be applied for each instance to ensure consistency. 
% Then, the bag-level representation $H$ is defined as the weighted summation of the instance representations, which is:

% \begin{equation}
%     H=\sum_{k=1}^Ka_kh_k
% \end{equation}

% In general, our framework can provide an accuracy improvement for most existing methods without modification of their structures. 

\begin{figure}[t]
\center
\includegraphics[width=\textwidth]{ICMIL_teacher_student.pdf}
\caption{A schematic view of the proposed teacher-student alike model for label propagation from $f(x)$ to $g(x)$ (mainly in step \textcircled{2}), and its position in ICMIL pipeline.} 
% \vspace{-4mm}
\label{knowledge_distillation}
\end{figure}

% \vspace{-1mm}
\subsection{Label Propagation from Bag Classifier to Embedder}
\label{tsfinetuning}
% \vspace{-1mm}
% We propose a teacher-student alike model for more accurate and robust label propagation from $f(x)$ to $g(x)$. The structure of this model is presented in Fig.~\ref{knowledge_distillation}. Compared with the na誰ve method of directly generating all the pseudo labels and retraining $g(x)$ all over again, the proposed method can train a new $g(x)$ along with the pseudo label generation process, which is more flexible. Besides, the augmented inputs can also bring in more extra information to the training process by making better use of the supervision signals, resulting in a robuster $g(x)$. In addition, a learnable $f'(x)$ for student branch is also used to allow flexiblity to the instance-level fine-tuning. 

% Specifically, we freeze the weights of $g(x)$ and $f(x)$ to set them as the teacher branch, and then try to train a student patch embedding network $g'(x)$ to learn the category knowledge from the teacher. For a given patch input, the teacher is responsible for generating the corresponding pseudo label, while the student receives the augmented image and try to generate a similar prediction as the teacher's. During training, the gradient is back-propagated to $g'(x)$ through a learnable $f'(x)$, which is an instance-level classifier whose initial weights are the same of $f(x)$. We use this learnable $f'(x)$ instead of a fixed $f(x)$ mainly because there may be slight difference between the instance- and bag-level classification boundary. However, this difference should be minor. So as to prevent $f'(x)$ being too different from $f(x)$, there is also a weight similarity loss $L_w$ to constrain them. In this way, the patch embeddings from $g'(x)$ can still suits the bag-level classification task, avoiding being too tailored for the instance-level classifier $f'(x)$. In addition, a consistency loss $L_c$ is added to make sure that student branch can generate similar soft labels as the teacher does. 
%ChatGPT
We propose a novel teacher-student model for accurate and robust label propagation from $f(x)$ to $g(x)$. The model's architecture is depicted in Fig.~\ref{knowledge_distillation}. In contrast to the conventional approach of generating all pseudo labels and retraining $g(x)$ from scratch, our proposed method can simultaneously process the pseudo label generation and $g(x)$ fine-tuning tasks, making it more flexible. Moreover, incorporating augmented inputs in the training process allows for the better utilization of supervision signals, resulting in a more robust $g(x)$. We also introduce a learnable $f'(x)$ to self-adaptively modifying the instance-level decision boundary for more effective fine-tuning of the embedder. 

Specifically, we freeze the weights of $g(x)$ and $f(x)$ and set them as the teacher. We then train a student patch embedding network, $g'(x)$, to learn category knowledge from the teacher. For a given patch input, the teacher generates the corresponding pseudo label, while the student receives an augmented image $x'$ and attempts to generate a similar prediction to that of the teacher through a consistency loss $L_c$. $L_c$ is defined as:

\begin{equation}
\label{eqn3}
    L_c=\sum_{c=0}^C \left[f(x)_c log\left( \frac{f(x)_c}{f'(x')_c}\right)\right],
\end{equation}

\noindent where $f(x)$ and $f'(x)$ are teacher classifer and student classifier respectively, and $f(x)_c$ indicates the c-th channel of $f(x)$. 

Additionally, during training, a learnable instance-level classifier is used on student to back-propagate gradients to $g'(x)$. The initial weights of $f'(x)$ are the same as those of $f(x)$, as the differences in the instance- and bag-level classification boundaries is expected to be minor. To make $f'(x)$ not so different from $f(x)$ during training, a weight similarity loss, $L_w$, is imposed to constrain it. By doing so, the patch embeddings from $g'(x)$ can still suit the bag-level classification task well, rather than being tailored solely for the instance-level classifier $f'(x)$. $L_w$ is defined as:
% Moreover, we introduce a , to ensure that the student branch can generate soft labels similar to those of the teacher.
% The two loss functions can be defined as follows:

\begin{equation}
\label{eqn4}
    L_w=\sum_{l=0}^L \sum_{c=0}^C \left[f(x)_c^l log\left( \frac{f(x)_c^l}{f'(x)_c^l}\right)\right],
\end{equation}

\noindent where $f(x)_c^l$ indicates the c-th channel of l-th layer's output in $f(x)$. The overall loss function for this step is $L_c+\alpha L_w$, with $\alpha$ set to 0.5 in our experiments.

% \vspace{-1mm}
\section{Experiments}
% \vspace{-1mm}
\subsection{Datasets}
% \vspace{-1mm}
Our experiments utilized two datasets, with the first being the publicly available breast cancer dataset, Camelyon16 \cite{camelyon16}. This dataset consists of a total of 399 WSIs, with 159 normal and 111 tumour WSIs for the training set, and the remaining 129 for test. While patch-level labels are officially provided in Camelyon16, they are not used in our experiments. 
% This is because our aim was to design a reliable Multiple Instance Learning (MIL) model that only requires slide-level labels for training. It is worth noting that typically only 10\% of instances in a tumor bag are positive in Camelyon16.

% KF-PRO-400-HI
The second dataset is a private hepatocellular carcinoma (HCC) dataset collected from Hangzhou Sir Run Run Shaw Hospital. This dataset comprises a total of 1140 valid tumor WSIs scanned at 40$\times$ magnification, and the objective is to identify the severity of each case based on the Edmondson-Steiner (ES) grading. The ground truth labels are binary classes of low risk and high risk, which are provided by experienced pathologists. 
% WSIs with ES grading I-II were classified as cases with less severity (i.e., negative), while those with ES grading III-IV were considered as cases with high severity (i.e., positive). 
% Different from Camelyon16, distinguishing the low and high severity of tumor is harder than simply tell tumor patches from normal ones since the positive embeddings and negative embeddings may be more mixed up in the hidden space. Under such circumstances, a powerful instance feature projection with cleaner decision boundary can help boost the bag-level classification greatly.
% \vspace{-1mm}
\subsection{Implementation Details}
% \vspace{-1mm}
For Camelyon16, we tile the WSIs into 256$\times$256 patches on 20$\times$ magnification using the official code of \cite{dtfdmil}, while for the HCC dataset the patches are 384$\times$384 on 40$\times$ magnification following the pathologists' advice. For both datasets, we use an ImageNet pre-trained ResNet50 \footnote{https://download.pytorch.org/models/resnet50-11ad3fa6.pth} to initialize $g(x)$ (except DS-MIL \cite{dsmil}). The instance embedding process is the same of \cite{clam}, which means for each patch, it will be firstly embedded into a 1024-dimension vector, and then be projected to a 512-dimension hidden space for further bag-level training. For the training of bag classifier $f(x)$, we use an initial learning rate of 2e-4 with Adam \cite{adam} optimizer for 200 epochs with batch size being 1. Camelyon16 results are reported on the official test split, while the HCC dataset uses a 7:1:2 split for training, validation and test. For the training of patch embedder $g(x)$, we use an initial learning rate of 1e-5 with Adam \cite{adam} optimizer for 10000 iterations with batch size being 100. Three metrics are used for evaluation, namely area under curve (AUC), F1 score, and slide-level accuracy (Acc). Experiments are all conducted on a Nvidia Tesla M40 (12GB). 


\begin{table}[t]
\renewcommand\tabcolsep{3pt}
% \renewcommand\arraystretch{0.88}
\caption{Results of ablation studies on Camelyon16 with AB-MIL.}
\center
\label{ablation_study}
\subtable[Ablation study on the ICMIL iteration times]{
\begin{tabular}{l
>{\columncolor[HTML]{F4F9FF}}c 
>{\columncolor[HTML]{ECF4FF}}c 
>{\columncolor[HTML]{ECF4FF}}c 
>{\columncolor[HTML]{DAE8FC}}c 
>{\columncolor[HTML]{DAE8FC}}c 
>{\columncolor[HTML]{CDE1FF}}c 
>{\columncolor[HTML]{CDE1FF}}c }
\hline
ICMIL Iterations & 0     & 0.5 & 1     & 1.5  & 2     & 2.5  & 3    \\ \hline
AUC              & 85.4 & 88.8    & 90.0 & 89.7 & 90.5 & 90.4 & 90.0 \\
F1               & 78.0 & 79.4    & 80.5 & 80.1 & 82.0 & 80.7 & 81.7 \\
Acc              & 84.5 & 85.0    & 86.6 & 86.0 & 85.8 & 86.9 & 86.6    \\ \hline
\end{tabular}
}
\subtable[Loss Propagation]{
\begin{tabular}{ccc}
\hline
Method & Na誰ve & Ours \\ \hline
AUC    & 88.5     & 90.0      \\
F1     & 78.8     & 80.5      \\
Acc    & 83.9     & 86.6      \\ \hline
\end{tabular}
}
\end{table}

% \subsection{Ablation Study}
% The results of ablation studies are presented in Table~\ref{ablation_study}. Please note that one complete ICMIL fine-tuning includes 1,000,000 randomly picked instances, and only after one complete iteration will the newly trained $f(x)$ be used as guidance for next iteration.

% From Table~\ref{ablation_study}(a), we can learn that as the number of ICMIL iteration increases, the performance will also go up until reaching a stable point. Since the number of instances is very large in WSI datasets, we finally choose to run ICMIL 1 iteration for fine-tuning $g(x)$ one time to achieve a balance between performance gain and time consumption. From Table~\ref{ablation_study}(b), it is shown that our teacher-student based method outperforms the na誰ve "pseudo label generation" method for fine-tuning $g(x)$, which proves the effectiveness of introducing the learnable instance-level classifier $f'(x)$.
% Following results are all reported under this experimental setting.

\begin{table}[t]
\renewcommand\tabcolsep{1.8pt}
% \renewcommand\arraystretch{0.88}
\caption{Comparison with other methods on Camelyon16 and HCC datasets. Best results are in bold, while the second best ones are underlined.}
\center
\label{experimental_results}
\begin{tabular}{cccccccccc}
\hline
\multirow{2}{*}{Method} & \multicolumn{3}{c}{Loss Propagation}                         & \multicolumn{3}{c}{Camelyon16} & \multicolumn{3}{c}{HCC} \\ \cmidrule(l){2-4} \cmidrule(l){5-7}  \cmidrule(l){8-10} 
                        & $g(x)$                      & $f(x)$ & $f$$\rightarrow$$g$                 & AUC(\%)      & F1(\%)       & Acc(\%)      & AUC(\%)    & F1(\%)     & Acc(\%)   \\ \hline
Mean Pooling            &                           & \checkmark     &  & 60.3    & 44.1    & 70.1    & 76.4  & 83.1  & 73.7 \\
Max Pooling             &                           & \checkmark     &  & 79.5    & 70.6    & 80.3    &  80.1      &  84.3      & 76.8      \\
RNN-MIL \cite{abmil}                 &                           &   \checkmark   &  & 87.5    & 79.8    & 84.4    & 79.4       &  84.1      & 75.5      \\
AB-MIL \cite{abmil}                 &                           &  \checkmark    &  & 85.4    & 78.0    & 84.5    & 81.2  & 86.0  & 78.1 \\
DS-MIL \cite{dsmil}                 &   \checkmark    &  \checkmark    &  & 89.9    & 81.5    & 85.6    & 86.1       & 86.6       & 81.4      \\
CLAM-SB  \cite{clam}                &                           & \checkmark     &  & 87.1    & 77.5    & 83.7    &  82.1      & 84.3       & 77.1      \\
CLAM-MB \cite{clam}                &                           & \checkmark      & & 87.8    & 77.4    & 82.3    &  81.7      & 83.7       & 76.3      \\
TransMIL \cite{shao2021transmil}               &                           & \checkmark     &  & 90.6    & 79.7    & 85.8    & 81.2       & 84.4       & 76.7      \\
DTFD-MIL \cite{dtfdmil}               &                           &   \checkmark   &  & \underline{93.2}    & \underline{84.9}    & \underline{89.0}    & 83.0  & 85.5  & 78.1 \\ \hline
\vspace{-0.5mm}$\rm \mathop{Ours}\limits_{(w/\ Max\ Pooling)}$ & \checkmark &  \checkmark    & \checkmark &   $\mathop{85.2}\limits_{(+5.7)}$      & $\mathop{74.7}\limits_{(+4.1)}$         & $\mathop{81.9}\limits_{(+1.6)}$    & $\mathop{86.6}\limits_{(+6.5)}$  & $\mathop{87.3}\limits_{(+3.0)}$     & $\mathop{82.0}\limits_{(+5.2)}$  \\
\vspace{-0.5mm}$\rm \mathop{Ours}\limits_{(w/\ AB-MIL)}$    & \checkmark & \checkmark     & \checkmark & $\mathop{90.0}\limits_{(+4.6)}$   & $\mathop{80.5}\limits_{(+2.5)}$    & $\mathop{86.6}\limits_{(+2.1)}$  & $\mathop{87.1}\limits_{\underline{(+5.9)}}$        &  $\mathop{88.3}\limits_{\underline{(+2.3)}}$       & $\mathop{83.3}\limits_{\underline{(+5.2)}}$       \\
\vspace{-0.5mm}$\rm \mathop{Ours}\limits_{(w/\ DTFD-MIL)}$   & \checkmark &  \checkmark    & \checkmark 
&  $\boldsymbol{\mathop{93.7}\limits_{(+0.5)}}$      & $\boldsymbol{\mathop{87.0}\limits_{(+2.1)}}$   & $\boldsymbol{\mathop{90.6}\limits_{(+1.6)}}$  & $\boldsymbol{\mathop{87.7}\limits_{(+4.7)}}$     &  $\boldsymbol{\mathop{89.1}\limits_{(+3.6)}}$      &  $\boldsymbol{\mathop{83.5}\limits_{(+5.4)}}$     \\ \hline
\end{tabular}
\end{table}


\begin{figure}[t]
\includegraphics[width=\textwidth]{visualization.pdf}
\caption{Visualization of the instance- and bag-level representations before and after ICMIL training. Only one iteration of ICMIL is used to achieve the right figure.} 
% \vspace{-4mm}
\label{visualization}
\end{figure}

% \vspace{-1mm}
\subsection{Experimental Results}
% \vspace{-1mm}
\subsubsection{Ablation Study.}
The results of ablation studies are presented in Table~\ref{ablation_study}. Please note that one complete ICMIL fine-tuning includes 1,000,000 randomly picked instances, and only after one complete iteration will the newly trained $f(x)$ be used as guidance for next iteration.

From Table~\ref{ablation_study}(a), we can learn that as the number of ICMIL iteration increases, the performance will also go up until reaching a stable point. Since the number of instances is very large in WSI datasets, we finally choose to run ICMIL one iteration for fine-tuning $g(x)$ to achieve the balance between performance gain and time consumption. From Table~\ref{ablation_study}(b), it is shown that our teacher-student based method outperforms the na誰ve "pseudo label generation" method for fine-tuning $g(x)$, which proves the effectiveness of introducing the learnable instance-level classifier $f'(x)$.

% \vspace{-3mm}

\subsubsection{Comparison with Other Methods.}
Experimental results are presented in Table~\ref{experimental_results}. As shown, our ICMIL framework consistently improves the performance of three different MIL baselines (i.e., Max Pool, AB-MIL, and DTFD-MIL), demonstrating the effectiveness of bridging the loss back-propagation from bag calssifier to embedder. It proves that a more suitable patch embedding can greatly enhance the overall MIL classification framework. When used with the state-of-the-art MIL method DTFD-MIL, ICMIL further increase its performance on Camelyon16 by 0.5\% AUC, 2.1\% F1, 1.6\% Acc.
% This proves that ICMIL successfully enables the information exchange within the entire MIL framework, resulting in a better cooperation between instance embedding and bag classification. Among all the MIL baselines, Max Pooling enjoys the highest improvement from ICMIL, which is a 5.7\% increase on AUC. One reason is that a lower baseline leads to higher potential of improving, while another reason is that Max Pooling based method explicitly model the bag-level classification into an instance-level classification problem, therefore benefiting the most from our motivation of increasing the instance-level representations' quality. 

% Results on the HCC dataset are a little different. On this dataset, Mean Pooling performs better than usual. This is because the WSIs in this dataset usually contain a large area of tumor. Therefore, average pooling on the instances become less harmful, since it would not offset the difference between postive and negative instances too much. In addition, it is shown that the performance difference between different vanilla MIL methods tends to be smaller, as the max difference of AUC is only 9.7\% (DS-MIL to Mean Pooling) compared to Camelyon16's 32.9\% (DTFD-MIL to Mean Pooling). This is because the difference between low severity instances and high severity instances is much smaller than the difference between tumor and non-tumor instances, making the aggregated bag-level instances also difficult to be classified. This is also why DS-MIL can outperform DTFD-MIL on this dataset, for it uses self-supervised pretraining to initialize $g(x)$, leading to better instance representations. In comparison, ICMIL also involves instance-level fine-tuning, and can improve the separability of positive and negative cases with the help of bag classifier. After applying ICMIL on DTFD-MIL, it still outperform other methods, indicating the superiority of its bag classifier design.
% short version by ChatGPT
Results on the HCC dataset also proves the effectiveness of ICMIL, despite the minor difference on the relative performance of baseline methods. Mean Pooling performs better on this dataset due to the large area of tumor in the WSIs, which mitigates the impact of average pooling on instances. Also, the performance difference between different vanilla MIL methods tends to be smaller on this dataset since risk grading is a harder task than Camelyon16's identifying tumor cases. In this situation, the quality of instance representations plays a crucial role in generating more separable bag-level representations. 
As a result, after applying ICMIL on the MIL baselines, these methods all enjoy great performance boost on the HCC dataset.

% \subsection{Visualization Analysis}

% To further verify the effectiveness of our proposed method, we present the instance- and bag-level representations of Camelyon16 before and after ICMIL in Fig.~\ref{visualization} (with AB-MIL backbone). As shown in the figure, after only one iteration of $g(x)$ fine-tuning in ICMIL, the instance-level representations can already distinguish from each other better, which naturally leads to a better aggregated bag-level representation. Moreover, the bag-level representations are also better aligned with the instance representations, indicating that the instance- and bag-level decision boundaries indeed come closer to each other. 
% ChatGPT make this short
Furthermore, Fig.~\ref{visualization} displays the instance- and bag-level representations of Camelyon16 dataset before and after applying ICMIL on AB-MIL backbone. The results indicate that one iteration of $g(x)$ fine-tuning in ICMIL significantly improves the instance-level representations, leading to a better aggregated bag-level representation naturally. Besides, the bag-level representations are also more closely aligned with the instance representations, proving that ICMIL can reduce the inconsistencies between $g(x)$ and $f(x)$ by coupling them together for training, resulting in a better separability.


% \subsection{Visualization Analysis}
% \vspace{-1mm}
\section{Conclusion}
% \vspace{-1mm}
In this work, we propose ICMIL, a novel framework that iteratively couples the feature extraction and bag classification steps to improve the accuracy of MIL models. Our proposed method bridges the loss propagation from bag classifier to patch embedder by leveraging the category knowledge in the bag classifier as pseudo supervision for embedder fine-tuning, and we also design a two-stream model to facilitate such knowledge transfer efficiently. The fine-tuned patch embedder can provide more accurate instance embeddings, in return benefiting the bag classifier. The experimental results show that our method brings consistent improvement to existing MIL backbones.

% \subsubsection{Acknowledgements} This work is supported in part by the National Key Research and Development Project (2022YFC2504605), the Natural Science Foundation of Zhejiang Province (LZ22F020012), and Hangzhou Major Science and Technology Innovation Project (2022AIZD0147). This work is also supported in part by Grant-in Aid for Scientific Research from the Japanese Ministry for Education, Science, Culture and Sports (MEXT) under Grant No. 20KK0234, 21H03470 and 20K21821.
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{mybibliography}
%
% \begin{thebibliography}{8}
% \bibitem{ref_article1}
% Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

% \bibitem{ref_lncs1}
% Author, F., Author, S.: Title of a proceedings paper. In: Editor,
% F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
% Springer, Heidelberg (2016). \doi{10.10007/1234567890}

% \bibitem{ref_book1}
% Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
% Location (1999)

% \bibitem{ref_proc1}
% Author, A.-B.: Contribution title. In: 9th International Proceedings
% on Proceedings, pp. 1--2. Publisher, Location (2010)

% \bibitem{ref_url1}
% LNCS Homepage, \url{http://www.springer.com/lncs}. Last accessed 4
% Oct 2017
% \end{thebibliography}
\newpage
\section*{Supplementary Materials}
%
% \titlerunning{Iteratively Coupled Multiple Instance Learning}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
% \author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
% \author{Paper ID: 322}
%
% \authorrunning{Anonymous et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
% \institute{Anonymous Institute}

%
% \maketitle 


% \section{More Details about the HCC dataset}
% \subsection{A Subsection Sample}

\begin{figure}[ht]
% \vspace{-5mm}
\includegraphics[width=\textwidth]{HCC_pipeline.pdf}
\caption{
The collecting process of the HCC dataset. We collect the HCC pathology dataset with a 7-site sampling procedure on the tumor tissues after surgery. Each annotation is provided by experienced pathologists based on the 7 WSIs of each case. However, to increase the training efficiency, we normally select 3 WSIs (sometimes 2 or 4 WSIs) with the highest tumor proportion in a case to form this HCC dataset. The 3 WSIs inherit the case-level label as their slide-level labels. In our experiments, WSIs with Edmondson-Stenier grading I, II are classified as low risk (negative in MIL), and III, IV are classified as high risk (positive in MIL). } 
% \label{visualization}
\vspace{-5mm}
\end{figure}


\begin{figure}[hb]
\vspace{-5mm}
\includegraphics[width=\textwidth]{Implementation_Details.pdf}
\caption{Following previous works, we use the first 3 stages of ResNet50 for patch embedding, generating the 1024-dimension feature vectors for each patch as the final instance in the bag. The ResNet50 is initialized with ImageNet pre-trained weights, but is then finetuned in our proposed ICMIL to mitigate the domain shift for generating more optimal instance embeddings. It should be noted that ICMIL can also be used with other $g(x)$ structures to achieve similar effects. } 
% \label{visualization}
\vspace{-10mm}
\end{figure}

% \section{More about the Implementation Details}
% Our code is mainly based on the official code of DTFD-MIL. However, DTFD-MIL does not provide official code for generating the instance-level embeddings, but only provide a preprocessed pickle file for Camelyon16. Therefore, we have to write our own code for $g(x)$ on Camelyon16. Our own implementation leads to a 93.2\% AUC opn DTFD-MIL(AFS) baseline, which is lower than the result reported in the original paper. But we have also trained DTFD-MIL baseline on the official pickle dataset, and it still can only achieves a 92.7\% AUC. Similar situation is also reported in other papers \cite{}.

\begin{algorithm}[t]
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\caption{Pseudo Code for ICMIL Training Pipeline}
\begin{algorithmic}[1]
\Require WSI dataset X, annotations Y, loss function weight $\alpha$, learning rate $\beta_1$, $\beta_2$, and total ICMIL iteration times T
\Ensure Optimal MIL model components' weights $\theta^f,\theta^a,\theta^g$
\State \textbf{Initialize $\theta^g$ with ImageNet pretrained weights for g(x)}
% \State $ \textbf{while } \rm True \textbf{ do}: $
\State $\textbf{for } iter\textbf{ from } 0\textbf{ to } T\textbf{ do}:$
\State \hspace{0.5cm}\# Step 1: fix embedder g(x) and train the bag classifier f(x) \textcolor{blue}{\Comment{Fig.~\ref{general_idea}(\textcircled{1})}}
\State \hspace{0.5cm}$ \textbf{for } x_i \in X \textbf{ do}: $
\State \hspace{1.0cm}$ \textbf{for } x_i^j \in Tiled(x_i) \textbf{ do}: $
\State \hspace{1.5cm}$ \widehat{x_i^j}\gets g(x_i^j) $
\State \hspace{1.0cm}$ \widehat{x_i}\gets \{\widehat{x_i^j}|0\le j\le len(Tiled(x_i))\} $
\State \hspace{0.5cm}$ \widehat{X}\gets \{\widehat{x_i}|0\le i\le len(X)\}$
% \State \hspace{0.5cm}\# STEP 2: train classifier f(x) \textcolor{blue}{\Comment{Fig. 3(\textcircled{1})}}
\State \hspace{0.5cm}$epoch\gets 0$
\State \hspace{0.5cm}$ \textbf{while } epoch\le200 \textbf{ do}:$
\State \hspace{1.0cm}$ \textbf{for } (\widehat{x_i},y_i) \in (\widehat{X},Y) \textbf{ do}:  $
\State \hspace{1.5cm}$ l_{ce}\gets CrossEntropy(\theta^a,\theta^f;f(a(\widehat{x_i})),y_i) $
\State \hspace{1.5cm}$ \theta^a=\theta^a-\beta_1 \nabla_{\theta^a}(l_{ce}) $
\State \hspace{1.5cm}$ \theta^f=\theta^f-\beta_1 \nabla_{\theta^f}(l_{ce}) $
\State \hspace{1.0cm}$ epoch\gets epoch+1 $
\State \hspace{0.5cm}$ \textbf{if } iter=T \textbf{ do} $
\State \hspace{1.0cm}$ \textbf{return } \theta^f,\theta^a,\theta^g$
\State \hspace{0.5cm}\# Step 2: fix bag classifier f(x) and finetune the embedder g(x) \textcolor{blue}{\Comment{Fig.~\ref{general_idea}(\textcircled{2})}}
\State \hspace{0.5cm}$ f'(\cdot)\gets f(\cdot).copy() $ \quad \# Initialize an instance classifier f'($\cdot$) with f($\cdot$)
\State \hspace{0.5cm}$ \theta^{f'}\gets \theta^{f}.copy() $ \quad\quad\ \# f'($\cdot$) use the same weights as f($\cdot$) initially
\State \hspace{0.5cm}$ g'(\cdot)\gets g(\cdot).copy() $
\State \hspace{0.5cm}$ \theta^{g'}\gets \theta^{g}.copy() $ 
\State \hspace{0.5cm}$ f(\cdot).require\_grad\gets False $
\State \hspace{0.5cm}$ g(\cdot).require\_grad\gets False $
\State \hspace{0.5cm}$ \textbf{for } x_i \in X \textbf{ do}: $
\State \hspace{1.0cm}$ \textbf{ for } x_i^j \in Tiled(x_i) \textbf{ do}: $
\State \hspace{1.5cm}$ y_{teacher}\gets f(g(x_i^j)) $
\State \hspace{1.5cm}$ y_{student}\gets f'(g'(Augment(x_i^j))) $
\State \hspace{1.5cm}$ l_{c}\gets L_c(\theta^{g'},\theta^{f'};  y_{student},y_{teacher}) $ \textcolor{blue}{\Comment{Eqn.~\eqref{eqn3}}}
\State \hspace{1.5cm}$ l_{w}\gets L_w(\theta^{f'},\theta^f) $ \textcolor{blue}{\Comment{Eqn.~\eqref{eqn4}}}
\State \hspace{1.5cm}$ l_{cw}=l_c+\alpha l_w $
\State \hspace{1.5cm}$ \theta^{f'}=\theta^{f'}-\beta_2 \nabla_{\theta^{f'}}(l_{cw}) $
\State \hspace{1.5cm}$ \theta^{g'}=\theta^{g'}-\beta_2 \nabla_{\theta^{g'}}(l_{cw}) $
\State \hspace{0.5cm}$ \theta^g\gets \theta^{g'}.copy() $ \quad \quad\quad\ \# Update the embedder for next training iteration
% \State $ \textbf{return } \theta^f,\theta^a,\theta^g$
\end{algorithmic}
\label{alg1}
\end{algorithm}


\end{document}
