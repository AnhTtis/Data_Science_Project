

%\gbc{Removed: Theorems~\ref{thm:1/3_APS_guarantee} and~\ref{thm:equal-10/27} imply (among other things) the existence of allocations that give each agent with a submodular valuation a certain fraction of her APS (or MMS). However, they do not provide polynomal time algorithms to find such allocations, because they assume that the value of the APS (or MMS) is known, whereas computing this value is NP-hard. In this section we show that this assumption can be removed, and consequently that there are polynomial time allocation algorithms that output allocations that approximate the APS and MMS within ratios almost as good as those shown in Theorems~\ref{thm:1/3_APS_guarantee} and~\ref{thm:equal-10/27}. Our proof is based on a technique that was introduced in~\cite{DBLP:conf/sigecom/GhodsiHSSY18}. }
%with some minor modifications.
%\ufc{remove: After showing existential results of approximate $MMS/APS$ allocations, we turn to show a polynomial algorithm that finds those allocations.} 
%\gbe{We continue by stating explicitly what parameters we consider when addressing a polynomial algorithm, and proving some useful theorems towards \Cref{cor:polyTimeSubmodular} and ~\ref{cor:submodular, additive, and unit demand algorithm} proofs.}


Consider an allocation instance $I$ with $n$ agents, $m$ items, integer valued %submodular
valuation functions, with values of bundles in the range $[0,K]$ (that is, $K=\max_{i\in\mathcal{N}}v_i(\items)$). (Alternatively, for a valuation function $v_i$ that is not integer valued, $K$ denotes an upper bound on  $\frac{v_i(\items)}{v_i(S)}$, over all sets $S \subset \items$ for which $v_i(S) > 0$. Namely, $K$ is an upper bound on the ratio between the values of the most valuable bundle and least valuable bundle of positive value.) We assume that all allocation algorithms have value query access to the valuation functions of the agents. We say that an allocation algorithm runs in polynomial time if both its running time and the number of value queries that it makes are polynomial in $n$, $m$ and $\log K$. In the following presentation, we consider the APS as our share notion, and allow for agents of arbitrary entitlement. We remark that the same principles apply (with straightforward modifications) to settings with equal entitlement, and the MMS as a fairness notion. 
%\ufc{remove: If we denote as $n$ the number of agents, $m$ to be the number of items, and $K=\max_{i\in\mathcal{N}}v_i(\items)$, then we would like to show an algorithm} \ufc{remove: \ufe{We design an allocation algorithm} that runs in time polynomial in $n$, $m$ and $\log K$.}

\begin{remark}
    Definition~\ref{def:conditional algorithm} and Theorem~\ref{thm:polytime} (that will be presented shortly) involve an approximation ratio $\rho$. All results extend without any change in the proofs to settings in which $\rho$ is not a fixed constant, but instead a function of the entitlement (such approximation ratios appear in Theorem~\ref{thm:1/3_APS_guarantee}, for example). That is, for agent $i$ with entitlement $b_i$, the approximation ratio is $\rho(b_i)$. 
\end{remark}


\begin{definition}
\label{def:conditional algorithm}
For $\rho > 0$, we say that an allocation algorithm is a $\rho$-APS algorithm for a class $C$ of valuations, if given any allocation instance with valuations from the class $C$, the algorithm outputs an allocation $(A_1, \ldots, A_n)$ in which every agent $i$ gets a bundle $A_i$ of value $v_i(A_i) \ge \rho \cdot APS_i$. 
We say that an allocation algorithm is a {\em conditional} $\rho$-APS algorithm for a class $C$ of valuations, if given any allocation instance with valuations from the class $C$, and given any vector $(t_1, \ldots, t_n)$, the algorithm outputs an allocation $(A_1, \ldots, A_n)$ that satisfies the following property: for every agent $i$, if it happens that $t_i \le APS_i$, then $v_i(A_i) \ge \rho \cdot t_i$. %$t_i = APS_i$, then $v_i(A_i) \ge \rho \cdot APS_i$. 
\end{definition}

%\begin{remark}
%    A variation on the notion of conditional $\rho$-APS algorithm is to have the following property: for every agent $i$, if it happens that $t_i \le APS_i$, then $v_i(A_i) \ge \rho \cdot t_i$. This variation is not needed in the current work in which $C$ is the class of submodular valuations, but has implicitly been used in~\cite{BEF21} for the class of additive valuations. Moreover, with this variation, the proof of Theorem~\ref{thm:polytime} becomes slightly simpler, and extends to all classes of valuation functions.
%\end{remark}

The proof of the following theorem is similar to a proof of a related theorem proved in~\cite{DBLP:conf/sigecom/GhodsiHSSY18}. We present its proof for completeness.
%\gbc{Talk with Uri about this point - I think it is too much credit, I think they proved it only for their algorithms, and not in such a general setting as presented in the next Theorem}

\begin{theorem}
\label{thm:polytime}
    Fix arbitrary $\rho > 0$ and arbitrary $\varepsilon > 0$. Then every polynomial time conditional $\rho$-APS algorithm for a class $C$ of valuations can be transformed into a polynomial time (unconditional) $(1 - \varepsilon)\rho$-APS  algorithm for the class $C$ of valuations. Here, the dependence on $\varepsilon$ of the running time of the unconditional algorithm is a multiplicative factor of $O(\frac{1}{\varepsilon})$. 
\end{theorem}



\begin{proof}
%\ufc{Need to refer the reader to the algorithm.}
{In Algorithm~\ref{alg:conditional to unconditional algorithm} we give an unconditional $(1 - \varepsilon)\rho$-APS algorithm, using a conditional $\rho$-APS algorithm as a blackbox.}


\RestyleAlgo{ruled}
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}[hbt!]
\caption{An \emph{unconditional} $(\rho - \varepsilon)$-APS algorithm using a \emph{conditional} $rho$-APS algorithm as a blackbox }\label{alg:conditional to unconditional algorithm}
\KwData{$\mathcal{M},\mathcal{N},\langle v_1,\dots,v_n\rangle,  \varepsilon{,K}$}
For every $i\in\mathcal{N},\quad t_i\gets v_i(\items)$\;

\While{true}{
    Run \emph{conditional}-$\rho$-APS algorithm with guesses $\langle t_1,\dots,t_n\rangle$, resulting $\mathcal{A}=\langle A_1,\dots,A_n\rangle$\; 
  \eIf{$\exists i,$ such that $v_i(A_i)<\rho_i\cdot t_i$ {{\bf and} $t_i\geq v_i(\items)\cdot\frac{1}{K}$}}{
    $i = i$ which satisfies the condition\;
    $t_i\gets (1 -\varepsilon)t_i$\;
  }{ Return $\mathcal{A}$ and exit\;
  }
}
\end{algorithm}

{
\begin{remark}
    In Algorithm~\ref{alg:conditional to unconditional algorithm}, we require having $K$ (the maximum ratio between largest and smallest value bundles) as an input. However, in the case of agents with submodular valuations, $K$ is not needed as input. Instead,  $K$ can be computed efficiently as it equals $\max_{i\in\mathcal{N}}\{\max_{\{e\in\mathcal{M}\mid v_i(e)>0\}}\{\frac{v_i(\items)}{v_i(e)}\}\}$. 
\end{remark}
}
% \end{figure}


\begin{claim}
\label{lower bound of guesses of APS}
During the whole run of Algorithm~\ref{alg:conditional to unconditional algorithm}, for every agent $i$, $t_i\geq (1-\varepsilon)APS_i$.

\end{claim}

\begin{proof}
    Fix an agent $i$. At the beginning of the algorithm, $t_i=v_i(\items)\geq APS_i$. during the algorithm we only reduce the value of $t_i$ each time by a factor of $(1-\varepsilon)$. Consider the first time when $t_i<APS_i$. Then, $t_i\geq (1-\varepsilon)APS_i$ (since in its previous value, the variable $t_i$ was greater than $APS_i$).
    Since $t_i<APS_i$, by \Cref{def:conditional algorithm}, every time we run command 3, the bundle of agent $i$ in the resulted allocation $\mathcal{A}$ is of value $\geq\rho t_i$, so we will not reduce the value of $t_i$.
\end{proof}

We prove the correctness of Algorithm~\ref{alg:conditional to unconditional algorithm}. If the algorithm terminates, then it returns an allocation $\mathcal{A}=\langle A_1,\dots,A_n\rangle$  with the property that for every agent $i$ { with $t_i\geq v_i(\items)\cdot\frac{1}{K}$}, $v_i(A_i)\geq \rho_i \cdot t_i$. By \Cref{lower bound of guesses of APS}, we have that each variable $t_i$ holds during the algorithm a value greater than $(1-\varepsilon) APS_i$. Thus, given that the algorithm terminates, {each such} agent $i$ gets a bundle $A_i$ of value at least $(1-\varepsilon) \rho APS_i$. 
%So the correctness boils down to the termination of the algorithm.
It remains to consider those agents $i$ with $t_i<v_i(\items)\cdot\frac{1}{K}$, and for which furthermore, $APS_i > 0$. The assumption that $APS_i>0$ implies that $APS_i \ge v_i(S)$, where $S$ is the bundle of minimum value. Also, $t_i<v_i(\items)\cdot\frac{1}{K} \le v_i(S)$. %$v_i(\items)\cdot\frac{1}{K}\geq v_i(S)$ , which is no greater than $APS_i$. 
Thus, by \Cref{lower bound of guesses of APS}, $v_i(A_i)\geq \rho t_i\geq v_i(S) \ge t_i$ (where the middle inequality holds because every bundle of positive value has value at least $v_i(S)$). As $APS_i < \frac{t_i}{1-\varepsilon}$ (otherwise, the condition of step~4 of the algorithm would not allow the value $t_i$ to be reached), we have that $v_i(A_i)\geq (1 - \varepsilon)APS_i$.


We turn to analyze algorithm's time complexity. 
%showing it is finite and polynomial. \ufc{not true} From \Cref{def:conditional algorithm}, we obtain that command 3 of Algorithm ~\ref{alg:conditional to unconditional algorithm} runs in polynomial time, given value queries. Denote its running time as 
Let $T(n,m,\log K)$ denote the running time of the \emph{conditional}-$\rho$-APS algorithm (called in command 3 of Algorithm ~\ref{alg:conditional to unconditional algorithm}). The number of times that command~3 is run is at most $n\cdot\log_{(1-\varepsilon)}K=n\cdot\frac{1}{\varepsilon}\cdot\log K$ (because in each iteration, at least one $t_i$ drops by a factor of $1-\epsilon$, and the total drop in value of $t_i$ is at most a factor of $K$).
%We need to analyze how many times we run command 3 (i.e., how many iterations for the ``while'' loop). Denote as $K$ to be $\max_{i\in\mathcal{N}}(v_i(\items))$. We begin with every agent $i$ having $t_i=v_i(\items)\leq K$, and we reduce one $t_i$ by an $\varepsilon$ factor in every iteration. Since there are $n$ agents, the ``while'' loop runs for at most $n\cdot\log_{(1-\varepsilon)}K=n\cdot\frac{1}{\varepsilon}\cdot\log K$ many iterations. 
Thus the overall runtime of Algorithm ~\ref{alg:conditional to unconditional algorithm} is $O\left( n\cdot\log(K)\cdot \frac{1}{\varepsilon}\cdot T(n,m,\log K)\right)$, yielding a polynomial time algorithm (under the assumption that $T(n,m,\log K)$ is polynomial).

\end{proof}


%\begin{remark}
%    The proof of Theorem~\ref{thm:polytime} uses the assumption that valuation functions are integer valued, with values in the range $[0,K]$. The statement of the theorem can be modified to a setting in which valuation functions are not integer valued, and instead values of bundles are expressed as rational numbers with numerators and denominators of values at most $K$. The modification is that for every desired $\epsilon > 0$, one can produce an (unconditional) $(\rho - \epsilon)$-APS algorithm, and the running time of the algorithm is polynomial in $n$, $m$, $\log K$, and $\log \frac{1}{\epsilon}$.  The proof of the modified theorem is very similar to that of Theorem~\ref{thm:polytime}, and is omitted.
%\end{remark}

The following theorem, Theorem~\ref{thm:conditionalSubmodular}, is a relatively straightforward consequence of Theorems~\ref{thm:1/3_APS_guarantee} and~\ref{thm:equal-10/27}.

\begin{theorem}
\label{thm:conditionalSubmodular}
    There is a polynomial time conditional $\rho$-APS algorithm for submodular valuations, with $\rho = \frac{1}{3 - 2b_i}$. For the equal entitlement case, there is a polynomial time conditional $\rho$-MMS algorithm for submodular valuations, with $\rho = \frac{10}{27} + {\Omega(\frac{1}{n})}$.
\end{theorem}

\begin{proof}
%    \ufc{Insert a proof. Given the vector of $t_i$, run the bidding game with the respective strategies. Ties can be broken arbitrarily. Explain that there are two ways to address $t_i < APS_i$. One is to observe that the analysis still works. The other, a more generic way, it to truncate at $t_i$, which is allowed because we are dealing with submodular functions, and truncation preserves submodularity.}
As described in the \emph{proportional bidding strategy}, both in the original and \emph{altruistic} version of the bidding game, an agent $i$ executes the \emph{proportional bidding strategy} is required to know/compute their APS (MMS). Based on her $APS_i$ ($MMS_i$), the agent knows how to bid. Consider a modification of the bidding strategy, in which agent $i$ receives as an auxiliary input a value $t_i$ (instead of computing her true APS (MMS) value), and truncates her valuation function at $t_i$, namely $v_i\gets v_i^{t_i}$ (\Cref{def:$v^t_p$}). Then, the agent infers her bidding using the value of $t_i$ instead of $APS_i$ ($MMS_i$). 

The conditional $\rho$-APS algorithm (or $\rho$-MMS algorithm) is simply to simulate the bidding game (or altruistic bidding game) with the $t_i$ values as auxiliary inputs to the agents, and having each agent follow her respective modified proportional bidding strategy.  Now, giving value queries, the bidding game is simulated in polynomial time, where we break ties arbitrarily. It remains to show the correctness of the algorithm. For this, notice that given a value $t_i\leq APS_i$ ($MMS_i$), then by \Cref{claim:truncation} the $APS$ ($MMS$) value of agent $i$ is reduced to $t_i$, and the truncation preserves submodularity. Now the conditions of \Cref{thm:1/3_APS_guarantee} (\Cref{thm:equal-10/27}) are met, and agent $i$ gets a bundle of value at least $\rho$-APS (-MMS), as desired.
\end{proof}

Combining theorems~\ref{thm:polytime} and~\ref{thm:conditionalSubmodular} we prove \Cref{cor:polyTimeSubmodular}, which is restated here for convenience.

\PolySubmodular*

\begin{proof}
\Cref{thm:conditionalSubmodular} states that there is a conditional $\rho$-APS algorithm for submodular valuations with $\rho=\frac{1}{3-2b_i}$. We can assume $b_i\geq\frac{1}{m}$ (as otherwise the APS of agent $i$ is~0,
%\gbc{Should I explain further that if  $b_i<\frac{1}{m}$, each item in a fractional partition associated with $APS_i$ have a total weight strictly less than $\frac{1}{m}$ implying a total weight $< m\cdot\frac{1}{m}$ leading to contradiction?}, 
implying that $\rho = \frac{1}{3} + \Omega(\frac{1}{m})$. Thus, setting $\varepsilon$ to be $O(\frac{1}{m})$ in Algorithm~\ref{alg:conditional to unconditional algorithm} yields the existence of an unconditional $\frac{1}{3}$-APS polynomial time algorithm, as desired. In a similar way for the $MMS$, by setting $\varepsilon$ to be $O(\frac{1}{n})$ we obtain an unconditional $\frac{10}{27}$-MMS polynomial time algorithm.
\end{proof}

%{Corollary~\ref{cor:submodular, additive, and unit demand algorithm} states that if valuation functions of agents come from different classes, then there is an allocation that simultaneously gives each agent a bundle of value that is a certain fraction of her APS, where this fraction depends on the class ($1$ for unit demand, $\frac{3}{5}$ for additive, $\frac{1}{3}$ for submudular). This is a consequence of the fact that all these ratios can be achieved by bidding strategies for a certain bidding game. The bidding game that is used is a variation on the bidding games considered in the current paper, in which agents who win a bid may pick more than a single item (as long as they can afford to pay for the items that they pick). This variation is used in~\cite{BEF21} in their proof of the $\frac{3}{5}$ ratio for additive valuations. Our $\frac{1}{3}$ ratio for submudular valuations extends also to this version of the bidding game (and unit demand bidders have trivial bidding strategies), establishing Corollary~\ref{cor:submodular, additive, and unit demand algorithm}.} \ufe{We now provide more details.}

%\ufe{Recall Definition~\ref{def:conditional algorithm} concerning conditional algorithms.}

Finally, we restate and prove Corollary~\ref{cor:submodular, additive, and unit demand algorithm}.
\PolyEnsamble*




\begin{proof}
For the sake of this proof, we  consider a modified version of the original bidding game. When an agent wins a round (i.e., she is the highest bidder), instead of picking one item, she can pick $k\geq1$ of the remaining items and pay $k$ times her bid.
We consider this version of bidding game because this is the version for which it was previously shown (in~\cite{BEF21}) that additive agents have a bidding strategy that guarantees themselves $\frac{3}{5}$ of their APS. That strategy is implementable in polynomial time. 

We show that in this version of the bidding game, any submodular, additive, or unit-demand agent has a strategy that guarantees herself the relevant guarantee of her APS.
\begin{itemize}
    \item Submodular agents have a strategy that guarantees $\frac{1}{3}+\Omega(\frac{1}{n})$ fraction of their APS. The key property that enables the proportional bidding strategy presented in \Cref{thm:1/3_APS_guarantee} to maintain its guarantee also in the current version of he bidding game is the fact the bidding sequence of a submodular agent executing the proportional bidding strategy is non-increasing. (\Cref{obsrv: bidding sequence decreasing}).
     Therefore, if another agent, $o$, wins a round and decides to pick $k>1$ items, for the submodular agent perspective, this is equivalent to $k$ rounds in which $o$ raises the same bid, and all other agents raise a bid of zero. Since the bids of the submodular agent are non-increasing, the submodular agent will not raise a bid strictly greater than $o$'s bid. Thus, with adversarial tie-breaking, we can guarantee that in both cases of the bidding game, the bundle of the submodular agent will remain the same, and the $\frac{1}{3}+\Omega(\frac{1}{n})$ guarantee from \Cref{thm:1/3_APS_guarantee} holds.
    
    \item Additive agents have a strategy that guarantees a $\frac{3}{5}$ fraction of their APS. The proof is presented in \cite{BEF21}. In addition, \cite{BEF21} presented a polynomial time implementation of this strategy, that does not require knowing the APS value of an agent.
    
    \item Unit-demand agents have a strategy that guarantees a $1$-APS. Consider a unit-demand agent $p$ with entitlement $b_p$. It is easy to verify that the APS of $p$ is the $\lceil \frac{1}{b_p} \rceil$th most valuable item, and $0$ if there are fewer than $\lceil \frac{1}{b_p} \rceil$ items.
    We claim that the simple strategy of $p$ bidding her entire budget in each round and, upon winning, taking the most valuable remaining item guarantees $p$ her APS.
    Since $p$ bids her entire budget until she wins an item, in every round she does not win, at least $b_p$ of the total budget of agents is spent. Hence, $p$ must win one of the first $\lfloor\frac{1}{b_p}\rfloor$ rounds. By that, she guarantees herself one of the $\lfloor\frac{1}{b_p}\rfloor$ most valuable items, which is at least her APS. Note that this strategy does not require agent $p$ to know her APS value, and given access to value queries, her strategy is polynomial-time.
\end{itemize}

It remains to show a transformation from the existence of approximate fair allocation (induced by the above strategies) to a polynomial time algorithm. The proof of this is similar to the proof of \Cref{cor:polyTimeSubmodular}, and is omitted. 
%However, we do stress that the main property that allows the polynomial implementation is that the guarantees of each bidding strategy, as the above, is the independency of the other agents' classes of valuation or their bidding strategies.
\end{proof}

% \gbe{
%     With slight modification, the above algorithm suggests a more general algorithm, in which different agents might have different bidding strategies for their bidding, and hence different fairness guarantees.
%     \cite{BEF21} suggests that an additive agent has a bidding strategy for the original version of the bidding game, which guarantees herself a $\frac{3}{5}$ fraction of her $APS$. Moreover, for unit-demand agents, \cite{BEF21} presents bidding guarantees each such agent an entire APS value. In terms of \Cref{def:conditional algorithm}, \cite{BEF21} presents a conditional $\frac{3}{5}$-APS for additive agents and a conditional $1$-APS for unit demand agents. However, \cite{BEF21} also presents a transformation from a conditional algorithm to an unconditional, in polynomial time, without losing an $\varepsilon$ factor from the approximation ratio. Combining \cite{BEF21} results with \Cref{cor:polyTimeSubmodular} we obtain Corollary ~\ref{cor:submodular, additive, and unit demand algorithm}
%     \gbc{Need to make sure why /Cref does not work here}
    % Therefore, if we have an instance consisting of submodular and additive agents, combining both strategies to agents guarantees the submodular agents a $\frac{1}{3}$-fraction of their APS, and $\frac{3}{5}$-fraction of the APS for the additive agents.}



