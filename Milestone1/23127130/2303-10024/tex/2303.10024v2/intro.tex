% The task of synthesizing a control algorithm for a given dynamical system is a central topic in control theory. 
%This is especially true when the systems one aims at stabilizing are subject to disturbances or only uncertainly known. 
The design of effective control laws guaranteeing closed-loop stability and performance is the quintessential problem in control theory.
% Among the many approaches to do so,  Lyapunov methods~\cite{blanchini2015set} have lately found a renewed interest in the community due to their flexibility and power. 
% Among available approaches
Among the avenues to do so, Lyapunov methods~\cite{blanchini2015set} have traditionally attracted interest in the systems-and-control community in view of their flexibility and power. Indeed, several approaches have been developed to synthesize different forms of Lyapunov functions (e.g., quadratic/quartic, piecewise affine/quadratic) for various types of systems, a task that is often accomplished {through convex optimization~\cite{biswas2005survey, kothare1996robust,parrilo2000structured,WuPrajna2004})}, although other approaches have been explored based on, e.g., neural networks~\cite{gabyetal2022} or formal verification~\cite{munser2021synthesis}. 
 % Common quadratic/quartic, piecewise affine/quadratic, neural networks are just a few among the many types of functions that have been used. To synthesize Lyapunov functions, such templates have been traditionally used with convex optimization approaches~\cite{biswas2005survey, kothare1996robust, parrilo2000structured}, but other ideas have also been explored~\cite{munser2021synthesis}. 
% Recently, Authors have started to explore the idea of using counter-example guided sampling-based approaches~\cite{ravanbakhsh2019learning,mcgough2010symbolic} to synthesize Lyapunov functions, possibly exploiting the presence of already existing baseline controllers~\cite{khansari2017learning, mordatch2014combining}.
A recent trend, instead, looks at the design of (control) Lyapunov functions using counter-example guided sampling-based approaches~\cite{ravanbakhsh2019learning,mcgough2010symbolic}, to possibly take advantage of the presence of baseline controllers already in place~\cite{khansari2017learning, mordatch2014combining}.
Among these, the \textit{counter-example guided inductive synthesis} (CEGIS) family of techniques has found widespread use and success {in %the 
recent years~\cite{solar2006combinatorial,abate2017automated,berger2022learning,chang2019neural,dai2020counter,Abate2023Neural,AhmedPeruffoAbate2020}}. %{\color{red} Citare \cite{WuPrajna2004} da qualche parte del paper, insieme ai vari metodi alternativi suggeriti dal primo reviewer.}
The main idea behind CEGIS consists of designing a function $f: \mathbb{R}^n \to \mathbb{R}$ by exploiting the information contained in a growing dataset 
of \mbox{(counter-)}examples (hereinafter called $\mc C_i$ at step $i$), while making sure that $f$ %also
belongs to some %prescribed 
given
set of functions $\Theta$. 
To this end, CEGIS relies on an iterative adversarial procedure %that involves 
with two actors, a \textit{learner} and a \textit{verifier}.
% , and the inclusion $f\in\Theta$ is certified \textit{after} the learning procedure.
In summary, at each iteration $i\in\mathbb{N}^+$: 
\begin{enumerate}
    \item The learner takes the dataset $\mc C_i$ as input and synthesizes a function $f_i$ from a hypothesis space $\mathcal{H}$, according to some criterion, or establishes that such a function can not be synthesized; 
    \item The selected function $f_i$ is then passed to the verifier, which verifies if  $f_i \in \Theta \coloneqq\{f: \mathbb{R}^n \to \mathbb{R} \mid g(f(z)) \le 0, \text{ for all } z \in \mc Z\}$, for some $g : \mathbb{R} \to \mathbb{R}$ 
    and set $\mc Z \subseteq \mathbb{R}^n$ over which the variable $z$ takes values. The verifier can hence take two different conclusions: 
    \begin{enumerate}
    \item It finds a \textit{counter-example} $z_{i+1} \in \mc Z$ so that $g(f_i(z_{i+1}))>0$. In such a case     
            $
            \mc C_{i+1} \leftarrow \mc C_i \cup \{z_{i+1}\},
            $
            and a new iteration step follows;
            
        
    \item It certifies that no counter-example exists, yielding the positive conclusion of the procedure.

    \end{enumerate}
\end{enumerate}


%One of the most central component of CEGIS-like scheme is the verifier. Many works resorted on very general yet computationally expensive approaches such as SMT approaches~\cite{barrett2018satisfiability,abate2017automated,abate2020formal}, Mixed Integer Programming~\cite{dai2020counter,fabiani2021reliably} or SDP relaxations~\cite{ravanbakhsh2017learning,ravanbakhsh2019learning} to accomplish this taks.  Yet, these methods, may not adapt well to larger scale problems.
%This may be problematic if one is interested in systems affected by uncertainty or stochasticity since the verification process may start involving a large number of variables.

While CEGIS schemes have been successfully employed to design disparate types of (control) Lyapunov functions for different classes of systems \cite{solar2006combinatorial,abate2017automated,berger2022learning,chang2019neural,dai2020counter,Abate2023Neural},  little attention has been given to how such methods can be used to extend the capabilities of traditional robust control approaches, both in terms of enlarging their applicability and, more prominently, of reducing their computational~requirements.

In this paper we make an attempt to fill this gap. %We propose a CEGIS-based method aimed at simplifying the synthesis of control Lyapunov functions, and associated feedback controllers, for linear systems whose parameters are only known to belong to an arbitrary compact set.
Specifically, we start from the classical machinery proposed in \cite{kothare1996robust}, %tailored to stabilize systems subject to polytopic parametric uncertainties,
and leverage a novel Lipschitz-based verification approach, rooted in perturbation of linear operators~\cite{kato2013perturbation}, to efficiently design control Lyapunov functions, and associated feedback controllers, for linear systems whose parameters are only known to belong to an arbitrary compact set. %Moreover, %in all those cases in which the uncertainty set is convex,
This is achieved without introducing %any kind of   introducing 
{conservativeness due to the adoption of a convex polytopic outer-approximation of %to set overapproximation, due
%either
%to the outer approximation of
the %(possibly) %convex %non-polytopic 
uncertainty set. Indeed, due to computational reasons, standard methods use it to approximate the convex hull of such a set (which may have a complex shape), possibly based on a few vertices}. %or the convexification in the nonconvex case. % like often done by other authors~\cite{alessio2007squaring,bernardini2011stabilizing}.
%The synthesis problem is solved using well known  we exploit the well known Linear Matrix Inequality (LMI) machinery to surely avoid candidates failing on known counter-examples. 
%extend the domain of application of the machinery used to stabilize systems subjected to polytopic uncertainties to the case of general connected uncertainty set 
%do not introduce any kind of conservativeness 
%(like in~\cite{alessio2007squaring,bernardini2011stabilizing})
%and 
% In doing so, we also introduce an approach which may make possible stabilizing systems for which it would be otherwise required to solve practically intractable optimization problems if stabilized using classical approaches.
In summary, we make the following contributions:
\begin{itemize}
    \item We design a novel CEGIS-based method, in which the learner solves an LMI feasibility problem, while the verifier a Lipschitz continuous nonconvex one;
    \item We get Lipschitz continuity of the objective function of the verifier's task, which is key to resort on efficient solvers tailored for global Lipschitz optimization;
    \item We prove that our algorithm converges in finite-time.  
\end{itemize}


% The paper is organized as follows: i
In \S \ref{sec:background} we formalize the control problem and recall fundamentals of Lyapunov stability, while in \S \ref{sec:cegis} we describe the learner' and verifier's tasks, characterize the technical properties of the problems they are asked to solve, and establish the finite-time convergence of our CEGIS-based method. Computational aspects are, instead, analyzed in \S \ref{sec:comp_aspect}, 
% {\color{blue} along with potential limitations of the proposed method, which are further characterized in \S \ref{sec:numerical} through numerical examples.}
while numerical examples are finally given in \S \ref{sec:numerical}.
% We finally draw some conclusions and propose%some
% future outlooks in Section~\ref{sec:conclusions}
