\section{Real world Evaluation}
In this section, we evaluate  AICS in the real world in two energy harvesting scenarios by developing a solar and RF-powered acoustic event detector using MSP430 microcontroller-based nodes. We use energy and event traces from real-world datasets for a fair comparison. We design prototypes of intermittent computing platforms with software-controlled cascading capacitor arrays described in Section~\ref{sec:hardware}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.45\textwidth]{fig/pcb.pdf}
    \caption{Custom PCB board with software-controlled cascading capacitor array}
    \label{fig:falinks_pcb}
\end{figure}




% \begin{figure*}[!htb]
% \begin{minipage}{0.45\textwidth}
% \centering
%     \centering
%     \includegraphics[width=\linewidth]{fig/pcb.pdf}
%     \caption{Custom PCB board with software-controlled cascading capacitor array}
%     \label{fig:falinks_pcb}
% \end{minipage}
% \hspace{0.7em}
% \begin{minipage}{0.45\textwidth}
% \centering
%     \includegraphics[width=\linewidth]{fig/circuit-cropped.pdf}
%     \caption{Circuit design of software-controlled cascading capacitor array}
%     \label{fig:falinks_hardware}
% \end{minipage}
% % \vspace{-2em}
% \end{figure*}


\subsection{Implementation and Experimental Setup}
\label{sec:hardware}

\parlabel{Hardware Platform}
We design an MSP430FR994-based prototype shown in Figure~\ref{fig:falinks_pcb} with a unique software-controlled cascading capacitor array that can dynamically customize the number and size of capacitors depending on the requirement. This capacitor array reduces the charging time and supports a broader range of applications.


\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.45\textwidth]{fig/circuit-cropped.pdf}
    \caption{Circuit design of software-controlled cascading capacitor array}
    \label{fig:falinks_hardware}
\end{figure}


Figure~\ref{fig:falinks_hardware} shows the circuit design of the software-controlled cascading capacitor array. Each supercapacitor of the cascading array has two switches~\cite{smarton,luo2023efficient} connected to the harvester and the microcontroller that control capacitor charging (harvesting) and discharging (computing) at any time. When the system restarts, we use a default-OFF switch that disconnects the supercapacitor from the harvester/microcontroller. The first capacitor has a default-ON switch to ensure that at least one capacitor is active. Along with the capacitor array, the platform has a Cascaded Hierarchical Remanence Timekeeper (CHRT)~\cite{dereliable} for timekeeping and uses a low-power microphone at an 8 kHz sampling rate. Figure~\ref{fig:falinks_pcb} shows our prototype board with four capacitors -- one default-ON and three default-OFF switches. We use three identical nodes for this experiment. 

\parlabel{Data Processing Pipeline}
After data acquisition, each intermittent node first converts the time domain data into the frequency domain by performing a 256-point Fast Fourier Transform and then infers a deep neural network-based acoustic event detector. This detector consists of one convolution layer, two fully connected layers, and max pool and batch normalization. The mean inference time of this acoustic event detector in an MSP430FR5994 is 3.89 seconds, consuming 26.72 mJ energy on average. Note that we train this network using a regular GPU machine, then perform pruning to fit the network into the 256 KB non-volatile memory of the system. Finally, we convert the weights and program into suitable binary code to execute in the MSP430 microcontroller. 

\parlabel{Power Failure Protection}
Due to the limited harvestable energy and energy buffer, the entire data processing pipeline can only be executed with interruption. Besides, the stochastic nature of the energy sources causes random power failure. 
To ensure the forward progress of code execution and avoid corrupted results, we divide the pipeline into atomically executable units â€” which guarantees correct intermittent execution using SONIC API~\cite{gobieski2019intelligence}. SONIC stores important program states in the non-volatile memory after the execution of each unit. The system executes the next unit or re-executes the current unit (if it fails to finish before power failure) after each failure. Moreover, we utilize a double-buffered to ensure data integrity when the power supply is interrupted. We further reduce context switching and read-write overheads and minimize memory requirements by double-buffering~\cite{islam2020zygarde,zhang2022demo}.

\parlabel{Energy Source}
In this experiment, we only consider the two types of target energy source behaviors -- available energy is constant over time, and the available energy varies over time. For the fair evaluation of different algorithms, we use a Raspberry Pi logger with an Arduino Uno to collect solar and RF energy traces. We measure the voltage across the load resistor connected to the harvester and collect a total of 11.5 hours long trace. 

We use an Ethylene Tetrafluoroethylene (ETFE) based solar panel with an LTC3105 step-up regulator in indoor and outdoor scenarios. For outdoor scenarios, we deploy the energy collection setups on the pavement of a busy road where passing pedestrians and vehicles are blocking the sun and introducing unexpected unavailability of energy. The collected solar harvester collects up to 100mW of energy. 

We use the Powercast harvester-transmitter pair~\cite{powercast, powercasetransmitter} operating at 915 MHz to harvest RF energy (58-80mW). These energy traces contain the uncontrolled movement of the source and passing traffic (people walking between the harvester and the transmitter). Then we utilize these traces to execute different algorithms in the same energy condition.

\parlabel{Acoustic Event}
We use the Detection and Classification of Acoustic Scenes and Events (DCASE) 2018 challenge "\textit{Large-scale weakly labeled semi-supervised sound event detection in domestic environments}" dataset. It contains 3328 occurrences of ten acoustic events-- alarm bell ringing, dogs, cats, dishes, speech, frying, running water, blender, vacuum, and electric shaver.
An event's maximum and minimum duration is 10 and 0.25 seconds, and multiple events can coincide. To reduce the concurrent occurrence of multiple events, we only consider six types of events whose average duration is below five seconds. This subset has 3003 events with 307 alarm bells ringing, 450 dogs, 246 cats, 445 dishes, 1499 speeches, and 56 blender audios. 

In summary, we play six acoustic events, each lasting between 0.25 and 5 seconds. This dataset provides us with the event occurrence time, allowing us to evaluate different algorithms fairly.

\parlabel{Reward for Suboptimal Reinforcement Learning (SRL)}
The positive reward is straightforward and is given when a device can successfully capture an event. The negative reward is challenging because the device needs to know what happened during the power-off period. To determine the reward without additional sensing, we assume that it missed the data during the last cycle when a node fails to capture the beginning of an event (by observing a higher magnitude after a silence). Then, the system gets a random negative reward where the randomness ensures that not all nodes get the same negative rewards, which can lead to non-collaborative behavior. Note that the system knows the average duration of events as a priori. 

% \begin{figure*}[!htb]
% \begin{minipage}{0.45\textwidth}
% \centering
%     \includegraphics[width=\linewidth]{plot/read_cpsr.pdf}
%     \caption{The capture and process success rate for various algorithms in real-world scenarios.}
%     \label{fig:real_cpsr}
% \end{minipage}
% \hspace{0.7em}
% \begin{minipage}{0.45\textwidth}
% \centering
%     \includegraphics[width=\linewidth]{plot/real_rat.pdf}
%     \caption{Redundant active time for various algorithms in real-world scenarios.}
%     \label{fig:real_rat}
% \end{minipage}
% % \vspace{-2em}
% \end{figure*}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.45\textwidth]{plot/read_cpsr.pdf}
    \caption{The capture and process success rate for various algorithms in real-world scenarios.}
    \label{fig:real_cpsr}
\end{figure}
\subsection{Performance Analysis}
Figure~\ref{fig:real_cpsr} provides the capture and process success rate comparison of our proposed algorithm with the baseline algorithms. As it is only possible to know every node's available and stored energy with communication overhead, we do not consider the Oracle baseline in this real-world experiment. We observe that the greedy swarm, GRDY(3), and the ACES swarm, ACES(3), reflect the $\zeta$ of the simulation during the real-world experiment. Compared to the simulated scenario, the capture and process success rate of fixed and general duty cycles (DC) drops by almost 20\% in the real-world scenario. The simulated result is an average over hundreds of energy scenarios, while the real-world experiment is close to 12 hours of solar and RF traces. Our investigation reveals that in some energy conditions during the simulation, the capture and process success rate is higher than 80\%. In comparison, in some other cases, it is lower than 30\% bringing our average close to 64\%. Moreover, the real-world energy trace combines the constant and variable available energy over time, which we have no control over. 

This real-world experiment also reflects our previous observation that PCP fails to utilize the swarm of nodes fully. Though SRL performed better than RSB in the simulation, in the real world, RBS and SRL can successfully capture and process a similar (less than 3\% difference) number of events. Though these two algorithms' average capture and process success rate are 65\%, they only missed 24.91\% of events on average. The lower $\zeta$ occurred due to failure to complete jobs within the deadline. RBS performs better than simulation because the energy is less random in the real world than in the simulation. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.45\textwidth]{plot/real_rat.pdf}
    \caption{Redundant active time for various algorithms in real-world scenarios.}
    \label{fig:real_rat}
\end{figure}

Figure~\ref{fig:real_rat} shows the redundant active time in the real-world scenario. More than one node has the same active time more than 90\% of the time, which is more than what we have observed in our simulated experiments. Similarly, ACES also observes higher redundant active time than the simulation. The less aggressive clock drift in the real world than in the simulation may contribute to this. Though RBS and SRL have similar capture and process success rate, SRL has lower redundant active time due to the more tailored adaptation by this heuristic. Despite the higher active redundant time than simulation, SRL has higher capture and process success rate than other algorithms. 