\section{Performance Characterization}This section describes the baseline algorithm and performance metric for the evaluation. 

\subsection{Baseline Algorithms}
We compare \Sys against four baseline algorithms -- oracle, greedy, pre-defined duty cycle, and ACES~\cite{fraternali2020aces}. 
% The first three algorithms are used as the baselines for all the energy scenarios, while CIS is only used when the same energy is available to every node. 
For the greedy and ACES algorithms, we consider two variants -- (1) a single node and (2) a swarm of nodes, where wake-up and sleep scheduling happens locally in each node. We leave out simpler algorithms, e.g., round-robin, because a node does not know whether another node has finished executing. To preserve the evaluation's integrity, every algorithm with a swarm of nodes has the same number of nodes. 

\begin{itemize}
    \item \textit{Oracle Algorithm (\textbf{ORCL}).}
    The oracle solution has perfect and prior knowledge of all nodes' energy status without additional computation or memory overhead. At any point in time, the node with the maximum total available and stored energy (in the energy buffer) remains awake if the maximum total energy is more than or equal to the minimum operational energy. 

    \item\textit{Greedy Algorithm (\textbf{GRDY}).}
    In the greedy scheduler, a node wakes up whenever it accumulates enough energy to turn on the microcontroller and executes as long as energy storage has sufficient energy before going to sleep or low-power mode.

    \item \textit{Duty Cycle Algorithm (\textbf{DC}).}
    This algorithm has fixed pre-defined duty cycles for all nodes. However, it starts the nodes at different start times to keep at least one active node at any given time. If $t_h$ is the harvesting time and $t_e$ is the execution time, the duty cycle of the nodes is $t_e + t_h$ (if $t_h$ is divisible by $t_e$) or $t_e + t_h + 1$ (if $t_h$ is not divisible by $t_e$). An offset, $(n-1)t_e$,  determines the start time of the nodes; here, $n$ is the number of the node. 

    \item \textit{Automatic Configuration of Energy Harvesting Sensors (\textbf{ACES}).}
    ACES uses reinforcement learning to maximize each battery-free node sensing performance. Every 15 minutes, each node uses Q-learning to choose between four duty-cycle periods -- 15 seconds, 1 minute, 5 minutes, and 15 minutes.

    % \item \textit{Coalesced Intermittent Sensor (\textbf{CIS}).}
    % CIS only works for scenarios where the target energy is variable but equal for every node. Here, each node keeps track of the energy at the other nodes and then calculates the number of active nodes to randomly chooses whether to sleep or wake up. We only compare  \Sys with CIS only when all nodes have identical energy, as it fails to precisely count active nodes when the available energy at each node varies. We compare this with our proposed priority function, which works when every node has equal energy. 
\end{itemize}

\subsection{Performance Metric}
\label{sec:metric}
We evaluate the performance of our proposed method using two evaluation metrics. 

\begin{itemize}
    \item \textit{Capture and Process Success Rate \textbf{($\zeta$)}.}
    Real-time systems define \textit{schedulability} as a scheduler's ability to schedule all processing tasks in a task set. An amalgamated intermittent system's performance depends on more than just finishing processing within the deadline. It is crucial to consider the success of capturing events. CIS proposes \textit{availability} which refers to when at least one node is active and can capture an event. Nevertheless, it fails to consider finishing a process within the deadline. 

    Hence, we propose the capture and process success rate, defined as $\zeta = \dfrac{|N_C \cap N_P|}{|N|}$, where $N_C$ is the set of successfully captured events, $N_P$ is the set of successfully processed events within the deadline, and $N$ is the set of all events. 
    Given a scheduling algorithm that schedules the wake-up and sleep of intermittent nodes, if all energy and event combinations can be captured and processed within the deadline, we achieve 100\% $\zeta$. If a scheduler can capture and finish processing 50\% of the combined set events, the scheduler has 50\% $\zeta$. If a node only captures the event and fails to process the sample within the deadline, it does not contribute to $\zeta$.
    
    \item \textit{Redundant Active Time \textbf{($\Gamma$)}.}
    As multiple active nodes waste resources, we want only one node to be active at any time. Thus, we measure the redundant active time ($\Gamma$), the percentage of the total time more than one node is active. We define $\Gamma = \dfrac{T - T_{N_1}}{T}\times100$, where $T$ is the total time, and $T_{N_1}$ is when only one node is active. To illustrate, if a single node is active at any time, the redundant active time is 0\%. If only one node is active 30\% of the time, the redundant active time is 70\%. 
    
    % \item \textit{Mean Inactive Time \textbf{($\Lambda$)}.}
    % Mean inactive time means the average timespan when no node is active; thus, the system may fail to capture any event. In other words, mean inactive time denotes the average value of the continuous non-observability or power-off time.
\end{itemize}