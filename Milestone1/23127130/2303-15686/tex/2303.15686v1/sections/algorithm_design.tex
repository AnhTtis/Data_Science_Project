%%%%%%%%%%%%%%
\section{Alternating Analog and Digital Beamforming Optimization Algorithm}
%%%%%%%%%%%%%%
\label{sec: alg design}

In this section, we propose an efficient algorithm named \emph{alternating \acrshort{and} beamforming optimization algorithm} to solve (P1).
\emph{Firstly}, to avoid the high complexity in finding the global optimum of a non-convex problem, we focus on gradient-based methods to search for a local optimum.
\emph{Secondly}, to reduce the complexity in calculating (\ref{optprob: P1}a), we adopt the Monte Carlo method to sample the \acrshort{roi}.
\emph{Thirdly}, to handle the large number of variables, we alternatingly optimize \acrshort{and} beamforming variables and derive the gradient formulas of the \acrshort{crlb} in a matrix form that is easy to calculate.

The \acrshort{roi} is sampled following distribution $\gls{userDistribu}$, and $\gls{numSamples}$ sampled positions are obtained and denoted by set $\gls{setSamples}$.
Then, (\ref{optprob: P1}a) is converted into:
\begin{align}
\label{equ: transformed obj func}
\min_{\gls{sigSet}, \gls{codeSet}}&  \sum_{\gls{userPos} \in \gls{setSamples}} \frac{\mathrm{CRLB}(\gls{userPos})}{\gls{numSamples}}.
\end{align}

We then solve the above problem by alternatingly optimizing $\{\gls{codeMat_i}\}_i$ and $\{\gls{sigMat_ij}\}_{i,j}$ in an iterative manner.
In the $\rho$-th iteration, $\{\gls{codeMat_i}\}_i$ is optimized given $\{\gls{sigMat_ij}\}_{i,j}^{(\rho-1)}$ by solving (sP1):
\begin{subequations}
\begin{align*}
\text{(sP1)}:~\min_{\gls{codeSet}}~ \sum_{\gls{userPos} \in \gls{setSamples}} {\mathrm{CRLB}(\gls{userPos})\over \gls{numSamples}}, \text{s.t.}~ \text{(\ref{equ: matrix forms elements})$\sim$(\ref{equ: decorrelation matrices}), (\ref{optprob: P1}d)}.
\end{align*}
\end{subequations}


To solve~(sP1) efficiently, we derive the gradient formulas of the objective average CRLB in Proposition~\ref{prop: grad of crlb with c}.
\begin{proposition}
\label{prop: grad of crlb with c}
The gradient of the average \acrshort{crlb} w.r.t. $\gls{codeMat_i}$ can be calculated as:\begin{align*}
& \sum_{\gls{userPos}\in \gls{setSamples}}\!{\partial \gls{crlb_userpos}\over \partial \gls{codeMat_i}} \!=\! - \hspace{-.4em}\sum_{\gls{userPos}\in \gls{setSamples}}\hspace{-.4em}\trace({\partial\gls{fimMat_userpos}\over \partial \gls{codeMat_i}}\gls{inv2fimMat_userpos}),\\
& \Big[{\partial\gls{fimMat_userpos}\over \partial \gls{codeMat_i}}\Big]_{u,v} = \bm A_{i,vu}^{\mathrm c} \!+\!  \bm A_{i,uv}^{\mathrm c} \!+\! \bm B_{i,uv}^{\mathrm c} \!+\! \bm B_{i,vu}^{\mathrm c} ,
\end{align*}
where $u,\!v \!\in\! \{1,\!2,\!3\}$. The detailed expressions of $\bm A_{i,uv}^{\mathrm c}$ and $\bm B_{i,uv}^{\mathrm c}$ can be found in Appendix~\ref{appx: 1}.
\end{proposition}
\begin{IEEEproof}
The gradient is obtained by calculating the partial derivatives of~(\ref{equ: general crlb expression}) w.r.t. \gls{codeMat_i},  based on~(36)$\sim$(40) in~\cite{matrix_cookbook}.
\end{IEEEproof}

Based on~Proposition~\ref{prop: grad of crlb with c}, (sP1) is solved by updating \gls{codeSet} along the inverse direction of the gradient.
As for the constraints in (sP1), constraints~(\ref{equ: matrix forms elements})$\sim$(\ref{equ: decorrelation matrices}) are implicitly contained in the calculation of gradients.
Besides, constraint~(\ref{optprob: P1}d) can be handled by the \emph{interior point approach}, where a barrier function is used to restrict $\gls{codeSet}$ within its feasible region~\cite{Byrd2000Trust}.
Moreover, we adopt \emph{\acrfull{cg} method} to calculate the update by solving a quadratic approximation of (sP1) within a local region of current $\gls{codeSet}$~\cite{Byrd2000Trust}.
The result of solving (sP1) in the $\rho$-th iteration is denoted by $\{\bm C_{i}\}_i^{(\rho)}$.

Given $\{\bm C_{i}\}_i^{(\rho)}$, $\{\gls{sigMat_ij}\}_{i,j}$ is optimized by solving (sP2):
\begin{subequations}
\begin{align}
\text{(sP2)}:~\min_{\gls{sigSet}}~ \hspace{-0.3em}\sum_{\gls{userPos} \in \gls{setSamples}}\! {\mathrm{CRLB}(\gls{userPos})\over \gls{numSamples}},~
\text{s.t.}~\text{(\ref{equ: matrix forms elements})$\sim$(\ref{equ: decorrelation matrices}), (\ref{optprob: P1}c)}. \nonumber
\end{align}
\end{subequations}


Similar with solving~(sP1), we adopt gradient-based method to solve~(sP2), where the gradient is derived in Proposition~\ref{prop: grad of crlb with s}.
 \begin{proposition}
\label{prop: grad of crlb with s}
The gradient of the average \acrshort{crlb} w.r.t. $\gls{sigMat_ij}$ can be calculated as
\begin{align*}
& \sum_{\gls{userPos}\in \gls{setSamples}}\hspace{-1em}{\partial \gls{crlb_userpos}\over \partial \gls{sigMat_ij}} \!=\! - \hspace{-0.0em}\sum_{\gls{userPos}\in \gls{setSamples}}\hspace{-0.0em}\trace({\partial\gls{fimMat_userpos}\over \partial \gls{sigMat_ij}}\!\gls{inv2fimMat_userpos}),\\
& [{\partial\gls{fimMat_userpos}\over \partial \gls{sigMat_ij}}]_{u,v} =  \bm A_{ij,vu}^{\mathrm s}\!+\!  \bm A_{ij,uv}^{\mathrm s} \!+\! \bm B_{ij,uv}^{\mathrm s} \!+\! \bm B_{ij,vu}^{\mathrm s},
\end{align*}
where $u,\!v \!\in\! \{1,\!2,\!3\}$.
The detailed expressions of $\bm A_{ij,uv}^{\mathrm s}$ and $\bm B_{ij,uv}^{\mathrm s}$ can be found in Appendix~\ref{appx: 1}.
\end{proposition}
\begin{IEEEproof}
The gradient is obtained by calculating partial derivatives of~(\ref{equ: general crlb expression}) w.r.t. \gls{sigMat_ij},  based on~(36)$\sim$(40) in~\cite{matrix_cookbook}.
\end{IEEEproof}

We solve (sP2) also by gradually updating each $\gls{sigSet}$ along the inverse direction of its gradient, and the interior point approach is used to handle constraint~(\ref{optprob: P1}c) with \acrshort{cg} method utilized to calculate the update.
The result of solving~(sP2) in the $\rho$-th iteration is denoted by $\{\bm S_{i,j}\}_{i,j}^{(\rho)}$.

Within each iteration, the number of update steps for $\{\gls{codeMat_i}\}_i$ and $\{\gls{sigMat_ij}\}_{i,j}$ are denoted by \gls{numUpdate}.
The iteration process terminates when the results are not changed by the last update or when the number of iterations exceeds $\gls{numMaxIteration}$.
The complete algorithm is summarized as Algorithm~1.


\begin{algorithm}[!t]
\small
  \caption{Alternating Analog and Digital Beamforming Optimization Algorithm}
\label{alg: summary algorithm}
\begin{algorithmic} [1]
\State Sample $\gls{numSamples}$ positions following $\gls{userDistribu}$ and obtain $\gls{setSamples}$.
\State Set initial points by $\{\gls{sigMat_ij}\}_{i,j}^{(0)} = \{\gls{sigMat_ij}|\gls{sigVec_ijq}=\bm 1\cdot \sqrt{\gls{userMaxPower}}/\gls{numFeed}\}$ and $\{\gls{codeMat_i}\}_i^{(0)}$ with elements randomly chosen from $[0,1]$.
\For{$\rho = 1, ..., \gls{numMaxIteration}$}
\State Given $\{\gls{sigMat_ij}\}_{i,j}^{(\rho-1)}$ and $\{\gls{codeMat_i}\}_i^{(\rho-1)}$, solve (sP1) to obtain $\{\gls{codeMat_i}\}_i^{(\rho)}$ using the gradient formula in Proposition~\ref{prop: grad of crlb with c}.
\State Given $\{\gls{codeMat_i}\}_i^{(\rho)}$ and $\{\gls{sigMat_ij}\}_{i,j}^{(\rho-1)}$, solve (sP2) to obtain $\{\gls{sigMat_ij}\}_{i,j}^{(\rho)}$ using the gradient formula in Proposition~\ref{prop: grad of crlb with s}.
\State \textbf{If} $\{\gls{sigMat_ij}\}_{i,j}^{(\rho-1)}\!=\!\{\gls{sigMat_ij}\}_{i,j}^{(\rho)}$ and $\{\gls{codeMat_i}\}_i^{(\rho-1)}\!=\!\{\gls{codeMat_i}\}_i^{(\rho)}$: \textbf{break}
\EndFor
\State \Return $\{\gls{sigMat_ij}\}_{i,j}^{*}=\{\gls{sigMat_ij}\}_{i,j}^{(\rho)}$ and $\{\gls{codeMat_i}\}_i^{*}=\{\gls{codeMat_i}\}_i^{(\rho)}$.
\end{algorithmic}
\end{algorithm}

\endinput