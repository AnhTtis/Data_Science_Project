\section{Implementation of CFR and CFR+}

Most implementations of CFR and CFR+ employ the depth-first search of the game tree~\cite{tammelin2014solving,neller2013introduction}.
This method has the advantage of greatly reducing computation time in huge games, at the expense of accuracy, by using sampling.
On the other hand, simply exploring all nodes may be computationally inefficient.
For example, in a game with multiple terminal nodes $z \in Z$ such that the pair $(p_1(z),p_2(z))$ is equal (see Section \ref{sec-efg} for the definition of $p_1, p_2$), all terminal nodes are searched at each iteration in the depth-first search type implementation, but in the BSPP type unnecessary. 

This paper presents CFR and CFR+ implementations using the BSPP representation of the extensive-form game introduced in Section \ref{sec-efg}.
These implementations are also available on~\url{https://github.com/habara-k/egt-on-efg}.

\begin{algorithm}[htbp]
\caption{CFR and CFR+ (in BSPP form)}
\begin{algorithmic}[1]
\Function{prod}{$\bm z\in\R_{\ge 0}^\abs{\Sigma}$}
\State $\bm x \gets \bm 0\in\R^\abs{\Sigma}$
\State $x_\emp \gets 1$
\For{$I\in\mathcal{I}$ in top-down order}
    \For{$a\in\A(I)$}
        \State $x_{I,a} \gets x_{p(I)} z_{I,a}$
    \EndFor
\EndFor
\State \Return $\bm x$
\EndFunction
\Statex
\Function{normalize}{$\bm r\in\R_{\ge 0}^\abs{\Sigma}$}
\State $\bm z\gets \bm 0\in\R^\abs{\Sigma}$
\For{$I\in\mathcal{I}$}
    \If{$\exists a\in\A(I) \text{ s.t. } r_{I,a}>0$}
        \For{$a\in\A(I)$}
            \State $z_{I,a} \gets r_{I,a}/\sum_{a\in\A(I)} r_{I,a}$
        \EndFor
    \Else
        \For{$a\in\A(I)$}
            \State $z_{I,a} \gets 1/\abs{\A(I)}$
        \EndFor
    \EndIf
\EndFor
\State \Return $\bm z$
\EndFunction
\Statex
\Function{regret}{$\bm z\in\R^\abs{\Sigma}, \bm u\in\R^\abs{\Sigma}$}
\State $\bm r\gets \bm 0\in\R^\abs{\Sigma}$
\For{$I\in\mathcal{I}$ in bottom-up order}
    \For{$a\in\A(I)$}
        \State $r_{I,a} \gets u_{I,a} - \sum_{a\in\A(I)} u_{I,a} z_{I,a}$
    \EndFor
    \State $u_{p(I)} \gets u_{p(I)} + \sum_{a\in\A(I)} u_{I,a} z_{I,a}$
\EndFor
\State \Return $\bm r$
\EndFunction
\algstore{cfr}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htbp]
\begin{algorithmic}[1]
\algrestore{cfr}
\Ensure{$\bm x\in Q_1, \bm y\in Q_2$: solutions of CFR}
\State $\bm r_\X, \bm r_\Y \gets \bm 0\in\R^\abs{\Sigma_1}, \bm 0\in\R^\abs{\Sigma_2}$
\State $\bm z_\X, \bm z_\Y \gets $ \Call{normalize}{$\bm r_\X$}, \Call{normalize}{$\bm r_\Y$}
\State $\bm x^1, \bm y^1 \gets $ \Call{prod}{$\bm z_\X$}, \Call{prod}{$\bm z_\Y$}
\For{$k=1,\dots,T-1$}
    \State $\bm r_\X \gets \bm r_\X \ + $ \Call{regret}{$\bm z_\X, -\bm A\bm y^k$}
    \State $\bm r_\Y \gets \bm r_\Y \ + $ \Call{regret}{$\bm z_\Y, \bm A^\T\bm x^k$}
    \State $\bm z_\X \gets $ \Call{normalize}{$\max(\bm r_\X, \bm 0)$}
    \State $\bm z_\Y \gets $ \Call{normalize}{$\max(\bm r_\Y, \bm 0)$}
    \State $\bm x^{k+1} \gets $ \Call{prod}{$\bm z_\X$}
    \State $\bm y^{k+1} \gets $ \Call{prod}{$\bm z_\Y$}
\EndFor
\State $\bm x, \bm y \gets \frac{1}{T}\sum_{k=1}^T k\bm x^k, \frac{1}{T}\sum_{k=1}^T k\bm y^k$
\Statex
\Ensure{$\bm x\in Q_1, \bm y\in Q_2$: solutions of CFR+}
\State $\bm r_\X, \bm r_\Y \gets \bm 0\in\R^\abs{\Sigma_1}, \bm 0\in\R^\abs{\Sigma_2}$
\State $\bm z_\X, \bm z_\Y \gets $ \Call{normalize}{$\bm r_\X$}, \Call{normalize}{$\bm r_\Y$}
\State $\bm x^1, \bm y^1 \gets $ \Call{prod}{$\bm z_\X$}, \Call{prod}{$\bm z_\Y$}
\For{$k=1,\dots,T-1$}
    \State $\bm r_\X \gets \max(\bm r_\X \ + $ \Call{regret}{$\bm z_\X, -\bm A\bm y^k$}$, \bm 0)$
    \State $\bm z_\X \gets $ \Call{normalize}{$\bm r_\X$}
    \State $\bm x^{k+1} \gets $ \Call{prod}{$\bm z_\X$}
    
    \State $\bm r_\Y \gets \max(\bm r_\Y \ + $ \Call{regret}{$\bm z_\Y, \bm A^\T\bm x^{k+1}$}$, \bm 0)$
    \State $\bm z_\Y \gets $ \Call{normalize}{$\bm r_\Y$}
    \State $\bm y^{k+1} \gets $ \Call{prod}{$\bm z_\Y$}
\EndFor
\State $\bm x, \bm y \gets \frac{2}{T+T^2}\sum_{k=1}^T k\bm x^k, \frac{2}{T+T^2}\sum_{k=1}^T k\bm y^k$
\end{algorithmic}
\end{algorithm}