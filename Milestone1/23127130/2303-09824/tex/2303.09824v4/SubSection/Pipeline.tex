\section{Pipeline Planning Methods \label{ppl}}

The pipeline method, also known as the modular approach, is widely used in the industry and has become the conventional approach. This method originates from architectures that primarily evolved for autonomous mobile robots and consists of self-contained, interconnected modules such as perception, localization, planning, and control.

Planning methods are responsible for calculating a sequence of trajectory points for the ego vehicle's low-level controller to track, typically consisting of three functions: global route planning, local behavior planning, and local trajectory planning \cite{Li2,Li3}. \textcolor{black}{ Global route planning provides a road-level path from the start point to the end point on a global map. Local behavior planning decides on a driving action type (e.g., car-following, nudge, side pass, yield, and overtake) for the next several seconds. Local trajectory planning generates a short-term trajectory based on the decided behavior type. In fact, the boundary between local behavior planning and local trajectory planning is somewhat blurred \cite{Li2}, as some behavior planners do more than just identify the behavior type. For the sake of clarity, this paper does not strictly distinguish between the two functions, and the related methods are simply regarded as trajectory planning methods.}

\textcolor{black}{This section categorizes the related algorithms into two functions: global route planning and local behavior/trajectory planning. To provide a more detailed analysis and discussion, local behavior/trajectory planning is divided into three components: state grid identification, primitive generation, and other approaches, based on their respective extension methods and optimization theories}
\subsection{Global Route Planning}
% Dijkstra
Global route planning is responsible for finding the best road-level path in a road network, which is presented as a directed graph containing millions of edges and nodes. A route planner searches in the directed graph to find the minimal-cost sequence that links the starting and destination nodes. Herein, the cost is defined based on the query time, preprocessing complexity, memory occupancy, and solution robustness considered. Edsger Wybe Dijkstra is a pioneer in this field and innovatively proposes the Dijkstra algorithm \cite{GlobalPath_Dijkstra,Dij} named after him. Lotfi et al. \cite{Advance_dijkstra} construct a Dijkstra-based intelligent scheduling framework that computes the optimal scheduling for each agent, including maximum speed, minimum movement, and minimum consumption cost. A-star algorithm \cite{Astar,Astar69} is another famous algorithm in road-level navigation tasks, it leverages the advantages of the heuristic function to streamline research space. All of these algorithms substantially alleviate the problem of transportation efficiency and garnered significant attention in the field of intelligent transportation systems.





\subsection{Local Behavior/Trajectory Planning}
Local behavior planning and local trajectory planning functions work together to compute a safe, comfortable and continuous local trajectory based on the identified global route from route planning. 
Since the resultant trajectory is local, the two functions have to be implemented in a receding-horizon way unless the global destination is not far away \cite{Li6}. It deserves to emphasize that the output of the two functions should be a trajectory rather than a path \cite{Li7, tmach}, and the trajectory interacts with other dynamic traffic participants, otherwise, extra efforts are needed for the ego vehicle to evade the moving obstacles in the environment.

Nominally, local planning is done by solving an optimal control problem (OCP), which minimizes a predefined cost function with multiple types of hard or soft constraints satisfied \cite{SoftConstrain,Li16}. The solution to the OCP is presented as time-continuous control and state profiles, wherein the desired trajectory is reflected by a part of the state profiles. \textcolor{black}{As shown in Equ. \ref{equ:pipline}, the state space of the vehicle is denoted as $\bm{z} \in \mathbb{R}^{n_{z}}$, the control space is presented as $\bm{u} \in \mathbb{R}^{n_{u}}$. $\Upsilon$ shows the workspace. The obstacle space as $\Upsilon_{OBS}\subset \Upsilon$and the free space is described as  $\Upsilon_{FREE}\subset \Upsilon\setminus \Upsilon_{OBS}$.}

\begin{eqnarray}
    \begin{aligned}
        \min_{\bm{z}(t),\bm{u}(t),T}&{J (\bm{z}(t),\bm{u}(t))},\\
        s.t.,&\dot{\bm{z}}(t)=f(\bm{z}(t),\bm{u}(t));\\
        &\bm{z}\le \bm{z}(t)\le \bm{\bar{u}},\bm{u}\le \bm{u}(t)\le \bm{\bar{z}},,t\in [0,T];\\
        &\bm{z}(0)=\bm{z}_{init},\bm{u}(0)=\bm{u}_{init};\\
        &g_{end}(\bm{z}(T), \bm{z}(T)) \le 0;\\
        &fp(\bm{z}(t))\subset \Upsilon_{FREE},t\in [0,T];
    \end{aligned}
    \label{equ:pipline}
\end{eqnarray}

\textcolor{black}{
 The planning process duration in seconds is described as $T$, where $t\subset T$, and the cost function to be minimized is denoted as $J$. We use the common shorthand $\dot{\bm{z}}$ to denote the derivative with respect to time, $\dot{\bm{z}}=\partial \bm{z}/ \partial \bm{t}$, $\dot{\bm{u}}=\partial \bm{u}/ \partial \bm{t}$. The vehicle kinematic is described by the function $f$ and the allowable intervals where $\bm{z}(t)$ and $\bm{u}(t)$ are denoted by $[\bm{z},\bm{\bar{z}}]$ and $[\bm{u},\bm{\bar{u}}]$ respectively, where $\bm{z}$ and $\bm{u}$ representing the initial values. The inequality $g_{end} \le 0$ models the implicit end-point conditions at $t = T$. Finally, $f$ is a mapping from the vehicle state to its footprints, and $fp(\cdot ):\mathbb{R}^{n_{z}}\to \mathbb{R}^{2}$ represents the collision-avoidance constraints. In the following context of this section, we provide a detailed review of the motion planning method based on this scheme.
}

Since the analytical solution to such an OCP is generally not available, two types of operations are needed to construct a trajectory. Concretely, local planning is divided into three parts, the first type of operation is to identify a sequence of state grids, the second type is to generate primitives between adjacent state grids, and The third is an organic combination of the first two.

\subsubsection{State Grid Identification}  
State grid identification can be done by search, selection, optimization, or potential minimization. Search-based methods abstract the continuous state space related to the aforementioned OCP into a graph and find a link of states there. Prevalent search-based methods include A* search \cite{Li17} and dynamic programming (DP) \cite{Li19}.  Many advanced applications of these algorithms have pushed its influence to the top of the heap, such as Hybrid A*\cite{hybridAstar}, Bi-direction A*, Semi-optimization A*\cite{Bi-Astar}, and LQG framework \cite{Li19}. Selection-based methods decide the state grids in the next one or several steps by seeking the candidate with the optimal cost function. Greedy selection \cite{Li22} and Markov decision process (MDP) series methods typically \cite{Li23,Li24} fall into this category.

An optimization-based method discretizes the original OCP into a mathematical program (MP), the solution of which are high-resolution state grids \cite{Li28,Li29}. MP solvers are further classified as gradient-based and non-gradient-based ones; gradient-based solvers typically solve nonlinear programs \cite{Li16}, quadratic programs \cite{Li21,Li28,Li31}, quadratically constrained quadratic programs \cite{Li30} and mix-integer programs; non-gradient-based solvers are typically represented by metaheuristics \cite{Li35}. Multiple previous methods could be combined to provide a coarse-to-fine local behavior/motion planning strategy.
\begin{figure*}[t]
    \centering
    \includegraphics[width=0.88\linewidth]{Pictures/MindMapE2E.png}
    \caption{The critical method survived in End-to-End Planning Section. The time axis (dark blue) represents the progressiveness of the survived methods, and the performance of the methods is better with the latter proposed time.}
    \label{fig:Mindmap}
\end{figure*}
\subsubsection{Primitive Generation} 
Primitive generation commonly manifests as closed-form rules, simulation, interpolation, and optimization. Closed-form rules stand for methods that compute primitives by analytical methods with closed-form solutions. Typical methods include the Dubins/Reeds-Shepp curves \cite{Li42}, polynomials \cite{Li22}, and theoretical optimal control methods \cite{Li44, hu2018dynamic}. Simulation-based methods generate trajectory/path primitives by forwarding simulation, which runs fast because it has no degree of freedom \cite{Li17}. Interpolation-based methods are represented by splines or parameterized polynomials \cite{Li46}. Optimization-based methods solve a small-scale OCP numerically to connect two state grids \cite{Li47,Li48}.

\subsubsection{Other Approaches}
State grid identification and primitive generation are two fundamental operations to construct a trajectory. Both operations may be organized in various ways. For example, Kuwata et al. \cite{Li45} integrate both operations in an iterative loop; Hu et al. \cite{Li47} build a graph of primitives offline before online state grid identification; Fan et al. \cite{Li21} identify the state grids before generating connective primitives. If a planner only finds a path rather than a trajectory, then a time course should be attached to the planned path as a post-processing step \cite{Li48}. This strategy, denoted as path velocity decomposition (PVD), has been commonly used because it converts a 3D problem into two 2D ones, which largely facilitates the solution process. Conversely, non-PVD methods directly plan trajectories, which has the underlying merit to improve the solution optimality \cite{Li19,Li20,Li51,li12342}.

Recent studies in this research domain include how to develop specific planners that fit specific scenarios/tasks particularly \cite{Li6,Li51}, and how to plan safe trajectories with imperfect upstream/downstream modules \cite{Li51}. The past decades have seen increasingly rapid progress in the autonomous driving field. In addition to the advances in computing hardware, this rapid progress has been enabled by major theoretical progress in the computational aspects of mobile robot motion planning theory. Research efforts have undoubtedly been spurred by the improved utilization and safety of road networks that intelligent vehicles would provide.
