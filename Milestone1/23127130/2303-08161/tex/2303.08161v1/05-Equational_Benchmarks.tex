% !TEX root = main.tex
\section{Equational Benchmarks for \cbv Program Equivalences}
\label{sect:benchmarks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In \cbn, there are only two benchmarks, or degrees of freedom, for program equivalences, namely $\eta$-equivalence and the scrutable equivalence. In \cbv, the situation is richer, there are various equivalences that can be validated or not. Here we list the most relevant ones. We start by discussing the \cbv variants of $\eta$-equivalence and scrutability, and then present the equivalences that are found in known extensions of Plotkin's calculus.

For all the equivalences, we simply give the root axioms defining them, assuming that they are closed by all contexts. All the given equivalences (but \cbn erasure) are validated by \cbv contextual equivalence $\eqcv$. Some of them rather appear in the literature as reductions, but for the sake of uniformity we discuss them as equivalences. The meaning of some of the equivalences from extended \cbv calculi might seem obscure. They shall make more sense after the introduction of explicit substitutions in \refsect{vsc}.

In \cbv, $\eta$-equivalence has to be restricted, otherwise it turns non-values into values. At first sight, the by value version of $\eta$ seems to be $\val \equivetav \la\var{\val\var}$ if $\var\notin\fv\val$. But since any \cbv program equivalence validates $\betav$-reduction, the case $\val=\la\vartwo\tm$ is actually caught by $\betav$-reduction  (because $\la\var (\la\vartwo\tm)\var \tobv \la\var\tm\isub\vartwo\var =_\alpha \la\vartwo\tm$), so that $\equivetav$ simply amounts to the variable case.
\begin{itemize}
\item \emph{$\etav$ equivalence}: $\vartwo \equivetav \la\var{\vartwo\var}$ for every variable $\vartwo$.
\end{itemize}


\paragraph{\cbv Scrutability} Scrutability adapts to \cbv by simply replacing the use of $\tob$ with $\tobv$.
\begin{definition}[\cbv (in)scrutability]
\label{def:cbv-scrutability}
A term $\tm$ is \emph{\cbv scrutable} if there is a testing context $\tctx$ (see \refdef{cbn-scrutability}) and a value $\val$ such that $\tctxp\tm \tobv^* \val$, otherwise $\tm$ is \emph{\cbv inscrutable}.
\end{definition}
The equivalence to be validated here is the following one:
\begin{itemize}
\item \emph{(In)scrutable equivalence}: $\tm \equivscr \tmtwo$ if $\tm$ and $\tmtwo$ are \cbv inscrutable.
\end{itemize}
\cbv inscrutable terms are the right notion of \emph{meaningless term} in \cbv, as they are exactly the minimum ones for the contextual preorder $\leqcv$. In Plotkin's calculus, \cbv scrutable terms, however, cannot have an operational characterization analogous to that of \cbn scrutable terms (\refthm{cbn-scrutability-characterization})---they shall have one in the VSC. For instance, a term such as $\Omega^L \defeq (\la\var\delta)(\vartwo\varthree)\delta$ is \cbv inscrutable and yet it is normal for Plotkin, while it should diverge if a good characterization existed. 

The equivalence $\equivscr$ has a special role among those listed here because whether a term is (in)scrutable is \emph{undecidable}, so that the equivalence cannot be seen as computational principle to be tested via a rewriting rule. It is then all the more relevant that a program equivalence validates it.

\paragraph{Moggi} We now turn to equivalences found in extensions of Plotkin's calculus. The equivalences enriching $\betav$-conversion in Moggi's untyped computational $\l$-calculus are the following ones, here reformulated without ${\tt let}$-expressions:
\begin{itemize}
	\item \emph{Left identity}: $\Id \tm \equiv_{lid} \tm$, where $\Id=\la\var\var$ is the identity combinator;
	\item \emph{Associativity of lets}: $(\la\var\tm)((\la\vartwo\tmtwo)\tmthree) \equivass (\la\vartwo(\la\var\tm)\tmtwo)\tmthree)$ if $\vartwo \not \in \fv\tmtwo$;
	\item \emph{Left decomposition of applications}: $\tm\tmtwo \equivlad (\la\var\var\tmtwo)\tm$ if $\var\not\in\fv\tmtwo$;
	\item \emph{Right decomposition of applications}: $\val\tm \equivrad (\la\var\val\var)\tm$ if $\var\not\in\fv\val$. This one exists also in an extended form: $\tmtwo\tm \equivexrad (\la\var\tmtwo\var)\tm$ if $\var\not\in\fv\val$
\end{itemize}
Of them, the delicate one for our study is $\equivlid$, which in Plotkin's calculus holds only for values, as for values it is an instance of $\betav$-conversion, while in Moggi's holds for every term $\tm$.

\paragraph{Shuffling} Carraro's and Guerrieri's \emph{shuffling calculus} \cite{shufflingcalculus} extends Plotkin's calculus with the \cbv variants, noted $\tosone$ and $\tosthree$, of some shuffling rules introduced in \cbn by Regnier \cite{regnier94}. The induced equivalences follows.
\begin{itemize}
	\item $(\la\var\tm)\tmtwo\tmthree \equivsone (\la\var\tm\tmthree)\tmtwo$ if $\var\not\in\fv\tmthree$;
	\item $\val((\la\var\tm)\tmtwo) \equivsthree (\la\var\val\tm)\tmtwo$ if  $\var\not\in\fv\val$.
\end{itemize}
Note that Moggi's $\equiv_{ass}$ rule is an instance of $\equivsthree$.

\paragraph{Proof Nets} The \cbv translation of $\l$-calculus in linear logic proof nets, studied in detail by Accattoli \cite{Accattoli-proofnets}, equates various pairs of terms. The induced equivalences are better expressed with explicit subsitution, as we shall see in \refsect{benchmarks-vsc}, but we anticipate them here anyway. They subsume Moggi's $\equivass$ and the shuffling equivalences. Moreover, they include the following equivalences.
\begin{itemize}
	\item Extended $\sigma_3$: $\tmthree((\la\var\tm)\tmtwo) \equivexsthree (\la\var\tmthree\tm)\tmtwo$ if  $\var\not\in\fv{\tmthree}$;
	\item Commutativity: $(\la\vartwo(\la\var\tm)\tmtwo)\tmthree \equivcom (\la\var(\la\vartwo\tm)\tmthree)\tmtwo$ if $\var\notin\fv\tmthree$ and $\vartwo\notin\fv\tmtwo$.
\end{itemize}
The first one is a slight generalization of $\equivsthree$ replacing the value $\val$ with whatever term $\tmthree$. Commutativity swaps adjacent and unrelated redexes. It is a special equivalence, for at least two reasons. 
\begin{enumerate}
\item \emph{Effects}: commutativity holds in the pure \cbv setting but it often fails in extensions of \cbv with effects, because many effects are order-dependent (think of the order of writes on a memory cell). Therefore, it is an equivalence that one might want to be able to modularly add or remove from a notion of bisimilarity, rather than always validate it. 
\item \emph{Unorientable}: being symmetric, commutativity cannot be oriented as a rewriting rule. Therefore, any normal form bisimulation validating it needs to be able to compare normal forms up to some deformation of terms.
\end{enumerate}
The reason why some equivalences at times appear in restricted forms is also related to effects. The idea is that with non-commutative effects one has to fix a deterministic evaluation strategy, typically left-to-right, and this constrains the shape of equivalences forcing a sub-term to be a value $\val$, as in $\equivrad$ and $\equivsthree$. Proceeding right-to-left would relax them but force other dual constraints (such as $\tm$ being a value in $\equivlad$), and adopting a non-specified order induces the extended versions.

\paragraph{\cbn Duplication and \cbn Erasure} The last equivalences that we consider are \cbn duplication and \cbn erasure. We do not actually know how to characterize \cbn duplication independently of erasure with an axiom, or a set of axioms, but we discuss a specific case, to illustrate the idea.
\begin{itemize}
\item \emph{\cbn Duplication}: $(\la\var \vartwo \var \var) \tmtwo \equiv_{dup} \vartwo \tmtwo\tmtwo$;
\item \emph{\cbn Erasure}: $(\la\var \tm ) \tmtwo \equiv_{era} \tm$ with $\var\notin\fv\tm$.
\end{itemize}
In \cbv, duplication and erasure are included in $\betav$-conversion if $\tmtwo$ is a value, but not otherwise. For arbitrary terms, erasure is unsound in \cbv, because erasing a sub-term might turn divergence into termination: for instance $\tm\defeq (\la\var\varthree)(\vartwo\vartwo)$ is not contextually equivalent to $\tmtwo\defeq \la\var\varthree$ in \cbv, because $\ctxp\tm$ diverges while $\ctxp\tmtwo$ terminates with respect to the context $\ctx\defeq (\la\vartwo\ctxhole)\delta$. 

Duplication, instead, is sound for arbitrary terms, the idea being that terminating (resp. diverging) once, or terminating (resp. diverging) twice does not affect termination (resp. divergence). It is however a suspicious principle in \cbv. The cornerstone of \cbv is the idea that one should reduce arguments \emph{before} substituting them, and \cbn duplication does exactly the opposite. Intuitively, a \cbv program equivalence validating \cbn duplication is \emph{qualitative} or \emph{cost-insensitive}, as it only observes termination, while one rejecting it is somehow \emph{quantitative} or \emph{cost-sensitive}, as it distinguishes between differently efficient ways of realizing the same qualitative behavior.

\paragraph{Summing Up} Of all the discussed equivalences, the most relevant ones for our study are the scrutable equivalence $\equivscr$ and left identity $\equivlid$. Commutativity $\equivcom$ shall also be a source of inspiration for the modular \emph{mirror} approach of \refsect{net}. \cbn Duplication is validated by \cbv contextual equivalence while none of the program equivalences studied in this paper validates it. On the one hand, this fact shows that they are sound but not complete with respect to contextual equivalence. On the other hand, it shows that such incompleteness is not necessarily a negative fact,  because a cost-insensitive theory of \cbv is in some sense an oxymoron.