% !TEX root = main.tex

\section{From Operational to Denotational Semantics: the Type Preorder}
In this section, we study a behavioral preorder, the \emph{type preorder} $\leqtype$, which is not defined as a normal form similarity, it is instead induced by a denotational model. Namely, Ehrhard's \cbv relational model \cite{DBLP:conf/csl/Ehrhard12} presented as a system of multi types, also known as \emph{non-idempotent intersection types}. We shall prove that both Lassen's similarity $\leqenf$ and our net similarity $\leqnet$ are included in $\leqtype$. The aim is to show that, while $\leqenf$ and $\leqnet$ are incomparable, they can be combined in a cost-sensitive preorder (the contextual preorder combines them but it is not cost-sensitive). We introduce the bare minimum about \cbv multi types. For more, see Accattoli and Guerrieri \cite{Accattoli-Guerrieri-TypesFireballs,DBLP:journals/corr/abs-2104-13979,DBLP:journals/pacmpl/AccattoliG22}.


%Let's first recall the definition of a lambda-model, in the case of Call-by-Value evaluation, adding clauses for explicit substitutions as we are considering the Value Substitution Calculus.

%\begin{definition}[Lambda-model, \cite{lambda-models-dezani}]
%	A $\l$-model is a pair $(\dom, \interp{~})$ where $\dom$ is a set, $\interp{~}$ is a mapping from $\l$-terms to elements of $\dom$ called the \emph{interpretation} and $\interp{~}$ satisfies the following:
%	
%	\begin{itemize}
%		%\item \emph{(applicative)} $\interp{\tm} \applaw \interp{\tmtwo} \subseteq \interp{\tm\tmtwo}$
%		\item \emph{(applicative)}  $\interp\tm \subseteq \interp\tmp ~\&~ \interp\tmtwo \subseteq \interp\tmtwop \Rightarrow \interp{\tm\tmtwo} \subseteq \interp{\tmp\tmtwop}$
%		\item \emph{(abstractive)} $\interp\tm \subseteq \interp\tmtwo \Rightarrow \interp{\la\var\tm} \subseteq \interp{\la\var\tmtwo}$
%		\item \emph{($\alpha$-equivalence)} $\interp{\la\var\tm} = \interp{\la\vartwo\tm\isub\var\vartwo}$
%		\item \emph{($\beta_v$-equivalence)} $\interp{(\la\var\tm)\val} = \interp{\tm\isub\var\val}$
%		\item \emph{(explicitly substitutive)} $\interp\tm \subseteq \interp\tmp ~\&~ \interp\tmtwo \subseteq \interp\tmtwop \Rightarrow \interp{\tm\esub\var\tmtwo} \subseteq \interp{\tmp\esub\var\tmtwop}$
%		\item \emph{($\alpha$-equivalence')} $\interp{\tm\esub\var\tmtwo} = \interp{(\tm\isub\var\vartwo)\esub\vartwo\tmtwo}$
%	\end{itemize}
%	
%	%We add the two last clauses because we are dealing with the Value Substitution Calculus, which uses explicit substitutions.
%\end{definition}

\input{figures/figure-types} 
\paragraph{Multi Types} \Cref{fig:multi-types-vsc} gives the definition of multi types $\mtype$ for the VSC, which  mutually depends on the definition of linear types $\ltype$. Multi types are defined as finite multi-sets $\multitype{n}{\ltype}$, which intuitively denote the intersection $\ltype_1 \cap \ldots \cap \ltype_n$, where the intersection $\cap$ is a commutative, associative and non-idempotent ($A \cap A \not = A$) operator, the neutral element of which is $\emptytype$, the empty multi set.
Note that there is no ground type, its role is played by the empty multi type $\emptytype$.

A typing judgment is of the shape $\typectx \types \tm \hastype T$ where $T$ is a linear or a multi type and $\typectx$ is a typing context, that is an assignment of multi types to a finite set of variables ($\typectx = \var_1 \hastype \mtype_1, \ldots, \var_n \hastype \mtype_n$). To derive a typing judgment, we follow the derivation rules defined in \Cref{fig:multi-types-vsc}.

\paragraph{Typing Rules} Linear types only type values, via the rules $\typingruleAx$ and $\typingruleAbs$. To give a multi type to value $\val$, one has to use the $\typingruleMany$ rule, turning an indexed family of linear types for $\val$ into a multi type. Note that any value can be typed with the empty multi type $\emptytype$. %The rules $\typingruleApp$ and $\typingruleES$ involve choosing a new type, which is what makes typing undecidable, but are syntax-based. 
The symbol $\uplus$ is the disjoint union operator on multi sets (which corresponds to our non-idempotent intersection on multi types).  

\paragraph{Characterization of Termination} A key property of multi types is that they characterize $\tovsc$ termination. The characterization is proved via subject reduction and expansion.

\begin{theorem}[Characterization of termination, \cite{DBLP:journals/pacmpl/AccattoliG22}]
\label{thm:mtypes-charac}
\hfill
\begin{enumerate}
\item 	\label{p:mtypes-charac-subject} \emph{Subject reduction and expansion}:	let $\tm \tovsc \tmtwo$. Then $\typectx \types \tm \hastype \mtype$ if and only if $\typectx \types \tmtwo \hastype \mtype$.

\item $\tm$ is $\tovsc$-terminating if and only if there exists $\typectx$ and $\mtype$ such that $\typectx \types \tm \hastype \mtype$.
\end{enumerate}
\end{theorem}
Since $\tovsc$-termination characterizes \cbv scrutability (\refthm{cbv-scrutability-characterization}), multi types characterize it too.

\paragraph{Multi Types Induce a Model}
Multi types induce a model
by interpreting a term %simply 
as the set of its type judgments. 
A possibly empty list of pairwise distinct variables $\vec{\var} = (\var_1, \dots, \var_n)$ is \emph{suitable for} $\tm$ if $\fv{\tm} \subseteq \{\var_1, \dots, \var_n\}$.
If $\vec{\var} = (\var_1, \dots, \var_n)$ is suitable for $\tm$, the \emph{semantics} $\sem{\tm}_{\vec{\var}}$ \emph{of} $\tm$ \emph{for} $\vec{\var}$ is given by:
\begin{align*}
	\sem{\tm}_{\vec{\var}} &\defeq \{((\mtypetwo_1,\dots, \mtypetwo_n),\mtype) \mid 
	\exists 
	\, 
	\concl{\tderiv}{\var_1 \hastype \mtypetwo_1, \dots, \var_n \hastype \mtypetwo_n}{\tm}{\mtype} \}
\end{align*}
This is exactly Ehrhard's \cbv relational model \cite{DBLP:conf/csl/Ehrhard12}. Ehrhard considers it with respect to Plotkin's calculus. We do not prove that it is a model for the VSC, because there is no formal notion of VSC model. We do have, however, that subject reduction and expansion (\refthmp{mtypes-charac}{subject}) ensure that the interpretation $\sem{\tm}_{\vec{\var}}$ is \emph{invariant} by $\tovsc$, and compatibility of the induced equational theory is proved below. These properties are what the definitions of $\l$-models or categorical models are meant to ensure. Moreover, the characterization theorem (\refthm{mtypes-charac}) ensures that $\sem{\tm}_{\vec{\var}}$ is adequate.


\begin{corollary}[\cite{DBLP:journals/pacmpl/AccattoliG22}]
	\label{thm:invariance-and-adequacy}
	Let $\tm$ be a term in the \VSC with $\vec{\var}  = (\var_1, \dots, \var_n)$ suitable for it.
\begin{enumerate}
	\item \emph{Invariance}: if $\tm (\tovsc \cup \streq) \tmtwo$ then $\sem{\tm}_{\vec{\var}} = \sem{\tmtwo}_{\vec{\var}}$.
	\item \emph{Adequacy for} $\tovsc$: $\sem{\tm}_{\vec{\var}}$ is non-empty if and only if $\tm$ is $\tovsc$-terminating.

\end{enumerate}
\end{corollary}

\paragraph{The Type Preorder} Every model $M$ induces an equational theory defined as $\tm =_M \tmtwo$ if $\sem\tm_M = \sem\tmtwo_M$. For the multi types model, we consider the \emph{preorder} induced by $\interp\tm_{\vec\var} \subseteq \interp\tmp_{\vec\var}$.
\begin{definition}[Type preorder]
The type preorder $\tm \leqtype \tmp$ holds if $\typectx \types \tm \hastype \mtype$ implies $\typectx \types \tmp \hastype \mtype$.
\end{definition}
Rephrasing the definition with respect to interpretations, we have that $\tm \leqtype \tmp$ if $\interp\tm_{\vec\var} \subseteq \interp\tmp_{\vec\var}$ for every list of suitable variables $\vec\var$. By the adequacy of $\interp\tm_{\vec\var}$, it follows the adequacy of $\leqtype$. Compatibility is easily proved directly, for once, and soundness follows.

\begin{toappendix}
\begin{proposition}[Compatibility of $\leqtype$] \label{prop:type-preorder-is-compatible}
\hfill
\begin{enumerate}
\item \emph{Compatibility}: if $\tm\leqtype\tmp$ then $\ctxp\tm \leqtype \ctxp\tmp$.
\item \emph{Soundness}: if $\tm\leqtype\tmp$ then $\tm\eqcv\tmp$.
\end{enumerate}
\end{proposition}
\end{toappendix}

\paragraph{Enf and Net Are Included in Type}
Now, we show that $\leqenf$ and $\leqnet$ are both included in $\leqtype$. For that, we prove that, if $\tm\leqenf\tmp$ or $\tm\leqnet \tmp$, then any typing derivation for $\tm$ can be transformed in a typing derivation for $\tmp$ having the same final judgement. The next two propositions and the associated lemma are proved by induction on the following notion: the size $\size\typeder$ of a type derivation $\typeder$ is the number of rule occurences in $\typeder$ except for rule $\typingruleMany$.

\begin{toappendix}
\begin{proposition}
	\label{l:bisimulation-preserves-typeder}
\hfill
\begin{enumerate}
\item \emph{Net simulations and type derivations}:
	let $\relsym$ be a \net simulation. If $\tm \rel \tmp$ and $\typeder: \typectx \types \tm \hastype \mtype$ then there exists a derivation $\typederp: \typectx \types \tmp \hastype \mtype$.
	\item \emph{Net is included in Type}: if $\tm\leqnet\tmp$ then $\tm\leqtype\tmp$.
	\end{enumerate}
\end{proposition}
\end{toappendix}

%\begin{corollary}
%	$\leqnet \subseteq \leqtype$.
%\end{corollary}

To relate \enf similarity and typability, we need a lemma to deal with Lassen's stop-and-go. 
\begin{toappendix}
\begin{lemma}[Stop-and-go and type derivations]
	\label{l:smaller-derivations-stuck}
	Let $\typeder \derives \typectx \types {\levctxp{\var\val}} \hastype \mtype$ and $\varthree$ be fresh. Then there exist $\typeder_\levctx \derives  \typectx_\levctx, \varthree \hastype \mtypetwo \types  \levctxp{\varthree} \hastype \mtype$ with $\size{\typeder_\levctx}<\size\typeder$ and $\typeder_\val \derives \typectx_\val \types \val : \mtypetwo_1$ with $\size{\typeder_\val}<\size\typeder$.
\end{lemma}
\end{toappendix}

\begin{toappendix}
\begin{proposition}
	\label{l:enf-bisimulation-preserves-typeder}
	\hfill
\begin{enumerate}
\item \emph{Enf simulations and type derivations}:
	let $\relsym$ be an \enf simulation. If $\tm \rel \tmp$ and $\typeder \derives \typectx \types \tm \hastype \mtype$ then there exists a derivation $\typederp \derives \typectx \types \tmp \hastype \mtype$.
	\item \emph{Enf is included in Type}: if $\tm\leqenf\tmp$ then $\tm\leqtype\tmp$.
	\end{enumerate}
\end{proposition}
\end{toappendix}



%
%\begin{corollary}
%	$\leqenf \subseteq \leqtype$.
%\end{corollary}

%\paragraph{Proof method}We shall now use this type equivalence as a program equivalence. For axiomatisable rules like the equivalences described in this paper, it is fairly easy to show that type equivalence validates them (for structural equivalence see \refprop{equivstruct-subseteq-equivtype}). 
%
%
%\begin{proposition}[Type equivalence validates structural equivalence]
%	\label{prop:equivstruct-subseteq-equivtype}
%	If $\tm \equiv \tmtwo$, then $\tm\equivtype\tmtwo$.
%\end{proposition}
%
%\begin{proposition}[Type equivalence validates Moggi's equivalences]
%	
%	\label{prop:equivmoggi-subseteq-equivtype}
%	If $\tm \equivlid \tmtwo$, $\tm \equiv_{rad} \tmtwo$, $\tm \equiv_{rad} \tmtwo$ or $\tm \equiv_{ass} \tmtwo$, then $\tm\equivtype\tmtwo$.
%\end{proposition}
%
%We look at an easy example, with Moggi's $\equivlid$ rule. The statement we want to prove is the following:
%\begin{center}
%	$\forall \typectx,\mtype~\,\,\,\,\,\,\, \typectx \types \tm \hastype \mtype \iff \typectx\types\var\esub\var\tm\hastype\mtype$
%\end{center}
%
%Note that at first glance, this statement seems as hard as proving contextual equivalence, because of the universal quantification over typing contexts and multi types. However, in this case we can unfold the derivation for $ \typectx\types\var\esub\var\tm\hastype\mtype$ as there is only one possibility for the last derivation rule given the syntax of the term.
%
%
%\begin{center}
%	$\forall \typectx,\mtype~\,\,\,\,\,\,\, \typectx \types \tm \hastype \mtype \iff \exists \mtypetwo\,\,\, \infer[\typingruleES]{\typectx\types\var\esub\var\tm\hastype\mtype}{\var\hastype \mtypetwo \types \var\hastype \mtype & \typectx \types \tm \hastype \mtypetwo}$
%\end{center}
%
%We cannot apply the rule $\typingruleAx$ yet on the left side of the derivation, as $\mtype$ is not \emph{linear}, hence we can only apply $\typingruleMany$. Note that there are \emph{many} possibilities on how to apply the rule (depending on the choice of $I$ for the premices).
%
%
%\begin{center}
%	$\ldots \iff \exists n, (\mtypetwo_i)_{1\leq i \leq n},(\ltype_i)_{1\leq i \leq n}\,\,\,  \infer[\typingruleES]{\typectx\types\var\esub\var\tm\hastype\multitype{n}{\ltype} = \mtype}{\infer[\typingruleMany]{\biguplus_{0\leq i\leq n}(\var\hastype \mtypetwo_i) \types \var\hastype \multitype{n}{\ltype}}{\left(\var\hastype \mtypetwo_i \types \var \hastype \ltype_i\right)_{1\leq i \leq n}} & \typectx \types \tm \hastype \biguplus_{0\leq i\leq n}\mtypetwo_i}$
%\end{center}
%
%%Note that for the second possibility, the typing judgment $\var\hastype \emptytype \types \var\hastype \emptytype$ is the same as $\emptytypectx \types \var\hastype \emptytype$. 
%We keep unfolding the rules (if $n>0$): while for now we introduced an existential quantifier for the types $\mtypetwo$ and $\ltype$, because of the left leaves of the derivation, the only possibility is that $\mtypetwo_i = [\ltype_i]$.
%
%
%\begin{center}
%	$\forall \typectx,\mtype~\,\, \typectx \types \tm \hastype \mtype \iff \exists n, (\ltype_i)_{1\leq i \leq n}\,\,\,  \infer[\typingruleES]{\typectx\types\var\esub\var\tm\hastype\multitype{n}{\ltype} = \mtype}{\infer[\typingruleMany]{\var\hastype \multitype{n}{\ltype} \types \var\hastype \multitype{n}{\ltype}}{\left(\infer[\typingruleAx]{\var\hastype [\ltype_i] \types \var \hastype \ltype_i}{}\right)_{1\leq i \leq n}} & \typectx \types \tm \hastype \multitype{n}{\ltype}}$
%\end{center}
%
%The resulting statement is trivial, as any multi type $\mtype$ can be written as $ \multitype{n}{\ltype}$.
%
%Similar arguments can be made to prove that structural equivalence, Moggi's $\equiv_{ass}$, $\equiv_{lad}$, $\equiv_{rad}$ rules are validated by type equivalence $\equivtype$. On the other hand, it seems fairly intricated to prove that Turing's and Curry's fixpoint combinators are type equivalent, as arises the problem of universal quantification as well as the general complications when trying to type fixpoint combinators.


%If one is able to develop an appropriate notion of \emph{type normal form simulation} to match denotational identity, the proof technique to prove completeness is quite satisfactory. Indeed, by coinduction, it suffices to show that $\leqtype$ is a type simulation. Depending on the definition of type simulation, such a proof could be quite easy or relying on a \cbv separability theorem.
%Depending on how type bisimulations are defined, one might need a statement close to a \emph{separability} theorem for \cbv.
%\begin{center}
%	if $\tm\not\equivtype\tmp$ then $\tm \not \equiv_{todo}\tmp$
%\end{center}
%
% Where $\equiv_{todo}$ would be a set of equivalences relating normal forms of terms $\tm$ and $\tmp$. A criteria like this seems too syntactical to be able to grasp semantics, here specifically non-idempotent intersection types semantics.
%Back to \cbv scrutability concerns, by Proposition \ref{prop:typability-normalization}, inscrutable terms are exactly minimal elements for the $\leqtype$ preorder (and therefore are equated by $\equivtype$). 

%\cadr{\paragraph{$\etav$ Equivalence and Failure of Full Abstraction} Concerning $\etav$ equivalence, the multi type system we consider does not validate it but this is standard and it is usually fixable---in \cbn---by adding a recursive equation on the ground type. To our knowledge, however, the question has not been studied in \cbv.
%About full abstraction with respect to \cbv contextual equivalence $\eqcv$, it is easily seen that it fails, as type equivalence does not validate \cbn duplication, while $\eqcv$ does.}{}

%%%%For multi types with ground type
\ignore{\paragraph{$\etav$ Reduction} Concerning $\etav$ equivalence, the multi type system we consider does not (fully) validate it. In \cbn but this is standard and it is usually fixable by adding a recursive equation on the ground type. To our knowledge, however, the question has not been studied in \cbv. 

Part of $\eta_v$ equivalence, that is $\eta_v$-reduction, is however validated by the type preorder. On the other side, $\eta_v$-expansion fails. Hence none of them is validated by the symmetric closure of the type preorder, namely type equivalence. We first show the result on $\eta_v$-reduction for variables.
Actually, $\eta_v$ equivalence on closed values is standard and validated by $\alpha$-equivalence and reduction steps below lambdas. Therefore we can describe exactly how $\eta_v$ is included in the type preorder.
\begin{toappendix}
\begin{proposition} Let $\var$ a variable and $\val$ a value. One then has:
	\label{prop:etav-for-leqtype}
	\begin{enumerate}
		\item \emph{(Variable $\eta_v$-equivalence)} $\la\vartwo\var\vartwo \leqtype \var$, but $\var \not \leqtype \la\vartwo\var\vartwo$,
		\item  \emph{(Value $\eta_v$-equivalence)} $\la\vartwo\val\vartwo \leqtype \val$ for any $\val$ and $\val \leqtype \la\vartwo\val\vartwo$ iff $\val$ is an abstraction.
	\end{enumerate}
\end{proposition}
\end{toappendix}}



\paragraph{$\eta_v$ Equivalence} 
By the fact that \enf and \net similarities are incomparable follows that they are strictly included in $\leqtype$. A further  gap between the type preorder $\leqtype$ and $\leqenf$ or $\leqnet$ is $\eta_v$ equivalence, which is included in $\leqtype$ but not in $\leqenf$ nor $\leqnet$.
%It is somewhat arbitrary to describe linear types with a ground type (see \Cref{fig:multi-types-vsc}), and the counterexample for $\var \leqtype \la\vartwo\var\vartwo$ precisely uses the existence of a ground type. We now show that if we define linear types with the grammar $\ltype \grameq [\mtype \multimap \mtypetwo]$, $\eta_v$ equivalence is included in the induced preorder $\leqtypetwo$. 
%Again, we reason first on $\eta_v$-reduced or $\eta_v$-expanded variables. In the same fashion as before, we can extend the result to all values, which gives us that $\eta_v$ equivalence is included in the $\leqtypetwo$ preorder.
%We first show the result on $\eta_v$-reduction for variables.
%Actually, $\eta_v$ equivalence on closed values is standard and validated by $\alpha$-equivalence and reduction steps below lambdas.
%The technical statement is the first part of the next proposition, as $\eta_v$ equivalence on abstractions is included in $\beta_v$ equivalence.

\begin{toappendix}
	\begin{proposition}[Variable $\eta_v$-equivalence is included in type equivalence]	\label{prop:etav-for-leqtypetwo}
	Let $\var$ a variable. Then $\la\vartwo\var\vartwo \leqtype \var$ and $\var \leqtype \la\vartwo\var\vartwo$.
	\end{proposition}
\end{toappendix}



\paragraph{Characterizing Type Equivalence} We conjecture that $\leqtype$ is exactly the sup of the \enf and \net similarities enriched with $\eta_v$ equivalence, that is, that generalizing $\leqnet$ as to validate $\equivlid$ and $\equivetav$ would match $\leqtype$. If the conjecture is false, finding a normal form similarity presentation of $\leqtype$---which corresponds to describe the equational theory of \cbv relational semantics---is anyway an interesting and challenging problem.

We leave refining the definition of \net bisimilarity to include $\equivetav$ for future work. The addition of $\equivetav$  has been investigated in the literature, as it is already present in Lassen's work about enf bisimilarity \cite{LassenEnf} and is studied in more depth by \citet{DBLP:journals/lmcs/BiernackiLP19}.

About full abstraction with respect to \cbv contextual equivalence $\eqcv$, it fails for $\equivtype$, as $\equivtype$ is cost-sensitive---it does not validate \cbn duplication---while $\eqcv$ is cost-insensitive.



