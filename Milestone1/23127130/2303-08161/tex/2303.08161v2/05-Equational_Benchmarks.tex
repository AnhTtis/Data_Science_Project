% !TEX root = main.tex
\section{Equational Benchmarks for \cbv Program Equivalences}
\label{sect:benchmarks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In \cbn, there are only two 'equational benchmarks', or degrees of freedom, for program equivalences, namely $\eta$-equivalence and the $\Omega$-equivalence $\equivom$. In \cbv, the situation is richer, there are various equivalences that can be validated or not. Here we list the most relevant ones. We start by discussing the \cbv variants of $\eta$-equivalence and $\Omega$-equivalence, and then present the equivalences that are found in known extensions of Plotkin's calculus.

For all the equivalences, we simply give the root axioms defining them, assuming that they are closed by all contexts. All the given equivalences (but \cbn erasure) are validated by \cbv contextual equivalence $\eqcv$. %Some of them rather appear in the literature as reductions, but for the sake of uniformity we discuss them as equivalences. 
The meaning of some of the equivalences from extended \cbv calculi might seem obscure. They shall make more sense after the introduction of explicit substitutions in \refsect{vsc}.

In \cbv, $\eta$-equivalence has to be restricted, otherwise it turns non-values into values. At first sight, the by value version of $\eta$ seems to be $\val \equivetav \la\var{\val\var}$ if $\var\notin\fv\val$. But since any \cbv program equivalence validates $\betav$-reduction, the case $\val=\la\vartwo\tm$ is actually caught by $\betav$-reduction  (because $\la\var (\la\vartwo\tm)\var \tobv \la\var\tm\isub\vartwo\var =_\alpha \la\vartwo\tm$), so that $\equivetav$ simply amounts to the variable case.
\begin{itemize}
\item \emph{$\etav$ equivalence}: $\vartwo \equivetav \la\var{\vartwo\var}$ for every variable $\vartwo$.
\end{itemize}


\paragraph{\cbv $\Omega$-terms} $\Omega$-terms adapt to \cbv by simply considering \cbv contextual equivalence.
The equivalence to be validated here is the following one:
\begin{itemize}
\item \emph{$\Omega$-equivalence by value}: $\tm \equivomv \tmtwo$ if $\tm$ and $\tmtwo$ are \cbv $\Omega$-terms.
\end{itemize}
%\cbv inscrutable terms are the right notion of \emph{meaningless term} in \cbv, as they are exactly the minimum ones for the contextual preorder $\leqcv$. 
In Plotkin's calculus, \cbv $\Omega$-terms cannot have a diverging characterization akin to that of \cbn $\Omega$-terms (\refthm{cbn-scrutability-characterization})---they shall have one in the VSC. For instance, an $\Omega$-term such as $\Omega^L \defeq (\la\var\delta)(\vartwo\varthree)\delta$ is normal for Plotkin, while it should diverge if a good characterization existed. 

The equivalence $\equivomv$ has a special role among those listed here because whether a term is an $\Omega$-term is \emph{undecidable}, so that the equivalence cannot be seen as computational principle to be tested via a rewriting rule. It is then all the more relevant that a program equivalence validates it.

\paragraph{Moggi} We now turn to equivalences found in extensions of Plotkin's calculus. The equivalences enriching $\betav$-conversion in Moggi's untyped computational $\l$-calculus are the following ones, here reformulated without $\letexp$-expressions:
\begin{itemize}
	\item \emph{Left identity}: $\Id \tm \equiv_{lid} \tm$, where $\Id=\la\var\var$ is the identity combinator;
	\item \emph{Associativity of lets}: $(\la\var\tm)((\la\vartwo\tmtwo)\tmthree) \equivass (\la\vartwo(\la\var\tm)\tmtwo)\tmthree)$ if $\vartwo \not \in \fv{\adr\tm}$;
	\item \emph{Left decomposition of applications}: $\tm\tmtwo \equivlad (\la\var\var\tmtwo)\tm$ if $\var\not\in\fv\tmtwo$;
	\item \emph{Right decomposition of applications}: $\val\tm \equivrad (\la\var\val\var)\tm$ if $\var\not\in\fv\val$. This one exists also in an extended form: $\tmtwo\tm \equivexrad (\la\var\tmtwo\var)\tm$ if $\var\not\in\fv{\adr{\tmtwo}}$
\end{itemize}
Of them, the most interesting one for our study is $\equivlid$, which in Plotkin's calculus holds only for values, as for values it is an instance of $\betav$-conversion, while in Moggi's it holds for every term $\tm$.

\paragraph{Proof Nets} The \cbv translation of $\l$-calculus in linear logic proof nets, studied in detail by \citet{Accattoli-proofnets}, equates various pairs of terms. The induced equivalences are better expressed with explicit subsitution, as we shall see in \refsect{benchmarks-vsc}, but we anticipate them here anyway. They subsume Moggi's $\equivass$ rule and other presentations of proof nets equivalences such as the $\sigma$-rules of the shuffling calculus of \citet{shufflingcalculus}. Moreover, they include the following equivalences.
\begin{itemize}
	\item Left (Applied-$\l$) Application: $(\la\var\tm)\tmtwo\tmthree \equivsone (\la\var\tm\tmthree)\tmtwo$ if $\var\not\in\fv\tmthree$;
	%\item Right Value-Application: $\val((\la\var\tm)\tmtwo) \equivsthree (\la\var\val\tm)\tmtwo$ if  $\var\not\in\fv\val$.
	
	\item Right (Applied-$\l$) Application: $\tm((\la\vartwo\tmtwo)\tmthree) \equivexsthree (\la\vartwo\tm\tmtwo)\tmthree$ if  $\vartwo\not\in\fv{\tm}$;
	\item Commutativity: $(\la\vartwo(\la\var\tm)\tmtwo)\tmthree \equivcom (\la\var(\la\vartwo\tm)\tmthree)\tmtwo$ if $\var\notin\fv\tmthree$ and $\vartwo\notin\fv\tmtwo$.
\end{itemize}
The first two rules correspond to possible commutations between applications and applied lambdas--which shall correspond to commutations between applications and $\letexp$s in \refsect{benchmarks-vsc}. The second one also can be seen as a generalization of Moggi's $\equiv_{ass}$ replacing the value $\la\var\tm$ with whatever term $\tm$. Commutativity swaps adjacent and unrelated redexes, and it is the equivalence that in the introduction is formulated with $\letexp$s. It is a special equivalence, for at least two reasons. 
\begin{enumerate}
\item \emph{Effects}: commutativity holds in the pure \cbv setting but it often fails in extensions of \cbv with effects, because many effects are order-dependent (think of the order of writes on a memory cell). Therefore, it is an equivalence that one might want to be able to modularly add or remove from a notion of bisimilarity, rather than always validate it. 
\item \emph{Unorientable}: being symmetric, commutativity cannot be oriented as a rewriting rule. Therefore, any nf-bisimulation validating it needs to be able to compare normal forms up to some deformation of terms.
\end{enumerate}
The reason why some equivalences at times appear in restricted forms is also related to effects. With non-commutative effects one has to fix a deterministic evaluation strategy, typically left-to-right, and this constrains the shape of equivalences forcing a sub-term to be a value $\val$ (resp. $\la\var\tm$), as in $\equivrad$ (resp. $\equiv_{ass}$). Similarly for proof nets equivalence, evaluating left-to-right would lead us to a restricted version of $\equivexsthree$ where the sub-term $\tm$ has to be a value. Proceeding right-to-left would relax them but force other dual constraints (such as $\tm$ being a value in $\equivlad$), and adopting a non-specified order induces the extended versions of Moggi's laws and the unrestricted version of the proof nets equivalences.

\paragraph{\cbn Duplication and \cbn Erasure} The last equivalences that we consider are \cbn duplication and \cbn erasure. We do not actually know how to characterize \cbn duplication independently of erasure with an axiom, or a set of axioms, but we discuss a specific case, to illustrate the idea.
\begin{itemize}
\item \emph{\cbn Duplication}: $(\la\var \vartwo \var \var) \tmtwo \equiv_{dup} \vartwo \tmtwo\tmtwo$;
\item \emph{\cbn Erasure}: $(\la\var \tm ) \tmtwo \equiv_{era} \tm$ with $\var\notin\fv\tm$.
\end{itemize}
In \cbv, duplication and erasure are included in $\betav$-conversion if $\tmtwo$ is a value, but not otherwise. For arbitrary terms, erasure is unsound in \cbv, because erasing a sub-term might turn divergence into termination: for instance $\tm\defeq (\la\var\varthree)(\vartwo\vartwo)$ is not contextually equivalent to $\tmtwo\defeq \varthree$ in \cbv, because $\ctxp\tm$ diverges while $\ctxp\tmtwo$ terminates with respect to the context $\ctx\defeq (\la\vartwo\ctxhole)\delta$. 

Duplication, instead, is sound for arbitrary terms, the idea being that terminating (resp. diverging) once, or terminating (resp. diverging) twice does not affect termination (resp. divergence). It is however a principle somewhat clashing with the nature of \cbv. The cornerstone of \cbv is the idea that one should reduce arguments \emph{before} substituting them, and \cbn duplication does exactly the opposite. Intuitively, a \cbv program equivalence validating \cbn duplication is \emph{qualitative} or \emph{cost-insensitive}, as it only observes termination, while one rejecting it is somehow \emph{cost-sensitive}, as it distinguishes between differently efficient ways of realizing the same qualitative behavior.

\paragraph{Summing Up} Of all the discussed equivalences, the most relevant ones for our study are the $\Omega$-equivalence $\equivomv$ and left identity $\equivlid$. Commutativity $\equivcom$ shall also be a source of inspiration for the modular \emph{mirror} approach of \refsect{net}. \cbn Duplication is validated by \cbv contextual equivalence while none of the program equivalences studied in this paper validates it. This fact shows that they may be sound but are \emph{not complete} with respect to contextual equivalence.