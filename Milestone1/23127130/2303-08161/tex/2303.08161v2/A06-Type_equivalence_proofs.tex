% !TEX root = main.tex

\section{Proofs from \refsect{type-preorder} (From Operational to Denotational Semantics: the Type Preorder)}
In this section, we prove the propositions from the Section 12 \emph{From Operational to Denotational Semantics: the Type Preorder}.


\subsection{Type preorder is compatible}
Here we show that the type preorder is compatible. The proof is quite trivial, as the type preorder is somehow \emph{compositional}. We first prove a lemma about compositionality of syntax, then compatibility follows by an induction on contexts.

\begin{lemma} Type preorder verifies:
	\begin{itemize}
		\item \emph{(applicative)}  $\tm \leqtype \tmp ~\&~ \tmtwo\leqtype\tmtwop \Rightarrow {\tm\tmtwo}  \leqtype{\tmp\tmtwop}$.
		\item \emph{(abstractive)} $\tm \leqtype \tmtwo \Rightarrow {\la\var\tm} \leqtype {\la\var\tmtwo}$.
		\item \emph{(explicitly substitutive)} $\tm \leqtype \tmp ~\&~ \tmtwo \leqtype \tmtwop \Rightarrow {\tm\esub\var\tmtwo} \leqtype {\tmp\esub\var\tmtwop}$.
		\item \emph{($\alpha$-equivalence)} ${\la\var\tm} \equivtype {\la\vartwo\tm\isub\var\vartwo}$.
		\item \emph{($\alpha$-equivalence')} ${\tm\esub\var\tmtwo} \equivtype {(\tm\isub\var\vartwo)\esub\vartwo\tmtwo}$.
	\end{itemize}
\end{lemma}

\begin{proof}
\hfill
	\begin{itemize}
		\item \emph{(applicative)}, \emph{(explicitly substitutive)} and \emph{(abstractive)} properties can be done by looking at trees since they are very syntax driven. We look at the (ES) case to sketch the idea:
		\\
		
		Let $\typeder$ be a type derivation for $\tm\esub\varthree\tmtwo$, $\typeder :~ \typectx \types \tm\esub\varthree\tmtwo \hastype \mtype$.
		
		We show that there exists a type derivation $\typederp$ such that $\typederp :~ \typectx \types \tmp\esub\varthree\tmtwop \hastype \mtype$.
		
		Since the term $\tm\esub\varthree\tmtwo$ is not a value, there is only one possibility for the last rule of the derivation: ($\typingruleES$).
		\[\infer[\typingruleES]{\typectx \types \tm\esub\varthree\tmtwo \hastype \mtype}{\typectx_1, \varthree \hastype \mtypetwo \types \tm \hastype \mtype & \typectx_2 \types \tmtwo \hastype \mtypetwo}\]
		
		where $\typectx = \typectx_1 \uplus \typectx_2$.
		
		Since $\tm$ is type equivalent to $\tmp$ and $\tmtwo$ is type equivalent to $\tmtwop$, there exists two derivations $\typectx_2 \types \tmtwop \hastype \mtypetwo$ and $\typectx_1, \varthree \hastype \mtypetwo \types \tmp \hastype \mtype$. Hence we can construct the appropriate derivation $\typederp$ for $\tmp\esub\varthree\tmtwop$.
		\[\infer[\typingruleES]{\typectx \types \tmp\esub\varthree\tmtwop \hastype \mtype}{\typectx_1, \varthree \hastype \mtypetwo \types \tmp \hastype \mtype & \typectx_2 \types \tmtwop \hastype \mtypetwo}\]
		
		
		Hence $\tm\esub\varthree\tmtwo\leqtype \tmp\esub\varthree\tmtwop$.
		
		\item \emph{($\alpha$-equivalence)} and \emph{($\alpha$-equivalence')} are obvious, because typing judgments do not depend on the representation of bounded variables.\qedhere
	\end{itemize}
\end{proof}







\gettoappendix{prop:type-preorder-is-compatible}

\begin{proof}
	\begin{enumerate}
		\item By induction on $\ctx$.
	\begin{itemize}
		\item $\ctx = \ctxhole$, $\tm\leqtype\tmp$.
		\item $\ctx \leqtype \tmtwo\ctxtwo$, then by induction ${\ctxtwop\tm} \leqtype{\ctxtwop\tmp}$ and obviously $\tmtwo \leqtype \tmtwo$, hence by the (applicative) property ${\tmtwo\ctxtwop\tm} \leqtype{\tmtwo\ctxtwop\tmp}$.
		\item $\ctx = \ctxtwo\tmtwo$, $\ctx \leqtype \ctxtwo\esub\var\tmtwo$ and $\ctx \leqtype \tmtwo\esub\var\ctxtwo$ are similar to the previous case.
		\item $\ctx = \la\var\ctxtwo$ then by induction ${\ctxtwop\tm} \leqtype{\ctxtwop\tmp}$, hence by the (abstractive) property ${\la\var\ctxtwop\tm} \leqtype{\la\var\ctxtwop\tmp}$.
	\end{itemize}
\item By compatibility and adequacy.\qedhere

\end{enumerate}
\end{proof}

\subsection{\Net similarity is included into the Type preorder}
In fact, for all \nafex similarities, such that the following propoposition is true (and not necessarily that $\equivx$ is a mirror), we get that $\leqnafex \subseteq \leqtype$. The only prerequisite is that $\equivx$ satisfies the following proposition.

\begin{proposition}[$\equivx$-equivalence implies typability-equivalence]
	\label{prop:equivx-subseteq-equivtype}
	If $\tm\equivx\tmtwo$ then $\tm\equivtype\tmtwo$.
\end{proposition}

For $\leqtype$, this proposition is true, see Theorem \ref{thm:invariance-and-adequacy}.

\gettoappendix{l:bisimulation-preserves-typeder}


\begin{proof}
	
	\begin{enumerate}
		\item By induction on the size of the derivation $\typeder: \typectx \types \tm \hastype \mtype$.
	
	
	The term $\tm$ is typable by a derivation $\typeder: \typectx \types \tm \hastype \mtype$ therefore it is normalizable by \refthm{invariance-and-adequacy}. Hence we have $\tm\tovsc^k\ntm$ and therefore (since $\relsym$ is a bisimulation) $\tmp\tovsc^*\ntmtwo$ with $\ntm \relnafex \ntmtwo$. Instead of looking for a derivation $\typederp$  of $\tmp$, we can look for a derivation $\typederp_1$ of $\ntmtwo$ and conclude by (typability) expansion for the $\tovsc$ reduction.
	
	There is a derivation $\typeder_1: \typectx \types \ntm \hastype \mtype$ whose size is at most the size of $\typeder$.
	
	By case analysis on the last rule of the derivation $\typeder_1$.
	
	\begin{enumerate}
		\item \emph{Axiom rule.} \[\typeder_1 :~~~~~ \infer[\typingruleAx]{\var \hastype [\ltype] \types \ntm = \var \hastype \ltype}{}\]
		
		Then by $\ntm=\var\relnafex \ntmtwo$, $\ntmtwo = \var$ and $\typederp_1 \defeq \typeder_1$ types $\ntmtwo$ accordingly.
		\item \emph{Abstraction rule.} \[\typeder_1 :~~~~~ \infer[\typingruleAbs]{\typectx \types \ntm = \la\var\tmtwo \hastype \mtype \multimap \mtypetwo}{\typectx, \var \hastype \mtype \types  \tmtwo \hastype \mtypetwo}\]
		
		Then by $\ntm=\la\var\tmtwo\relnafex \ntmtwo$, $\ntmtwo = \la\var\tmtwop$ with $\tmtwo\rel\tmtwop$.
		
		The derivation $\typeder_2 : \typectx, \var \hastype \mtype \types  \tmtwo \hastype \mtypetwo$ is of a strictly smaller size than $\typeder$. By induction, since $\tmtwo\rel\tmtwop$, there is a derivation $\typederp_2 : \typectx, \var \hastype \mtype \types  \tmtwop \hastype \mtypetwo$.
		
		Then, \[\typederp_1 :~~~~~ \infer[\typingruleAbs]{\typectx \types \ntmtwo = \la\var\tmtwop \hastype \mtype \multimap \mtypetwo}{\infer*{\typectx, \var \hastype \mtype \types  \tmtwop \hastype \mtypetwo}{\typederp_2}}\]
		
		\item \emph{Many rule.} \[\typeder_1 : ~~~~~
		\infer[\typingruleMany]{\biguplus_{i\in I} \typectx_i \types \ntm = \val \hastype \biguplus_{i\in I} \ltype_i}{\infer*{(\typectx_i \types \ntm= \val \hastype \ltype_i)_{i\in I}}{\typedertwo_i}  & I~ \text{finite} } \]
		
		Then by $\ntm=\val\relnafex \ntmtwo$, $\ntmtwo = \valtwo$ with $\val\relnafex\valtwo$.
		
		Two sub-cases depending on the value nature of $\val$:
		\begin{itemize}
			\item \emph{Variable}. If $\val=\var$ then, $\valtwo=\var$ as well.
			Then, $\typederp_1\defeq\typeder_1$ is a correct derivation for $\valtwo$ and concludes the proof in this case.  
			\item \emph{Abstract}. If $\val=\la\var\tmtwo$ then, $\valtwo=\la\var\tmtwop$ with $\tmtwo\rel\tmtwop$.
			
			Suppose there is at least a $\typedertwo_i$ derivation (if there are none the result is trivial).
			
			Since $\ltype_i$ is a linear type the only possibility for the last rule of $\typedertwo_i$ is a ($\typingruleAbs$) rule. 
			
			Suppose $\ltype_i = \mtype_i\multimap \mtypetwo_i$.
			\[{\typedertwo_i} :~~~~~ \infer[\typingruleAbs]{\typectx \types \la\var\tmtwo \hastype \mtype_i\multimap \mtypetwo_i}{\infer*{\typectx, \var \hastype \mtype_i\types \tmtwo \hastype\mtypetwo_i}{\typederthree_i}}\]
			
			We know that $\tmtwo\rel\tmtwop$. By \ih on $\typederthree_i$ (whose size is strictly smaller than the size of $\typeder$), we get $\typederthreep_i : \typectx, \var \hastype \mtype_i\types \tmtwop \hastype\mtypetwo_i$. Hence we can reconstruct the appropriate $\typederp_1$ derivation.
			\[\typederp_1 : ~~~~~
			\infer[\typingruleMany]{\biguplus_{i\in I} \typectx_i \types \ntmtwo = \valtwo \hastype \biguplus_{i\in I} \ltype_i}{(\infer{\typectx_i \types \valtwo = \la\var\tmtwop \hastype \ltype_i}{{\infer*{\typectx, \var \hastype \mtype_i\types \tmtwo \hastype\mtypetwo_i}{\typederthreep_i}}})_{i\in I}  & I~ \text{finite} } \]
		\end{itemize}
		
		
		
		
		\item \emph{Application rule.} \[	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types \ntm=\ntmONE\ntmTWO \hastype \mtypetwo}{ \typectx \types \ntmONE \hastype [\mtype \multimap \mtypetwo] & \typectxtwo \types \ntmTWO \hastype \mtype }
		\]
		
		Then by $\ntm=\ntmONE\ntmTWO\relnafex \ntmtwo$, $\ntmtwo \equivx \ntmONEtwo\ntmTWOtwo$ with $\ntmONE\rel\ntmONEtwo$ and $\ntmTWO\rel\ntmTWOtwo$.
		
		By \refprop{equivx-subseteq-equivtype}, $\ntmtwo$ is type equivalent with $\ntmONEtwo\ntmTWOtwo$. Hence it is enough to construct an appropriate $\typederp$ for $\ntmONEtwo\ntmTWOtwo$.
		
		By induction on $\ntmONE,\ntmONEtwo$ and $\ntmTWO,\ntmTWOtwo$, we get the appropriate derivation.
		
		\item \emph{Explicit Substitution rule.} \[
		\infer[\typingruleES]{\typectx \uplus \typectxtwo \types \ntm = \ntmONE\esub\var\ntmTWO \hastype \mtypetwo}{ \typectx, \var \hastype \mtype \types \ntmONE \hastype \mtypetwo & \typectxtwo \types \ntmTWO \hastype \mtype }\]
		
		Then by $\ntm=\ntmONE\esub\var\ntmTWO\relnafex \ntmtwo$, $\ntmtwo \equivx \ntmONEtwo\esub\var\ntmTWOtwo$ with $\ntmONE\rel\ntmONEtwo$ and $\ntmTWO\rel\ntmTWOtwo$.
		
		By \refprop{equivx-subseteq-equivtype}, $\ntmtwo$ is type equivalent with $\ntmONEtwo\esub\var\ntmTWOtwo$. Hence it is enough to construct an appropriate $\typederp$ for $\ntmONEtwo\esub\var\ntmTWOtwo$.
		
		By induction on $\ntmONE,\ntmONEtwo$ and $\ntmTWO,\ntmTWOtwo$, we get the appropriate derivation.
	\end{enumerate}
\item 
Let $\tm,\tmp$ terms such that $\tm \leqnafex\tmp$.
By the first part of the proposition, $\tm\leqtype\tmp$.\qedhere
	\end{enumerate}
\end{proof}



\subsection{Lassen's Enf similarity is included in the Type preorder}
For Lassen's bisimilarity, the proof is a little more intricated, but relies on the same reasoning. We consider Plotkin's normal form and type them using the VSC multi types. Since multi types are invariant by reduction, this does not affect type equivalence.

\gettoappendix{l:smaller-derivations-stuck}


\begin{proof}
	By induction on $\levctx$.
	\begin{itemize}
		\item $\levctx = \ctxhole$
		\[\typeder =~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types \var\val \hastype \mtype}{ \typectx \types \var \hastype [\mtypetwo_1 \multimap \mtype] & \infer*{\typectxtwo \types \val \hastype \mtypetwo_1}{\typeder_{\val}} }
		\]
		
		Then, $\typeder_{\levctx}$ is of size $1$, \ie clearly smaller than $\typeder$, and it is easy to see that $\typeder_{\val}$ is of size $\size{\typeder}-2$.
		
		\item $\levctx= \valtwo\levctxtwo$
		\[\typeder =~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types \levctxp{\var\val}=\valtwo\levctxtwop{\var\val} \hastype \mtype}{ \typectx \types \valtwo \hastype [\mtype_1 \multimap \mtype] & \infer*{\typectxtwo \types \levctxtwop{\var\val} \hastype \mtype_1}{\typeder_1} }
		\]
		
		By \ih, $\exists \typeder_{1\levctx} :  \typectxtwo_{a}, \varthree \hastype \mtypetwo \types  \levctxtwop{\varthree} \hastype \mtype_1$ and $\exists \typeder_{\val} : \typectx_{\val} \types \val : \mtypetwo_1$ with $\size{\typeder_{1\levctx}}<\size{\typeder_1}$ and $\size{\typeder_{\val}}<\size{\typeder_1}$.
		
		Therefore $\size{\typeder_{\val}}<\size{\typeder}$. We complete $\typeder_{\levctx}$ in the following way:
		\[\typeder_{\levctx} =~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo_{\levctx},\varthree \hastype \mtypetwo \types \levctxp\varthree=\valtwo\levctxtwop{\varthree} \hastype \mtype}{ \typectx \types \valtwo \hastype [\mtype_1 \multimap \mtype] & \infer*{\typectxtwo_{\levctx},\varthree \hastype \mtypetwo \types \levctxtwop{\varthree} \hastype \mtype_1}{\typeder_{1\levctx}} }
		\]
		
		Then $\size{\typeder_{\levctx}}<\size\typeder$.
		
		\item $\levctx=\levctxtwo\tm$
		\[\typeder =~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types \levctxtwop{\var\val}\tm \hastype \mtype}{    \infer*{\typectxtwo \types \levctxtwop{\var\val} \hastype [\mtype_1 \multimap \mtype]}{\typeder_1} &\typectx \types \tm \hastype \mtype_1}
		\]
		
		By \ih, $\exists \typeder_{1\levctx} :  \typectxtwo_{a}, \varthree \hastype \mtypetwo \types  \levctxtwop{\varthree} \hastype [\mtype_1 \multimap \mtype]$ and $\exists \typeder_{\val} : \typectx_{\val} \types \val : \mtypetwo_1$ with $\size{\typeder_{1\levctx}}<\size{\typeder_1}$ and $\size{\typeder_{\val}}<\size{\typeder_1}$.
		
		Therefore $\size{\typeder_{\val}}<\size\typeder$. We complete $\typeder_{\levctx}$ in the following way:
		\[\typeder_{\levctx} =~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo_{\levctx},\varthree\hastype\mtypetwo \types \levctxtwop{\varthree}\tm=\levctxp\varthree \hastype \mtype}{    \infer*{\typectxtwo_{\levctx},\varthree\hastype\mtypetwo \types \levctxtwop{\varthree} \hastype [\mtype_1 \multimap \mtype]}{\typeder_{1\levctx}} &\typectx \types \tm \hastype \mtype_1}
		\]
		
		Then $\size{\typeder_{\levctx}}<\size\typeder$.\qedhere
	\end{itemize}
\end{proof}

\begin{proposition}
	\label{prop:stuck-typed-applicative-form}
	${\levctxp{\var\val}}\equivtype{(\la\varthree\levctxp{\varthree})(\var\val)}$ where $\varthree$ does not appear in $\levctx$.
\end{proposition}

\begin{proof}
	Similar arguments apply, proof by induction on $\levctx$.
\end{proof}





\gettoappendix{l:enf-bisimulation-preserves-typeder}


\begin{proof}
\begin{enumerate}
	\item 
	By induction on the size of the derivation $\typeder: \typectx \types \tm \hastype \mtype$.
	
	\newcommand{\ntmleft}{\ntm_{\mathsf{left}}}
	\newcommand{\ntmlefttwo}{\ntmtwo_{\mathsf{left}}}
	The term $\tm$ is typable by a derivation $\typeder: \typectx \types \tm \hastype \mtype$ therefore it is normalizable by \refthm{invariance-and-adequacy}. Hence we have $\tm\tovsc^k\ntm$. By the fact that all VSC terminating terms are Plotkin's left terminating, we have that $\tm\tolw\ntmleft$ and therefore (since $\relsym$ is an enf bisimulation) $\tmp\tolw^*\ntmlefttwo$ with $\ntmleft \relenf\ntmlefttwo$. Instead of looking for a derivation $\typederp$  of $\tmp$, we can look for a derivation $\typederp_1$ of $\ntmlefttwo$ and conclude by (typability) expansion for the $\tolw$ reduction.
	
	There is a derivation $\typeder_1: \typectx \types \ntmleft \hastype \mtype$ whose size is at most the size of $\typeder$.
	
	By case analysis on the last rule of the derivation $\typeder_1$.
	
	\begin{enumerate}
		\item \emph{Axiom rule.} \[\typeder_1 :~~~~~ \infer[\typingruleAx]{\var \hastype [\ltype] \types \ntmleft = \var \hastype \ltype}{}\]
		
		Then by $\ntmleft=\var\relenf \ntmlefttwo$, $\ntmlefttwo = \var$ and $\typederp_1 \defeq \typeder_1$ types $\ntmlefttwo$ accordingly.
		\item \emph{Abstraction rule.} \[\typeder_1 :~~~~~ \infer[\typingruleAbs]{\typectx \types \ntmleft = \la\var\tmtwo \hastype \mtype \multimap \mtypetwo}{\typectx, \var \hastype \mtype \types  \tmtwo \hastype \mtypetwo}\]
		
		Then by $\ntmleft=\la\var\tmtwo\relenf \ntmtwo$, $\ntmlefttwo = \la\var\tmtwop$ with $\tmtwo\rel\tmtwop$.
		
		The derivation $\typeder_2 : \typectx, \var \hastype \mtype \types  \tmtwo \hastype \mtypetwo$ is of a strictly smaller size than $\typeder$. By induction, since $\tmtwo\rel\tmtwop$, there is a derivation $\typederp_2 : \typectx, \var \hastype \mtype \types  \tmtwop \hastype \mtypetwo$.
		
		Then, \[\typederp_1 :~~~~~ \infer[\typingruleAbs]{\typectx \types \ntmlefttwo = \la\var\tmtwop \hastype \mtype \multimap \mtypetwo}{\infer*{\typectx, \var \hastype \mtype \types  \tmtwop \hastype \mtypetwo}{\typederp_2}}\]
		
		\item \emph{Many rule.} \[\typeder_1 : ~~~~~
		\infer[\typingruleMany]{\biguplus_{i\in I} \typectx_i \types \ntmleft = \val \hastype \biguplus_{i\in I} \ltype_i}{\infer*{(\typectx_i \types \ntmleft= \val \hastype \ltype_i)_{i\in I}}{\typedertwo_i}  & I~ \text{finite} } \]
		
		Then by $\ntmleft=\val\relenf \ntmtwo$, $\ntmlefttwo = \valtwo$ with $\val\relenf\valtwo$.
		
		Two sub-cases depending on the value nature of $\val$:
		\begin{itemize}
			\item \emph{Variable}. If $\val=\var$ then, $\valtwo=\var$ as well.
			Then, $\typederp_1\defeq\typeder_1$ is a correct derivation for $\valtwo$ and concludes the proof in this case.  
			\item \emph{Abstract}. If $\val=\la\var\tmtwo$ then, $\valtwo=\la\var\tmtwop$ with $\tmtwo\rel\tmtwop$.
			
			Suppose there is at least a $\typedertwo_i$ derivation (if there are none the result is trivial).
			
			Since $\ltype_i$ is a linear type the only possibility for the last rule of $\typedertwo_i$ is a ($\typingruleAbs$) rule. 
			
			Suppose $\ltype_i = \mtype_i\multimap \mtypetwo_i$.
			\[{\typedertwo_i} :~~~~~ \infer[\typingruleAbs]{\typectx \types \la\var\tmtwo \hastype \mtype_i\multimap \mtypetwo_i}{\infer*{\typectx, \var \hastype \mtype_i\types \tmtwo \hastype\mtypetwo_i}{\typederthree_i}}\]
			
			We know that $\tmtwo\rel\tmtwop$. By \ih on $\typederthree_i$ (whose size is strictly smaller than the size of $\typeder$), we get $\typederthreep_i : \typectx, \var \hastype \mtype_i\types \tmtwop \hastype\mtypetwo_i$. Hence we can reconstruct the appropriate $\typederp_1$ derivation.
			\[\typederp_1 : ~~~~~
			\infer[\typingruleMany]{\biguplus_{i\in I} \typectx_i \types \ntmlefttwo = \valtwo \hastype \biguplus_{i\in I} \ltype_i}{(\infer{\typectx_i \types \valtwo = \la\var\tmtwop \hastype \ltype_i}{{\infer*{\typectx, \var \hastype \mtype_i\types \tmtwo \hastype\mtypetwo_i}{\typederthreep_i}}})_{i\in I}  & I~ \text{finite} } \]
		\end{itemize}
		
		

		
		\item \emph{Application rule.} \[	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types \ntmleft=\tmrone\tmrtwo \hastype \mtypetwo}{ \typectx \types \tmrone \hastype [\mtype \multimap \mtypetwo] & \typectxtwo \types \tmrtwo \hastype \mtype }
		\]
		
		Then by $\ntmleft=\tmrone\tmrtwo\relenf \ntmtwo$, $\ntmleft=\levctxp{\var\val}$ and $\ntmtwo = \levctxtwop{\var\valtwo}$ with $\levctxp\varthree\rel\levctxp\varthree$ and $\val\rel\valtwo$ with $\varthree$ fresh.
		
		By \refprop{stuck-typed-applicative-form}, typability of $\ntmleft$ is equivalent to typability of $(\la\varthree\levctxp{\varthree})(\var\val)$, which the derivation (for this type) is:
		\[	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types (\la\varthree\levctxp{\varthree})(\var\val) \hastype \mtypetwo}{ \infer[\typingruleAbs]{\typectx \types \la\varthree\levctxp{\varthree} \hastype [\mtype \multimap \mtypetwo]}{\infer*{\typectx, \varthree \hastype \mtype \types  \levctxp\varthree \hastype \mtypetwo}{\typeder_{\levctx}}} & \infer[\typingruleApp]{\typectxtwo',\var \hastype [\mtype_1 \multimap \mtype] \types \var\val \hastype \mtype}{\var \hastype [\mtype_1 \multimap \mtype] \types \var \hastype [\mtype_1 \multimap \mtype] & \infer*{\typectxtwo' \types \val \hastype \mtype_1}{\typeder_{\val}}} }
		\]
		By \reflemma{smaller-derivations-stuck}, $\typeder_{\levctx}$ and $\typeder_{\val}$ are strictly smaller than $\typeder$. Hence, by \ih, there exists $\typederp_{\levctx}$ and $\typederp_{\val}$ such that we can build the following derivation tree:
			\[\typederp=~~~	\infer[\typingruleApp]{\typectx \uplus \typectxtwo \types (\la\varthree\levctxtwop{\varthree})(\var\valtwo) \hastype \mtypetwo}{ \infer[\typingruleAbs]{\typectx \types \la\varthree\levctxtwop{\varthree} \hastype [\mtype \multimap \mtypetwo]}{\infer*{\typectx, \varthree \hastype \mtype \types  \levctxtwop\varthree \hastype \mtypetwo}{\typeder_{\levctx}}} & \infer[\typingruleApp]{\typectxtwo',\var \hastype [\mtype_1 \multimap \mtype] \types \var\valtwo \hastype \mtype}{\var \hastype [\mtype_1 \multimap \mtype] \types \var \hastype [\mtype_1 \multimap \mtype] & \infer*{\typectxtwo' \types \valtwo \hastype \mtype_1}{\typeder_{\val}}} }
		\]
		
		Which concludes the proof, since by \refprop{stuck-typed-applicative-form}, $(\la\varthree\levctxtwop{\varthree})(\var\valtwo)$ and $\levctxtwop{\var\valtwo}$ are type equivalent.
		
		\item \emph{Explicit Substitution rule.} \[
		\infer[\typingruleES]{\typectx \uplus \typectxtwo \types \ntmleft = \ntmONE\esub\var\ntmTWO \hastype \mtypetwo}{ \typectx, \var \hastype \mtype \types \ntmONE \hastype \mtypetwo & \typectxtwo \types \ntmTWO \hastype \mtype }\]
		This case is not possible: $\ntmleft$ is a term without explicit substitutions.
	\end{enumerate}
\item 
Let $\tm,\tmp$ terms such that $\tm \leqenf\tmp$.
By the first part, $\tm \leqtype\tmp$.\qedhere
\end{enumerate}
\end{proof}


\subsection{Multi types by value, regarding $\eta_v$ equivalence}
We now prove that multi types as they are defined in this paper, validate $\eta_v$ equivalence. We only need to prove the result for variables, as $\eta_v$ equivalence on abstractions is contained in $\equivbetav$.

\ignore{\subsubsection{Validating $\eta_v$ preorder}

\gettoappendix{prop:etav-for-leqtype}

\begin{proof}\begin{enumerate}
		\item \begin{itemize}
		\item 
	Let $(\typectx,\mtype)$ and $\typeder$ such that $\typeder : \typectx \types \la\vartwo\var\vartwo \hastype \mtype$.
	
	It is easy to type $\var$ with the multi type $\mtype$, with the context $\typectxtwo = \var \hastype \mtype$. We then need to prove that $\typectx = \typectxtwo$ to conclude.
	
	By unfolding the derivation $\typeder$, we get:
	
	
	Let $n$, $(\ltype_i)_{1\leq i\leq n}$ such that $\mtype = \multitype{n}{\ltype}$. Let $\mtypetwo_i$ and $\mtypetwo'_i$ such that $\ltype_i = \mtypetwo_i \multimap \mtypetwo'_i$.
	Let $m_i$, $((\ltypetwo_{i,j})_{1\leq j\leq m_i})_{0 \leq i \leq n}$ such that $\mtypetwo_i = \multitype{m_i}{\ltypetwo_{i,}}$.
	
	\[\infer[\typingruleMany]{\biguplus_{0 \leq i\leq n}\typectx_i \types \la\vartwo\var\vartwo \hastype \mtype}{\ldots & \infer[\typingruleAbs]{\typectx_i \types \la\vartwo\var\vartwo \hastype \ltype_i}{\infer[\typingruleApp]{\typectx_i,\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \var\vartwo \hastype \mtypetwo'_i}{\typectx_i \types \var \hastype [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i] & \infer[\typingruleMany]{\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \vartwo \hastype \biguplus_{0 \leq j\leq m}\ltypetwo_{i,j}}{\left(\infer[\typingruleAx]{\vartwo \hastype [\ltypetwo_{i,j}] \types \vartwo \hastype \ltypetwo_{i,j}}{}\right)_{0\leq j \leq m}}}} & \ldots ~{0 \leq i \leq n}}\]
	
	Hence, if we keep unfolding on $\typectx_i \types \var \hastype [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i]$, we get that $\biguplus_{0 \leq i\leq n}\typectx_i = \var \hastype \mtype$.
	\item $\var \hastype [\vartype] \types \var \hastype [\vartype]$ but $\var \hastype [\vartype] \not \types \la\vartwo\var\vartwo \hastype [\vartype]$, as an abstraction cannot be typed without a linear type of the shape $\mtype \multimap \mtypetwo$.
	\end{itemize}
\item For abstractions, the result is easier as $\eta_v$ equivalence amounts then to reducing under lambdas and $\alpha$-equivalence.
	\end{enumerate}
\end{proof}

\subsubsection{Removing ground types, validating $\eta_v$ equivalence}

Consider the same multi type system but with a new grammar of types, removing ground types (the empty multi type $\emptytype$ can be seen as acting as a ground type):


\begin{center}
	$\begin{array}{ccccc}
	\textsc{Linear Types} & \ltype, \ltypetwo &\grameq& \mtype \multimap \mtypetwo
	\\
	\textsc{Multi Types} & \mtype, \mtypetwo &\grameq& \multitype{n}{\ltype} & n\geq 0
	\end{array}$
\end{center}
}

\gettoappendix{prop:etav-for-leqtypetwo}

\begin{proof}
\hfill
\begin{enumerate}
		
		\item \emph{$\var \leqtype \la\vartwo\var\vartwo$}
		
		Let $\typeder$ be a type derivation such that $\typeder : \typectx \types \var \hastype \mtype$.
		
		We show that $\la\vartwo\var\vartwo$ can be typed in the same context and with the same type.
		
		Let $n$, $(\ltype_i)_{1\leq i\leq n}$ such that $\mtype = \multitype{n}{\ltype}$. Let $\mtypetwo_i$ and $\mtypetwo'_i$ such that $\ltype_i = \mtypetwo_i \multimap \mtypetwo'_i$.
		Let $m_i$, $((\ltypetwo_{i,j})_{1\leq j\leq m_i})_{0 \leq i \leq n}$ such that $\mtypetwo_i = \multitype{m_i}{\ltypetwo_{i,}}$.
		
		\[\infer[\typingruleMany]{\biguplus_{0 \leq i\leq n}\typectx_i \types \la\vartwo\var\vartwo \hastype \mtype}{\ldots & \infer[\typingruleAbs]{\typectx_i \types \la\vartwo\var\vartwo \hastype \ltype_i}{\infer[\typingruleApp]{\typectx_i,\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \var\vartwo \hastype \mtypetwo'_i}{\typectx_i \types \var \hastype [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i] & \infer[\typingruleMany]{\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \vartwo \hastype \biguplus_{0 \leq j\leq m}\ltypetwo_{i,j}}{\left(\infer[\typingruleAx]{\vartwo \hastype [\ltypetwo_{i,j}] \types \vartwo \hastype \ltypetwo_{i,j}}{}\right)_{0\leq j \leq m}}}} & \ldots ~{0 \leq i \leq n}}\]
		
		It only remains to show that $\typectx = \var \hastype \biguplus_{0 \leq i\leq n} [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i]$ and then we are done.
		
		Let's unfold the derivation $\typeder : \typectx \types \var \hastype \mtype$:
		\[\infer[\typingruleMany]{\biguplus_{0 \leq i\leq n}\typectxtwo_i \types \var \hastype \mtype}{(\infer[\typingruleAx]{\typectxtwo_i \types \var \hastype \mtypetwo_i \multimap \mtypetwo'_i}{})_{0 \leq i \leq n}}\]
		
		Hence $\typectxtwo_i = \var \hastype [\mtypetwo_i \multimap \mtypetwo'_i]$, which concludes the proof.
		
		\item \emph{$\la\vartwo\var\vartwo \leqtype \var$}, 
		
		Let $(\typectx,\mtype)$ and $\typeder$ such that $\typeder : \typectx \types \la\vartwo\var\vartwo \hastype \mtype$.
		
		It is easy to type $\var$ with the multi type $\mtype$, with the context $\typectxtwo = \var \hastype \mtype$. We then need to prove that $\typectx = \typectxtwo$ to conclude.
		
		By unfolding the derivation $\typeder$, we get:
		
		
		Let $n$, $(\ltype_i)_{1\leq i\leq n}$ such that $\mtype = \multitype{n}{\ltype}$. Let $\mtypetwo_i$ and $\mtypetwo'_i$ such that $\ltype_i = \mtypetwo_i \multimap \mtypetwo'_i$.
		Let $m_i$, $((\ltypetwo_{i,j})_{1\leq j\leq m_i})_{0 \leq i \leq n}$ such that $\mtypetwo_i = \multitype{m_i}{\ltypetwo_{i,}}$.
		\[\infer[\typingruleMany]{\biguplus_{0 \leq i\leq n}\typectx_i \types \la\vartwo\var\vartwo \hastype \mtype}{\ldots & \infer[\typingruleAbs]{\typectx_i \types \la\vartwo\var\vartwo \hastype \ltype_i}{\infer[\typingruleApp]{\typectx_i,\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \var\vartwo \hastype \mtypetwo'_i}{\typectx_i \types \var \hastype [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i] & \infer[\typingruleMany]{\vartwo \hastype \biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \types \vartwo \hastype \biguplus_{0 \leq j\leq m}\ltypetwo_{i,j}}{\left(\infer[\typingruleAx]{\vartwo \hastype [\ltypetwo_{i,j}] \types \vartwo \hastype \ltypetwo_{i,j}}{}\right)_{0\leq j \leq m}}}} & \ldots ~{0 \leq i \leq n}}\]
		
		Hence, if we keep unfolding on $\typectx_i \types \var \hastype [\biguplus_{0 \leq j\leq m}[\ltypetwo_{i,j}] \multimap \mtypetwo'_i]$, we get that $\biguplus_{0 \leq i\leq n}\typectx_i = \var \hastype \mtype$.\qedhere
		\end{enumerate}
\end{proof}


%\input{example-cbn-duplication-not-validated-by-type-equivalence}