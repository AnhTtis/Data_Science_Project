% !TEX root = main.tex

\section{From Operational to Denotational Semantics: the Type Preorder}
\label{sect:type-preorder}
In this section, we study a behavioral preorder, the \emph{type preorder} $\leqtype$, which is not defined as a nf-similarity, it is instead induced by a denotational model. Namely, \citeauthor{DBLP:conf/csl/Ehrhard12}'s \cbv relational model \citeyearpar{DBLP:conf/csl/Ehrhard12} presented as a system of multi types, also known as \emph{non-idempotent intersection types}. We shall prove that both Lassen's similarity $\leqenf$ and our net similarity $\leqnet$ are included in $\leqtype$. The aim is to show that, while $\leqenf$ and $\leqnet$ are incomparable, they can be combined in a cost-sensitive preorder (the contextual preorder combines them but it is not cost-sensitive). We introduce the bare minimum about \cbv multi types. For more, see \cite{Accattoli-Guerrieri-TypesFireballs,DBLP:journals/pacmpl/AccattoliG22}.


%Let's first recall the definition of a lambda-model, in the case of Call-by-Value evaluation, adding clauses for explicit substitutions as we are considering the Value Substitution Calculus.

%\begin{definition}[Lambda-model, \cite{lambda-models-dezani}]
%	A $\l$-model is a pair $(\dom, \interp{~})$ where $\dom$ is a set, $\interp{~}$ is a mapping from $\l$-terms to elements of $\dom$ called the \emph{interpretation} and $\interp{~}$ satisfies the following:
%	
%	\begin{itemize}
%		%\item \emph{(applicative)} $\interp{\tm} \applaw \interp{\tmtwo} \subseteq \interp{\tm\tmtwo}$
%		\item \emph{(applicative)}  $\interp\tm \subseteq \interp\tmp ~\&~ \interp\tmtwo \subseteq \interp\tmtwop \Rightarrow \interp{\tm\tmtwo} \subseteq \interp{\tmp\tmtwop}$
%		\item \emph{(abstractive)} $\interp\tm \subseteq \interp\tmtwo \Rightarrow \interp{\la\var\tm} \subseteq \interp{\la\var\tmtwo}$
%		\item \emph{($\alpha$-equivalence)} $\interp{\la\var\tm} = \interp{\la\vartwo\tm\isub\var\vartwo}$
%		\item \emph{($\beta_v$-equivalence)} $\interp{(\la\var\tm)\val} = \interp{\tm\isub\var\val}$
%		\item \emph{(explicitly substitutive)} $\interp\tm \subseteq \interp\tmp ~\&~ \interp\tmtwo \subseteq \interp\tmtwop \Rightarrow \interp{\tm\esub\var\tmtwo} \subseteq \interp{\tmp\esub\var\tmtwop}$
%		\item \emph{($\alpha$-equivalence')} $\interp{\tm\esub\var\tmtwo} = \interp{(\tm\isub\var\vartwo)\esub\vartwo\tmtwo}$
%	\end{itemize}
%	
%	%We add the two last clauses because we are dealing with the Value Substitution Calculus, which uses explicit substitutions.
%\end{definition}

\input{figures/figure-types} 
\paragraph{Multi Types} \Cref{fig:multi-types-vsc} gives the definition of multi types $\mtype$ for the VSC, which  mutually depends on the definition of linear types $\ltype$. Multi types are defined as finite multi-sets $\multitype{n}{\ltype}$, which intuitively denote the intersection $\ltype_1 \cap \ldots \cap \ltype_n$, where the intersection $\cap$ is a commutative, associative and non-idempotent ($A \cap A \not = A$) operator, the neutral element of which is $\emptytype$, the empty multi set.
Note that there is no ground type, its role is played by the empty multi type $\emptytype$.

A typing judgment is of the shape $\typectx \types \tm \hastype T$ where $T$ is a linear or a multi type and $\typectx$ is a typing context, that is an assignment of multi types to a finite set of variables ($\typectx = \var_1 \hastype \mtype_1, \ldots, \var_n \hastype \mtype_n$). A typing derivation $\typeder \derives \typectx \types \tm \hastype \mtype$ is a tree built from the derivation rules defined in \Cref{fig:multi-types-vsc} which ends with the typing judgment $\typectx \types \tm \hastype \mtype$.

\paragraph{Typing Rules} Linear types only type values, via the rules $\typingruleAx$ and $\typingruleAbs$. To give a multi type to value $\val$, one has to use the $\typingruleMany$ rule, turning an indexed family of linear types for $\val$ into a multi type. Note that any value can be typed with the empty multi type $\emptytype$. %The rules $\typingruleApp$ and $\typingruleES$ involve choosing a new type, which is what makes typing undecidable, but are syntax-based. 
The symbol $\uplus$ is the disjoint union operator on multi sets (which corresponds to our non-idempotent intersection on multi types).  

\paragraph{Characterization of Termination} A key property of multi types is that they characterize $\tovsc$ termination. The characterization is proved via subject reduction and expansion.

\begin{theorem}[Characterization of termination, \cite{DBLP:journals/pacmpl/AccattoliG22}]
\label{thm:mtypes-charac}
\hfill
\begin{enumerate}
\item 	\label{p:mtypes-charac-subject} \emph{Subject reduction and expansion}:	let $\tm \tovsc \tmtwo$. Then $\typectx \types \tm \hastype \mtype$ if and only if $\typectx \types \tmtwo \hastype \mtype$.

\item $\tm$ is $\tovsc$-terminating if and only if there exists $\typectx$ and $\mtype$ such that $\typectx \types \tm \hastype \mtype$.
\end{enumerate}
\end{theorem}
Since $\tovsc$-divergence characterizes \cbv $\Omega$-terms (\refthm{cbv-scrutability-characterization}), \emph{not being typable} with multi types characterizes it too, by the previous theorem.

\paragraph{Multi Types Induce a Model}
Multi types induce a model
by interpreting a term %simply 
as the set of its type judgments. 
A possibly empty list of pairwise distinct variables $\vec{\var} = (\var_1, \dots, \var_n)$ is \emph{suitable for} $\tm$ if $\fv{\tm} \subseteq \{\var_1, \dots, \var_n\}$.
If $\vec{\var} = (\var_1, \dots, \var_n)$ is suitable for $\tm$, the \emph{semantics} $\sem{\tm}_{\vec{\var}}$ \emph{of} $\tm$ \emph{for} $\vec{\var}$ is given by:\adr{
\begin{center}$
	\sem{\tm}_{\vec{\var}} \defeq \{((\mtypetwo_1,\dots, \mtypetwo_n),\mtype) \mid 
	\exists 
	\, 
	\concl{\tderiv}{\var_1 \hastype \mtypetwo_1, \dots, \var_n \hastype \mtypetwo_n}{\tm}{\mtype} \}$
\end{center}}
This is exactly \citeauthor{DBLP:conf/csl/Ehrhard12}'s \cbv relational model \citeyearpar{DBLP:conf/csl/Ehrhard12}. Ehrhard considers it with respect to Plotkin's calculus. We do not prove that it is a model for the VSC, because there is no formal notion of VSC model. We do have, however, that subject reduction and expansion (\refthmp{mtypes-charac}{subject}) ensure that the interpretation $\sem{\tm}_{\vec{\var}}$ is \emph{invariant} by $\tovsc$, and compatibility of the induced equational theory is proved below. These properties are what the definitions of $\l$-models or categorical models are meant to ensure. Moreover, the characterization theorem (\refthm{mtypes-charac}) ensures that $\sem{\tm}_{\vec{\var}}$ is adequate.


\begin{corollary}[\cite{DBLP:journals/pacmpl/AccattoliG22}]
	\label{thm:invariance-and-adequacy}
	Let $\tm$ be a term in the \VSC with $\vec{\var}  = (\var_1, \dots, \var_n)$ suitable for it.
\begin{enumerate}
	\item \emph{Invariance}: if $\tm (\tovsc \cup \streq) \tmtwo$ then $\sem{\tm}_{\vec{\var}} = \sem{\tmtwo}_{\vec{\var}}$.
	\item \emph{Adequacy for} $\tovsc$: $\sem{\tm}_{\vec{\var}}$ is non-empty if and only if $\tm$ is $\tovsc$-terminating.

\end{enumerate}
\end{corollary}

\paragraph{The Type Preorder} Every model $M$ induces an equational theory defined as $\tm =_M \tmtwo$ if $\sem\tm_M = \sem\tmtwo_M$. For the multi types model, we consider the \emph{preorder} induced by $\interp\tm_{\vec\var} \subseteq \interp\tmp_{\vec\var}$.
\begin{definition}[Type preorder]
The type preorder $\tm \leqtype \tmp$ holds if $\typectx \types \tm \hastype \mtype$ implies $\typectx \types \tmp \hastype \mtype$.
\end{definition}
Rephrasing the definition with respect to interpretations, we have that $\tm \leqtype \tmp$ if $\interp\tm_{\vec\var} \subseteq \interp\tmp_{\vec\var}$ for every list of suitable variables $\vec\var$. By the adequacy of $\interp\tm_{\vec\var}$, it follows the adequacy of $\leqtype$. Compatibility is easily proved directly, for once, and soundness follows.

\begin{toappendix}
\begin{proposition}[Compatibility of $\leqtype$] \label{prop:type-preorder-is-compatible}
\hfill
\begin{enumerate}
\item \emph{Compatibility}: if $\tm\leqtype\tmp$ then $\ctxp\tm \leqtype \ctxp\tmp$.
\item \emph{Soundness}: if $\tm\leqtype\tmp$ then $\tm\leqcv\tmp$.
\end{enumerate}
\end{proposition}
\end{toappendix}

\paragraph{Enf and Net Are Included in Type}
Now, we show that $\leqenf$ and $\leqnet$ are both included in $\leqtype$. For that, we prove that, if $\tm\leqenf\tmp$ or $\tm\leqnet \tmp$, then any typing derivation for $\tm$ can be transformed in a typing derivation for $\tmp$ having the same final judgement. The next two propositions and the associated lemma are proved by induction on the following notion: the \emph{size} $\size\typeder$ of a type derivation $\typeder$, defined as the number of rule occurences in $\typeder$ except for rule $\typingruleMany$.

\begin{toappendix}
\begin{proposition}
	\label{prop:bisimulation-preserves-typeder}
\hfill
\begin{enumerate}
\item \emph{Net simulations and type derivations}:
	let $\relsym$ be a \net simulation. If $\tm \rel \tmp$ and $\typeder: \typectx \types \tm \hastype \mtype$ then there exists a derivation $\typederp: \typectx \types \tmp \hastype \mtype$.
	\item \emph{Net is included in Type}: if $\tm\leqnet\tmp$ then $\tm\leqtype\tmp$.
	\end{enumerate}
\end{proposition}
\end{toappendix}

%\begin{corollary}
%	$\leqnet \subseteq \leqtype$.
%\end{corollary}
To relate \enf similarity and typability, we need a lemma to deal with Lassen's stop-and-go. 
\begin{toappendix}
\begin{lemma}[Stop-and-go and type derivations]
	\label{l:smaller-derivations-stuck}
	Let $\typeder \derives \typectx \types {\levctxp{\var\val}} \hastype \mtype$ and $\varthree$ be fresh. Then there exist $\typeder_\levctx \derives  \typectx_\levctx, \varthree \hastype \mtypetwo \types  \levctxp{\varthree} \hastype \mtype$ with $\size{\typeder_\levctx}<\size\typeder$ and $\typeder_\val \derives \typectx_\val \types \val : \mtypetwo_1$ with $\size{\typeder_\val}<\size\typeder$.
\end{lemma}
\end{toappendix}

\begin{toappendix}
\begin{proposition}
	\label{l:enf-bisimulation-preserves-typeder}
	\hfill
\begin{enumerate}
\item \emph{Enf simulations and type derivations}:
	let $\relsym$ be an \enf simulation. If $\tm \rel \tmp$ and $\typeder \derives \typectx \types \tm \hastype \mtype$ then there exists a derivation $\typederp \derives \typectx \types \tmp \hastype \mtype$.
	\item \emph{Enf is included in Type}: if $\tm\leqenf\tmp$ then $\tm\leqtype\tmp$.
	\end{enumerate}
\end{proposition}
\end{toappendix}

\ignore{\paragraph{$\etav$ Reduction} Concerning $\etav$ equivalence, the multi type system we consider does not (fully) validate it. In \cbn but this is standard and it is usually fixable by adding a recursive equation on the ground type. To our knowledge, however, the question has not been studied in \cbv. 

Part of $\eta_v$ equivalence, that is $\eta_v$-reduction, is however validated by the type preorder. On the other side, $\eta_v$-expansion fails. Hence none of them is validated by the symmetric closure of the type preorder, namely type equivalence. We first show the result on $\eta_v$-reduction for variables.
Actually, $\eta_v$ equivalence on closed values is standard and validated by $\alpha$-equivalence and reduction steps below lambdas. Therefore we can describe exactly how $\eta_v$ is included in the type preorder.
\begin{toappendix}
\begin{proposition} Let $\var$ a variable and $\val$ a value. One then has:
	\label{prop:etav-for-leqtype}
	\begin{enumerate}
		\item \emph{(Variable $\eta_v$-equivalence)} $\la\vartwo\var\vartwo \leqtype \var$, but $\var \not \leqtype \la\vartwo\var\vartwo$,
		\item  \emph{(Value $\eta_v$-equivalence)} $\la\vartwo\val\vartwo \leqtype \val$ for any $\val$ and $\val \leqtype \la\vartwo\val\vartwo$ iff $\val$ is an abstraction.
	\end{enumerate}
\end{proposition}
\end{toappendix}}



\paragraph{$\eta_v$ Equivalence} 
By the fact that \enf and \net similarities are incomparable follows that they are strictly included in $\leqtype$. A further  gap between the type preorder $\leqtype$ and $\leqenf$ or $\leqnet$ is $\eta_v$ equivalence, which is included in $\leqtype$ but not in $\leqenf$ nor $\leqnet$.
%It is somewhat arbitrary to describe linear types with a ground type (see \Cref{fig:multi-types-vsc}), and the counterexample for $\var \leqtype \la\vartwo\var\vartwo$ precisely uses the existence of a ground type. We now show that if we define linear types with the grammar $\ltype \grameq [\mtype \multimap \mtypetwo]$, $\eta_v$ equivalence is included in the induced preorder $\leqtypetwo$. 
%Again, we reason first on $\eta_v$-reduced or $\eta_v$-expanded variables. In the same fashion as before, we can extend the result to all values, which gives us that $\eta_v$ equivalence is included in the $\leqtypetwo$ preorder.
%We first show the result on $\eta_v$-reduction for variables.
%Actually, $\eta_v$ equivalence on closed values is standard and validated by $\alpha$-equivalence and reduction steps below lambdas.
%The technical statement is the first part of the next proposition, as $\eta_v$ equivalence on abstractions is included in $\beta_v$ equivalence.

\begin{toappendix}
	\begin{proposition}[$\eta_v$-equivalence is included in type equivalence]	\label{prop:etav-for-leqtypetwo}
	Let $\var$ a variable. Then $\la\vartwo\var\vartwo \leqtype \var$ and $\var \leqtype \la\vartwo\var\vartwo$.
	\end{proposition}
\end{toappendix}



\paragraph{Characterizing Type Equivalence} We conjecture that $\leqtype$ is exactly the sup of the \enf and \net similarities enriched with $\eta_v$ equivalence, that is, that generalizing $\leqnet$ as to validate $\equivlid$ and $\equivetav$ would match $\leqtype$. If the conjecture is false, finding a nf-similarity presentation of $\leqtype$---which corresponds to describe the equational theory of \cbv relational semantics---is anyway an interesting and challenging problem.

About full abstraction with respect to \cbv contextual equivalence $\eqcv$, it fails for $\equivtype$, as $\equivtype$ is cost-sensitive---it does not validate \cbn duplication---while $\eqcv$ is cost-insensitive.



