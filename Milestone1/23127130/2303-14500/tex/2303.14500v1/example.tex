% EPTCS Style distribution v1.7.0 released May 23, 2022.
% https://github.com/EPTCS/style
\documentclass[submission,copyright,creativecommons]{eptcs}
%\providecommand{\event}{QPL 2023} % Name of the event you are submitting to


\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage {svg}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{tcolorbox}

\usepackage{braket} % added by miao (2021/12/12)

\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}

\usepackage{booktabs} % For formal tables
\usepackage{multirow}
\usepackage{float}
\newfloat{Figure}{htbp}{lof}[section]
\usepackage{subfigure}
\usepackage{diagbox}
\usepackage{enumitem} % for itemize distance

\usepackage{url}
\usepackage{stmaryrd}
%\usepackage[section]{placeins}
%\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{amsfonts}
\usepackage{makecell}

%\usepackage[dvipsnames]{xcolor}
%\definecolor{light-gray}{gray}{0.92}

\input{macros} %Jianjun Zhao (20210106)

\title{On Code Safety for Quantum Intermediate Representations}
\title{Formalization of Quantum Intermediate Representations\\ for Code Safety}
%\author{
%Junjie Luo\quad\quad Jianjun Zhao
%\institute{Kyushu University}
%\email{\{luo.junjie.609@s,zhao@ait\}.kyushu-u.ac.jp}
%}

\author{Junjie Luo
\institute{Kyushu University}
\email{luo.junjie.609@s.kyushu-u.ac.jp}
\and
Jianjun Zhao
\institute{Kyushu University}
\email{zhao@ait.kyushu-u.ac.jp}
}

\def\titlerunning{}
\def\authorrunning{}
\begin{document}
\maketitle

\begin{abstract}
Quantum Intermediate Representation (QIR) is a Microsoft-developed, LLVM-based intermediate representation for quantum program compilers. QIR aims to provide a general solution for quantum program compilers independent of front-end languages and back-end hardware, thus avoiding duplicate development of intermediate representations and compilers. Since it is still under development, QIR is described in natural language and lacks a formal definition, leading to ambiguity in its interpretation and a lack of rigor in implementing quantum functions. In this paper, we provide formal definitions for the data types and instruction sets of QIR, aiming to provide correctness and safety guarantees for operations and intermediate code conversions in QIR. To validate our design, we show some samples of unsafe QIR code where errors can be detected by our formal approach.
\end{abstract}

\iffalse
\section{Todo List}
\begin{itemize}
    %\item Under 12 pages
    %\item \textcolor{blue}{\checkmark Adjusting Figure 1 to include the specific architecture of the tool (framework) during implementation (complete). }
    \item Reinforcing the presentation on the novelty of the study
    \item Any technical difficulty?
    %\item \textcolor{blue}{\checkmark How to formalize QIR as a straightforward extension of an existing result.  Extend from Zhou's work. }
    %\item \textcolor{blue}{\checkmark The formalization of B[[b]]. Give up the usage of B[[b]], use \textbf{check...} and the description of \textbf{check...} fails... \textbf{Reference:} \textbf{checkbounds} fails when a program accesses such pointers. \textcolor{red}{Need to modify the text content.}}
    %\item \textcolor{blue}{\checkmark The mistake of changing pointer. Modify it during the modification of the equations. }
    %\item \textcolor{blue}{\checkmark The formalization of list Q and R. Modify them with the usage of \textbf{checkreleaselist} and \textbf{appendreleaselist}. }
    %\item \textcolor{blue}{\checkmark The mistake of the release check argument (change to pointer)}
    %\item \textcolor{blue}{\checkmark Modification of abstract syntax (type name, f, LLVM instruction, etc). }
    %\item \textcolor{blue}{\checkmark The gate operation part deleted from abstract syntax and move to the semantics part.}
    %\item \textcolor{blue}{\checkmark Table 1 should be deleted.}
    %\item \textcolor{blue}{\checkmark The gate operation should not define as input/output relation. }
    %\item \textcolor{red}{Maybe do not need the sample of unsafe QIR code?}
    %\item \textcolor{red}{Modify all the equation.}
\end{itemize}
\fi

\section{Introduction}

Developing a Noisy Intermediate-Scale Quantum Computer (NISQ)~\cite{preskill2018quantum} offers new opportunities for research and development of quantum software. With the increasing development of quantum hardware, quantum program processors (QPUs) are expected to complement further and accelerate existing classical scientific computation workflows, called heterogeneous quantum-classical computation. Various programming languages such as \texttt{Qiskit}~\cite{aleksandrowicz2019qiskit}, \texttt{Cirq}~\cite{cirq2018google}, \texttt{Q\#}~\cite{svore2018q}, \texttt{Quipper}~\cite{green2013quipper}, and \texttt{ProjectQ}~\cite{projectq2017projectq} have been developed to implement such a computational model. Like classical programs, compiled quantum programming languages, such as Q\#, require their quantum programs to be compiled by a compiler into an intermediate representation (IR), which is subsequently optimized and transformed for efficient execution on a designated platform. Since IR has platform-independent features, its optimizer and executable generator can be reused under multiple source languages and generate the corresponding executable code according to the target execution platform. It is often necessary to develop new IRs or extend existing ones to adapt the intermediate representation to quantum properties. Some of the intermediate representations used in quantum programming languages include MLIR~\cite{mlir,MLIR-Quantum}, SQIR~\cite{SQIR}, and OpenQASM~\cite{OpenQASM}.

Quantum Intermediate Representation (QIR)~\cite{QIR} is a new intermediate representation of quantum programs developed by Microsoft, based on the popular open-source LLVM intermediate language~\cite{LLVM:CGO04}. QIR enables the representation of quantum computing workflows and tasks by specifying a set of rules for representing quantum structures in LLVM without any extensions or modifications. Its goal is to provide a unified and common interface to multiple quantum programming languages and quantum computing platforms, thus facilitating the development of general quantum compilation tools that can be reused in the compiler mechanism. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]
    {image/QIR_structure.pdf}
    \caption{The QIR compiler architecture. }
    \label{fig:QIR_structure}
    \vspace*{-2mm}
\end{figure}

The QIR-based compiler processes the high-level source quantum language by converting it to QIR and handing it over to the target backend for execution (see Figure \ref{fig:QIR_structure}). Since QIR is designed and implemented based on LLVM, applying the classical LLVM optimization methods to transform and optimize QIR code is possible. However, since QIR is still in the early stage of development, it lacks clear formal semantics. Thus, its execution and the correctness of the optimization and conversion are difficult to rigorously proven, making it difficult to guarantee the correct operations of quantum programs. \textcolor{black}{In our work, we hope to design a formal method for QIR and develop a framework for verification based on this method so that QIR code can be tested for \textcolor{black}{safety} by this verification framework before it actually executed.}

In our work, we focus on the core functions of QIR, which play a crucial role in the correct operation of QIR programs. Therefore, in this paper, we prioritize formalizing the syntax and semantics of these core functions so that we can detect possible errors in the execution of QIR's core functions and guarantee that QIR's essential functions can be executed properly. Our contributions can be summarized as follows: 

\begin{itemize}
    %\item \textcolor{red}{We present an abstract syntax of QIR, which is an extension of the work~\cite{qirsyntax} by Campora, to express the features of QIR better. Concretely, we expand the data types, subdivide the types of gate operations, and add an abstract syntax for measurement operations.}
    \item We formalize the syntax of QIR based on the work of Zhao {\it et al.}~\cite{vellvm}. Specifically, we have adapted its abstract syntax to remove LLVM directives and types not used in QIR and augment QIR-specific data types. 
    \item We design the semantics of important instructions in QIR, such as allocation and release qubits, gate operations, and measurement. These operations constitute the implementation of the most basic quantum program functions, and formalization based on them can allow us to capture unsafe parts of the code. 
    \item We design a management model for qubits through which, together with our formal methods, the unsafe parts of the QIR code can be captured (e.g., qubits cloning and the use of released qubits).
    \item We validate the effectiveness of our formal approach by applying it to real cases of unsafe QIR code.
\end{itemize}

The rest of the paper is organized as follows. We introduce the background information of LLVM Intermediate Representation (LLVM IR) and QIR in Section \ref{sec:background}. We present our formalization of the syntax and semantics of QIR in Section \ref{sec:methodology}. The validation of our formal method with real-world examples is presented in Section \ref{sec:result}. We discuss related work in Sections \ref{sec:related-work}, and the conclusion is given in Section~\ref{sec:conclusion}.


%2
\section{Background}
\label{sec:background}
%Before introducing the formalization of QIR, 
This section briefly introduces LLVM IR, the basis of QIR, and QIR itself. 


\subsection{Basic Concepts}

Unlike classical programs that use classical bits to store information, in quantum programs, quantum bits ("qubits") are used as the medium for storing data. As compared to a classical bit that can only be in either $0$ or $1$ state, a qubit can be in both $0$ and $1$ states, and it is called a quantum \texttt{superposition} state. The superposition state of a qubit can be represented by $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, where $\ket{}$ is called the Dirac symbol, and $|\alpha|^2 + |\beta|^2 = 1$. We cannot directly observe the state of a qubit, which is in the superposition state; instead, we must measure it and obtain a $0$-state with probability $|\alpha|^2$ or a $1$-state with probability $|\beta|^2$.

In quantum computing, we usually use quantum logic gates to control the state of the qubits. Some basic gate operations include: 
\begin{itemize}
    \item \textbf{X gate (NOT gate)}: When a quantum undergoes the X-gate operation, its state changes from $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$ to $\ket{\psi} = \beta\ket{0} + \alpha\ket{1}$. We can use the matrix to represent this operation: 
    \begin{equation}
    %\footnotesize
        X=\left[\begin{array}{ll}
0 & 1 \\
1 & 0
\end{array}\right]
    \end{equation}
    \item \textbf{Y gate and Z gate}: Similarly, for the Y and Z gates have the following expressions: 
    \begin{equation}
    %\footnotesize
        Y=\left[\begin{array}{ll}
0 & -1i \\
1i & 0
\end{array}\right] \quad\&\quad Z=\left[\begin{array}{ll}
1 & 0 \\
0 & -1
\end{array}\right]
    \end{equation}
    \item \textbf{Hadamard gate (H gate)}: Hadamard gate can turn a $\ket{0}$ state or a $\ket{1}$ state into a superposition of $\ket{0}$ and $\ket{1}$ with equal probability: 
    \begin{equation}
    %\footnotesize
        H=\frac{1}{\sqrt{2}}\left[\begin{array}{cc}
1 & 1 \\
1 & -1
\end{array}\right]
    \end{equation}
    \item \textbf{Controlled gate}: Unlike the single-qubit gate that can only accept one qubit as input, as described above, the controlled gate can accept multiple qubits as input. Specifically, for qubits input to the controlled gate, there are control qubits and target qubits, and the state of the target qubit is changed only when the states of both control qubits are $\ket{1}$. For example, for the CNOT gate (Controlled NOT gate), the logical expression is: 
    \begin{equation}
        \ket{A, B} \rightarrow \ket{A, B\oplus A} 
    \end{equation}
    Similarly, the Toffoli gate, also known as the CCNOT gate, possesses two control qubits that together control the flip of the target qubit with the expression: 
    \begin{equation}
        \ket{A, B, C} \rightarrow \ket{A, B, C\oplus AB}
    \end{equation}
\end{itemize}
All the above quantum logic gates are reversible, so no information loss occurs during quantum computing. By applying gate operations to qubits, quantum circuits can be composed, and thus quantum algorithms can be implemented. It is the model widely used by quantum programs nowadays. One other important operation is measurement. A classical bit in a 0 or 1 state can be obtained by performing a measurement operation on a single qubit. More content related to quantum computing can be found in the book by Nielsen and Chuang~\cite{nielsen2002quantum}.



\subsection{LLVM IR}
The LLVM IR~\cite{LLVM:CGO04} is a high-level static single assignment form (SSA) language used by the LLVM compiler infrastructure as the intermediate representation for source code. It is a representation of the source code that is independent of the source languages and target platforms. It is currently widely used and there are many conversion and optimization methods available around it. Compilers can perform various optimizations on the code of a program based on this, including common subexpression elimination, dead code elimination, and loop unrolling. These optimizations can improve the performance of the generated machine code, making it run faster and more efficiently.

LLVM IR is a strongly typed language, meaning each value has a specific type, such as an integer or floating point value. Such a design helps prevent type errors and allows the compiler to generate more efficient code. \textcolor{black}{Similar to RISC instructions,} LLVM IR is designed as a triple-address form. Combined with its strong typing, it allows for both compilation and optimization based on individual compilation units and precise global optimization performed at link time using type information. LLVM IR also includes support for control flow, loops, and other common language constructs, which makes it possible to represent a wide range of programs. %\textcolor{purple}{delete}% \textcolor{blue}{in this language.} 

%LLVM IR is a static single assignment form (SSA) language that is independent of the front-end language, instruction set, and type system. It provides type safety, low-level operation, flexibility, and the ability to adapt to multiple source languages and back-end hardware. Its feature of assigning each variable only once simplifies the analysis of dependencies between variables, thus helping to simplify the process of compiler optimization. 

%LLVM programs consist of \texttt{Module}'s, where each input program corresponds to a module. Modules consist of functions, global variables, and symbol table entries. Multiple modules can be combined using the LLVM linker.

\subsection{Quantum Intermediate Representation (QIR)}

Microsoft has developed a new quantum intermediate representation called Quantum Intermediate Representation (QIR), which is based on the widely used open-source LLVM IR. To promote QIR and provide solutions for efficient use of different quantum processors, Microsoft has established the QIR Alliance~\cite{QIR-Alliance}. QIR avoids the need for creating new compilers for different quantum programming languages by leveraging the existing classical infrastructure of LLVM IR, enabling support for the necessary functions of quantum programs without requiring additional extensions or modifications. Specifically, QIR preserves the LLVM primitives such as \textbf{call}, \textbf{bitcast}, \textbf{getelementptr}, and other classical data types such as integer \textbf{i}$sz$ and double \textbf{Double}. In order to implement quantum operations, QIR adds two data types to LLVM IR, \textbf{\%Qubit} and \textbf{\%Result}, which represent quantum registers and the results of measurements, respectively. There are also two data structures, \textbf{\%Array} and \textbf{\%Tuple}, which represent arrays of the same type of data and user-defined structures composed of arrays of multiple types, respectively. All the above four data types are opaque to QIR. To make it easier to express the operations of qubits, QIR adds new data types, such as \textbf{\%Pauli}, which refers to the four Pauli matrices in quantum mechanics. 

%Here, \textbf{\%Qubit} and \textbf{\%Result} are opaque LLVM structures, requiring each associated runtime library to provide definitions for them, thus maximizing flexibility in implementation.


\iffalse
\begin{table*}[h]
\caption{\label{table:QIR_TYPE} New data types used in quantum intermediate representation}
\begin{tabular}{@{}lll@{}}
\toprule
Type   & LLVM Representation       & Description                                                                                                                                                                                             \\ \toprule
\texttt{Pauli}  & \texttt{\%Pauli}=\texttt{i2}                & \tabincell{l}{The \texttt{Pauli} type indicates the type of quantum gate, from 00 \\to 11 for \texttt{I} gate, \texttt{X} gate, \texttt{Z} gate, and \texttt{Y} gate, respectively. }                                                                                  \\\midrule
\texttt{Range}  & \texttt{\%Range}=\{\texttt{i64}, \texttt{i64}, \texttt{i64}\} & \tabincell{l}{The \texttt{Range} type represents a sequence of integers and the \\three parameters in the \texttt{Range} type represent the start of \\ \texttt{Range}, the step length, and the end of \texttt{Range}. }                                    \\\midrule
\texttt{Result} & A pointer \texttt{\%Result*}               & \tabincell{l}{The \texttt{Result} type is usually present in QIR as a pointer. It is \\usually associated with a measurement result and is expressed \\as a \texttt{0} or \texttt{1}.}                                                                                                           \\\midrule
\texttt{Qubit}  & A pointer \texttt{\%Qubit*}   & \tabincell{l}{The \texttt{Qubit} type is usually present in QIR as a pointer. Each \\ \texttt{Qubit*} points to a qubit in the hardware or simulator, and \\the program can accomplish operations on the qubit by passing \\it to a function.} \\\midrule
\texttt{Array}  & A pointer \texttt{\%Array*}   & \tabincell{l}{The \texttt{Array} type represents arrays. Since Array is an opaque \\type in QIR, all operations on arrays should be performed by \\runtime functions.} \\
\bottomrule
\end{tabular}
\end{table*}
\fi

In addition to the data types, QIR also declares quantum-related runtime functions and functions that operate on qubits (e.g., quantum gate operations and measurement operations). These functions are not implemented in the QIR and need to be defined and implemented externally. Such a design facilitates the adaptation of the QIR to different hardware backends, thus making the QIR independent of the hardware backend. QIR's official documentation~\cite{qir-spec} contains definitions for its instructions, and we will provide a brief explanation of the QIR instructions used in our work. Since the instructions for qubits declared in QIR have the same prefix \emph{@\_\_quantum\_\_rt\_\_} or \emph{@\_\_quantum\_\_qis\_\_}, in our work, we have adopted an omitted notation for them to save space (e.g., the \emph{@\_\_quantum\_\_rt\_\_qubit\_allocate} is omitted and noted as \textit{qubit\_allocate}, the \textit{@\_\_quantum\_\_qis\_\_gateop\_\_body} is omitted and noted as \textit{gateop\_\_body}). 

%\iffalse
Figure \ref{fig:QIR_SAMPLE} shows a sample QIR code, which briefly describes the design of QIR. Lines 1 to 3 of the code mark the opaque data types. 
%Since \textcolor{blue}{Array} consists of \textcolor{blue}{Qubit}, it is an opaque data type here. 
In lines 5 through 12, the code implements the function of allocating a qubit register and measuring it after executing the H gate%on that \textcolor{blue}{Qubit}
. In line 7, the \textit{qubit\_allocate} function is called, which allocates a qubit register. The functions that perform operations on the $Qubit$ are all declared as \textit{gateop\_\_body}, where \textit{gateop} is the specific operation to be performed, e.g., \textit{h} in line 8 refers to the \text{H} gate%, and \texttt{measure} in \textcolor{blue}{line 26} refers to the measurement
. After executing the H gate operation in line 8, the measurement operation in line 9 is explicitly defined in lines 14 through 32. After completing the measurement, the qubit is released with \textit{qubit\_release} in line 10, and the measurement result is returned in line 11.

\begin{figure}[h]
%\begin{figure*}[h]
\begin{center}
\begin{CodeOut}
\scriptsize{
\begin{alltt}

1   \%Result = type opaque
2   \%Qubit = type opaque
3   \%Array = type opaque
4   
5   define internal \%Result* @Sample__SampleQ__body() \{
6   entry:
7     \%q = call \%Qubit* @__quantum__rt__qubit_allocate()
8     call void @__quantum__qis__h__body(\%Qubit* \%q)
9     \%0 = call \%Result* @Microsoft__Quantum__Intrinsic__M__body(\%Qubit* \%q)
10    call void @__quantum__rt__qubit_release(\%Qubit* \%q)
11    ret \%Result* \%0
12  \}
13  
14  define internal \%Result* @Microsoft__Quantum__Intrinsic__M__body(\%Qubit* \%qubit) \{
15  entry:
\iffalse
16    \%bases = call \%Array* @__quantum__rt__array_create_1d(i32 1, i64 1)
17    \%0 = call i8* @__quantum__rt__array_get_element_ptr_1d(\%Array* \%bases, i64 0)
18    \%1 = bitcast i8* \%0 to i2*
19    store i2 -2, i2* \%1, align 1
20    call void @__quantum__rt__array_update_alias_count(\%Array* \%bases, i32 1)
21    \%qubits = call \%Array* @__quantum__rt__array_create_1d(i32 8, i64 1)
22    \%2 = call i8* @__quantum__rt__array_get_element_ptr_1d(\%Array* \%qubits, i64 0)
23    \%3 = bitcast i8* \%2 to \%Qubit**
24    store \%Qubit* \%qubit, \%Qubit** \%3, align 8
25    call void @__quantum__rt__array_update_alias_count(\%Array* \%qubits, i32 1)
26    \%4 = call \%Result* @__quantum__qis__measure__body(\%Array* \%bases, \%Array* \%qubits)
27    call void @__quantum__rt__array_update_alias_count(\%Array* \%bases, i32 -1)
28    call void @__quantum__rt__array_update_alias_count(\%Array* \%qubits, i32 -1)
29    call void @__quantum__rt__array_update_reference_count(\%Array* \%bases, i32 -1)
30    call void @__quantum__rt__array_update_reference_count(\%Array* \%qubits, i32 -1)
\fi
    ...
31    ret \%Result* %4
32  \}
33
34    declare \%Qubit* @__quantum__rt__qubit_allocate() 
35    declare void @__quantum__rt__qubit_release(\%Qubit*) 
36    declare void @__quantum__qis__h__body(\%Qubit*) 
37    declare void @__quantum__rt__array_update_alias_count(\%Array*, i32) 
38    declare \%Array* @__quantum__rt__array_create_1d(i32, i64) 
39    declare i8* @__quantum__rt__array_get_element_ptr_1d(\%Array*, i64) 
40    declare \%Result* @__quantum__qis__measure__body(\%Array*, \%Array*) 
41    declare void @__quantum__rt__array_update_reference_count(\%Array*, i32) 
    
\end{alltt}
    }
    \end{CodeOut}
    \caption{Example of QIR.}
    \label{fig:QIR_SAMPLE}
%\vspace*{-4mm}
\end{center}
\end{figure}
%\fi

%3
\section{Methodology}
\label{sec:methodology}

In this section, we formalize the syntax and semantics of QIR to support the verification of unsafe code. Since QIR is designed based on LLVM IR, this paper does not consider the formalization of the classical LLVM IR part, which can be done using methods~\cite{vellvm, k-llvm}. Our formalization of QIP is based on version 0.1 of QIR.

\subsection{Syntax of QIR}

We first present our formalization of the syntax of QIR in Figure~\ref{fig:QIR_syntax}. Our abstract syntax extends on the work of Zhou {\it et al.}~\cite{vellvm}, which provides a relatively complete formalization of LLVM IR. We mainly add to it data types that are specific to QIR, such as \textbf{\%Qubit}, \textbf{\%Result}, \textbf{\%Array}, etc. Since the QIR instruction is called with LLVM's \textbf{call} instruction, its abstract semantics can be attributed to $id$, so instructions about quantum gate operations, measurement operations, etc., cannot be reflected in the abstract syntax. 


%\iffalse
\begin{comment}
\textcolor{cyan}{We first present our formalization of the syntax of QIR. 
Recently, Campora presented a simple formal syntax at the QIR workshop of QCE2022~\cite{qirsyntax}, which includes several items such as \textit{Decl}, \textit{Op}, \textit{CondExp}, \textit{Exp}, and \textit{Prog}. However, this formalization misses some items and details when considering handling real QIR code. 
To this end, we extend his work to give a more complete formalization of the syntax of QIR.} Figure \ref{fig:QIR_syntax} illustrates the abstract syntax of QIR, where the parts with gray backgrounds show the new syntax we added compared to the original syntax presented by Compora. In particular, we added types that were missing in the original abstract syntax. For the gate operation \texttt{GateOp}, to make the abstract syntax better express QIR, we subdivide the gate operation into a single qubit gate and a controlled gate. Furthermore, in the types of primitives \texttt{Prim}, we complement the measure operation and its abstract syntax, distinguishing it from operations \texttt{Op} and gate operations \texttt{GateOp}. This is because the measurement operation is irreversible, unlike the reversible nature of quantum logic gates, and confusing it with other gate operations could lead to unpredictable errors.

In the syntax in Figure \ref{fig:QIR_syntax}, \texttt{n} denotes a natural number, \texttt{sg} and \texttt{cg} denote the name of a valid gate, and \texttt{x} is the name of a register. The declaration \texttt{Decl} defines the declaration of QIR for classical registers and quantum registers. Primitive \texttt{Prim} defines the operations that can be executed in QIR, where operation \texttt{Op} denotes some common operations, including summation, difference, and comparison. Gate operation \texttt{GateOp} includes quantum logic gates such as \texttt{X} gate, \texttt{CNOT} gate, and \texttt{Toffoli} gate. \texttt{MzOp} denotes the measurement of qubits, where \texttt{m} refers to the instruction \texttt{\_\_quantum\_\_qis\_\_measure\_\_body} in QIR. The conditional expression \texttt{CondExp} defines the conditional execution in QIR, and together with \texttt{Prim}, they form the expressions \texttt{Exp} of QIR.

Based on this, we have further adapted and optimized the syntax by further subdividing \texttt{GateOp} into \texttt{SingleGateOp} and \texttt{ControlGateOp}. In QIR, multiple qubit gates are implemented using controlled gates (e.g., SWAP and Toffoli gates), so controlled gates should be discussed to trace back to the most atomic gate operations. This is because, in our investigation of the QIR code, we found that the operations of multi-qubit gates such as \texttt{SWAP} gates and \texttt{Toffoli} gates are finally implemented in the form of controlled gates (e.g., \texttt{SWAP} gate is a combination of three \texttt{CNOT} gates, and \texttt{Toffoli} gate is a \texttt{CCNOT} gate using two control qubits). Therefore, at this stage, the distinction between gate operations as single-qubit gates and controlled gates can better represent the code generated by QIR. At the same time, since controlled gates have a unique operational process in the QIR implementation, discussing them separately will be specified later in the semantics of gate operations. Moreover, to accommodate this change, we also distinguish the \texttt{g}, which originally represented the name of the gate, with \texttt{sg} and \texttt{cg} to represent single-qubit quantum gates and multi-qubit quantum gates, respectively.
\fi
\end{comment}



\begin{figure}[h]
    \centering
    \begin{math}
    \small
        \begin{array}{l}
        \text{Types\quad\quad\ $typ$ ::= \textbf{i}\textit{sz} $|$ \textbf{double} $|$ \textit{typ}* $|$ [$sz\times typ$] $|$ $typ$ $\overline{typ_j}^j$ $|$ \{$\overline{typ_j}^j$\} $|$ \textit{id} $|$ \textcolor{red}{\textbf{\%Pauli}} $|$ \textcolor{red}{\textbf{\%Range}} $|$ \textcolor{red}{\textbf{\%Result}} }\\
        \text{\quad\quad\quad\quad\quad\quad\ \ \  $|$ \textcolor{red}{\textbf{\%Qubit}} $|$ \textcolor{red}{\textbf{\%Array}} $|$ \textcolor{red}{\textbf{\%Tuple}}}\\
%            \text{n ::= \textbf{i}\textit{sz}}\\
            %\text{\textcolor{red}{Single gates \textit{sg} ::= \textbf{I} $|$ \textbf{X} $|$ \textbf{Y} $|$ \textbf{Z}}} \\
            %\text{\textcolor{red}{controlled gates \textit{cg} ::= \textbf{CNOT} $|$ \textbf{CCNOT} $|$ \textbf{CY} $|$ \textbf{CZ}}} \\
            \text{Products\ \ \textit{prod} ::= \textbf{define} $typ$ $id$ ($\overline{arg}$) \{$\overline{b}$\} $|$ \textbf{declare} $typ$  $id$ ($\overline{arg}$)}\\
            \text{Values\quad\ \ \ \ $val$ ::= $id$ $|$ $cnst$} \\
            \text{Constants \textit{cnst} ::= \textbf{i}\textit{sz} \textit{Int} $|$ \textbf{double} \textit{Double} $|$ 
 \textbf{void} $|$ $typ^* id$ $|$ $typ$ [$\overline{cnst_j}^j$] $|$ \{$\overline{cnst_j}^j$\} $|$ \textbf{extractvalue} $cnst$ $\overline{cnst_j}^j$ }\\
            \text{\quad\quad\quad\quad\quad\quad\ \  $|$ \textbf{getelementptr} $cnst$ $\overline{cnst_j}^j$ $|$ \textbf{bitcast} \textit{cnst} \textbf{to} \textit{typ} $|$ \textcolor{red}{\textbf{\%Range} \textit{Int} \textit{Int} \textit{Int}} $|$ \textcolor{red}{\textbf{\%Pauli} $Int$}}\\
            %\text{Operation Op ::= x\  $|$\  n\ $|$\  Op\ +\ Op\ $|$\  Op\ -\ Op\ $|$\  Op\ *\ Op\ $|$\  Op\ \&\ Op\ $|$\  Op\ ==\ Op\ $|$ \  Op\ $!=$\ Op\ $|$\  Op\ $<$\ Op\ ...}\\
            \text{Blocks\ \ \quad\quad b ::= $l\overline{\phi}\overline{c}tmn$} \\
            \text{Tmns \quad\ \ \ $tmn$ ::= \textbf{ret} $typ$ $val$ $|$ \textbf{ret void} $|$ \textbf{br} $val$ $l_1$ $l_2$ $|$ \textbf{br} $l$ }\\
            \text{Commands \ \ \textit{c} ::= \textit{id} = \textbf{bitcast} $typ_1 val$ \textbf{to} $typ_2$ $|$ \textbf{store} \textit{typ} $val_1$ $val_2$ \textit{align} $|$ \textit{option id} = \textbf{call} $typ_0$ $val_0$ $\overline{param}$ }\\
            \text{\quad\quad\quad\quad\quad\quad\ \  $|$ \ \textit{id} = \textbf{getelementptr} ($typ*$) $val$ $\overline{val_j}^j$ $|$ \textit{id} = \textbf{load} ($typ*$) $val_1$ $align$}\\
            \text{\quad\quad\quad\quad\quad\quad\ \  $|$ \ $id$ = \textbf{icmp} $cond$ $typ$ $val_1$ $val_2$ $|$ $id$ = \textbf{alloca} $typ$ $val$ $align$}\\
            %\text{Commands \textit{c} ::= \textcolor{red}{\textit{GateOp}} $|$ \textcolor{red}{\textit{MzOp}} $|$ \textit{LLVMc}} \\
            %\text{Condition expression CondExp ::= if CompOp\ \{\underline{Prim}\}} \\
            %\text{Expression Exp ::= Prim \ $|$\  CondExp} \\
            %\text{Program Prog ::= \underline{Decl}\ \underline{Exp}}
            %\colorbox{light-gray}{Gate operations \textit{GateOp} ::= SingleGateOp\  $|$\  ControlGateOp} \\
            %\colorbox{light-gray}{Single gate operations \textit{SingleGateOp} ::= sg(\underline{f})\ qreg[n]} \\
            %\colorbox{light-gray}{controlled gate operation \textit{ControlGateOp} ::= cg(\underline{f})\ \underline{qreg[n]}\ qreg[n]} \\
            %\colorbox{light-gray}{Measurement operations \textit{MzOp} ::= m(\underline{p}) \underline{qreg[n]}}\\
        \end{array}
    \end{math}
%    \vspace*{-2mm}
    \caption{The abstract syntax of QIR. The red font shows what is added to the abstract semantics of QIR compared to LLVM IR.}
%    \vspace*{-4mm}
    \label{fig:QIR_syntax}
\end{figure}

\subsection{Semantics of QIR}

We next present our formalization of the semantics of QIR. Since QIR is designed to treat instructions as declarations of quantum runtime functions, the type is explicitly specified for each instruction input and output. Such a design avoids the nondeterministic semantics found in classical LLVM IR, thus liberating our efforts from cumbersome type checking and allowing us to focus the formalization on checking the correctness of quantum operations. Since the back-end hardware is responsible for implementing quantum operations in QIR, formalizing this process in QIR is not necessary. The guarantee of correct quantum operations should lie with the back-end hardware. Therefore, we can assume that the quantum operations are correct and further improve the security of the QIR code.

\subsubsection{Allocating and Releasing Qubits}
\label{Allocate}
\begin{comment}
In QIR code, $Qubit^*$ is a pointer used to represent the concrete syntax of qreg[n]. For ease of understanding, %distinguish between different types of qubits (e.g., control-qubits and controlled-qubits), the qreg[n] in this paper is represented by $Qubit^*$ and 
an $Array$ with $n$ elements and $typ$ type is represented by $\overline{typ}^n$, the pointer of $i$-th element of the $Array$ is represented as $\overline{typ}^n[i]$.
\end{comment}

QIR manipulates the corresponding qubits in the back-end registers by feeding $\textbf{\%Qubit}^*$ or $\textbf{\%Array}^*$ composed of them to the corresponding functions, without having direct access to $\textbf{\%Qubit}$ or $\textbf{\%Array}$ information (since they are opaque to QIR as well as LLVM). It makes it difficult for QIR to manage the state of qubits, and the compiler cannot know whether they have been released, thus raising a potential security risk. In this section, we formalize the semantics from the creation of a single qubit as well as an array of qubits and propose a set of management schemes for qubits and qubit arrays so that the possible problems of qubits cloning and the use of released qubits in QIR can be effectively captured.

\paragraph{Static creation.}
In QIR, the allocation of qubits includes both static and dynamic methods. For qubits whose identifiers are already determinable at compile time, static qubit values can be generated using LLVM's \textbf{inttoptr} instruction. The following example is given in the specification document of QIR: 

\begin{center}
    \text{\%qubit3 = \textbf{{inttoptr}} \textbf{i}32 3 \textbf{{to}} $\textbf{\%Qubit}^*$}
    \vspace*{-2mm}
\end{center}

This code refers to a qubit3 device in the real equipment (or simulator) by converting the 3 of the \textbf{i}32 data type to the $\textbf{\%Qubit}^*$ type. \textcolor{black}{Since the instructions for static creation of qubits use only the classical LLVM IR, the formal semantics are not elaborated in our work. }

\begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{image/qir_sementic.pdf}
    \caption{A management model for qubits and qubits arrays in QIR.}
    \label{fig:QandQAmanagement}
    \vspace*{-2mm}
\end{figure}

\paragraph{Dynamic management.} 
Dynamic qubits are allocated and released by the quantum runtime method. To store the allocated qubits and qubit arrays in the QIR code, we introduce two data structures in the framework, a one-dimensional array \textbf{\texttt{Q}} and a two-dimensional array \textbf{\texttt{QA}}, respectively. Our management model is presented in Figure \ref{fig:QandQAmanagement}, where \textbf{\texttt{Q}} stores the $\textbf{\%Qubit}^*$ pointers for each allocated qubit. The first column of \textbf{\texttt{QA}} stores the $\textbf{\%Array}^*$ pointer for the qubit array, while the corresponding row stores the pointer $\textbf{\%Qubit}^*$ for each qubit in the array. Some of the methods used to manage these two data structures are listed in Table \ref{tab: QQAmanagement}.

\begin{table}[h]
\centering
\caption{Some of the methods used to manage qubits and qubit arrays in our validation framework}
\begin{tabular}{|l|l|}
\hline
\makecell[c]{Method}                                 & \makecell[c]{Description}                                                             \\ \hline
\textbf{appqlist}(\textbf{\texttt{Q}}, $q$)  & Append $q$ to \textbf{\texttt{Q}}.                                              \\ \hline
\textbf{appqarrlist}(\textbf{\texttt{QA}}, $qarray$) & Append $qarray$ to \textbf{\texttt{QA}}.                                              \\ \hline
\textbf{checkq}(\textbf{\texttt{Q}}, $q$) & Check if $q$ is in \textbf{\texttt{Q}}. If true, return 1; otherwise, return 0.    \\ \hline
\textbf{checkqarrlist}(\textbf{\texttt{QA}}, $qarray$) & Check if $qarray$ is in \textbf{\texttt{QA}}. If true, return 1; otherwise, return 0.    \\ \hline
\textbf{delq}(\textbf{\texttt{Q}}, $q$)         & Remove $q$ from \textbf{\texttt{Q}}.                                            \\ \hline
\textbf{delqarr}(\textbf{\texttt{QA}}, $qarray$)         & Remove the row of $qarray$ from \textbf{\texttt{QA}}.                                            \\ \hline
\textbf{appqarr}(\textbf{\texttt{QA}}, $qarray$, $q$)                 & Append $q$ to $qarray$ in \textbf{\texttt{QA}}. Skip if $q$ already exists in $qarray$.                                              \\ \hline
\textbf{checkqarr}(\textbf{\texttt{QA}}, $qarray$, $q$)               & Check if $q$ is in $qarray$. If true, return 1; otherwise, return 0.           \\ \hline
\textbf{findqarr}(\textbf{\texttt{QA}}, $q$)                        & Returns the array where $q$ is located, or 0 if the array does not exist. \\ \hline
\end{tabular}
\label{tab: QQAmanagement}
\end{table}

Our formal method is concerned with two possible \textcolor{black}{safety} issues in QIR code: the \textbf{cloning operation of qubits} and the \textbf{usage of released qubits}. These two kinds of unsafe codes can be effectively captured using our proposed management model. Equations \ref{QALLOC} to \ref{QARRDEALLOC} show the operational semantics of allocation and release of qubits and qubit arrays, respectively, where $qubit\_allocate$, $qubit\_allocate\_array$, $qubit\_release$, and $qubit\_release\_array$ are the instructions provided in QIR. Specifically, after performing the allocation of qubits and qubit arrays, their return values ($\textbf{\%Qubit}^*$ and $\textbf{\%Array}^*$) are stored in \textbf{\texttt{Q}} and \textbf{\texttt{QA}} (See Figure \ref{fig:QandQAmanagement}). After releasing the qubit and qubit arrays, the corresponding values are removed from \textbf{\texttt{Q}} and \textbf{\texttt{QA}}. \textbf{To avoid using released qubits and qubit arrays}, we add the process of checking whether the qubits and qubit arrays are in \textbf{\texttt{Q}} and \textbf{\texttt{QA}} (use \textbf{checkq} and \textbf{checkqarrlist}) in all the rules in addition to \hyperref[QALLOC]{Q\_ALLOC} and \hyperref[QARRALLOC]{QARR\_ALLOC}. 

In particular, when releasing a single qubit (rule \hyperref[QDEALLOC]{Q\_DEALLOC}), we have added the process of checking whether the qubit belongs to a qubit array (with \textbf{findqarr}) because releasing a single qubit in a qubit array directly can lead to errors when releasing the qubit array later.

%\textcolor{red}{Under.}
%We will refine and implement the details of $\texttt{\textbf{R}}$ concretely on platforms such as Coq in future work.

%In QIR, a qubit value is treated as a special kind of integer identifier. QIR only provides the corresponding interface but does not define new LLVM instructions for the operation of qubits, which are chosen to be implemented by the target of the link. 
%Therefore, in our work, \textcolor{blue}{we determine the interpretation of the semantics of the individual instructions without the necessity to develop the derivation of the process of implementing the instructions.}

\iffalse
Figure~\ref{QIR_AL} presents our formalization of the methods in QIR for the dynamic management of qubits, which includes the allocation and release of a single qubit and the allocation and release of an array of qubits. 
\fi

%Specifically, QIR returns a $Qubit^*$ when allocating a single qubit.
%and sets the $Qubit^*$ to \texttt{null} when releasing it. 
%When allocating an array of qubits, it returns an Array with the specified size of $Qubit^*$. 
%On releasing the qubit array, it sets the pointer to the array to \texttt{null}. 
%However, since QIR does not operate on the pointers of the $Qubit$ and $Array$ while releasing them. This leads to the fact that for QIR, there is an inability to determine whether a $\textbf{\%Qubit}$ or $\textbf{\%Array}$ has been released or not. \textcolor{red}{For this, we introduce a list $\texttt{\textbf{Q}}$ in our formal method, and by default, the names of all released $Qubit$ and $Array$ are stored in $\texttt{\textbf{Q}}$ immediately, and for the released $Qubit$ or $Array$ we represent it as $\_Qubit$ and $\_Array$. }

%Although QIR requires that to implement the \texttt{qubit\_release\_array} instruction, the qubits in the array should be released before \textcolor{black}{releasing} the array itself. However, since it is executed on the target device (or simulator), which is opaque to the compiler, and the $Array$ pointer is already released after the execution, the compiler cannot check whether the qubit in the array has been released or not.

\iffalse
\begin{figure}[h]
\centering
\Large
\subfigbottomskip=2pt
\subfigcapskip=5pt
\subfigure[Allocation of a single qubit]{
\begin{math}
%\text{\Gamma \vdash Q : Qubit}\\
\frac{\ \ }{ \vdash \ qubit\_allocate \Rightarrow \ \textbf{\%Qubit}^* \ id}\ {\footnotesize \text{QU\_ALLOC}}
\end{math}
\label{all_single}
}\quad
\subfigure[Allocation of array of qubits]{
\begin{math}
%\text{\Gamma \vdash Q : Qubit, n : i64} \\
\frac{\ \ }{n \vdash qubit\_allocate\_array \ \textbf{i}64\ n \Rightarrow 
 \ \textbf{\%Array}^{*}\ id} \ {\footnotesize \text{QUARR\_ALLOC}}
\end{math}
\label{all_arr}
}

\subfigure[Releasing of a single qubit]{
\begin{math}
%\text{\Gamma \vdash Q : Qubit}\\
\frac{ {\normalsize \colorbox{light-gray}{\textbf{checkreleaselist}(\texttt{\textbf{R}}, \textit{id})}}\ {\normalsize \colorbox{light-gray}{\textbf{appendreleaselist}(\texttt{\textbf{R}}, \textit{id})=\texttt{\textbf{R}}}}}{\ qubit\_release \ \textbf{\%Qubit}^* \textit{id}}\ {\footnotesize \text{QU\_RELEASE}}
\end{math}
\label{rel_single}
}

\subfigure[Releasing of array of qubits]{
\begin{math}
%\text{\Gamma \vdash Q : Qubit, n : i64} \\
\frac{{ {\normalsize \colorbox{light-gray}{\textbf{checkreleaselist}(\texttt{\textbf{R}}, \textit{id})}}\ {\normalsize \colorbox{light-gray}{\textbf{appendreleaselist}(\texttt{\textbf{R}}, \textit{id})=\texttt{\textbf{R}}}}}}
{qubit\_release\_array \ \textbf{\%Array}^{*}\  \textit{id}}\ {\footnotesize \text{QUARR\_RELEASE}}
\end{math}
}

\caption{The allocation and releasing of a qubit or an array of qubits. \textcolor{red}{More abstract?}}
\label{QIR_AL}
\end{figure}
\fi

\iffalse
\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            q=(id=\textbf{call \%Qubit}^* qubit\_allocate())\ \textbf{appqlist}(\textbf{\texttt{Q}}, q)=\textbf{\texttt{Q}}'
        \end{aligned}}{\textbf{\texttt{Q}} \vdash \textbf{\texttt{Q}},new\_qubit()\Rightarrow \textbf{\texttt{Q}}', q}\ \text{Q\_ALLOC}
    \end{aligned}
\end{equation}
\fi

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            q=qubit\_allocate()\ \textbf{appqlist}(\textbf{\texttt{Q}}, q)=\textbf{\texttt{Q}}'
        \end{aligned}}{\textbf{\texttt{Q}} \vdash \textbf{\texttt{Q}},id=\textbf{call \%Qubit}^* qubit\_allocate()\Rightarrow \textbf{\texttt{Q}}', id\leftarrow q}\ \text{Q\_ALLOC}
    \end{aligned}
    \vspace*{-2mm}
    \label{QALLOC}
\end{equation}

\iffalse
\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            qarray=(id=\textbf{call \%Array}^* qubit\_allocate\_array(n))\ \textbf{appqarrlist}(\textbf{\texttt{QA}}, qarray)=\textbf{\texttt{QA}}'
        \end{aligned}}{\textbf{\texttt{QA}}, n\vdash \textbf{\texttt{QA}}, new\_qubit\_array(n)\Rightarrow \textbf{\texttt{QA}}', n, qarray}\ \text{QARR\_ALLOC}
    \end{aligned}
\end{equation}
\fi

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            qarray=qubit\_allocate\_array(n)\ \textbf{appqarrlist}(\textbf{\texttt{QA}}, qarray)=\textbf{\texttt{QA}}'
        \end{aligned}}{\textbf{\texttt{QA}}, n\vdash \textbf{\texttt{QA}}, id=\textbf{call \%Array}^* qubit\_allocate\_array(n)\Rightarrow \textbf{\texttt{QA}}', n, id\leftarrow qarray}\ \text{QARR\_ALLOC}
    \end{aligned}
    \vspace*{-4mm}
    \label{QARRALLOC}
\end{equation}

\iffalse
\begin{equation}
\footnotesize
\begin{aligned}
    \frac{\begin{aligned}
        &\text{if not}\ qarray=\textbf{findqarr}(\textbf{\texttt{QA}}, q)\ \text{and}\ \textbf{checkq}(\textbf{\texttt{Q}}, q)\ \text{then}\ \textbf{call void}\ qubit\_release(q)\ \textbf{delq}(\textbf{\texttt{Q}},q)=\textbf{\texttt{Q}}'\ \text{else}\ abort
    \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, q \vdash \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, rel\_qubit(q) \Rightarrow \textbf{\texttt{Q}}', \textbf{\texttt{QA}}, q}\ \text{Q\_DEALLOC}
\end{aligned}
\end{equation}
\fi

\begin{equation}
\footnotesize
\begin{aligned}
    \frac{\begin{aligned}
        &\text{if not}\ qarray=\textbf{findqarr}(\textbf{\texttt{QA}}, q)\ \text{and}\ \textbf{checkq}(\textbf{\texttt{Q}}, q)\ \text{then}\ qubit\_release(q)\ \textbf{delq}(\textbf{\texttt{Q}},q)=\textbf{\texttt{Q}}'\ \text{else}\ abort
    \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, q \vdash \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, \textbf{call void}\ qubit\_release(q) \Rightarrow \textbf{\texttt{Q}}', \textbf{\texttt{QA}}, q}\ \text{Q\_DEALLOC}
\end{aligned}
%\vspace*{-6mm}
\label{QDEALLOC}
\end{equation}

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ \textbf{checkqarrlist}(\textbf{\texttt{QA}}, qarray)\ \text{then}\ qubit\_release\_array(qarray)\ \textbf{delqarr}(\textbf{\texttt{QA}},qarray)=\textbf{\texttt{QA}}'\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{QA}}, qarray\vdash \textbf{\texttt{QA}}, \textbf{call void}\ qubit\_release\_array(qarray)\Rightarrow \textbf{\texttt{QA}}', qarray}\ \text{QARR\_DEALLOC}
    \end{aligned}
%    \vspace*{-2mm}
    \label{QARRDEALLOC}
\end{equation}


\begin{comment}
\iffalse
\begin{equation}
\footnotesize
\begin{aligned}
    \frac{\begin{aligned} &\text{if}\ \textbf{isQubit}\ \textit{typ}\ \text{then}\ \textbf{findqarr}(\textbf{\texttt{QA}}, val_2)=qa\ \textbf{checkreleaselist}(\texttt{\textbf{R}}, qa)\ \\
    &\textbf{checkqarray}(qa, val_1) \ \textbf{appqarr}(qa, val_1)\ %val_2\rightarrow val_1
    \end{aligned}}{\textbf{store} \ typ\ val_1\ val_2\ align}{Q\_STORE}
    \label{store}    
\end{aligned}
\end{equation}
\fi

\iffalse
\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ \textbf{checkq}(\textbf{\texttt{Q}}, q)\ \text{or}\ qarray_{temp}=\textbf{findqarr}(\textbf{\texttt{QA}}, q)\ \text{then}\ \textbf{call void}\ gateop\_\_body(option\ d, q)\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q\vdash \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, singlegateop(option\ d, q)\Rightarrow \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q}\ \text{SG\_OP}
    \end{aligned}
\end{equation}
\fi

\iffalse
\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ (\textbf{checkq}(\textbf{\texttt{Q}}, q)\ \ \text{or}\ qarray_{temp}=\textbf{findqarr}(\textbf{\texttt{QA}}, q))\ \text{and}\ \textbf{checkqarr}(\textbf{\texttt{QA}}, qarray)\ \\ &\text{and not}\ \textbf{checkqarrlist}(\textbf{\texttt{QA}}, qarray, q)\ \text{then}\ \textbf{call void}\ gateop\_\_ctl(qarray,(option\ d,q))\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q\vdash\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, controlledgateop(qarray, (option\ d, q))\Rightarrow \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q}\ \text{CG\_OP}
    \end{aligned}
\end{equation}
\fi
\end{comment}




%\textcolor{red}{need description: appqlist, checkqarrlist, appqarr, appqarrlist, checkqarr, checkq, deleteq, deleteqarr, findqarr}

\subsubsection{Manipulating Qubits in Qubit Arrays and Forming Qubit Arrays with Allocated Qubits}

In addition to directly allocating qubits and qubit arrays with the methods of QIR, it is possible to load a single qubit from a qubit array or combine multiple allocated qubits into a new qubit array.  We summarize these two operations in the functions $load\_qubit$ and $create\_qubit\_array$, respectively: 
\\
\\
\begin{math}
\small
    \begin{aligned}
        (id=load\_qubit(qarray, n))=\{&id_1=\textbf{call i}sz^*\ array\_get\_element\_ptr\_1d(qarray, n);\\&id_2=\textbf{bitcast i}sz^*\ id_1\ \textbf{to}\ \textbf{\%Qubit}^{**};\\&id=(id_3=\textbf{load \%Qubit}^*, \textbf{\%Qubit}^{**}\ id_2, align)\}
    \end{aligned}
\end{math}\\
\\
\begin{math}
\small
    \begin{aligned}
        (id=&create\_qubit\_array(q_1, q_2, ...,q_n))=\{\\&id=(id_1=\textbf{call \%Array}^* array\_create\_1d(sz, n));\\
        &\overline{id_{2i}=(\textbf{call i}sz^*\ array\_get\_element\_ptr\_1d(qarray, i));id_{3i}=\textbf{bitcast i}sz^*\ id_{2i}\ \textbf{to}\ \textbf{\%Qubit}^{**};}^{i=1...n}\\
        &\overline{\textbf{store \%Qubit}^*\ q_i, \textbf{\%Qubit}^{**}\ id_{3i}, align;}^{i=1...n}\}
    \end{aligned}
\end{math}\\

In the above two functions, $array\_create\_1d$ and $array\_get\_element\_ptr\_1d$ are instructions in QIR. $array\_create\_1d$ returns an array pointer $\textbf{\%Array}^*$ of size $sz$ with length $n$ by inputting byte size $sz$ of array elements and array length $n$. $array\_get\_element\_ptr\_1d$ can obtain the $\textbf{i}sz^*$ pointer of the corresponding element by inputting the array $qarray$ and indices $n$ of the qubit array. Then through the \textbf{bitcast} instruction of LLVM, it can be converted into a $\textbf{\%Qubit}^{**}$ pointer and the qubit pointer $\textbf{\%Qubit}^{*}$ can be loaded or stored with \textbf{load} or \textbf{store} instruction.

\paragraph{Manipulating qubits in qubit arrays. }The rule \hyperref[QLOAD]{Q\_LOAD} defines the semantics of loading a qubit from the qubit array. Specifically, besides the necessity to check whether the qubit array has been released before executing the loaded operation, it is also needed to record the qubit in the corresponding qubit array of the list \textbf{\texttt{QA}} at the end of the execution (see Figure \ref{fig:QandQAmanagement}).

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ \textbf{checkqarrlist}(\textbf{\texttt{QA}}, qarray)\ \text{then}\ ptr=(id_1=\textbf{call i}sz^* array\_get\_element\_ptr\_1d(qarray, n))\\ 
            &qptr=(id_2=\textbf{bitcast i}sz^*\ ptr\ \textbf{to}\ \textbf{\%Qubit}^{**})\ q=(id_3=\textbf{load}\ \textbf{\%Qubit}^*, \textbf{\%Qubit}^{**}\ qptr, align)\\ 
            &\textbf{appqarr}(\textbf{\texttt{QA}}, qarray, q)=\textbf{\texttt{QA}}'\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{QA}}, qarray,n\vdash \textbf{\texttt{QA}}, id=load\_qubit(qarray,n)\Rightarrow \textbf{\texttt{QA}}', qarray, n, id\leftarrow q}\ \text{Q\_LOAD}
    \end{aligned}
%    \vspace*{-2mm}
    \label{QLOAD}
\end{equation}

\paragraph{Forming qubit arrays with allocated qubits. }The rule \hyperref[QARRCREATE]{QARR\_CREATE} summarizes the semantics of the function that forms an array qubit from allocated qubits. We add the process of checking whether the qubit to be stored already exists in the array (\textbf{checkqarr}) before the store instruction and abort if the qubit already exists in the array. It is because there should not be two identical qubits in the same qubit array, otherwise, there will be \textbf{a risk of qubits cloning}. If this qubit array is used as control qubits, two identical qubits will act as control qubits simultaneously. While it doesn't impact the operation's outcome, it violates the non-cloning principle of quantum computing. Its management for \textbf{\texttt{Q}} and \textbf{\texttt{QA}} is shown in Figure \ref{fig:QandQAmanagement}. Specifically, rule \hyperref[QARRCREATE]{QARR\_CREATE} adds the new array pointer to the \textbf{\texttt{QA}} and adds the qubits that make up the array to the corresponding row.

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ \overline{\textbf{checkq}(\textbf{\texttt{Q}}, q_i)\ \text{or}\ qarray_{temp}=\textbf{findqarr}(\textbf{\texttt{QA}}, q_i)}^{i=1...n}\ \text{then}\\\
            &qarray=(id_1=\textbf{call \%Array}^* array\_create\_1d(sz, n))\ \textbf{appqarrlist}(\textbf{\texttt{QA}}, qarray)\ \\
            &\overline{ptr_i=(id_{2i}=(\textbf{call i}sz^*\ array\_get\_element\_ptr\_1d(qarray, i)))\ qptr_i=(id_{3i}=\textbf{bitcast i}sz^*\ ptr_i\ \textbf{to}\ \textbf{\%Qubit}^{**})}^{i=1...n}\\
            &\overline{\text{if not}\ \textbf{checkqarr}(\textbf{\texttt{QA}}, qarray, q_i)\ \text{then}\ \textbf{store \%Qubit}^*\ q_i, \textbf{\%Qubit}^{**}\ qptr_i, align\ \text{else}\ abort}^{i=1...n}\\
            &\overline{\textbf{appqarr}(\textbf{\texttt{QA}}, qarray, q_i)}^{1=1...n}=\textbf{\texttt{QA}}'\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, (q_1, q_2, ...,q_n) \vdash \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, id=create\_qubit\_array(q_1, q_2, ...,q_n)\Rightarrow \textbf{\texttt{Q}}, \textbf{\texttt{QA}}', (q_1, q_2, ...,q_n), id\leftarrow qarray}\ \text{QARR\_CREATE}
    \end{aligned}
%    \vspace*{-2mm}
    \label{QARRCREATE}
\end{equation}

\subsubsection{Gate Operations}
In QIR, gate operations can be divided into two main categories: single-qubit gate operations and controlled gate operations formed by adding control qubits to single-qubit gate operations. We will formalize the semantics of these two types of gate operations separately. In QIR, the gate operations of qubits do not change in our management model for \textbf{\texttt{Q}} and \textbf{\texttt{QA}} since they do not involve loading and storing of data as well as allocation and release of qubits. The rules \hyperref[SGOP]{SG\_OP} and \hyperref[CGOP]{CG\_OP} show our formalization of the semantics of single-qubit gates as well as controlled gates, respectively, where $gateop\_\_body$ and $gateop\_\_ctl$ are instructions for gate operations in QIR, and $gateop$ is a single-qubit gate such as $x$,$Rx$,$h$.

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ \textbf{checkq}(\textbf{\texttt{Q}}, q)\ \text{or}\ qarray_{temp}=\textbf{findqarr}(\textbf{\texttt{QA}}, q)\ \text{then}\ gateop\_\_body(option\ d, q)\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q\vdash \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, \textbf{call void}\ gateop\_\_body(option\ d, q)\ \Rightarrow \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q}\ \text{SG\_OP}
    \end{aligned}
%    \vspace*{-2mm}
    \label{SGOP}
\end{equation}

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            &\text{if}\ (\textbf{checkq}(\textbf{\texttt{Q}}, q)\ \ \text{or}\ qarray_{temp}=\textbf{findqarr}(\textbf{\texttt{QA}}, q))\ \text{and}\ \textbf{checkqarr}(\textbf{\texttt{QA}}, qarray)\ \\ &\text{and not}\ \textbf{checkqarr}(\textbf{\texttt{QA}}, qarray, q)\ \text{then}\ gateop\_\_ctl(qarray,(option\ d,q))\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q\vdash\textbf{\texttt{Q}}, \textbf{\texttt{QA}}, \textbf{call void}\ gateop\_\_ctl(qarray,(option\ d,q))\Rightarrow \textbf{\texttt{Q}}, \textbf{\texttt{QA}}, option\ d, q}\ \text{CG\_OP}
    \end{aligned}
    %\vspace*{-2mm}
    \label{CGOP}
\end{equation}

\vspace*{3mm}
In QIR, the control qubits are entered into the instruction in the form of a qubit array. So similar to the rule \hyperref[QARRCREATE]{QARR\_CREATE}, for \hyperref[CGOP]{CG\_OP}, we also add a check for whether the target qubit exists in the control qubit array (with \textbf{checkqarr}) to avoid the problem of qubit cloning. 

%\textcolor{red}{Need modify!!!} Use \textbf{call} \textbf{void} @\_\_quantum\_\_rt\_\_... Maybe we can formalize the whole instruction directly? 

\label{GateOperation}


\begin{comment}
\iffalse
Gate operations are divided into two main types, single-qubit gate operations, and controlled gate operations. We can directly provide the semantics of single-qubit gates as follows:

\iffalse
\begin{equation}
\begin{aligned}
    %\Gamma \vdash Q: Qubit, f: float\\
    \frac{\textbf{checkreleaselist}(\texttt{\textbf{R}}, id_j)}
    {\textbf{call void}\ qis\_gateop\_body\  option\ \overline{\textbf{double}\ id_i},\  \textbf{\%Qubit}^*\ id_j }
    \end{aligned}
    \label{sg}
\end{equation}
\fi
\end{comment}

\begin{comment}
    
Specifically, after the execution of the single-qubit gate operation of $sg(\overline{f})$, the state of the qubit pointed by the pointer $Qubit^*$ changes from $Qubit$ to $Qubit\prime$ (the pointer to the qubit does not change). Similarly, the semantics for controlled gates can be defined as: 


\iffalse
\begin{equation}
\begin{aligned}
    %\Gamma \vdash Cq, Tq: Qubit, f: float\\
    \frac{\mathcal{B} \llbracket \overline{Qubit_c^*}^{n} \notin \texttt{\textbf{R}} \rrbracket = tt \quad \mathcal{B} \llbracket Qubit_t^* \notin \texttt{\textbf{R}} \rrbracket = tt}
    {\overline{f}, \overline{Qubit_c^*}^n, Qubit_t^* \vdash cg(\overline{f})\ \overline{Qubit_c^*}^n \ Qubit_t^* \Rightarrow \overline{f}, \overline{Qubit_c^*}^n, Qubit_t\prime^*}
    \end{aligned}
    \label{control_gate_operation}
\end{equation}

\begin{equation}
\begin{aligned}
    %\Gamma \vdash Cq, Tq: Qubit, f: float\\
    \frac{\textbf{checkreleaselist}(\texttt{\textbf{R}}, id_i)\ \textbf{checkreleaselist}(\texttt{\textbf{R}}, id_k)}
    {qis\_gateop\_ctl\ \textbf{\%Array}\ id_i,\ (\textbf{double}\ id_j,\ \textbf{\%Qubit}^*\ id_k)}
    \end{aligned}
    \label{control_gate_operation}
\end{equation}
\fi

\noindent
where $Qubit_c$ denotes the control qubit and $Qubit_t$ denotes the controlled qubit. After the execution of $cg(\overline{f})$, the state of $Qubit_c$ remains unchanged, and the state of $Qubit_t$ changes from $Qubit_t$ to $Qubit_t\prime$. 
\iffalse
In Equation \ref{control_gate_operation}, the control qubits are entered as an $Array$ and the controlled qubit are entered as a single qubit, so here introduces the problem of creating and releasing the control qubit array $\overline{Qubit_c^*}^n$.
\fi
In Equation \ref{control_gate_operation}, the control qubits are input as an array, and the controlled qubit is input as a single qubit. Therefore, before applying the instruction of the controlled gate operation, it is necessary to generate the array of control qubits $\overline{Qubit_c^*}^n$ and release it after the operation on the controlled qubit is finished (without releasing the qubits stored in $\overline{Qubit_c^*}^n$).

\textcolor{red}{Summary the complete controlled gate operation together? }When generating arrays of control qubits, it is first necessary to prepare the containers in which they will be stored, which can be generated in QIR with the function \textit{array\_create\_1d}:

\iffalse
\begin{equation}
\begin{aligned}
    \frac{}
    {n \vdash array\_create\_1d\ \textbf{i}32\ n \Rightarrow \textbf{\%Array}^*\ id}
    \end{aligned}
    \label{array_create_1d}
\end{equation}
\fi

\noindent
\textcolor{red}{delete }where $t_i$ represents the element to be stored, $sz$ represents the maximum size of each element in bytes and $n$ is the length of $Array$. The data type stored in the $Array$ is \textbf{i}$sz$, so it needs to be converted to $Qubit^{**}$ (Equation \ref{bitcast}) by the \texttt{bitcast} instruction of LLVM IR, and then the control qubits are stored in $\overline{Qubit^*}^n$ with the \texttt{store} instruction: 

\iffalse
\begin{equation}
\begin{aligned}
    \frac{\begin{aligned}
        \text{if }\textbf{isQubitptr}\ typ_2\ \text{then} \textbf{append}
    \end{aligned}}{typ_1,val,typ_2\vdash \textbf{bitcast}\ typ_1\ val\ \textbf{to}\ typ_2\Rightarrow typ_2\ id}
    \end{aligned}
    \label{bitcast}
\end{equation}
\fi

\paragraph{Avoiding cloning operations. }In Equation \ref{store}, we added two judgment conditions to modify the semantic of \textbf{store}: 

\iffalse
\begin{equation}
    \begin{aligned}
        \frac{\begin{aligned}
            
        \end{aligned}}{gateop\_ctl( \overline{ctl\_qubits}^n, (\overline{P}, \overline{d}, rgr\_qubits)}
    \end{aligned}
\end{equation}
\fi


When storing qubits, we first determine whether they are released. Then, it should be confirmed whether the qubits already exist in the array. Although QIR allows storing the same qubits in an array, we consider this to be an unsafe operation. This is because the generated $\overline{Qubit^*}^n$ may be input as control qubits in subsequent processing to the instruction of the controlled gate operation, and each qubit in the array will be treated as a different individual, which would violate the \textbf{non-cloning theorem} if there are identical qubits existing. For $Array$s of type $Qubit$, in our formal method, for each $\overline{Qubit^*}^n$ a corresponding list $\mathcal{QA}(\overline{Qubit^*}^n)$ is generated to store the value names of the $Qubit^*$ that have been stored in $\overline{Qubit^*}^n$. 

For the same reason, a safer version of the semantics of the instruction controlling the gate operation is designed, avoiding qubits cloning by including a judgment of whether $Qubit_t^*$ exists in $\overline{Qubit_c^*}^n$: 

\iffalse
\begin{equation}
\begin{aligned}
    %\Gamma \vdash Cq, Tq: Qubit, f: float\\
    \frac{\textbf{checkreleaselist}(\texttt{\textbf{R}}, id_i)\ \textbf{checkqarray}(id_i, id_k) \ \textbf{checkreleaselist}(\texttt{\textbf{R}}, id_k)}
    {qis\_gateop\_ctl\ \textbf{\%Array}\ id_i,\ (\overline{\textbf{double}\ id_j},\ \textbf{\%Qubit}^*\ id_k)}
    \end{aligned}
    \label{cg_update}
\end{equation}
\fi

By Equations \ref{array_create_1d}, \ref{bitcast}, and \ref{store}, we can derive \ref{Qubit_Array_Create} as a summary for the semantic of creating $\overline{Qubit^*}^n$: 

\iffalse
\begin{equation}
\begin{aligned}
&\text{State } s=\{\{Qubit_{0}^*, ... , Qubit_{j}^*\},  sz, n\}\\
&\frac{(\ref{array_create_1d})\quad (\ref{bitcast}) \quad (\ref{store})}{s \vdash Qubit\_Array\_Create\ s \Rightarrow s, \overline{Qubit^*}^{n}} %\quad \text{(1)}
    \label{Qubit_Array_Create}
\end{aligned}
\end{equation}
\fi

It is worth noting that although we also introduced the instruction for creating qubit arrays in Section \ref{Allocate}, it differs from the \texttt{Qubit\_Array\_Create}. The \texttt{qubit\_allocate\_array} creates a qubit array and fills it with newly allocated qubits, while the \texttt{Qubit\_Array\_Create} in this section creates an empty qubit array and then fills it with the declared qubits, hence the difference in formalization.

\textcolor{red}{Maybe do not need this part. }For releasing arrays, it is difficult to formalize them accurately because the parameters \texttt{reference count} and \texttt{alias count} are not defined in detail enough in the QIR specification file for the $Array$ data type. Here we refer to the actual QIR program and apply the instructions \texttt{array\_update\_alias\_} \texttt{count} and \texttt{array\_update\_reference\_count} to release the $Array$:


\iffalse
\begin{equation}
\begin{aligned}
    \text{Statement } S=array\_&update\_alias\_count; array\_update\_reference\_count \\
    &\quad\frac{\mathcal{B} \llbracket \overline{typ}^{n} \notin \texttt{\textbf{R}} \rrbracket = tt}{S\ \overline{typ}^{n} }
    \end{aligned}
    \label{array_release}
\end{equation}

\begin{equation}
    \begin{aligned}
    &\frac{\mathcal{B} \llbracket \overline{typ}^{n} = \emptyset \rrbracket = ff}{S\ \overline{typ}^{n}}
    \end{aligned}
    \label{array_release_null}
\end{equation}
\fi

In QIR, \texttt{array\_update\_alias\_count} and \texttt{array\_update\_reference\_count} are the only instructions that allow null pointers to be input, with the result that the instruction is ignored and therefore the state of $\overline{typ}^{n}$ is not affected, as we show in Equation \ref{array_release_null}. Note that unlike the instruction \texttt{qubit\_release\_array}, Equation \ref{array_release} does not release elements at the same time when it releases $\overline{typ}^{n}$.

Finally, we can complete the formalization of the semantic of the complete controlled gate operations in QIR by combining Equation \ref{Qubit_Array_Create} (generating the control qubits array), \ref{cg_update} (performing the controlled gate operation), and \ref{array_release} (releasing the qubit array): 


\iffalse
\begin{equation}
\begin{aligned}
&\text{State } s=\{\overline{f}, \{Qubit_{c\_0}^*, ... , Qubit_{c\_j}^*\}, Qubit_t^*, sz, n\}\\
&\text{Statement } S_1=Qubit\_Array\_Create\\
&\text{\quad\quad\quad\quad\ } S_2=array\_update\_alias\_count; array\_update\_reference\_count\\
\\
&(a)\quad s \vdash S_1\ s \Rightarrow s, \overline{Qubit_c^*}^{n}\\
&(b)\quad cg(\overline{f})\ \overline{Qubit_c^*}^{n} \ Qubit_t^* \\
&(c)\quad \overline{Qubit_c^*}^{n} \vdash S_2\ \overline{Qubit_c^*}^{n} \Rightarrow \_\overline{Qubit_c^*}^{n}\\
&\quad\quad\quad\quad\frac{(a) \quad (b) \quad (c)}
{Control\_Gate\_Operate \ s} 
\end{aligned}
\label{QIR_Gate_Op}
\end{equation}
\fi

\textcolor{blue}{Done. }
\fi

\end{comment}


\subsubsection{Measurement}
For the measurement operation, the measurement result can be returned in QIR by entering an array of Pauli values and an array of qubits. The semantics of the measurement operation is: 
\iffalse
\begin{equation}
    \frac{\textbf{checkreleaselist}(\texttt{\textbf{R}}, id_2)}
    {id_1,\ id_2 \vdash \textbf{measure}(\textbf{\%Array}^*\ id_1, \textbf{\%Array}^*\ id_2)\ \Rightarrow \textbf{\%Result}^*\ id_3}
    \label{measure}
\end{equation}
\fi

\begin{equation}
\footnotesize
    \begin{aligned}
        \frac{\begin{aligned}
            \text{if}\ \textbf{checkqarr}(\textbf{\texttt{QA}},qarray)\ \text{then}\ result=measure\_\_body(Pauliarr, qarray)\ \text{else}\ abort
        \end{aligned}}{\textbf{\texttt{QA}},Pauliarr, qarray\vdash id=\textbf{call \%Result}^*\ measure\_\_body(Pauliarr, qarray)\Rightarrow \textbf{\texttt{QA}},Pauliarr, qarray, id\leftarrow result}\ \text{MEASURE}
    \end{aligned}
    \vspace*{-2mm}
\end{equation}


%4
\section{Verification on Unsafe Code of QIR}
\label{sec:result}

This section applies our method to verify some insecure QIR codes. Since QIR is still not officially in use, the most prominent way to generate QIR code at present is to use the Q\# compiler provided by Microsoft. This provides us with the inspiration to collect verification samples. If an unsafe Q\# program passes the compiler but fails at runtime, we can generate the corresponding QIR code from it for verification. Figure \ref{fig:Unsafe_qsharp_SAMPLE} shows two samples of unsafe Q\# code referenced from~\cite{qsharpalgo}, where in Figure \ref{fig:Unsafe_qsharp_SAMPLE}a the qubit returned is released at the end of the execution of the function \textit{NewQubit}, and in Figure \ref{fig:Unsafe_qsharp_SAMPLE}b the three qubits called by \textit{CCNOT} are the same qubit, violating the no-cloning theorem. In the next subsections, we will present the corresponding QIR code and apply the semantics we designed to check for faults.

\begin{figure*}[h]
\centering
\subfigbottomskip=2pt
\subfigcapskip=5pt
\subfigure[Return a released qubit.]{%\begin{CodeOut}
$\footnotesize{
\begin{array}{l}
    \texttt{\@EntryPoint()}\\
    \texttt{operation Deadqubit() : Result \{}\\
        \quad\quad\texttt{let q = NewQubit();}\\
        \quad\quad\texttt{H(q);}\\
        \quad\quad\texttt{return M(q);}\\
    \texttt{\}}\\
    \\
    \texttt{operation NewQubit() : Qubit \{}\\
        \quad\quad\texttt{use q = Qubit();}\\
        \quad\quad\texttt{return q;}\\
    \texttt{\} }
\end{array}
    }
    %\end{CodeOut}
$}
\vspace*{-2mm}
\subfigure[Control qubit and target qubit are the same one.]{
$\footnotesize{
\begin{array}{l}
    $\texttt{\@EntryPoint()}$\\
    $\texttt{operation Cloning() : Result \{}$\\
    $\quad\quad\texttt{use q1 = Qubit();}$\\
    $\quad\quad\texttt{let q2 = q1;}$\\
    $\quad\quad\texttt{let q3 = q2;}$\\
    $\quad\quad\texttt{CCNOT(q1, q2, q3);}$\\
    $\quad\quad\texttt{return M(q3);}$\\
    $\texttt{\} }$   
\end{array}    
    }
$}
    \caption{Example of unsafe Q\# codes.}
    \vspace*{-5mm}
    \label{fig:Unsafe_qsharp_SAMPLE}
\end{figure*}

\subsection{Using Deallocated Qubits}
Figure \ref{fig:Released_qubit_QIR} shows the QIR code obtained from the Q\# code conversion from Figure \ref{fig:Unsafe_qsharp_SAMPLE}a. 
%
In this example, for the return value of the function $@NewQubit\_\_body$ in line 3, we can analyze it using the rules \hyperref[QALLOC]{Q\_ALLOC} and \hyperref[QDEALLOC]{Q\_DEALLOC}, so that we can know that the $\%q$ returned has been released (see Figure \ref{fig:QQAexample}a). In the execution of $h\_\_body$ in line 4, the rule \hyperref[SGOP]{SG\_OP} is applied to interrupt the program since $\%q$ does not exist in \textbf{\texttt{Q}}, thus avoiding the error of using the released qubit.

\begin{figure}
    \centering
    \includegraphics[width=0.95\textwidth]{image/QQAexample.pdf}
    \caption{Example of applying the formal method to verify unsafe QIR code.}
%    \vspace*{-5mm}
    \label{fig:QQAexample}
\end{figure}

%Lines 1 through 5 of the code return a pointer to the $Result$ after the execution of the \texttt{Deadqubit} function. We can derive the semantics of \texttt{Deadqubit} as follows: 

\iffalse
\begin{equation}
    \begin{aligned}
    \text{Statement } &S_1=\{\textit{\textbf{q}}=\texttt{\textbf{call}}\ Qubit^*\ NewQubit\}\\
    &S_2=\{\textit{\textbf{0}} = \texttt{\textbf{call}}\ Result*\ M\ Qubit^*\ \textit{\textbf{q}}\}\\
        &S_3=\{\texttt{\textbf{ret}}\ Result^*\ \textit{\textbf{0}}\}\\
        &\frac{\vdash S_1; S_2; S_3 \Rightarrow \textit{\textbf{0}}}{\vdash Deadqubit \Rightarrow \textit{\textbf{0}}}
    \end{aligned}
    \label{deadqubit}
\end{equation}
\fi

%To avoid confusion, the names of the values in this section will be bolded and italicized (e.g., \textit{\textbf{q}} and \textit{\textbf{0}}), while the values indicating constants will remain unchanged. Since $S_1$, $S_2$, and $S_3$ are executed sequentially in Equation \ref{deadqubit}, we first analyze the semantics of $S_1$. The semantics of \texttt{NewQubit} (Equation \ref{NewQubitbody}) can be obtained from Figure \ref{QIR_AL}, which leads to the semantics of $S_1$: assigning a pointer of a released $Qubit$ to \textit{\textbf{q}} (Equation \ref{S1}).

\iffalse
\begin{equation}
    \begin{aligned}
        \frac{ \vdash qubit\_allocate \Rightarrow Qubit^*\quad Qubit^* \vdash qubit\_release \Rightarrow \_Qubit^*}{ \vdash qubit\_allocate; qubit\_release \Rightarrow \_Qubit^*}\\
        \hline{ \vdash NewQubit \Rightarrow  \_Qubit^*\quad\quad\quad\quad\quad\quad\quad\quad\quad}
    \end{aligned}
    \label{NewQubitbody}
\end{equation}

\begin{equation}
    \begin{aligned}
         \vdash \textit{\textbf{q}}=\texttt{\textbf{call}}\ Qubit^*\ NewQubit \Rightarrow \textit{\textbf{\_q}}
    \end{aligned}
    \label{S1}
\end{equation}
\fi

%In $S_2$, the measurement of \textit{\textbf{\_q}} needs to be performed using \texttt{Instruminsic\_M}. Although we have not shown the complete semantics of \texttt{Instruminsic\_M}, it is known from the excerpted part of the code that the $Qubit^*$ array needs to be created first during the execution of $S_2$. Here we introduce Equation \ref{store}, and substituting \textit{\textbf{\_q}} and the empty $\overline{Qubit^*}^1$ (assuming it has been generated correctly), we can obtain Equation \ref{nullstore}: 

\iffalse
\begin{equation}
    \frac{{\color{red} \mathcal{B} \llbracket \textit{\textbf{\_q}} \notin \texttt{\textbf{R}} \rrbracket = ff}}{\textit{\textbf{\_q}}, \overline{Qubit^*}^1[0] \vdash \textbf{\texttt{store}} \ \textit{\textbf{\_q}}\ \overline{Qubit^*}^1[0] \Rightarrow } 
    \label{nullstore}
\end{equation}
\fi

%Based on the above equation, we can determine that the instruction of store cannot be executed because $\mathcal{B} \llbracket \textit{\textbf{\_q}} \notin \texttt{\textbf{R}} \rrbracket = ff$. Based on the semantics, the program should throw a runtime failure in the execution of the $S_2$ statement (there is no terminal state in Equation \ref{nullstore}).

\begin{figure}[h]
%\begin{figure*}[h]
\begin{center}
\begin{CodeOut}
\scriptsize{
\begin{alltt}
\quad \quad \quad 1   define internal \%Result* @Deadqubit__body() \{
\quad \quad \quad 2   entry:
\quad \quad \quad 3     \%q = call \%Qubit* @NewQubit__body()
\quad \quad \quad 4     call void @__quantum__qis__h__body(\%Qubit* \%q)
\quad \quad \quad 5     \%0 = call \%Result* @Microsoft__Quantum__Intrinsic__M__body(\%Qubit* \%q)
\quad \quad \quad 6     ret \%Result* \%0
\quad \quad \quad 7   \}
\quad \quad \quad 8
\quad \quad \quad 9   define internal \%Qubit* @NewQubit__body() \{
\quad \quad \quad 10   entry:
\quad \quad \quad 11    \%q = call \%Qubit* @__quantum__rt__qubit_allocate()
\quad \quad \quad 12    call void @__quantum__rt__qubit_release(\%Qubit* \%q)
\quad \quad \quad 13    ret \%Qubit* \%q
\quad \quad \quad 14  \} 
\quad \quad \quad     ...
\end{alltt}
    }
    \end{CodeOut}
    \caption{QIR code converted from Figure \ref{fig:Unsafe_qsharp_SAMPLE}a. To save space, we have only intercepted the minimum critical code.}
    \label{fig:Released_qubit_QIR}
%\vspace*{-4mm}
\end{center}
\end{figure}


\subsection{Qubit Cloning}

Figure \ref{fig:Cloning_qubit_QIR} shows the QIR code obtained from the code conversion of the cloned quantum in Figure \ref{fig:Unsafe_qsharp_SAMPLE}b. 
%
In the example, for the function, $CCNOT\_\_body$ in line 4, two identical $\textbf{Qubit}^*$ $\%q1$ are entered as control qubits, and $\%q1$ itself as the target qubit. Thus for lines 12 to 18 of the code, the rule \hyperref[QARRCREATE]{QARR\_CREATE} can be applied, thus interrupting the program in line 18 due to the transfer to the array $\%\_\_controlQubits\_\_$ stores the same $\textbf{Qubit}^*$ $\%q1$ and avoiding the qubit cloning problem (see Figure \ref{fig:QQAexample}b). Other than that, for line 20 of the code, the rule \hyperref[CGOP]{CG\_OP} can be applied, and since $\%q1$, which is the target qubit, is the same as the element in the control qubit array, qubit cloning can be avoided in this step as well.

%The crux of the problem lies in the statement in line 4 of the code, where the code calls the function \texttt{CCNOT} and passes the same $Qubit$ pointer to it, So we can directly apply the complete semantics of the controlled gate operation \ref{QIR_Gate_Op} and obtain: 

\iffalse
\begin{equation}
    \begin{aligned}
    &\text{State }s=\{\overline{f}=[], \{\textbf{\textit{q1}}, \textbf{\textit{q1}}\}, \textbf{\textit{q1}}, sz, n=2\}\\
    &\text{Statement } S_1=Qubit\_Array\_Create\\
    &\text{\quad\quad\quad\quad\ } S_2=array\_update\_alias\_count; array\_update\_reference\_count\\
    \\
    &(a)\quad s \vdash S_1\ s \Rightarrow s, \overline{Qubit_c^*}^{2}\\
    &(b)\quad s, \overline{Qubit_c^*}^{2} \vdash cg(\overline{f})\ \overline{Qubit_c^*}^{2} \ \textbf{\textit{q1}} \Rightarrow s[\textbf{\textit{q1}} \mapsto \textbf{\textit{q1}}\prime], \overline{Qubit_c^*}^{2}\\
    &(c)\quad \overline{Qubit_c^*}^{2} \vdash S_2\ \overline{Qubit_c^*}^{2} \Rightarrow \_\overline{Qubit_c^*}^{2}\\
    &\quad\quad\quad\quad\quad\quad\quad\quad\frac{(a)\quad(b)\quad(c)}{s \vdash CCNOT\ s \Rightarrow s[\textbf{\textit{q1}} \mapsto \textbf{\textit{q1}}\prime], \_\overline{Qubit^*_c}^2}
    \end{aligned}
    \label{cloning16}
\end{equation}
\fi

%If the derivations of Equation \ref{cloning16}(a) are continued, the following problematic sub-derivation tree can be derived: 

\iffalse
\begin{equation}
    \frac{\mathcal{B} \llbracket \textbf{\textit{q1}} \notin \texttt{\textbf{R}} \rrbracket = tt \quad {\color{red} \mathcal{B}\llbracket \textbf{\textit{q1}} \notin \mathcal{QA}(\overline{Qubit_c^*}^{2})\rrbracket=ff}}
    {\textbf{\textit{q1}}, \overline{Qubit_c^*}^2[1] \vdash \textbf{\texttt{store}} \ \textbf{\textit{q1}}\ \overline{Qubit_c^*}^2[1] \Rightarrow}% \overline{Qubit_c^*}^2[1]} 
    \label{cloning17}
\end{equation}
\fi

%Specifically, the first execution of the \texttt{store} instruction can be executed properly (line 17). However, when the second \texttt{store} instruction is executed (line 18), the program throws a runtime failure because $Qubit^*$ \textbf{\textit{q1}} already exists in the $\overline{Qubit_c^*}^2$, and thus $\mathcal{B}\llbracket \textbf{\textit{q1}} \notin \mathcal{QA}(\overline{Qubit_c^*}^{2})\rrbracket=ff$.

%Assuming Equation \ref{cloning16}(a) passes, for Equation \ref{cloning16}(b), a new error occurs: 

\iffalse
\begin{equation}
\begin{aligned}
    %\Gamma \vdash Cq, Tq: Qubit, f: float\\
    \frac{\mathcal{B} \llbracket \overline{Qubit_c^*}^{2} \notin \texttt{\textbf{R}} \rrbracket = tt \quad {\color{red} \mathcal{B} \llbracket \textbf{\textit{q1}} \notin \mathcal{QA}(\overline{Qubit_c^*}^{2}) \rrbracket = ff} \quad \mathcal{B} \llbracket \textbf{\textit{q1}} \notin \texttt{\textbf{R}} \rrbracket = tt}
    {[], \overline{Qubit_c^*}^{2}, \textbf{\textit{q1}} \vdash CCNOT\ \overline{Qubit_c^*}^{2} \ \textbf{\textit{q1}} \Rightarrow }%{[], \overline{Qubit_c^*}^2, \textbf{\textit{q1}}\prime^*}
    \end{aligned}
    \label{cloning18}
\end{equation}
\fi

%When executing the \texttt{CCNOT} instruction (line 20), the program throws a runtime failure because \textbf{\textit{q1}} has been deposited into $\overline{Qubit_c^*}^{2}$ in the previous operation, so $\mathcal{B} \llbracket \textbf{\textit{q1}} \notin \mathcal{QA}(\overline{Qubit_c^*}^{2}) \rrbracket = ff$.


\begin{figure}
    \centering
    \begin{CodeOut}
    \scriptsize{
        \begin{alltt}
1   define internal \%Result* @Cloning__body() \{
2   entry:
3     \%q1 = call \%Qubit* @__quantum__rt__qubit_allocate()
4     call void @Microsoft__Quantum__Intrinsic__CCNOT__body(\%Qubit* \%q1, \%Qubit* \%q1, 
                                                            \%Qubit* \%q1)
    ...
8   \}
9   
10  define internal void @Microsoft__Quantum__Intrinsic__CCNOT__body(\%Qubit* \%control1, 
                                                \%Qubit* \%control2, \%Qubit* \%target) \{
11  entry:
12    \%__controlQubits__ = call \%Array* @__quantum__rt__array_create_1d(i32 8, i64 2)
13    \%0 = call i8* @__quantum__rt__array_get_element_ptr_1d(\%Array* \%__controlQubits__, i64 0)
14    \%1 = bitcast i8* \%0 to \%Qubit**
15    \%2 = call i8* @__quantum__rt__array_get_element_ptr_1d(\%Array* \%__controlQubits__, i64 1)
16    \%3 = bitcast i8* \%2 to \%Qubit**
17    store \%Qubit* \%control1, \%Qubit** \%1, align 8
18    store \%Qubit* \%control2, \%Qubit** \%3, align 8
19    call void @__quantum__rt__array_update_alias_count(\%Array* \%__controlQubits__, i32 1)
20    call void @__quantum__qis__x__ctl(\%Array* \%__controlQubits__, \%Qubit* \%target)
    ...  
24  \}   
        \end{alltt}
        }
    \end{CodeOut}
    \vspace*{-5mm}
    \caption{QIR code converted from Figure \ref{fig:Unsafe_qsharp_SAMPLE}a. To save space, we have only intercepted the minimum critical code.}
    \label{fig:Cloning_qubit_QIR}
    \vspace*{-2mm}
\end{figure}


%5
\section{Related Work}
\label{sec:related-work}
This section discusses some related work in the areas of intermediate representations for both classical and quantum programming languages.

\subsection{LLVM IR Semantics}
As the basis of QIR, the formal approach of LLVM IR is an important reference for our work. Zhao {\it et al.}~\cite{vellvm} propose the Vellvm (verified LLVM) framework, which provides a formalization of the static semantics, memory model, and several operational semantics of LLVM IR. The framework is implemented using Coq, through which verified executable code with high confidence can be extracted directly, and the effectiveness of Vellvm was verified with the SoftBound~\cite{softbound} case. Li and Gunter~\cite{k-llvm} design K-LLVM, the complete formal LLVM IR semantics, including all LLVM IR instructions, intrinsic functions in the LLVM documentation, etc. Compared to Vellvm, which focuses on formalizing LLVM semantics as a mathematical object, K-LLVM shows possible implementations of the semantics in a virtual computer with a more direct approach. K-LLVM is implemented by $\mathbb{K}$~\cite{K}, and its validity is verified by testing against unit test programs as well as actual LLVM IR programs. However, the above work is directed toward formalizing LLVM IR and does not address quantum programming languages or intermediate representations.

\subsection{Formalized Quantum Intermediate Representation and Programming Language}

As the most relevant work to us, Hietala {\it et al.}~\cite{SQIR} present VOQC, a verified optimizer for quantum circuits. As the input to VOQC, a small quantum intermediate representation (SQIR) was developed to represent quantum circuits and support the verification of quantum circuit optimization. SQIR is well formalized, and its syntax and semantics for quantum circuits can guarantee the correctness of VOQC optimization. Our work differs from SQIR in two main ways: first, the formal object, which is QIR developed by Microsoft, and its application scenario is to provide a general solution for quantum programming languages and back-end hardware. SQIR, on the other hand, is an independently developed quantum intermediate representation, which is mainly applied to the verification process of VOQC. The second is the difference in purpose. In our work, the main goal of the formalization of QIR is to provide guarantees for the correctness of quantum programs and the behavior of QIR, while SQIR focuses on the assurance of correctness for quantum circuit optimization. 

In terms of formalizations of quantum programming languages, Singhal {\it et al.}~\cite{qsharpalgo} present $\lambda_{Q\#}$, an idealized version of Q\#. Based on Staton's work~\cite{staton}, they provide a syntactic and semantic formalization of $\lambda_{Q\#}$ that enables it to ensure quantum no-cloning theorem and to provide stacked-like management of qubits. By converting from Q\# to $\lambda_{Q\#}$, additional safety guarantees can be provided for Q\# code. For the Quipper~\cite{green2013quipper} programming language, Mahmoud and Felty~\cite{quipperformal} present Proto-Quipper, which contains the core functionality of Quipper and extends Quipper's system based on the linear specification logic (SL). They also implemented a formalization of Proto-Quipper via Hybird~\cite{hibird}, encoded the complete Proto-Quipper specification, and proved the correctness of its type system. While these works can serve as valuable references for our research, it is critical to recognize significant differences between our work and theirs; our research centers on quantum intermediate representations rather than quantum programming languages.

%6
\section{Concluding Remarks}
\label{sec:conclusion}

In this paper, we have formalized the core functionality of QIR, particularly its abstract syntax and the semantics of its several runtime functions. Our formalization ensures that QIR programs follow the quantum non-cloning theorem and avoid calls to released qubits and arrays. Based on the analysis of real QIR code, we also demonstrated the effectiveness of our formalization in capturing unsafe code in programs.

%We have formalized the core functionality of QIR, specifically its abstract syntax and the semantics of several of its runtime functions. Our formalization ensures that the QIR program follows the quantum no-cloning theorem and avoids calls to released qubits and arrays. The effectiveness of our formalism in capturing unsafe code in programs is also demonstrated by analyzing it based on real QIR code. 

Our current work is only an initial attempt to formalize the specification of QIR, and more work is needed to refine it. The QIR functions that have been formalized so far are only a small part. More functions need to be formalized, such as $Tuple$ and $String$ in the data type, the semantics of the complete measurement process, and performing batched gate operations on qubits array. From a practical perspective, to apply our formal method directly to the QIR programs for automatic verification (rather than through human analysis as in this work), we need to implement our formal approach with formal interactive theorem checkers such as Coq~\cite{Coq:manual} in further work.

\nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
