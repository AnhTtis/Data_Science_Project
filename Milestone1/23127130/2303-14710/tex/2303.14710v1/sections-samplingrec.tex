\section{Recursive sampling algorithm}\label{sec:sampling:rec}

In this section we describe a uniform random sampler of DOAGs based on the
recursive decomposition given in the previous section.
Our algorithm is based on the so-called ``recursive method'' from~\cite{NW1978}
in the way we select the parameters of the sub-structures.
However, unlike what we would expect in the systematised framework
from~\cite{FZV1994}, the substructures are not independent.
Once the sub-DOAG~$D'$ accounted for by~$D_{n - 1, m - p, k - 1 + p - i}$ has
been selected, the set~$I$ and the injective function~$f: I \to \llbracket 1;
|I| + s \rrbracket$ accounted for by~$\binom{n - k - p + i}{i} \binom{p}{i}
i{!}$ cannot be sampled independently from~$D'$.

Our random sampler is given in Algorithm~\ref{algo:sample:DOAG}.
We first give a high-level description of the algorithm here for the sake of
readability.
Implementation considerations are discussed below, and in particular in
Algorithm~\ref{algo:sample:source} we give a fast algorithm for the generation
of the outgoing edges of the new source at each step of the global random
sampling procedure.

\begin{algorithm}[htb]
  \caption{Recursive uniform sampler of DOAGs}%
  \label{algo:sample:DOAG}

  \begin{algorithmic}[1]
    \Require{Three integers~$(n, m, k)$ such that~$D_{n,m,k} > 0$}
    \Ensure{A uniform random DOAG with~$n$ vertices (including $k$ sources)
    and~$m$ edges}
    \Function{UnifDOAG}{$n, m, k$}
      \If{$n = 1$}
        {generate the (unique) DOAG with~$1$ vertices}
      \Else{}
        \State{\textbf{pick}~$(p, i)$ with probability
          $\displaystyle {D_{n-1, m-p, k-1+p-i} \binom{n-k-p+i}{i} \binom{p}{i}
          i{!}} / {D_{n, m, k}}$}%
          \label{algo:line:pick}
        \State{$D' \gets \text{\Call{UnifDOAG}{$n-1, m-p, k-1+p-i$}}$}%
        \label{algo:line:nsrc:begin}
        \State{$I \gets$ a uniform subset of size~$i$ of the inner vertices
          of~$D'$}
        \State{$I' \gets$ a uniform permutation of~$I$}
        \State{$E \gets$ a uniform shuffling of~$I'$ with the~$s = p - i$
          largest sources of~$D'$}\label{algo:line:nsrc:end}
        \return{the DOAG obtained by adding a new source to~$D'$ with~$E$ as its
        list of outgoing edges}
      \EndIf{}
    \EndFunction{}
  \end{algorithmic}
\end{algorithm}

The~\textbf{pick} instruction at line~\ref{algo:line:pick} implements the
``recursive method'' scheme: pick the parameters of the sub-structures using the
pre-computed counting information.
The standard way to implement this is to draw a uniform random integer~$r$ from
the interval~$[0; D_{n, m, k} - 1]$ and then start to compute the sum of general
term terms~$D_{n-1, m-p, k-1+p-i} \binom{n-k-p+i}{i} \binom{p}{i} i{!}$ (in any
order independent of~$r$) until the sum is greater than~$r$.
The indices~$p$ and~$i$ of the last term of the sum are the ones to pick.
Independently of the summation order, this procedure has complexity~$O(n^2)$ in
the worst case in terms of multiplications of big integers.
An interesting order of summation is the one where the pairs~$(p, i)$ are taken
in lexicographic order.
In this case the complexity of the~\textbf{pick} function can be expressed in
terms of the result of the drawing as~$O(p^2)$, which is more informative about
the cost of sampling the whole DOAG since~$p$ is the \emph{out-degree} of the
new source.
We consider that this order is used here.

Once we have sampled the sub-DOAG~$D'$, sampling~$I$ is straightforward and the
injective function~$f$ is obtained as a permutation of~$I$ (thus deciding of the
order of the elements of~$I$ as children of the new vertex) shuffled with the
largest~$(p-i)$ sources of~$D'$.
The correctness and complexity of this procedure in terms of integer
multiplications are stated in Theorem~\ref{thm:sample:cost}.

\begin{theorem}\label{thm:sample:cost}
  Algorithm~\ref{algo:sample:DOAG} computes a uniform random DOAG with~$n$
  vertices (among which~$k$ are sources) and~$m$ edges by
  performing~$O\left(\sum_{v} d_v^2 \right)$ multiplications where~$v$ ranges
  over the vertices of the resulting graph and $d_v$ is the out-degree of~$v$.
\end{theorem}

\begin{proof}
  The complexity result is a straightforward consequence of the above
  discussion.
  Uniformity is proved by induction.
  Let~$D$ be a DOAG of parameters~$(n, m, k)$ and let~$(D', s, I, f)$ denote the
  result of one decomposition step of~$D$.
  Then the probability that~$D$ is returned by~$\funname{UnifDOAG}(n, m, k)$ is
  \begin{equation*}
    \PP[D] = \PP[(p, i)] \cdot \PP[D' | p, i] \cdot \PP[I|D', i] \cdot \PP[f|I,
    p, i]
  \end{equation*}
  where, by induction we have~$\PP[D'|p, i] = 1 / D_{n-1,m-p,k-1+p-i}$ and by
  definition:
  \begin{align*}
    \PP[(p,i)]     &= D_{n-1, m-p, k-1+p-i} \binom{n-k-p+i}{i} \binom{p}{i} i{!}
                      / D_{n, m, k} \\
    \PP[I|D', i]   &= {\binom{n-k-p+i}{i}}^{-1} \\
    \PP[f|I, p, i] &= {\left(i! \binom{p}{i}\right)}^{-1}.
  \end{align*}
  In the end, we get that~$\PP[D'] = 1 / D_{n,m,k}$.
\end{proof}

Note that the sum~$\sum_v d_v^2$ is of the order of~$m^2$ in the worst case but
can be significantly smaller if the out-degrees of the vertices are evenly
distributed.
In the best case we have~$d_v \sim \frac{m}{n}$ for most of the vertices and as
a consequence~$\sum_v d_v^2 \sim {m^2} / {n}$.

We have decomposed the generation of the new source into several steps in
Algorithm~\ref{algo:sample:DOAG} (lines~\ref{algo:line:nsrc:begin}
to~\ref{algo:line:nsrc:end}) to make the role of each term in the counting
formula apparent, and help stating the uniformity.
However there is a faster way to implement this part of the Algorithm by
sampling~$I$ and its ordering \emph{together} using a variant of the well-known
Fisher{--}Yates algorithm (see~\cite{FY1948}) using the property that the
first~$i$ terms of a uniform permutation form a uniform ordered subset of
size~$i$ of its elements.
This is described in Algorithm~\ref{algo:sample:source} which can substitute
lines~\ref{algo:line:nsrc:begin} to~\ref{algo:line:nsrc:end} in
Algorithm~\ref{algo:sample:DOAG} in a practical implementation.

\begin{algorithm}[htb]
  \caption{Optimised uniform sampler of new sources with given parameters}%
  \label{algo:sample:source}
  \begin{algorithmic}
    \Require{Two non-negative integers~$i$ and~$s$, an array~$S$ of
      length~$\ell_S \geq s$ vertices playing the role of sources and an
      array~$T$ of length~$\ell_T \geq i$ vertices playing the role of internal
      vertices.}
    \Ensure{An array~$v$ of~$i + s$ vertices, representing a new vertex with~$s$
      out-edges to the~$s$ last elements of~$S$ (appearing in the same order as
      in~$S$) and~$i$ edges to elements of~$T$, chosen uniformly at random.}
  \end{algorithmic}
  \begin{algorithmic}[1]
    \assign{$i'$}{$i$}
    \assign{$s'$}{$s$}
    \assign{$v$}{new array of length~$(i + s)$}
    \For{$j = 0$ \textbf{to} $i - 1$}\label{algo:line:fy}
      \State{$r \gets \text{\Call{Unif}{$\llbracket j; \ell_T - 1 \rrbracket$}}$}
      \State{$T[j] \leftrightarrow T[r]$}
    \EndFor{}
    \While{$i' + s' > 0$}\label{algo:line:shuffle}
      \If{\Call{Bern}{$i' / (i' + s')$}}
        \State{$v[i' + s' - 1] \gets T[i' - 1]$}
        \State{$i' \gets i' - 1$}
      \Else{}
        \State{$v[i' + s' - 1] \gets S[\ell_S - s + s' - 1]$}
        \State{$s' \gets s' - 1$}
      \EndIf{}
    \EndWhile{}
  \end{algorithmic}
\end{algorithm}

The first loop of Algorithm~\ref{algo:sample:source} (at
line~\ref{algo:line:fy}) implements the Fisher{--}Yates algorithm with an early
exit after~$i$ iterations rather than~$\ell_T$.
After this, the first~$i$ elements of~$T$ represent the set~$I$ and their
ordering is uniform.
The second loop (at line~\ref{algo:line:shuffle}) implements the shuffling
of~$I$ with the last~$s$ elements of~$S$.
We populate the array~$v$ in reverse order so as to ensure that the elements
coming from~$S$ remain sorted.

This algorithm achieves linear complexity in~$p = (i + s)$ in terms of memory
accesses and number of calls to the random number generator, but needs to
modify~$T$ in place.
Since~$T$ represents the internal vertices of a DOAG, this means that we must
choose a data structure for DOAGs that is not sensitive to the order of its
internal vertices.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1]{images-datastructure}
  \caption{The memory layout used for storing DOAGs during the generation.
  The labels on the vertices of the DOAG on the left correspond to the order in
  which they are consumed by the decomposition.
  Each vertex on the left corresponds to a cell of the main array on the right.
  Each cell (except for the last one) has a pointer to an array of vertices
  representing its outgoing edges (here represented as integers for readability
  but stored as pointers in practice).
  For instance the cell labelled~$1$ has three outgoing edges to the vertices
  labelled~$7$,~$8$ and~$4$.}%
  \label{fig:doag:memlayout}
\end{figure}

The idea is to represent a DOAG with~$n$ vertices and~$k$ sources as an array of
vertices where the first~$k$ elements are the sources, sorted in increasing
order, and the other~$n-k$ elements are the internal nodes stored in an
unspecified order.
Vertices are represented as \emph{pointers} to arrays of vertices, the order of
the elements encodes the order of the edges.
One can then allocate a single array of size~$n$ before the first call to the
sampler and populate it from right to left in the recursive calls.
The invariant is that, after each recursive call of the
form~$\funname{UnifDOAG}(n', m', k')$, the~$n'$ last elements of the array
represent its resulting DOAG~$D'$ of size~$n'$.
Algorithm~\ref{algo:sample:source} is then used by taking the~$n' - k'$ last
elements of the array as~$T$ and the~$k'$ elements preceding them as~$S$,
without making any copy.
Finally the newly generated source is stored at index~$n - n'$, just before
the~$n'$ vertices representing~$D'$.
The advantage of this memory layout is that after this point, the~$s$ former
sources that have been turned into internal nodes are already at the right
place.
The memory representation discussed above is pictured in
Figure~\ref{fig:doag:memlayout}.

\paragraph*{A remark on constrained out-degrees}

Consider a set of allowed degrees~$\mathcal P$ for the vertices.
If the sequence~$D_{n,m,k}^{\mathcal P}$ from
equation~\eqref{eq:recurrence:general} in Section~\ref{sec:subclasses} is used
in place of~$D_{n,m,k}$ in the algorithm, and without any further change, we
obtain a uniform random sampler of DOAGs whose vertices have their out-degree
in~$\mathcal P$.
The fact that only the sequence has to be changed and not the rest of the
algorithm reflects the generality of the recursive method.
A large DOAG of out-degree bounded by~$10$, sampled using this algorithm, is
shown in Figure~\ref{fig:bdoag} on page~\pageref{fig:bdoag}.
