\section{MPC and Pipeline}
In this section, we describe our~\gls{mpc} formulation for selecting footstep placements and contact surfaces (\sref{sec:topology_based_mpc}).
Then, we present the control pipeline and setup used in our experiments with the ANYmal robot (\sref{sec:control_pipeline_and_experimental_setup}).

\subsection{Topology-Based MPC}\label{sec:topology_based_mpc}
Building upon our previous work~\cite{mastalli-underreview22}, our~\gls{mpc} solves a hybrid optimal control problem at each control time step.
The different modes of hybrid dynamics define different contact conditions along the optimization horizon.
These rigid contact conditions are subject to the robot's full-body dynamics (i.e., \textit{contact dynamics}).
We also model the contact-gain transitions between these modes using the \textit{impulse dynamics}.
Our~\textsc{Box-FDDP} solver~\cite{mastalli22auro} then computes full-body motions, torque commands, and feedback policies while keeping within the robot's joint torque limits, given a predefined set of footstep placements.

Here, our contact-surface penalty function extends the capabilities of our previous~\gls{mpc} by enabling it to automatically plan footstep placements and contact surfaces, given a reference velocity and a set of candidate contact surfaces.
In~\eref{eq:oc_problem}, the modifications introduced in this work are highlighted in \textcolor{blue}{blue}.

\begin{equation}\label{eq:oc_problem}
\resizebox{\columnwidth}{!}{$
\begin{aligned}
\min_{\mathbf{x}_s,\mathbf{u}_s}
&\hspace{-2.em}
& & \hspace{-0.75em}\sum_{k=0}^{N-1} \left(\ell^{reg}_k+\textcolor{blue}{ w_r\|\mathbf{\dot{r}}_k-\mathbf{\dot{r}}^{ref}\|^2 + w_f\sum_{\mathcal{C}_k}\ell_{\boldsymbol{\mathbf{p}}_{\mathcal{C}_k}}}\right) \hspace{-8.em}&\\
& \hspace{-1.5em}\textrm{s.t.} & &\hspace{-1em}\text{if $k$ is a contact-gain transition:}\\
& & & \mathbf{q}_{k+1} = \mathbf{q}_{k},\\
& & & \left[\begin{matrix}\mathbf{v}_{k+1} \\ -\boldsymbol{\Lambda}_{\mathcal{C}_k}\end{matrix}\right] =
\left[\begin{matrix}\mathbf{M}_k & \mathbf{J}^{\top}_{\mathcal{C}_k} \\ {\mathbf{J}_{\mathcal{C}_k}} & \mathbf{0} \end{matrix}\right]^{-1}
\left[\begin{matrix}\boldsymbol{\tau}^\mathcal{I}_{b_k} \\ -\mathbf{a}^\mathcal{I}_{\mathcal{C}_k} \\\end{matrix}\right], \hspace{-1em}&\textrm{(impulse dyn.)}\\
& & & \hspace{-1em}\textrm{else:}\\
& & & \mathbf{q}_{k+1} = \mathbf{q}_k \oplus \int_{t_k}^{t_k+\Delta t_k}\hspace{-2em}\mathbf{v}_{k+1}\,dt, &\\
& & & \mathbf{v}_{k+1} = \mathbf{v}_k + \int_{t_k}^{t_k+\Delta t_k}\hspace{-2em}\mathbf{\dot{v}}_k\,dt, &\textrm{(integrator)}\\
& & & \left[\begin{matrix}\mathbf{\dot{v}}_k \\ -\boldsymbol{\lambda}_{\mathcal{C}_k}\end{matrix}\right] =
\left[\begin{matrix}\mathbf{M}_k & \mathbf{J}^{\top}_{\mathcal{C}_k} \\ {\mathbf{J}_{\mathcal{C}_k}} & \mathbf{0} \end{matrix}\right]^{-1}
\left[\begin{matrix}\boldsymbol{\tau}^\mathcal{C}_{b_k} \\ -\mathbf{a}^\mathcal{C}_{\mathcal{C}_k} \\\end{matrix}\right], \hspace{-1em}&\textrm{(contact dyn.)}\\
  & & & \hspace{-1em}\textcolor{blue}{\log{({}^\mathcal{W}\mathbf{p}_{\mathcal{G}_k, z}^{-1}\cdot {}^\mathcal{W}\mathbf{p}^{ref}_{{\mathcal{G}_k, z}})} = \mathbf{0}}, &\textcolor{blue}{\textrm{(vertical foot pos.)}}\\
& & & \hspace{-1em}\textcolor{blue}{{}^\mathcal{W}\mathbf{\dot{p}}_{\mathcal{G}_k, z}^{-1}- {}^\mathcal{W}\mathbf{\dot{p}}^{ref}_{{\mathcal{G}_k, z}} = \mathbf{0}}, &\textcolor{blue}{\textrm{(vertical foot vel.)}}\\
% & & & \hspace{-1em}\log{({}^\mathcal{W}\mathbf{p}_{\mathcal{G}_k}^{-1}\cdot {}^\mathcal{W}\mathbf{p}^{ref}_{{\mathcal{G}_k}})} = \mathbf{0}, &\textrm{(contact pos.)}\\
% & & & \hspace{-1em}{}^\mathcal{W}\mathbf{\dot{p}}_{\mathcal{G}_k}^{-1}- {}^\mathcal{W}\mathbf{\dot{p}}^{ref}_{{\mathcal{G}_k}} = \mathbf{0}, &\textrm{(contact velocity)}\\
& & & \hspace{-1em}\textcolor{blue}{\mathbf{A}{}^\mathcal{W}\mathbf{p}^{ref}_{\mathcal{G}_k, z} = \mathbf{a}}, &\textcolor{blue}{\textrm{(contact surface height)}}\\
& & & \hspace{-1em}\mathbf{C}\boldsymbol{\lambda}_{\mathcal{C}_k} \geq \mathbf{c}, &\textrm{(friction-cone)}\\
& & & \hspace{-1em}\mathbf{\underline{x}} \leq \mathbf{x}_k \leq \mathbf{\bar{x}}, &\textrm{(state bounds)}\\
& & & \hspace{-1em}\mathbf{\underline{u}} \leq \mathbf{u}_k \leq \mathbf{\bar{u}}, &\textrm{(control bounds)}\\
\end{aligned}
$}
\end{equation}
where $\mathbf{x}=(\mathbf{q},\mathbf{v})$ is the state of the system, $\mathbf{q}\in\mathbb{SE}(3)\times\mathbb{R}^{n_j}$ (with $n_j$ as the number of joints) is the joint configuration, $\mathbf{v}\in\mathbb{R}^{n_v}$ (with $n_v = 6 + n_j$) is the generalized velocity, $\mathbf{u}\in\mathbb{R}^{n_j}$ is the joint torque input, $\boldsymbol{\lambda}_\mathcal{C}\in\mathbb{R}^{n_c}$ (with $n_c$ as the dimension of the contact forces) is the contact force, $\boldsymbol{\mathbf{p}}_{\mathcal{C,G}}\in\mathbb{R}^{n_c}$ (with
$\mathcal{C}$ and $\mathcal{G}$ as active and inactive contacts, respectively) is the position of the foot, $\mathbf{A}$ and $\mathbf{a}$ describes the contact surface, $\oplus$ and $\ominus$ denote \textit{integration} and \textit{difference operations} needed to optimize over manifolds~\cite{gabay82jota}---notations introduced in \textsc{Crocoddyl}~\cite{mastalli-icra20}.
Furthermore, $\ell^{reg}_k$ regularizes the robot's configuration around a nominal posture $\mathbf{q}^{ref}$, the generalized velocity, joint torques, and contact forces as follows:
\begin{equation*}
    \ell^{reg}_k = \|\mathbf{q}_k\ominus\mathbf{q}^{ref}\|^2_\mathbf{Q}+\|\mathbf{v}_k\|^2_\mathbf{N}+\|\mathbf{u}_k\|^2_\mathbf{R}+\|\boldsymbol{\lambda}_{\mathcal{C}_k}\|^2_\mathbf{K},
\end{equation*}
where $\mathbf{Q},\mathbf{N}\in\mathbb{R}^{n_v\times n_v}$, $\mathbf{R}\in\mathbb{R}^{n_j\times n_j}$ and $\mathbf{K}\in\mathbb{R}^{n_c\times n_c}$ are a set of (positive definite) diagonal weighting matrices.

To enable the automatic footstep placement, we first define a quadratic cost $w_r\|\mathbf{\dot{r}}_k-\mathbf{\dot{r}}^{ref}\|^2$ (with $w_r$ as its weight) that tracks the reference base velocity $\mathbf{\dot{r}}^{ref}$ in the horizontal plane.
Next, for all active contacts, we include our contact-surface penalty function $\sum_{\mathcal{C}_k}\ell_{\mathbf{p}_{\mathcal{C}_k}}$ (with $w_f$ as its weight).
We also add a constraint that specifies the contact surface height.
Finally, we impose constraints that define the vertical motion of the swing foot.
% Although it is possible to impose collision avoidance constraints, we choose to define constraints on the vertical movement of the foot so we can focus on validating our approach.
Note that we define the $\log(\cdot)$ operator in the vertical foot velocity constraint as the footstep placement may lie on a $\mathbb{SE}(3)$ manifold. ${}^\mathcal{W}\mathbf{p}_\mathcal{G}^{-1} \cdot {}^\mathcal{W}\mathbf{p}^{ref}_\mathcal{G}$ describes the inverse composition between the reference and current contact placements~\cite{blanco-10se3}.

\begin{figure}[t]
    \centering
    \includegraphics[trim={1.7cm 16.5cm 10.1cm 1.8cm}, clip, width=1.0\linewidth]{figs/plot/control_pipeline.pdf}
    \caption{
    Overview of our locomotion pipeline.
    }
    \label{fig:control_pipeline}
\end{figure}

Again, we employ the robot's full-body dynamics (contact and impulse dynamics) in~\eref{eq:oc_problem}, where $\mathbf{M}\in\mathbb{R}^{n_v\times n_v}$ is the joint-space inertia matrix, $\mathbf{J}_\mathcal{C}\in\mathbb{R}^{nc \times nv}$ is the active contact Jacobian, $\boldsymbol{\tau}^{\mathcal{C},\mathcal{I}}_b\in\mathbb{R}^{n_v}$ is the force-bias vector, $\mathbf{a}_{\mathcal{C}}\in\mathbb{R}^{n_c}$ is the desired acceleration, and $\mathbf{C}$ and $\mathbf{c}$ describes the linearized friction cone (or wrench cone for humanoids).
Note that the definition of the force-bias term ($\boldsymbol{\tau}^{\mathcal{C}}_b$ or $\boldsymbol{\tau}^{\mathcal{I}}_b$) changes between the contact and impulse dynamics.
For more details on the regularization cost, dynamics, friction cone, and implementation aspects of our~\gls{mpc}, we encourage readers to refer to~\cite{mastalli-underreview22}.

% \subsection{Single-region approach: an alternative formulation}\label{sec:single_region_approach}

% We develop a variant of the optimal control problem described in~\eref{eq:oc_problem}.
% We call this alternative formulation as \textit{single-region approach}.
% When we know the contact region in advance, then the role of the~\gls{mpc} is to find a footstep placement within this region (see~\fref{fig:convex_region}), which for the case of a convex polygon can be described as:
% \begin{equation}\label{eq:convex_region3}
%     \mathbf{A}{}^\mathcal{W}\mathbf{p}^{ref}_{\mathcal{G}_k, x, y} \leq \mathbf{a},
% \end{equation}
% where closed polygon $\boldsymbol{\gamma}$ is defined by $(\mathbf{A,a})$ in which its rows define the inequality constraints introduced by each linear segment.
% Then, if we include such kind of constraint in~\eref{eq:oc_problem}, we must remove the contact-region penalty function.
% Finally, we point out that this variant of the optimal control problem does not have to deal with the combinatorics of selecting a unique contact region.
% Indeed, in our implementation, we use the convex polygon selected by SL1M~\cite{tonneau-icra20} and discard the planned footstep placements as they are based on quasi-static dynamics.

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.35\textwidth]{figs/convex_patch.png}
%     \caption{
%     Convex region and notation.
%     The footstep position is denoted by $\mathbf{\hat{p}}$ and two consecutive vertices are denoted by $\mathbf{a}$ and $\mathbf{b}$.
%     If the footstep position is inside the convex region, $[\protect\overrightarrow{\mathbf{ab}} \times \protect\overrightarrow{\mathbf{a\hat{p}}}]_z$, should be negative.
%     }
%     \label{fig:convex_region}
% \end{figure}

% In \sref{sec:control_pipeline_and_experimental_setup}, we describe the pipeline of the convex region approach with an open-source region selection feature, SL1M.

\subsection{Locomotion Pipeline and Experimental Setup}\label{sec:control_pipeline_and_experimental_setup}

\fref{fig:control_pipeline} depicts our locomotion pipeline.
Reference velocities are sent using a joystick that runs at \SI{30}{\hertz}.
Candidate footstep surfaces in the predefined environment are extracted from mesh files at \SI{10}{\hertz}.
Our topology-based~\gls{mpc} operates at \SI{50}{\hertz} with an optimization horizon of \SI{0.85}{\second}.

Our~\gls{mpc}, teleoperation, and surface extractor run on two external PCs.
The joystick and surface extractor run on an Intel Core i9-9980 PC (8 core, 2.40 GHz), while the~\gls{mpc} runs on an Intel Core i9-9900 PC (8 core, 3.60 GHz).
Lastly, the state feedback controller and state estimator operate at \SI{400}{\hertz} on two separate onboard PCs equipped with an Intel Core i7-7500 (2 core, 2.70 GHz).
