\section{Description of the Model}
\label{sec:model}

\begin{table*}[th!]
    \centering
    \scalebox{0.85}{
        \begin{tabular}{r|ccc|ccc|ccc|ccc|c}
            \multicolumn{14}{c}{\textbf{Synthetic dataset: $p = 0.0025$, $a = 0.05$}}\\[1ex]
            \multicolumn{1}{c}{\textbf{}} & \multicolumn{3}{c}{\textbf{Egonet}}    & \multicolumn{3}{c}{\textbf{Node2Vec}} & \multicolumn{3}{c}{\textbf{Spectral Clustering}} & \multicolumn{3}{c}{\textbf{Deepwalk}} & \\
                & Prec. & Recall & F1-Score & Prec. & Recall & F1-Score & Prec. & Recall & F1-Score & Prec. & Recall & F1-Score & Data Points \\
            Anomaly & 1.00 & 1.00 & 1.00 & 0.00 & 0.00 & 0.00 & 0.01 & 0.04 & 0.02 & 0.27 & 0.56 & 0.36 & 25 \\
            Normal & 1.00 & 1.00 & 1.00 & 0.95 & 0.95 & 0.95 & 0.94 & 0.82 & 0.88 & 0.98 & 0.92 & 0.95 & 475 \\
            Accuracy & & & 1.00 & & & 0.90 & & & 0.78 & & & 0.90 & 500                   
        \end{tabular}
    }
\caption{Where $p$ is is the connection probability for the authentic nodes, and a is the percentage of the anomalous nodes.} \label{tab:my-table}
\end{table*}

The basic idea behind TET is that changes in a node's egonet can be summarized by counting \emph{subgraph transitions}.
A subgraph transition for a node $v$ at a given time transition $(t, t+1)$ is defined as a pair of graphs $(H_t, H_{t+1})$ on a shared node set $V$ such that:

\begin{itemize}
    \item[$\cdot$] $H_t$ is a subgraph of the adjacency neighborhood of $v$ at time $t$ if any missing nodes from the neighborhood at time $t+1$ are included
    \item[$\cdot$] $H_{t+1}$ is a subgraph of the adjacency neighborhood of $v$ at time $t+1$ if any missing nodes from the neighborhood at time $t$ are included
    \item[$\cdot$] $H_t$ and $H_{t+1}$ are not isomorphic.
\end{itemize}

In the interest of computational tractability, we only consider subgraph transitions up to a certain number of vertices---for this paper, we only consider subgraph transitions on at most $N = 3$ nodes.

By enumerating and canonically ordering all of the subgraph transitions in question, we can construct a vector of \emph{subgraph transition counts} for the node $v$ during the time hop from $t$ to $t+1$.
This subgraph transition count vector summarizes the change in $v$'s behavior from the previous time step to the next time step.

Performing this for each time transition results in a sequence of count vectors $\vec{v}_1, \vec{v}_2, \dots \vec{v}_{T-1} \in \mathbb{R}^d$, where $d$ is the number of subgraph transitions enumerated (note: $d$ may be \emph{very} large, even for small $N$).
We can then condense these counts into a single vector representation for $v$ by applying some element-wise \emph{aggregation function} (e.g., mean, sum, min, max).
In this paper, we aggregate the count vectors by averaging each of the transition counts over all of the time steps, producing $\vec{v} = \frac{1}{T-1}\sum_{t=1}^{T-1}\vec{v}_t \in \mathbb{R}^d$ as the embedding vector for the node in question.
The model is described in detail in \autoref{fig:pseudocode}.
%\hl{hmm}
% very insightful

\begin{algorithm}[h]
\SetAlgoLined
\KwIn{List of subgraph transitions $\mathcal{T}$\\
\phantom{eeeeeii} Temporal graph sequence, $G_1, \dots G_T$\\
\phantom{eeeeeii} Set of nodes $V$\\}
\KwOut{Set of embeddings $\left\{\vec{c}_v ~|~ v \in V\right\}$}
\For{$v$ in $V$}{
    \For{$t \in \left\{1, \dots T-1\right\}$}{
        Initialize $\vec{c}_{v, t} = (0, \dots 0) \in \mathbb{R}^{|\mathcal{T}|}$\;
        Let $G_{t}(v)$ be the egonet of $v$ at time $t$\;
        Let $G_{t+1}(v)$ be the egonet of $v$ at time $t+1$\;
        Union the vertex sets of $G_{t}(v)$ and $G_{t+1}(v)$\;
        \For{$(L, R)_i \in \mathcal{T}$}{
            \For{$G \lhd G_{t}(v)$ isomorphic to $L$}{
                \For{$H \lhd G_{t+1}(v)$ isomorphic to $R$}{
                    \eIf{$G$ and $H$ share the same nodes}{
                        Increment index $i$ of $\vec{c}_{v, t}$\;
                    }{
                        Continue\;
                    }
                }
            }
        }
    }
Compute $\vec{c}_v = \frac{1}{T-1}\sum_{t=1}^{T-1}\vec{c}_{v, t}$\;
{\bf yield} $\vec{c}_v$\;
}
\caption{\label{fig:pseudocode}how to embed temporal egonets}
\end{algorithm}


%In order to most-efficiently enumerate and count subgraph transitions, it will be useful to conceptualize a \emph{subgraph labeller} and a \emph{transition counter}.
%The subgraph labeller will be tasked with enumerating all graphs, up to isomorphism, on $N$ or less vertices, and assigning them a canonical (i.e., isomorphism-invariant) label.
%That way, when a subgraph is mined from a node's egonet, we have an unambiguous representation of the subgraph free from its initial context.
%We plan on using a variation of the \emph{color refinement} algorithm~\cite{arvind2016colorrefinement} to accomplish this.
%The transition counter will then be tasked with recognizing and counting pairs of subgraphs and generating the transition count vectors for each node.
%
%For dealing with graphical representations of data and most manipulations, we make good use of the NetworkX package for Python~\cite{Hagberg2008ExploringNetworkX}, which provides a fast intuitive framework for processing graphs.
%In order to quickly enumerate graphs and efficiently compute graph isomorphisms and automorphisms, we take advantage of Nauty~\cite{mckay2014nauty} and the Python bindings provided by PyNauty.

%igraph for Python\cite{igraph}
