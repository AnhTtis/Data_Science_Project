One of the fundamental challenges of collision-free motion planning is ensuring the entire trajectory remains safely outside the obstacles.
While checking that an individual point is collision free can be done efficiently, verifying that an entire trajectory is outside of every obstacle is a much harder problem.
In addition, decomposing the free space into overlapping convex sets has provided one solution for formulating the planning problem in a way that can be solved to global optimality \cite{deits2015efficient}.
However, performing that decomposition in configuration space is non-trivial as obstacles that are convex in task space can become nonconvex when mapped into the configuration space of the robot.

This paper extends the original IRIS (Iterative Regional Inflation by Semidefinite programming) algorithm proposed by \citet{deits2015computing} to compute convex, collision-free regions in configuration space.
IRIS relies on the assumption that the obstacles are convex.
This works well when looking for task-space collision-free regions in the presence of task-space convex obstacles.
But when the user needs convex regions in configuration space and the description of the obstacles are only convex in task space, IRIS does not work.
The algorithm does not consider the nonlinear kinematics mapping between task and configuration space, requiring task-space obstacles to be explicitly mapped into configuration space which thus far has proven to be an intractable problem.

\begin{figure}[t]
\centering
\includegraphics[width=0.35\textwidth]{figures/refined_region.png}
\caption{Three configuration that lie in the same convex collision-free region of configuration space generated by IRIS-NP.  Convex regions that contain both approaching grasp and grasping configurations allow users to plan all the way up to grasp efficiently, without requiring the heuristic pre-grasp configuration used by other planners.
}
\label{fig:refined_region}
\end{figure}


Instead of explicitly mapping task-space obstacles to configuration space, we present a method to utilize an implicit configuration-space representation of the obstacles through forward kinematics.  Our algorithm, IRIS-NP (Iterative Regional Inflation by Semidefinite \& Nonlinear Programming) contributes a generalization of the iterative process of IRIS by replacing the convex problem for adding hyperplanes with a nonlinear problem. By doing this we not only can handle avoiding task-space obstacles while moving in configuration space, we are also able to handle additional nonlinear constraints on the configuration of the robot.

An alternate extension to IRIS that considers the robot kinematics for converting between configuration space and task space is C-IRIS (C-space Iterative Regional Inflation by Semidefinite programming), laid out in \citet{amice2023finding}.
C-IRIS utilizes a reparameterization of the robot configuration to convert the forward-kinematics to a rational function that can be optimized using  Sums-of-Squares (SOS) programming.
By formulating each step as a convex optimization that can be solved to global optimality, C-IRIS is able to provide rigorous guarantees that the entire region is collision free.
Since IRIS-NP uses nonlinear optimization to handle the forward-kinematics the region is convex in the configuration-space coordinates but can only be probabilistically certified collision free.
Empirically though, we find very few colliding configurations within these regions and the probability of colliding configurations can be reduced by solving the nonlinear optimization from multiple initial guesses.
Also, IRIS-NP can be used to seed C-IRIS by generating an initial region in the reparameterized coordinates.
C-IRIS can then adjust the region to quickly find certified collision-free regions.


At a high level, IRIS-NP starts with an initial seed that is a point in $\R^n$ and a polytope defined only by the joint limits. On each iteration, we formulate a nonlinear optimization that searches for configurations within the current polytope that are in collision, an optimization that we refer to as counterexample search.
These conterexamples are used to define the polytope of collision-free configuration space (C-free).
Once all obstacles have been checked, a volume-maximizing ellipse is fit to the inside of the polytope to defines a metric which maximizes volume for the next iteration of counterexample searches.

The problem of decomposing a non-convex space into a collection of convex regions has attracted several different approaches.
Many of these seek to exactly decompose a non-convex shape into approximately convex components.
\citet{lien2004approximate} performs the decomposition by iteratively splitting a non-convex shape to remove the largest concavity. 
\citet{liu2010convex} instead formulates the problem as a mixed-integer optimization to find the best cuts to break the shape into components with concavity below a given threshold.
\citet{mamou2009simple} clusters the faces of the shape to find faces that together form components of the decomposition that are approximately convex.
All of these methods return only approximately convex components that cover the original shape.
Taking the convex hull of these shapes and using that for motion planning could result in regions that intersect with obstacles.
We instead search for an inner approximation of C-Free in this work.
In addition, all of these methods require a mesh representation of the space to decompose.
In the case of generating configuration-space regions among task-space obstacles, this requires not only mapping the obstacles from task to configuration space, which is intractable to do explicitly, but also finding the complement of the resulting configuration-space obstacle mesh.

The ability to generate convex, collision-free regions in configuration space using IRIS-NP is a useful tool for motion planning and can be used directly in algorithm such as \citet{marcucci2022motion}.
These regions could also be used for collision checking in sampling-based motion planners, eliminating the need to check for collisions at regular intervals along each segment, instead directly checking that the entire segment is safe.

The remainder of this paper digs into how IRIS-NP is implemented and performs. In Section \ref{sec:approach}, we discuss the mathematical formulation for our algorithm and the iterative sequence of optimizations that are solved to grow a region.
We continue in Section \ref{sec:implementation} by discussing details of our implementation that improve runtime, simplify the resulting polytope, and extend the capabilities of IRIS-NP.s
In Section \ref{sec:experiments}, we demonstrate how well IRIS-NP region generation works and compare how the implementation details affect performance.

\textbf{Notation:}
In this paper, we will use capital letters ($X$) to denote matrices and lower case letters ($x$) to denote vectors. The monogram notation used in \citet{manipulation}, which attaches relative-to and expressed-in frames to spatial vectors, will be used for rigid transforms.

