IRIS-NP mirrors IRIS by searching for the convex polytope with largest volume inscribed ellipse.
While the true goal is to generate a polytope of maximum volume, calculating the volume of an polytope is NP-hard.
Calculating the volume of an ellipse can be done with convex optimization and maximizing the volume of the largest inscribed ellipse achieves a similar goal as maximizing the polytope's volume.
As in \citet{deits2015efficient}, we represent the ellipse as the image of unit ball
$ \mathcal{E}(C,d) =  \{x | (x-d)^T C^T C (x-d) \leq 1 \}$
and the polytope as a collection of halfplanes
$P(A, b) = \{x | Ax \leq b\}$.
Put together the optimization we would like to solve is
\begin{subequations}
\begin{align}
\label{eq:full_cost}
\min_{A, b, C, d} \quad & \text{det} \ C \\
\label{eq:full_fk}
\begin{split}
\text{s.t.} \quad & \Fk_{\mathcal{O}_i} (q,\: ^{O_i}p^x) \neq \Fk_{\mathcal{O}_j } (q,\: ^{O_j}p^y) \\
	& \quad \quad \forall \ ^{O_i}p^x \in \mathcal{O}_i,\ ^{O_j}p^y \in \mathcal{O}_j,\ q \ | \ Aq \leq b
\end{split}\\
\label{eq:full_poly}
& Ax \leq b \quad \forall \ x \ | \ (x-d)^T C^T C (x-d) \leq 1
\end{align}
\end{subequations}

\noindent
where $\mathcal{O}_i$ and $\mathcal{O}_j$ represent a pair of collision geometries and is applied for all collision pairs $i, j$ in the set of possible collision pairs $\mathcal{C}$.
The set of possible collision pairs includes both collisions between the robot and the world as well as collision between the robot and itself.
The notation $ ^{O_i}p^x$ describes a 3 dimensional vector corresponding to the position of $x$ relative to the origin of body $O_i$, expressed in the frame of $O_i$.
$\Fk_{\mathcal{O}_i} (q,\: ^{O_i}p^x)$ maps the point $x$ from the representation relative to $O_i$ to a representation relative to the world frame when the configuration of the robot is $q$.

This optimization will maximize the total volume of the ellipse \ref{eq:full_cost}.
The first constraint \ref{eq:full_fk} ensures that, for each pair of collision bodies, there is no configuration in the polytope $P$ where for any two bodies, $\mathcal{O}_i$ and $\mathcal{O}_j$, there exists points $ ^{O_i}p^x \in \mathcal{O}_i,\ ^{O_j}p^y \in \mathcal{O}_j$ that are coincident.
The second constraint \ref{eq:full_poly} ensures that the ellipse is fully contained within the polytope.
Taken together, these ensure that the polytope is as large as possible while still separating its interior from the configurations that lead to collision.
Since the forward kinematics for most robots are nonlinear, this optimization is even more difficult to solve than the one given by Equation 1 in \citet{deits2015computing}.
Specifically, the nonlinear portion of this problem can only be solved with local optimization instead of the convex optimization that was used for the convex problems that made up the iterative steps of IRIS.
Despite this, we can still use the same iterative process for splitting up the polytope optimization and the ellipse optimization.
While only using local nonlinear optimization prevents us from making guarantees that we have found a globally-optimal solution, in practice we find that we can still find high-quality solutions that achieve the goal of maximizing the volume of the collision-free polytope.


\begin{algorithm}[!h]
\caption{Given a seed point $q_0$, a list of collision pairs $\mathcal{C}$, and a bounding box on the regions limits (usually the robots joint limits) $q_{upper}$ \& $q_{lower}$ for the upper and lower limits respectively. Find a polytope $P = \{x | Ax \leq b\}$ and ellipse $\mathcal{E}(C,d) =  \{x | (x-d)^T C^T C (x-d) \leq 1 \}$ such that $\mathcal{E} \subset P$ and no collision pair in $\mathcal{C}$ are in collision for any configuration in $P$. The $AddSeparatingHyperplanes$ method is expanded in Algorithm \ref{alg:hyperplane}. The $InscribedEllipse$ method is explained in Section 3.4 of \citet{deits2015computing}.}\label{alg:iris_nl}
\begin{algorithmic}
\State $A_0, \ b_0 = [I, -I]^T, \ [q_{upper}, -q_{lower}]^T$
\State $C_0, \ d_0 = \epsilon I, \ q_0$
\State $i = 0$
\While{$i < \text{iteration limit}$}
	\State $(A_{i+1}, b_{i+1}) = AddSeparatingHyperplanes(\mathcal{E}_i, \mathcal{C}, P_0)$
	\State $(C_{i+1}, d_{i+1}) = InscribedEllipse(A_{i+1}, b_{i+1})$
	\State $i = i + 1$
	\If{($\text{det} C_i - \text{det} C_{i-1}) / \text{det} C_{i-1} < tolerance$}
    	\State \textbf{break}
	\EndIf
\EndWhile
\Return $A_i,\ b_i$
\end{algorithmic}
\end{algorithm}

\subsection{Initializing the Algorithm}
As in \cite{deits2015computing}, the algorithm starts with an initial seed configuration, $q_0$, that is not in collision around which the region will grow.
Using the seed, the polytope $P_0$ can be initialized using the joint limits of the robot and the ellipse $\mathcal{E}_0$ can be initialized as a hypersphere with small radius $\epsilon$ centered about the initial seed.

\subsection{Adding Separating Hyperplanes}

\begin{figure}[t]
\centering
\includegraphics[width=0.4\textwidth]{figures/cspace-iris.pdf}
\caption{The counterexample search consists of finding the first configuration on a uniform expansion of the ellipse that results in collision.
}
\label{fig:counterexample}
\end{figure}

In order to determine what hyperplanes to add to the polytope, the algorithm iterates over all pairs of collision bodies and searches for configurations within the polytope that result in collision.
By finding these counterexamples, tangent planes can be added to the polytope $P$ to separate the collision-free configurations from the in-collision configurations.
Conceptually, the process of finding these counterexamples consists of uniformly expanding the ellipse until a configuration on the surface of the ellipse is in collision.
A visualization of this idea is shown in Figure \ref{fig:counterexample}.

For this paper, we assume the environment is known with all collision geometries of both the robot and obstacles defined as convex sets in task space;
all non-convex geometries have been decomposed into convex components.
While IRIS-NP does not require that all collision geometries are convex in task space, having only convex collision geometries makes two of the constraints in the counterexample search convex, reducing the difficulty of the problem.

The counterexample search can be written down as

\begin{subequations}
\label{eq:counterexample}
\begin{align}
\label{eq:hyp_cost}
\min_{q, ^{O_i}p^x, ^{O_j}p^y} \quad & (q-d)^T C^T C (q-d) \\
\label{eq:hyp_points}
\text{s.t.} \quad & ^{O_i}p^x \in \mathcal{O}_i , \quad ^{O_j}p^y \in \mathcal{O}_j \\
\label{eq:hyp_fk}
& ^WX^{O_i}(q) \: \cdot \, ^{O_i}p^x = \, ^WX^{O_j}(q) \: \cdot \, ^{O_j}p^y \\
\label{eq:hyp_poly}
& A q \leq b
\end{align}
\end{subequations}

\noindent
The cost for this optimization \ref{eq:hyp_cost} specifies the configuration that is closest to the center of the ellipse using the distance metric, $C$, given by the ellipse $\mathcal{E}$. The convex constraints \ref{eq:hyp_points} select points, $^{O_i}p^x$ and $^{O_j}p^y$, that respectively lie within the geometries $\mathcal{O}_i$ and $\mathcal{O}_j$ of the collision pair. \ref{eq:hyp_poly} ensures that only configurations within the current polytope are considered. Lastly, the constraint \ref{eq:hyp_fk} specifies that the configuration $q$, when passed through the forward kinematics, results in points $x$ and $y$ being coincident in the world frame.
All of the costs and constraints for this problem are convex, except for the kinematic constraint \ref{eq:hyp_fk}. The forward kinematics make this a nonlinear optimization which can be solved using an off-the-shelf nonlinear solver.
This problem returns a feasible solution only when the polytope contains a configuration that results in collision.


\begin{figure}[t]
\centering
\begin{subfigure}[t]{0.23\textwidth}
\centering
\includegraphics[width=\textwidth]{figures/cspace_margin_close.pdf}
\end{subfigure}
\
\begin{subfigure}[t]{0.23\textwidth}
\centering
\includegraphics[width=\textwidth]{figures/cspace_margin_far.pdf}
\end{subfigure}
\caption{To separate obstacles that are concave in configuration space from the interior of the polytope with finitely many hyperplanes, the configuration-space margin backs the hyperplane away from the surface of the obstacle. Increasing this margin reduces the number of faces in the final polytope at the expense of a more conservative region.
}
\label{fig:config_margin}
\end{figure}


Once a counterexample has been found, we add a hyperplane to the iteration's polytope $P_i$ to ensure that other configurations that are in collision are excluded from the polytope.
If the obstacle is convex in configuration space, a hyperplane that is tangent to an expansion of the ellipse at the counterexample point would fully separate the interior of the polytope from collision.
As in \citet{deits2015computing} such a hyperplane can be defined using the counterexample point and the gradient of the ellipse's boundary at that point

\begin{equation}
\label{eq:hyperplane_no_margin}
a_j = C^T C (q-d), \quad b_j = a_j q.
\end{equation}

However, we cannot assume that the obstacle is convex in the configuration space.
As a result, we employ a configuration-space margin, $\delta$, that backs the hyperplane away from the obstacle by a user defined margin.
In our implementation, $\delta$ takes the units of distance in the configuration space, moving the hyperplane away from the obstacle by a fixed amount.
This makes the hyperplane more conservative than necessary but ensures that a finite number of hyperplanes can separate the obstacle from the interior of the polytope as shown in Figure \ref{fig:config_margin}.  We use the same formula as Equation \ref{eq:hyperplane_no_margin} but normalize the normal vector $a_j$ and subtract the configuration-space margin from $b_j$

\begin{equation}
\label{eq:hyperplane}
a_j = \frac{C^T C (q-d)}{||C^T C (q-d)||}, \quad b_j = a_j q - \delta.
\end{equation}
The counterexample search is performed repeatedly with the updated polytope and the same collision pairs until the program returns infeasible, ensuring that enough hyperplanes have been added to separate the collision geometries.
We repeat this search for each pair of collision geometries.
However, with the counterexample search being a nonlinear optimization, the solver reporting infeasibility does not guarantee that it is globally infeasible, meaning that a colliding configuration could escape the counterexample search. A method for reducing the probability of this happening is discussed in Section \ref{sec:prob_cert}.

\begin{algorithm}[!h]
\caption{\textbf{AddSeparatingHyperplanes} Given an ellipse defined by $C$, $d$, add separating hyperplanes to the polytope $P_i(A,b)$ that are tangent to the expanded ellipse to prevent collision pairs in the sorted list $\mathcal{C}$ from colliding.}\label{alg:hyperplane}
\begin{algorithmic}
\For {$\mathcal{O}_i$, $\mathcal{O}_j$ in $\mathcal{C}$}
	\State Setup counterexample optimization Equation \ref{eq:counterexample}
	\State $failures = 0$
	\While{$failures < \text{max infeasible samples}$}
		\If {Solve counterexample successful $\rightarrow q*$}
			\State $a_j = \frac{C^T C (q-d)}{||C^T C (q-d)||}$
			\State $b_j = a_j q - \delta$
			\State Add $a_j$, $b_j$ to $A$, $b$
			\State $failures = 0$
		\Else
			\State $failures = failures + 1$
		\EndIf
	\EndWhile
\EndFor
\Return $A,\ b$
\end{algorithmic}
\end{algorithm}

\subsection{Calculating the Largest Inscribed Ellipse}
Once the counterexample search has been completed for each collision pair, the result is a convex collision-free polytope in configuration space.
The next step of the iterative process is to find the inscribed ellipsoid of maximum volume.
Given the representation of the ellipse $ \mathcal{E}(C,d) =  \{x | (x-d)^T C^T C (x-d) \leq 1 \}$
and the polytope $P(A, b) = \{x | Ax \leq b\}$, if we define $C = \tilde{C}^{-1}$ the optimization we want to solve is

\begin{equation}
\begin{aligned}
\max_{\tilde{C}, d} \quad & \log \text{det} \tilde{C} \\
\text{s.t.} \quad & ||a_i\tilde{C}||_2 \leq b_i - a_id, \ \forall i \\
& \tilde{C} \succeq 0.
\end{aligned}
\end{equation}

\noindent
as stated by \citet{boyd2004convex} where $a_i$ are the rows of $A$ and $b_i$ are the elements of $b$.  This is a convex optimization (a semidefinite program to be precise) that can be efficiently solved using commercial solvers. For our implementation, we used both Mosek \cite{mosek} and Gurobi \cite{Gurobi} and found comparable performance from each of them.

\subsection{Termination criteria}
As with the original IRIS algorithm, this algorithm will converge to a maximal size as the volume of the inscribed ellipsoid is monotonically increasing and bounded by the initial joint limits.
To account for the fact that no bounds on the number of iterations required to achieve convergence are currently known, multiple termination criteria are provided for the algorithm.
These include:
\begin{itemize}
  \item A threshold on growth rate of the inscribed ellipse's volume
  \item An iteration limit
  \item Containment of the initial seed
\end{itemize}
Taken together these ensure the algorithm terminates in a timely manner while still generating large regions.
