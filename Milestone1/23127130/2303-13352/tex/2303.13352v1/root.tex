%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX conversion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\let\proof\relax
\let\endproof\relax
\usepackage[cmex10]{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}

\usepackage{multicol}

\usepackage{xspace}

\newcommand\moduleName[1]{\textsf{#1}\xspace}
\newcommand{\MAMO}{\moduleName{MAMO}}
\newcommand{\MAPF}{\moduleName{MAPF}}
% \newcommand\algName[1]{\textsf{#1}\xspace}
\newcommand{\MfM}{\moduleName{\fontfamily{pbk}\selectfont M{\footnotesize 4}M}}
\newcommand{\MAPFalg}{\textsc{MAPF}\xspace}
\newcommand{\CBS}{\textsc{CBS}\xspace}
\newcommand{\WHCA}{\textsc{WHCA*}\xspace}
\newcommand{\KPIECE}{\textsc{KPIECE}\xspace}
\newcommand{\RRT}{\textsc{RRT}\xspace}
\newcommand{\PrPl}{\textsc{PP}\xspace}
\newcommand{\UI}{\textsc{UI}\xspace}
\newcommand{\SelSim}{\textsc{SelSim}\xspace}
\newcommand{\Dogar}{\textsc{Dogar}\xspace}

\usepackage[table,xcdraw,dvipsnames,x11names]{xcolor}
\usepackage{color}
\def\D#1{\textcolor{Plum}{#1}}

\colorlet{documentLinkColor}{red}
\colorlet{documentUrlColor}{blue}
\colorlet{documentCitationColor}{ForestGreen}
\usepackage[bookmarks=true]{hyperref}
\hypersetup{
     colorlinks = true,
     citecolor = documentCitationColor,
     linkcolor = documentLinkColor,
     urlcolor = documentUrlColor,
}

\usepackage{graphicx}

\newcommand{\PP}{\mathcal{P}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\Obs}{\mathcal{O}}
\newcommand{\OI}{\mathcal{O}_I}
\newcommand{\OM}{\mathcal{O}_M}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}

\usepackage{textcomp,gensymb}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode} % algorithmicx
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}

\theoremstyle{proposition}
\newtheorem{proposition}{Proposition}

\usepackage{titlesec}
% \titleformat*{\subsubsection}{\bfseries}

\usepackage[binary-units]{siunitx}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage{geometry}
\geometry{
left=19.1mm,
top=19.1mm,
right=19.1mm,
bottom=21mm,
}
\usepackage{cite}

\usepackage{mathtools}
\usepackage{balance}

\title{\LARGE \bf
Planning for Complex Non-prehensile Manipulation Among Movable Objects by Interleaving Multi-Agent Pathfinding and Physics-Based Simulation
}


\author{Dhruv Mauria Saxena$^{1}$ and Maxim Likhachev$^{1}$% <-this % stops a space
% \thanks{*This work was not supported by any organization}% <-this % stops a space
\thanks{$^{1}$The authors are with the
Robotics Institute, Carnegie Mellon University, Pittsburgh, PA 15213, USA.
{\small e-mail: \tt \{dsaxena, mlikhach\}@andrew.cmu.edu}. This work was in part supported by ARL grant W911NF-18-2-0218 and ONR grant N00014-18-1-2775.}%
}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}

% We consider the problem of planning for pick-and-place manipulation in heavy clutter where it might be necessary to interact with and rearrange movable objects via a sequence of non-prehensile pushes in order to grasp and extract a desired object. This planning problem is computationally very challenging for several reasons. First, it requires searching over a search-space that includes the configuration of movable objects. Second, it requires prediction of the effects of all the non-prehensile interactions with objects considered by the planner, which involves forward simulating a computationally expensive physics-based model. In this paper, we make an observation that the problem of planning for Manipulation Among Movable Objects is closely related to the Multi-Agent Pathfinding problem if we treat all movable objects as actuated robots. Using this insight, we construct a planning algorithm that iterates between (i) solving a multi-agent planning problem that reasons about the configuration of movable objects but does not forward simulate a physics model, and (ii) solving an arm motion planning problem that uses a physics-based simulator but does not search over the possible configurations of movable objects. We present the \MfM algorithm, briefly analyse it from a theoretical perspective, and evaluate its performance experimentally in both simulations and on a physical PR2 robot.

% Using this insight, we construct a planning algorithm that decouples the search over configurations of movable objects from the use of a physics-based simulator to predict the effects of robot-object and object-object interactions.

Real-world manipulation problems in heavy clutter require robots to reason about potential contacts with objects in the environment.
We focus on pick-and-place style tasks to retrieve a target object from a shelf where some `movable' objects must be rearranged in order to solve the task.
In particular, our motivation is to allow the robot to reason over and consider non-prehensile rearrangement actions that lead to complex robot-object and object-object interactions where multiple objects might be moved by the robot simultaneously, and objects might tilt, lean on each other, or topple.
% In contrast to prehensile pick-and-place rearrangements, our non-prehensile pushes do not require prior knowledge of valid grasp poses or stable placement poses for movable objects.
% However they do require the ability to predict the effects of the complicated interaction dynamics that ensue from our robot arm pushing objects.
To support this, we query a physics-based simulator to forward simulate these interaction dynamics which makes action evaluation during planning computationally very expensive.
To make the planner tractable, we establish a connection between the domain of \textbf{\fontfamily{pbk}\selectfont M}anipulation Among Movable Objects and \textbf{\fontfamily{pbk}\selectfont M}ulti-Agent Pathfinding that lets us decompose the problem into two phases our \MfM algorithm iterates over.
First we solve a multi-agent planning problem that reasons about the configurations of movable objects but does not forward simulate a physics model.
Next, an arm motion planning problem is solved that uses a physics-based simulator but does not search over possible configurations of movable objects.
We run simulated and real-world experiments with the PR2 robot and compare against relevant baseline algorithms.
Our results highlight that \MfM generates complex 3D interactions, and solves at least twice as many problems as the baselines with competitive performance.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Manipulation Among Movable Objects \raisebox{0.5pt}{(}\MAMO{\raisebox{0.5pt}{)}}~\cite{StilmanMAMO} defines a broad class of problems where a robot must complete a manipulation task in the presence of obstructing clutter.
In heavily cluttered scenes, there may be no collision-free trajectory that solves the task.
This does not make the problem unsolvable since \MAMO allows rearrangement of some objects \emph{a priori} designated as `movable'.
In addition, \MAMO may associate each object with constraints on how it can be interacted with -- it is undesirable to allow robots to carelessly push or throw objects around.
% \MAMO solutions rely on the ability of the robot to rearrange movable clutter
% (while satisfying the interaction constraints)
% such that the original manipulation task can be completed.

In this paper, we consider \MAMO problems for pick-and-place manipulation tasks where the robot needs to retrieve a target object from a cluttered shelf, cabinet, fridge, or a similar structure.
% We use a physics-based simulator in-the-loop during planning to forward simulate the effect of rigid-body interactions and thereby ensure that all interaction constraints for all objects are satisfied.
% Fig.~\ref{fig:intro_fridge} shows an instantiation of the type of \MAMO problem we aim to solve.
Fig.~\ref{fig:intro_fridge} (a) shows an example of such a scene where two movable objects must be rearranged in order to retrieve the desired object, while ensuring they do not topple and no contacts are made with an immovable obstacle.
% In order to retrieve the desired can of beer, the robot must first push out of the way the movable box of milk and a tub of yogurt taking care not to topple either object over.
% The robot also needs to ensure that nothing (itself or a movable object) makes contact with the glass of coffee.

\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\columnwidth]{figures/intro_fridge_2.pdf}
    \caption{(a) An example \MAMO problem to retrieve the beer can (yellow outline). Access is blocked by the movable box of milk and tub of yogurt (blue outlines). In order to retrieve the can, they must be rearranged out of the way without toppling them, and without anything making contact with the glass of juice (red outline). (b) A complex non-prehensile action that tilts the movable potted meat can (blue outline) to rearrange it.}
    \label{fig:intro_fridge}
\end{figure}

Solving such \MAMO problems requires answers to three difficult questions: \emph{which} objects to move, \emph{where} to move them, and \emph{how} to move them.
% (perhaps under additional constraints that they remain on the freezer shelf and not topple over).
Thus \MAMO problems assign the robot a goal with respect to the overall task and object-of-interest (OoI), without any additional goal specifications for other objects except for satisfying their associated interaction constraints; while \MAMO solutions exist in a composite configuration space that includes the configuration of the robot arm and all objects in the scene.
% In contrast, the related problem of rearrangement planning~\cite{Ben-ShaharR98,Ota09} explicitly specifies desired goal configurations for some movable objects.
The search for a solution is computationally challenging since the size of this space grows exponentially with the number of objects.

% Existing work in \MAMO typically adopts one of two common simplifications to make this problem tractable.
% The first limits the robot to prehensile rearrangement of the scene via a sequence of pick-and-place actions to relocate the movable clutter~\cite{StilmanMAMO,KrontirisSDKB14,KrontirisB15,ShomeB21,WangGNYB21_uniform_rearrangement,LeeCNPK19}.
% This requires access to known grasp and stable placement poses for the movable objects.
% For heavily cluttered scenes, an intermediate ``buffer'' location for placing objects may also be required.
% The second simplification only considers planar non-prehensile interactions~\cite{BergSKLM08,DogarS12,King1,HuangHYB22,homology_nonprehensile} which fails to capture realistic 3D interactions where objects might tilt, lean on each other, or topple.

We are interested in non-prehensile rearrangement actions since they allow robots to manipulate objects that may be too big or too bulky or otherwise ungraspable.
In many cases it is more time- and energy-efficient to push an object off to the side than to grasp it, pick it up, move it elsewhere, place it down, and release it before proceeding.
Furthermore, we allow the robot to move multiple objects simultaneously with the same push action, and we allow objects to tilt, lean on each other, and slide (an example is shown in Fig.~\ref{fig:intro_fridge} (b)).
% Interaction constraints for movable objects in our problems of interest forbid them from falling off the shelf, toppling over on it, making contact with known `immovable' obstacles, and moving with large velocities.
% However, the search for \MAMO solutions with
Planning with these actions requires the ability to predict the effect of robot actions on the configuration of objects, typically through computationally expensive forward simulations of a rigid-body physics simulator.
% do require simulating a physics model to obtain the result of robot-object interactions which can be time-consuming.


% Existing solvers for the class of \MAMO problems we consider belong to one of two families.
% The first focus on prehensile rearrangement of the scene via a sequence of pick-and-place actions to relocate the movable clutter~\cite{StilmanMAMO,KrontirisSDKB14,KrontirisB15,ShomeB21,WangGNYB21_uniform_rearrangement,LeeCNPK19}.
% % Prehensile rearrangements usually require access to known grasp configurations of the robot arm (from where objects can be grasped) and stable configurations of the objects (where they can rest in a stable pose). They may even require an intermediate ``buffer'' location for placing movable objects~\cite{WangGNYB21_uniform_rearrangement,LeeCNPK19}.
% % All of these are unavailable to the planning algorithm in the \MAMO problems we instantiate.
% The second allow \emph{planar} robot-object non-prehensile interactions in addition to prehensile actions~\cite{BergSKLM08,DogarS12,King1,HuangHYB22,SelSim,homology_nonprehensile}.

% A brute-force approach to solve \MAMO problems might try to compute a valid sequence of actions to achieve a particular rearrangement before determining if the desired object can be grasped and extracted.
% The space of all possible rearrangements of a scene grows rapidly with the number of movable objects\footnote{Even with one movable object, without thinking about a specific goal configuration for it, a robot might need to evaluate possibly infinite grasp poses for prehensile manipulation and push locations for non-prehensile manipulation.}.
% Wilfong~\cite{Wilfong91} showed that the first step of computing a plan for a specific rearrangement is PSPACE-hard (and NP-hard if any rearrangement will lead to a solution).
% Only a small subset of all possible rearrangements can be expected to make it feasible to retrieve the OoI.
% Since solving a \MAMO problem requires finding such a rearrangement, they are at least NP-hard to solve, and PSPACE-hard in our case as no goal configurations are specified for movable objects.
% We assume that the goal of the pick-and-place manipulation task for our \MAMO problems is specified with respect to the OoI, however we utilise non-prehensile interactions for rearrangement of movable objects for the reasons mentioned above.
% This lets us manipulate all objects in the scene without the need for known stable configurations of movable objects and grasp poses/configurations for them~\cite{StilmanMAMO,KrontirisSDKB14,KrontirisB15,ShomeB21}, or an intermediate ``buffer'' location sometimes required for prehensile rearrangements~\cite{WangGNYB21_uniform_rearrangement,LeeCNPK19}.
% Unlike existing approaches that push movable objects, we do not assume planar interactions between the robot and movable objects.
% We simulate the push actions in a physics-based simulator to verify interaction constraints (on tilting, toppling, movement velocity, and obstacle contact) in the 3D workspace.

Our key insight in this work draws a connection between the \MAMO domain and Multi-Agent Pathfinding \raisebox{0.5pt}{(}\MAPF{\raisebox{0.5pt}{)}} to decompose the problem into two parts.
% We are inspired by existing literature on reducing planning problems to simpler analogues~\cite{GochevSL12} and using solutions in abstract spaces to guide the search for a full solution~\cite{Sacerdoti74}.
% We show how solving a particular \MAPF problem intuitively prescribes a strategy to rearrange the scene and solve the \MAMO problem of retrieving the OoI.
First, we treat the movable objects as artificially actuated agents tasked with avoiding collisions with (i) our robot arm retrieving the OoI, (ii) each other, and (iii) immovable obstacles.
% A solution to a \MAPF problem with all movable objects as `agents' lets the robot arm successfully retrieve the OoI while the movable objects rearrange themselves.
A solution to this abstract \MAPF problem searches over potential rearrangements of objects \emph{without} the need to query a physics simulator.
% Although this solves the \MAMO problem in the abstract space where movable objects are actuated, it also suggests a rearrangement strategy for the robot to `realise' in the real-world where it is the only actuated entity.
Next, we use the \MAPF solution to compute informed push actions to rearrange movable objects \emph{without} searching over their possible configurations.
These actions are forward simulated with a physics model to ensure validity.
The decomposition helps us keep track of object configurations in the full $SE(3)$ space and generate informed push actions that lead to realistic multi-body interactions in the 3D workspace as shown in Fig.~\ref{fig:intro_fridge} (b). % where objects tilt, lean on each other, and slide.
Fig~\ref{fig:intro_soln} shows a complex and interesting solution found by our algorithm for one of the simpler scenarios in our test data.
% This abstract \MAPF solution suggests a rearrangement for the robot to `realise' in the real-world where it is the only actuated entity.
% This lets us
% Our \MfM algorithm iterates between two aspects of the \MAMO problem -- first we find a suitable rearrangement of the scene without any physics simulations, and then we try to realise this rearrangement via non-prehensile actions that are simulated for interaction constraint verification.

\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\columnwidth]{figures/intro_soln.pdf}
    \caption{Sequence of images showing a solution found by our \MfM algorithm for a simple \MAMO scene. From \emph{left} to \emph{right}: (a) initial scene, (b) rearranged scene after one push action, (c) successful OoI retrieval. Movable objects are blue, immovable obstacles are red, and the OoI is yellow.}
    \label{fig:intro_soln}
\end{figure}

% For these reasons we utilise non-prehensile interactions for rearrangement of movable objects in this work.

The main contributions of our work in this paper for solving \MAMO planning problems are:
\begin{itemize}
    \item Enable reasoning over and usage of complex non-prehensile interactions that may push multiple objects in tandem and produce object-object interactions like leaning and toppling  (Fig.~\ref{fig:intro_fridge} (b)).
	\item \MAPF abstraction for computing suitable rearrangements for \MAMO planning problems, without using a simulation-based model.
% 	\item Approach to compute non-prehensile push actions to realise the rearrangement from the \MAPF solution.
	\item An efficient algorithm to solve \MAMO problems that iterates between calls to an \MAPF solver (to determine \emph{which} objects to move \emph{where}) and a push planner (to verify \emph{how} to move the objects).
% 	to achieve a feasible rearrangement of the scene for the retrieval of a desired object.
	\item A thorough experimental evaluation of our approach in simulation and in the real-world on a PR2 robot.
\end{itemize}

We provide details of relevant works from \MAMO literature in Section~\ref{sec:related_work}.
Section~\ref{sec:prelims} formalises the \MAMO planning problem. %, and includes a general overview of \MAPF.
% Section~\ref{sec:key_idea} discusses our key idea of abstracting a \MAMO problem to a \MAPF problem and formalises the \MAPF problem we solve.
Section~\ref{sec:m4m} presents our iterative planning algorithm \MfM, including the abstraction from \MAMO to \MAPF (Section~\ref{sec:key_idea}) and a non-prehensile push planner (Section~\ref{sec:push_actions}). %, and discusses the theoretical incompleteness of \MfM (Section~\ref{sec:theory}).
% under specific conditions\footnote{We discuss \emph{completeness} of our planning algorithm vis-\`a-vis the \MAPF solver used and the feedback loop between the two phases of our iterative algorithm.}.
% on the \MAPF solver used and the feedback loop between the two phases of our iterative algorithm.
We provide extensive quantitative evaluation against relevant \MAMO baselines in simulation in Section~\ref{sec:exps} along with real-world results of our algorithm on the PR2 robot.
Section~\ref{sec:discussion} discusses the benefits, limitations, and future extensions of this work. % of using the \MAPF abstraction for \MAMO. %, and concludes with several ideas to extend this connection.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Related Work}\label{sec:related_work}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Manipulation Among Movable Objects}

\MAMO generalises Navigation Among Movable Obstacles \raisebox{0.5pt}{(}\textsf{NAMO}\raisebox{0.5pt}{)} where a mobile robot must navigate from start to goal in a reconfigurable environment~\cite{alami,Wilfong91,StilmanNAMO}.
It is also related to the rearrangement planning problem~\cite{Ben-ShaharR98,Ota09} which explicitly specifies desired goal configurations for movable objects.
% Latombe~\cite{LatombePlanning} provides an excellent review of early work in these domains which were limited to planar environments and geometric solutions.
Wilfong~\cite{Wilfong91} showed that rearrangement planning is PSPACE-hard, and \MAMO problems are NP-hard to solve.
% Non-prehensile actions were introduced in \MAMO planning algorithms~\cite{LynchMason} based on analysis done by Mason~\cite{Mason86} on the mechanics of pushing.

% \MAMO problems can be formulated as \emph{task and motion planning problems}~\cite{KimGTAMP,NamLCCK20,ChitnisHGSGLA16,KaelblingL11} where a high-level search reasons about all allowed rearrangements of the workspace such that the manipulation task of OoI retrieval may be completed.
% The success of these methods depends on how the high-level actions are parameterised.
% Parameterisations that include more information -- such as stable configurations and grasp poses of objects -- potentially lead to easier motion planning problems, provided the parameters are sampled intelligently.
% In contrast, we rely on a \MAPF abstraction to guide our search towards a suitable rearrangement for completing the manipulation task, and dynamically generate push strategies based on the \MAPF solution.

Many existing \MAMO and \emph{rearrangement planning} solvers make use of prehensile actions~\cite{StilmanMAMO,KrontirisSDKB14,KrontirisB15,ShomeB21,WangGNYB21_uniform_rearrangement,LeeCNPK19}.
% Approaches that use prehensile rearrangements in the environment assume access to known grasps and stable poses for movable objects~\cite{StilmanNAMO,StilmanMAMO,DogarS12,KrontirisSDKB14,KrontirisB15,ShomeB21}.
This simplifies planning since grasped objects behave as rigid bodies attached to the robot, but assumes access to known stable configurations of and grasp poses for objects~\cite{StilmanMAMO,KrontirisSDKB14,KrontirisB15,ShomeB21}.
In some cases a ``buffer'' location to place grasped objects is required~\cite{WangGNYB21_uniform_rearrangement,LeeCNPK19}.
In particular,~\cite{KrontirisSDKB14} and~\cite{ShomeB21} utilise the concept of ``pebble graphs''~\cite{KMS84,SoloveykColor} from \MAPF literature to find prehensile actions for rearrangement planning.
Their formulation restricts the motion of the movable objects (pebbles) on a precomputed roadmap of robot arm trajectories via prehensile actions.
This limits the possible configurations of objects they consider since motions are limited to poses from where they can be grasped and to those where they can be stably placed.
% In contrast, our \MAPF formulation only requires that these objects rearrange themselves out of the way of the arm trajectory that retrieves the OoI.
% We then focus on realising such a rearrangement via non-prehensile push actions.% with a physics-based simulator in-the-loop to forward simulate the complex multi-body interaction dynamics.
Since we utilise non-prehensile pushes for rearrangement and a physics-based simulator for action validation, our planner explores a richer space of robot-object and object-object interactions in the 3D workspace. %so long as interaction constraints are not violated.

Allowing \emph{non-prehensile interactions} with objects typically requires access to a simulation model to obtain the result of complex interaction dynamics~\cite{BergSKLM08,DogarS12,King1,HuangHYB22,homology_nonprehensile,SelSim}.
Of these approaches, only Selective Simulation~\cite{SelSim} considers realistic interactions in the 3D workspace and is one of our comparative baselines in Section~\ref{sec:exps}.
Others rely on planar robot-object interactions which fail to account for object dynamics in $SE(3)$ where they might tilt, lean, or topple.
In Section~\ref{sec:exps}, we adapt the \MAMO solver from~\cite{DogarS12} to use our push actions that lead to 3D robot-object interactions and require a physics simulator during planning.
Originally their work was limited to interacting with a single object at a time, and used an analytical motion model in $SE(2)$ to propagate the effect of the push on the planar configuration of the object being pushed (tilting and toppling was not considered in~\cite{BergSKLM08,DogarS12,King1,HuangHYB22,homology_nonprehensile}).

Querying \emph{physics-based simulators} for the result of an action is much more expensive than collision checking it.
% The judicious use of simulators within planning loops to minimise planning times is an important field of research for \MAMO.
\KPIECE~\cite{KPIECE} is a randomised algorithm for planning with a computationally expensive transition model (querying a physics-based simulator is an example of such a model).
\KPIECE and RRT~\cite{RRT} are two other baselines we compare against in Section~\ref{sec:exps}.
% This algorithm was extended in~\cite{pKPIECE} to deal with uncertainty in model parameters.
% Since we assume no state/environment uncertaialgorithmnty in this work, we compare against \KPIECE~\cite{KPIECE} and vanilla RRT~\cite{RRT} in Section~\ref{sec:exps}.
% For \MAMO planning, Agboh and Dogar~\cite{agboh2021robust} borrowed the ideas of convergent planning~\cite{johnson2016convergent} to address modelling uncertainties in simulation.
In our own prior work on \MAMO planning~\cite{SPAMP}, we find a collision-free trajectory to a region near the OoI grasp pose, and simulate goal-directed non-prehensile actions only within this region.
The assumption that such a collision-free trajectory exists is easily violated in the cluttered \MAMO workspaces we instantiate in our experiments (see Figs.~\ref{fig:intro_fridge} (a),~\ref{fig:levels}, and~\ref{fig:pr2_soln} for example).
% Since we assume no modelling uncertainty in this work, we also compare the performance of our approach against \KPIECE~\cite{KPIECE} that tries to intelligently query the simulator during planning.
% In other applications, simulators have been used to compute the effect of higher-level and longer-horizon robot ‘skills’~\cite{ZicklerV09}, and to determine low-level feasibility of a high-level discrete plan~\cite{PlakuKV10}.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Multi-Agent Pathfinding}\label{sec:related_mapf}

% The objective of multi-agent pathfinding (\MAPF) is to find paths for a team of robots from a set of start locations to a set of goal locations.
% % This general formulation can give rise to many different types of problems based on the homogeneity of the robot team, a centralised or decentralised planning algorithm, the number of robots in the team and the number of goals to be achieved, and whether the goals are ‘labeled’ (specific goals for specific robots) or not.
% % Additional factors that can be important to consider include whether the environment is static or dynamic, known or unknown, and whether there are inter-robot communication latencies.
% % A general introduction to multi-agent pathfinding can be found in~\cite{L2006,SharonSFS15,SternSFK0WLA0KB19}.
% One class of algorithms that solve \MAPF problems assigns priorities to the robots and solves a sequence of single-agent planning problems based on this prioritisation~\cite{ErdmannL87,Silver05}.
% This \emph{prioritised planning} scheme trades off algorithmic incompleteness and solution suboptimality for practical efficiency.
% Turpin et al.~\cite{TurpinMMK14} present a resolution complete prioritised \MAPF solver for the specific case when robots are interchangeable and can wait indefinitely at their respective start and goal states.

% Conflict-based search (\CBS)~\cite{SharonSFS12,SharonSFS15} and \textsc{M*}~\cite{WagnerC11} are complete and optimal \MAPF solvers that use different techniques to provide strong theoretical guarantees.
% \CBS searches a tree of all possible solutions in a best-first manner by resolving robot conflicts into constraints on robot motion.
% For two robots that collide at any instant, either one can be in that location in the final solution but not both.
% \CBS enumerates all such possibilities for all potential conflicts until a solution with no conflict is found.
% % While optimal, \CBS will never stop executing if a \MAPF problem has no solution.
% \textsc{M*} resolves robot conflicts by combining two conflicting robots and treating them as one agent until the conflict between them is resolved.
% This idea has also been adopted in the \CBS family of algorithms~\cite{SharonSFS12-MACBS}.

% While the focus of \MAPF is typically limited to finding paths on discrete graphs, multi-robot motion planning tries to compute feasible trajectories for a team of robots.
% This has been formulated as an integer program in prior work~\cite{MAPFILP}, and techniques from sampling-based planning have been used to quickly search the continuous composite space~\cite{DayanRoadmap,shome2020drrt}.
% However, in this work we solve an abstract \MAPF problem with artificially actuated agents that move on a discrete grid.
% This simplifies the \MAPF problem by discretising it, and we then ateempt to realise the \MAPF solution in the continuous 3D workspace via our non-prehensile push planner.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Abstract Planning}
% \emph{Abstract} search spaces or \emph{abstractions} of planning problems refer to simpler, reduced forms of the \emph{full space} of the original problem.
% The use of these search abstractions is related to the field of hierarchical planning~\cite{Sacerdoti74} which attempts to use abstract space solutions as partial plans or heuristics in the full space.
% Pearl~\cite{PearlHeuristics} contains a thorough review of these techniques.
% An abstract solution can sometimes be refined to obtain a full solution by removing the simplifications used to construct the abstraction hierarchy~\cite{BacchusY91,Haslum07}.
% Another common approach is to use abstract space distances to abstract goals as a heuristic in the full space~\cite{HolteMZM96,HoffmannN01,ChatterjeeLKV19}.
% Pattern databases generalise this idea for multiple abstract space states or ``subgoals'', and store cost-to-subgoal values for use as a heuristic in the full search~\cite{CulbersonS98}.
% Guided optimisation in the computer graphics and animation community~\cite{HandOfGod}, postulates a ``hand of god'' which applies an external balancing torque to help find a control trajectory for bipedal locomotion.
% % The work done by this ``hand of god'' is reduced over time to guide the solver towards a good optimum.
% Philosophically this idea is the same as the artificial actuation of movable objects in our work.

% The idea of solving a simplified version of the planning problem as a means to finding a solution in the full space is related to \emph{curriculum learning}.
% Curriculum learning was explored in the context of robotics by Sanger~\cite{Sanger94}, and since then a more formal theoretical basis for machine learning methods has been established~\cite{BengioLCW09}.
% A brief overview specifically for robot manipulation can be found in~\cite{KroemerNK21}.
% Guided optimisation in the computer graphics and animation community~\cite{HandOfGod}, postulates a ``hand of god'' which applies an external balancing torque to help find a control trajectory for bipedal locomotion.
% % The work done by this ``hand of god'' is reduced over time to guide the solver towards a good optimum.
% Philosophically this idea is the same as the artificial actuation of movable objects in our work.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem Statement}\label{sec:prelims}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{\MAMO Problem Statement}\label{sec:mamo_problem}
Let $\X_\R \subset \mathbb{R}^q$ denote the configuration space of a $q$ degrees-of-freedom robot manipulator $\R$.
Let $\Obs = \{O_1, \ldots, O_n\}$ be the set of objects in the scene, and $\X_{O_i} \equiv SE(3)$ be the configuration space of object $O_i$ that includes its 3D position and orientation.
The search space for a \MAMO planning problem is
% the Cartesian product of the robot and all object configuration spaces, denoted as
$\X = \X_\R \times \X_{O_1} \times \cdots \times \X_{O_n}$.
We denote movable objects by $\OM$ and immovable obstacles by $\OI$ such that $\Obs = \OM \cup \OI$ and $\OM \cap \OI = \emptyset$.

% An interaction constraint is encoded as a boolean valued function $k: \X \rightarrow \{0, 1\}$ which returns 1 if the constraint is satisfied, 0 otherwise.
Each object is associated with a set of interaction constraints.
% We denote a constraint belonging to an object as $k \ni O_i$.
For example, an `immovable' obstacle (an object that cannot be interacted with, such as a wall) will contain a constraint function which is satisfied so long as neither the robot nor any other object makes contact with it.
In our problems similar functions encode that movable objects cannot fall off the shelf, tilt too far (beyond $\SI{25}{\degree}$), or move with a high instantaneous velocity (above $\SI{1}{\meter\per\second}$).
% $K_i(x): \X \rightarrow \{0, 1\}$ denotes the evaluation of all constraints associated with object $O_i$, computed as $K_i(x) = \wedge_{k \ni O_i} k(x)$.
A state $x \in \X$ is valid if all constraints for all objects are satisfied at that state. %, i.e. $K_i(x) = 1 \,\forall\, O_i \in \Obs, i \in \{1, \ldots, n\}$.
Let $\X_V$ be the space of valid states.

A \MAMO planning problem can be defined with the tuple $\PP = (\X, \A, \T, c, x_S, \X_G)$.
$\A$ is the action space of the robot, $\T: \X \times \A \rightarrow \X$ is a deterministic transition function, $c: \X \times \X \rightarrow \mathbb{R}_{\geq 0}$ is a state transition cost function, $x_S \in \X_V$ is the start state, and $\X_G \subset \X, \X_G \cap \X_V \neq \emptyset$ is the set of goal configurations.
The start state $x_s$ includes a ``home'' robot configuration in $\X_\R$ and the initial poses of all objects. %, denoted $\OM^{\text{init}}$ and $\OI$ respectively.
% In this work, $\X_G$ is defined using end-effector poses in $SE(3)$.
% (a pregrasp location for an object; grasp planning is outside the scope of this problem).
% , which leads to a set of possible manipulator configurations, some of which must be valid $(\X_G \cap \X_V \neq \emptyset)$. %
% A path $\pi$ of length $T$ is a sequence of states $\{x_1, \ldots, x_T\}$ and has cost $C(\pi) = \sum_{i=1}^{T-1} c(x_i, x_{i+1})$ where $x_{i+1} = \T(x_i, a_i)$.
We would like to find the least-cost valid path $\pi^*$ from start to goal i.e., a path made up of a sequence of valid states.
% A path $\pi = \{x_1, \ldots, x_T\}$ has cost $C(\pi) = \sum_{i=1}^{T-1} c(x_i, x_{i+1})$.
% \footnote{We assume all possible solution paths for \MAMO satisfy $x_{i+1} = \T(x_i, a_i)$.}
Formally, we can write this as:

\begin{equation}\label{eq:background_problem}
\begin{aligned}
    \text{find } &\pi^* = \argmin_{\pi = \{x_1, \ldots, x_T\}} \sum_{i=1}^{T-1} c(x_i, x_{i+1}) \\
    \text{s.t. } &x \in \X_V, \,\forall\, x \in \pi \quad\qquad\qquad\emph{(path of valid states)} \nonumber \\
    &x_1 = x_S, x_T \in \X_G \,\qquad\qquad\emph{(start, goal constraints)} \nonumber \\
    &x_{i+1} = \T(x_i, a_i), a_i \in \A, \!\!\!\!\!\quad\forall x_i, x_{i+1} \in \pi \nonumber \\
    & \qquad\qquad\qquad\qquad\qquad\qquad\emph{(transition dynamics)}
\end{aligned}
\end{equation}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\columnwidth]{figures/100011.pdf}
    \caption{\MAMO workspace (\emph{left}) and its 2D projection labelled with movable object IDs. Movable objects are in blue, immovable obstacles in red, and the object-of-interest to be retrieved in yellow.}
    \label{fig:100011}
\end{figure}

In our work we discretise $\A$ to include ``simple motion primitives'' that independently change each robot joint angle by a fixed amount and dynamically generated ``push actions'' described in Section~\ref{sec:push_actions}. % based on information about where to move an object.
% All actions $a_i \in \A$ necessarily change the robot configuration in $\X_\R$, and in addition simple motion primitives may only change the OoI configuration (if it has been grasped) while only push actions can change movable object configurations.
For transition $x_{i+1} = \T(x_i, a_i)$, action $a_i \in \A$ can affect object configurations between $x_i$ and $x_{i+1}$ only if $a_i$ is a push action or the OoI has been grasped.
The cost of robot actions $c$ is proportional to the distance travelled in $\X_\R$.
We assume $\X_G$ is defined in two parts -- a grasp pose in $SE(3)$ for the OoI and a goal pose in $SE(3)$ where it must end up (while grasped by the robot).
Our solution to \MAMO problems is a sequence of arm trajectories in the robot configuration space $\X_\R \subset \mathbb{R}^q$ ($q = 7$ for the PR2 robot) that (i) rearrange movable clutter and (ii) retrieve the OoI.
Fig.~\ref{fig:100011} shows an example of the \MAMO problems we consider in this paper, along with its 2D projection. Red objects are immovable obstacles $\OI$, blue objects are initial movable objects $\OM^{\text{init}}$, and the goal for the robot arm is to extract the yellow OoI from the shelf.
There is no collision-free trajectory for the arm to extract the OoI from the shelf.
Upon rearrangement of some movable objects ($A$ and $B$ in particular), such a trajectory may be found.
% Our algorithm formulates an abstract \MAPF problem to identify \emph{which} objects need to move ($A$ and $B$ in Fig.~\ref{fig:100011}), and \emph{where} they should be moved (shown in Fig.~\ref{fig:ngr}).

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Classical Multi-Agent Pathfinding}\label{sec:mapf_problem}
% % We adapt the text on classical \MAPF from~\cite{SternSFK0WLA0KB19} in this section to give a high-level introduction to discretised \MAPF problems.
% % A more general discussion is provided in~\cite{L2006}.
% Classical \MAPF planning problems seek to find non-conflicting paths for a set of agents $\{r_1, \ldots, r_n\}$ on a discrete graph $G = (V, E)$ in discrete time.
% % \footnote{\emph{Conflicts} in \MAPF are detected by collision-checking paths in spacetime against static obstacles and other robots.}
% Each robot $r_i$ has a designated start state $s_i \in V$ and a desired goal state $g_i \in V$.
% Robot $r_i$ has access to an action space $\A_i$, which includes an action to \emph{wait} at the current state.
% An edge $(v, v^\prime) \in E$ implies that some action $a^j \in \A_i$ takes robot $r_i$ from vertex $v$ to $v^\prime$.
% All actions are assumed to take the same amount of time such that traversing an edge $(v, v^\prime) \in E$ takes one unit of time.
% A \emph{single-agent solution path} for $r_i$ is a sequence of states $\pi_i = \{v_0 = s_i, \ldots, v_T = g_i\}$ where the subscripts denote time indices.
% Two single-agent solution paths $\pi_i$ and $\pi_j$ are \emph{conflict-free} if robots $r_i$ and $r_j$ never collide as they traverse their respective paths.
% The solution to a \MAPF problem with $n$ robots $\{r_1, \ldots, r_n\}$ is a set of $n$ \emph{mutually} conflict-free paths, i.e. $\pi_i$ and $\pi_j$ must be conflict-free for any $1 \leq i, j \leq n\,, i \neq j$.

% Although a thorough review of \MAPF literature is beyond the scope of this work, we would like to highlight that the \MAPF problem is NP-hard to solve optimally~\cite{YuL13}.
% While \MAPF typically focuses on finding paths on discrete graphs, multi-robot motion planning tries to compute dynamically feasible trajectories for robots in continuous space~\cite{DayanRoadmap,shome2020drrt}.
% The agents in our \MAPF formulation (movable objects) are artificially actuated so we are not concerned with any object dynamics.
% This allows us to solve the simpler discrete \MAPF problem and the solution directly informs us of desirable final poses for the objects for the \MAMO problem.
% We use Conflict-Based Search (\CBS)~\cite{SharonSFS15}, a complete and optimal \MAPF algorithm, to solve our abstract \MAPF problem formulated in Section~\ref{sec:key_idea}.
% % A general introduction to multi-agent pathfinding can be found in~\cite{L2006,SharonSFS15,SternSFK0WLA0KB19}.

% % This has been formulated as an integer program in prior work~\cite{MAPFILP}, and techniques from sampling-based planning have been used to quickly search the continuous composite space~\cite{DayanRoadmap,shome2020drrt}.
% % In contrast to optimal solvers like \CBS and \textsc{M*}~\cite{WagnerC11}, \emph{prioritised planning}~\cite{ErdmannL87,Silver05} trades off algorithmic incompleteness and solution suboptimality for practical efficiency.
% % It solves \MAPF problems by assigning priorities to the agents and solving a sequence of single-agent planning problems based on this prioritisation.


% % \D{
% % \begin{enumerate}
% %     \item MAMO
% %     \item MAPF
% % \end{enumerate}
% % }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \MfM Planning Algorithm}\label{sec:m4m}

We call our algorithm \MfM: Multi-Agent Pathfinding for Manipulation Among Movable Objects.
\MfM is given access to a physics-based simulator (PyBullet~\cite{coumans2019}) to ensure that no interaction constraints defined in the \MAMO problem are violated.
% We use  as our simulator.
% Interaction constraints for immovable obstacles encode that they cannot be contacted by any other object or the robot.
% Movable objects cannot fall off the shelf, topple over, tilt too far (beyond $\SI{25}{\degree}$), or move with a high instantaneous velocity (above $\SI{1}{\meter\per\second}$).
% These constraints are encoded as the boolean valued functions $k: \X \rightarrow \{0, 1\}$ from Section~\ref{sec:mamo_problem} and are evaluated when robot actions are simulated.
% The discrete action space $\A$ for the robot includes \emph{simple motion primitives} that independently change each joint angle by a fixed amount and \emph{push actions} described in Section~\ref{sec:push_actions}.
% The cost of robot actions $c$ is proportional to the distance travelled in $\X_\R$.
% For transition $x_{i+1} = \T(x_i, a_i)$, $x_i$ and $x_{i+1}$ can have different object states only if $a_i$ is a push action or the OoI is being manipulated.
% The start state $x_s$ includes a ``home'' robot configuration in $\X_\R$ and the initial poses of the movable objects and immovable obstacles, $\OM^{\text{init}}$ and $\OI$ respectively.
% We assume the goal set $\X_G$ is defined in two parts -- a grasp pose in $SE(3)$ for the OoI and a goal pose in $SE(3)$ where it must end up (while grasped by the robot).
% We compute the solution to this \MAMO problem $\PP = (\X, \A, x_S, \X_G, \T, c)$ as a sequence of robot arm trajectories in the robot configuration space $\X_\R \subset \mathbb{R}^q$ ($q = 7$ for the PR2 robot) that (i) rearrange movable clutter and (ii) retrieve the OoI.
We note that a \MAMO problem $\PP$ to retrieve the OoI with $\OM \neq \emptyset$ is solvable \emph{iff} the simpler problem $\hat{\PP}$ without any movable objects i.e., $\OM = \emptyset$ can be solved.
We denote a solution trajectory to $\hat{\PP}$ as $\hat{\pi}_\R$.
Let $\mathcal{V}\left(\hat{\pi}_\R\right)$ denote the volume occupied by the robot arm in the workspace during execution of $\hat{\pi}_\R$.
$\mathcal{V}\left(\hat{\pi}_\R\right)$ specifies a ``negative goal region'' (NGR)~\cite{DogarS12} for the movable objects.
A NGR is a sufficient volume of the 3D workspace which, if there are no objects inside it, allows the robot arm to retrieve the OoI without other contacts.
If all movable objects can be rearranged such that they are outside $\mathcal{V}\left(\hat{\pi}_\R\right)$, the robot can execute $\hat{\pi}_\R$ to retrieve the OoI.
Fig.~\ref{fig:ngr} shows a NGR $\mathcal{V}\left(\hat{\pi}_\R\right)$ for the problem from Fig.~\ref{fig:100011}.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.65\columnwidth]{figures/100011-ngr.pdf}
    \caption{The negative goal region (NGR) $\mathcal{V}\left(\hat{\pi}_\R\right)$ in gray for the \MAMO problem from Fig.~\ref{fig:100011}. (\emph{left}) 3D volumes of the NGR and all objects at their initial poses (we omit the shelf for ease of visualisation). (\emph{right}) 2D projection of the NGR and the workspace, overlayed with the solution to the abstract \MAPF problem from Section~\ref{sec:key_idea} formulated for this scene. Objects $A$ and $B$ need to move outside the NGR, and object $C$ needs to move to allow $A$ to reach its goal. \MAPF solution paths are shown in pink.}
    \label{fig:ngr}
\end{figure}

Algorithm~\ref{alg:mfm} contains the pseudocode for \MfM. At a high-level, \MfM first computes $\hat{\pi}_\R$ (Line~\ref{line:simple_mamo}) and the NGR $\mathcal{V}\left(\hat{\pi}_\R\right)$ (Line~\ref{line:ngr}).
It then iterates over two steps:
\begin{enumerate}
    \item\label{bullet:call_mapf} Section~\ref{sec:key_idea}: Compute a solution to the abstract Multi-agent Pathfinding (\MAPF) problem where each movable object is treated as an agent that needs to escape the NGR without colliding with other agents using Conflict-Based Search (\CBS)~\cite{SharonSFS15}, a complete and optimal \MAPF algorithm.
    \item Section~\ref{sec:push_actions}: Pick a movable object to be rearranged according to the \MAPF plan computed in~\ref{bullet:call_mapf} and find a valid non-prehensile push for it by forward simulating potential pushes using a physics-based simulator.
\end{enumerate}

% Since \CBS returns the same solution for the same input problem (specified as object poses in the scene and an NGR $\mathcal{V}\left(\hat{\pi}_\R\right)$),
Algorithm~\ref{alg:mfm} uses \texttt{replan} to ensure \CBS is only called to solve new \MAPF problems.
After the first \CBS call, \texttt{replan} triggers subsequent \CBS calls once a valid push has been found i.e., at least one object has been moved.
This leads to a different \MAPF problem with new object poses.
Until a valid push is found, we sample and simulate pushes for all objects that move in the \MAPF solution.

% Only when we find a valid push for an object that needs to move per the \MAPF solution do we call the \MAPF solver again for the resulting scene.
% Until such time we sample and simulate pushes for all objects that move as part of the \MAPF solution.
% After successfully moving an object, the next call to the \MAPF solver can take this change in object state into account to find a better solution for rearrangement.

% Fig.~\ref{fig:intro_fridge} shows an example a \MAMO workspace.
% % -- our PR2 robot is placed in front of the shelf.
% Even though objects in \MAMO exist in the 3D world $(\X_{O_i} \equiv SE(3))$, they move on the plane of the shelf in the \MAPF solver.

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=\columnwidth]{figures/scenes.eps}
%     \caption{Randomly generated \MAMO workspaces. The OoI is in yellow, movable objects in blue, and immovable obstacles in red.}
%     \label{fig:scenes}
% \end{figure}


% It takes as input the initial poses of the movable objects and immovable obstacles, $\OM^{\text{init}}$ and $\OI$ respectively.

% \MfM starts by solving the relaxed \MAMO problem $\hat{\PP}$ in Line~\ref{line:simple_mamo} and computing the corresponding NGR in Line~\ref{line:ngr}.
The \textsc{PlanRetrieval} function takes as input a set of objects to be considered as immovable obstacles for the robot and runs Multi-Heuristic A$^\ast$~\cite{AineSNHL16} to find an arm trajectory in $\X_\R$ to retrieve the OoI.
% \MfM solves the abstract \MAPF problem (Section~\ref{sec:key_idea}) in Line~\ref{line:plan_mapf} and computes non-prehensile pushes to rearrange movable objects (Section~\ref{sec:push_actions}) in the loop from Line~\ref{line:plan_rearrange}.

\CBS is called in Line~\ref{line:plan_mapf} with the latest known movable object poses in $SE(3)$ to obtain a set of paths that ensure they all satisfy the NGR $\mathcal{V}\left(\hat{\pi}_\R\right)$.
This searches over all possible rearrangements of the scene from the current state, without ever querying a physics simulator, by assuming that movable objects are artificially actuated agents (Section~\ref{sec:key_idea}).

We then loop over all objects that need to be rearranged (from Line~\ref{line:plan_rearrange}) and try and find a valid push for them (Section~\ref{sec:push_actions}).
% Details of our push planner are provided in Section~\ref{sec:push_actions}.
If a valid push is found (Line~\ref{line:push_found}), it is added to the final sequence of arm trajectories to be executed $\Psi$, and the pose of that object is updated for future iterations.

\MfM terminates either when the allocated planning budget expires, or we successfully find a trajectory to retrieve the OoI in the presence of all objects ($\OI \cup \OM$) as obstacles in Line~\ref{line:finalise_plan}.
Although this trajectory $\pi_\R$ may be different from $\hat{\pi}_\R$ (Line~\ref{line:simple_mamo}), it will still retrieve the OoI successfully since it is guaranteed to not make contact with any object (immovable or movable).
The sequence of trajectories $\Psi$ can then be executed in order to rearrange the movable objects (if required) and finally ending in successful OoI retrieval.% thereby solving the \MAMO problem.

\begin{algorithm}[t]
\begin{small}
\caption{Multi-Agent Pathfinding for Manipulation Among Movable Objects}\label{alg:mfm}
\begin{algorithmic}[1]

\Procedure{\MfM}{$\OM^{\text{init}}, \OI$}
    \State $\OM \gets \OM^{\text{init}}$ \Comment{Rearranged object positions}
    \State $\Psi \gets \emptyset$ \Comment{Sequence of arm trajectories}
    \State $\hat{\pi}_{\R} \gets \textsc{PlanRetrieval}(\OI)$ \label{line:simple_mamo} \Comment{OoI retrieval trajectory}
    \State Compute $\mathcal{V}(\hat{\pi}_{\R})$ \label{line:ngr}
    \State \texttt{replan} $\gets$ \texttt{true}, \texttt{done} $\gets$ \texttt{false}
    \While{\texttt{time remains}}
        \If{\texttt{replan}} \label{line:push_found}
            \State $\pi_{\R} \gets \textsc{PlanRetrieval}(\OI \cup \OM)$ \label{line:finalise_plan}
            \If{$\pi_{\R}$ exists}
                \State $\Psi \gets \Psi \cup \{\pi_{\R}\}$, \texttt{done} $\gets$ \texttt{true}
                \State \textbf{break} \label{line:finalised}
            \EndIf
            \State $\{\pi_{o_m}\}_{o_m \in \OM} \gets \CBS( \OM, \OI, \mathcal{V}(\hat{\pi_{\R}}))$ \label{line:plan_mapf}
            \State \texttt{replan} $\gets$ \texttt{false}
        \EndIf
        \For{$o_m \in \OM$} \label{line:plan_rearrange}
            \If{$\pi_{o_m} = \emptyset$} \label{line:dont_move}
                \State \textbf{continue}
            \EndIf
            \State $\psi \gets \textsc{PlanPush}(o_m, \pi_{o_m}, \OM, \OI)$ \label{line:plan_push}
            \State $(\texttt{valid}, o_m^\prime) \gets \textsc{SimulatePush}(\psi)$ \label{line:sim_push}
            \If{\texttt{valid}} \label{line:push_found}
                \State $\Psi \gets \Psi \cup \{\psi\}$, \texttt{replan} $\gets$ \texttt{true}
                \State $\textsc{UpdatePose}(\OM, o_m^\prime)$
                \State \textbf{break}
            \EndIf
        \EndFor
    \EndWhile
    \If{$\neg\texttt{done}$}
        \Return $\emptyset$
    \EndIf
    % \For{$\psi \in \Psi$} \label{line:exec}
    %     \State $\textsc{Execute}(\psi)$
    % \EndFor
    \Return $\Psi$
\EndProcedure

\end{algorithmic}
\end{small}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\MAPF Abstraction for Manipulation}\label{sec:key_idea}

A fundamental challenge to solving \MAMO problems requires determining \emph{which} objects need to be rearranged and \emph{where} they should be moved.
% There are infinitely many possible ways to rearrange a scene in the continuous 3D space since any object can be manipulated in infinitely many ways.
% Existing approaches either use a discrete set of parameterised actions to find a plan for relocating objects from undesirable locations~\cite{DogarS12}, randomly sample robot control sequences in the hope that a beneficial rearrangement is achieved~\cite{KPIECE,King1}, or compute a drop-off location for prehensile rearrangement~\cite{WangGNYB21_uniform_rearrangement}.
The key idea in this paper uses an existing \MAPF solver to search over potential rearrangements of the scene which lead to successful OoI retrieval.
Importantly, the \MAPF solver does not require access to a physics simulator for this purpose -- it only relies on 3D collision checking.
Our \MAPF abstraction includes all movable objects $o_m \in \OM$ as agents.
We check for collisions between agents in space and time in their full $SE(3)$ configuration space.
All agents have a discrete action space corresponding to a four-connected grid on the $(x, y)-$plane of the shelf.
We assume each action takes unit time and either the agent remains in place, or the $x-$ or $y-$coordinate of the agent pose changes by $\SI{1}{\centi\meter}$.

Agent start configurations are determined by their latest pose in $SE(3)$ prior to the \MAPF call (Algorithm~\ref{alg:mfm}, Line~\ref{line:plan_mapf}).
% The high-level of \CBS searches a tree of all possible solutions in a best-first manner by resolving agent conflicts into constraints on agent motion.
% For two agents that collide along their paths, either one can be in the location where and when they collide in the final solution but not both.
% The low-level of CBS runs single-agent searches for each agent on a discrete graph $G_{\CBS} = (V, E)$ where vertices $V \subset SE(3)$ are object poses.
% Edges $(v, v^\prime) \in E$ take unit time to traverse and either $v \equiv v^\prime$, or the $x-$ or $y-$coordinate of the agent pose changes by $\SI{1}{\centi\meter}$ between $v$ and $v^\prime$.
% Agent goals in the \MAPF abstraction are specified with respect to $\hat{\pi}_\R$ and $\mathcal{V}\left(\hat{\pi}_\R\right)$ -- the solution of the simpler \MAMO problem $\hat{\PP}$ that does not include any movable objects and its corresponding ``negative goal region'' (NGR).
% We denote this solution trajectory for the robot arm as $\hat{\pi}_\R$.
% Let $\mathcal{V}\left(\hat{\pi}_\R\right)$ denote the volume occupied by the robot arm in the workspace during execution of $\hat{\pi}_\R$, and $\mathcal{B}(o_m, x)$ denote the volume occupied by object $o_m$ at pose $x \in SE(3)$.
% $\mathcal{V}\left(\hat{\pi}_\R\right)$ specifies a ``negative goal region'' (NGR)~\cite{DogarS12} for the agents in the \MAPF problem.
% Let $\mathcal{B}(o_m, x)$ denote the volume occupied by movable object $o_m \in \OM$ at pose $x \in SE(3)$.
% $o_m$ satisfies the NGR if it is ``outside'' it, i.e. in a state $x$ such that $\mathcal{V}\left(\hat{\pi}_\R\right) \cap \mathcal{B}(o_m, x) = \emptyset$.
% If all movable objects can be rearranged such that they are outside the NGR, the robot can execute $\hat{\pi}_\R$ to retrieve the OoI.
% To be precise, each agent $o_m$ in the \MAPF problem has a \emph{set} of possible goal states $\{g : \mathcal{V}\left(\hat{\pi}_\R\right) \cap \mathcal{B}(o_m, g) = \emptyset\}$.
Each agent $o_m$ in the \MAPF problem has a set of possible goals that include all states where the agent satisfies the NGR by being ``outside'' it.

We call \CBS to obtain a solution, shown in Fig.~\ref{fig:ngr}, to this \MAPF abstraction.
The solution is a set of paths for movable objects $\{\pi_{o_m}\}_{o_m \in \OM}$ whose final states $\pi_{o_m}^{end}$ satisfy the NGR, and suggests a rearrangement strategy in terms of \emph{which} objects to move and \emph{where}.
If we can rearrange all $o_m \in \OM$ to their respective $\pi_{o_m}^{end}$ poses, we know that the trajectory $\hat{\pi}_\R$ will successfully retrieve the OoI, thereby solving the \MAMO problem.

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.5\columnwidth]{figures/100011-soln.eps}
%     \caption{A solution to the abstract \MAPF problem for Fig.~\ref{fig:100011} returned by CBS. Only objects 14 and 15 need to move outside the NGR, and their solution paths are shown in pink. }
%     \label{fig:mapf_solution}
% \end{figure}

% We refer to this \MAPF formulation as `abstract' since the movable objects act as actuated agents by virtue of their action spaces, when in reality they can only be moved by the robot arm.
% Nevertheless the solution to this \MAPF abstraction, shown in Fig.~\ref{fig:mapf_solution}, prescribes a rearrangement strategy in terms of \emph{which} objects to move and \emph{where}.

% For this toy example, we assume our robot is a planar disc that can push the movable objects if it makes contact with them, and grasp the object-of-interest (OoI) if it makes contact with that specific object.
% % \footnote{The OoI becomes rigidly attached to the robot once grasped.}.
% Following the notation described in Section~\ref{sec:mamo_problem} in this example, $\X_\R \equiv \X_{O_i} \equiv SE(2)$ i.e. the configurations of the robot and objects include their 2D position $(x, y) \in \mathbb{R}^2$ and orientation $\theta$ about the $z$-axis.
% We also assume an intermediate goal is specified as a pregrasp pose vis-\`a-vis the OoI, the grasp is hard-coded as a straight-line motion along the specified direction, and the overall goal is to extract the OoI beyond the shelf.

% Our key insight abstracts this \MAMO problem to a \MAPF problem by imagining the movable objects as \emph{actuated} agents.
% Furthermore, these actuated agents are provided a simple action space that only affects their 2D position $(x, y) \in \mathbb{R}^2$ on a discrete gridworld representation of the shelf\footnote{This can be trivially modified to allow actions to also change orientation.}.
% The objective for the robot remains the same as before -- to retrieve the OoI.
% The objective for the actuated agents is to remain on the shelf and avoid all collisions.

% In doing so, we can construct a \MAPF problem as described in Section~\ref{sec:mapf_problem}.
% Let $\OM = \{O_1, \ldots, O_m\}$ be the set of $m$ movable objects.
% The agents in our abstract space \MAPF problem are $\{r_0 \equiv \R, r_1 \equiv O_1, \ldots r_m \equiv O_m\}$.
% Our discrete graph $G = (V, E)$ can be implicitly constructed using the action space $\A$ of the robot, and the action spaces of movable objects $\OM$.
% The start states for all agents are defined as their initial states in the \MAMO problem.
% The goal states for the robot are defined with respect to the pregrasp pose (intermediate goal) and any state where the OoI is beyond the shelf (final goal).
% All positions on the shelf are potential goal states for a movable object.
% A goal state is \emph{valid} if it is collision-free in spacetime.
% The robot arm solves for its path in robot configuration space $\X_\R$ using the action space $\A$.
% % , given the single-agent solution paths of other agents.

% Any existing \MAPF solver from Section~\ref{sec:related_mapf} can be used to solve this problem.
% Fig.~\ref{fig:mapf_solution} shows one such solution to the abstract \MAPF problem we constructed from the \MAMO problem in Fig.~\ref{fig:100011}.
% It shows the artificially actuated movable objects 14 and 15 relocating themselves to allow the robot to successfully retrieve the OoI.
% This solution suggests a rearrangement of the scene that would let the robot solve the \MAMO problem.
% Since the robot is the only actuated entity, we need to compute actions for it to \emph{realise} this rearrangement in the real-world by moving the appropriate objects.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Generating Non-Prehensile Push Actions}\label{sec:push_actions}
Given a path $\pi_{o_m}$ for $o_m \in \OM$ from the \MAPF solution, \textsc{PlanPush} (Algorithm~\ref{alg:mfm}, Line~\ref{line:plan_push}) determines \emph{how} an object may be rearranged (Fig.~\ref{fig:push_algo}).
% We overload $o_m$ to also refer to the current pose of object $o_m$.
We would like to move the object to $\pi_{o_m}^{end}$, which is known to satisfy the NGR.
To compute a push trajectory, we first shortcut $\pi_{o_m}$ (taking into account collisions with immovable obstacles $\OI$) into a series of straight line segments defined by points $\{x^1 = \pi_{o_m}^{start}, \ldots, x^n = \pi_{o_m}^{end}\}$.
We also compute the point of intersection $x^{aabb}$ of the ray from $x^1$ along the direction $\overrightarrow{(x^2, x^1)}$ with the axis-aligned bounding box of $o_m$.

\textsc{PlanPush} computes a collision-free path between successive pushes by planning in $\X_\R$ with all objects $\OI \cup \OM$ as obstacles to a point $x_{\text{push}}^{0}$ sampled around $x^{aabb}$\footnote{We sample $(x, y)$ coordinates for $x_{\text{push}}^{0}$ from $\mathcal{N}(x^{aabb}, \sigma I), \,\sigma = \SI{2.5}{\centi\meter}$. The $z-$coordinate is fixed at $\SI{3}{\centi\meter}$ above the shelf for the entire push action.}.
% We sample the $(x, y)$ coordinates from a Gaussian distribution $\mathcal{N}(x^{aabb}, \sigma I), \,\sigma = \SI{0.025}{\centi\meter}$. The $z-$coordinate is fixed at $\SI{3}{\centi\meter}$ above the shelf, and remains constant for the rest of the push trajectory.
% If such a path $\pi_0$ is found, \textsc{PlanPush} appends pushing actions $\pi_i, \,i = 2, \ldots n$ by running inverse kinematics (IK) in sequence for each straight line segment in the shortcut path.
If this path is found, \textsc{PlanPush} similarly samples points $x_{\text{push}}^{i}$ around each $x^i$ in the shortcut path.
It runs inverse kinematics (IK) in sequence for each segment of the push action between points $\left(x_{\text{push}}^{i-1}, x_{\text{push}}^{i}\right), i = \{1, \ldots, n\}$.
% Specifically, for each segment $(x^i, x^{i+1}),\, i = 1, \ldots n-1$, we sample $x_{\text{push}}^{i} \sim \mathcal{N}(x^i, \sigma I)$ as before to compute points to run IK towards to obtain the corresponding segment $\pi_i$ of the push trajectory.
% The final segment of the push trajectory $\pi_n$ is computed by running IK towards $x_{\text{push}}^{n} \sim \mathcal{N}(x^n, \sigma I)$.
% \textsc{PlanPush} tries to find a path to
% Algorithm~\ref{alg:push_planner} computes a push along the direction $\overrightarrow{(o_m, \pi_{o_m}^{end})}$ in an attempt to move object $o_m$ to $\pi_{o_m}^{end}$.
% We sample the initial and final $(x, y)$ coordinates for the first segment of our push, $x_{\text{push}}^{0}$ and $x_{\text{push}}^{1}$, from Gaussian distributions around $x_{aabb}$ and $x^1$ respectively.
% The final $(x, y)$ coordinates of the push  are similarly sampled around $\pi_o^{end}$.
% The $z-$coordinate is fixed at $\SI{3}{\centi\meter}$ above the shelf, and remains constant along the push action.
If all IK calls succeed, we return the full push trajectory by concatenating $\pi_0$ with all push action segments.
% such a path is found, the pushing action is computed by running inverse kinematics (IK) along the straight line $\overrightarrow{(x_{\text{push}}^{0}, x_{\text{push}}^{1})}$.
% If IK succeeds in computing the push action $\pi_2$, we return the full push trajectory by concatenating $\pi_1$ and $\pi_2$.
% Otherwise \MfM would proceed with computing a push for a different object.
% For paths $\pi_{o_m}$ with multiple straight line segments after shortcutting, we execute a sequence of IK calls between $\left\{\overrightarrow{(x_{\text{push}}^{0}, x_{\text{push}}^{1})}, \ldots, \overrightarrow{(x_{\text{push}}^{n-1}, x_{\text{push}}^{n})}\right\}$ where $x_{\text{push}}^{j}$ is sampled around the end point $\pi_{o_m}^{j}$ of the $j^{\text{th}}$ segment $(\pi_{o_m}^{0} \vcentcolon= x_{aabb})$.

This push action, informed by the \MAPF solution about \emph{which} object to move \emph{where}, is forward simulated with a physics model to verify whether it satisfies all interaction constraints for all objects.
If so, it is queued into the sequence of rearrangements that will be executed as part of the \MAMO solution returned by \MfM (Algorithm~\ref{alg:mfm}, Line~\ref{line:push_found}).

% \begin{algorithm}[t]
% \begin{small}
% \caption{Non-Prehensile Push Planner}\label{alg:push_planner}
% \begin{algorithmic}[1]

% \Procedure{PlanPush}{$o_m, \pi_{o_m}, \OM, \OI$}
%     \State $\textsc{ShortcutPath}(o_m, \pi_{o_m}, \OI)$
%     \State $aabb \gets \textsc{ComputeAABB}(o_m)$ \Comment{$o_m$ is the current pose}\label{line:aabb}
%     \State $x_{aabb} \gets \textsc{RayAABBIntersection}\left(aabb, \overrightarrow{(\pi_{o_m}^{end}, o_m)}\right)$ \label{line:x_aabb}
%     \State $x_{\text{push}}^{i} \sim \mathcal{N}(x_{aabb}, \sigma)$, $x_{\text{push}}^{f} \sim \mathcal{N}(\pi_{o_m}^{end}, \sigma)$ \Comment{$\sigma = \SI{0.025}{\centi\meter}$}\label{line:sample_push_points}
%     \State $\textsc{AddObstacles}(\OI \cup \OM)$
%     \State $\pi_1 \gets \textsc{PlanApproach}(x_{\text{push}}^{i})$ \Comment{MHA$^\ast$~\cite{AineSNHL16}}
%     \If{$\pi_1$ exists}
%         % \State $z \sim \textsc{SamplePushHeight}()$
%         \State $\textsc{RemoveObstacles}(\OM)$
%         \State $\pi_2 \gets \textsc{InverseKinematics}\left(\pi_1^{end}, \overrightarrow{(x_{\text{push}}^{i}, x_{\text{push}}^{f})}\right)$
%         \If{$\pi_2$ exists $\wedge\,\, \pi_2 \cap \mathcal{B}(o_m, o_m) \neq \emptyset$}
%             \Return $\pi_1 + \pi_2$
%         \EndIf
%     \EndIf
% \EndProcedure

% \end{algorithmic}
% \end{small}
% \end{algorithm}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\columnwidth]{figures/push_planner.pdf}
    \caption{2D illustration of our push planner. Given a movable object $o_m$ (blue) and its \MAPF solution path $\pi_{o_m}$ (pink), we shortcut $\pi_{o_m}$ while accounting for immovable obstacles $\OI$ (red) to get the green path of straight line segments. After computing $x^{aabb}$ by intersecting the $\protect\overrightarrow{(x^2, x^1)}$ ray with the axis-aligned bounding box for $o_m$, the push action (cyan) is computed via inverse kinematics between sampled points $x_{\text{push}}^{i} \sim \mathcal{N}(x^i, \sigma I), \,i = \{0,\ldots,n\}, \, x^0 \vcentcolon= x^{aabb}$.}
    \label{fig:push_algo}
\end{figure}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Theoretical Discussion}\label{sec:theory}

% The solution returned by \MfM lies on a discrete graph $G_0 = (V_0, E_0)$ whose vertices $V_0$ are \MAMO states in the composite configuration space $\X = \X_\R \times \X_{O_1} \times \cdots \times \X_{O_n}$ and edges $E_0$ correspond to actions taken by the robot arm.
% The iterative nature of \MfM greedily commits to valid push actions found during the search for a \MAMO solution.
% This notion of planning ``in the now''~\cite{KaelblingL11} drastically reduces search efforts since we do not consider (i) all feasible pushes for an object that needs to be rearranged to a specific location, (ii) all orderings of all feasible push actions to realise a particular rearrangement for a set of objects, and (iii) all possible rearrangements for a set of objects.
% The trade-off associated with the computational savings of being greedy makes \MfM \emph{incomplete} with respect to $G_0$.

% % Developing even a \emph{resolution complete} algorithm for \MAMO (with respect to $G_0$) remains a challenging open research question. % as it would require an extremely computationally expensive search on $G_0$ whose size grows exponentially with the number of objects.
% Two modifications to \MfM that introduce notions of \emph{backtracking} and \emph{feedback} would result in a resolution complete version with respect to $G_0$.
% First, for a particular rearrangement suggested by the \MAPF solver, we must consider all feasible pushes for an object and all orderings of these pushes for the set of objects that need to be rearranged.
% This can be formulated as a search over a discrete graph where nodes are \MAMO states and edges represent abstract actions to move an object, changing the greedy nature of \MfM to a systematic search inspired by the Minimum Constraint Removal problem~\cite{Hauser14}.
% Searching this graph is computationally expensive since each abstract action can correspond to multiple push actions, however this graph contains all possible orderings of all feasible pushes to realise a specific rearrangement.
% If this search fails to find a solution, we must query the \MAPF solver for a different solution since we failed to realise the previous one.
% This feedback loop would force the algorithm to systematically search over all possible rearrangements of the scene since the \MAPF solver, itself being complete with respect to $G_{\CBS}$, will find any possible rearrangement.
% Developing an \emph{efficient} version of such a resolution complete algorithm is ongoing work.

% % Given that \MfM uses a complete \MAPF solver, we can guarantee that our algorithm will return a potential rearrangement of the scene on graph $G_{\CBS}$ from Section~\ref{sec:key_idea}, if one exists.
% % In order to achieve this with \MfM, we need two forms of \emph{backtracking} in our search for a \MAMO solution on graph $G_0$:
% % \begin{enumerate}
% %     \item The ability to
% % \end{enumerate}

% % A planning algorithm is said to be \emph{complete} if it returns a solution to a planning problem provided one exists, or else returns failure (in finite time).
% % The completeness of our \MfM algorithm depends on three factors:
% % \begin{enumerate}
% %     \item 3D collision checking between the robot and objects.
% %     \item The use of a complete \MAPF solver.
% %     \item The ability to backtrack from a (non-empty) sequence of rearrangements, if the \MAPF solver returns failure.
% % \end{enumerate}
% % The first two factors are necessary since our \MAMO workspaces are in 3D and we try rearrangements based on \MAPF solutions.
% % If we collision check in 2D by projecting all agents down, we might detect spurious collisions that rule out possible \MAPF solutions.
% % Similarly, an incomplete \MAPF solver might potentially fail to find rearrangements that exist in the workspace.
% % The third factor is unique to our iterative approach to solve \MAMO problems.
% % Suppose at the $i^{\text{th}}$ iteration of \MfM, we found and sequenced a push action for an object $O_r$.
% % This object will be initialised at its new pose (the result of the successful push action) for the $i+1^{\text{th}}$ call to the \MAPF solver.
% % It is possible that there is no solution to this \MAPF problem.
% % % This might happen due to the discrepancy between the true configuration space of movable objects $(\X_{O_r} \equiv SE(3))$ and the fact that they effectively move in the Euclidean plan $\mathbb{R}^2$ in the \MAPF problem.
% % This might happen because a push trajectory fails to precisely move the object along $\pi_{O_r}$ which was computed without any physics modelling in the \MAPF solver.
% % This leads to a different rearrangement than the $i^{\text{th}}$ \MAPF solution and even a complete \MAPF solver might fail to find a solution at the $i+1^{\text{th}}$ iteration.
% % We call this a \emph{stalemate} to signify that the rearrangement itself is valid (no interaction constraints were violated thus far), but we cannot make further progress towards a \MAMO solution.

% % \begin{proposition}\label{prop:complete}
% % \MfM is complete if it uses a full 3D collision checker within all motion planners, it uses a complete \MAPF solver, and it is able to account for or backtrack from stalemates.
% % \end{proposition}

% % As presented in Algorithm~\ref{alg:mfm}, \MfM is \emph{incomplete} since it has no ability to backtrack from stalemates.
% % However, we can modify \MfM in two different ways to make it complete.
% % We could deem any push trajectory that does not precisely move $O_r$ along $\pi_{O_r}$ invalid.
% % This would limit \MfM to sequencing only those pushes that do not diverge from the rearrangement prescribed by the \MAPF solver.
% % Thus, as long as the initial \MAPF abstraction is solvable, \MfM would solve the \MAMO problem.
% % The second way to modify \MfM is inspired by the constraint trees used in conflict-based search (\CBS)~\cite{SharonSFS12}.
% % Whenever \MfM ends up in a stalemate, we can exercise one of two options.
% % The first is to compute a different push trajectory for $O_r$ in order to end up with a different scene rearrangement than the stalemate.
% % Alternatively, we can deque the last push queued and add a constraint for the corresponding object (in the above example the constraint would prevent $O_r$ from moving along $\pi_{O_r}$).
% % This generates a new \MAPF problem for us to solve whose solution may not lead to a stalemate.
% % Searching for a solution in this binary tree will lead to a \MAMO solution (if one exists) as the nodes of this tree span the space of all possible rearrangements of the scene.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{A Note on Practical Efficiency of \MAPF Solvers}

% % \MAPF solvers like
% \CBS~\cite{SharonSFS12} and \textsc{M*}~\cite{WagnerC11} attain theoretical completeness at the cost of practical efficiency.
% Even improved versions of the original algorithms~\cite{LiEECBS,WagnerC15} are hard to scale beyond 2D gridworld environments and point robots.
% They scale especially poorly with an increasing number of inter-agent conflicts, which is exacerbated by higher-dimensional search spaces\footnote{Constraints in \CBS affect one state at a time, and \textsc{M*} couples agents to find conflict-free paths in the compound space. Both techniques suffer greatly as the dimensionality of the individual search spaces increase.}.
% This is inherently true for \MAMO where the robot plans in $\X_\R$, and even though movable objects move in $\mathbb{R}^2$, collision checking is done in 3D.
% In contrast, theoretically incomplete \MAPF solvers like Windowed Hierarchical Cooperative A* (\WHCA)~\cite{Silver05} can be scaled to complex kinodynamic robot motion planning problems~\cite{8637037}.
% For this reason, our results in Section~\ref{sec:exps} use \WHCA as our \MAPF solver in \MfM.
% We also compare the effect of collision checking only in 2D (using projections of the \MAMO workspace), against a hybrid where full 3D collision checking is performed only if 2D collisions are detected.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Experimental Results}\label{sec:exps}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simulation Experiments}\label{sec:sim_exps}

We run our simulation experiments in \MAMO workspaces of three difficulty levels shown in Fig.~\ref{fig:levels}.
Each workspace has one OoI (yellow), four immovable obstacles (red), and different numbers of movable objects (blue).
Objects are cylinders and cuboids with random sizes, initial poses, masses, and coefficients of friction.
We assume perfect knowledge of the initial workspace state and all object parameters.
We set a planning timeout of $\SI{120}{\second}$ for 100 randomly generated \MAMO problems at each level.
% We compare performance based on success rate, total planning time, and time spent querying the physics-based simulator on 100 randomly generated \MAMO problems at each level.
Our analysis includes two versions of our algorithm -- \MfM refers to Algorithm~\ref{alg:mfm}, and $\widehat{\MfM}$ refers to a version which only calls \CBS once (after Line~\ref{line:ngr}) and does not iterate between calling \CBS and finding a valid push in simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsubsection{Baselines}\label{sec:baselines}

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.65\columnwidth]{figures/2d_ui.eps}
%     \caption{Three 2D paths drawn by an expert user for the \UI baseline are shown in different colours. Stars on the paths in correspond to the indicated pushing locations for each path.}
%     \label{fig:2d_ui}
% \end{figure}

\textbf{Baselines: }
We compare the performance of \MfM against three types of baselines for solving \MAMO problems with non-prehensile interactions.
The first are standard implementations of sampling-based algorithms \KPIECE~\cite{KPIECE} and RRT~\cite{RRT} from OMPL~\cite{OMPL} that search the entire \MAMO state space $\X$ by randomly sampling robot motions.
% Our experiments used open-source implementations of these algorithms from OMPL~\cite{OMPL}.
% \KPIECE~\cite{KPIECE} is a sampling-based planning algorithm that uses a notion of information gain to grow its randomised search tree towards more promising areas of the workspace.
% The rationale is that we are more likely to query the physics-based simulator (the most computationally expensive operation) for actions that lead us to a solution.
% We use our own implementation of \KPIECE which includes some of the improvements suggested in~\cite{KPIECE} and performs better than the standard implementation from OMPL~\cite{OMPL}\footnote{Our implementation uses goal biasing, multiple levels of discretisation, and adds all intermediate states of ‘motions’ to the search tree. The implementation from OMPL~\cite{OMPL} only uses goal biasing.}.

% For the first baseline, an expert user is shown a 2D image of the \MAMO workspace (like the one from Fig.~\ref{fig:conflict_graph}) and is asked to draw independent 2D paths in this workspace that might be beneficial for the robot to track and approach the OoI.
% Along these paths, the user can also indicate locations at which the robot should consider executing a directional push action to rearrange the movable objects.
% % Although the user is free to draw as many trajectories with as many push locations as they desire, planning efficiency drops drastically with increase in these numbers.
% For the purpose of our evaluation, we provide up to four paths with up to four push locations along them.
% Fig.~\ref{fig:2d_ui} shows an example of a scene with three paths input by the user.
% The planning algorithm searches over the graph defined by actions that track the 2D path between waypoints, and actions that execute directional pushes at those waypoints (we allow four possible push directions).
% This baseline is referred to as \UI in the following discussion.
% At the start of each 2D path and at each specified push location, the planner can execute a probe action to the next push location (or the end of the 2D path).
% At each push location and the end of the 2D path, it can execute a straight-line push action.

The second baseline, Selective Simulation~\cite{SelSim} (\SelSim), is a search-based algorithm that interleaves a `planning' phase and a `tracking' phase.
The former queries the physics-based simulator for interactions with a set of `relevant' movable objects identified so far.
The latter executes the solution found by the planning phase in the presence of all objects in simulation and, if any interaction constraints are violated, it adds the `relevant' object to the set.
It only uses the simple motion primitives described in Section~\ref{sec:prelims}.

Our final baseline is the work from Dogar et al.~\cite{DogarS12} (\Dogar) which introduced the idea of a negative goal region (NGR) we use in \MfM.
\Dogar recursively searches for a solution backwards in time, similar to~\cite{StilmanMAMO}.
It first finds an OoI retrieval trajectory ignoring all movable objects.
The NGR induced by this trajectory helps identify a set of objects to be rearranged, and the OoI is added as an obstacle.
If an object is successfully rearranged, the NGR and set of objects still to be rearranged are updated with the trajectory found, and the rearranged object is added as an obstacle at its initial pose.
This process continues until no further objects need to be rearranged. % and the sequence of trajectories found can be executed in reverse order (ending in OoI retrieval).
Our implementation of \Dogar finds the same OoI retrieval trajectory as \MfM, and uses the same push actions (Section~\ref{sec:push_actions}) to try and rearrange objects.
Notably, \Dogar only has information about \emph{which} objects to move but not \emph{where} to move them.
% Thus we randomly sample the end locations outside the latest NGR for the push actions.
Our implementation finds the closest cell outside the latest NGR for an object and samples points around this location to try to move the object towards.
% After finding a trajectory to retrieve the OoI in the absence of all movable objects, it identifies objects in the induced NGR that need to be rearranged.
% For any object it tries to rearrange, the NGR is computed as the union of all robot and object trajectory volumes found thus far, all movable objects for which a rearrangement action has been found are considered obstacles at their initial locations, while all other movable objects are ignored.
% If a rearrangement action is found, the NGR, list of objects yet to be moved, and list of objects to be avoided are updated for the subsequent recursive call.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % \subsubsection{Results}\label{sec:sim_results}
% \MfM samples one push in \textsc{SamplePushes} (Line~\ref{line:sample_push}) per rearrangement considered.
% The \MAPF solver (Line~\ref{line:plan_mapf}) uses a 2D projection of the \MAMO workspace for collision checking between the single-agent solution paths.
% We collision check against immovable obstacles in 3D when computing these single-agent solutions.
% The projected 2D space contains the footprint of all objects.
% The robot arm is projected to 2D by approximating the upper arm, forearm, and end-effector of our PR2 robot as rectangles of fixed width (based on the forward kinematics of these links at each waypoint along the path of the robot $\pi_{\R}$).

\begin{table*}
\centering
\caption{Simulation Study for \MAMO Planning in Cluttered Scenes - success rates and \emph{min/median/max} planning and simulation times}
\label{tab:sim_main}
\begingroup
% \setlength{\tabcolsep}{4pt}
\begin{tabular}{@{}cccccccc@{}}
\toprule
\multirow{2}{*}{\textbf{Metrics}} & \multirow{2}{*}{\textbf{Level}} & \multicolumn{6}{c}{\textbf{Planning Algorithms}} \\
\cmidrule{3-8}
& & \textbf{\MfM} & $\widehat{\MfM}$ & \Dogar~\cite{DogarS12} & \SelSim~\cite{SelSim} & \KPIECE~\cite{KPIECE} & \RRT~\cite{RRT}  \\ \midrule
\multirow{3}{*}{\shortstack{Success\\ Rate $(\%)$}} & 1 & 92 & 79 & 40 & 33 & 48 & 55 \\
 & 2 & 73 & 54 & 20 & 21 & 33 & 40 \\
 & 3 & 62 & 36 & 6 & 16 & 17 & 26 \\ \midrule
\multirow{3}{*}{\shortstack{Total\\ Planning\\ Time $(\SI{}{\second})$}} & 1 & 1.0 / 2.6 / 102.5 & 1.0 / 2.4 / 103.8 & 0.1 / 0.9 / 115.3 & 0.004 / 0.02 / 0.03 & 7.4 / 23.4 / 117.8 & 7.1 / 15.8 / 101.4 \\
 & 2 & 1.2 / 6.6 / 115.4 & 1.3 / 2.6 / 100.3 & 0.3 / 0.5 / 113.5 & 0.002 / 0.008 / 0.2 & 9.3 / 28.2 / 112.0 & 8.6 / 27.6 / 104.9 \\
 & 3 & 1.3 / 7.2 / 116.1 & 1.6 / 2.4 / 72.6 & 0.2 / 0.4 / 55.0 & 0.004 / 0.01 / 0.03 & 10.6 / 32.0 / 98.5 & 10.3 / 26.7 / 113.4 \\ \midrule
\multirow{3}{*}{\shortstack{Simulation\\ Time $(\SI{}{\second})$}} & 1 & 0 / 0 / 58.6 & 0 / 0 / 20.1 & 0 / 0 / 42.0 & 27.3 / 35.0 / 43.6 & 0 / 10.6 / 99.0 & 0 / 4.4 / 87.2 \\
 & 2 & 0 / 0.4 / 75.9 & 0 / 0 / 37.0 & 0 / 0 / 20.9 & 36.7 / 44.1 / 58.3 & 0 / 16.1 / 95.4 & 0 / 16.7 / 83.7 \\
 & 3 & 0 / 0.4 / 55.1 & 0 / 0 / 24.3 & 0 / 0 / 20.0 & 47.3 / 55.7 / 76.0 & 0 / 18.3 / 79.3 & 0 / 15.3 / 101.2 \\ \bottomrule
\end{tabular}
\endgroup
\end{table*}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\columnwidth]{figures/levels.pdf}
    \caption{\MAMO problems of differing complexity. From \emph{left} to \emph{right}, Levels 1, 2, and 3 have 5, 10, and 15 movable objects respectively. Each Level has 1 OoI and 4 immovable obstacles.}
    \label{fig:levels}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/m4m.png}
    \caption{A \MAMO solution generated by \MfM. The tomato soup can (yellow outline) is the OoI, all other objects are movable.}
    \label{fig:pr2_soln}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Results: }
Table~\ref{tab:sim_main} shows the result of our experiments where we present the \emph{min}$/$\emph{median}$/$\emph{max} values for total planning time and simulation time of successful runs only.
Experiments were run on a $\SI{4}{\giga\hertz}$ Intel i7-4790K CPU with $\SI{28}{\giga\byte}$ $\SI{1600}{\mega\hertz}$ DDR3 RAM.

Both versions of \MfM solve the most problems across all difficulty levels.
For Levels 1, 2, and 3, the \MfM solution successfully executed $0.8$, $1.9$, and $3.1$ push actions on average.
The difference in performance between \MfM and $\widehat{\MfM}$ highlights the benefit of the iterative nature of \MfM.
% The \MAPF solver does not utilise any information about robot kinematics or the complex multi-body interaction dynamics.
Since \MAPF paths are usually not precisely replicated in simulation via pushes, querying the solver repeatedly with an updated workspace configuration leads to more informed future paths for objects, instead of trying to forcibly push them to the first goal configuration suggested by \MAPF.
% It is evident from Table~\ref{tab:sim_main} that an informed rearrangement strategy from the \MAPF solution and an expressive action space in the form of our push planner helps \MfM far outperform all baselines.
% \MfM solves almost twice as many \MAMO problems as any of the other baselines, with comparable or better planning times than all except \SelSim which only solves problems where the first tracking iteration (without any movable objects) is successful.
% Even in the worst case our simulation time is $10-83\%$ better than \KPIECE and \RRT.
% In contrast, \Dogar spends planning time trying to find valid pushes that may be simulated leading to low simulation times in general.
% The pushes considered by \MfM are informed by the \MAPF rearrangement and are more likely to be simulated than the uninformed sampling of pushes performed by \Dogar.

All baseline algorithms from Table~\ref{tab:sim_main} suffer due to poor exploration over the space of rearrangements. %, in addition to a poor action space.
Our approach benefits from the \MAPF abstraction to produce guidance on \emph{where} to move each object to free up the NGR.
The stochastic sampling of push actions used by our push planner leads to complex, multi-body non-prehensile interactions that satisfy interaction constraints in the final solution.
In contrast \Dogar naively samples pushes to be simulated, and necessarily tries to ensure there is no overlap between the NGR and movable objects, even if a slightly different collision-free path can be found to retrieve the OoI (Algorithm~\ref{alg:mfm}, Line~\ref{line:finalise_plan}).
This strategy suffers when sampled points are near immovable obstacles, and limits the possible rearrangements considered since movable objects that are rearranged successfully are treated as immovable obstacles.
% Moreover, it has no information about \emph{where} to move objects that overlap with the NGR which results in uninformed sampling of pushes to be simulated.
\Dogar also never executes a potential trajectory until there is no overlap between the NGR and movable objects, unlike \SelSim which simulates all trajectories found during planning.
In fact, all \SelSim successes in Table~\ref{tab:sim_main} correspond to scenes where the very first planned trajectory succeeds in OoI retrieval in simulation.
This is only true when there is minimal overlap between the NGR and movable objects.
When any movable object needs to be rearranged, \SelSim suffers from its poor action space -- the simple motion primitives are ineffective at causing meaningful robot-object interactions in the workspace. %, especially since rearranging objects requires the \SelSim search to explore against the heuristic guiding it towards the goal (OoI grasp or home pose).
\KPIECE and \RRT benefit significantly from goal biasing in simpler scenes where either little to no robot-object interactions are required or the objects that need to be moved have nice physical properties (large supporting footprint, low center-of-mass, low coefficient of friction).

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.5\columnwidth]{figures/intro2.png}
%     \caption{Real-world setup for pick-and-place \MAMO experiments with a PR2. The tomato soup can (yellow outline) is the object-of-interest.}
%     \label{fig:pr2_setup}
% \end{figure}

% With respect to the baseline algorithms, across all levels \textsc{SelSim} only solved \MAMO problems that did not require any simulation.
% This occurs when the first path found for the robot successfuly retrieves the OoI without interaction constraint violations (even if it made contact with movable objects).
% Since \textsc{SelSim} uses a simple robot action space\footnote{Independed robot arm joint angle changes.} which leads to small robot-object interactions, it cannot proactively rearrange the scene.
% The \textsc{UI} baseline is restricted to specific 2D paths drawn by the user and therefore cannot find simple solution paths like \textsc{SelSim}.
% However, since it tries to rearrange the scene via push actions, it solved $6/50$ problems at Level 3.

% \MfM far outperforms both these baselines as it can exploit simple, interaction-free paths if they exist and proactively work towards rearrangements of the scene that enable \MAMO success.
% For Levels 1, 2, and 3, the \MfM solution successfully executed $1.3$, $1.9$, and $3.1$ rearrangement actions on average.
% The iterative nature of \MfM leads to a judicious use of the total planning budget.
% \MfM balances time spent between solving a \MAPF problem without the use of simulator, and achieving the resultant rearrangement by querying the simulator with informed push actions.
% % It does not need to repeatedly query the simulator to find a suitable rearrangement, which allows repeated queries .
% % Instead
% % between searching for useful rearrangements via \MAPF solutions and realising them via non-prehensile pushes.
% This is reflected in Table~\ref{tab:sim_main} as \MfM spends proportionately less time in simulation compared to \textsc{UI}.
% It also solves more \MAMO problems than either baseline at all levels since the \MAPF solution vastly reduces the space of pushes \MfM needs to consider.
% The increase in success rate for \MfM over \textsc{SelSim} on Level 1 and 2 problems shows that the \MAPF solution leads us to useful rearrangements.
% These rearrangements, computed specifically to lead us to a \MAMO solution, help us solve an additional $32\%$ and $36\%$ of problems from Level 1 and 2.
% We also solve $40\%$ of extremely difficult Level 3 problems, all of which require at least one object to be rearranged.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Real-World Performance on the PR2}\label{sec:pr2_exps}

We ran \MfM on a PR2 robot where we used a refrigerator compartment as our \MAMO workspace (Fig.~\ref{fig:pr2_soln}).
We placed five objects from the YCB Object Dataset~\cite{YCB} in the refrigerator.
Four of these were movable and the tomato soup can was the object-of-interest.
Objects were localised using a search-based algorithm~\cite{Agarwal2020PERCH2} run on a NVidia Titan X GPU.
% Fig.~\ref{fig:pr2_setup} shows an image of this setup in our lab.
We gave \MfM a total planning timeout of $\SI{120}{\second}$.


% \begin{table}
% \centering
% \caption{Quantitative Performance for Real-World Experiments}
% \label{tab:realworld}
% \begingroup
% % \setlength{\tabcolsep}{4pt}
% \begin{tabular}{ccc}
% \toprule
% % \multicolumn{3}{c}{\textbf{Metrics}} \\
% % \cmidrule{1-3}
% \textbf{Success Rate} & \textbf{Total Planning Time $(\SI{}{\second})$} & \textbf{Simulation Time $(\SI{}{\second})$} \\ \midrule
% 75$\%$ & 56.41 $\pm$ 27.29 & 49.26 $\pm$ 24.21 \\ \bottomrule
% \end{tabular}
% \endgroup
% \end{table}


Out of 16 perturbations of the initial scene from Fig.~\ref{fig:pr2_soln}, 12 runs successfully retrieved the OoI.
Across the successful runs the planner took $56.41 \pm 27.29 \,\SI{}{\second}$ to compute a plan of which $49.26 \pm 24.21 \,\SI{}{\second}$ was spent simulating pushes.
% Table~\ref{tab:realworld} contains the result of these runs.
% We report the average and standard deviation for planning and simulation time.
Failures were due to interaction constraints being violated during execution by the PR2.
Since \MfM returns a solution that does not violate constraints in simulation, failures are due to modelling errors between the simulator and the real-world.
Specifically, accurately computing coefficients of friction is difficult and can lead to differing contact mechanics in simulation than the real-world.
Fig.~\ref{fig:pr2_soln} shows the solution to a \MAMO problem being executed by the PR2.
It moves the coffee can out of the way, pushes the potted meat can slightly aside, and finally the OoI (tomato soup can) is extracted while also nudging the potted meat can.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Comparison of \MAPF Solvers}\label{sec:pr2_exps}

% \MfM uses a resolution complete \MAPF solver (\CBS) to ensure it does not miss any potential rearrangement of a scene (with respect to the graph $G_{\CBS}$ of the low-level \CBS searches).
% Another class of \MAPF solvers assigns priorities to agents and solves a sequence of single-agent planning problems based on this prioritisation~\cite{ErdmannL87}.
% This \emph{prioritised planning} (\PrPl) scheme trades off algorithmic incompleteness and solution suboptimality for practical efficiency.
% For all the problems solved by \MfM in Table~\ref{tab:sim_main}, we compare the performance of \CBS against \PrPl in terms of success rates for an initial solution and planning times.

% Being provably complete, \CBS succeeds in finding an \MAPF solution $100\%$ of the time.
% Given the same $\SI{30}{\second}$ timeout as \CBS, \PrPl failed to find solutions for 2 Level 1 problems, 9 Level 2 problems, and 9 Level 3 problems.
% The bottleneck for \MAPF is collision checking between objects in $SE(3)$.
% \CBS only collision checks solution trajectories returned by the low-level searches of the corresponding agents.
% In addition to being incomplete, \PrPl turns out to also be much slower than \CBS.
% This is because \PrPl collision checks every state expanded by the low-level search against corresponding states of higher priority agents, which is slow when many agents collide with each other along their solution paths.
% We compare the ratio of planning times for \CBS to those for \PrPl across the three levels.
% The median value of this ratio $T_{\CBS}/T_{\PrPl}$ for Level 1 is $1.22$ (\PrPl is at least $22\%$ faster in half the problems).
% For Levels 2 and 3, this value is $0.89$ (\PrPl is at least $11\%$ slower in half the problems) and $0.63$ (\PrPl is at least $37\%$ slower in half the problems).
% The ability to solve all problems and in less time when the \MAMO problem is more complicated highlights the benefit of using \CBS over \PrPl.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % \subsubsection{Number of Sampled Pushes}\label{sec:push_samples_exp}
% \textbf{Number of Sampled Pushes: }
% The results for \MfM in Section~\ref{sec:sim_exps} tried to generate a single push trajectory in Lines~\ref{line:sample_push} to~\ref{line:plan_push} in Algorithm~\ref{alg:mfm} whenever an object rearrangement was attempted.
% The planner was given a $\SI{0}{\second}$ timeout to sample one push -- no more than one sample was generated.
% We compare the performance of this version of \MfM versus another that may generate up to four pushes in $\SI{4}{\second}$.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % \subsubsection{Collision Checking Scheme}\label{sec:cc_exp}
% \textbf{Collision Checking Scheme: }
% For the purpose of practical efficiency, we study the effect of different collision checking schemes used by the \MAPF solver run by \MfM.
% We try two different strategies -- collision checking in a projected 2D space as in Section~\ref{sec:sim_exps}, and a hybrid collision checker where we collision check in 3D if a collision is detected in 2D.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% shows a comparison between $\MfM(1, 0 \,\lvert\, \textsc{2D})$, $\MfM(1, 0 \,\lvert\, \textsc{Hybrid})$, $\MfM(4, 4 \,\lvert\, \textsc{2D})$, and $\MfM(4, 4 \,\lvert\, \textsc{Hybrid})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion and Discussion}\label{sec:discussion}

This paper presents \MfM: Multi-Agent Pathfinding for Manipulation Among Movable Objects, an algorithm to plan for manipulation in heavy clutter that considers complex interactions such as rearranging multiple objects simultaneously, and tilting, leaning and sliding objects.
% These \MAMO problems include interaction constraints that define how the robot is allowed to interact with objects.
% \MfM decouples the search over all rearrangements of movable objects from the need to query a physics-based simulator.
% It first constructs and solves an appropriate \MAPF abstraction for \MAMO to search over all rearrangements without the need to query a physics-based simulator.
% This \MAPF solution helps the push planner generate informed non-prehensile rearrangements that are simulated for interaction constraint verification.
% We recognise that if we artificially actuate these movable objects and solve an appropriately constructed abstract \MAPF problem, the solution informs us of a suitable rearrangement for completing the original \MAMO task.
% The \MAPF formulation searches over object configurations without a simulator, and upon returning a solution, \MfM computes non-prehensile push actions to realise the suggested rearrangement within the simulator.
% Thus, \MfM is able to find a suitable rearrangement of the \MAMO workspace without querying a physics-based simulator and attempts to rearrange movable clutter without needing to search the space of all rearrangements of the scene for an appropriate one to complete the \MAMO task.
\MfM uses a \MAPF abstraction to the \MAMO problem to find suitable rearrangements, and a non-prehensile push planner to realise these rearrangements by utilising complex multi-body interactions.
It dramatically outperforms alternative approaches that do not reason about such interactions efficiently.

% The key contribution of this paper, an application of \MAPF solvers within \MAMO, leads to several distinct areas of future research.
\MfM greedily commits valid pushes found to its sequence of rearrangement trajectories.
This greedy behaviour makes \MfM incomplete, given that it has no ability to backtrack from this decision.
In the future we hope to address this incompleteness of \MfM by developing an algorithm that considers (i) all feasible pushes for an object that needs to be rearranged to a specific location, (ii) all orderings of all feasible push actions to realise a particular rearrangement for a set of objects, and (iii) all possible rearrangements for a set of objects.
Additionally, the \MAPF solver used in \MfM should be modified to use a cost function which has information about robot kinematics and pushing dynamics so as to compute and thus simulate better push actions.
% Using a model-based push planner, even for simple straight-line pushes like those used by \MfM, will greatly reduce the time \MfM currently spends stochastically sampling and simulating valid pushes.
% \MfM currently terminates with success when it has found a complete sequence of rearrangement actions that help solve the \MAMO task.
% Modifying it to interleave planning and execution can help introduce robustness by allowing \MfM to replan from the current rearrangement of the scene.
% We can also augment the \MAPF solver with information from past execution steps that constrain the motions of some movable objects.
% The key idea of this work is more broadly applicable to other \MAMO problems like assembly/disassembly planning and box packing.
% Both of these may also require a physics-based simulator in-the-loop and investigating the direct adoption of \MfM for these domains would be an exciting extension to this work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\balance
\bibliographystyle{IEEEtran}
\bibliography{references}



\end{document}
