For simplicity, we focus on box-shaped objects with only one of three dimensions within the gripper's graspable width. 

The pivoting task is divided into three sub-tasks. The first task covers visual object pose detection where the 6D pose of the box is estimated. The second task generates the grasp pose, which is placed on a point along the top edge of the box based on a user input. Finally, closed loop gripper width control is used to grasp the object, and further regulates slip during the pivot motion. A force-based end-effector position controller is also used to amend a pre-planned end-effector path, aiming to maintain contact between the grasped box and the surface. The control loop runs until the robot is able to complete the pivoting task, or when all waypoints of the pre-planned path have been executed. This overall structure of the system is illustrated in Fig.\ref{fig: module}.


% \begin{figure*}[ht]
%     \centering\includegraphics[scale=0.28]{Pics/flowchart.png}
%     \caption{Flowchart of the system}
%     %the robot will generate a grasp pose from visual image captured by a camera, then try to pivot the object in an arc from its current pose up to a certain degrees either clockwise or anti-clockwise (depends on where the robot will grasp the object). The radius of the arc is determined from the object's dimensions.}
%     \label{fig: flowchart}
% \end{figure*}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\linewidth]{Pics/new_pics/system_diagram_edited_v2.drawio.png}
    \caption{System diagram}
    \label{fig: module}
\end{figure}

\subsection{Object Pose Estimation}
\label{sec:box_pose_estimation}

An RGB-D side camera is used to detect the ArUco marker placed in the center of the largest surface of the box. Based on this marker detection as well as the box dimensions, the box pose can be inferred by offsetting the marker's pose by half of the box's respective dimension. The 6D pose of the box's axis of origin is defined at its centre point with an orientation that aligns the axes so that they are parallel with the length, width and height of the box. 

\subsection{Grasp Pose Synthesis} 

From the box's pose, a feasible grasp pose is generated using the known dimensions of the box. The gripper grasps the box such that the gripper is perpendicular to the table surface, i.e. the gripper is pointing down into the table. The grasp pose is also positioned ensuring that the sensing elements of the tactile sensors make full contact with the box. Given that there is only one graspable dimension, the robot can only grasp along one surface of the box. %The user is able to input a number to choose which end of the box should be grasped.  

The placement of the grasp pose on the top corner of the box prevents the box from being stopped by the gripper palm during the pivoting motion, and allows it to fit through the gap between the fingers. The grasp point relative to the box, as well as the orientation of the gripper, is maintained during the pivoting action. For a given grasp point, the pivot direction is always chosen such that the grasp point and pivot point are on opposite sides of the box. This is demonstrated in Fig.\ref{fig:intro}.
    


\subsection{Closed Loop Control}\label{closed_loop}
To successfully pivot the box we employ a robot end-effector position controller and a gripper controller. These controllers will adjust both the robot end-effector path and the gripper width respectively throughout the pivoting motion.

We analyse the expected forces applied to the sensors during the pivot process assuming equilibrium conditions during the pivot action, corresponding to a constant speed rotation, as illustrated in Fig.\ref{fig: force_profile}. Torque applied on the box by the gravitational force $F_g$, with the centre of mass assumed to be at the centre of the box, is balanced by the forces applied to it from the pivoting motion $F_p$. 
    
    \begin{figure}[h]
        \centering\includegraphics[width=0.3\columnwidth]{Pics/force_profile_symbols.png}
        \caption{Free-body diagram of a pivoting box under equilibrium conditions}
        \label{fig: force_profile}
    \end{figure}
    
    The wrist sensor measured force in the vertical (z) direction is the vertical component of the pivoting force $F_p$, $f_p^z$:

    \begin{equation}
        f_p^z = \frac{F_g sin(\alpha)cos(\beta)}{2}
    \end{equation}

    The above equation can then be expressed with respect to the pivot angle between the base of the box and the surface, $\varphi$, and specific properties of the box, including the angle between its base and diagonal, $\theta$, its mass $m$, and gravity constant $g$:

    \begin{equation}\label{eq:pivot_force}
        f_p^z(\varphi) = \frac{mg sin(\frac{\pi}{2} - \varphi - \theta)cos(\varphi + \theta)}{2}
    \end{equation}

    This expected force profile is used in relation to the force measured by the wrist sensor to control the robot.

%\par\vspace{\baselineskip}
%\begin{enumerate}
    %\item 
    \noindent\textbf{Initial Gripper Width:} Determining an adequately loose grip is essential to allow the box to rotate in-hand. To grasp the box, the gripper fingers are set to continue closing until the total force in the direction normal to the box surface, as measured by the two tactile sensors, exceeds a threshold. 
    
    This force threshold is set to ensure that the gripper does not experience translational slip initially. This requires the static friction force between the gripper fingers and the box to be greater than the pivoting force $f^z_p$ applied to the box at the start of the motion, when the pivot angle $\varphi$ is infinitesimally small. The static friction force $F\textsubscript{static}$ is calculated from empirically tested friction coefficient $\mu_s$ and the normal force $F_N$ exerted through contact as measured by the tactile sensors, giving the grip force threshold: 

    \begin{equation}
        F\textsubscript{static} = \mu_sF_N  > f_p^z(\varphi \approx 0)
    \end{equation}
    
    % \begin{equation}
    %     F_N > f_p^z(\varphi \approx 0) % init_ft_force from code
    % \end{equation}
    
    % Additionally, to speed up the grasping process, the gripper first closes to a distance slightly larger than the known dimensions of the box before executing the grasping algorithm. The fingers do not make contact with the box during this action.

     
    
    \noindent\textbf{Force-based Position Controller:} The robot force-based position controller controls and updates the arm's path throughout the pivoting motion. % This controller utilises the force/torque wrist sensor which provides force readings, and the RGB side camera which detects and estimates the box's rotation angle as the robot pivots the box. 
    
    We represent a complete pivoting motion with the pivot point of the object remaining in contact with the surface by the ideal pivoting force profile described by Equation \ref{eq:pivot_force}. The controller will then maintain contact by tracking this profile. The force exerted by the robot is controlled by applying a vertical offset to a pre-planned arc path for the end-effector. 





    Initially, a Cartesian path consisting of 50 waypoints is generated to traverse an arc parameterised by the box's dimensions. 50 waypoints are used as a balance between time taken to complete the movement and maintaining the arc with radius as the distance between the grasp point and the pivot point. For a box grasped at the top corner, the radius would become its diagonal, as seen in Fig.\ref{fig:arc}. 

    \begin{figure}[!ht]
        \centering\includegraphics[width=0.7\linewidth]{Pics/new_pics/arc.pdf}
        \caption{Path Analysis: the box is pivoting from the solid line position to dashed line position. O represents the pivoting center, P is the grasp point at the beginning of the pivot and Q is the corresponding point of P after pivoting. When the grasp point is at point P, the corresponding pivot angle $\varphi$ is 0\degree, whereas at point Q $\varphi$ is 90\degree.}
        \label{fig:arc}
    \end{figure}
    
    To pivot the box from point $P$ to point $Q$, the movement required to get to each waypoint on the arc trajectory from the starting point $P$ is given as:
    \begin{equation}\label{eq:path_x}
        \Delta x = L - r \cdot cos(\varphi + \theta)
    \end{equation}
    \begin{equation}\label{eq:path_z}
        \Delta z = r \cdot sin(\varphi + \theta) - W
    \end{equation}

    
    where $L$ is the length of the box, the arc radius $r$ is the diagonal of the box and $\varphi$ is the pivot angle between the surface and the base of the box.


    The MoveIt motion planning API is then used to generate and execute the timed trajectory for the robot end effector between each waypoint. It computes straight line path segments between the start and end using linear interpolation. The velocity and acceleration of the trajectory is then derived with an algorithm termed iterative parabolic time parameterisation, which generates parabolic blends to smooth the planned paths and adhere to velocity and acceleration limits \cite{kunz2011turning}. 
    % The robot will move according to this pre-generated plan, while the controller continuously checks that the box's rotation angle does not exceed the goal rotation angle, which is 90 degrees for a complete pivot, to ensure the box stops appropriately.  

    

    % To close the loop for dynamic pivot action, we use an analytical force profile in the vertical dimension to detect and ensure that the box remains in contact with the surface. 
    % From empirical tests, the relationship between the height that the gripper lifts the box up to and the force measured by the wrist sensor during surface-contact pivoting was found to be roughly linear. Thus, to control the force applied to the box, a vertical offset is applied to the trajectory for every waypoint. 

    Using the above information including Equation \ref{eq:pivot_force}, the position controller is implemented, and described in Alg.\ref{alg:traj}. At each waypoint, the ideal force $f_{ideal}$ is predicted using the rotation angle of the box, estimated using vision. The measured force $f_{real}$ is then compared to the ideal force to produce an error, and accumulated in $error_{accum}$. The vertical offset that should be applied is then calculated from the force error using Proportional-Integral (PI) control, with proportional constant $K_p$ and integral constant $K_i$, both empirically tuned. The offset is applied to all waypoints, and adjusted incrementally during each iteration. This aims to maintain the offset that minimises the error between the two force values. The pre-planned waypoint is updated by applying this offset to the vertical dimension, and trajectories are generated by MoveIt so that the robot moves in accordance to the adjustment. If at any point the rotation angle is estimated to be greater than or equal to 90\degree, it is assumed that the pivot is complete and the program will terminate. 

    \begin{algorithm}
    \caption{Force-based position controller, using z as the vertical dimension}\label{alg:traj}
    \begin{algorithmic}
    \State $\mathit{offset} \gets 0$ 
    \State $error_{accum} \gets 0$
    \FOR{\textit{waypoint} \textbf{in} \textit{path}}
        \State $\varphi \gets $ vision detection
        \State $f_{real} \gets $ force torque sensor
        \State $f_{ideal} \gets $ $f_p^z(\varphi)$ (Equation \ref{eq:pivot_force})
        \IF{$\varphi < 90\degree$}
            \State $error \gets |f_{ideal} - f_{real}|$
            \State $error_{accum} \gets error_{accum} + error$
            \State $\mathit{offset} \gets \mathit{offset} + K_p \times error + K_i \times error_{accum}$
            \State $waypoint.z \gets waypoint.z + \mathit{offset}$
            \State move\_robot($waypoint$)
        \ELSE
            \State \textbf{break}
        \ENDIF
    \ENDFOR
    \end{algorithmic}
    \end{algorithm}
    

    Due to the MoveIt planning computation, the robot pauses momentarily before each consecutive movement to the next waypoint. This causes a discontinuous, slow motion that becomes slower with more waypoints. 

    \textbf{Gripper Controller:} The slip of the object is controlled to perform the pivoting movement. We estimate the slip type as either translational or rotational. During pivoting, the desired slip is rotational slip and translational slip as a result of gravity should be avoided. We ignore the no slip case as this was not possible for our chosen configuration. Hence it is sufficient to only explicitly detect and control translational slip.
    
    To detect the type of slip, we utilise the direction of force measurements at different points of the tactile sensing elements. Our method uses distributed sensing elements on the tactile sensor, and assumes the tactile sensor consists of nine physical elements in a 3x3 square array \cite{khamis2018papillarray}. Each element measures the displacement of the tip of the sensing pillar, and predicts applied force from this displacement. We focus on the displacement and force values in the vertical dimension, parallel to gravity, as this is the major indicator of slip. 
    
    In the event of gravity-induced translational slip, the downwards movement of the box will be captured by the tactile sensor as a global downwards force across all sensing elements on the tactile sensor. This is in contrast to when the box undergoes rotational slip, where local sensing elements measure forces in different directions, as the centre of rotation is roughly at the centre of the sensor. The direction of the applied force in the vertical dimension is simply taken as the sign of the measured value. We also set a small magnitude threshold of 0.1 to exclude noise. Slip type is only estimated for sensing elements that are detected to be in contact, through an in-built algorithm of the tactile sensors which is based on the normal force applied to the element. 
    
    If the tactile sensors detect translational slip, the gripper width incrementally closes until it is no longer detected. Each step of the increment is $1/256$ times the max distance between the gripper fingers. If the tactile sensors detect rotational slip, then the gripper width is unaltered. The gripper will also loosen its grip if at least one of the pillars experience excessive deformation, to prevent damage to the sensors and the box. We choose the displacement threshold to be slightly higher than values seen in trial runs keeping the heaviest box in midair while avoiding slip, representing the expected highest force situation. The gripper control algorithm is summarised in Alg. \ref{alg:grip}. It is executed at the tactile sensor sample rate of 500 Hz.

    \begin{algorithm}
    \caption{Gripper controller}\label{alg:grip}
    \begin{algorithmic}
    \State $downwards\_z\_count \gets 0$
    \State $contact\_count \gets 0$
    \FOR{\textit{element} \textbf{in} \textit{sensor array}}
        \IF{element detects contact}
            \State $contact\_count \gets contact\_count + 1$
        \ENDIF
        \IF{$displacement_z < -0.1$}
            \State $downwards\_z\_count \gets downwards\_z\_count + 1$
        \ENDIF
        \IF{$displacement_{x,y,z} > 5$}
            \State loosen\_gripper()
        \ENDIF
    \ENDFOR
    \IF{$downwards\_z\_count == contact\_count$}
        \State tighten\_gripper()
    \ENDIF
    \end{algorithmic}
    \end{algorithm}
%\end{enumerate}
