\section{METHOD}
\label{sec:method}

%\daigo{Briefly mention what this section is going to do.}\sara{please check what I wrote}

 We first introduce the concept of Joint State Graph (JSG) which simplifies the joint action selection problem into a standard path planning problem on graphs.  To improve scalability, we propose in \ref{Sec_CJSG} a method of decomposing JSG to deal with scalability of the graph. Finally, we conclude the section with a complexity analysis.

\subsection{Joint State Graph}\label{Sec_JSG}

 The problem described in the previous section can be solved using MDP. However, we propose transforming the environment graph into a joint state space graph. The paths on the JSG inherit the actions of the agents, which means we no longer need to consider the action sets. This makes the problem simpler than MDP. Let the JSG be a graph \(\mathbb{J}=(\mathcal{S},\mathcal{L})\), where $\mathcal{S}=\{\state{i}{j}:i,j\in \nodeset\}$ is the set of nodes representing joint states, and \(\mathcal{L}\) is the set of edges. 

Let $\state{1}{1}$ be the initial state assuming that $\nodeset_0=(1,1)$. Let $\state{g}{g}$ be the goal state. 
Edges on JSG are denoted as $\edges{ij}{wk}=(\state{i}{j},\state{w}{k})$ if agent A can move from \(i\) to \(w\) in the \bgraph{}, and agent B can move from \(j\) to \(k\), i.e., \(\edge{i}{w}\in \edgeset\) and \(\edge{j}{k}\in \edgeset\). If agent A does not move, we have $i=w$. Similarly, if B does not move, $j=k$.

%$\edges{ij}{ik}=(\state{i}{j},\state{i}{k})$ given that agent B can move from node \(j\) to node \(k\) in the \bgraph{}, i.e., \(\edge{j}{k}\in \edgeset\). And $\edges{ij}{wj}=(\state{i}{j},\state{w}{j})$ is an edge if agent A can move from node \(i\) to node \(w\) in the \bgraph{}, i.e., \(\edge{i}{w}\in \edgeset\). And $\edges{ij}{wk}=(\state{i}{j},\state{w}{k})$ is an edge if agent A can move from node \(i\) to node \(w\) in the \bgraph{} and agent B can move from node \(j\) to node \(k\), i.e., \(\edge{i}{w}\in \edgeset\) and \(\edge{j}{k}\in \edgeset\). Fig. \ref{fig: jsg-example} is an example of a JSG using the 5-node environment graph in Fig. \ref{fig: example}.


Let $\mathcal{C}$ be the set of costs for each edge on the JSG, where an element is denoted as $\CostJ{ij}{wk}$. 
%If agents at $\state{i}{j}$ move to $\state{w}{k}$, where $i\neq w$ and $j \neq k$, this indicates that both agents took the action to move instead of staying in place and support the other traverse an edge.  
%This lack of supporting behaviour makes the cost of the edge $\edges{ij}{wk}$ be $\CostJ{ij}{wk} = \cost{i}{w} + \cost{j}{k}$. 
If A remains at $i \in \supnodes{j}{k}$ while B traverses from $j$ to $k \in \mathcal{N}_j$, the cost is defined as $\CostJ{ij}{ik}= \min \{\cost{j}{k}, (\supmove{j}{k}+\supcost)\}$. This is how the edge in JSG subsumes the action selection in the original problem. 
However, if $i \notin \supnodes{j}{k}$, then the  cost is simply $\CostJ{ij}{ik} = \cost{j}{k}$. 
The case when A moves is defined similarly.
%Similarly, when A traverses from $i$ to $w \in \mathcal{N}_i$  while B remains at $j \in \supnodes{i}{w}$, the cost becomes $\CostJ{ij}{wj} = \min \{\cost{i}{w}, (\supmove{i}{w} + \supcost$)\}. 
%And if $j \notin \supnodes{i}{w}$, then the cost is $\CostJ{ij}{wj} = \cost{i}{w}$.
This explains lines 7-17 of Algorithm \ref{Alg_defJSG}.
If A traverses from $i$ to $w \in \mathcal{N}_i$ and B traverses from $j$ to $k \in \mathcal{N}_j$, then we add the nominal costs $\CostJ{ij}{wk} = \cost{i}{w} + \cost{j}{k}$. In the case that both agents are stationary, the cost is $\CostJ{ij}{ij} = 0$
The details of the JSG construction are in Algorithm \ref{Alg_defJSG}.

%If $\post{t}{A} \in \supnodes{j}{k}$, the cost $\CostJ{ij}{ik}=\min {}$
%\daigo{This part is essentially explaining lines 7-15 of Algorithm 1. Can specifically mention that.}

Let $\pathsetJ = \{\pathJ{1},...,\pathJ{m}\}$ be the set of paths on the JSG, where an element $\pathJ{}=\{\edges{11}{kw},...,\edges{ij}{gg}\}$ is the set of edges from the initial state to the goal state. Then, the cost of each path $\pathJ{}$ is given by the sum of the cost of the edges on that path in JSG,
% 
\begin{equation}
 Q({u}) = \sum_{\edges{ij}{wk} \in \pathJ{}} \CostJ{ij}{wk}.
\end{equation}
% 
Using a standard shortest-path algorithm, we can find the optimal path that minimizes $Q({u})$:
% over the paths in $\pathsetJ$, gives the optimal path for JSG,
\begin{equation}
 Q({u}^{\star}) =\min_{\pathJ{} \in \pathsetJ{}}  Q({u}).
\end{equation} 

An example of JSG is shown in Fig.~\ref{fig: jsg-example},
\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\textwidth]{figures/Final5nodeJSG_cropped.pdf}
    \caption{Code-generated Joint State Graph from the 5-node environment graph. Black edges are non-risky edges, red edges are risk with no support, and green edges are risk with support.}
    \label{fig: jsg-example}
\end{figure}
which corresponds to the environment graph shown in Fig. \ref{fig: example}.
% We now have a graph that subsumes actions, and we want to perform path planning on this graph. Fig. \ref{fig: jsg-example} is the JSG for the environment graph in Fig. \ref{fig: example}. 
The edges highlighted in blue indicates the optimal path $u^\star$ for Case~1 in Fig.~\ref{fig: example}. 
Importantly, we can easily identify the original actions from the edges selected in this JSG: e.g., the use of edge $e_{21,24}$ indicates that A at node 2 supported B who moved from node 1 to 4.
% edges form a path that implies what actions the agents took.

Although planning on JSG is conceptually simple, it can become computationally expensive with greater graph sizes. The next section addresses this issue. 

%\begin{algorithm2e}
%    \label{Alg_defJSG}
%    \caption{JSG Construction}
%    \SetAlgoLined
%    \textbf{Input} $\mathbb{G}=(\mathcal{V},\mathcal{E})$, $\mathcal{Z}_{i,j}$.\\
%    \textit{Let} $\mathbb{J}=(\mathcal{S}, \mathcal{L})$.\\
%    \For{$\forall i,j\in \mathcal{V}$}
%    {
%    Add $s_{ij}$ to $\mathcal{S}$
%    }
%    \textit{Initialize} $\mathcal{S}_{\text{V}}=\emptyset$, $\mathcal{S}_{\text{TV}}=\{s_{11}\}$\;
%    \While{$\mathcal{S}_{\text{TV}}\neq \emptyset$}
%    {\For{each $s_{ij} \in \mathcal{S}_{\text{TV}}$}
%    {
%    \For{each $k \in \mathcal{N}_i$ and $s_{kj}\notin \mathcal{S}_{\text{V}}$  }
%    {
%    \uIf{$j\in\mathcal{Z}_{i,k}$}
%    {Add $e_{ij,kj}$ to $\mathcal{L}$. Define its cost as $C_{ij,kj}=\min\{(c_{i,k,s}+c_{s}),c_{i,k}\}$}
%    \Else{
%    {Add $e_{ij,kj}$ to $\mathcal{L}$. Define its cost as $C_{ij,kj}=c_{i,k}$}   
%    }
%    \textbf{if} $s_{kj}\notin \mathcal{S}_{\text{TV}}$, add  $s_{kj}$ to $\mathcal{S}_{\text{TV}}$
%    }
%    \For{each $w \in \mathcal{N}_j$ and $s_{iw}\notin \mathcal{S}_{\text{V}}$}
%    {
%    \uIf{$i\in\mathcal{Z}_{j,w}$}
%    {Add $e_{ij,iw}$ to $\mathcal{L}$. Define its cost as $C_{ij,iw}=\min\{(c_{j,w,s}+c_{s}),c_{j,w}\}$}
 %   \Else{
 %   {Add $e_{ij,iw}$ to $\mathcal{L}$. Define its cost as $C_{ij,iw}=c_{j,w}$}   
 %   }
 %   \textbf{if} $s_{iw}\notin \mathcal{S}_{\text{TV}}$, add  $s_{kj}$ to $\mathcal{S}_{\text{TV}}$
 %   }
 %       \For{each $k \in \mathcal{N}_i$}
 %   {
 %   \For{each $w \in \mathcal{N}_j$}
 %   {
 %   \If{$s_{kw}\notin \mathcal{S}_{\text{V}}$}
 %   {Add $e_{ij,kw}$ to $\mathcal{L}$. Define its cost as $C_{ij,kw}=c_{ik}+c_{jw}$}  
 %   \textbf{if} $s_{kw}\notin \mathcal{S}_{\text{TV}}$, add  $s_{kj}$ to $\mathcal{S}_{\text{TV}}$
 %   }
 %   } 
 %   }
     
 %   Remove $s_{ij}$ from $\mathcal{S}_{\text{TV}}$. Add $s_{ij}$ to $\mathcal{S}_{\text{V}}$.
 %   }

 %   \textit{Return} $\mathbb{J}=(\mathcal{S}, \mathcal{L})$
%\end{algorithm2e}


\begin{algorithm2e}
    \label{Alg_defJSG}
    \caption{JSG Construction.}
    \SetAlgoLined
    \textbf{Input} $\mathbb{G}=(\mathcal{V},\mathcal{E})$, $\mathcal{Z}_{i,j}$.\\
    \textit{Let} $\mathbb{J}=(\mathcal{S}, \mathcal{L})$\\
    \For{$\forall i,j\in \mathcal{V}$}
    {
    Add $s_{ij}$ to $\mathcal{S}$
    }
    \For{any two distinct elements $s_{ij},s_{wk} \in \mathcal{S}$}
    {\uIf{$i=w$, $j\neq k$ and $k\in\mathcal{N}_{j}$ }
    {\uIf{$i\in$ $\mathcal{Z}_{jk}$ }
   {
   Add edge $\edge{ij}{wk}$ to $\mathcal{L}$. Define its cost as $C_{ij,wk}=\min\{c_{j,k}, (\supmove{j}{k}+\supcost)\}$\\
   }    
   \Else{
    Add edge $\edge{ij}{wk}$ to $\mathcal{L}$. Define its cost as $C_{ij,wk}=c_{j,k}$\\
    }
    }
    {\uElseIf{$i\neq w$, $j=k$ and $w\in\mathcal{N}_i$}
    {\uIf{$j\in \mathcal{Z}_{iw} $}
    {
    Add edge $\edge{ij}{wk}$ to $\mathcal{L}$. Define its cost as $C_{ij,wk}=\min\{c_{i,w},(\supmove{i}{w}+\supcost)\}$\\
    }    
    \Else{
    Add edge $\edge{ij}{wk}$ to $\mathcal{L}$. Define its cost as $C_{ij,wk}=c_{i,w}$\\
    }}}
    {\ElseIf{$k\in\mathcal{N}_{j}$ and $w\in\mathcal{N}_i$}{
    Add edge $\edge{ij}{wk}$ to $\mathcal{L}$. Define its cost as $C_{ij,wk}=c_{i,w}+c_{j,k}$
    }}
    }
   \textbf{Return} $\mathbb{J}=(\mathcal{S}, \mathcal{L})$ and the associated costs $C_{ij,wk}$.
\end{algorithm2e}

\subsection{Search Algorithm: Critical Joint State graph}\label{Sec_CJSG}
 In this section, we introduce a new search algorithm based on constructing a Critical Joint State Graph (CJSG), which has reduced computational complexity compared with the straightforward JSG method in Sec. \ref{Sec_JSG}. 
Note that the Joint State Graph $\mathbb{J}$ has $|S|=|\nodeset|^2$ number of nodes, leading to high complexity if directly used for planning.
To address this issue, our key idea is to classify the agents' movements into coupled and decoupled modes, where only the coupled movements need to be planned on a joint state representation, and the decoupled movements can be independently planned by each agent on \bgraph{} $\mathbb{G}$.
%We start with a decomposition of the environment graph formulated in section II. Based on whether the edges in $\mathbb{G}$ are associated with support nodes, we categorize them into a base edge set $\mathcal{E}_B$ such that $\forall e_{i,j}\in \mathcal{E}_B$, $\supnodes{i}{j}=\emptyset$, and a supported edge set $\mathcal{E}_R$ such that $\forall e_{i,j}\in \mathcal{E}_R$, $\supnodes{i}{j}\neq\emptyset$. Clearly, $\mathcal{E}_B\bigcup \mathcal{E}_R=\mathcal{E}$ and $\mathcal{E}_B\bigcap \mathcal{E}_R=\emptyset$. %The two types of edges allow us to decompose the environment graph $\mathbb{G}$ into a base graph $\mathbb{G}_B$ and a support graph $\mathbb{G}_S$, as visualized in Fig. \ref{fig_dcp}.
As visualized in Fig. \ref{fig_dcp}, the environment graph formulated in Sec. \ref{sec:problem-formulation} builds on a base graph $\mathbb{G}$, then associates some of its edges with a set ($\supnodes{i}{j}$) of support nodes. 
Depending on whether the edges in $\mathbb{G}$ have at least one support node, we define a risk edge set $\mathcal{E}_R$ such that $\forall e_{i,j}\in \mathcal{E}_R$, $\supnodes{i}{j}\neq\emptyset$. %Clearly, $\mathcal{E}_B\bigcup \mathcal{E}_R=\mathcal{E}$ and $\mathcal{E}_B\bigcap \mathcal{E}_R=\emptyset$.
%Then, as visualized in Fig. \ref{fig_dcp}, we can decompose the environment graph into a base graph $\mathbb{G}$ and a support graph. 
Note that the support graph in Fig. \ref{fig_dcp} does not follow the standard `graph' definition in mathematics. It only describes a supporting relationship between nodes and risk edges which we use later to study coupled movements of agents.
%and a supported edge set $\mathcal{E}_R$. Each supported edge $e_{ij}\in\mathcal{E}_R$ is associated with a node set $\supnodes{i}{j}$ such that for a particular time step, one agent staying at node $v_k\in\supnodes{i}{j}$ can provide support to the other agent moving across edge $e_{ij}$ or $e_{ji}$ with a cost $c_{ij,s}$.
%Let the graph with all nodes and base edges be a base graph. Let the graph with all nodes and supported edges (and the corresponding supporting nodes) be the supported graph. 
\begin{figure}[h]
    \centering
    \includegraphics[width=0.48\textwidth]{figures/figure2.pdf}
    \caption{Example for environment graph decomposition. In $\mathbb{G}$, node 2 and node 3 can support the edge between node 1 and node 4. }
    \label{fig_dcp}
\end{figure}

We start by considering the costs for decoupled movements of the two agents. 
Recall that $\psi_{a,b}$ denotes the minimum cost for an agent to move from $a$ to $b$ on the base graph $\mathbb{G}$, the following statement holds. %, which can be easily computed by Dijkstra's algorithm with a complexity of $\mathcal{O}(|\mathcal{V}|^2)$. 

\begin{lemma}\label{Lm_base_graph} \longthmtitle{Decoupled planning on base graph}
On graph $\mathbb{G}$, consider the first agent moves from node $i$ to $w$; the second agent moves from node $j$ to $k$. Let  $R_{ij,wk}$ be the minimum cost for the two agents to complete the movement without performing supporting behaviors. Then
$$R_{ij,wk}= \psi_{i,w}+\psi_{j,k}.$$
\end{lemma}
%\daigo{$\psi$ must be defined earlier in the paper.}
 \begin{proof}
 The proof is trivial. Since the two agents do not perform supporting behaviors, their movements and associated costs can be computed individually on the base graph $\mathbb{G}$, which by definition are $\psi_{i,w}$ and $\psi_{j,k}$. 
 \end{proof}


%While Lemma \ref{Lm_base_graph} characterizes the decoupled movements, 
Now, to characterize the coupled movements of the two agents, we construct a Critical Joint State Graph (CJSG), $\mathbb{T}=(\mathcal{M}, \mathcal{H})$, where $\mathcal{M}$ and $\mathcal{H}$ are the node set and edge set of $\mathbb{T}$, respectively. For any $h_{ij,wk}\in\mathcal{H}$, let $W_{ij,wk}$ denote the cost associated with this edge.
Details of CJSG construction are summarized in Algorithm \ref{Alg_defCJSG}.  

\begin{algorithm2e}
    \label{Alg_defCJSG}
    \caption{CJSG Construction}
    \SetAlgoLined
    \textbf{Input} $\mathcal{E}_R$, $s_{11}$, $s_{gg}$, $\mathcal{Z}_{i,j},R_{ij,wk}$.\\
    \textit{Let} $\mathbb{T}=(\mathcal{M}, \mathcal{H})$\\
    \For{each $e_{i,j} \in \mathcal{E}_R$}
    {\For{each $k\in\supnodes{i}{j}$}
    {
    Add $s_{k i}$ and $s_{k j}$ to $\mathcal{M}$. \label{step_add_node}\\
    Add $s_{i k}$ and $s_{j k}$ to $\mathcal{M}$. \label{step_add_node2}\\
    }
    Add $s_{11}=(1,1)$ and $s_{gg}=(g,g)$ to $\mathcal{M}$ (if they are not already in $\mathcal{M}$).\label{step_add_node3}\\
    \For{any two distinct elements
    $s_{ij}, s_{wk}\in\mathcal{M}$}
    {\uIf{
    $e_{j,k}\in\mathcal{E}_R$ and $i=w\in \supnodes{j}{k}$ 
    }
    {Add edge $h_{ij,wk}$ to $\mathcal{H}$. Define its cost as $W_{ij,wk}= \min\{(\supmove{j}{k}+\supcost),R_{ij,wk}\}$\label{step_add_cost}\\
    }
    \uElseIf{$e_{i,w}\in\mathcal{E}_R$ and $j=k\in \supnodes{i}{w}$}
    {Add edge $h_{ij,wk}$ to $\mathcal{H}$. Define its cost as $W_{ij,wk}= \min\{(\supmove{i}{w}+\supcost),R_{ij,wk}\}$. \label{step_add_cost2}
    }
    \Else{
        Add edge $h_{ij,wk}$ to $\mathcal{H}$. Define the associated cost as $W_{ij, wk}=R_{ij,wk}$. \label{step_add_cost3}
    }
    }
    }
    \textbf{Return} $\mathbb{T}=(\mathcal{M}, \mathcal{H})$ and the associated costs $W_{ij,wk}$.
\end{algorithm2e}

\begin{remark}\longthmtitle{Algorithm \ref{Alg_defCJSG} explained}  \label{RM_Alg_defCJSG}
In CJSG, we consider the node of the graph as any joint state that the two agents (i) can initiate or complete supporting behaviors (c.f. steps \ref{step_add_node} and \ref{step_add_node2}), (ii) at their start or goal position of the planning task (c.f. step \ref{step_add_node3}). We let CJSG be fully connected. The edge costs are associated with two agents moving over the base graph (c.f. step \ref{step_add_cost3}) or a possible lower cost when they perform a support behavior (c.f. steps \ref{step_add_cost} or \ref{step_add_cost2}, depending on who supports who).
%For steps \ref{step_add_node} and \ref{step_add_node2}: one agent provides support at $v_k$, then the other agent may move between $i$ and $j$ with reduced cost. 
%$\mathbb{T}$ is a fully connected graph. 
\end{remark}


To provide a toy example, given the environment graph in Fig. \ref{fig_dcp}, we can construct the corresponding CJSG as shown in Fig. \ref{fig_CJSG}. Using the support graph, the \emph{critical joint states} are the highlighted states in the middle part of Fig. \ref{fig_CJSG} as well as the initial and goal states. By computing edge costs according to Lemma \ref{Lm_base_graph} and Algorithm \ref{Alg_defCJSG}, the CJSG is constructed as shown on the right side of Fig. \ref{fig_CJSG}. Red edges are edges under supporting behaviors such that $\supmove{j}{k}$ and $\supmove{i}{w}$ are available. The blue edges are associated with $R_{ij,wk}$ where two agents are decoupled and individually seek optimal paths on the base graph.

\begin{figure*}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/figure3.pdf}
    \caption{Example for CJSG Construction. Based on support graph in (a), we can observe all critical joint states as depicted in (b). By fully connecting these critical joint states with the initial states and goal states, we obtain the CJSG $\mathbb{T}$ as shown in (c).}
    \label{fig_CJSG}
\end{figure*}


After constructing CJSG, we present our search algorithm. We define a path composition operation. Suppose $u_1=\{e_{a,b},e_{c,d},\cdots,e_{i,j}\}$, $u_2=\{e_{g,h},e_{r,t},\cdots,e_{k,\ell}\}$. Then $u_1\oplus u_2 =\{e_{ag,bh},e_{cr,dt},\cdots,e_{il,j\ell}\}$. When the two paths do not have the same length, we extend the shorter one by repeating its final node (so that in the graph representation, it stays at that node). For example, if $u_1$ is two elements shorter than $u_2$ then we extend it by $u_1=\{e_{a,b},e_{c,d},\cdots,e_{i,j},e_{j,j},e_{j,j}\}$. The length of the composed path equals the length of the $u_1$ or $u_2$, whichever is longer.
Based on CJSG and path composition, our search algorithm is presented in Algorithm \ref{Algorithm_search_CJSG}, where \textit{PathPL} can be any path planning algorithm, i.e., Dijkstra's algorithm \cite{CTH-LCE-RRL-SC:22}, that can obtain a shortest path between two nodes.


\begin{algorithm2e}
	\label{Algorithm_search_CJSG}
	\caption{Path Planning based on CJSG.}
	\SetAlgoLined
	\textbf{Input}  $\mathbb{T}=(\mathcal{M}, \mathcal{H})$, $\mathbb{G}=(\nodeset,\edgeset)$.\\
    %\textbf{Function} Dijkstra(Graph, Start, Goal):\\
    %\STATE \textit{return} optimal path $u$.\\
    $\widehat{u} \leftarrow$ PathPL($\mathbb{T}$, $s_{11}$, $s_{gg}$) \\
    \For{each ${h}_{ij,wk}$ in $\widehat{u}$}
    {
    \uIf{
    $W_{ij,wk}=R_{ij,wk}$
    }
    {Add [PathPL$(\mathbb{G},i,w)$$\oplus$PathPL$(\mathbb{G},i,k)$)]  to ${u}^{\dagger}$ \label{step_recons}} 
    \ElseIf{
    $W_{ij,wk}= \supmove{i}{w}+\supcost$ or $W_{ij,wk}= \supmove{j}{k}+\supcost$
    }
    {Add $[e_{ij,wk}]$ to ${u}^{\dagger}$}
    }
	\textbf{Return} ${u}^{\dagger}$.
\end{algorithm2e}

\begin{remark}\longthmtitle{Algorithm \ref{Algorithm_search_CJSG} explained}  \label{RM_Alg_searchCJSG}
We first perform path planning on $\mathbb{T}$. Note that some edges ${h}_{ij,wk}$, when $W_{ij,wk}=R_{ij,wk}$, are associated with paths of two agents planned in $\mathbb{G}$ using Lemma \ref{Lm_base_graph}. We use step \ref{step_recons} to reconstruct these edges back to paths that the agents can traverse on the environment. Furthermore, although step \ref{step_recons} recalls a path planning process, this planning should have already been computed by Lemma \ref{Lm_base_graph} when executing Algorithm \ref{Alg_defCJSG}.
\end{remark}

\begin{lemma} \label{Lm_CJSG_Veri} \longthmtitle{Effectiveness of the critical-joint state graph} The following statements hold.\\
(i) Any path ${u}^{\dagger}$ reconstructed from a path $\widehat{u}$ on CJSG is a feasible path for the two agents on the environment graph, thus, $Q({u}^{\dagger}) \ge Q({u}^{\star})$. \\
(ii) The optimal path planned from the CJSG has the same minimum cost as the optimal path planned directly from the JSG, thus, $Q({u}^{\dagger}) \le Q({u}^{\star})$.
\end{lemma}

 \begin{proof}
 We prove the two statements in Lemma \ref{Lm_CJSG_Veri}. \\
(i) Given any edge $e_{ij,wk}$ in path ${u}^{\dagger}$, there are two situations. One is $W_{ij,wk}= \supmove{i}{w}+\supcost$ or $W_{ij,wk}= \supmove{j}{k}+\supcost$, and another is $W_{ij,wk}=R_{ij,wk}$. For the first case, the path in the environment graph represents one agent staying at the support node where another agent traverses the corresponding supported edge. It is a feasible path for two agents on the environment graph by definition. For the second case, according to Lemma 1, two agents move independently and decoupled. As each agent moves from one node to another on the environment graph, the path obtained from the algorithm is feasible since the planned base graph $\mathbb{G}$ is a subgraph of the environment graph. Therefore, $u^{\dagger}$ is always a feasible path for two agents on the environment graph. Since $u^{\star}$ is the optimal path for the environment graph planned from the JSG, we have $Q({u}^{\dagger}) \ge Q({u}^{\star})$. \\
(ii) We prove this by showing that for any optimal path planned from the JSG, there is a path on CJSG with the same cost. Considering the optimal path planned from JSG, it consists of two agents' movements with and (possibly) without supporting behaviors. Let the $u^{\star}$ be divided into different segments according to the above attribute. It is obvious that all such segments are connected by a joint state that initiates the supporting behavior and a state that completes the supporting behavior, which are essentially critical-joint states. Therefore, if we consider each segment independently, the optimal path over this segment must always be associated with the edges on the CJSG, either in the form of decoupled paths on the base graph or by performing a supporting behavior. Thus, for any optimal path planned from the JSG, there is a path on CJSG with the same cost. This together with the fact that ${u}^{\dagger}$ is the optimal path on CJSG leads to the conclusion $Q({u}^{\dagger}) \le Q({u}^{\star})$. We complete the proof.
%since each segment has the minimum cost forming the JSG optimal path $u^{\star}$, where $u^{\star}$ can be mapped on CJSG as a path from initial state to goal state (i.e., $Q({u}^{\dagger}) \le Q({u}^{\star})$).
%If for any edge $\edge{pq,r\ell}$ in $u^{\star}$, no supporting behavior is performed on them. two agents are decoupled in the team planning for JSG. From lemma 1, the minimum cost in JSG is $Q(u^{\star})=R_{11,gg}=\psi_{1g}+\psi_{1g}$ which can be illustrated from CJSG planning since the initial state and goal state are connected in the CJSG. Once the supporting behaviour exists in $u^{\star}$, the supporting behaviour must happen at one critical joint state and end at the other critical joint state corresponding to the previous one, where this joint cost is same as the cost for these two states in the CJSG. This is equivalent to the path on which we set several critical joint states as the way-points. The rest parts of the path are just decoupled move planning. Those parts can be totally reflect on the CJSG planning since any two critical states are connect by the CJSG edge. 
\end{proof}

\subsection{Comparison of Computational Complexity}\label{Sec_complex}
 We quantify the computational complexity of the search algorithm applied to the joint state graph (JSG) and the critical joint state graph (CJSG), to demonstrate the advantage of CJSG over the JSG.

%Given a graph with $m$ nodes, the computational complexity of Dijkstra's search algorithm [x] is $\mathcal{O}(m^2)$. 
For JSG $\mathbb{J}=(\mathcal{S}, \mathcal{L})$ the graph construction complexity is given by the addition of complexities of nodes and edges. The complexity for the nodes is $\mathcal{O}(|\mathcal{S}|)=\mathcal{O}(|\mathcal{V}|^2)$. Similarly, the complexity of edges is $\mathcal{O}(|\mathcal{L}|)$ which equals $\mathcal{O}(|\mathcal{V}|^4)$ in worst case senario when edges are fully connected. Thus, the graph construction complexity of JSG equals
\begin{align}\label{eq_jsg_const}
    \mathcal{O}_{\text{Jconst}} = \mathcal{O}(|\mathcal{V}|^2)+ \mathcal{O}(|\mathcal{V}|^4).
\end{align}
Since the total number of nodes in JSG is $\mathcal{O}(|\mathcal{V}|^2)$, the search complexity when edges are fully connected follows
\begin{align}\label{eq_jsg_plan}
    \mathcal{O}_{\text{Jplan}} = \mathcal{O}(|\mathcal{V}|^4).
\end{align} 
Combining equations \eqref{eq_jsg_const} and \eqref{eq_jsg_plan}, complexity of JSG becomes
\begin{align}
    \mathcal{O}_{\text{JSG}} = \mathcal{O}(|\mathcal{V}|^4).
\end{align}

Similarly, the construction complexity of CJSG $\mathbb{T}=(\mathcal{M}, \mathcal{H})$ can be expressed as the addition of construction complexities for nodes and edges. For nodes, the complexity simply equals $\mathcal{O}(|\mathcal{M}|)$. For edges, the complexity equals $\mathcal{O}(|\mathcal{M}|^2)+\mathcal{O}(|\mathcal{V}|^2\log(|\mathcal{V}|))$, where the first term is the number of edges in $\mathbb{T}$, which is fully connected. The second term comes from Lemma \ref{Lm_base_graph}, which, in the worst case, needs to compute the shortest path between any pair of nodes in $\mathbb{G}$. The complexity of $\mathcal{O}(|\mathcal{V}|^2\log(|\mathcal{V}|))$ assumes the use of Johnson's algorithm \cite{CTH-LCE-RRL-SC:22}. Thus, the construction complexity of CJSG equals 
\begin{align}\label{eq_complx_cons}
    \mathcal{O}_{\text{const}}=\mathcal{O}(|\mathcal{M}|)+\mathcal{O}(|\mathcal{M}|^2)+\mathcal{O}(|\mathcal{V}|^2\log(|\mathcal{V}|)).
\end{align}
The search complexity of CJSG is determined by the number of nodes in $\mathbb{T}$, which follows
\begin{align}\label{eq_complx_search}
    \mathcal{O}_{\text{plan}}=\mathcal{O}(|\mathcal{M}|^2)+\mathcal{O}(|\mathcal{M}|).
\end{align}
where for the first term, we assume the use of Dijkstra's Algorithm \cite{CTH-LCE-RRL-SC:22} on $\mathbb{T}$, to obtain $\widehat{u}$. The second term is associated with reconstructing $u^{\dagger}$ from $\widehat{u}$. Although Algorithm \ref{Algorithm_search_CJSG} embeds search functions in step \ref{step_recons}, all the planning must have been computed by Lemma \ref{Lm_base_graph} when executing Algorithm \ref{Alg_defCJSG}. No replanning is needed. By combining \eqref{eq_complx_cons} and \eqref{eq_complx_search}, one has 
\begin{align}\label{eq_complx_cons2}
    \mathcal{O}_{\text{CJSG}}=\mathcal{O}(|\mathcal{M}|^2)+\mathcal{O}(|\mathcal{V}|^2\log(|\mathcal{V}|)).
\end{align}

%\midskip
%The CJSG construction complexity can be expressed as a product of construction complexities for node and edge, that is, $\mathcal{O}(construction)=\mathcal{O}(node)+\mathcal{O}(edge)=\mathcal{O}(|\mathcal{M}|)+\mathcal{O}(|\mathcal{H}|)$. 

%For node creation, the number of critical joint states is $4\sum_{e_{ij}\in\mathcal{E}_R}|\mathcal{N}_{i,j}|$ such that the number of nodes is $4\sum_{e_{ij}\in\mathcal{E}_R}|\mathcal{N}_{i,j}|+2$ for adding on initial and goal states. Therefore, $\mathcal{O}(|\mathcal{M}|)$ is only relied on the number of supported edges $e_{ij}$ in $\mathcal{E}_R$ and the number of associated support nodes in $\mathcal{N}_{i,j}$. $\mathcal{O}(|\mathcal{M}|)=\mathcal{O}(|\mathcal{E}_R|\bar{N})$ with $\bar{N}=\max(|\mathcal{N}_{i,j}|)$, where $|\mathcal{E}_R|$ here represents the number of elements in this set.

%For edge construction, the number of edges is $\tbinom{2}{|Nodes|}=\tbinom{2}{4\sum_{e_{ij}\in\mathcal{E}_R}|\mathcal{N}_{i,j}|+2}$. The non-shortcut edges are computed from the information by Dijkstra's search on the ordinary graph. Thus $\mathcal{O}(|\mathcal{H}|)$ becomes a function of $|\mathcal{E}_R|$, $\bar{N}$ and $|\mathcal{V}|$, i.e., $\mathcal{O}(|\mathcal{H}|)=\mathcal{O}((|\mathcal{E}_R|\bar{N}|)^2|\mathcal{V}|^2)$ bounded by $\mathcal{O}|(\mathcal{V}|^4)$.

%The CJSG search complexity is based on the number of nodes according to Dijkstra's search complexity, i.e., $\mathcal{O}(search)=\mathcal{O}((|\mathcal{E}_R|\bar{N})^2)$ bounded by $\mathcal{O}|(\mathcal{V}|^4)$.

%In general, $T$ is a function as a product of node create and edge construction. Let $T$ is a function of $e_{ij}$, $k$, and $v$, i.e., $T=f(e_{ij},k,v)$, where $e_{ij}$ and $k$ are the elements of supported edge set and associate support node set separately and $v$ represents the nodes from ordinary graph. Let $m$ be the number of supported edges and $n$ be the number of associate support nodes. The node creation part rely on $m$ and $n$ which means the time complexity here is $O(mn)$. The number of nodes in CJSG is $4\sum_{m}n+2$.
%for construction cost: the number of nodes is $4\sum_{e_{ij}\in\mathcal{E}_R}|\mathcal{N}_{i,j}|+2=\mathcal{O}(|\mathcal{E}_R|\bar{N})$ with $\bar{N}=\max(|\mathcal{N}_{i,j}|$. The cost for computing edges is $\mathcal{O}((|\mathcal{E}_R|\bar{N}|)^2|\mathcal{V}|^2)$, but is bounded by  $\mathcal{O}|\mathcal{V}|^4)$.
%Here, $\mathcal{O}((|\mathcal{E}_R|\bar{N}|)^2|\mathcal{V}|^2)$ stands for 
%Search algorithm complexity is $\mathcal{O}((|\mathcal{E}_R|\bar{N}|)^2)$, but is bounded by  $\mathcal{O}|\mathcal{V}|^4)$

\begin{remark}\longthmtitle{Comparison of complexity}\label{Rm_complexity}
To compare the complexities of $\mathcal{O}_{\text{CJSG}}$ and $\mathcal{O}_{\text{JSG}}$, we only need to compare $\mathcal{O}(|\mathcal{M}|^2)$ and $\mathcal{O}(|\mathcal{V}|^4)$. Note that in most scenarios, we assume the number of support edges in $\mathbb{G}$ is small. As a consequence, the number of critical-joint states is far less than that of common joint states, i.e. $|\mathcal{M}|\ll |\mathcal{V}|^2$. Then the proposed Algorithm \ref{Algorithm_search_CJSG} based on CJSG is significantly more efficient than the traditional JSG method. The worst boundary scenario happens when support edges widely exist in $\mathbb{G}$, in this case, one has $|\mathcal{M}|\to |\mathcal{V}|^2$, but $|\mathcal{M}|$ is still upper bounded by $|\mathcal{V}|^2$ due to the fact that critical joint states are subsets of joint states. Thus, $\mathcal{O}_{\text{CJSG}}$ is always no worse than $\mathcal{O}_{\text{JSG}}$.

%of $\mathcal{O}(|\mathcal{M}|)$  In the worst scenario, 
\end{remark}
%it with $\mathcal{O}_{\text{JSG}}=\mathcal{O}|(\mathcal{V}|^4)$, note that 
%The boundary conditions of $\mathcal{O}(|\mathcal{M}|)$ 

%can be explained by two extreme scenarios, one is all nodes are critical-joint states, and the other is no critical joint states which also means no support behavior in environment graph, i.e., CJSG = JSG. For the first scenario, $\mathcal{O}(|\mathcal{H}|)$ only depends on $|\mathcal{E}_R|$ and $\bar{N}$ since the edge computing does not need any information from the search on the ordinary graph, i.e., $\mathcal{O}(|\mathcal{H}|)=\mathcal{O}((|\mathcal{E}_R|\bar{N})^2)$. For the second scenario, the construction time complexity is equal to JSG's, i.e.,  $\mathcal{O}(|\mathcal{H}|)=\mathcal{O}|(\mathcal{V}|^4)$.  

%Compared the computational complexities between JSG and CJSG, the key idea of CJSG is to simplify the computation when the two agents' movements can be decoupled. If the number of critical joint states infinitely approaches the number of joint states, i.e., $||\mathcal{E}_R|\bar{N}|\to |\mathcal{V}|$, the gain of CJSG is limited. Otherwise, when $||\mathcal{E}_R|\bar{N}|\ll |\mathcal{V}|$, the effect of CJSG is more significant. 
%If $|\mathcal{E}_R|\bar{N}|\to |\mathcal{V}|$, the gain of CJSG is limited. This can be verified by XXX.
%When $|\mathcal{E}_R|\bar{N}|\ll |\mathcal{V}|$, the difference is significant. 
%Although we characterize the complexity as $\mathcal{O}((|\mathcal{E}_R|\bar{N}|)^2|\mathcal{V}|^2)$.  In practice, the computation can be further simplified by XXX. 