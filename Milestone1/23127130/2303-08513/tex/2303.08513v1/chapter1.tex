% INTRODUCTION

% partitioned solution technique
For the solution of fluid-structure interaction (FSI) problems, partitioned approaches are widespread, because they allow to reuse mature and reliable solvers, tailored to each of the two subproblems \cite{felippa2001partitioned}.
The flow and structure solvers are treated as black boxes and all data exchange is limited to the shared interface.
%This modularity stands in striking contrast to the monolithic approach, which requires the development of a problem-specific FSI solver.
The main drawback of the partitioned technique is its need for an iterative coupling loop that repeatedly solves the subproblems within each time step to assure satisfaction of the equilibrium conditions on the interface.
Moreover, these coupling iterations are prone to stability issues, due to the added-mass effect \cite{Causin2005, Forster2007, VanBrummelen2009}.

% from instabilities to quasi-Newton techniques
During the last two decades, these instabilities have been studied extensively \cite{Causin2005,Formaggia2001, Vierendeels2005, Badia2008, Joosten2009} and various techniques to stabilize and accelerate the coupling have been proposed.
The simplest approach is a relaxation of the interface data, which improves stability at the expense of slow convergence.
%
Dynamically updating the relaxation factor as in Aitken relaxation \cite{Mok2001,Mok2001b,Kuttler2008} mitigates this drawback, but
it still treats all error components identically,
while it has been shown \cite{Degroote2008, Degroote2009b} that the added-mass instability is only caused by the lowest wave number components of the error between the correct solution and the one in the iterative coupling.
%\todo{@Nicolas: Do you think one could specify which error we are talking about without bloating the sentence?}

% quasi-Newton techniques
This realization opened the door to quasi-Newton techniques, which update the interface data communicated between the subproblems using a Newton-Raphson approach with a low-rank approximation of the Jacobian, based on input-output data from previous solver calls.
%
Throughout the years, many different variants have been proposed.
They differ in when the interface data is updated, i.e., after only one of the solvers or after both,
and in the technique employed to approximate the Jacobian,
such as the least-squares or the 
multi-vector approach \cite{Delaisse2021}.
% Further, some variants make use of the so-called least-square approach, while others employ the multi-vector technique to obtain a low-rank Jacobian.
% Throughout the years, many different variants have been proposed.
% They differ in when the interface data is updated: after only one of the solvers or in between both.
% Further, some variants make use of the so-called least-square approach, while others employ the multi-vector technique to obtain a low-rank Jacobian.
An extensive overview is given in \cite{Delaisse2023}.

% comparing different techniques: old cost measure
In literature, the efficiency of a coupling algorithm is generally assessed based on 
the required number of coupling iterations per time step,
justified by the observation that the solution of the subproblems is by far the most expensive part of the coupling scheme.
Although never stated explicitly, however, this cost measure also implies that the computational cost of each coupling iteration, and therefore each call of a solver, is constant.

% comparing different techniques: new cost measure
This work demonstrates that this is not the case in practice.
% Typically, the subproblems are nonlinear and therefore introduce their own internal iterative linearization, such as fixed-point or Newton iterations.
%
Since the subproblems are typically nonlinear,
they introduce their own internal iteration loop to handle this nonlinearity, using
% Since the subproblems are typically nonlinear, they introduce 
% their own internal iterative linearization, 
% their own internal iterative loop linearizing the problm
% using 
fixed-point or Newton iterations.
% 
These internal \textit{subproblem iterations} have a considerable impact on the computational cost of a solver call.
% 
As an illustrative example, imagine two solid solver calls:
the first performs ten Newton iterations, the second only one;
% 
% 
% the flow solver performs ten Newton steps in a first  call, before it is called a second time, this time running only one Newton step.
% is then call two in its next call:
clearly, the second call is expected to consume much less time, although most probably not by a factor of ten.
% 
% As an illustration, imagine one solver call performing ten Newton steps and the next solver call only one. 
%Which solver call will take less time?
% Clearly, the second call is expected to be much faster, although most probably not by a factor ten.
% 
Against this backdrop, this work proposes a new cost measure that considers not only the number of coupling iterations, but also the number of subproblem iterations in each of the two solvers, and combines them in a weighted sum.
The numerical results confirm that this new measure represents the actual wall-clock time much more accurately than looking at the coupling iterations alone.

% limiting the number of subproblemiterations
As the impact of the \subproblemIter s on the computational cost has been overlooked so far, literature offers plenty of techniques to converge in fewer coupling steps, 
but, to the best of the authors' knowledge, lacks any studies on how to minimize the number of \subproblemIter s.
%As the impact of the \subproblemIter s on computational cost has been overlooked so far,
%literature offers plenty of techniques to converge in fewer coupling steps, 
%but, to the best of the authors' knowledge, lacks any studies on how to minimize the number of %\subproblemIter s.
%
% As a simple way,
To start closing this gap,
this work investigates the effects of limiting the number of iterations performed for one solver call, 
demonstrating that a significant speed-up can be obtained by not converging to the final subproblem tolerance in each solver call.
% 
This is mainly because it avoids investing time into polishing a preliminary subproblem solution that will be overwritten in the next coupling iteration, as long as the partitioned scheme has not converged yet.
% 
On the other hand, passing back inaccurate results
brings the risk of compromising the coupling loop's stability,
as well as the quality of the input-output data used by quasi-Newton methods.

% new convergence criterion
In any case,
at the end of each time step,
% For an accurate solution of the coupled problem, however, 
an accurate solution of the coupled problem requires
both subproblems to be converged up to their respective solver tolerances.
% for an accurate solution of the coupled problem.
% .at the end of each time step. 
While this condition is inherently satisfied when iterating to full convergence in every solver call, limiting the number of \subproblemIter s per call requires to monitor it explicitly.
% 
Therefore, a new convergence criterion is introduced that evaluates the convergence of the coupling scheme solely based on the solver residuals.
% ensuring the coupled problem is iterated to the same precision, independently from the
% 
As an added benefit, this new approach avoids choosing the value of the rather non-intuitive coupling tolerance commonly used in literature
and provides a natural link between the accuracy of the coupling on the one hand and each of the subproblems on the other hand.

% also other partitioned problems
%Although this work focuses on fluid-structure interaction problems, most of the results and conclusions can directly be %extended to other multi-field problems in which black-box solvers are coupled in a partitioned fashion.

% finite elements and finite volumes
As different discretization approaches for solving the subproblems are common in modern engineering science,
this work discusses numerical results obtained from different partitioned FSI frameworks to broaden its scope.
While the first framework uses finite elements for both subproblems, the second employs a finite-volume method for the flow problem and finite elements for the structural problem. \\

% structure of the text
The remainder of this work is structured as follows.
After the introduction of the fluid-structure interaction problem in \Sec{fsi}, \Sec{subproblems} treats the solution of the subproblems with finite elements or finite volumes and focuses on how both techniques manage nonlinearities.
This is important for \Sec{convergence}, which presents a new cost function, taking into account the number of coupling iterations as well as the number of \subproblemIter s. Moreover, it discusses the impact the number of \subproblemIter s per solver call has on this cost measure and
introduces the new convergence criterion.
Results are generated with both frameworks and discussed in \Sec{results} for two test cases, the lid-driven cavity and flexible tube case, before the conclusions are presented in \Sec{conclusion}.
