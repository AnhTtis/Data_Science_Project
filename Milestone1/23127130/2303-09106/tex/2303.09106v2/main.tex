%\documentclass[envcountsect,envcountsame,runningheads,a4paper]{elsarticle} 
\documentclass[preprint,
    10pt,
%    authoryear,
    3p,
    fleqn,
%    times
]{elsarticle}

\usepackage{main}

% \allowdisplaybreaks

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
% \usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\newcommand{\cmt}[1]{\textnormal{\color{Maroon}\{#1\}}}
% Useful packages

%\usepackage[colorlinks=true,allcolors=blue]{hyperref}

\begin{document}

\begin{frontmatter}

  \title{Formally Verified Animation for RoboChart using Interaction Trees\tnoteref{t1,t2}}

  \tnotetext[t1]{This document presents results from the research project CyPhyAssure (\url{www.cs.york.ac.uk/circus/CyPhyAssure/}) funded by EPSRC.}

  \author[1]{Kangfeng Ye\corref{cor1}}

  \ead{kangfeng.ye@york.ac.uk}

  \author[1]{Simon Foster}

  \ead{simon.foster@york.ac.uk}

  \author[1]{Jim Woodcock}

  \ead{jim.woodcock@york.ac.uk}

  \cortext[cor1]{Corresponding author}

  % \fntext[fn1]{This is the first author footnote.}
  % \fntext[fn2]{Another author footnote, this is a very long 
  % footnote and it should be a really long footnote. But this 
  % footnote is not yet sufficiently long enough to make two 
  % lines of footnote text.}
  % \fntext[fn3]{Yet another author footnote.}

  \affiliation[1]{%
    organization={Department of Computer Science, University of York},
    addressline={Deramore Lane, Heslington},
    postcode={YO10 5GH},
    city={York},
    country={United Kingdom}
  }%
  
  \begin{abstract}
    RoboChart is a core notation in the RoboStar framework. It is a timed and probabilistic domain-specific and state machine-based language for robotics. RoboChart supports shared variables and communication across entities in its component model. It has formal denotational semantics given in CSP. The semantic technique of Interaction Trees (ITrees) represents behaviours of reactive and concurrent programs interacting with their environments. Recent mechanisation of ITrees, ITree-based CSP semantics and a Z mathematical toolkit in Isabelle/HOL bring new applications of verification and animation for state-rich process languages, such as RoboChart. In this paper, we use ITrees to give RoboChart novel operational semantics, implement it in Isabelle, and use Isabelle's code generator to generate verified and executable animations. We illustrate our approach using an autonomous chemical detector and patrol robot models, exhibiting nondeterminism and using shared variables. With animation, we show two concrete scenarios for the chemical detector when the robot encounters different environmental inputs and three for the patrol robot when its calibrated position is in other corridor sections. We also verify that the animated scenarios are trace refinements of the CSP denotational semantics of the RoboChart models using FDR, a refinement model checker for CSP. \changed[\C{31}]{This ensures that our approach to resolve nondeterminism using CSP operators with priority is sound and correct.}
    % \\
    % \textbf{Keywords}: interaction trees, CSP, animation, theorem proving, RoboChart, code generation, robotic software, operational semantics
  \end{abstract}
  
  \begin{keyword}
    Interaction trees\sep CSP\sep animation\sep theorem proving\sep RoboChart\sep code generation\sep robot software\sep operational semantics\sep nondeterminism.
  \end{keyword}
  
\end{frontmatter}

% \maketitle % not necessary 

\section{Introduction}
\label{sec:intro}

The RoboStar%
\footnote{%
  \url{robostar.cs.york.ac.uk}.%
} framework~\cite{Cavalcanti2021} brings modern modelling and verification technologies into software engineering for robotics.  In this framework, models of the platform, environment, design, and simulations are given formal semantics in a unified semantic framework~\cite{Hoare1998}.  Correctness of simulation is guaranteed for particular models using a variety of analytical technologies, including model checking, theorem proving, and testing.  Additionally, modelling, semantics generation, verification, simulation, and testing are automated and integrated into an Eclipse-based tool, RoboTool.%
\footnote{%
  \url{robostar.cs.york.ac.uk/robotool/}.%
} The core of RoboStar is RoboChart~\cite{Miyazawa2019,Ye2021}, a timed and probabilistic domain-specific language \changed[\C{6}]{to model robotic software}, which provides UML-like architectural and state machine modelling notations.  RoboChart is \changed[\C{32}]{distinguished by} its formal semantics~\cite{Miyazawa2019,Woodcock2019,Ye2021}, which enables automated verification using model checking and theorem proving~\cite{Ye2021a}. \changed[\C{6}]{In RoboChart, physical robots are abstracted into robotic platforms through variables, events, and operations. RoboSim~\cite{Cavalcanti2019a} is a domain-specific language for simulation in robotics. It can be seen as a correct implementation or refinement of RoboChart into the simulation level in terms of control software, called d-model. RoboSim is also enriched to specify robotic platforms' physical and dynamic behaviours, provided through p-models. The d-model and p-model of RoboSim are related through a platform mapping, which describes how variables, events, and operations in the d-model are interpreted as continuous variables in the p-model. The hybrid models then can be verified using Differential Hoare logics~\cite{Foster2020a,Foster2021a}, or hardware/software co-verification~\cite{Murray2022}. Our work presented here targets the animation of RoboChart models for robotic control software, \changed[\C{34}]{and so users can interact with RoboChart models through provided command line interfaces. From this aspect, users play a role in the environment of the models. They inspect the behaviour of the models by choosing what the model is allowed to do and observing its response.}}

Previous work~\cite{Miyazawa2019} gives RoboChart a denotational semantics based on the CSP process algebra~\cite{Hoare1985,Roscoe2011}.  This paper defines direct operational semantics for RoboChart using Interaction Trees (ITrees)~\cite{Xia2019}. \changed[\C{5}]{ITrees support a coinductive encoding of labelled transition systems that can model infinite behaviours of a reactive system interacting with its environment. Crucially, ITrees provide abstract yet directly executable semantics, which means they can support animation to support model exploration, verification using coinductive proof techniques, and generation of correct-by-construction implementations~\cite{Foster2021}. An ITree-based semantics for RoboChart thus further empowers developers with techniques for prototyping and analysis of models}. ITrees have been mechanised in both Coq~\cite{Xia2019} and Isabelle/HOL~\cite{Foster2021}. ITrees also unify trace-based denotational failures-divergences semantics~\cite{Brookes1984,Roscoe2011} for CSP, transition-based operational semantics, and algebraic semantics, as demonstrated in our previous work~\cite{Foster2021}.

% Recent work~\cite{Foster2021} on mechanisation of Interaction Trees (ITrees)~\cite{Xia2019} in Isabelle/HOL introduces a verification and animation framework for state-rich process languages. In particular, the CSP process algebra~\cite{Hoare1985,Woodcock2004} has been given an ITree-based semantics, formally linked to the standard failures divergences semantic model.  This brings new applications for the work. Such an application is the verification and animation of

% This work aims at the animation and verification of RoboChart using ITrees, based on code generation~\cite{Haftmann2010} in Isabelle/HOL. Existing potential accounts of animation of a RoboChart model through its CSP semantics include Probe in FDR~\cite{GABR14} and the ProB animator~\cite{Leuschel2003}.\footnote{\url{https://prob.hhu.de/w/index.php?title=Main_Page}} %, expose all internal choices (nondeterministic choice) to users, which makes the animation at a very low level and not efficient because users need to make so many choices of events. This is not convenient even for experts, not alone for regular users.
%
% These animators support machine-readable CSP (or CSP-M) and can deal only with a subset of RoboChart's types and expressions that are based on the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}~\cite{Spivey1992,Woodcock1996}. They also cannot solve preconditions and postconditions in function definitions, requiring users to supply explicit implementations.

The existing implementation of RoboChart's semantics in RoboTool is restricted to machine-readable CSP (or CSP-M) for verification with FDR~\cite{GABR14}, a CSP refinement checker, and so only a subset of RoboChart's rich types and expressions (which is based on that of the Z notation~\cite{Toyn2002}) can be supported, and quantified predicates cannot be solved.  Our contribution here is a richer ITree-based CSP semantics for RoboChart in terms of types and expressions to address these restrictions, thanks to the mechanised Z toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.}~\cite{Spivey1992} in Isabelle/HOL.
%
% We use ITree-based CSP to implement RoboChart's semantics in Isabelle/HOL and then utilise the code generator~\cite{Haftmann2010} to produce Haskell code for animation. Our approach supports all types and expressions of RoboChart %(thanks to the mechanised Z mathematical toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.}~\cite{Spivey1992} in Isabelle/HOL)
% and can solve preconditions and postconditions of function definitions effectively.
Our semantics also allow us to characterise systems with an infinite number of states symbolically, avoiding the need to generate an explicit transition system.
% (though we cannot directly animate them).
%
% Different from the standard CSP, which is stateless, the ITree-based CSP is stateful, and a process may return a value (or state) in addition to normal interactions through events.  The data model of the ITree-based CSP is based on that of Isabelle/HOL and the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}~\cite{Spivey1992,Woodcock1996}. Because RoboChart is state-rich and has a data model in Z, our approach supports more data types and expressions than other animation methods based on RoboChart's CSP semantics, such as Probe and ProB.  Functions of RoboChart, defined by preconditions and postconditions that usually involve quantifier or lambda expressions, also cannot be automatically implemented in the CSP semantics for these animation methods. Our approach, however, can solve these preconditions and postconditions so function definitions can be automated.
%

We mechanise the ITree-based CSP semantics in Isabelle/HOL, \changed[\C{7}]{which ensures that all our definitions and proofs are theoretically well-grounded, yet also practically applicable in development tasks. Isabelle/HOL provides us with an array of tools to support software engineering and verification, including a flexible syntax frontend, integration of automated theorem provers, and code generation}.  \changed[\C{12}]{Animation of a RoboChart model is realised in two stages. The first stage generates the ITree-based CSP semantics for the model, and the second stage utilises the code generator~\cite{Haftmann2010} in Isabelle/HOL to automatically produce Haskell code for animation. We note that the work presented in this paper results from manually generating CSP semantics for RoboChart models in the first stage. Supporting full automation for semantics generation is part of our future work. In the second stage, } Isabelle's code generator~\cite{Haftmann2010} translates executable definitions in the source HOL logic to target functional languages (such as SML and Haskell), and the translation preserves semantic correctness using higher-order rewrite systems~\cite{Mayr1998}.
% in two stages via an intermediate language. In the first stage, the source and the intermediate language are both given equational semantics in terms of higher-order rewrite systems~\cite{Mayr1998}. Then, in the second stage, a semantic preservation dictionary translation [12] is applied to the intermediate language.
As a result, the semantics of the source logic in Isabelle is preserved during code generation via translation to target functional languages. Our animation, therefore, is formally verified for RoboChart's semantics in ITrees. Thanks to the equational logic, functional algorithms and data refinement are supported in code generation, so less efficient algorithms and \changed[\C{33}]{data structures used for} verification in Isabelle can be replaced with more efficient ones for animation.
% For example, associative lists are used in our animation to implement partial functions.

% Code generation also provides a concrete implementation of RoboChart controllers, which could enable us to develop verified ROS~\cite{Quigley2009} nodes using RoboChart.  %because of guaranteed partial correctness~\cite{Haftmann2010} in code generation.

% Unlike ProBE and ProB, which must be used entirely from the generated CSP code for a RoboChart model, our approach leverages the model itself. The counterpart of the model in ITrees benefits from this approach in that some information lost during the generation of CSP code is still present, such as Z types and expressions.  (such as primitive types.)

Our technical contributions are as follows: we %
\begin{inparaenum}[(1)]
\item implement extra CSP operators (generalised choice, interrupt, exception, and renaming), which are required to support the RoboChart semantics, and new CSP operators with priority (hiding with priority and renaming with priority) to resolve nondeterminism in RoboChart based on an order; %
\item implement a bounded list or sequence type (that is not defined in the Z toolkit) for code generation; %
\item use the new concepts to define an ITree-based operational semantics for RoboChart; %
\item implement the semantics of two RoboChart models for case studies; and %
\item apply our animator to explore the behaviour of the models. %
\end{inparaenum}
%
With our mechanisation and animation, we have detected several issues in one RoboChart model, explored the semantics of shared variables in RoboChart, and resolved nondeterminism in a particular way. Specifically, the prioritised renaming operator uses the order in which transitions are given in the renaming mappings to resolve nondeterminism. The benefit of resolving nondeterminism statically in semantics, instead of dynamically in the animator, is that animation becomes more automatic since the user only needs to resolve external choice and not nondeterministic choice. There is no need to overcome the big $\tau$ diamonds~\cite{Roscoe2011} as in the animator of ProB~\cite{Leuschel2003} and FDR. All definitions and theorems in this paper are mechanised, and accompanying icons (\isalogo) link to corresponding repository artefacts. \changed[\C{15}]{We assume basic knowledge of Isabelle/HOL from interested readers to understand these definitions and theorems.}
%

The remainder of this paper is organised as follows. Section~\ref{sec:robochart} gives a brief discussion of \changed[\C{4}]{CSP and then introduces} RoboChart through two examples: an autonomous chemical detector model and a patrol robot model.
% and discuss its CSP semantics.
Section~\ref{sec:itree} briefly describes the mechanisation of ITrees in Isabelle, \changed[\C{9}]{lists the semantics of previously defined CSP operators}, and presents the extra CSP operators in detail. Then we introduce the RoboChart semantics in ITrees in Sect.~\ref{sec:rc_to_itrees} \changed[\C{11}, \C{14}]{using general mathematical rules}, exemplified using the two models, and illustrate several scenarios for the two models in Sect.~\ref{sec:animation} using animation. We review related work in Sect.~\ref{sec:related} and conclude in Sect.~\ref{sec:concl}.

This paper is an extension of \cite{Ye2022}. It adds a new generalised choice operator, redefines the CSP external choice operator using the generalised choice, and introduces biased external choice operators in Sect.~\ref{ssec:itree_genchoice}. This work also gives the ITrees-based semantics to shared variables in RoboChart. It resolves nondeterminism in the semantics using the new CSP operators with priority defined in Sects.~\ref{ssec:itree_hiding_with_priority} and \ref{ssec:itree_renaming_with_priority}. The semantics for shared variables and nondeterminism are exemplified in a new case study introduced in Sect.~\ref{ssec:robochart_patrol} and illustrated in Sect.~\ref{ssec:animation_patrol} for its animation. We also add \changed[\C{11}, \C{14}]{semantic rules} and important details in Sect.~\ref{sec:rc_to_itrees} to give a clear understanding of our semantics for RoboChart with examples from the two models, including new subsections: Sect.~\ref{ssec:semantics_overview} to give an overview of RoboChart semantics, Sect.~\ref{ssec:semantics_channels} about channels and alphabet transformation, and Sect.~\ref{ssec:semantics_operation} to give semantics to operations in RoboChart. We give more details and examples to illustrate the semantics of the existing subsections. In particular, Sect.~\ref{ssec:semantics_stm} is substantially extended to give semantics to state machines, not only its sketch but also its detailed definitions and examples for memories, different kind of nodes, and their composition in parallel. Similarly, Sects.~\ref{ssec:semantics_ctrl} and \ref{ssec:semantics_module} are also extended with examples.

\section{CSP and RoboChart}
\label{sec:robochart}
\changed[\C{4}]{
\subsection{CSP}
\label{ssec:robochart_csp}

Communicating Sequential Processes or CSP~\cite{Hoare1987,Roscoe2011} is a well-established process algebra to model concurrent systems using communication (message-passing via channels) for the interaction between processes. It has primitives for specifying sequential behaviour and concurrent interaction using events. Table~\ref{table:csp_operators} summarises the CSP processes and operators used in our semantics for RoboChart.

\begin{table}[!htb]
  \setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
  \caption{\label{table:csp_operators} \changed[\C{4}]{A summary of CSP processes and operators.}}
  \resizebox{\textwidth}{!}{
  \begin{tabularx}{\textwidth}{l|p{3.5cm}|X}
    \hline
    \textbf{Symbol} & Name & Description \\
    \hline
    $\tau$ & internal event & Invisible event.\\
    $Skip$ & skip & Terminate immediately without change to the state.\\ 
    %\hline
    $Stop$ & deadlock & Refuse any interaction with the state unchanged. \\ 
    $c \then P$ & prefix & Synchronise on channel $c$ and then behave like $P$. \\
    $c?x \then P(x)$ & input & Accept an input of any value (of type $T$) on channel $c$ if $c$ has a type $T$, record the value on variable $x$, and then behave like $P(x)$. \\
    $c?x:S \then P(x)$ & restricted input & Similar to input, but it only accepts the values from set $S$.\\
    $c!v \then P$ & output & Synchronise on channel $c$ with value $v$, and then behave like $P$.\\
    $b \guard P$ & guarded process & Behave like $P$ if $b$ is true, and deadlock otherwise.\\
    $P \extchoice Q$ & external choice & Offer the environment a choice of the first events of $P$ and $Q$, and then behave accordingly.\\
    $P \intchoice Q$ & internal choice & Nondeterministic choice between $P$ and $Q$ without offering the environment a choice.\\
    $P ; Q$ & sequential composition & Behave like $P$ initially, and behave like $Q$ if $P$ terminates. \\
    $P \interrupt Q$ & interrupt & Behave like $P$, but offer the environment a choice of the initial events of $Q$ at any time until $P$ terminates. If one of these events is performed, $Q$ takes over and behaves accordingly.\\
    $ P \exception{E} Q$ & exception & Behave like $P$ until $P$ performs an event from set $E$, at that point, then behave like $Q$. \\
    $P \parallel_{E} Q$ & generalised parallel composition & $P$ and $Q$ run simultaneously, synchronise on the events in $E$, progress independently on the events not in $E$, and terminate if both terminate. \\
    $P \interleave Q$ & interleave & Equal to $P \parallel_{\emptyset} Q$ where $P$ and $Q$ always progress independently on any event.\\
    $ P \hide E$ & hiding & Behave like $P$ except that the events from $E$ become internal.\\% $\tau$ events.\\
    $ \rename{P}{c \becomes d}$ & renaming & Rename the event $c$ in $P$ to $d$.\\
    $ \Extchoice i:I @ P(i)$ & replicated external choice & Offer a choice of the indexed processes $P(i)$ by $i$ from set $I$. The similar replicated internal choice, sequential composition, parallel composition, and interleaving are omitted here.\\
    %\hline
    \hline
  \end{tabularx}}
\end{table}

CSP has several rich semantic models~\cite{Roscoe2011}, including traces, stable failures, failures-divergences, and refusal testing models based on its denotational semantics and characterising the observable behaviours of processes. CSP also has consistent denotational and operational semantics~\cite{Roscoe2011}: all these semantic models have congruence theorems in the operational semantics. CSP also has been extended to specify time in concurrent systems like \emph{tock}-CSP~\cite{Roscoe2011,Baxter2021} and Timed CSP~\cite{Roscoe2011,Schneider1999}, and to specify shared variables, priority, and mobility~\cite{Roscoe2011} in concurrent systems. Several languages are also built on CSP, such as Circus~\cite{Woodcock2002}, CML~\cite{Woodcock2012}, and RoboChart presented here.

FDR is a widely used model-checking tool for verifying CSP processes through refinement: $P \refinedby_\mathcal{M} Q$ represents a specification $P$ is refined by an implementation $Q$ in terms of a semantic model $\mathcal{M}$. FDR supports hierarchical compression methods\footnote{\url{https://cocotec.io/fdr/manual/cspm/prelude.html\#compressions}} to tackle the state space explosion problem in model checking. According to~\cite{GABR14}, the cluster version of FDR3 is able to analyse problems with $10^{12}$ compressed states (approximately $10^{20}$ uncompressed states). FDR also has a built-in CSP process animator called ProBE~\cite{GABR14}, which can be used to manually explore the full transition tree of a CSP process. 

This paper applies an ITree-based semantics for CSP, which we developed previously~\cite{Foster2021}. It is consistent with the failures-divergences semantics~\cite{Roscoe2011} but focuses on deterministic CSP processes, which are directly executable. Since our encoding of CSP is symbolic and implicit, we can avoid the state explosion problem.
}

\subsection{RoboChart}
{
\changed[\C{8}]{RoboChart is motivated by problems in the current practice of programming robotic applications using standard state machines:
\begin{enumerate*}[label={(\alph*)}]
\item no precise syntax and formal semantics, 
\item informally discussed time and uncertainty requirements, 
\item loosely connected artefacts, 
\item no tool support, and 
\item no assurance. 
\end{enumerate*}
%
RoboChart is a state machine-based notation designed for roboticists to model robotic control software and apply modern verification techniques. RoboChart has precise syntax and formal semantics and allows users to specify time and probability features in state machines formally. Modelling using RoboChart and verification is supported by its accompanying tool, RoboTool. Roboticists can use RoboTool to create RoboChart models using consistent diagrammatic and textual modelling. They can either draw diagrams (and RoboTool automatically generates the corresponding textual model) or program models (RoboTool can also automatically render its diagrammatic representation).

RoboChart has an unambiguous mathematical semantics. RoboTool automatically generates semantics for models and applies verification techniques like model checking and theorem proving to analyse the semantics based on the properties specified by users. RoboChart models and properties use languages familiar to roboticists. Other artefacts, like semantics, are automatically linked to the models and properties, making modern software engineering and verification techniques more accessible for roboticists.
}

RoboChart also has a component model with notions of controller, module, and state machines to foster reuse. 
In a RoboChart model, physical robots are abstracted into robotic platforms through variables, events, and operations. 
%
We describe \changed[\C{35}]{some of the features} of RoboChart for modelling controllers of robots using two examples: an autonomous chemical detector~\cite{Hilder2012,Miyazawa2019,RoboChartRef} in Sect.~\ref{ssec:robochart_chemical} and a patrol robot in Sect.~\ref{ssec:robochart_patrol}.
We refer to the RoboChart reference manual~\cite{RoboChartRef} for a complete account of the notation and its semantics.
}

\subsubsection{Autonomous chemical detector}
\label{ssec:robochart_chemical}
The robot is equipped with sensors to 
\begin{inparaenum}[(1)]
\item analyse the air to detect dangerous gases;  
\item detect obstacles; and
\item estimate change in position (using an odometer).
\end{inparaenum}
The controller of the robot performs a random walk with obstacle avoidance. Upon detecting a chemical with its intensity above a threshold, the robot drops a flag and stops there.
This model\footnote{\url{robostar.cs.york.ac.uk/case_studies/autonomous-chemical-detector/autonomous-chemical-detector.html}}~\cite{Miyazawa2019} has been studied and analysed in RoboTool, using \changed[\C{36}]{FDR}.
%, but not particularly studied animation as we do here. We consider a specific version 3 of the models because it is the latest with more features of RoboChart at the time when we conducted this work. 

The top-level structure of a RoboChart model, a module, is shown in Fig.~\ref{fig:robochart_acd_module}. 
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=.90\textwidth]{Module.pdf}%
  \vspace{-2ex}
  \caption{The module of the autonomous chemical detector model.}%
\vspace{-4ex}
  \label{fig:robochart_acd_module}%
\end{figure}
%
The module \rcitem{ChemicalDetector} contains a robotic platform \rcitem{Vehicle} and two controller references \rcitem{MainController} and 
\rcitem{MicroController}. The physical robot is abstracted into the robotic platform through variables, events, and operations. The platform provides the controllers with services  
\begin{inparaenum}[(1)]
\item to read its sensor data through three events: \rcitem{gas}, \rcitem{obstacle}, and \rcitem{odometer};
\item for movement through three operations: \rcitem{move}, \rcitem{randomWalk}, and \rcitem{shortRandomWalk} as grouped in an interface \rcitem{Operations}; and 
\item to drop a flag through receiving a \rcitem{flag} event.
\end{inparaenum}
{These services represent the controllers' observable behaviour or external interaction with the physical robot. The controllers \rcitem{MainController} is responsible for gas analysis, and \rcitem{MicroController} accounts for the robot movement with obstacle avoidance. 
}

A platform and controllers communicate using directional connections. {For example, the platform is linked to \rcitem{MainController} through an asynchronous connection on event \rcitem{gas} of type \rcitem{seq(GasSensor)}, sequences of type \rcitem{GasSensor}.} Furthermore, the \rcitem{MainController} and \rcitem{MicroController} interact using the events \rcitem{turn}, \rcitem{stop}, and \rcitem{resume} {to allow \rcitem{MainController} to instruct \rcitem{MicroController} to \emph{turn} towards the location where the gas is detected, \emph{stop} the robot if the gas is dangerous, or \emph{resume} its movement behaviour (by ignoring the current movement operation) if no gas is detected. These interactions are the internal behaviour of controllers and are not observable.}

% {
% Generally, the robot controllers behave as follows:
% \begin{inparaenum}[(1)]
% \item \rcitem{MainController} gets the gas sensor reading via event \rcitem{gas} and then analyses it to decide whether a chemical is detected or not, and upon detection, whether the intensity is over or below a threshold;
% \item if no chemical is detected, the controller \rcitem{resumes} and is ready to continue to read and analyse;
% \item if a chemical is detected but the intensity is low, the controller sends an asynchronous communication to \rcitem{MicroController} to \rcitem{turn} towards the spot, and the controller itself continues to read and analyse;
% \item otherwise, the controller requests \rcitem{MicroController} to \rcitem{stop} the robot, and then \rcitem{MicroController} requests the platform to drop a \rcitem{flag} on the spot.
% \end{inparaenum} 
% }

{
\begin{figure}
  \centering%
  \includegraphics[width=.95\textwidth]{Chemical.pdf}%
  \caption{The Chemical package of the autonomous chemical detector model.}%
  \label{fig:robochart_acd_chemical}%
\end{figure}
}

The types used in the module are defined in the two imported packages: \rcitem{Chemical} and \rcitem{Location} %(whose diagrams are omitted here for simplicity). 
{shown in Figures~\ref{fig:robochart_acd_chemical} and~\ref{fig:robochart_acd_location}. 
The \rcitem{Chemical} package declares primitive types \rcitem{Chem} and \rcitem{Intensity}, enumerations \rcitem{Status} and \rcitem{Angle}, a record \rcitem{GasSensor} containing two fields (\rcitem{c} of type \rcitem{Chem} and \rcitem{i} of type \rcitem{Intensity}), and five functions specified using preconditions and postconditions (in the original model, two are specified and three are unspecified).
%An operation \rcitem{changeDireciton} in Fig.~\ref{fig:robochart_acd_location}, with a parameter \rcitem{l} of type \rcitem{Loc} and a constant \rcitem{lv}, is also defined using a state machine. 
%
\begin{figure}
  \centering%
  \includegraphics[width=.65\textwidth]{Location.pdf}%
  \caption{The Location package of the autonomous chemical detector model.}%
  \label{fig:robochart_acd_location}%
\end{figure}
%
The \rcitem{Location} package declares an enumeration \rcitem{Loc} and defines an operation \changed[\C{37}]{\rcitem{changeDirection}} using a state machine. The operation has a parameter \rcitem{l} of type \rcitem{Loc} and a constant \rcitem{lv}.
This operation aims to move the robot in the opposite direction of the currently detected gas location \rcitem{l} using a constant linear velocity \rcitem{lv}.

\rcitem{MainController}, defined in the left diagram of Fig.~\ref{fig:robochart_acd_gasanalysis},  is implemented using a state machine \rcitem{GasAnalysis} (by a contained reference to the machine), presented in the right diagram of Fig.~\ref{fig:robochart_acd_gasanalysis}.
}
%
{
\begin{figure}[t]
  \centering%
  \includegraphics[width=0.4\textwidth]{MainController.pdf}%
  \includegraphics[width=0.6\textwidth]{GasAnalysis.pdf}%
  \vspace{-2ex}
  \caption{\rcitem{MainController} and GasAnalysis state machine of the autonomous chemical detector model.}%
  \vspace{-4ex}
  \label{fig:robochart_acd_gasanalysis}%
\end{figure}
}
{
\noindent
The machine \rcitem{GasAnalysis} declares one constant \rcitem{thr} of type \rcitem{Intensity} for the intensity threshold, and four variables (\rcitem{gas} of \rcitem{Seq(GasSensor)}, \rcitem{st} of \rcitem{Status}, \rcitem{i} of \rcitem{Intensity}, and \rcitem{a} of \rcitem{Angle}) for a sequence of gas sensor readings (from the platform), and the gas analysis results including its status (either no gas \rcitem{NoGas} or a gas \rcitem{gasD} detected), intensity and angle. 
The machine also contains a variety of nodes: one initial junction (\includegraphics[align=c,height=8pt]{initial.pdf}), seven normal states such as \rcitem{NoGas} and \rcitem{Analysis}, and a final state (\includegraphics[align=c,height=8pt]{final24.png}). A state may have an \rcitem{entry} action such as an assignment of \rcitem{st} from an application of function \rcitem{analysis} to \rcitem{gs} in the state \rcitem{Analysis}, an exit action, or a \rcitem{during} action.

In state machines, transitions connect states and junctions. Transitions have a label with optional features: a trigger event, a clock reset, a guard condition, and an action. For example, 
the transition of \rcitem{GasAnalysis} from \rcitem{NoGas} to \rcitem{Analysis} has an input trigger \rcitem{gas?gs} enabling the machine to receive sensor readings from the channel \changed[\C{38}]{\rcitem{gas}} and store the value in the variable \rcitem{gas}, and the transition from \rcitem{GasDetected} to \rcitem{Reading} has a guard (\rcitem{not goreq(i, thr)}) and an action (\rcitem{a=location(gs); turn!a}) which is a sequential composition of an assignment and an output communication (\rcitem{turn!a}) enabling the machine to send the angle \rcitem{a} of the detected gas over the channel \rcitem{turn}.

This machine gives the behaviour of the robot's gas analysis: 
\begin{inparaenum}[(1)]
\item enter the state \rcitem{NoGas} after the transition from the initial junction is taken;
\item wait for the gas sensor to be ready on channel \rcitem{gs}, then receive readings, recorded in \rcitem{gs}, on the channel from the platform (via connections from \rcitem{MainController}), and at the same time the transition to state \rcitem{Analysis} is taken;
\item upon entering the state \rcitem{Analysis} whose entry action is executed first to analyse the sensor readings by the function \rcitem{analysis} and to record the result in variable \rcitem{st}; 
\item signal the event \rcitem{resume} if no gas is detected (guard [\rcitem{st == noGas]}) and return to state \rcitem{NoGas};
\item go to state \rcitem{GasDetected} otherwise (guard [\rcitem{st == gasD]});
\item upon entering the state \rcitem{GasDetected} whose entry action is executed to determine the intensity by the function \rcitem{intensity} and to record the result in variable \rcitem{i}; 
\item {signal \rcitem{stop} if the intensity \rcitem{i} is larger than or equal to (implemented in function \rcitem{goreq}) the intensity threshold \rcitem{thr}, and terminate by going to the final state;}
\item {take the transition to state \rcitem{Reading} otherwise with the action of the transition being executed to determine the angle \rcitem{a} of the detected gas and signal \rcitem{turn} towards the angle;}
\item {try to read the gas sensor again at state \rcitem{Reading} with its only outgoing transition, and if the \changed[\C{39}]{transition} is taken, the machine is back to state \rcitem{Analysis}.}
\end{inparaenum}
}

\rcitem{MicroController}, defined in Fig.~\ref{fig:robochart_acd_microcontroller},  is implemented using a state machine \rcitem{Movement} (by a contained reference), presented in Fig.~\ref{fig:robochart_acd_movement}, and a reference to the operation \changed[\C{40}]{\rcitem{changeDirection}}.
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=0.6\textwidth]{MicroController.pdf}%
  %\vspace{-2ex}
  \caption{\rcitem{MicroController} of the autonomous chemical detector model.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_microcontroller}%
\end{figure}
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=1.0\textwidth]{Movement.pdf}%
  %\vspace{-2ex}
  \caption{Movement state machine of the autonomous chemical detector model.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_movement}%
\end{figure}
%
\noindent
The machine \rcitem{Movement} declares various constants such as \rcitem{lv} for linear velocity, four variables (\rcitem{a}, \rcitem{d0}, \rcitem{d1}, and \rcitem{l}) for the preservation of values (angle, odometer readings, and location) carried on communication, and a clock \rcitem{T}. The machine also contains one initial junction, seven normal states such as \rcitem{Waiting} and \rcitem{Going}, and a final state. Notably, the state \rcitem{Waiting} has a \rcitem{during} action, an operation call \rcitem{randomWalk()}, which provides parallelism in a machine and means the robot is doing a random walk \changed[\C{41}]{when waiting for further instructions from \rcitem{MainController} based on the gas analysis result}. This operation can be interrupted at any time as long as a transition from the state is taken.  
The transitions of this machine have labels with various features. The transition from \rcitem{Going} to \rcitem{Avoiding} has an input trigger \rcitem{obstable?l} and a clock reset \rcitem{\rcreset T}, and the transition from \rcitem{TryingAgain} to \rcitem{AvoidingAgain} has an input trigger and an action \rcitem{odometer?d1} (an input communication). The transition from \rcitem{AvoidingAgain} to \rcitem{Avoiding} has a clock reset \rcitem{\rcreset T} and a {disjunctive} guard in which \rcitem{since(T)} counts the elapsed time since the last reset of \rcitem{T}.

This machine gives the behaviour of the robot's response to outcomes of the chemical analysis: 
\begin{inparaenum}[(1)]
\item \rcitem{resume} to state \rcitem{Waiting} {if no gas is detected (implemented in \rcitem{GasAnalysis})};
\item \rcitem{stop} to state \rcitem{Found} and then terminate {if a gas above the threshold is detected};
\item \rcitem{turn} {to the direction, where a gas is detected but not above the threshold, with obstacle avoidance in state \rcitem{Going}};
\item {upon the first detection of an \rcitem{obstacle}, reset \rcitem{T} and start \rcitem{Avoiding} with an initial \rcitem{odometer} reading and the movement direction changed (software \rcitem{wait}s for \rcitem{evadeTime} for the effect of that change);}
\item {if a gas is still detected after the changed direction, \rcitem{TryingAgain} to \rcitem{turn} and \rcitem{move} to the gas direction;}
\item {if another obstacle is detected during avoidance, \rcitem{AvoidingAgain} by reading the \rcitem{odometer} to check the distance of two obstacles;}
\item {if the robot has moved far enough between the two obstacles or not got stuck long enough, go back to continue \rcitem{Avoiding};}
\item {otherwise, the robot has got stuck in a corner, use a \rcitem{shortRandomWalk} for \rcitem{GettingOut} of the area, then resume normal activities.}
\end{inparaenum}

% Next, we describe RoboChart's semantics and return to this model in Sect.~\ref{sec:rc_to_itrees}.
% 
% %\subsection{CSP Semantics}
% %\label{ssec:robochart_csp}
% RoboChart~\cite{Miyazawa2019,RoboChartRef} has formal semantics in CSP.
% % of its core language in CSP and its timed language in tock-CSP~\cite{Baxter2021}. 
% Its untimed semantics ignores timed constructs, such as \rcitem{\#T}, \rcitem{since(T)}, and \rcitem{wait}. 
% %When RoboTool generates the core semantics of RoboChart models, it ignores timed constructs. For example, the clock reset \rcitem{\#T}, the two guards having a timed expression \rcitem{since(T)}, and the \rcitem{wait} action is ignored. 
% Our animation in this paper is based on untimed semantics, which is also generated and used for untimed analysis with FDR in RoboTool.
% 
% The CSP semantics of RoboChart modules, controllers, and state machines are given by processes. The semantics of a model are just the semantics of its module, a CSP process defined by a parallel composition of the processes for its controllers and a memory process for its platform (to record the variables 
% of the platform for sharing between the controllers), synchronising the events according to the connections between the controllers and the platform. 
% 
% Similarly, the semantics of a controller is the parallel composition of the processes for its state machines and memory processes for its variables, synchronising events according to the connections between state machines and the controller.
% %
% The semantics of a state machine is the parallel composition of a process for its state machine behaviour and memory processes for its variables and transitions. We also note the semantics of operations, such as \rcitem{changeDirection}, that are defined using a state machine, provided by a controller, and called in this state machine, are also part of that of this state machine: not only the state machine behaviour but also the memory processes.

%The following section describes interaction trees in Isabelle/UTP, on which the CSP semantics of RoboChart is implemented in this paper.

{
\subsubsection{One-dimensional patrol robot}
\label{ssec:robochart_patrol}

\begin{figure}[t]
  \centering%
  \includegraphics[width=0.7\textwidth]{patrol.pdf}%
  \vspace{0ex}
  \caption{Sections for the patrol robot: S1 - adjacent to the left boundary; S2 - central area; S3 - adjacent to the right boundary.}%
  \vspace{0ex}
  \label{fig:robochart_patrol_sections}%
\end{figure}
In addition to the features introduced in the chemical detector example, RoboChart supports abstraction via nondeterministic choice and interaction via shared variables, exemplified in the model for a one-dimensional patrol robot on a corridor. 
The corridor, as shown in Fig.~\ref{fig:robochart_patrol_sections}, is split into three sections by four boundaries, denoted by their coordinates: \rcitem{-MAX\_INT}, \rcitem{-MAX}, \rcitem{MAX}, and \rcitem{MAX\_INT}. The left and right boundaries are hard and represent the walls, and the other two are soft and represent controlled limits. Section S2, soft boundaries exclusive, is the central working area. The sections S1 and S3, soft boundaries inclusive, are limited, and the robot will tend to move to S2 if it is in these sections. 

The control software of this patrol robot behaves as follows: 
\begin{inparaenum}[(1)]
\item it maintains a belief state ($x$) of the robot, default at 0 (denoting the centre of the corridor) and able to reset to 0 by an event \rcitem{reset};
\item when $x$ is 0, it can be calibrated to the actual position of the robot from its sensor by a \rcitem{cal} event; 
\item when $x$ is within S2, it can be either increased or decreased by 1, denoting the robot moves either to the left or to the right nondeterministically;  
\item when $x$ is within S1, it can only be increased by 1, denoting the robot moves to the right; and 
\item when $x$ is within S3, it can only be decreased by 1, denoting the robot moves to the left.
\end{inparaenum}

\begin{figure}[t]
  \centering%
  \includegraphics[width=1.0\textwidth]{system.pdf}%
  \vspace{0ex}
  \caption{A RoboChart model for a patrol robot with nondeterministic behaviour and interaction using shared variables.}%
  \vspace{0ex}
  \label{fig:robochart_patrol}%
\end{figure}
We illustrate in Fig.~\ref{fig:robochart_patrol} the RoboChart model for this patrol robot. The module \rcitem{PatrolMod} contains a robotic platform \rcitem{RP} and a controller \rcitem{Ctrl} composed of two state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. \rcitem{RP} declares two output events \rcitem{cal} of type \rcitem{int} and \rcitem{reset}, and two inputs events \rcitem{left} and \rcitem{right} (to indicate the direction of moving and its new position) of type \rcitem{int} through the interface \rcitem{eventsInf}, and provides a variable \rcitem{x} of type \rcitem{int} through the interface \rcitem{dataInf}. This variable is shared in \rcitem{Ctrl} and to the two machines by requesting \rcitem{dataInf}.

The machine \rcitem{CalSTM} sets \rcitem{x} to 0 in action (\rcitem{x=0}) of its default transition \rcitem{t0} to state \rcitem{cal}, and then it is ready for calibration from the input trigger \rcitem{cal?l} of the transition \rcitem{t1} if \rcitem{[x==0]}, or to update $x$ (the action \rcitem{update!x} of the transition \rcitem{t2} ) to \rcitem{MoveSTM} through a connection on event \rcitem{update} of type \rcitem{int} otherwise \rcitem{[x!=0]}. We note that it is not mandatory to use this communication mechanism to update \rcitem{x} to \rcitem{MoveSTM} because \rcitem{x} is shared in \rcitem{MoveSTM} too. This illustrates how nondeterminism is introduced in \rcitem{MoveSTM} and how it interleaves with the shared variable. 

The machine \rcitem{MoveSTM} is responsible for resetting \rcitem{x} (\rcitem{x=0}) by the self-transition \rcitem{t2} of state \rcitem{move} with trigger \rcitem{reset}. The robot movement around the corridor is based on the value (of variable \rcitem{x}), which passes on \rcitem{update} and is stored in a local variable \rcitem{l} by the other two self-transitions (\rcitem{t1} and \rcitem{t3}) from state \rcitem{move}. If \rcitem{l} is larger than \rcitem{-MAX} (guard \rcitem{[l>-MAX]} of \rcitem{t3} where \rcitem{MAX} is a constant variable), denoting sections S2 and S3, \rcitem{x} is updated to \rcitem{l-1}, followed by a \rcitem{left!x} event. If \rcitem{l} is less than \rcitem{MAX} (guard \rcitem{[l<MAX]} of \rcitem{t1}), denoting sections S2 and S1, \rcitem{x} is updated to \rcitem{l+1}, followed by a \rcitem{right!x} event. Consequently, if \rcitem{l} is in section S2, the choice between the two transitions is nondeterministic. We note that \rcitem{MAX\_INT} is not explicitly declared in the model and will be given in verification or animation where \rcitem{int} is bounded. 

Next, we describe the extra ITree-based CSP operators for the RoboChart semantics and return to the two models in Sect.~\ref{sec:rc_to_itrees}.
}

\section{Interaction trees}
\label{sec:itree}
This section briefly introduces interaction trees and extends our existing CSP semantics with additional operators to support the RoboChart semantics. These include three operators (interrupt,  exception,  and renaming) introduced in the previous work~\cite{Ye2022}, one generalised choice operator, and two prioritised hiding and renaming operators presented in this extension paper.
%\begin{inparaenum}[(1)]
%\item three operators (interrupt,  exception,  and renaming) that are introduced in the previous work~\cite{Ye2022}, 
%\item one generalised choice operator that is useful to define various choice operators such as redefined external choice and newly introduced biased choice operators, % to resolve nondeterminism statically, 
%\item the prioritised variants of hiding and renaming to statically resolve nondeterminism based on an order.
%This section describes the definition of interaction trees, its data model, and existing CSP constructs briefly first, %in Sect.~\ref{ssec:itree_background}, and then gives semantics to three newly defined CSP operators (interrupt,  exception,  and renaming).% in Sect.~\ref{ssec:itree_csp}.
%\end{inparaenum}

%\subsection{Preliminaries}
%\label{ssec:itree_background}
Interaction trees (ITrees)~\cite{Xia2019} are a data structure for modelling reactive systems interacting with their environment through events. They are potentially infinite and defined as coinductive trees%~\cite[Definition 1]{Foster2021}
~\cite{Blanchette2014} 
in Isabelle/HOL.
% through the command \isakwmaj{codatatype}. %shown in Definition~\ref{def:itrees}.
%\begin{definition}[Interaction Trees]
%\label{def:itrees}
\newcommand{\itreedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L22}}
\begin{alltt}
\isakwmaj{codatatype} (\textquotesingle{e}, \textquotesingle{r}) itree = \(\itreedef\) 
  Ret \textquotesingle{r} | Sil "(\textquotesingle{e}, \textquotesingle{r}) itree" | Vis "\textquotesingle{e} \(\pfun\) (\textquotesingle{e}, \textquotesingle{r}) itree"
\end{alltt}
%\end{definition}
\noindent ITrees are parameterised over two types: \texttt{\textquotesingle e} for events ($E$), and \texttt{\textquotesingle r} for return values or states ($R$) . Three possible interactions are provided: 
\begin{inparaenum}[(1)]
	\item $\Ret~x$: termination with a value $x$ of type $R$ returned, denoted as $\tick_x$;\footnote{\changed[\C{27}]{We note that $\tick_x$ is just a shorthand for $\Ret~x$ and $\tick$ cannot be used alone. In some CSP literature, such as ~\cite{Roscoe2011}, $\tick$ means a special event representing termination. We do not refer to the single $\tick$ in this paper.}}
	\item $\Sil~P$: an internal silent event, denoted as $\tau P$ for a successor ITree $P$; or
	\item $\Vis~F$: a choice among several visible events represented by a partial function $F$ of type $E \pfun (E,R) \cspkey{itree}$.
%; the choice of visible events and their continuation is represented as a partial function $F$ of type $E \pfun (E,R) \cspkey{itree}$.
\end{inparaenum}
Partial functions are part of the Z toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.}~\cite{Spivey1992}, which is also mechanised in Isabelle/HOL. We also use a notation $\vbar\, e\!\in\!E \then P(e)$ for $\Vis~(\lambda e \in E @ P(e))$.

\changed[\C{7}]{Though ITrees are elementary structures, they can be used to encode, animate, and symbolically reason about the complex behaviour of systems of interacting concurrent processes. ITrees is a model that gives semantics to various languages and potentially unifies them.} In particular, deterministic CSP processes can be given executable semantics using ITrees. Determinism is inherent since we use a partial function to model events and their continuations. Precisely, each unique event must map to at most one continuation. The benefit of this approach is that ITrees are easy to implement and animate since the behaviour depends solely on provided input events. Therefore, our CSP operators cannot introduce nondeterminism, which must be statically resolved.

Our animator takes a model with ITree-based semantics in Isabelle/HOL and generates Haskell code for the underlying ITree. Though this is often an infinite structure, Haskell's intrinsic use of lazy evaluation allows us to model and partially evaluate infinite objects. We can, therefore, step through an ITree's behaviour by unfolding the various constructors of the underlying algebraic (co)datatype. When a $\Vis$ constructor is encountered, the user is presented with a choice for one of the enabled events. When a $\Sil$ is encountered, it is removed, and the successor ITree is animated. This allows us to compress long sequences of $\tau$ events and simplified animation. Finally, $\Ret$ leads to the termination of the animation.

%These processes are parametrised over a type $E$ of events, which is declared through the \isakwmaj{chantype} command, representing the event alphabet ($\Sigma$) of the CSP processes. $E$ is expressed by a finite set of channels declared in the command.  
%Each channel $c$ is modelled by a prism~\cite{Pickering2017}: $V \pto E$ where $V$ is the value type of $c$. Each prism contains two functions~\cite[Definition 5]{Foster2021}: a destructor \IsaKey{match} and a constructor \IsaKey{build}. We use \IsaKey{c\_C} for \IsaKey{build}$_c$. %Example~\ref{ex:chantype} illustrates the creation of such an event alphabet \texttt{chan}.
%
%\begin{example}[Event alphabet and channels]\label{ex:chantype}
%\isalink{https://github.com/isabelle-utp/interaction-trees/blob/666527fb6e860ea79e94a8258f87e2669c1eddf8/examples/ITree_CSP_Examples.thy\#L25}
%\begin{alltt}
%\isakwmaj{chantype} chan = 
%  	Input::integer     Output::integer     State::"integer list"
%\end{alltt}
%\end{example}
%
%\noindent This \texttt{chan} is expressed by three channels: \texttt{Input} and \texttt{Output} of type \texttt{integer}, and \texttt{State} of type integer lists. These channels are characterised through prisms~\cite{Pickering2017} ($V \pto E$ where $V$ is the value type of a channel). Each channel in \texttt{chan} is modelled by a prism. For example, the channel \texttt{Input},  carrying a value of \texttt{integer}, has a type \texttt{integer~}$\pto$\texttt{~chan}. 
%
%CSP processes usually do not return a value and are typically of type \texttt{(E, unit) itrees}. Internal components of a CSP process, such as \texttt{input?x \(\then\) output!x \(\then\) skip}, however, could pass a value to the subsequent process in scope through binding in CSP.
%

Previously\changed[\C{17}]{~\cite{Foster2021}}, the following CSP processes and operators have been defined: 
\begin{inparaenum}[(1)]
	\item basic processes: \cspkey{skip}, \cspkey{stop}, and \cspkey{div}; % and  \cspkey{run};
    \item input prefixing: $\cspkey{inp}~c~V$ (communicate any value from \changed[\C{42}]{$V$} over the channel $c$);%$\cspkey{inp}::(E \pto V) \Rightarrow \power V \Rightarrow (E, V) \cspkey{itree}$; 
	%\item \cspkey{inp}: an input event; 
	%\item \cspkey{outp}: an output event;
	%\item input prefixing $c?x$;
	\item output prefixing $c!v$ \changed[\C{43}]{(send a value $v$ over the channel $c$)};
	%\item $\cspkey{guard}~::~\Bool \Rightarrow (E, unit) \cspkey{itree}$;
	\item $\cspkey{guard}~b$ \changed[\C{43}]{(guarded based on a Boolean value $b$)};
	%\item $b \& P$
	\item external choice $P \extchoice Q$ \changed[\C{43}]{between two processes $P$ and $Q$}; 
	\item parallel composition $P \parallel_A Q$;
	\item hiding $P \hide A$; 
	\item sequential composition $P \fatsemi Q$; %$P \mbind Q$;
	%\item \cspkey{while} and two special cases: \cspkey{loop} and \cspkey{iter}.
	\item \cspkey{loop} and \cspkey{iterate}.
\end{inparaenum} 
\changed[\C{9},\C{10}]{
We summarise their definitions in Table~\ref{table:existing_csp_itrees} and show some definitions omitted in the table (due to the large space they will take) as follows.

\newcommand{\skippdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L50}}
\newcommand{\deadlockdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/ITree_Deadlock.thy\#L9}}
\newcommand{\stopdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L11}}
\newcommand{\divdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/ITree_Divergence.thy\#L77}}
\newcommand{\rundef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L240}}
\newcommand{\runaltdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L243}}
\newcommand{\inpdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L59}}
\newcommand{\outpdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L155}}
\newcommand{\guarddef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L161}}
\newcommand{\extchoicedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L424}}
\newcommand{\paralleldef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L844}}
\newcommand{\interleavedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L846}}
\newcommand{\hidedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L898}}
\newcommand{\seqdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L142}}
\newcommand{\iteratedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/ITree_Iteration.thy\#L9}}
\newcommand{\loopdef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/ITree_Iteration.thy\#L12}}

\begin{table}[!htb]
  \setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
  \caption{\label{table:existing_csp_itrees} \changed[\C{9}]{A summary of the existing basic CSP operators defined in the previous work~\cite{Foster2021}. The definitions for $\extchoice$, $\Vert_A$, % here $\Vert$ should be $\parallel_A$, but it causes a problem when it is in a caption.
  $\interleave$, $\hide$, and $\fatsemi$ are omitted in the table (because their definitions take a large space) and are presented and discussed in the overview of Sect.~\ref{sec:itree}.}}
  \resizebox{\textwidth}{!}{
  \begin{tabularx}{\textwidth}{c|c|X}
    \hline
    \textbf{Operator} & Definition & Description \\
    \hline
    \cspkey{skip} & $\Ret ()$ \skippdef & Terminate immediately, and return a unit type $()$, a degenerate form of $\Ret$.\\ 
    \hline
    \cspkey{stop} & $\Vis~ \{\mapsto \}$ \deadlockdef\stopdef & Deadlock, or no event is possible. \\ 
    \hline
    \cspkey{div} & $\isakwmaj{primcorec}\ \cspkey{div} = \tau \cspkey{div} $ \divdef & ITree of infinite depth, a divergent ITree that does not terminate and only performs internal activity. \\ 
    \hline
    $\cspkey{run}~E$ & $\vbar\, e\!\in\!E \then \cspkey{run}~E$ \runaltdef & Repeatedly perform any event from $E$. We give an alternative definition instead of the original definition for simplicity.\\
    \hline
    $\cspkey{inp}~c~V$ & $\Vis~\left(
        \begin{array}{l}
        \lambda e \in \left(
        \begin{array}{l}
            \dom(\pmatch_c) \\
            \cap \pbuild_c \limg A \rimg
        \end{array}\right) \\
        @ \Ret~(\pmatch_c~e)
        \end{array}\right)$ \inpdef & Accept a constrained input (only the values from $V$) over channel $c$ and return the value. \\
    \hline
    $\cspkey{outp}~c~v$ & $\Vis~\{\pbuild_c~v \mapsto \Ret~()\}$ \outpdef & Send a value $v$ over channel $c$, or denoted as $c!v$.\\
    \hline
    $\cspkey{guard}~b$ & $\IF b \THEN skip \ELSE stop$ \guarddef & Behave as $\cspkey{skip}$ if $b$ is true and otherwise $\cspkey{stop}$. \\
    \hline
    $b \& P$ & $\isakwmin{do} \{ \cspkey{guard}~b; P\}$ & Guarded process. \\
    \hline
    $P \fatsemi Q$ & \seqdef & Sequential composition of $P$ and $Q$.\\
    \hline
    $P \extchoice Q$ & \extchoicedef & External choice, redefined in Sect.~\ref{ssec:itree_genchoice}. \\
    \hline
    $P \parallel_A Q$ & \paralleldef & Parallel composition of $P$ and $Q$ over $A$.\\
    \hline
    $P \interleave Q$ & \interleavedef & Interleave of $P$ and $Q$.\\
    \hline
    $P \hide A$ & %$\Vis~F = \begin{cases}
       %\Sil~\left(F(e) \hide A\right) & \IF A \cap \dom(F)=\{e\} \\
       %\Vis~\{(e, P \hide A \mid (e, P) \in F\} & \IF A \cap \dom(F)= \emptyset\\
       %\cspkey{stop} & \text{Otherwise}
    %\end{cases}
    %\Sil(P) \hide A = \Sil(P\hide A)
    %\Ret x \hide A = \Ret x
    %$
    \hidedef & Hide the events in $A$ from $P$.\\
    \hline
    $\cspkey{iterate}~b~P~s$ & $\begin{array}{l}
        %\cspkey{iterate}~b~P~s = \\
        \IF (b~s) \THEN \\
        \quad\Sil (P~s \mbind \cspkey{iterate}~b~P) \\
        \ELSE \tick_s
    \end{array}$ \iteratedef & Continue to execute $P$ %with its current state $s$ passed to next iteration 
    while the condition $b~s$ holds and otherwise terminates and returns the current state $s$. Also called $\cspkey{while}$ in~\cite{Foster2021}.\\
    \hline
    $\cspkey{loop}~P$ & $\cspkey{iterate}~(\lambda s. True)~P$ \loopdef& Infinite loop.\\
    \hline
  \end{tabularx}}
\end{table}

\changed[\C{21}]{External choice $P \extchoice Q$ is defined corecursively. \changed[\C{23}]{A corecursive definition can have several equations ordered by priority.} \isalink{https://github.com/isabelle-utp/interaction-trees/blob/ff9f73f98c653b265bd9da55689715cf973499c1/ITree_CSP.thy\#L75}
\begin{align*}
    (\Vis~F) \extchoice (\Vis~G) &= \Vis~(F \odot G) \\
    (\Sil~P') \extchoice Q &= \Sil~(P' \extchoice Q) \\
    P \extchoice (\Sil~Q') &= \Sil~(P \extchoice Q') \\
    (\Ret~x) \extchoice (\Vis~G) &= \Ret~x \\
    (\Vis~F) \extchoice (\Ret~y) &= \Ret~y \\
    (\Ret~x) \extchoice (\Ret~y) &= (\textit{if}~x = y~\textit{then}~(\Ret~x)~\textit{else}~\skey{stop})
\end{align*}
The merge function $F \odot G \defs (\dom(G) \ndres F) \oplus (\dom(F) \ndres G)$ is used to define the \Vis~case. \changed[\C{19}]{The $\ndres$ is called the domain anti-restriction, and $A \ndres R$ denotes the domain restriction of relation $R$ to the complement of set $A$.} \changed[\C{18}]{The $\oplus$ is a relational overriding operator.} For example, $A \oplus B$ agrees with the relation $B$ and with the relation in $A$ outside the domain of $B$. The relation in $A$ inside the domain of $B$ is overridden by $B$. This function $F \odot G$ combines all event maplets from $F$ and $G$, ignoring any maplets whose events occur in the intersection $\dom(F) \cap \dom(G)$. For example $\{e_1 \mapsto P_1, e_2 \mapsto P_2\} \odot \{e_3 \mapsto P_3, e_2 \mapsto P_4\} = \{e_1 \mapsto P_1, e_3 \mapsto P_3\}$, since $e_2$ is ignored. This avoids nondeterminism; when the two domains are disjointed, the operator can be considered a union.}

Sequential composition ($P \fatsemi Q$) of ITrees is supported through a monadic bind operator ($\mbind$): $P \fatsemi Q \defs \left(\lambda x. P(x) \mbind Q\right)$ which executes $P$ first, and then passes the value of $x$ to its continuation $Q$ upon the termination of $P$. The $P \mbind Q$ is defined corecursively, including several equations ordered by priority.  \isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L142}
\begin{align*}
    \tick_r \mbind Q &= Q(r) \\%\tag*{(pass the value of $x$ to $Q$ immediately)}\\
    \tau P' \mbind Q &= \tau(P' \mbind Q) \\%\tag*{($\tau$ happens independently )}\\
    \Vis~F \mbind Q &= \Vis~(\lambda e \in \dom(F) @ F(e) \mbind Q) %\tag*{()}
\end{align*}
With the monadic \isakwmin{do} notation, we can write a sequential composition like the one shown below. 
$$\isakwmin{do}\{x \gets \cspkey{inp}~c~V; outp~d~(x+1) ; \tick_x \}$$ 
This is equivalent to the composition:
$$inp~c~V \mbind \left(\lambda x. outp~d~(x+1) \mbind (\lambda y. \tick_x)\right)$$
This process accepts input from set $V$ on channel $c$, records the value in $x$, passes $x$ to its continuation, which sends $x+1$ on channel $d$, and afterwards terminates and returns the value of $x$.

Parallel composition $P \parallel_E Q$ over a set $E$ of events is defined corecursively below. \isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L844}
\begin{align*}
    (\Sil~P') \parallel_E Q &= \Sil~(P' \parallel_E Q) \\
    P \parallel_E (\Sil~Q') & = \Sil~(P \parallel_E Q') \\
    (\Vis~F) \parallel_E (\Vis~G) &= 
        \Vis\left(\begin{array}{l}
            \{e \mapsto (P' \parallel_E (\Vis~G)) | (e \mapsto \skey{Left}(P')) \in merge_E(F, G)\} \\
            \oplus~ \{e \mapsto ((\Vis~F) \parallel_E Q') | (e \mapsto \skey{Right}(Q')) \in merge_E(F, G)\} \\
            \oplus~ \{e \mapsto (P' \parallel_E Q') | (e \mapsto \skey{Both}(P', Q')) \in merge_E(F, G)\}
        \end{array}\right) \\
    (\Ret~x) \parallel_E (\Ret~y) &= \Ret~(x, y) \\
    (\Ret~x) \parallel_E (\Vis~G) &= \Vis~\{e \mapsto \left(\Ret~x \parallel_E Q'\right) | (e \mapsto Q') \in G\} \\
    (\Vis~F) \parallel_E (\Ret~y) &= \Vis~\{e \mapsto \left(P' \parallel_E \Ret~y\right) | (e \mapsto P') \in F\}
\end{align*}
The definition of the \Vis\ case uses an operator $merge_E(F, G)$ to merge two event functions. We omit its definition here for simplicity and refer to~\cite{Foster2021} for more details. \changed[\C{44}]{For the sake of presentation, we present partial functions as sets and use set comprehensions for construction.} \changed[\C{18}]{A set comprehension $\{e | P\}$ is a shorthand for $\{e | x~y. P\}$ if $x$ and $y$ are free variables of $e$ and occur in $P$. For example, $\{e \mapsto \left(\Ret~x \parallel_E Q'\right) | (e \mapsto Q') \in G\}$ in the above definition means $\{e \mapsto \left(\Ret~x \parallel_E Q'\right) | e~Q'. (e \mapsto Q') \in G\}$, that is, any maplet $e \mapsto Q'$ (a visible event $e$ and its continuation $Q'$) in the partial function $G$ becomes $e \mapsto \left(\Ret~x \parallel_E Q'\right)$. }

Interleave $P \interleave Q$ is simply the parallel composition over the empty set: $P \parallel_{\emptyset} Q$. \isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L846}

Hiding $P \hide A$ is defined corecursively below. \isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L898}
\begin{align*}
    & \Vis~F = \begin{cases}
        \Sil~\left(F(e) \hide A\right) & \IF A \cap \dom(F)=\{e\} \\
        \Vis~\{(e, P \hide A \mid (e, P) \in F\} & \IF A \cap \dom(F)= \emptyset\\
        \cspkey{stop} & \text{Otherwise}
    \end{cases} \\
    & \Sil(P) \hide A = \Sil(P\hide A)\\
    & \Ret x \hide A = \Ret~x
\end{align*}

The hiding operator is restricted to at most one event once to avoid nondeterminism introduced by hiding multiple events. However, hiding more than one event can be achieved through hiding with priority described in Sect.~\ref{ssec:itree_hiding_with_priority}. 

Though operators like external choice and parallelism can introduce nondeterminism, we restrict this by construction. Nevertheless, different strategies \changed[\C{20}]{such as biased operators, which give priority to the left-hand side or right-hand side process of the operators, and priority based on an order of events for hiding or renaming,} can be employed for statically resolving nondeterminism, which we explore further in this section. \changed[\C{20}]{We use these strategies to define alternative operators for different purposes.}
}
%\subsection{Data model}
%The data model of ITrees is based on that of Isabelle/HOL and also the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}. For example, partial functions used in the definition of ITrees are part of the Z toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.} which is also mechanised in Isabelle/HOL. Other examples in the toolkit that are mechanised for this work include partial injections ($\pinj$, \isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/b78103d556a528d5a7739c10fdcfdbe81a9396d7/Partial_Inj.thy}) and bounded lists: \texttt{('a, 'n::finite) blist} \isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/52c815c7f6b1c4f9259eacae4a23b020db58f6e9/Bounded_List.thy\#L10}, denoting a set of all lists of type \texttt{'a} 
%\verb+'a+ $'a$ \isa{\isacharprime a}
%, in which the length of each list is bounded by the cardinality of a finite type \texttt{'n}. A numeral type \texttt{2} is such a finite type that contains two elements: zero (\texttt{0::2}) and one (\texttt{1::2}).

%\subsection{CSP operators}
%\label{ssec:itree_csp}
Next, we give an ITree semantics to extra CSP operators to allow us to give an ITree-based semantics to RoboChart. We 
\begin{inparaenum}[(1)]
    \item generalise external choice; 
    \item introduce three new operators---interrupt, exception, and renaming operators---used in the RoboChart's semantics to allow interruption of a during-action, termination of a state machine, a controller, or a module, and alphabet transformation of processes; and 
    \item add prioritised variants of renaming and hiding to resolve nondeterminism based on an order statically.
\end{inparaenum}
% for parallel composition.
% The interrupt operator is used in the RoboChart's semantics to allow interruption during the action by a taken transition.  The exception operator enables the termination of a state machine,  a controller,  or a module.  Synchronisation and communication are defined via connections in RoboChart, and they are realised in semantics using the renaming operator to rename events of corresponding processes because CSP relies on the name of events for synchronisation.
We restrict ourselves to deterministic operators as it makes the animation of large models more efficient. 

\subsection{Generalised choice and external choice}
\label{ssec:itree_genchoice}

Previously~\cite{Foster2021}, we have given semantics to CSP's external choice operator as a corecursive definition. Our mechanisation of ITrees intrinsically supports external choice through the use of partial functions to model visible events. However, our definition of choice can be generalised to support more flexible choice schemes. For example, priority can be given to one branch of the choice to resolve any nondeterminism statically. We achieve this through a novel generalised choice operator, $\genchoice{P}{\mathcal{M}}{Q}$. For this, we use a merge function $\mathcal{M}$, which merges two choice functions of type $E \pfun (E, R)\textit{itree}$. The operator is defined as a corecursive function using the equations listed below.

\begin{definition}[Generalised choice]\label{def:genchoice}
%$P \interrupt Q$ is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L169}
\begin{align*}
\arraycolsep=1.4pt
\begin{array}{rlrl}
    \genchoice{\left(\Vis~F\right)}{\mathcal{M}}{\left(\Vis~G\right)} &= \Vis~\left(\mathcal{M}~F~G\right)
    &\qquad \genchoice{\left(\Ret~x\right)}{\mathcal{M}}{\left(\Ret~y\right)} &= \left(\IF x = y \THEN \Ret~x \ELSE \cspkey{stop}\right)  \\ [3pt]
%
 \genchoice{\left(\Sil~P'\right)}{\mathcal{M}}{Q} &= \Sil~\left(\genchoice{P'}{\mathcal{M}}{Q}\right) 
 &\qquad \genchoice{P}{\mathcal{M}}{\left(\Sil~Q'\right)} &= \Sil~\left(\genchoice{P}{\mathcal{M}}{Q'}\right) \\ [3pt]
 \genchoice{\left(\Ret~v\right)}{\mathcal{M}}{\left(\Vis~G\right)} &= \Ret~v 
 &\qquad \genchoice{\left(\Vis~F\right)}{\mathcal{M}}{\left(\Ret~v\right)} &= \Ret~v\\ %[2pt]
%\qquad P \interrupt \left(\Sil~Q'\right) = \Sil~\left(P \interrupt Q'\right) \\ [1pt]
%\left(\Ret~x\right) \interrupt Q = \Ret~x 
%\qquad\qquad\quad\  P \interrupt \left(\Ret~x\right) = \Ret~x \\[1pt]
%\left(\Vis~F\right) \interrupt \left(\Vis~G\right)  = \Vis \left(
%\begin{array}{l}
%\left\{ e \mapsto \left(P' \interrupt Q\right) | \left(e \mapsto P' \right) \in \left(\ZKey{$\dom$}(G) \ndres F\right) \right\} 
%\oplus G
%%\\
%%\left\{ e \mapsto Q' | \left(e \mapsto Q' \right) \in G \right\}
%\end{array}
%\right) 
\end{array}
\end{align*}
\end{definition}

\noindent When choosing between two visible event functions, $\Vis~F$ and $\Vis~G$, the merge function is applied to combine the two. When combining two return value ITrees, $\Ret~x$ and $\Ret~y$, we require the two possible values to be identical and otherwise deadlocked to avoid nondeterminism. For silent events ($\tau$) and returns, we also prioritise their occurrence before any visible activity can occur. In particular, any $\tau$ events are greedily consumed before any visible event or return can occur.

With generalised choice, we can redefine external choice $P \extchoice Q \defs \genchoice{P}{\odot}{Q}$.
%With generalised choice, we can define external choice using a merge function $F \odot G \defs \left(\dom(G) \ndres F\right) \oplus \left(\\dom(F) \ndres G\right)$ \changed[\C{20}]{where $\ndres$ is called the domain anti-restriction}, and defining $P \extchoice Q \defs \genchoice{P}{\odot}{Q}$. % This function combines all event maplets from $F$ and $G$, ignoring any maplets whose events occur in the intersection $\dom(F) \cap \dom(G)$. For example $\{e_1 \mapsto P_1, e_2 \mapsto P_2\} \odot \{e_3 \mapsto P_3, e_2 \mapsto P_4\} = \{e_1 \mapsto P_1, e_3 \mapsto P_3\}$, since $e_2$ is ignored. Again, this avoids nondeterminism, and when the two domains are disjointed, the operator can be considered a union.

Another benefit of the generalised choice operator is that, as with Hoare and He's parallel-by-merge operator~\cite{Hoare1998}, its properties reduce to the merge function itself. This simplifies proof of algebraic properties for choice functions. The most basic property of a merge function is well-formedness:

\begin{definition}[Wellformed merge function]
A merge function $\mathcal{M}$ is well-formed provided that for any choice function $F$, $\mathcal{M}~\emptyset~F = \mathcal{M}~F~\emptyset = F$.
\end{definition}

\noindent A wellformed merge function has the empty choice function $\emptyset$ as a left and right identity. For example, it is clear that $\odot$ is well-formed because $\dom(\emptyset) = \emptyset$. From this definition of well-formedness, we obtain the following properties.

\begin{thm}[Generalised choice] If $\mathcal{M}$ is well-formed, then 
\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L238}
\begin{align*}
    \genchoice{P}{\mathcal{M}}{\cspkey{stop}} =\,& \genchoice{\cspkey{stop}}{\mathcal{M}}{P} = P \\ 
    \genchoice{P}{\mathcal{M}}{\cspkey{div}} =\,& \genchoice{\cspkey{div}}{\mathcal{M}}{P} = \cspkey{div} \\
    \genchoice{P}{\mathcal{M}}{Q} =& \genchoice{Q}{\mathcal{M}^{\sim}}{P}
\end{align*}
\end{thm}

\noindent Generalised choice has $\cspkey{stop}$ as a unit since it can add no further behaviour. Moreover, $\cspkey{div}$ is a zero since $\tau$ events always take priority, so a divergent process prevents choices. We can commute a choice by taking the converse of the merge function, where $\mathcal{M}^{\sim} = (\lambda F~G.\, \mathcal{M}~G~F)$. As a result of the final law, if $\mathcal{M}$ is symmetric, that is $\mathcal{M} = \mathcal{M}^{\sim}$, then choice is commutative: $\genchoice{P}{\mathcal{M}}{Q} = \genchoice{Q}{\mathcal{M}}{P}$. These properties show that external choice is commutative and has $\cspkey{stop}$ as a unit. The former follows because $f \oplus g = g \oplus f$ whenever $\dom{f} \cap \dom{g} = \emptyset$, a property that is ensured by the construction of $\odot$.

We now consider how we can derive alternative choice schemes. In some circumstances, it may be undesirable that possible events are lost by external choice. For example, $a \then P \extchoice a \then Q$ ends as $\cspkey{stop}$ since both processes have $a$ as an initial event. Instead, We can resolve any nondeterminism by prioritising the addition of events from either the left or right branches. We introduce a biased choice operator, $P \extchoicel Q \defs \genchoice{Q}{\oplus}{P}$, which chooses events from $P$ whenever initial events are present in both $P$ and $Q$. For example, $a \then P \extchoicel a \then Q = a \then P$, since the event from the left branch is prioritised.

%\begin{definition}[External choice and biased external choice]\label{def:extchoice}
%$P \interrupt Q$ is defined corecursively by the following equations: 
% \begin{align*}
%    & f \odot g = \left(\ZKey{$\dom$}(g) \ndres f\right) \oplus \left(\ZKey{$\dom$}(f) \ndres g\right)  \tag*{[Product of partial functions]\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L368}} \label{def:map_prod}\\
%    & P \extchoice Q = \genchoice{P}{\odot}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L435}}\\
%    & P \extchoicel Q = \genchoice{P}{\left(\lambda f\,g \bullet g \oplus f\right)}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP_Biased.thy\#L11}}\\ 
%    & P \extchoicer Q = \genchoice{P}{\oplus}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP_Biased.thy\#L14}}\\ 
%\end{align*}
%\end{definition}

%\subsection{Biased external choice and biased parallel composition}

\subsection{Interrupt}
The second operator we introduce is interrupt~\cite{Hoare1985,Roscoe2011}, $P \interrupt Q$, which behaves like $P$ except that if at any time $Q$ performs one of its initial events, it takes over. This operator, along with the other two, is defined corecursively, which allows them to operate on the infinite structure of an ITree. In corecursive definitions, every corecursive call on the right-hand side of each equation must be guarded by an ITree constructor. 
%
\begin{definition}[Interrupt]\label{def:interrupt}
%$P \interrupt Q$ is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L952}
\begin{align*}
\begin{array}{l}
\left(\Sil~P'\right) \interrupt Q = \Sil~\left(P' \interrupt Q\right)
\qquad P \interrupt \left(\Sil~Q'\right) = \Sil~\left(P \interrupt Q'\right) \\ [1pt]
\left(\Ret~x\right) \interrupt Q = \Ret~x 
\qquad\qquad\quad\  P \interrupt \left(\Ret~x\right) = \Ret~x \\[1pt]
\left(\Vis~F\right) \interrupt \left(\Vis~G\right)  = \Vis \left(
\begin{array}{l}
\left\{ e \mapsto \left(P' \interrupt Q\right) | \left(e \mapsto P' \right) \in \left(\ZKey{$\dom$}(G) \ndres F\right) \right\} 
\oplus G
%\\
%\left\{ e \mapsto Q' | \left(e \mapsto Q' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\end{align*}
\end{definition}
%
%In the definition, $\ndres$ is called the domain anti-restriction, and $A \ndres R$ denotes the domain restriction of relation $R$ to the complement of set $A$. 
The $\Sil$ cases allow $\tau$ events to happen independently with priority and without resolving $\interrupt$. The $\Ret$ cases terminate with $x$ returned from $ \ interrupt$'s left or right side.

\changed[\C{45}]{The $\Vis$ case also results in a $\Vis$ process} constructed from an overriding $\oplus$ of the further two sets, representing two partial functions.  In the partial function,  $(\ZKey{$\dom$}(G) \ndres F)$ restricts the domain of $F$ to the complement of the domain of $G$.  %Here $\ndres$ is called the domain anti-restriction. 
The first partial function denotes that an initial event $e$ of $P$, not the initial event of $Q$, can occur independently (without resolving the interrupt), and its continuation is a corecursive call $P' \interrupt Q$.  
The second function is just $G$,  which 
denotes that the initial events of $Q$ can happen whether they are in $F$ or not. 
%Then the subsequent process $Q'$ will take over. 
If $P$ and $Q$ share events, $Q$ has priority.  This prevents nondeterminism.
%In the partial functions, the operator $merge_E(F, G)$, defined in the recent work~\cite{Foster2021} for parallel composition, merges two event functions by tagging each event with $\IsaKey{Left}$, $\IsaKey{Right}$, or $\IsaKey{Both}$ depending on whether this event occurs on $F$ only (not in $E$), $G$ only (not in $E$), or both (also in $E$). In the merge expression $merge_{\emptyset}(\ZKey{dom}(G) \ndres F, G)$, $E$ is $\emptyset$ and so  $\IsaKey{Both}$ is not possible. This, together with the first or left expression $\ZKey{dom}(G) \ndres F$, which restricts the domain of $F$ to the complement of the domain ($\ZKey{dom}$, the domain of a partial function) of $G$, also called domain anti-restriction $\ndres$, is necessary to prevent nondeterminism by giving priority to the right side if both sides share the same events.  For example, $(a \then P) \interrupt (a \then Q) = a \then Q$.

\subsection{Exception}
Next, we present the exception operator, $\except{P}{A}{Q}$, which behaves like $P$ initially, but if $P$ ever performs an event from the set $A$, then $Q$ takes over. 
%
\begin{definition}[Exception]\label{def:exception}
%$\except{P}{A}{Q}$ is defined corecursively by the following equations:
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L1012}
\begin{align*}
\begin{array}{l}
\except{\left(\Ret~x\right)}{A}{Q} = \Ret~x \qquad 
\except{\left(\Sil~P'\right)}{A}{Q} = \Sil~\left( \except{P'}{A}{Q} \right) \\[1pt]
\except{\left(\Vis~F\right)}{A}{Q}
 = %\left(
%\begin{array}{l}
%\LET m = merge_{\emptyset}(A \ndres F, \{e \mapsto Q | e \in (A \cap \ZKey{dom}(F))\}) \\
\Vis \left(
\begin{array}{l}
\left\{ e \mapsto \left(\except{P'}{A}{Q}\right) | \left(e \mapsto P' \right) \in (A \ndres F) \right\} 
\oplus \\
\left\{ e \mapsto Q | e \in (A \cap \ZKey{$\dom$}(F)) \right\}
\end{array}
\right) 
%\end{array}
%\right)
\end{array}
\end{align*}
\end{definition}
%
The $\Ret$ case terminates immediately with the value $x$ returned, and $Q$ will not be performed. The $\Sil$ case consumes the $\tau$ event.

%In the $\Vis$ case, we use the $\LET$ expression to declare a local variable $m$ to be used in the expression after $@$. This is merely for the sake of presentation. The variable $m$ is a merge of two event functions. The events of $F$ not in $A$, $A \ndres F$ are tagged with $\IsaKey{Left}$. And for the events, $(A \cap (\ZKey{dom}(F)))$ of $F$ that are in $A$, they are tagged with $\IsaKey{Right}$ and the subsequent process after these events is $Q$ because the right side of the merge is a partial function, $\{e \mapsto Q | e \in (A \cap \ZKey{dom}(F))\}$. Additionally, as $E$ in $merge$ is $\emptyset$, the tag $\IsaKey{Both}$ is also not possible. 

Similar to Definition~\ref{def:interrupt}, the $\Vis$ case is also represented by the overriding of two partial functions. The first partial function means that an initial event $e$ of $P$ that is not in $A$ (that is, $e \in \ZKey{$\dom$}(A \ndres F)$)  can occur independently. Its continuation is a corecursive call $\except{P'}{A}{Q}$. Following the execution of an initial event $e$ of $P$ that is in $A$ (that is,  $e \in (A \cap \ZKey{$\dom$}(F)$),  the exception behaves like $Q$, which is expressed by the second partial function.

\subsection{Renaming}
\label{ssec:itree_renaming}
The other new operator we define for this work is renaming, $\rename{P}{\rho}$, which renames events of $P$ according to the renaming relation $\rho:E_1 \rel E_2$, which is equivalent to $\power (E_1 \cross E_2)$. 
This relation is possibly heterogeneous, so $E_1$ and $E_2$ are different types of events.
 %has each event $e_1$ of $P$ renamed to $e_2$ where $\left(e_1 \mapsto e_2\right)$ is in the renaming relation $\rho$. 
%The objective here is to define the operator so that it does not introduce nondeterminism. 
First, we define an auxiliary function for making a relation functional by removing any pairs with duplicate distinct values. This is the case when the renaming relation is functional, restricted to the initial events of $P$.
%
\begin{align*}
mk\_functional(R) = \{(x, y) \in R. \forall y'. (x, y') \in R \implies y=y' \}
\end{align*}
%
This produces the minimal functional relation that is consistent with $R$. For example, 
\begin{align*}
mk\_functional \left(\{e_1 \mapsto e_2, e_1 \mapsto e_3, e_2 \mapsto e_3 \}\right) = \{e_2 \mapsto e_3\}
\end{align*}
This function avoids nondeterminism introduced by renaming multiple events to the same event. We use this function to define the renaming operator.
\begin{definition}[Renaming]\label{def:rename}
%$\rename{P}{\rho}::(E_1, R) \cspkey{itree} \Rightarrow (E_1 \rel E_2) \Rightarrow (E_2, R) \cspkey{itree}$ 
% is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L1048}
\begin{align*}
\begin{array}{l}
\rename{\left(\Ret~x\right)}{\rho} = \Ret~x \\[1pt] 
\rename{\left(\Sil~P'\right)}{\rho} = \Sil~\left( \rename{P'}{\rho} \right) \\[1pt]
\rename{\left(\Vis~F\right)}{\rho}
 = \left(
\begin{array}{l}
\LET 
G = F \circ mk\_functional\left( (\ZKey{$\dom$}(F) \dres \rho)^{\inv}\right) \\
@ \Vis \left(
\begin{array}{l}
\left\{ e_2 \mapsto \left(\rename{P'}{\rho}\right) | \left(e_2 \mapsto P' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\right)
\end{array}
\end{align*}
\end{definition}
The $\Ret$ case behaves like $P$, and the renaming does not affect it. The $\Sil$ case allows $\tau$ events to be consumed since they are not subject to renaming. 

In the $\Vis$ case, $G$ is a partial function ($E_2 \pfun (E_1, R)\cspkey{itree}$) that is the backward partial function composition $\circ$ of $F$ and a partial function made using $mk\_functional$ from the inverse $\inv$ of the relation $(\ZKey{$\dom$}(F) \dres \rho)$ which is the domain restriction $\dres$ of $\rho$ to the domain $\ZKey{$\dom$}(F)$ of $F$. 
%We note that the function made by $mk\_functional$ is a relation (a set of pairs), not a partial function. 
%Since we use sets to represent partial functions for presentation, another function to turn this relation into a partial function is omitted here. 
%We also note that $R^{-1}$ is the inverse of a general relation, and the corresponding one in Z is $\inv$ ($R^{-1}$ in Z is the inverse of a homogeneous relation from a set $X$ to itself: $X \rel X$). 
The multiple events of $E_1$ that are mapped to the same event of $E_2$ in $\rho$ and also are the initial events of $P$, or in $\ZKey{$\dom$}(F)$, are removed in $G$. %This prevents nondeterminism.
The renaming result is a partial function in which each event $e_2$ in the domain of $G$ is mapped to a renamed process by a corecursive call $\rename{P'}{\rho}$ where $\left(e_2 \mapsto P'\right) \in G$. 

{
 The potential nondeterminism is excluded because many-to-one mappings in $\rho$ are removed by $mk\_functional$ in $G$. For example, 
 \begin{align*}
 &\rename{\left(
% \begin{array}{l}
 e_1 \then P \extchoice 
 e_2 \then Q \extchoice 
 e_3 \then R
% \end{array}
 \right)}{
 \{
% \begin{array}{l}
 e_1 \mapsto e, 
 e_2 \mapsto e, 
 e_3 \mapsto ea,
 e_4 \mapsto eb
% \end{array}
 \}} \\
 =& \left(ea \then \rename{R}{\{
% \begin{array}{l}
 e_1 \mapsto e, 
 e_2 \mapsto e, 
 e_3 \mapsto ea,
 e_4 \mapsto eb
% \end{array}
 \}}\right) \tag*{(renaming example 1)} \label{eqn:renaming_example}
 \end{align*}
 Here, the only available initial event after renaming is $ea$ because the relation $(\ZKey{$\dom$}(F) \dres \rho)^{\inv}$ is equal to $\{e \mapsto e_1, e \mapsto e_2, ea \mapsto e_3\}$ and $mk\_functional$ removes the first two pairs (because of duplicate distinct values), and so results in $\{ea \mapsto e_3\}$.

\begin{rmk}
Roscoe~\cite{Roscoe2011} defines three ways for renaming in CSP. Injective functional renaming will not change the behaviour of a CSP process and is an alternative to parametrised CSP processes on channels. Non-injective functional renaming may change the behaviour of a process by ignoring some level of detail or introducing nondeterminism. Relational renaming, a more general and powerful operator than the other two functional renamings, allows many-to-one (may introduce nondeterminism) or one-to-many (to offer more choice) mappings. What machine-readable CSP (CSP-M) supports and FDR implements is relational renaming. We investigated all these approaches and chose to implement the relational renaming with many-to-one and one-to-many mappings. This is mainly because RoboChart's semantics is defined using CSP-M and verified using FDR. For many-to-one mappings, our definition here, however, blocks these many events, and the definition of renaming with priority in Sect.~\ref{ssec:itree_renaming_with_priority}, as follows, chooses one of these many events according to their priority.
\end{rmk}

\subsection{Hiding with priority}
\label{ssec:itree_hiding_with_priority}
The current semantics~\cite{Foster2021} of hiding $P \hide A$ is deadlock if more than one initial event of $P$ is in $A$. This is to avoid nondeterminism caused by the hiding of two possible events. This restriction can be relaxed by hiding events in an order. For example, $\left(a \then P \extchoice b \then Q\right) \hide \{a, b\} = stop$, but $\left(\left(a \then P \extchoice b \then Q\right) \hide \{a\} \right) \hide \{b\} = \tau \left(\left(P\hide \{a\}\right) \hide \{b\}\right)$, and $\left(\left(a \then P \extchoice b \then Q\right) \hide \{b\} \right) \hide \{a\} = \tau \left(\left(Q\hide \{b\}\right) \hide \{a\}\right)$. Hiding events in a different order resolves the external choice differently without deadlock. This difference is due to the maximal progress assumption of hiding: $\left(a \then P \extchoice b \then Q\right) \hide \{a\}$ is equal to $\tau \left(P\hide \{a\}\right)$.

We define hiding with priority, $P \hidep el$ (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L17}), to put these events to be hidden in an order based on their order in a list $el$.
%
\begin{align*}
    & P \hidep el = foldl\left(\left(\lambda Q~e.~Q \hide \{e\}\right), P, el\right) &
\end{align*}
The $foldl$ builds a return value by applying the function $\left(\lambda Q~e.~Q \hide \{e\}\right)$ (say $f$) to the combined result (initially $P$) and elements in $el$ based on their orders. For example, $foldl\left(f, P, [a,b]\right)$ will be expanded to $f(f(P, a), b)$, which is just $\left(P \hide \{a\}\right) \hide \{b\}$.
%
The above examples now can be expressed as $\left(a \then P \extchoice b \then Q\right) \hidep [a,b]$ and $\left(a \then P \extchoice b \then Q\right) \hidep [b,a]$.

\subsection{Renaming with priority}
\label{ssec:itree_renaming_with_priority}
Because the relation $\rho$ of type $E_1 \rel E_2$ in the renaming definition~\ref{def:rename} is possibly heterogeneous (so $E_1$ and $E_2$ are different types), renaming cannot be like hiding with priority to place the events to be renamed in an order to rename events one by one. This is because renaming a process changes its event type from $E_1$ to $E_2$, so we can no longer rename other events of type $E_1$. For this reason, we define renaming with priority, $\renamep{P}{\varrho}$, which renames events of $P$ according to a finite sequence $\varrho$ of type $\seq\left(E_1 \cross E_2\right)$. We use the finite sequence type here to describe the mathematical definition of this operator, and its representation in Isabelle is \changed[\C{47}]{a list}. \changed[\C{48}]{A finite sequence of type, $\seq X$, is a finite partial function $\nat \ffun X$ from natural numbers $\nat$ to $X$.} With $\varrho$, a priority is given based on the indices of pairs in the sequence to resolve potential nondeterminism in a particular way. For pairs with the same second element (in other words, many-to-one mappings), the pair with the smallest index has the highest priority. This renaming with a priority operator will only rename the event with the highest priority and block other events with lower priority. 
%The pair with a small index number in $\varrho$, has a higher priority. If two or more events are renamed to the same event, the event in the mapping pair with the highest priority will be retained, and others will be blocked.

Before defining $\renamep{P}{\varrho}$, we need to define another two functions. 
%one is the domain restriction $\dresl$ of $\varrho$ to a set $A$ and another is similar to the range anti-restriction $\nrres$ of $\varrho$ to $A$, but 
The first function is the domain restriction $\dresl$ of $\varrho$ to a set $A$. %As for the domain restriction $\dres$ for relations, $\dresl$ for an associative list $\varrho$ %of type \texttt{(\textquotesingle{a} \(\times\) \textquotesingle{b}) list} 
%based on a set $A$
%of type.
\begin{align*}
    % A \dresl \varrho = [p.~ p \leftarrow \varrho, fst~p \in A] \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/1a01b17004b7115eaca8b504ee96df46c7186478/RoboChart/ITree_RoboChart.thy\#L28}}
    A \dresl \varrho = squash~\left\{s : \seq\left(E_1 \cross E_2\right) | s \in \varrho \bullet (s.2).1 \in A\right\} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L31}}
\end{align*}
This function produces a new sequence, compacted from a function, or a set of ordered pairs, in which each member $s$ is in $\varrho$ and the first element $(s.2).1$ (of type $E_1$) of the second element $s.2$ (of type $E_1 \cross E_2$) of $s$ is in $A$, by the $squash$ function~\cite{Spivey1992}. \changed[\C{48}]{Here, we use the selection operator ($s.i$) to select the \emph{i}th element in a tuple $s$.} When a type is obvious, we use a short form $x \in A \bullet P(x)$ for $x : T | x \in A \bullet P(x)$. This could be used in set comprehension, quantification, etc.
%
%\newcommand{\dreslloc}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/1a01b17004b7115eaca8b504ee96df46c7186478/RoboChart/ITree_RoboChart.thy\#L28}}
%\begin{alltt}
%    \isakwmaj{definition} \(\dresl\) :: "\textquotesingle{a} set \(\implies\) (\textquotesingle{a} \(\times\) \textquotesingle{b}) list \(\implies\) (\textquotesingle{a} \(\times\) \textquotesingle{b}) list" 
%    \(\\\qquad\) \isakwmin{where} A \(\dresl\) \(\varrho\) = [p. p \(\leftarrow\) \(\varrho\), fst p \(\in\)A] \(\dreslloc\)
%\end{alltt}
%This produces a new associative list using list comprehension in Isabelle/HOL by preserving the pair $p$ in $\varrho$ whose first element is $A$. 

We give an example below to illustrate how $\dresl$ works.
%
\begin{align*}
    \{e_1, e_2, e_4\} \dresl \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle = \langle (e_1 , e), (e_2 , e), (e_4 , eb) \rangle
\end{align*}
%
For the second function $drop\_dup(\varrho)$, we need to drop the pairs with lower priority (and bigger indices). We define an auxiliary $least$ function first. 
\begin{align*}
    & least(\varrho, p) \defs \left(\nexists q \in \varrho \bullet q.1 < p.1 \land (q.2).2 = (p.2).2\right) \tag*{($least$ definition)} \label{def:drop_least}
\end{align*}
This function characterises if $p$ (of type $\nat \cross (E_1 \cross E_2)$) has the least index number $p.1$ in the members $q$ of $\varrho$ that have the same target event $(q.2).2$ (of type $E_2$) as that $(p.2).2$ of $p$. In other words, $p$ has the least index number in a set of renaming pairs with multiple events renamed to the same event as in $p$. Now $drop\_dup(\varrho)$ is defined below.
% keeps only the pair $(x, y)$ with the smallest index number for each element $y$ in the image of $\varrho$ based on the order of these pairs $(_, y)$.
%The second function $drop\_dup(\varrho, A)$ aims to drop the pairs in $\varrho$ whose second element is in set $A$. This function is defined recursively.
%
% \begin{align*}
%     & drop\_dup ([~], A) = [~] \\ 
%     &drop\_dup(x\#xs, A) = \left(\IF\ snd~x \in A \THEN drop\_dup(xs, A)\ \ELSE\ x \# drop\_dup \left(xs, A \cup \{snd~x\}\right)\right)
% \end{align*}
\begin{align*}
    %& \left(
    %\begin{array}[]{l}
        %\varrho \nrres \subseteq \varrho \\
        %\forall p : \seq~(X \times Y) \bullet p \in \varrho \nrres \implies \lnot \exists q : \seq (X \times Y) | q \in \varrho \bullet q.1 < p.1 \land (q.2).2 = (p.2).2 \\ 
    & \left(\forall p \in drop\_dup(\varrho) \bullet least(\rho, p)\right) \land \tag*{(maximal)} \label{def:drop_maximal}\\ 
    & \left(\forall p \in \varrho \bullet least(\varrho, p) \implies p \in drop\_dup(\varrho)\right) \tag*{(minimal)} \label{def:drop_minimal}
    %\end{array}
    %\right) \\
    % &drop\_dup(x\#xs, A) = \left(\IF\ snd~x \in A \THEN drop\_dup(xs, A)\ \ELSE\ x \# drop\_dup \left(xs, A \cup \{snd~x\}\right)\right)
\end{align*}
The first predicate \ref{def:drop_maximal} in the conjunction states that every element in the resultant $drop\_dup(\varrho)$ is $least$ in $\varrho$, and the second predicate \ref{def:drop_minimal} states that every least element in $\varrho$ must be in the resultant $drop\_dup(\varrho)$. 
% If $\varrho$ is an empty list $[~]$, the result is also an empty list. Otherwise, $\varrho$ is a concatenation of a pair $x$ and a list $xs$. If the second element $(snd~x)$ of $x$ is in $A$, then $x$ is dropped. Otherwise, $x$ is preserved, but $drop\_dup$ now is applied to $xs$ with an update set $A \cup \{snd~x\}$ (so the subsequent pair, whose second element is $snd~x$, becomes duplicate and is finally dropped). 
For example, 
%
\begin{align*}
    drop\_dup\left( \langle (e_1 , e), (e_2 , e), (e_4 , eb) \rangle \right) = \langle (e_1 , e), (e_4 , eb) \rangle
\end{align*}
Here, the pair $(e_2, e)$ is dropped because it does not have the highest priority in terms of the target event $e$ (because $e$ appears early in $(e_1, e)$). We can define $\renamep{P}{\varrho}$ corecursively with the two functions above.
%

\begin{definition}[Renaming with priority]\label{def:rename_priority}
%$\rename{P}{\rho}::(E_1, R) \cspkey{itree} \Rightarrow (E_1 \rel E_2) \Rightarrow (E_2, R) \cspkey{itree}$ 
% is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L56}
\begin{align*}
\begin{array}{l}
\renamep{\left(\Ret~x\right)}{\varrho} = \Ret~x \\[1pt] 
\renamep{\left(\Sil~P'\right)}{\varrho} = \Sil~\left( \renamep{P'}{\varrho} \right) \\[1pt]
\renamep{\left(\Vis~F\right)}{\varrho}
 = \left(
\begin{array}{l}
\LET 
G = F \circ mk\_functional\left( \left(\ZKey{$\ran$}\left(drop\_dup\left(\ZKey{$\dom$}(F) \dresl \varrho\right)\right)\right)^{\inv}\right) \\
@ \Vis \left(
\begin{array}{l}
\left\{ e_2 \mapsto \left(\renamep{P'}{\varrho}\right) | \left(e_2 \mapsto P' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\right)
\end{array}
\end{align*}
\end{definition}

This definition is similar to Definition~\ref{def:rename} except that $\varrho$ here is a sequence of renaming pairs, and the relation in the inverse now has all its domain elements mapped to distinct values by $drop\_dup$. Because $drop\_dup$ defines a sequence of type $\nat \ffun (E_1 \cross E_2)$, we get the range of the sequence by the $\ZKey{$\ran$}$ function, which is a relation. 

The difference between renaming and renaming with priority is exemplified below. 
 \begin{align*}
 &\renamep{\left(
% \begin{array}{l}
 e_1 \then P \extchoice 
 e_2 \then Q \extchoice 
 e_3 \then R
% \end{array}
 \right)}{
     \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle
 } \\
 = &\left(
 \begin{array}[]{l}
 e \then \renamep{P}{ \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle }  \extchoice  \\
 ea \then \renamep{R}{ \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle }
 \end{array}
\right) \tag*{(renaming example 2)} \label{eqn:renaming_priority_example}
 \end{align*}

Compared to \changed[\C{49}]{the \ref{eqn:renaming_example} where renaming excludes nondeterminism}, the potential nondeterminism introduced by renaming both $e_1$ and $e_2$ to $e$ is resolved by giving priority to the renaming map $(e_1, e)$. If $(e_1 , e)$ and $(e_2 , e)$ are swapped, then the renaming will give priority to $e_2$ and its continuation is $Q$ (instead of $P$).

}

% {
% \begin{rmk}
%     New syntax for renaming: $\isasymlbrace \varg \mapsto \varg | \varg \in \varg. \varg\isasymrbrace$ and the definition of \isacode{rncollect} 
%    We also explored several implementations of the renaming operator and why we chose this one. Give some insights and discuss the renaming operator in CSP-M and FDR. And also the pros and cons of our approach.
%    \begin{itemize}
%        \item Channel or event parametrisation like $COPY(left, right)$ where $left$ and $right$ are parametrised channel names,
%        \item Renaming with a relational map using partial injection,
%        \item Renaming with a relational map using partial functions.
%    \end{itemize}
% \end{rmk}
% }

\section{RoboChart semantics in interaction trees}
\label{sec:rc_to_itrees}

%We base our implementation of the RoboChart semantics in ITrees on the CSP semantics generated by RoboTool. So, we also consider the practical details of the semantics generation in RoboTool. %For example, a CSP file \cspcode{instantiation.csp} is used to record the parameters to the generation and the customisation by users for the constants and definitions in models. 
In this section, we describe how we give semantics to RoboChart regarding ITrees in Isabelle/HOL. These include types, instantiations, functions, state machines, controllers, and modules. In implementing RoboChart's semantics, we also consider the practical details of the CSP semantics generation in RoboTool, such as naming and bounded primitive types. 

In particular, the nondeterministic choice between transitions, for example, in Fig.~\ref{fig:robochart_patrol}, is resolved using the prioritised renaming operator defined earlier through ordered transition event mappings. This is not covered in the previous work~\cite{Ye2022} and is the new contribution of this paper.
% Use of bounded types is necessary for model checking with FDR and animation of this work to achieve consistency between the semantics in RoboTool and that in Isabelle/HOL. This consistency enables both tools to work in a complementary way. For example, the animation is used for debugging and then FDR for verification during model development and analysis.

{
\subsection{Overview of RoboChart semantics}
\label{ssec:semantics_overview}

The RoboChart CSP semantics is sketched in Fig.~\ref{fig:robochart_semantics}. The semantics for modules, controllers, state machines, and (either composite or basic) states are CSP processes. However, the semantics for a robotic platform is different from controllers and state machines in that it does not have a particular behaviour. So, its semantics is not a CSP process because the platform is an abstraction of a physical robot through variables, events, and operations.
\begin{figure}[t]
  \centering%
  \includegraphics[width=1.00\textwidth]{RoboChart_semantics.pdf}%
  %\vspace{-3ex}
  \caption{From~\cite[Fig.~11]{Miyazawa2019}. Structure of the RoboChart semantics: stacked components and parallel lines indicate parallel composition; bordered boxes indicate points of interaction; the semantics of a container is composed of the semantics of its contained components.}%
  %\vspace{-4ex}
  \label{fig:robochart_semantics}%
\end{figure}

RoboChart has a hierarchical memory model with memory for the robotic platform at the top, memories for controllers in the middle, and memories for state machines inside their container controllers. A memory process in scope records the reads and writes of variables for components (the platform, controllers, and state machines). The memory for a state machine caches the (both local and shared) variables it requires. So, the semantics of the machine is independent of the location where these variables are declared. However, the memory for a controller or the platform differs from that of a state machine in that it not only accepts updates to the variables in the memory but also propagates the updates down the hierarchy to the memories of state machines that require the updated variables.

The RoboChart semantics of the autonomous chemical detector model in Sect.~\ref{ssec:robochart_chemical} is shown in Fig.~\ref{fig:robochart_acd_semantics}. The module's semantics is a parallel composition of the two controllers with the robotic platform memory (RP memory) and a buffer process (Buffer). 
The buffer process models the asynchronous connection from \rcitem{MainController} to \rcitem{MicroController} on event \rcitem{turn} in Fig.~\ref{fig:robochart_acd_module}. For simplicity, this semantics for asynchronous connections is omitted in Fig.~\ref{fig:robochart_semantics}.

\begin{figure}[t]
  \centering%
  \includegraphics[width=1.00\textwidth]{Autonomous_RoboChart_semantics.pdf}%
  %\vspace{-3ex}
  \caption{RoboChart semantics of the autonomous chemical detector.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_semantics}%
\end{figure}

The platform and controller memories for this chemical detector model are simply the CSP process \cspkey{skip} because the platform and the controllers do not provide any variables for sharing. The platform memory and the controller memory for the one-dimensional patrol robot in Sect.~\ref{ssec:robochart_patrol}, nevertheless, record the access and update of the shared variable $x$ and propagate its update to the controller, and finally to the state machines in the controller.

The semantics of \rcitem{MainController} (or \rcitem{MicroController}) is the composition of the CSP process for the semantics of its contained state machine \rcitem{GasAnalysis} (or \rcitem{Movement}) with the controller memory. We note the CSP processes for the controllers are renamed, such as {Renamed MainController}. This is because RoboChart uses directed connections for communication, but CSP's parallel composition requires composites to have the same channel names for communication. We, therefore, need to rename the exported channels of the controller CSP processes to ensure the channel names for the two controllers in a connection are the same so they can communicate with each other.

Similarly, the CSP processes for the semantics of the state machines (\rcitem{GasAnalysis} and \rcitem{Movement}) are also renamed for the same reason to ensure the state machines in a controller can communicate on directed connections. The renaming is not compulsory for the chemical detector model because each controller contains only one state machine. Still, it is mandatory for the patrol robot because the controller includes two state machines connected on event \rcitem{update}. So, in general, we always rename them.

The semantics of the state machine \rcitem{GasAnalysis} is a parallel composition of the node (including the junction \rcitem{i0} and the states \rcitem{NoGas}, etc.) processes with the machine memory recording the access and update of the local variables of the machine. The semantics of the machine \rcitem{Movement} has a similar structure. The memories of the state machines \rcitem{CalSTM} and \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol}, nonetheless, record not only their local variables \rcitem{l} but also the shared variable \rcitem{x}.
}

{
\paragraph{Practical consideration}
In this paper, our ITree-based semantics for RoboChart aims for consistency with the restricted CSP semantics generated in RoboTool.
Here, the restriction mainly refers to bounded types for basic RoboChart types and corresponding closed arithmetic operators. In the future, we could use unbounded basic types with usual operators, then enforce enumerations just in the animator, not in the semantics like this work.
% Another restriction is the finite type of channels due to the command chantype,
One advantage of using this restricted semantics is the possibility of reusing the current CSP semantics generator in RoboTool to generate corresponding ITrees-based theories for Isabelle to generate Haskell code automatically.

RoboTool automatically generates multiple versions of CSP semantics for a RoboChart model, including a standard version (\textbf{S}), an optimised version (\textbf{D}) that reduces internal interaction to some extent, an optimised and visible version (\textbf{VS}) that further exposes internal interaction, and an optimised and compressed version (\textbf{O}) with compressions using strong bisimulation and diamond elimination~\cite{Roscoe2011}. All these versions use some compressions. Our ITree-based semantics for RoboChart in this paper is based on the \textbf{D} version because RoboTool uses this version for verification. Our semantics here does not support compressions in the \textbf{D} version. Instead, we implement a form of compression for internal events in the animator.  

}

\subsection{Types}
%\paragraph*{{Types.}}
\label{ssec:semantics_type}
RoboChart has its type system based on the Z notation~\cite{Toyn2002}. It supports basic types: \rcitem{PrimitiveType}, \rcitem{Enumeration}, records (or schema types), and other additional types from the mathematical toolkits of Z.%: \rcitem{SetType}, \rcitem{SeqType}, \rcitem{ProductType}, function and relation types. 

The \rcitem{core} package of RoboTool provides five primitive types: \changed[\C{50}]{booleans, natural numbers, integer, real numbers, and strings}. 
%Their corresponding types in Isabelle are shown in Table~\ref{table:types}. 
We map integers, naturals, and strings onto the corresponding types in Isabelle/HOL, but with support for code generation to target language types. This improves the efficiency of evaluation and, thus, animation. We define the mappings below where we use the notation $\semL{\rcitem{rc}}{c}=\isacode{ic}$ to denote a mapping from a RoboChart entity \rcitem{rc} into an ITree-based CSP counterpart \isacode{ic} in the context $c$. In other words, the semantics of \rcitem{rc} in the context $c$ is $\isacode{ic}$ in our ITree-based CSP.
%For integers and naturals, we use numeric types \IsaKey{integer} and  \IsaKey{natural} in Isabelle, which are isomorphic to \IsaKey{nat} and \IsaKey{int} but mapped to build-in integers of target languages for code generation. For a similar reason, we use \IsaKey{String.literal} for strings of RoboChart. 
%% Because CSP (specifically CSP-M) does not have a type for real numbers, we also use \IsaKey{integer} for real numbers of RoboChart, the same as the CSP semantics generated in RoboTool. Still, we could equally use Isabelle's real type.
%% We note the use of \IsaKey{integer} for real numbers here is to make our animation consistent with the generated CSP semantics, and it is possible to use \IsaKey{real} in Isabelle for real numbers for verification (instead of code generation here). 
%
\begin{align*}
%\begin{array}{@{}l}
    & \meta{\semL{\rcitem{bool}}{t}} = \isacode{bool} \quad
    \meta{\semL{\rcitem{nat}}{t}} = \isacode{natural} \quad 
     %\semL{\rcitem{string}}{t} = \IsaKey{String.literal} &
    \meta{\semL{\rcitem{int}}{t}} = \isacode{integer} 
     %\semL{\rcitem{real}}{t} = \IsaKey{integer} & 
%    & \semL{\meta{\rcitem{datatype T}}}{t} = \quad
%    \isacode{record }\meta{T}\isacode{ = } \meta{\left\{f : T.fields @ f.name \right.} \isacode{::''}\meta{\semL{f.type}{t}}\isacode{''}\meta{\left.\right\}} \\
%    & \semL{\meta{\rcitem{enumeration T}}}{t} = \quad
%    \isacode{datatype }\meta{T}\isacode{ = } 
%        \meta{\left\{l : T.literals @ l.name \right.} \isacode{|}\meta{\left.\right\}} \\ 
%    & \semL{\meta{\rcitem{type T}}}{t} = \metanobar{\left\{
%        \begin{array}{@{}l}
%            \isacodebl{typedef }\meta{T}\isacodebl{T = ''\{()\}'' by auto}\\
%            \isacodebl{type\_synonym (\textquotesingle{a})} \meta{T} \isacodebl{ = ''(}\meta{T}\isacodebl{T, \textquotesingle{a}) PrimType''}
%        \end{array}
%        \right.}
%\end{array}
\end{align*}
Here, the context $t$ means the type. 

For a record type \rcitem{T} (\rcitem{datatype T}) such as \rcitem{GasSensor} in Fig.~\ref{fig:robochart_acd_chemical} in RoboChart, we use \isakwmaj{record} in Isabelle. Its semantics is defined in the rule below.
\begin{align*}
    & \meta{\semL{\rcitem{datatype T}}{t}} = \quad
    \isacode{record }\meta{T}\isacode{ = } \meta{\left\{f : T.fields @ f.name \right.} \isacode{::''}\meta{\semL{f.type}{t}}\isacode{''}\meta{, \left.\right\}} 
\end{align*}
We also use the notation $\meta{a}$ to denote elements to be expanded, where we use the constructs from Z as a meta-notation and use $\isacode{a}$ to denote the resultant construct in our ITree-based CSP in Isabelle. % Because CSP-M does not have a type for real numbers, we use \IsaKey{integer} for real numbers \rcitem{real} in RoboChart, which is the same as the CSP denotational semantics generated in RoboTool. Still, we could equally use Isabelle's real type. 
The rule results in the definition of a record type $\meta{T}$ in Isabelle, which contains a set of fields corresponding to the fields ($\meta{T.fields}$) in \rcitem{T}. Here we use set comprehension $\meta{\left\{x : T_x @ expr(x)\right\}}$ from Z. For the sake of presentation, we introduce a comma $\meta{,}$ after the expression $\meta{expr(x)}$ to represent a character to separate each expression after the set is converted to concrete syntax in Isabelle. In the rule above, the character is empty, so there is a blank space to separate each expression. In the above rule, for each field $\meta{f}$, we use its name $\meta{f.name}$. The semantics of its type ($\meta{\semL{f.type}{t}}$) to construct each field in Isabelle by using Isabelle's syntax (\isacode{name::''type''}).

For an enumeration type such as \rcitem{Angle} and \rcitem{Status} in Fig.~\ref{fig:robochart_acd_chemical}, we use \isakwmaj{datatype} in Isabelle to define it.
\begin{align*}
    & \meta{\semL{\rcitem{enumeration T}}{t}} = \quad
    \isacode{datatype }\meta{T}\isacode{ = } 
        \meta{\left\{l : T.literals @ l.name, \right.} \isacode{|}\meta{\left.\right\}} 
\end{align*}
Similar to the rule for the record type, we use set comprehension to get a set of constructors: one for each literal $\meta{l}$ in the enumeration type \rcitem{T}. In Isabelle, only the name $\meta{l.name}$ of the literal matters and constructors are separated by \isacode{|}.

RoboChart models can also have abstract primitive types (\rcitem{type T}) with no explicit constructors, such as \rcitem{Chem} and \rcitem{Intensity} in the chemical detector model presented in Sect.~\ref{sec:robochart}. 
We map primitive types to finite enumerations for code generation. 
We define a finite type \isacode{PrimType} parametrised over two types: 
\isacode{\textquotesingle{t}} for specialisation and a numeral type \isacode{\textquotesingle{a}} for the number of elements.
% 
\newcommand{\PrimType}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L74}}
\begin{alltt}
\isakwmaj{datatype} (\textquotesingle{t}, \textquotesingle{a}::finite) PrimType = PrimTypeC \textquotesingle{a} \(\PrimType\)
\end{alltt}

We show the rule to generate \changed[\C{52}]{the semantics for primitive types} below.
\begin{align*}
  & \meta{\semL{\rcitem{type T}}{t}} = \metanobar{\left\{
      \begin{array}{@{}l}
          \isacodebl{typedef }\meta{T}\isacodebl{T = ''\{()\}'' by auto}\\
          \isacodebl{type\_synonym (\textquotesingle{a})} \meta{ T} \isacodebl{ = ''(}\meta{T}\isacodebl{T, \textquotesingle{a}) PrimType''}
      \end{array}
      \right.}
\end{align*}
This rule results in two statements in Isabelle: first to declare a new type $\meta{T}\isacode{T}$ using \isakwmaj{typedef}, and then the corresponding type $\meta{T}$ is just a synonym for \isacode{PrimType} instantiated to $\meta{T}\isacode{T}$. \changed[\C{52}]{We note that $\meta{T}\isacode{T}$ can be any type, and here we choose the type \isacode{\{()\}} containing only the unit \isacode{()}}. 

RoboChart additionally supports a large collection of data types from Z. We show the rules for set, product, and sequence types below and refer to the counterparts in the Z toolkit for other types.
\begin{align*}
    & \meta{\semL{\rcitem{Set(T)}}{t}} = \meta{\semL{T}{t}} \isacode{ set} \qquad 
    \meta{\semL{{T_1 * T_2}}{t}} = \meta{\semL{T_1}{t}} \isacode{ $\cross$ } \meta{\semL{T_2}{t}}\qquad
    \meta{\semL{\rcitem{Seq(T)}}{t}} = \meta{\semL{T}{t}} \isacode{ blist[\textquotesingle{n}]}
\end{align*}
The rules for set and product types are straightforward. \rcitem{Seq(T)} in RoboChart is a type representing an infinite set of all finite (any length) sequences of elements of type $T$. We need to bind the size of the set and also the length of sequences for code generation. 
%\changed[\C{17}]{\paragraph{Bounded sequences} \rcitem{Seq(T)} in RoboChart is a type representing an infinite set of all finite (any length) sequences of elements of type $T$. We need to bind the size of the set and also the length of sequences for code generation. } 
% We also bound the length of each sequence in this type for finite sequences such as \rcitem{Seq(GasSensor)}. 
For this reason, we define bounded lists or sequences \isacode{(\textquotesingle{a}, \textquotesingle{n}::finite) blist} 
%(\isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/90eefcdbc0dfd93cb1db6342a916add57a174381/Bounded_List.thy\#L10}) 
 over two parametrised types: \isacode{\textquotesingle{a}} for the type of elements and a finite type \isacode{\textquotesingle{n}} for the maximum length of each list. We introduce a notation \isacode{\textquotesingle{a} blist[\textquotesingle{n}]} for this type. So the rule above for \rcitem{Seq(T)} results in a type with bounded sequences. We describe the definition of bounded sequences in Isabelle below.

\newcommand{\blist}{\isalink{https://github.com/isabelle-utp/Z_Toolkit/blob/90eefcdbc0dfd93cb1db6342a916add57a174381/Bounded_List.thy\#L10}}
\begin{alltt}
\isakwmaj{typedef} (\textquotesingle{a},\textquotesingle{n}::finite) blist = \{xs::\textquotesingle{a} list. length xs \(\leq\) CARD(\textquotesingle{n})\} \(\blist\)
\end{alltt}
%
\noindent 
\isacode{CARD} here retrieves the cardinality of \isacode{\textquotesingle{n}}. If \isacode{\textquotesingle{a}} is a finite type, then \isacode{\textquotesingle{a} blist[\textquotesingle{n}]} also defines a finite type. We define several functions: 
\begin{inparaenum}[(a)]
\item \isacode{blength} to get the length of a bounded sequence; 
\item \isacode{bnth} to get the nth element of a bounded sequence; 
\item \isacode{bappend} ($\text{@}_s$) to concatenate two bounded sequence; and 
\item \isacode{bmake} to construct a bounded sequence from a finite list. 
\end{inparaenum} 
\changed[\C{16}]{These functions are lifted from the corresponding functions for lists in Isabelle. Additionally, we instantiate the type to be comparable and enumerable, and so the equality of two bounded lists of the same type \isacode{\textquotesingle{a} blist[\textquotesingle{n}]} can be established, and all elements in such a bounded type can be enumerated. Equality and enumerability are essential for code generation in Isabelle.}

\begin{example}[types in the autonomous chemical detector]
    Using the rule $\semL{\varg}{t}$, we get \changed[\C{11}]{the corresponding definitions} in Isabelle for the RoboChart types in Fig.~\ref{fig:robochart_acd_chemical}. 
\newcommand{\ChemicalChem}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L121}}
\newcommand{\ChemicalStatus}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L190}}
\newcommand{\ChemicalGasSensor}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L266}}
%
\begin{alltt}
\isakwmaj{typedef} ChemT = "{()}"  \(\ChemicalChem\)
\isakwmaj{type_synonym} (\textquotesingle{a}) Chem = "(ChemT, \textquotesingle{a}) PrimType"
\isakwmaj{abbreviation} ChemC::"('a::finite \(\Rightarrow\) \textquotesingle{a} Chem)" \isakwmin{where} "ChemC \(\equiv\) PrimTypeC"
\isakwmaj{datatype} Status = Status_noGas | Status_gasD \(\ChemicalStatus\)
\isakwmaj{record} \textquotesingle{a} GasSensor = gs\_c :: "\textquotesingle{a} Chem"   gs\_i :: "\textquotesingle{a} Intensity" \(\ChemicalGasSensor\)
\end{alltt}

An example of a finite type \isacode{\textquotesingle{a}} is the numeral type in Isabelle, such as type \isacode{2}, which contains two elements: zero (\texttt{0::2}) and one (\texttt{1::2}). To construct an element of type \rcitem{Chem}, we define a dedicated constructor \isacode{ChemC}, which is simply a type cast of \isacode{PrimTypeC}. Finally, we use \isacode{(ChemC 0::2)} and \isacode{(ChemC 1::2)} to construct such two elements of type \isacode{(2 Chem)}.

An instantiation type \isacode{(2 GasSensor)} is a record containing two fields of finite types \isacode{(2 Chem)} and \isacode{(2 Intensity)}, both of which have two elements. We now can \changed[\C{53}]{use record brackets \isacode{\(\lparr\)\(\ldots\)\(\rparr\)} in Isabelle to} construct an element \isacode{\(\lparr\)gs\_c = Chem (1::2), gs\_i = IntensityC (0::2)\(\rparr\)} of this type: the chemical is 1, and the intensity is 0.  \qed

For the type \rcitem{Seq(GasSensor)} in RoboChart, its bounded type in Isabelle is \isacode{(2 GasSensor) blist[2]}, which denotes the length of sequences bounded to 2 and elements (in the sequences) of type \isacode{(2 GasSensor)}.
We now can use \isacode{bmake TYPE(2) [\(\lparr\)gs\_c = Chem (0::2), gs\_i = IntensityC (0::2)\(\rparr\), \(\lparr\)gs\_c = Chem (1::2), gs\_i = IntensityC (1::2)\(\rparr\)]} to construct a sequence containing two sensor readings. \qed

%In the CSP semantics of models in RoboTool, their implementations are supplied by users. For example, the verification of the model has both types instantiated to a set \cspcode{\{0,1\}}.
% with two elements: \cspcode{0} and \cspcode{1} 
%
%We note that \isacode{\textquotesingle{t}} does not appear on the right side of the definition because it is introduced only to distinguish between different primitive types. 
% For example, \rcitem{Chem} is implemented as a generic type \isacode{\textquotesingle{a} Chem = (ChemT, \textquotesingle{a}) PrimType} (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L122}) \changed[\C{52}]{where \isacode{ChemT} is a new type defined using \isakwmaj{typedef}. Such a type like \isacode{ChemT} can be any type. We choose the type \isacode{\{()\}} containing only the unit \isacode{()}.}
%\isacode{Chemical\_Chem} (a specialisation of \isacode{PrimType} by type \isacode{Chemical\_ChemT}) defined below.
%
%\newcommand{\ChemicalChem}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L121}}
%\begin{alltt}
%\isakwmaj{typedef} Chemical\_ChemT = "{()}"  \(\ChemicalChem\)
%\isakwmaj{type_synonym} ('a) Chemical\_Chem = "(Chemical\_ChemT, 'a) PrimType"
%\end{alltt}
%\isakwmaj{abbreviation} Chemical\_ChemC::"('a::finite \(\Rightarrow\) 'a Chemical\_Chem)"
%  \isakwmin{where} "Chemical\_ChemC \(\equiv\) PrimTypeC"
%
%The constructor for this new type is \isacode{Chemical\_ChemC} which is just  \isacode{PrimTypeC}, but with type constraint. 
%
% An example of a finite type \isacode{\textquotesingle{a}} is the numeral type in Isabelle, such as type \isacode{2} which contains two elements: zero (\texttt{0::2}) and one (\texttt{1::2}). To construct an element of type \rcitem{Chem}, we define a dedicated constructor \isacode{ChemC}, which is simply a type cast of \isacode{PrimTypeC}. Finally, we use \isacode{(ChemC 0::2)} and \isacode{(ChemC 1::2)} to construct such two elements of type \isacode{(2 Chem)}.
%, which contains two elements: \isacode{0::2} and \isacode{1::2}. %A type \isacode{(2 Chem)}, therefore, corresponds to the instantiation of \rcitem{Chem} in RoboTool.

%
%\begin{table}[h!]
%\centering
% \caption{RoboChart core primitive types to Isabelle types.}
% \begin{tabular}{||c |c || c| c || c | c||} 
% \hline
% \textbf{RoboChart} & \textbf{Isabelle} & \textbf{RoboChart} & \textbf{Isabelle} & \textbf{RoboChart} &  \textbf{Isabelle} \\ %[0.5ex] 
% \hline%\hline
% \rcitem{bool} & \IsaKey{bool} & \rcitem{nat}& \IsaKey{natural} & \rcitem{int} & \IsaKey{integer}  \\ %[1ex] 
% \hline
 % \rcitem{real} & \IsaKey{integer} & \rcitem{string}& \IsaKey{String.literal} & & \\ 
 %\hline
 %\rcitem{datatype} & \IsaKey{record} & records & \rcitem{set(T)}& \IsaKey{T~set} &  & \rcitem{Seq(T)} & \IsaKey{T~blist[n]} & bounded \\ 
 %\hline
% \rcitem{T1$\cross$T2} & \IsaKey{T1 $\cross$ T2} &  & \rcitem{}& \IsaKey{T~set} &  & \rcitem{Seq(T)} & \IsaKey{T~blist[n]} & bounded \\ 
% \hline
% \end{tabular}
%\label{table:types}
%\end{table}

% For enumerations and records, we use \isakwmaj{datatype} and \isakwmaj{record} in Isabelle. The \isacode{Status} and \isacode{GasSensor} below are such examples for the corresponding types in the \rcitem{Chemical} package shown in Fig.\ref{fig:robochart_acd_chemical}%. 
%
% \newcommand{\ChemicalStatus}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L190}}
% \newcommand{\ChemicalGasSensor}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L266}}
% %
% \begin{alltt}
% \isakwmaj{datatype} Status = Status_noGas | Status_gasD \(\ChemicalStatus\)
% \isakwmaj{record} \textquotesingle{a} GasSensor = gs\_c :: "\textquotesingle{a} Chem"   gs\_i :: "\textquotesingle{a} Intensity" \(\ChemicalGasSensor\)
% \end{alltt}
% An instantiation type \isacode{(2 GasSensor)} is a record containing two fields of finite types \isacode{(2 Chem)} and \isacode{(2 Intensity)}, both of which have two elements. We now can \changed[\C{54}]{use record brackets \isacode{\(\lparr\)\(\ldots\)\(\rparr\)} in Isabelle to} construct an element \isacode{\(\lparr\)gs\_c = Chem (1::2), gs\_i = IntensityC (0::2)\(\rparr\)} of this type: the chemical is q and the intensity is 0.  \qed
\end{example}

%\subsection{Constants}
\subsection{Instantiations}
%\paragraph*{{Instantiations.}}
\label{ssec:semantics_inst}
The \cspcode{instantiation.csp} file of the CSP semantics contains common definitions used by all models for verification using FDR. These include the definitions of bounded core types such as \rcitem{core\_int} %(named types in CSP)
 and arithmetic operators under which these bounded types are closed. %We show below one example for type \rcitem{core\_int} and three for the arithmetic operators, closed under a bounded type \cspcode{T}.
% \begin{alltt}
%   \cspkey{nametype} core_int = \{-2 .. 2\}
%   Plus(e1, e2, T) = if member(e1 + e2, T) then (e1 + e2) else e1
%   Minus(e1, e2, T) = if member(e1 - e2, T) then (e1 - e2) else e1
%   Neg(e, T) = if member(-e, T) then (-e) else e
% \end{alltt}
% In the definition of \cspcode{Plus}, if \cspcode{e1+e2} is within \cspcode{T} then this is the result, otherwise, it is \cspcode{e1}. Other definitions \cspcode{Minus} and \cspcode{Neg} are similar.
We use \isacode{\isakwmaj{locale}}~\cite{Ballarin2004} in Isabelle to define these for reuse in all models.
 Locales allow us to characterise abstract parameters (such as \isacode{min\_int} and \isacode{max\_int}, to define \changed[\C{54}]{the} bounded core type \rcitem{core\_int}) and assumptions in a local theory context.
%, sketched below. 
 %\vspace{-1em}
 %
 \newcommand{\RoboChartConf}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L115}}
 %\begin{figure}[h!]
 \begin{alltt}
\isakwmaj{locale} robochart_confs = 	\(\RoboChartConf\)
  \isakwmin{fixes} min_int::"integer" \isakwmin{and} max_int::"integer" \isakwmin{and} max_nat::"natural" \isakwmin{and} 
        min_real::"integer" \isakwmin{and} max_real::"integer"
\isakwmin{begin} ...  \isakwmin{end}
 \end{alltt}
%  \isakwmaj{abbreviation} "core_int_list \(\equiv\) [min_int .. max_int]"
%  \isakwmaj{abbreviation} "core_int_set \(\equiv\) set core_int_list"
%  \isakwmaj{definition} Plus \isakwmin{where} "Plus e1 e2 T = (if (e1+e2) \(\in\) T then (e1+e2) else e1)"
%  \isakwmaj{definition} Minus \isakwmin{where} "Minus e1 e2 T = (if (e1-e2) \(\in\) T then (e1-e2) else e1)"
%  \isakwmaj{definition} Neg \isakwmin{where} "Neg e T = (if -e \(\in\) T then -e else e)"
%
% \label{fig:locale}
% \caption{Instantiations as locale and its interpretation.}
 %\end{figure}
\vspace{-2ex}
Here, we omit the definitions for simplicity.
%We define bounded core types as sets by ranges given by a lower limit and an upper limit, such as parameters \isacode{min\_int} and \isacode{max\_int}. In code generation, we use lists to implement sets, so we first define a list of ranges in \isacode{core\_int\_list} and then convert it into a set \isacode{core\_int\_set}.
%
%We note a named type in CSP can be used as a type and a set expression, so a bounded core type is a type and an expression. Isabelle, however, has different concepts for types and expressions, and they cannot be used interchangeably. For this reason, we have core types in Sect.~\ref{ssec:semantics_type} and bounded sets for these types here. 
% The definition \isacode{Plus} illustrated above corresponds to that in the \cspcode{instantiation.csp} file and is an example of defining a closure operator. 
%% %
%
In the theory of Isabelle for a RoboChart model, we instantiate this locale using \isakwmaj{interpretation} (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L97}), which allows us to assign concrete values for the parameters. 

\begin{example}[instantiation]
    An example is shown below that instantiates the parameters (limits) of the locale to \changed[\C{24},\C{56}]{\texttt{-2, 2, ...}}  etc. 
\newcommand{\LocaleInter}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L97}}
 \begin{alltt} 
 \isakwmaj{interpretation} rc: robochart_confs "-2" "2" "2" "0" "1". \(\LocaleInter\)
 \end{alltt}
\vspace{-1em}
Then we can use \isacode{rc.core\_int\_set} and \isacode{rc.Plus} to access the instantiated definitions in the locale. \qed
\end{example}
 
\subsection{Functions}
%\paragraph*{{Functions.}}
\label{ssec:semantics_funcs}
Functions in RoboChart benefit from \changed[\C{56}]{the rich expressions and Z toolkit in Isabelle.} The expressions that are not supported in CSP-M, such as logical quantification, 
%, definite descriptions, and lambda expressions 
are naturally present in Isabelle. 
% To support code generation, these expressions must be implemented (code equations) for the types they operate on. 
 % For example, \isacode{list\_all} is an implementation of $\forall$ for lists. 
 Using the code generator, the preconditions and postconditions of a function definition can be solved effectively \changed[\C{30}]{(thanks to Isabelle's data refinement in the code generation)}, which is impossible in CSP-M and FDR. 
 %Functions, defined by preconditions and postconditions, therefore, can be specified in RoboChart models and implemented in ITrees. 
% This guarantees the semantics of functions is consistent in the models and their implementation. 
% Since CSP-M cannot support these expressions, for verification with FDR, users need to supply a customised implementation. The consistency between the specification of a function and its customisation may not be guaranteed. However, this consistency is important and valuable to detect errors in models.

 We define the semantics of a function definition \rcitem{f} (of type \rcitem{Function} --- a class in RoboChart's metamodel) in RoboChart below.
\begin{align*}
    & \meta{\semLC{f : Function}{F}} = \\
    & \,\metanobar{\left\{
      \begin{array}{@{}l}
          \isacodebl{\isakwmaj{definition} ''pre\_}\meta{f.name~\langle p: f.parameters @ p.name, \rangle} \isacodebl{ = } \meta{\left\{c: f.preconditions @ \semL{c}{e}, \right.}\isacodebl{$\land$}\meta{\left.\right\}} \isacodebl{''}\\
          \isacodebl{\isakwmaj{definition} ''}\meta{f.name~\langle p: f.parameters @ p.name, \rangle} \isacodebl{ = (THE result.} \meta{\left\{c: f.postconditions @ \semL{c}{e}, \right.}\isacodebl{$\land$}\meta{\left.\right\}} \isacodebl{)''}
      \end{array}
      \right.}
\end{align*}
Here, the context $\mathcal{F}$ means functions. One function $\meta{f}$ corresponds to two definitions in Isabelle: one for its preconditions and one for its postconditions. This is due to the semantics of such a function \rcitem{f} in RoboChart: a \changed[\C{51}]{Boolean} guard \cspcode{(pre(f)$\guard$~P)} where \cspcode{pre(f)} is the preconditions of \rcitem{f} and \rcitem{f} is called in process $P$, and so if the preconditions are not satisfied, the semantics deadlocks. The name of the first definition has the name $\meta{f.name}$ of $\meta{f}$ with a prefix \isacode{pre\_}. Then, in the definition, the name is followed by a sequence of parameter names, constructed from sequence comprehension $\meta{\langle p: f.parameters @ p.name, \rangle}$, which is similar to set comprehension except that the result is a sequence instead of a set. We use the sequence here because the order of parameters matters. The body of the definition is a set of the semantics for preconditions, given by $\meta{\semL{c}{e}}$ in the context of expressions $\meta{e}$, combined using a conjunction operator \isacode{$\land$}. The second definition for the postconditions is similar except that a definite description ({\isacode{THE result}, denoting the unique \isacode{result} such that the predicate holds}) is used to return the \isacode{result} of the function.

\begin{example}[functions defined in the autonomous chemical detector]
 As mentioned in Sect.~\ref{ssec:robochart_chemical}, three (\rcitem{goreq}, \rcitem{angle}, and \rcitem{analysis}) among the five functions defined in the Chemical package of the autonomous chemical detector model in Fig.~\ref{fig:robochart_acd_chemical} are unspecified, and two (\rcitem{analysis} and \rcitem{intensity}) among them are specified in the original model. 
 Our model in Fig.~\ref{fig:robochart_acd_chemical} specifies all five functions.
 With the capability of solving preconditions and postconditions of functions introduced in our work, we detect two problems in the definitions of the two specified functions in the original model, which are corrected in our model. Next, we present the semantics of the two functions (\rcitem{intensity} and \rcitem{location}) by $\meta{\semLC{\varg}{F}}$ in our implementation.

%An example function is \rcitem{intensity}, shown in Fig.~\ref{fig:robochart_acd_chemical_intensity}, defined in %the \rcitem{Chemical} package of 
 The \rcitem{intensity} function defined in Fig.~\ref{fig:robochart_acd_chemical} has a precondition (\includegraphics[align=c,height=8pt]{pre.pdf}) that the length (\rcitem{size}) of the parameter \rcitem{gs} is more significant than 0, and two postconditions (\includegraphics[align=c,height=8pt]{post.pdf}) involving universal and existential quantifications {where \rcitem{@} separates constraint and predicate parts, and \rcitem{goreq} is a $\geq$ relation on intensities.  The \rcitem{result} of the function is the largest intensity in \rcitem{gs}}.
For verification with FDR in RoboTool, an explicit implementation of this function must be supplied \changed[\C{30}]{through the \cspcode{instantiation.csp} file or the assertion language for RoboChart~\cite{RoboChartRef}}.
%
% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=.65\textwidth]{Chemical_intensity.pdf}%
%   \vspace{-3ex}
%   \caption{The specification of function  \rcitem{intensity}.}%
%   \vspace{-4ex}
%   \label{fig:robochart_acd_chemical_intensity}%
% \end{figure}
%
However, our definition of this function in Isabelle is directly \changed[\C{57}]{generated} from its specification and is shown below.
%
\newcommand{\pregs}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L341}}
\newcommand{\postgs}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L348}}
 \begin{alltt}
\isakwmaj{definition} "pre\_Chemical\_intensity\ gs = (blength gs > 0)" \(\pregs\)
\isakwmaj{definition} "Chemical\_intensity gs = (THE result. \(\postgs\)
    (\(\forall\)x::nat < blength gs. Chemical\_goreq(result, gs\_i (bnth gs x)))\(\land\)
    (\(\exists\)x::nat < blength gs. result = gs\_i (bnth gs x)))"
 \end{alltt}
\vspace{-3ex}
%
\noindent In the definitions, \isacode{blength gs} gives the length of a bounded sequence \isacode{gs}, \isacode{bnth gs n} gives the nth element in \isacode{gs}, and \isacode{gs\_i} returns the field value in a record of type \rcitem{GasSensor}. %The two definitions are straightforward except that a definite description ({\isacode{THE result}, denoting the unique \isacode{result} such that the predicate holds}) is used to return the \isacode{result}.
%We have two definitions here corresponding to the definition of \rcitem{intensity}: one for its precondition and one for its postconditions. %This is due to the semantics of such a function \rcitem{f} in RoboChart: a \changed[\C{52}]{Boolean} guard \cspcode{(pre(f)$\guard$~P)} where \cspcode{pre(f)} is the preconditions of \rcitem{f} and \rcitem{f} is called in process $P$, and so if the preconditions are not satisfied, the semantics deadlocks. 

We note that there is an error in the definition of \rcitem{intensity} in the original model where $\leq$ (instead of $<$) is used for comparison between \rcitem{x} (and \rcitem{y}) and \rcitem{size(gs)}. {This is because sequences are zero-indexed.} Our animation detects this error 
%(Isabelle raises an exception) 
and so we have fixed it. 
%Similarly, we also found another error in the postcondition of the function \rcitem{location}: the postcondition is not strong enough to identify a unique \rcitem{result} of the function.% for the same input. 

%The \rcitem{analysis} function defined in Fig.~\ref{fig:robochart_acd_chemical} has only one postcondition, and its corresponding definition in Isabelle is shown below.
%\newcommand{\panalysis}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#2283}}
%\begin{alltt}
%\isakwmaj{definition} "Chemical\_analysis gs = (if blength gs > 0 then  \(\panalysis\)
%   (if (\(\exists\)x::nat<blength gs. \(\lnot\)gs\_i (bnth gs x) = 0) then Status_gasD else Status_noGas)
%   else Status_noGas)"
%\end{alltt}
%\vspace{-3ex}
%

The \rcitem{location} function defined in Fig.~\ref{fig:robochart_acd_chemical} has one precondition and one postcondition; their corresponding definitions in Isabelle are shown below. The \rcitem{result} of this function is the location (on the right or in the front of the robot, according to the definition of the \rcitem{angle} function) where the largest intensity in \rcitem{gs} is detected.
\newcommand{\prelocation}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L386}}
\newcommand{\postlocation}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L389}}
 \begin{alltt}
\isakwmaj{definition} "pre\_Chemical\_location\ gs = (blength gs > 0)" \(\prelocation\)
\isakwmaj{definition} "Chemical\_location gs = (THE result. (\(\exists\)x::nat<blength gs. \(\postlocation\)
    (Chemical\_intensity(gs) = gs\_i (bnth gs x)) \(\land\)
    (\(\lnot\) (\(\exists\)y::nat < x. (Chemical\_intensity(gs) = gs\_i (bnth gs y)))) \(\land\)
    (\(\forall\)x::nat < blength gs. Chemical\_goreq(result, gs\_i (bnth gs x)))
    (result = Chemical\_angle(x))))"
 \end{alltt}
\vspace{-3ex}
%
Inside the definite description is an existential quantification over an index \isacode{x} of \isacode{gs} such that (a conjunction of three conjuncts)  
\begin{inparaenum}[(1)]
\item the intensity \isacode{gs\_i (bnth gs x)} of the sensor reading at index \isacode{x} is the largest intensity (\isacode{Chemical\_intensity(gs)}) in \isacode{gs}; 
\item there does not exist an index \isacode{y} such that \isacode{y} is less than \isacode{x} and the intensity at \isacode{y} is also the largest intensity in \isacode{gs} (in other \changed[\C{58}]{words}, \isacode{x} is the smallest index whose intensity is the largest); and   
\item the result of the function is just the angle \isacode{Chemical\_angle(x)} of \isacode{x}.
\end{inparaenum}

We also found another error in the postcondition of \rcitem{location} in the original model: the postcondition is not strong enough to identify a unique \rcitem{result} of the function for the same input (and so the result is a relation and not a function). Our function definition fixes this problem by specifying that \isacode{x} is the smallest index.

\changed[\C{59}]{While there are problems with the definitions of \rcitem{intensity} and \rcitem{location} in the original model\footnote{\url{robostar.cs.york.ac.uk/case_studies/autonomous-chemical-detector/autonomous-chemical-detector.html\#version4}}, their previous implementations\footnote{The implementations can be found in the \cspcode{instantiation.csp} file in the original model available at \url{robostar.cs.york.ac.uk/case_studies/autonomous-chemical-detector/autonomouschemicaldetector_v4.zip}.} (defined in CSP-M and shown below) in CSP for verification with FDR, however, are correct.} 
\begin{alltt}
intensity(gs) = let 
  aux(<>,max) = max
  aux(<g>^gs,max) = 
    if GasSensor_i(g) > max then aux(gs,GasSensor_i(g)) else aux(gs,max)
within
  aux(gs,0)

location(gs) = let
  aux(<>,max,n) = Front
  aux(<g>^gs,max,n) = if GasSensor_i(g) == max then angle(n) else aux(gs,max,n+1)
within
  aux(gs,intensity(gs),0)
\end{alltt}
\changed[\C{59}]{Both definitions make use of pattern matching (an empty sequence \cspcode{<>} or a non-empty sequence \cspcode{<g>\^{}gs}) to decompose values, initially starting (after \cspcode{within}) from the function application of \cspcode{aux} to \cspcode{gs}. The pattern matching, therefore, starts from the beginning of the sequence \cspcode{gs}. The definition of \cspcode{intensity} does not refer to the length of \cspcode{gs} and so avoids the comparison error introduced by using $\leq$ in its specification in the model. The definition of \cspcode{location} starts the comparison with the maximum intensity \cspcode{intensity(gs)} in \cspcode{gs} from the beginning of the sequence, and so the result is the \cspcode{angle} of the smallest index \cspcode{n} whose corresponding intensity is maximal. This is deterministic, and so avoids the problem in the specification of \cspcode{intensity} in the original model.} \qed
\end{example}

\changed[\C{59}]{The manual implementations, however, lead to an inconsistency between models and their semantic implementation for verification.} Our approach presented here translates the specification of functions from models to their semantic implementation \changed[\C{60}]{directly in Isabelle}, so the consistency is preserved. This is one benefit of our approach.
 
{
\subsection{Channels and alphabet transformation}
\label{ssec:semantics_channels}
% \begin{rmk}
%    Different approaches discussed to mechanise channel types and why we chose this approach. 
%    \begin{itemize}
%        \item A monolithic channel type for a whole model,
%        \item Or current approach is to have a channel type for each state machine, controller, or module.
%    \end{itemize}
% \end{rmk}
% 
% \paragraph{Channel type and declaration}
A CSP process in our semantics is an interaction tree of type $(E,R) \cspkey{itree}$, parametrised over a type $E$ of events representing the event alphabet ($\Sigma$) of the CSP process and a type $R$ of return values. 
$E$ is declared through a \isakwmaj{chantype} command \changed[\C{25}]{, created in our ITree-based CSP,} and expressed as a finite set of channels declared in the command.  
% Each channel $c$ is modelled by a prism~\cite{Pickering2017}: $V \pto E$ where $V$ is the value type of $c$. Each prism contains two functions~\cite[Definition 5]{Foster2021}: a destructor \IsaKey{match}: $E \pfun V$ and a constructor \IsaKey{build}: $V \changed[\C{62}]{\fun} E$, \changed[\C{62}]{a total function from $V$ to $E$}. 
%We use \IsaKey{c\_C} for \IsaKey{build}$_c$. 
We show an example to illustrate the creation of such an event alphabet \isacode{chan}.
%
\begin{alltt}
\isakwmaj{chantype} chan = 
  Input::integer \(\qquad\) Output::integer \(\qquad\)State::"integer list"
\end{alltt}
%
\noindent 
This \isacode{chan} declares three channels: \isacode{Input} and \isacode{Output} of type \isacode{integer}, and \isacode{State} of type \isacode{integer list}. %A prism models each channel. For example, the channel \isacode{Input}, carrying a value of \isacode{integer}, has a type \isacode{integer~}$\pto$\isacode{~chan}. We use \IsaKey{build}$_{Input}~1$ (a notation \isacode{Input\_C 1} introduced for it) to construct an event (\isacode{Input 1}) of type \isacode{chan}.  

External choice $P \extchoice Q$ requires that $P$ and $Q$ have the same type $(E, R) \cspkey{itree}$ and the same event type $E$. 
Parallel composition $P \parallel_A Q$ additionally requires that the type $R$ of return values is empty (\isacode{()} or \isacode{unit} in Isabelle) because CSP processes in parallel usually do not return data. So both $P$ and $Q$ should be the type of $(E, ()) \cspkey{itree}$. $A$ is a set of events and of type $\power E$\changed[\C{26}]{, the power set of $E$}.

The CSP processes with different types must be transformed into the same type before composition. The alphabet transformation of a process $P$ of type $(E_1,R) \cspkey{itree}$ is through renaming (or renaming with priority) according to a renaming relation $\rho$ of type $E_1 \rel E_2$ (or a finite sequence $\varrho$ of type $\seq\left(E_1 \cross E_2\right)$), and the resultant process $\rename{P}{\rho}$ (or $\renamep{P}{\varrho}$) is of type $(E_2,R) \cspkey{itree}$.

We also note that the renaming relation or the finite sequence for the renaming operators is ``total'' --- only events of type $E_1$ in the relation or the sequence are renamed. Others are blocked --- no matter whether this is a homogeneous ($E_1$ and $E_2$ are the same) or heterogeneous ($E_1$ and $E_2$ are different) renaming. This differs from the relational renaming operator in CSP-M, where the relation is partial. So, the renaming does not affect the events not in the relation. This difference is because ITrees or Isabelle's terms are strongly typed. 

In our ITree-based semantics for RoboChart, illustrated in Fig.~\ref{fig:robochart_acd_semantics} for the autonomous chemical detector model, each state machine, controller, or module has a different event alphabet by declaring an individual channel type. For example, the state machine \rcitem{GasAnalysis}, the controller \rcitem{MainController}, and the module \rcitem{ChemicalDetector} declare channel types \isacode{Chan\_\-GasAnalysis}, \isacode{Chan\_\-MainController}, and \isacode{Chan\_\-ChemicalDetector}. The renamed {GasAnalysis} transforms the event alphabet of \rcitem{GasAnalysis} from \isacode{Chan\_\-GasAnalysis} to \isacode{Chan\_\-MainController}, and so it can be composed in parallel with the controller memory (whose event type is \isacode{Chan\_\-MainController}). Similarly, the two controllers are renamed to the event alphabet \isacode{Chan\_\-ChemicalDetector} of the module to be composed in parallel with the robotic platform memory and buffer processes.

% \paragraph{Sets of events}
% Currently explicitly enumerate all events using the \isacode{map} function; another option is syntax $\isasymlbrace \isasymrbrace$ where the value type of an event must be enumerable for code generation. %and equal

}

\subsection{State machines}
\label{ssec:semantics_stm}

%\begin{TRule}[Semantics of state machine]{\meta{
%			\lsem stm:StateMachineDef \rsem_{\mathscr{STM}}^{nops}: CSPProcess = }}%{STM (State Machine)}
% \begin{align*}
%     & \meta{\semLC{stm:StateMachineDef}{STM}} = \\
% &\quad\begin{array}{@{}l}
% 		\circblockbegin
% 		\circblockbegin
% 		\meta{initialisation(stm)}\\\quad
% 		\lpar \meta{flowevtsFromSTM(stm)} \rpar\\
% 		\meta{composeStates(\langle x: stm.nodes | x \in State\rangle, stm)}
% 		\circblockend\\
% 		\hide \lchan enter, entered, exit, exited\rchan\\
% 		\lpar \meta{getsetChannels(stm) \cup trigEvents(stm)} \rpar\\
% 		\meta{stmMemory(stm)}
% 		\circblockend\\
% 		\rename \meta{renameTriggerEvents(stm)} \\
% 		\hide \meta{getsetLocalChannels(stm)} \cup \lchan internal \rchan\\
% 		\Theta_{\{end\}} Skip
% 	\end{array}%\\
% %&	\meta{\bf where}
% %	\\ %
% %&	\
% %\begin{array}{@{}l}
% %		\meta{flowevts = }
% %		\\
% %		\ %
% %		\meta{\bigcup \{ x: }SIDS\meta{ \setminus states(stm); y: states(stm)}
% %		\meta{~@~}\lchan enter.\meta{x}.\meta{y}, entered.\meta{x}.\meta{y}, exit.\meta{x}.\meta{y},
% %		exited.\meta{x}.\meta{y}\rchan
% %		\meta{\}}
% %	\end{array}
% \end{align*}
% %	\label{semantics:STM}
% %\end{TRule}

The RoboChart semantics of a state machine is a parallel composition of memory processes for its variables (\cspcode{MemoryVar}) and transitions (\cspcode{MemoryTrans}), and a process (\cspcode{STM}) for its behaviour with internal events hidden and also catering for its termination using the exception operator. 

\cspcode{STM} is a parallel composition of the behaviour (\cspcode{STM\_I}) for its initial junction and the restricted behaviour (\cspcode{S\_R}) for each state \cspcode{S} synchronising on state entering and exiting events. A state's behaviour \cspcode{S} involves entering this state, the execution of its during-action, and the execution of one of its transitions. The execution of a transition exits the state, executes the action of the transition, and enters the target state of the transition. {Not all transitions are available for \cspcode{S}, such as the transitions from sibling states of \rcitem{S} and substates of \rcitem{S}. These transitions are excluded in the restricted behaviour \cspcode{S\_R}.}

\subsubsection{General definitions}
\label{ssec:semantics_stm:gen_def}
The state machine semantics uses a general type \cspcode{InOut} for the direction of an event in a connection.
\newcommand{\InOut}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L162}}
 \begin{alltt} 
\isakwmaj{datatype} InOut = din | dout \(\InOut\)
\end{alltt}

Every state machine also has two data types for state and transition identifiers (\cspcode{SIDS} and \cspcode{TIDS}), and an event alphabet ($E$) for the process of this state machine. They are generated by three functions defined in the rules below. %The event alphabet is represented by the parametrised type $E$ of events. which is declared through the \isakwmaj{chantype} command. %$E$ is expressed by a finite set of channels declared in the command.
%In CSP-M, the event alphabet is denoted by \cspcode{Event} and is expressed by multiple channel declarations. 
%In Isabelle, we use a command \isakwmaj{chantype} to create a channel type \isacode{Chan} to group all channels. 
\begin{align*}
    & \meta{sidsOfSTM(stm:StateMachineDef) = }\\
    & \quad \isacode{\isakwmaj{datatype} SIDS}%\meta{stm.name}
    \isacode{ = SID\_}%\meta{stm.name} 
    \isacode{ | } \meta{\left\{s : stm.nodes | s \in State @ \right.}\isacode{SID\_}%\meta{stm.name}\isacode{\_}
    \meta{s.name, }\isacode{|}\meta{\left.\right\}} \\
    & \meta{tidsOfSTM(stm:StateMachineDef) = }\\
    & \quad \isacode{\isakwmaj{datatype} TIDS}
    %\meta{stm.name}
    \isacode{ = }\meta{\left\{t : stm.transitions @ \right.}\isacode{TID\_}%\meta{stm.name}\isacode{\_}
    \meta{t.name, }\isacode{|}\meta{\left.\right\}} \\ 
    & \meta{channelsOfSTM(stm:StateMachineDef) = }\\
    & \quad \isacode{\isakwmaj{chantype} Chan}\isacode{ = internal::TIDS     terminate::unit } \\
    & \quad\ \  \isacode{enter::SIDS$\cross$SIDS }
           \isacode{entered::SIDS$\cross$SIDS }
           \isacode{exit::SIDS$\cross$SIDS }
           \isacode{exited::SIDS$\cross$SIDS } \\
    & \quad\ \ \meta{\bigcup \left\{v : allLocalVariables(stm) @ \left\{\right.\right.}
         \isacode{get\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},}
         \isacode{set\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t}\left.\right\},\left.\right\}} \\
    & \quad\ \ \meta{\bigcup }\metanobar{\left\{\meta{v : requiredVariables(stm) @} \metanobar{\left\{
    \begin{array}[]{@{}l}
         \isacodebl{get\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},} \\
         \isacodebl{set\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},} \\
         \isacodebl{set\_EXT\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t}}
    \end{array}\right\}}, \right\}} \\
    & \quad\ \ \meta{\bigcup }\metanobar{\left\{\meta{e : allEvents(stm) @} \metanobar{\left\{
    \begin{array}[]{@{}l}
        \meta{e.name}\isacodebl{\_::TIDS$\cross$InOut$\cross$}\meta{\semL{e.type}{t},} \\
        \meta{e.name}\isacodebl{::InOut$\cross$}\meta{\semL{e.type}{t}}
    \end{array}\right\}}, \right\}} \\
    & \quad\ \ \meta{\left\{op : requiredOperations(stm) @ \right.}
    \meta{op.name}\isacodebl{Call::}\meta{\langle p : op.parameters @ \semL{p.type}{t},}\isacodebl{$\cross$}\meta{\rangle} \meta{,\left.\right\}}
\end{align*}

The function $\meta{sidsOfSTM}$ declares an enumeration type \isacode{SIDS}\footnote{In the Isabelle code, we include suffixes to ensure that names do not collide, but omit them here} containing state identifiers representing the machine itself \isacode{SID\_} and other states of the machine, that is, the nodes $\meta{stm.nodes}$ of the machine that are states $\meta{s \in State}$. The function $\meta{tidsOfSTM}$ declares \isacode{TIDS} contains transition identifiers. Channels in the machine are declared by the statement generated by the function $\meta{channelsOfSTM}$. 
The channel type \isacode{Chan} includes four kinds of channels.
%\begin{inparaenum}[(1)]
%\item 
Firstly, flow control channels include 
\begin{inparaenum}[(a)]
\item \isacode{internal} for transitions without a trigger;
\item \isacode{enter}, \isacode{entered}, \isacode{exit}, and \isacode{exited} for the entering and exiting of a state; and
\item \isacode{terminate} for the termination of the machine.
\end{inparaenum}
Secondly,
%\item 
variable channels contain a \isacode{set} and a \isacode{get} channel for each local variable ($\meta{v}$ of all local variables $\meta{allLocalVariables(stm)}$ of the machine) with an additional \isacode{set\_EXT} for each shared variable ($\meta{v}$ of the required variables $\meta{requiredVariables(stm)}$ of the machine) to accept an external update. We use generalised union $\meta{\bigcup}$ to combine all sets of channels for these variables into a large set.
%\item 
Thirdly, event channels include two channels for each event ($\meta{e}$ of all events $\meta{allEvents(stm)}$) of the machine: one channel named $\meta{e.name}$ and another named $\meta{e.name}\isacode{\_}$. 
%one such as \isacode{obstacle} for the event \rcitem{obstacle} used in actions of RoboChart and another such as \isacode{obstacle\_} (with an additional \isacode{TIDS} for its type) for the event \rcitem{obstacle} used as triggers of transitions.
%\end{inparaenum}
%
The distinction of two event channels (\isacode{ech} and \isacode{ech\_}) for each event (\rcitem{e}) is necessary because the guard of a transition is evaluated in \cspcode{MemoryTrans}, and so only the trigger event (not action event) of the transition is subject to the guard evaluation, and, therefore, has a new channel (\isacode{ech\_}) with a transition id of type \isacode{TIDS}. We note, however, that events \isacode{ech\_.tid} of this new channel are eventually renamed to the event channel \isacode{ech} in the process for the machine.
%
Fourthly, operation call channels include a channel named $\meta{op.name}\isacode{Call}$ for each required operation ($\meta{op}$ of all required operations $\meta{requiredOperations(stm)}$) of the machine. The type of the channel is the product \isacode{$\cross$} of the corresponding types ($\meta{\semL{p.type}{t}}$ for each parameter $\meta{p}$) of the operation parameters $\meta{op.parameters}$ in a sequence constructed by comprehension and so the order of the parameters is preserved.

\begin{example}[general types for Movement]
Below is an example of these data types for the \rcitem{Movement} machine in Fig.~\ref{fig:robochart_acd_movement}.
%
% \isakwmaj{datatype} InOut = din | dout \(\InOut\)
% \newcommand{\InOut}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L162}}
\newcommand{\SIDSMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L77}}
\newcommand{\TIDSMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L104}}
\newcommand{\ChanMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L227}}
%
 \begin{alltt} 
\isakwmaj{datatype} SIDS_Movement = SID_Movement | SID_Movement_Waiting | ... \(\SIDSMovement\)
\isakwmaj{datatype} TIDS_Movement = TID_Movement_t1 | TID_Movement_t2 | ...\(\TIDSMovement\)
\isakwmaj{chantype} Chan_Movement =   \(\ChanMovement\)
  internal_Movement :: TIDS_Movement
  terminate_Movement:: unit
  enter_Movement    :: "SIDS_Movement\(\cross\)SIDS_Movement" ...
  get_l_Movement    :: "Location_Loc"  
  set_l_Movement    :: "Location_Loc"
  obstacle__Movement:: "TIDS_Movement\(\cross\)InOut\(\cross\)Location_Loc"
  obstacle_Movement :: "InOut\(\cross\)Location_Loc" ...
  moveCall_Movement :: "core_real\(\cross\)Chemical_Angle" ...
\end{alltt}
% The channel type of \rcitem{Movement} includes four kinds of channels.
% %\begin{inparaenum}[(1)]
% %\item 
% Firstly, flow control channels include 
% \begin{inparaenum}[(a)]
% \item \isacode{internal}\footnote{In the Isabelle code, we include suffixes to ensure that names do not collide, but omit them here} for transitions without a trigger;
% \item \isacode{enter}, \isacode{entered}, \isacode{exit}, and \isacode{exited} for the entering and exiting of a state; and
% \item \isacode{terminate} for the termination of the machine.
% \end{inparaenum}
% Secondly,
% %\item 
%  variable channels contain a \isacode{set} and a \isacode{get} channel for each variable with an additional \isacode{set\_EXT} for each shared variable to accept an external update.
% %\item 
% Thirdly, event channels include two channels for each event of the machine, one such as \isacode{obstacle} for the event \rcitem{obstacle} used in actions of RoboChart and another such as \isacode{obstacle\_} (with an additional \isacode{TIDS} for its type) for the event \rcitem{obstacle} used as triggers of transitions.
% %\end{inparaenum}
% %
% The distinction of two event channels (\isacode{obstacle} and \isacode{obstacle\_}) for each event (\rcitem{obstacle}) is necessary because the guard of a transition is evaluated in \cspcode{MemoryTrans}, and so only the trigger event (not action event) of the transition is subject to the guard evaluation, and, therefore, has a new channel (\isacode{obstacle\_}) with a transition id. We note, however, that events \isacode{obstacle\_.tid} of this new channel are eventually renamed to the event channel \isacode{obstacle} in the process for the machine.
% %
% Fourthly, operation call channels include a channel such as \isacode{moveCall} for each call to the operation \rcitem{move} provided by the platform.
\end{example}
 
\subsubsection{Memory for variables and transitions}
\label{ssec:semantics_stm:memory}
%
The memory for a state machine is composed of the memory for its local variables, for its shared variables, and that for its transitions. Its semantics is defined below.
\begin{align*}
    & \meta{memSharedVar(s: Variable) = }\\
    & \quad \isacode{ \cspkey{loop} ($\lambda v$.} 
    \isacode{get\_}\meta{s.name}\isacode{!v $\to\subscriptIntt{\tick}{v} \extchoice$}
    \isacode{ set\_}\meta{s.name}\isacode{?x}\isacode{$\to\subscriptIntt{\tick}{x} \extchoice$}
    \isacode{ set\_EXT\_}\meta{s.name}\isacode{?x}\isacode{$\to\subscriptIntt{\tick}{x}$)} \\
    & \meta{memLocalVar(l: Variable) = } 
        \isacode{ \cspkey{loop} ($\lambda v$.} 
        \isacode{get\_}\meta{l.name}\isacode{!v $\to\subscriptIntt{\tick}{v} \extchoice$}
        \isacode{ set\_}\meta{l.name}\isacode{?x}\isacode{$\to\subscriptIntt{\tick}{x}$)} \\
        & \meta{guardExpr(e:Expression) = \left(\right.\IF\ e \neq null\ \THEN\ }\isacodebl{guard }\meta{\semL{e}{e}} \meta{\ \ELSE\ }\isacodebl{\cspkey{skip}}\meta{\left.\right)} \\
    & \meta{memTransition(t: Transition) = } \\
    & \metanobar{
        \circblockbegin
        \meta{\IF\ t.trigger=null\ \THEN\ }\\ 
        \quad \isacodebl{internal!TID\_}\meta{t.name}\isacodebl{$\to \cspkey{skip}$} \\
        \meta{\ELSE\ \IF\ t.trigger.type=CommunicationType.SIMPLE\ \THEN\ }\\ 
        \quad \meta{t.tigger.event.name}\isacodebl{\_!(TID\_}\meta{t.name}\isacodebl{,din)$\to \cspkey{skip}$} \\
        \meta{\ELSE\ \IF\ t.trigger.type=CommunicationType.INPUT\ \THEN\ }\\ 
        \quad \meta{\LET\ e==t.trigger.event; p==t.trigger.parameter @ }\\
        \quad \meta{e.name}\isacodebl{\_?}\meta{p.name : \left\{p.name : p.type | t.condition @ \right.}\isacodebl{(TID\_}\meta{t.name}\isacodebl{,din,}\meta{\semL{p.name}{e}}\isacodebl{)}\meta{\left.\right\}}\isacodebl{$\to \cspkey{skip}$} \\
        \meta{\ELSE\ \IF\ t.trigger.type=CommunicationType.OUTPUT\ \THEN\ }\\ 
        \quad \meta{guardExpr(t.condition)} \isacodebl{;} \meta{t.tigger.event.name}\isacodebl{\_!(TID\_}\meta{t.name}\isacodebl{,dout,}\meta{\semL{t.trigger.value}{e}}\isacodebl{)$\to \cspkey{skip}$} \\
        \meta{\ELSE\ }\\%\IF\ t.trigger.type=CommunicationType.SYNC\ \THEN\ }\\ 
        \quad \meta{guardExpr(t.condition)} \isacodebl{;} \meta{t.tigger.event.name}\isacodebl{\_!(TID\_}\meta{t.name}\isacodebl{,din,}\meta{\semL{t.trigger.value}{e}}\isacodebl{)$\to \cspkey{skip}$} \\
        %\meta{\ELSE\ }\\ 
        \circblockend
} \\
    & \meta{memTransitions(stm:StateMachineDef) = }\\
    & \quad \isacode{ \cspkey{loop} ($\lambda id$. (} \isacode{$\Extchoice$}\meta{t:stm.transitions @ memTransition(t)}\isacode{))}  \\
    & \meta{\semLC{stm:StateMachineDef}{Mem} = }\\
    & \quad \metanobar{
        \circblockbegin
        \left(\isacodebl{$\Extchoice$}\meta{v : allLocalVariables(stm) @ memLocalVar(v)}\right) \isacodebl{$\extchoice$} \\
        \left(\isacodebl{$\Extchoice$}\meta{v : requiredVariables(stm) @ memSharedVar(v)}\right) \isacodebl{$\extchoice$} \\
        % \left(\isacodebl{$\Extchoice$}\meta{tr : allTransitions(stm) @ memTransition(rt)}\right)
        \meta{memTransitions(stm)}
        \circblockend
    }
\end{align*}

\noindent The memory $\meta{memSharedVar(s)}$ for a shared variable $\meta{s}$ is an infinite \isacode{\cspkey{loop}}. It provides three choices: output the value \isacode{v} on \isacode{get\_s} without updating the variable and
accept a local (or external) update of the variable through \isacode{set\_s} (or \isacode{set\_EXT\_s}). For a local variable $\meta{l}$, its memory process $\meta{memLocalVar(l)}$ does not provide an external update.

The memory $\meta{memTransition(tr)}$ for a transition $\meta{tr}$ depends on the trigger $\meta{tr.trigger}$ of $\meta{tr}$. Suppose $\meta{tr}$ has no trigger (such as the transition from the initial junction to \rcitem{Waiting} in the state machine \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement}), $\meta{tr.trigger=null}$. In that case, its memory is an output of the corresponding transition identifier \isacode{TID\_}$\meta{tr.name}$ on channel \isacode{internal}. Otherwise, if the trigger type $\meta{tr.trigger.type}$ of $\meta{tr}$ is $\meta{SIMPLE}$ (with an event name but no value such as \rcitem{resume}
%like the self transition of \rcitem{Waiting} in \rcitem{Movement}
), its memory is an output of a tuple composed of the transition identifier and \isacode{din} on the corresponding channel $\meta{tr.tigger.event.name}$\isacode{\_}. 
%
Suppose the trigger type is $\meta{INPUT}$ (such as \rcitem{turn?a}). In that case, we use local definitions $\meta{\LET}$ to introduce $\meta{e}$ for the trigger event and $\meta{p}$ for the trigger input variable. The memory for the transition is an input of tuples, composed of the transition identifier, \isacode{din}, and the value $\meta{\semL{p.name}{e}}$ (restricted to the type $\meta{p.type}$ of the trigger event and satisfy the guard $\meta{tr.condition}$ of the transition), from the corresponding channel. 
%
Suppose the trigger type is $\meta{OUTPUT}$ (such as \rcitem{turn!v}). In that case, the memory for the transition evaluates its guard first by $\meta{guardExpr(tr.condition)}$ which uses the \isacode{guard} operator to test the expression if it is not $\meta{null}$, or is just \isacode{skip} otherwise, followed by an output of the corresponding value $\meta{tr.trigger.value}$ on the corresponding channel. 
%
If the trigger type is not from one of the presented types, it must be of type $\meta{SYNC}$ (such as $turn.v$). Then the memory for $\meta{tr}$ (the $\meta{\ELSE}$ branch) is similar to the output trigger except that the event direction is \isacode{din} now (because of RoboChart's semantics). 

The memory $\meta{memTransitions(stm)}$ for all transitions in a state machine $\meta{stm}$ is a loop infinitely offering the memory $\meta{memTransition(tr)}$ for each transition $\meta{tr}$ from the transitions $\meta{stm.transitions}$ of $\meta{stm}$. Here, we use replicated external choice \isacode{$\Extchoice$} to construct external choice from a set of processes. 

Then the memory $\meta{\semLC{stm}{Mem}}$ of a state machine offers an external choice for the memories of all the local variables $\meta{allLocalVariables(stm)}$, all the shared variables $\meta{requiredVariables(stm)}$, and all the transitions.

\begin{example}[memory of a shared variable]
The memory process \isacode{Memory\_x} for the shared variable \rcitem{x} in the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}, is shown below.
%
\newcommand{\MemorySharedV}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L292}}
\begin{alltt}
  \cspkey{loop} (\(\lambda\)v. get_x!v \(\to\) \(\subscriptIntt{\tick}{v}\) \(\extchoice\) set_x?x \(\to\) \(\subscriptIntt{\tick}{x} \extchoice\) set_EXT_x?x \(\to\) \(\subscriptIntt{\tick}{x}\)) \(\MemorySharedV\)
\end{alltt}
%\qed
\end{example}
%
%\noindent The process is an infinite loop. It provides three choices: output the value \isacode{v} on \isacode{get\_x} without updating the variable and
%    accept a local (or external) update of the variable through \isacode{set\_x} (or \isacode{set\_EXT\_x}). For a local variable of the state machine, its memory process does not provide an external update.

\begin{example}[memory of transitions]
The memory process for transitions of the state machine \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement} is partially (3 in 24 transitions) illustrated below.
%
\newcommand{\MovementMemoryTrans}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L747}}
\begin{alltt}
  Movement_MemoryTrans = \cspkey{loop} (\(\lambda\)id.  \(\MovementMemoryTrans\)
    internal!TID_t1 \(\to\) \(\subscriptIntt{\tick}{id}\) \(\extchoice\) 
    resume_!(TID_t0, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    turn_?(TID_t3, din, a\(\in\)Chemical_Angle) \(\to\) \(\subscriptIntt{\tick}{id}\) \(\extchoice\) 
    ...  \(\extchoice\) 
    get_d1?d1 \(\to\) get_d0?d0 \(\to\) 
      ((rc.Minus d1 d0 rc.core_int) > stuckDist)\(\guard\)(internal!TID_t12 \(\to\) \(\subscriptIntt{\tick}{id}\)) \(\extchoice\) 
    ...
\end{alltt}
%\qed
\end{example}
%
% The state of this loop process is a constant \isacode{id} (used to identify a RoboChart module). Each choice corresponds to a transition: 
% \begin{inparaenum}[(1)]
%     \item the first choice \changed[\C{63}]{to} the default transition \rcitem{t1} from the initial junction to state \rcitem{Waiting} which has no trigger (hence \isacode{internal}); 
%     \item the second \changed[\C{63}]{to} the self transition of state \rcitem{Waiting} whose trigger is an output \rcitem{resume} (\changed[\C{64}]{the direction of the \rcitem{resume} event is }\rcitem{din} because it acts as an input in the state machine according to the connection in Fig.~\ref{fig:robochart_acd_microcontroller}); and   
%     \item the third \changed[\C{63}]{to} the transition from \rcitem{Waiting} to state \rcitem{Going} which has an input trigger \rcitem{turn?a} where we use a notation \isacode{turn\_?(TID\_t3, din, a$\in$Chemical\_Angle)} to denote \isacode{\cspkey{inp} turn\_ \{(TID\_t3, din, a) | a$\in$Chemical\_Angle\}} (input values from a set of triples by set comprehension over a channel \isacode{turn\_}); and   
%     \item the fourth \changed[\C{63}]{to} the transition from \rcitem{AvoidingAgain} to \rcitem{Avoiding} whose guard is \rcitem{(d1-d0>stuckDist)} (time semantics is ignored, \rcitem{-} becomes a closed operator \isacode{rc.Minus} under \isacode{core\_int}) and evaluated in this memory transition process.
% \end{inparaenum}
% We note that these choices will not lead to nondeterminism because their initial input or output events are parametrised over a distinct \isacode{TID} (for each choice).

\begin{example}[memory of transitions with an input trigger and a guard]
%For the transition with an input trigger and a guard together, such as the self transition of the state \rcitem{move} in Fig.~\ref{fig:robochart_patrol} with a trigger \rcitem{update?l} and a guard \rcitem{[l>=-MAX]}, its semantics in CSP is a constrained input prefix: \cspcode{update?l:(l$\geq$-MAX)} where \cspcode{(l$\geq$-MAX)} is a constraint on \cspcode{l}. 
    The memory process for the transitions of the state machine \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol} has \changed[\C{64}]{the} choices below.
%
\newcommand{\MoveSTMMemoryTrans}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L725}}
\begin{alltt}
  MoveSTM_MemoryTrans = \cspkey{loop} (\(\lambda\)id. \(\MoveSTMMemoryTrans\)
    internal!(TID_t0, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    reset_!(TID_t2, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    inp update\_ \{(TID\_t1, din, l) | l \(\in\) rc.core\_int. l \(\geq\) (rc.Neg MAX rc.core\_int)\} \(\extchoice\) 
    inp update\_ \{(TID\_t3, din, l) | l \(\in\) rc.core\_int. l \(\leq\) MAX\})
\end{alltt}
%\qed
\end{example}
%
%In Isabelle, we encode constraints in the predicate part of set comprehension.
\subsubsection{Transitions}
\label{ssec:semantics_stm:transitions}
This paper considers three kinds of nodes, initial junctions, basic states, and final states, used in the two RoboChart models. Semantics for other nodes, including normal junctions and composite states, are part of our future work. In the semantics for a transition defined below, we consider two kinds of source nodes because a final state is also a $\meta{State}$.
\begin{align*}
    & \meta{\semL{(t:Transition, stm:StateMachineDef)}{\mathscr{T}} =} \\
    & \quad \metanobar{
        \circblockbegin
        \meta{\IF\ t.src \in Initial \ \THEN\ }\\ 
        \quad \isacodebl{internal!TID\_}\meta{t.name}\isacodebl{ $\to$ }\meta{\semLC{t.action}{A}}\isacodebl{; enter!(SID\_}\meta{stm.name}\isacodebl{,SID\_} \meta{t.target.name}\isacodebl{)$\to$} \\
        \quad \isacodebl{entered!(SID\_}\meta{stm.name}\isacodebl{,SID\_} \meta{t.target.name}\isacodebl{) $\to  \cspkey{skip}$} \\
        \meta{\ELSE\ \IF\ t.src \in State \ \THEN\ }\\ 
        \quad \meta{\semLC{t.trigger}{TR}}\isacodebl{; exit!(SID\_}\meta{t.src.name}\isacodebl{,SID\_} \meta{t.src.name}\isacodebl{)$\to$} \meta{\semLC{t.src.exit}{A}} \isacodebl{;}\\
        \quad \isacodebl{exited!(SID\_}\meta{t.src.name}\isacodebl{,SID\_} \meta{t.src.name}\isacodebl{) $\to$} \meta{\semLC{t.action}{A}} \isacodebl{;} \\
        \quad\isacodebl{enter!(SID\_}\meta{t.src.name}\isacodebl{,SID\_} \meta{t.target.name}\isacodebl{)$\to$} \\
        \quad \isacodebl{entered!(SID\_}\meta{t.src.name}\isacodebl{,SID\_} \meta{t.target.name}\isacodebl{) $\to  \cspkey{skip}$} \\
        \circblockend
    }
\end{align*}
From the semantic point of view, a transition starts with the synchronising of its trigger, then initiates an exit from its source node, executes the exit action of the source node, makes its source node exited, executes its transitions action, and finally enters the target node of the transition. 
%
If the source node $\meta{t.src}$ of a transition $\meta{t}$ is an initial junction, $\meta{t.src \in Initial}$, then $\meta{t}$ has no trigger and so channel \isacode{internal} with \isacode{TID} for the transition is synchronised. Because the source node is an initial junction, $\meta{t}$ does not need to exit the junction explicitly. The next step after the trigger, therefore, is the execution of the transition action $\meta{\semLC{t.action}{A}}$ (whose definition in the context of actions $\meta{\mathscr{A}}$ is omitted here). After that, $\meta{t}$ \isacode{enter}s its target node, and the node is \isacode{entered}. 

If the source node $\meta{t.src}$ is a state, the transition trigger $\meta{\semLC{t.trigger}{TR}}$, defined below, is synchronised.  
\begin{align*}
    & \meta{\semLC{tr: Communication, t:Transition}{TR} = } \\
    & \quad \metanobar{
        \circblockbegin
        \meta{\IF\ tr = null \THEN\ }\\ 
        \quad \isacodebl{internal!TID\_}\meta{t.name}\isacodebl{$\to \cspkey{skip}$} \\
        \meta{\ELSE\ \IF\ tr.event.type = null \THEN\ }\\ 
        \quad \meta{tr.event.name}\isacodebl{\_!(TID\_}\meta{t.name}\isacodebl{,din)$\to \cspkey{skip}$} \\
        \meta{\ELSE\ }\\ 
        \quad \meta{\LET\ e==tr.event; p==tr.parameter @ }\\
        \quad \ \ \meta{e.name}\isacodebl{\_?}\meta{p.name : \left\{p.name : p.type @ \right.}\isacodebl{(TID\_}\meta{t.name}\isacodebl{,din,}\meta{\semL{p.name}{e}}\isacodebl{)}\meta{\left.\right\}}\\
        \qquad \ \ \isacodebl{$\to$ set\_} \meta{p.name}\isacodebl{!}\meta{p.name} \isacodebl{$\to \cspkey{skip}$} \\
        \circblockend
    }
\end{align*}
A trigger is of type $\meta{Communication}$. Depending on whether the trigger exists and the trigger type, the semantics of the trigger might synchronise on channel \isacodebl{internal}, the channel corresponding to the trigger event $\meta{tr.event.name}$, or accept input from the channel and then set the received value on $\meta{p.name}$ to the corresponding variable $\meta{p.name}$ in the memory using channel \isacodebl{set\_}$\meta{p.name}$.

After the trigger, the transition $\meta{t}$ starts to \isacodebl{exit} from its source node, executes the exit action $\meta{t.src.exit}$ of the node, and makes the node \isacodebl{exited}. The subsequent behaviour is similar to the $\meta{Initial}$ case.

\subsubsection{Nodes}
\label{ssec:semantics_stm:nodes}
The semantics of each node in a state machine is a CSP process. 

\paragraph{Initial junctions}
One state machine has only one initial junction and one outgoing transition. Its semantics is defined below.
\begin{align*}
    & \meta{\semL{(stm:StateMachineDef)}{\mathscr{NI}} =} \\
    & \quad \meta{\LET\ i==\left(\mu n : stm.nodes | n \in Initial\right); t==\left(\mu t : stm.transitions | t.source = i \right) @ \semL{t, stm}{\mathcal{T}}}
%    & \quad \meta{\left(\LET\ i==\left(\mu n : stm.nodes | n \in Initial\right); 
%              t==\left(\mu t : stm.transitions | t.source = i \right) 
%              @ \semL{t, stm}{\mathscr{T}}
%          \right)}
\end{align*}
The semantics of the only initial junction $\meta{i}$ (retrieved through the definite description operator $\mu$) in a state machine $\meta{stm}$ is just the semantics $\meta{\semLC{t, stm}{T}}$ of the only outgoing transition $\meta{t}$ (retrieved through $\mu$ too) from $\meta{i}$.

\begin{example}[initial junction]
 We show the semantics for the initial junction \rcitem{i0} in the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}, which has an outgoing transition \rcitem{t0} with an action \rcitem{x=0} to set the variable \rcitem{x} to 0. 
 %
 \newcommand{\ICalSTMij}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L306}}
 \begin{alltt}
   I_i0 = internal!TID_t0 \(\to\) set_x!0 \(\to\) enter!(SID_CalSTM, SID_CalSTM_cal) \(\to\) 
     entered!(SID_CalSTM, SID_CalSTM_cal) \(\to\) \(\subscriptIntt{\tick}{}\) \(\ICalSTMij\) 
 \end{alltt}
\end{example}
% %
% \noindent The process outputs 
% \begin{inparaenum}[(1)]
%     \item a pair \isacode{(TID\_t0, din)} on the channel \isacode{internal}, denoting the empty trigger of \rcitem{t0} from \rcitem{i0} to state \rcitem{cal}; 
%     \item 0 on the channel \isacode{set\_x}, denoting the initialisation of \rcitem{x} to 0 (by parallel composition with the memory for \isacode{x} presented later), which corresponds to the action of \rcitem{t0};
%     \item a pair \isacode{(SID\_CalSTM, SID\_CalSTM\_cal)} on the channel \isacode{enter}, denoting the start of entering the state \rcitem{cal}; and
%     \item a pair \isacode{(SID\_CalSTM, SID\_CalSTM\_cal)} on the channel \isacode{entered}, denoting the completion of entering \rcitem{cal}.
% \end{inparaenum}

\paragraph{States}
The semantics for a state node is given below.
\begin{align*}
    & \meta{\semLC{(s: State, stm:StateMachineDef)}{NS}} = \isacode{ \cspkey{loop} } \\
    & \ \ \circblockbegin
    \isacodebl{$\lambda id$.enter?sd:}\meta{\left\{sid : \right.}\isacodebl{SIDS} \meta{| sid \neq }\isacodebl{ SID\_}\meta{s.name} \meta{ @} \isacodebl{(}\meta{sid}\isacodebl{, SID\_} \meta{s.name} \isacodebl{)}\meta{\left.\right\}}\isacode{$\to$} \isacode{\Ret (True, fst sd);} 
    %& \quad \isacode{
    \\
    \circblockbegin
    \isacodebl{\cspkey{iterate} ($\lambda $r. fst r) } \\
    \circblockbegin
    \isacodebl{$\lambda $r.} \\
    \circblockbegin
    \meta{\semLC{s.entry}{A}} \isacodebl{;} \isacode{entered!(fst r, SID\_} \meta{s.name} \isacodebl{)}\isacode{$\to$ (} \meta{\semLC{s.during}{A}} \isacodebl{; stop) $\interrupt$}\\
    \circblockbegin
    \isacodebl{($\Extchoice$ }\meta{t : selfTransFromNode(s) @ } \isacodebl{(}\meta{\semLC{t, stm}{T}}\isacodebl{; \Ret (True, SID\_}\meta{s.name}\isacodebl{)))} \isacodebl{$\extchoice$} \\
    \isacodebl{($\Extchoice$ }\meta{t : nonSelfTransFromNode(s) @ } \isacodebl{(}\meta{\semLC{t, stm}{T}}\isacodebl{; \Ret (False, SID\_}\meta{s.name}\isacodebl{)))} \isacodebl{$\extchoice$} \\
    \circblockbegin
    \isacodebl{$\Extchoice$ }\meta{e : EvtChns @}\\
    \quad \meta{e.name} \isacodebl{\_?x:} \meta{\left\{t : \right.} \isacodebl{TIDS } \meta{ | t \in ITIDS(stm) \land t \notin ITIDS_s(s) @ } \isacodebl{(}\meta{t} \isacodebl{,\_,\_)} \meta{\left.\right\}} \isacodebl{$\to$}\\
    \quad \isacodebl{exit?sd:} \meta{\left\{sid: \right.}\isacodebl{SIDS }\meta{ | sid \neq } \isacodebl{SID\_}\meta{s.name @ }\isacodebl{(}\meta{sid}\isacodebl{,SID\_}\meta{s.name}\isacodebl{)} \meta{\left.\right\}} \isacodebl{$\to$} \meta{\semLC{s.exit}{A}} \isacodebl{;} \\
    \quad \isacodebl{exited!(fst sd, SID\_} \meta{s.name}\isacodebl{)$\to$ \Ret (False, SID\_}\meta{s.name}\isacodebl{)} 
    \circblockend\hspace*{-.5em}
    \circblockend\hspace*{-.5em}
    \circblockend\hspace*{-.5em}
    \circblockend\hspace*{-.5em}
    \circblockend\hspace*{-.5em} 
    \circblockend
\end{align*}
Basically, the semantics is an infinite loop, an ITree, whose state (a state of an ITree is its carried data or its return value) is an integer \isacode{id} (the parameter of the semantics process), with a nested conditional iteration by \isacode{iterate}. The state of the iteration is a pair such as \isacode{(True, fst sd)}, whose first element is a \changed[\C{52}]{Boolean} value to indicate if this iteration terminates or not, and whose second element is the RoboChart state (for example \isacode{fst r}) that initiates entering of the state $\meta{s}$. Initially, the state of the iteration is passed from its preceding \isacode{Ret} construct. 

Initially, the state $\meta{s}$ is waiting for the \isacode{enter}ing from other states ($\meta{sid \neq }\isacodebl{ SID\_}\meta{s.name}$). After that, the source node, the first \isacode{fst} element of the pair \isacode{sd}, is passed to the subsequent iteration. The first argument \isacode{($\lambda$r.fst r)} of the iteration is its condition, a boolean function from the state of the iteration (a pair and \isacode{fst r} is the termination condition), and the second argument is its body, an ITree process. The process starts with the execution of the entry action $\meta{\semLC{s.entry}{A}}$ of $\meta{s}$ and then signals that $\meta{s}$ is \isacode{entered} to the node, \isacode{fst sd}, that initiates the entering. Afterwards, the during action $\meta{\semLC{s.during}{A}}$ of $\meta{s}$ is being executed while offering the possibility of interruption \isacode{$\interrupt$} by a transition process on the right of \isacode{$\interrupt$}. The during action is composed sequentially with \isacode{stop}. So, the interrupt cannot be terminated here and can only be terminated by the transition process offered in an external choice of three groups:  
\begin{inparaenum}[(1)]
\item self-transitions $\meta{selfTransFromNode(s)}$ of $\meta{s}$; 
\item other transitions $\meta{nonSelfTransFromNode(s)}$ from $\meta{s}$ that are not self-transitions; and 
\item transitions that can interrupt $\meta{s}$.
\end{inparaenum}

The process for each self-transition $\meta{t}$ is terminated (\isacode{\Ret}), after $\meta{t}$ is taken ($\meta{\semLC{t.stm}{A}}$), and returned with a state \isacode{(True, SID\_)}$\meta{s.name}$. The iteration, therefore, is not terminated (because the condition is \isacode{True}), and so the self-transition doesn't need to \isacode{enter} $\meta{s}$ again. 

The process for each other transition $\meta{t}$ is terminated and returned with a state \isacode{(False, SID\_)}$\meta{s.name}$. The iteration, therefore, is terminated (because the condition is \isacode{False}), and so the semantics of $\meta{s}$ needs to re-\isacode{enter} it from the body of the loop again. 

% The third group is for the transitions $\meta{ITIDS(stm)}$ of $\meta{stm}$ that are from any state (and so they could interrupt other states) of $\meta{stm}$, but do not include those transitions $\meta{ITIDS_s(s)}$ in the parent of $\meta{s}$. 
The third group is for the transitions $\meta{ITIDS(stm)}$ of $\meta{stm}$ that are from any state (and so they could interrupt other states) of $\meta{stm}$, but do not include those transitions $\meta{ITIDS_s(s)}$ that are from or contained in $\meta{s}$. 
This group applies to composite states in RoboChart, which further contain nodes and transitions. No composite state is used for the two RoboChart examples in this paper, so the parent of $\meta{s}$ is just $\meta{stm}$. Therefore, no such interruptible transitions are in the examples. In general, for each event $\meta{e}$ of all trigger events $\meta{EvtChns}$ in $\meta{stm}$, its corresponding event channel is $\meta{e.name}$\isacode{\_}. Each trigger event can interrupt the during action if the corresponding transition is in this group. After the trigger event, the semantics of $\meta{s}$ accepts \isacode{exit} from any other state $\meta{sid}$ ($\meta{sid\neq }$\isacode{SID\_}$\meta{s.name}$), executes its exit action, signals that $\meta{s}$ is \isacode{exited}, and then terminates.

%% The process $S$ for the behaviour of a state \rcitem{S} is sketched below.
%% %as \isacode{\cspkey{inp} update\_ \{(TID\_t1, din, l) | l$\in$rc.core\_int. l$\geq$rc.Neg MAX rc.core\_int\}} where \isacode{rc.Neg} is an arithmetic negation operator closed under a bounded integer type implemented in a locale \isacode{robochart\_confs} (see Sect.~\ref{ssec:inst}).
%% 
%% % The process \cspcode{S} for the behaviour of a state \rcitem{S} contains two recursions (one is nested), and its CSP code is sketched below.
%% % %
%% % \begin{alltt}
%% % S(id) = \cspkey{let}
%% %   S_execute(id,sr) = S_entry; entered.sr!SID_S\(\to\)(
%% %     ... [] ... -> S_execute(id,st1) ... [] ... -> S(id) ...)
%% % \cspkey{within} enter?sr:oSIDs!SID_S -> S_execute(id,sr)
%% % \end{alltt}
%% % %
%% % The process \cspcode{S} is a recursion because \cspcode{S\_execute} can be a recursion (by calling itself) or a mutual recursion (by calling \cspcode{S}).
%% % 
%% % ITrees supports a tail-recursive iteration: \isacode{(iterate b P s)} which iterates whilst the condition \isacode{b} is satisfied by state \isacode{s} and, otherwise, returns the current state \isacode{s}. A \isacode{loop} is a special iteration in which the condition is always true, and so it never terminates. For the process \cspcode{S} shown above, its corresponding implementation in Isabelle is given below.
%% % 
%% \begin{align*}
%% &S(id) = enter?sd:OSIDS \to S\_exec(id, fst~sd)\\
%% &S\_exec(id, s) = S\_entry \fatsemi entered!(s,SID\_S) \fatsemi\\
%% &%\left(
%% %\begin{array}{@{}l}
%% 	\left(
%% 	    \begin{array}{@{}l}
%% 	    (S\_during \fatsemi stop) \interrupt \\
%% 	    \left(
%% 	        \begin{array}{@{}l}
%% 	    	\Extchoice t:sTrans @ \left(
%% 	    		\begin{array}{@{}l}
%% 	    		    e\_t?(TID\_t, \_) \to exit!pSID\_S \to S\_exit \fatsemi \\
%% 	    		    exited!pSID\_S \to enter!pSID\_S \to \\
%% 	    		    S\_exec(id, SID\_S)
%% 	    		\end{array}\right)
%%  \extchoice \\
%% 	    	\Extchoice t:oTrans @ \left(
%% 	    		\begin{array}{@{}l}
%% 	    		    %e\_t?(TID\_t, \_) \to exit!pSID\_S \to S\_exit; \\
%% 	    		    ... \fatsemi exited!pSID\_S \to enter!(SID\_S, SID\_td) \\
%% 	    		    \to entered!(SID\_S, SID\_td) \to S(id)
%% 	    		\end{array}\right) \extchoice\\
%% 	    		\Extchoice e\_:EvtChs @ \left(
%% 	    		\begin{array}{@{}l}
%% 	    		e\_?(TID\_t,\_) \to exit?sd:OSIDS \to \\ (S\_exit \fatsemi exited?(fst~sd, SID\_S) \to S(id))
%% 	    		 \end{array}
%% 	    		\right)
%% 	        \end{array}
%% 	    \right)
%% 	    \end{array}
%% 	\right)
%% %\end{array}
%% %\right)
%% \end{align*}
%% $S$ and $S\_exec$ are defined by mutual recursion. Initially, $S$ accepts $enter$ing from other nodes of the state machine containing \rcitem{S} where $OSIDS$ denotes a set of pairs $(oSID, SID\_S)$ ($oSID$ is $SID$ for one of the other nodes, and $SID\_S$ is $SID$ for \rcitem{S}). Afterwards, the behaviour of \rcitem{S} is given by $S\_exec$ with its second argument being the other node (the first element of $sd$). 
%% 
%% $S\_exec$, with a parameter $s$ denoting the node entering \rcitem{S}, executes the entry action of \rcitem{S} first, if any, denoted by $S\_entry$. Then \rcitem{S} is $entered$.
%% % by outputting a pair $(s, SID\_S)$
%% After that, the behaviour is given by an interrupt. The during-action of \rcitem{S} ($S\_during$) can be executed if none of the initial events of the right side (external choices) of the interrupt is performed, that is, none of the self transitions $sTrans$ of \rcitem{S} or other transitions $oTrans$ from \rcitem{S} is taken, or none of the trigger events $EvtChs$ of the state machine containing \rcitem{S} is signalled. If any of these transitions are taken, or trigger events are signalled, the during-action is interrupted. A $stop$ process after $S\_during$ prevents the interrupt from being terminated, so interruption is always possible.
%% 
%% For each $t$ of $sTrans$, it behaves as follows: 
%% \begin{inparaenum}[(1)]
%%     \item the corresponding event channel $e\_t$ for its trigger event, such as \isacode{obstacle\_}, synchronises on $t$ (identified by $TID\_t$) only;
%%     \item \rcitem{S} starts to $exit$ by itself where $pSID\_S$ denotes $(SID\_S, SID\_S)$;
%%     \item the exit action of \rcitem{S}, denoted by $S\_exit$, is executed;
%%     \item \rcitem{S} is $exited$;
%%     \item $t$ starts to $enter$ \rcitem{S} again because it is a self transition; and 
%%     \item finally $S\_exec$ is recursively called with the source state $s$ being $SID\_S$.
%% \end{inparaenum}
%% 
%% For each $t$ of $oTrans$, the early behaviour is the same as above, so it is omitted ($...$). After \rcitem{S} is $exited$, $t$ starts to $enter$ its target from \rcitem{S}, identified by $SID\_td$, and then the target is $entered$. Finally, \rcitem{S} returns to its initial state ($S(id)$ is called) and accepts a further $enter$ request.
%% 
%% For each trigger event \rcitem{e} of the state machine containing \rcitem{S}, there is a corresponding additional event channel \isacode{e\_} declared in the channel type of the machine. $EvtChs$ denotes the set of these channels. If this event $e$ of a transition $t$ is signalled ($e?(TID\_t,\_)$), the during-action is interrupted, and \rcitem{S} accepts an $exit$ from one of the other nodes. Then, its exit action, denoted by $S\_exit$, is executed. Afterwards, \rcitem{S} is $exited$ from the node ($fst~sd$). Finally, \rcitem{S} returns to its initial state ($S(id)$ is called) and accepts a further $enter$ request.
%% 
%% $S$ and $S\_exec$ are implemented in ITrees through nested iterations: the outer iteration, corresponding to $S$, is an infinite \cspkey{loop} and the inner, corresponding to $S\_exec$, is a conditional iteration by the \cspkey{iterate} constructor. The condition is true for self-transitions and false otherwise. 
%% 
%% An example of the process for state \rcitem{Waiting} in \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement} is shown below.
%% % can be found online (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}).
%% % \begin{align*}
%% % &S(id) = \cspkey{loop} \left(\lambda id. enter?sd:OtSIDS \to S\_exec(id, fst~sd); \tick_{id} \right)\\
%% % &S\_exec(id, s) = \\
%% % &\left(
%% % \begin{array}{@{}l}
%% % 	S\_entry; entered!(s,SID\_S); \\
%% % 	\left((S\_during; stop) \interrupt \left(
%% % 	\begin{array}{@{}l}
%% % 		(selfTransFromS; S\_exec(id, s)) \extchoice \\
%% % 		(otherTransFromS; S(id)) \extchoice\\		
%% % 	\end{array}
%% % 	\right)
%% % 	\right)
%% % \end{array}
%% % \right)\\
%% % \end{align*}
%% % \begin{alltt}
%% % S = \cspkey{loop} (\(\lambda\)id::integer. do \{ 
%% %   enter?sd:Other_SIDS_to_Waiting \(\to\) (
%% %   ret \(\gets\) \Ret (True, id, fst sd);  
%% %   (\cspkey{iterate} (\(\lambda\)s. fst s) (\(\lambda\)s. do \{ 
%% %     outp entered (snd (snd s), SID_Waiting);
%% %     (({CALL__randomWalk(id); stop}) \(\interrupt\)
%% %       (
%% %       \(\extchoice\)
%% %       ; \Ret (True, fst (snd s), st1)\(\extchoice\) 
%% %       ...; \Ret (False, fst (snd s), _)
%% %       )
%% %     )
%% %     \}) (ret)); 
%% %   \Ret (id))
%% % \})
%% % \end{alltt}
\begin{example}[state]
The process for state \rcitem{Waiting} in \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement} is shown below.
\newcommand{\StateWaiting}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}}
\begin{alltt}
1 State_Waiting = \cspkey{loop} (\(\lambda\)id::integer. \(\StateWaiting\)
2   sd \(\gets\) inp enter \{(s, SID_Waiting) | s. \(\lnot\) s \(\in\) SIDS_Movement_no_Waiting\} ;
3   ret \(\gets\) \Ret (True, fst sd);  
4   (\cspkey{iterate} (\(\lambda\)r. fst r) (\(\lambda\)r. 
5     entered!(snd (snd r), SID_Waiting); (
6     ({CALL__randomWalk(id); stop}) \(\interrupt\) (
7       (resume_!(TID_t0, din) \(\to\) exit!(SID_Waiting, SID_Waiting) \(\to\) 
8        exited!(SID_Waiting, SID_Waiting) \(\to\) enter!(SID_Waiting, SID_Waiting); 
9        \Ret (True, SID_Waiting)) \(\extchoice\)
10      (turn_?(TID_t2, din, a\(\in\)Chemical_Angle) \(\to\) set_a!a \(\to\) 
11       exit!(SID_Waiting, SID_Waiting) \(\to\) exited!(SID_Waiting, SID_Waiting) \(\to\) 
12       enter!(SID_Waiting, SID_Going) \(\to\) entered!(SID_Waiting, SID_Going) ; 
13       \Ret (False, SID_Waiting)) \(\extchoice\) 
14       ...
15  ))) (ret)); \Ret (id)) \qed
\end{alltt}
\end{example}

%% Basically, \isacode{State\_Waiting} is an infinite loop, an ITree, whose state (a state of an ITree is its carried data or its return value) is an integer \isacode{id} (corresponding to the parameter \cspcode{id}), with a nested conditional iteration by \isacode{iterate} (corresponding to \cspcode{S\_exec}). The state of the iteration is a triple such as \isacode{(True, id, fst sd)}, whose first element is a \changed[\C{52}]{Boolean} value to indicate if this iteration terminates or not, whose second element is \isacode{id}, and whose third element is the RoboChart state (for example \isacode{fst sd}, see lines 2 and 3)  that initiates entering of the state \rcitem{Waiting} of \cspcode{S\_exec}. Initially, the state of the iteration is passed from its preceding \isacode{Ret} construct and recorded in a variable \isacode{ret} (also the third argument of \isacode{iterate}, see line 15). 
%% 
%% In the iteration body, \isacode{snd (snd r)} on line 5 is the third element of the tuple \rcitem{r} and is a RoboChart state.
%% \isacode{CALL\_\_randomWalk(id)} on line 6 corresponds to the call to an operation \rcitem{randomWalk} (provided by the robotic platform) in the during-action of \rcitem{Waiting}. Lines 7 to 9 correspond to the self transition \rcitem{t0} of \rcitem{Waiting}, whose trigger is \rcitem{resume}, and lines 10 to 13 correspond to the transition \rcitem{t2} (from \rcitem{Waiting} to \rcitem{Going}) whose trigger is \rcitem{turn?a}. We note that there is no \isacode{entered} event for \rcitem{t0} and the first element in the return value \isacode{\Ret (True, fst (snd r), SID\_Waiting)} is \isacode{True}. This is because \rcitem{t0} is a self-transition and does not need to wait for entering, as shown in line 2. The first element \isacode{True} makes \isacode{iterate} continue its inner iteration, and the third element \isacode{SID\_Waiting} means this is entering from the state \rcitem{Waiting} itself.
%% The transition \rcitem{t2} is different from \rcitem{t0} in that it 
%% \begin{inparaenum}[(1)]
%% \item has an input trigger to get the angle and record it in the local variable \rcitem{a}, as shown on line 10, and 
%% \item will exit \rcitem{Waiting} (on line 11) and enter \rcitem{Going} (on line 12). 
%% \end{inparaenum}
%% The execution of this transition will leave the inner iteration by setting the first element of the return value to \isacode{False} (on line 13).

The semantics of a state $\meta{s}$ also captures the transitions from its sibling states, which have the same parent as $\meta{s}$. These transitions shall be blocked because they are part of the behaviours of its sibling states. This is implemented as the restricted behaviour of \rcitem{s} shown below.
\begin{align*}
    & \meta{restrictedState(s: State, stm:StateMachineDef) = }\\
%    & \quad \isacode{$\lambda$id.} \meta{\semLC{(s: State, stm:StateMachineDef)}{NS}} \parallel_{\meta{allOtherTransitionS(s, stm) \setminus allTransitionsPS(s, stm)}} \cspkey{skip} \\
    & \quad \isacode{$\lambda$id.} \meta{\semLC{(s: State, stm:StateMachineDef)}{NS}}~\isacodebl{$\parallel_{\meta{eventsAllTransFromSiblings(s, stm)}}$ \cspkey{skip}}
\end{align*}
The synchronisation of the semantics of $\meta{s}$ with \cspkey{skip} over a set of events $\meta{eventsAllTransFromSiblings(s, stm)}$ on the transitions that are from the sibling states of $\meta{s}$. These events are blocked in the restricted semantics because of the synchronisation with \cspkey{skip}.

% The restricted behaviour of \rcitem{Waiting} is shown below.
\newcommand{\StateWaitingR}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L}}
% \newcommand{\WaitingRParallelE}{\parallel_{\isacode{{internal\_events - trigger\_events}}}}
% \begin{alltt}
% State_Waiting_R = \(\lambda\)id. State_Waiting(id) \(\WaitingRParallelE\) \cspkey{skip} \(\StateWaitingR\)
% \end{alltt}
% \isacode{State\_Waiting\_R} is a parallel composition of \isacode{State\_Waiting} and a \cspkey{skip} process over a set of events for synchronisation which is the set difference of all internal events \isacode{internal\_event} (including \isacode{e\_} events and \isacode{internal\_} events) and all trigger events \isacode{trigger\_events} of the machine \rcitem{Movement}. The parallel composition with \cspkey{skip} blocks all events in the synchronisation set, leaving all events in \isacode{trigger\_events} to proceed independently.
% We note that for a basic state such as \rcitem{Waiting}, its restricted process will not change its behaviour \isacode{State\_Waiting}. The reason why restricted behaviour is needed is because of composite states. We will deal with it in the future.
%\isacode{Ret (True,fst (snd s),st1)} corresponds to \cspcode{S\_execute(id,st1)} where the iteration continues (\isacode{True}) with the same \isacode{id} (the second element of its state) and a new \isacode{st1} as the state of the next iteration. \isacode{Ret (False,fst (snd s),\_)} corresponds to the call \cspcode{S(id)} in the definition of \cspcode{S\_execute}. The iteration will terminate and return this triple because the first element is \isacode{False}. In this case, the only state carried on is \isacode{id}, and so we represent here \isacode{\_}. This unnecessary state is discarded after the termination of the iteration when the body of the loop returns \isacode{id} only by \isacode{Ret (id)}.

%The behaviour of each state of the \rcitem{Movement} machine is implemented as such a loop.

%The process for a state machine also needs to rename event channels, such as from \isacode{obstacle\_} to \isacode{obstacle}, to forget the extra \isacode{TID} because \isacode{TID} is introduced inside a state machine for the trigger of transitions. To form a renaming relation for forgetting \isacode{TID}, we define several functions in Isabelle.
%
%\newcommand{\mapf}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L94}}
%\newcommand{\mapfc}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L91}}
%\newcommand{\forgettwo}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L150}}
%
% \begin{alltt}
% \isakwmaj{definition} mapf::"('b \(\Rightarrow \)'a) list \(\Rightarrow\) 'b list \(\Rightarrow\) 'a list" \isakwmin{where}
% "mapf fs xs = concat (map (\(\lambda\)f. map f xs) fs" \(\mapf\)
% \isakwmaj{definition} mapfc::"('c\(\cross\)'a\(\Rightarrow\)'b) list\(\Rightarrow\)'c list \(\Rightarrow\)('a\(\Rightarrow\)'b) list"  \(\mapfc\)
% \isakwmin{where} "mapfc fs xs = concat (map (\(\lambda\)f. map f xs) (map curry fs))"
% \isakwmaj{definition} forget_first2::"('e\(\cross\)'a\(\cross\)'b\(\Rightarrow\)'c)\(\Rightarrow\)('a\(\cross\)'b\(\Rightarrow\)'d) 
%   \(\Rightarrow\)'e list \(\Rightarrow\)'a\(\cross\)'b \(\Rightarrow \)'c\(\cross\)'d list" \isakwmin{where} \(\forgettwo\)
% "forget_first2 e_ e xs = 
%   \(\lambda\)(dir, n). mapf [(\(\lambda\) tid. (e_ (tid, dir, n), e (dir,n))] xs"
% \end{alltt} 
% The function \isacode{mapf} applies each function in a list \isacode{fs} of functions to each element of a list \isacode{xs} and has all results concatenated. The function \isacode{mapfc} is similar to \isacode{mapf} except that the domain of each function \isacode{f} in \isacode{fs} is a pair, and then \isacode{f} is converted into a curried version like \isacode{('c\(\Rightarrow\)'a\(\Rightarrow\)'b)} by \isacode{curry}. The function \isacode{mapfc} defines a list of functions. The function \isacode{forget\_first2} defines a list of pairs in which each pair has the first element of \isacode{e\_} ignored when mapped to \isacode{e}.
% As an example, we consider renaming of \isacode{obstacle\_\_Movement} to \isacode{obstacle\_Movement} below.
% \begin{alltt}
% mapf (mapfc [forget_first2 obstacle__Movement_C obstacle_Movement_C 
%   TIDS_Movement_list]) InOut_list Location_Loc_list
% \end{alltt}
% %Here we use a symbol \isacode{c_C} for \isacode{build_c}.
% The result is a list of event maps, such as
% \begin{alltt}
% [(obstacle__Movement_C (TID_Movement_t0, din, Location_Loc_left),
%   obstacle_Movement_C (din, Location_Loc_left)), ...]
% \end{alltt}
% We define \isacode{rename\_Movement\_events} for such event maps for each event channel in \isacode{Chan\_Movement} defines. All other channels that will not be renamed have each event of these channels mapped to itself, defined in \isacode{rename\_Movement\_events\_others}. Finally, the renaming relation of \isacode{Movement} is a set of pairs given below, where \isacode{set} is the set representation of a list.
% \begin{alltt}
% set (rename_Movement_events @ rename_Movement_events_others)
% \end{alltt}
%\sloppy For the implementation of actions of RoboChart in ITrees, we illustrate two examples here. One example is the during action of state \rcitem{Waiting}: an operation call \rcitem{randomWalk()} and its implementation is \isacode{randomWalkCall!()}, an event synchronisation. Another example is an assignment \rcitem{i=intensity(gs)} where \rcitem{i} is a local variable and \rcitem{intensity} is a function described previously. The implementation of this assignment in ITrees is \isacode{pre\_Chemical\_intensity(gs) \(\&\) (set\_i!(Chemical\_intensity(gs)) \(\to \tick\))}, and so if the precondition does not hold this guarded process deadlocks.

The behaviour of multiple states is composed of their restricted behaviours.
\begin{align*}
    &\meta{composeStates(ss: \seq State, stm: StateMachineDef) =} \\    
    & \quad \metanobar{
        \circblockbegin
        \meta{\IF \# ss = 1 \THEN\ }\\ 
        \quad \meta{restrictedState(head~ss, stm)}\\
        \meta{\ELSE\ }\\ 
        \quad \meta{restrictedState(head~ss, stm)} \isacodebl{~$\parallel_{\meta{flowEvents(ss, stm)}}$~} \meta{composeStates(tail~ss, stm)}
        \circblockend
    }
\end{align*}
Here, $\meta{ss}$ is a sequence of states. If there is only one state in the sequence (that is, the length $\meta{\# ss}$ of $\meta{ss}$ is 1), the semantics is just that of the only state (in the $\meta{head}$ of $\meta{ss}$). Otherwise, the semantics is the parallel composition of the behaviour of the $\meta{head}$ state with the composed behaviour $\meta{composeStates(tail~ss, stm)}$ of the $\meta{tail}$ states ($\meta{tail~ss}$, $\meta{ss}$ after its head is removed), synchronised on a set of events $\meta{flowEvents(ss, stm)}$ that are flow channel (\isacodebl{enter}, \isacodebl{entered}, \isacodebl{exit}, and \isacodebl{exited}) events used in the restricted behaviours of all states in $\meta{tail~ss}$ to enter the head state or exit from the head state.

The behaviour of nodes in a state machine is then the composition of the initial junction and that of states.
\begin{align*}
    &\meta{\semLC{stm: StateMachineDef}{N} = }\\ 
    & \quad \meta{\semLC{stm: StateMachineDef}{NI}} \isacodebl{~$\parallel_{\meta{initFlowEvents(stm)}}$~} \meta{composeStates(\langle n:stm.nodes | n \in State \rangle, stm)}
\end{align*}
Here, we use sequence comprehension to construct all states in $\meta{stm}$ in a sequence. The composition synchronises on a set of events $\meta{initFlowEvents(stm)}$ that are flow channel events used to enter the states of $\meta{stm}$ from the initial junction and not from other states.

\begin{example}[nodes]
    The semantics of nodes in \rcitem{GasAnalysis} in Fig.~\ref{fig:robochart_acd_gasanalysis} can be found online \isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_maincontroller.thy\#L659}.
    
\end{example}

\subsubsection{Composition of STM and memory processes}
\label{ssec:semantics_stm:stm_memory}
The semantics of nodes in $\meta{stm}$ is composed with the memory of $\meta{stm}$.
\begin{align*}
    & \meta{MemorySTM(stm:StateMachineDef) =} \\
    & \quad \metanobar{ \left(\left(\meta{\semLC{stm}{N}} \isacodebl{$\hidep$} \meta{allFlowEvents(stm)} \right) \isacodebl{$\parallel_{\meta{\left(varChannelEvents(stm)\cup\, trigEvents(stm)\right)}}$} \meta{\semLC{stm}{Mem}} \right) \isacodebl{$\hidep$} \meta{localVarEvents(stm)}}
\end{align*}
In the semantics, all flow channel events $\meta{allFlowEvents(stm)}$ are hidden from the behaviour of nodes. Then the nodes synchronise with the memory on the union of two sets of events: $\meta{varChannelEvents(stm)}$ for all \isacode{get\_},  \isacode{set\_}, and \isacode{set\_EXT\_} variable channel events, and $\meta{trigEvents(stm)}$ for all trigger events. Subsequently, all local variable channel events $\meta{localVarEvents(stm)}$ are hidden.

%\begin{align*}
%    & \meta{\semLC{stm:StateMachineDef}{STM}} = \\
%    &\quad \metanobar{
%	\circblockbegin
%		\circblockbegin
%            \meta{\semLC{stm: StateMachineDef}{N}} \isacodebl{~$\hide$~} \meta{allFlowEvents(stm)}\\
%            \quad \isacodebl{$\parallel_{\meta{getsetChannels(stm)~\cup~trigEvents(stm)}}$} \\
%            \meta{\semLC{stm}{Mem}}
%		\circblockend\\
%	    \rename \meta{renameTriggerEvents(stm)} \\
%	    \hide \meta{getsetLocalChannels(stm)} \cup \lchan internal \rchan\\
%	    \Theta_{\{end\}} Skip
%	\circblockend}
%\end{align*}
%
%% As sketched in Figs~\ref{fig:robochart_semantics} and~\ref{fig:robochart_acd_semantics}, the semantics of a state machine is the parallel composition of the composed processes for its nodes and its memory.
%% We show below the composed processes for the nodes of the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}.
%% \newcommand{\StateCalR}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}}
%% \begin{alltt}
%% STM_CalSTM = \(\lambda\)id. I_i0(id) |[ flow_events_from_other_states ]| State_cal_R \(\StateWaitingR\)
%% \end{alltt}
%% The composed process \isacode{STM\_CalSTM} (called the node process) is a parallel composition of the process \isacode{I\_i0} for the initial junction and the restricted process \isacode{State\_cal\_R} for the state \isacode{cal} over all the flow events \isacode{flow\_events\_from\_other\_states} that enter \rcitem{cal} from other states.
%% 
%% Then, the node process of a state machine is composed in parallel with the machine's memory with proper event hiding. The definitions of such composition (the node memory process) are omitted here for simplicity. They can be found online (\isacode{MemorySTM\_Movement} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988} for the machine \rcitem{Movement} and \isacode{MemorySTM\_CalSTM} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988} for the machine \rcitem{CalSTM}). We note that in such a process, the \isacode{internal} events used for synchronisation between the node process and the memory, the \isacode{get} events of all variables, and the \isacode{set} events of all local variables are hidden because these events are used to synchronise between the node process and the memory and are internal. The \isacode{set} events of shared variables are not hidden because the update to shared variables by the \isacode{set} events needs to be propagated to other state machines.

As discussed previously \changed[\C{65}]{in Sect.~\ref{ssec:semantics_stm:gen_def}}, each event \rcitem{e} of a state machine has two corresponding event channels \isacode{e\_} (for triggers) and \isacode{e} (for actions) in the semantics of the machines, such as \isacode{obstacle\_} and \isacode{obstacle} for the event \rcitem{obstacle} of the machine \rcitem{Movement}. Trigger event channels \isacode{e\_} in $\meta{MemorySTM(stm)}$ are renamed to \isacode{e} by forgetting the first element (a transition identifier) of the value carried on \isacode{e\_}. 
%
\begin{align*}
%    & \meta{MemorySTM\_renamed(stm:StateMachineDef) =~}\isacode{$\rename{\meta{MemorySTM(stm)}}{\meta{event\_map}}$} \\
    & \meta{MemorySTM\_renamedp(stm:StateMachineDef) =~}\isacode{$\renamep{\meta{MemorySTM(stm)}}{\meta{triggerMap(stm)}}$}
\end{align*}
Here, we use the renaming operator with priority to avoid nondeterminism. The renaming mapping list $\meta{triggerMap(stm)}$ includes the mappings for renaming and also the mappings whose names are not changed.

\begin{example}[rename]
We show the renaming of the state machine \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol}.
\newcommand{\RenamedpMemorySTMMoveSTM}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1028}}
\begin{alltt}
MemorySTM\_renamedp = \(\renamep{\isacode{MemorySTM\_MoveSTM }}{\isacode{event\_map\_list}}\) \(\RenamedpMemorySTMMoveSTM\)
\end{alltt}

The \isacode{event\_map\_list} contains the mappings like \isacode{(update\_.(TID\_t1, din, v), update.(din, v))} and \isacode{(update\_.(TID\_t3, din, v), update.(din, v))} where \isacode{v} is an integer number. This renaming gives priority to the event at the front of the list. If \isacode{(update\_.(TID\_t3, din, v), update.(din, v))} is after \isacode{(update\_.(TID\_t1, din, v), update.(din, v))}, then \rcitem{t1} has a priority and so the nondeterminism is resolved. This corresponds to moving towards only one direction (to the left) when the robot is in Section S2 in Fig.~\ref{fig:robochart_patrol_sections} instead of the nondeterministic choice of two directions. If we change the order of the two mappings, then \rcitem{t3} will have a priority, and the direction of the movement to the right will be chosen. In our example, \isacode{event\_map\_list} is arranged based on the order in which the transitions are created. \qed
\end{example}

% For example, \isacode{MemorySTM\_Movement} is renamed according to a renaming relation \isacode{event\_map}.
% %
% \newcommand{\RenamedMemorySTMMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L2051}}
% \begin{alltt}
% Renamed_MemorySTM_Movement = \(\rename{\isacode{MemorySTM\_Movement }}{\isacode{event\_map}}\) \(\RenamedMemorySTMMovement\)
% \end{alltt}
% %
% The \isacode{event\_map} contains the mappings not only for the trigger events like \isacode{(obstacle\_.(TID\_t6, din, Loc\_left), obstacle.(din, Loc\_left))} but also for other event channels (events for actions, \isacode{terminate}, shared variable channels \isacode{set} and \isacode{set\_EXT}, and operation call) that will not be renamed like \isacode{(obstacle.(din, Loc\_left), obstacle.(din, Loc\_left))} and \isacode{(terminate.(), terminate.())} because the renaming relation is total.
% 
% Renaming may result in nondeterminism in the RoboChart semantics, which our renaming operator excludes. For example, the renaming of \isacode{MemorySTM\_MoveSTM} for the state machine \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol} blocks both self transitions of the state \rcitem{move} that have an input trigger \rcitem{update?l}.
% %
% \newcommand{\RenamedMemorySTMMoveSTM}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1020}}
% \begin{alltt}
% Renamed_MemorySTM_MoveSTM = \(\rename{\isacode{MemorySTM\_MoveSTM }}{\isacode{event\_map}}\) \(\RenamedMemorySTMMoveSTM\)
% \end{alltt}
% %
% The \isacode{event\_map} contains the mappings like \isacode{(update\_.(TID\_t1, din, v), update.(din, v))} and \isacode{(update\_. (TID\_t3, din, v), update.(din, v))} where \isacode{v} is a literal integer number in \isacode{core\_int}.
% For \isacode{v} that is between \isacode{-MAX} and \isacode{MAX}, the two events \isacode{update\_.(TID\_t1, din, v)} and \isacode{update\_.(TID\_t3, din, v)} are both enabled for communication (see the definition of \isacode{MoveSTM\_MemoryTrans} where both predicates in the two set comprehensions are satisfied), and they are mapped to the same event \isacode{update.(din, v)} in this relation. According to the definition of renaming in Sect.~\ref{ssec:itree_renaming}, both events are blocked, so the state \rcitem{move} cannot take the two self-transitions. This problem can be solved by renaming with priority defined in Sect.~\ref{ssec:itree_renaming_with_priority}.
% %
% \newcommand{\RenamedpMemorySTMMoveSTM}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1028}}
% \begin{alltt}
% Renamedp_MemorySTM_MoveSTM = \(\renamep{\isacode{MemorySTM\_MoveSTM }}{\isacode{event\_map\_list}}\) \(\RenamedpMemorySTMMoveSTM\)
% \end{alltt}
% %
% The \isacode{event\_map\_list} has the same mappings as \isacode{event\_map}, but it is a list (and so the mappings are ordered) instead of a relation. This renaming gives priority to the event at the front of the list. If \isacode{(update\_.(TID\_t3, din, v), update.(din, v))} is after \isacode{(update\_.(TID\_t1, din, v), update.(din, v))}, then \rcitem{t1} has a priority and so the nondeterminism is resolved. This corresponds to moving towards only one direction (to the left) when the robot is in Section S2 in Fig.~\ref{fig:robochart_patrol_sections}, instead of the nondeterministic choice of two directions. If we change the order of the two mappings, then \rcitem{t3} will have a priority, and the direction of the movement to the right will be chosen.

The semantics of a state machine also needs to take its termination (for example, the final state is reached) into consideration. 
\begin{align*}
    & \meta{\semLC{stm:StateMachineDef}{STM}} = \\ 
    % &\quad \metanobar{\left(\except{\meta{MemorySTM\_renamedp(stm)}}{\{\isacode{terminate.()}\}}{\cspkey{skip}}\right)} \isacodebl{$\hidep$} \meta{internalEvents(stm)} 
    &\quad \metanobar{\left(
        {{{\meta{MemorySTM\_renamedp(stm)}}
        ~\isacodebl{$\lbrack\mkern-3mu\lbrack$}
        {\isacodebl{\{terminate.()\}}}
        \isacodebl{$\rres$} 
        \isacodebl{\cspkey{skip}}}}
    \right)} \isacodebl{$\hidep$} \meta{internalEvents(stm)} 
\end{align*}
Based on the definition of the exception operator, if $\meta{MemorySTM\_renamedp(stm)}$ ever performs a \isacode{terminate} event, then \cspkey{skip} will take over, and so the process terminates. The process also hides all \isacode{internal} events and flow control events, defined in $\meta{internalEvents(stm)}$.

%This is shown in the process for \rcitem{MoveSTM} below. 
%%
%\newcommand{\DMoveSTMp}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1056}}
%\begin{alltt}
%D\_MoveSTM = (\(\except{\isacode{Renamedp\_MemorySTM\_MoveSTM}}{\{\isacode{terminate.()}\}}{\cspkey{skip}}\)) \(\hide\) internal_events \(\DMoveSTMp\)
%\end{alltt}
%%
%Based on the definition of the exception operator, if \isacode{Renamedp\_MemorySTM\_MoveSTM} ever performs a \isacode{terminate} event, then \cspkey{skip} will take over, and so the process terminates. The process also hides all \isacode{internal} events and flow control events, defined in \isacode{internal\_events}.

%% \subsubsection{Nondeterminism}
%% Nondeterminism in RoboChart (excluding during actions and composite states):
%% \begin{itemize}
%%     \item Within state machines 
%%         \begin{itemize}
%%             \item More than two transitions from a state are enabled at the same time, and they must have overlapped guards,
%%                 \begin{itemize}
%%                     \item they have the same trigger (external events or events to and from RP). In this case, nondeterminism is introduced by renaming \verb+e.t1.v1+ and \verb+e.t2.v2+ to \verb+e.v1+ and \verb+e.v2+ respectively by removing the first TID; or 
%%                     \item they have the same trigger (internal independent events of machines, without connections to other state machines). In this case, nondeterminism is introduced by renaming \verb+e.t1.v1+ and \verb+e.t2.v2+ to \verb+e.v1+ and \verb+e.v2+ respectively by removing the first TID, then possibly hiding or 
%%                     \item they have no triggers or the same \verb+internal__+ trigger. In this case, nondeterminism is introduced by hiding \verb+internal__.t1+; should hide a list of events or
%%                     \item they have different triggers, but these triggers are internal. Nondeterminism is introduced by hiding events. 
%%                 \end{itemize}
%%             \item Interleaving behaviours between state machines,
%%         \end{itemize}
%%     \item Inter-machines (within a controller)
%%     \item Inter-machines (within a module or different controllers)
%% \end{itemize}

\subsection{Operations}
\label{ssec:semantics_operation}

Operations in RoboChart can be provided by robotic platforms such as \rcitem{move} and \rcitem{randomWalk} in Fig.~\ref{fig:robochart_acd_module} or defined by state machines such as \rcitem{changeDirection} in Fig.~\ref{fig:robochart_acd_location}.

The semantics of a call (an action) to an operation provided by a robotic platform is an event to record the call with appropriate arguments. 
\begin{align*}
    & \meta{\semLC{s: Call}{A} = s.operation.name}\isacodebl{Call!(}\meta{\langle a:s.args @ \semL{a}{e}, \rangle} \isacodebl{) $\to \cspkey{skip}$ }
\end{align*}
Here, $\meta{s.operation.name}$\isacodebl{Call} is the corresponding channel name to the operation $\meta{s.operation.name}$ which $s$ calls. The call arguments $\meta{s.args}$ become a tuple composed of corresponding arguments $\meta{\semL{a}{e}}$ for each argument $\meta{a}$.

% For example, the semantics of \rcitem{move(lv,a)}, the entry action of the state \rcitem{Going} in Fig.~\ref{fig:robochart_acd_movement}, is \isacode{get\_a?a $\to$ moveCall!(const\_lv, a) $\to \subscriptIntt{\tick}{}$} where the message on the channel \isacode{moveCall} contains the value \isacode{const\_lv} of the constant variable \rcitem{lv} and the value of the local variable \rcitem{a}, retrieved from the memory through \isacode{get\_a}.

%In general, the semantics of a state machine-defined operation is similar to that of a state machine in that both are the composition of node and memory processes. 
The semantics of a state machine-defined operation differs from that of a state machine because an operation is not an independent execution element like a state machine. Its behaviour is within the scope of the state machine that calls the operation. 
For this reason, the semantics of the operation does not include a separate channel type (or an event alphabet) and does not have a separate memory. Instead, all channels required for the operation are declared along with the channels for the caller state machine in a channel-type declaration. However, the semantics of an operation's nodes, transitions, and memory are the same as those in a state machine.
 We omit the semantics of operations for simplicity. Instead, we illustrate it with an example below.

 \begin{example}[operation]
The channel type \isacode{Chan\_Movement} of \rcitem{Movement} has the following additional channels for the operation \rcitem{changeDirection}.
%
\newcommand{\ChanMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L227}}
 \begin{alltt} 
\isakwmaj{chantype} Chan_Movement =   \(\ChanMovement\)
  ...
  internal_changeDirection :: TIDS_changeDirection
  enter_changeDirection    :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  entered_changeDirection  :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  exit_changeDirection     :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  exited_changeDirection   :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  terminate_changeDirection:: unit
  get_l_changeDirection    :: "Location_Loc"
  set_l_changeDirection    :: "Location_Loc"
\end{alltt}
The \isacode{get\_l} and \isacode{set\_l} channels are for the parameter \rcitem{l} of the operation and not for a local variable \rcitem{l} (indeed, there is no such local variable). Different from local variables, \rcitem{l} is only set once (\isacode{set\_l}) by the caller of the operation for passing its value, not inside the operation like local variables. The call \rcitem{changeDirection(l)} to the operation in the entry action of the state \rcitem{Avoiding} has its semantics in CSP as follows.

\newcommand{\CallChangeDirectionMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L670}}
\begin{alltt}
CALL__changeDirection_Movement = \(\CallChangeDirectionMovement\)
  {get_l_Movement?l \(\to\) set_l_changeDirection!l \(\to\) \(\subscriptIntt{\tick}{}\); D_changeDirection \(\changed[\C{66}]{}\)} 
\end{alltt}
The first input event gets the value of the local variable \rcitem{l} of \rcitem{Movement}, and the value is recorded in \isacode{l}. The second event updates the value of the parameter \rcitem{l} (in the memory) of \rcitem{changeDirection} to \isacode{l}. Finally, the process for this call behaves as the process \isacode{D\_changeDirection} (for \rcitem{changeDirection}). 
%We note that the process \isacode{D\_changeDirection} is not similar to the process \isacode{D\_MoveSTM} to have a composition of the node process and the memory process of the machine. \isacode{D\_changeDirection} is a node process with appropriate event hiding and termination. The memory of \rcitem{changeDirection} is part of the memory of \rcitem{Movement}. So it is composed in parallel with the node process of \rcitem{Movement} like the memory of \rcitem{Movement}.
\qed
 \end{example}

% The semantics of an operation differ regarding how behaviour and memory processes are composed or used. Its memory is part of the memory of the state machine that calls the operation, so its memory processes are composed in parallel with those of the caller state machine. Its behaviour process is part of the calls (actions in RoboChart) to this operation. For this reason, the channel type of a state machine such as \isacode{Chan\_Movement} also contains flow control and variable channels for the  \rcitem{changeDirection} operation. We note there are no event and operation call channels like those for state machines because the caller state machine must require events and operations used in a defined operation, so those channels are declared with the semantics of the state machine.
%  
% We also note that the values passed to an operation from its caller through parameters are simulated using extra parameter variables  (one for each parameter) in its memory for exchange. For example, the process for \rcitem{changeDirection} contains a variable \isacode{l} in its memory. Then, the call \rcitem{changeDirection(l)} to this operation is implemented as a function shown below.
% %
% \begin{alltt}
% CALL__changeDirection_Movement id l = do \{
%   outp set_l_changeDirection l; D__changeDirection id\}
% \end{alltt}
% %
% Here, a parameter variable in the memory is updated to the value of \isacode{l} by channel \isacode{set\_l\_changeDirection}, and \isacode{D\_\_changeDirection} is the process for the operation which contains the state machine behaviour and termination of the operation, but no memory processes. The memory for this parameter variable is set only upon a call to this operation and not by the processes for this operation, which implements passing by value.

% How to access local and shared variables provided by its containing state machine.

\subsection{Controllers}
\label{ssec:semantics_ctrl}
%\paragraph*{Controllers.}
%{
%\subsubsection{Memory}
%\subsubsection{Channels}
%\subsubsection{Composition of state machines with its memory}
%}

The event alphabet of the process for a controller  % is also declared using the \isakwmaj{chantype} command, 
contains a termination, shared variable, event, and operation call channels. The event channels include not only the events of the controller but also those in connections between its state machines. 
%
\begin{align*}
    & \meta{channelsOfCTRL(c:ControllerDef) = }\\
    & \quad \isacode{\isakwmaj{chantype} Chan}\isacode{ = terminate::unit } \\
    %& \quad\ \ \meta{\bigcup \left\{v : allLocalVariables(c) @ \left\{\right.\right.}
    %     \isacode{get\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},}
    %     \isacode{set\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t}\left.\right\},\left.\right\}} \\
    & \quad\ \ \meta{\bigcup }\metanobar{\left\{
    \begin{array}[]{@{}l}
            \meta{v : allLocalVariables(c) @} \\
            \metanobar{\meta{\bigcup}\left\{
    \begin{array}[]{@{}l}
        \meta{\left\{\right.}\isacodebl{get\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},\ } \isacodebl{set\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t}\ } \meta{\left.\right\},}\\
         \meta{\left\{s:c.machines|v \in requiredVariables(s) @\right.}\isacodebl{set\_EXT\_}\meta{s.name}\isacodebl{\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},\left.\right\}}
    \end{array}\right\}}, 
    \end{array}\right\}} \\
    & \quad\ \ \meta{\bigcup }\metanobar{\left\{
    \begin{array}[]{@{}l}
            \meta{v : requiredVariables(c) @} \\
            \metanobar{\meta{\bigcup}\left\{
    \begin{array}[]{@{}l}
        \meta{\left\{\right.}\isacodebl{get\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},\ } \isacodebl{set\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},\ } 
         \isacodebl{set\_EXT\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t}\left.\right\},}\\
         \meta{\left\{s:c.machines|v \in requiredVariables(s) @\right.}\isacodebl{set\_EXT\_}\meta{s.name}\isacodebl{\_}\meta{v.name}\isacode{::}\meta{\semL{v.type}{t},\left.\right\}}
    \end{array}\right\}}, 
    \end{array}\right\}} \\
    & \quad\ \ \metanobar{\left\{\meta{e : allEvents(c) @ e.name}\isacodebl{::InOut$\cross$}\meta{\semL{e.type}{t}} , \right\}} \\
    & \quad\ \ \metanobar{\left\{\meta{e : internalEvents(c) @ e.name}\isacodebl{::InOut$\cross$}\meta{\semL{e.type}{t}} , \right\}} \\
    & \quad\ \ \meta{\left\{op : requiredOperations(c) @ \right.}
    \meta{op.name}\isacodebl{Call::}\meta{\langle p : op.parameters @ \semL{p.type}{t},}\isacodebl{$\cross$}\meta{\rangle} \meta{,\left.\right\}}
\end{align*}
The channel type for a controller includes channels for termination, local variables, shared variables, events, and operations. Different from those for a state machine, for each local or shared variable $\meta{v}$ a controller $\meta{c}$, additionally, declares a \isacodebl{set\_EXT\_}$\meta{s.name}$\isacode{\_}$\meta{v.name}$ channel for each state machine $\meta{s}$ of $\meta{c}$ that requires $\meta{v}$. These channels propagate the update of $\meta{v}$ to all state machines that require $\meta{v}$. 

In addition to event channels for all events, $\meta{allEvents{c}}$ of $\meta{c}$,  an event channel for each event $\meta{e}$ of all internal events (that is, the events that are used in connections between state machines) is also declared. These channels are used for communication between state machines.

\begin{example}[controller channel type]
The channel type of the controller \rcitem{Ctrl} in Fig.~\ref{fig:robochart_patrol} is defined below. 
\newcommand{\ChanCtrl}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1071}}
\begin{alltt}
\isakwmaj{chantype} Chan_Ctrl = \(\ChanCtrl\)
  terminate_Ctrl         :: unit 
  set_x_Ctrl             :: core_int
  get_x_Ctrl             :: core_int
  set_EXT_x_Ctrl         :: core_int
  set_EXT_x_Ctrl_CalSTM  :: core_int
  set_EXT_x_Ctrl_MoveSTM :: core_int
  rec_Ctrl               :: "InOut\(\cross\)core_int"
  reset_Ctrl             :: "InOut"
  update_Ctrl            :: "InOut\(\cross\)core_int" \(\hfill\)\qed
\end{alltt}
\end{example}

%This channel type includes a \isacode{terminate} channel, two \isacode{get} and \isacode{set} channels for the required shared variable \rcitem{x}, three \isacode{set\_EXT} channels for accepting the update of \rcitem{x} (through \isacode{set\_EXT\_x\_Ctrl}) and then propagating the update to the state machines of the controller that require \rcitem{x}: \rcitem{CalSTM} and \rcitem{MoveSTM} (through \isacode{set\_EXT\_x\_Ctrl\_CalSTM} and \isacode{set\_EXT\_x\_Ctrl\_MoveSTM}), and three event channels. The event channels are not only for the events \rcitem{rec} and \rcitem{reset} of \rcitem{Ctrl}   but also for the event \rcitem{update} that is used for communication between the two state machines.
The memory of a controller deals with the update of its local and shared variables, but not transitions like that of a state machine.
\begin{align*}
    & \meta{memSharedVarCtrl(s: Variable, c: ControllerDef) = }\\
    & \quad \isacode{\cspkey{loop}} 
        \circblockbegin
    \isacodebl{$\lambda v$.} \isacode{set\_EXT\_}\meta{s.name}\isacode{?x} \isacode{$\to$}  \\
    \quad \metanobar{\left(\isacodebl{$\fatsemi$ }\meta{m: \left\{m: c.machines | s\in requiredVariables(m)\right\} @ }\isacodebl{set\_EXT\_}\meta{m.name}\isacodebl{\_}\meta{s.name}\isacodebl{!x$\to$\cspkey{skip}}\right)}
    %\isacode{$\to\subscriptIntt{\tick}{x}$)} 
        \circblockend \\
    & \meta{memLocalVarCtrl(l: Variable, c: ControllerDef) = } \isacode{ \cspkey{loop}} \\ 
    & \ \ \left(\begin{array}{@{}l}
    \isacodebl{$\lambda v$.} \\
    \ \metanobar{
        \left(\begin{array}{@{}l}
        \isacode{(set\_}\meta{l.name}\isacodebl{?x} \isacodebl{$\to$} \\
        \left(\isacodebl{$\fatsemi$ }\meta{m: \left\{m: c.machines | l\in requiredVariables(m)\right\} @ }\isacodebl{set\_EXT\_}\meta{m.name}\isacodebl{\_}\meta{l.name}\isacodebl{!x$\to$\cspkey{skip}}\right)
        \isacodebl{;$\subscriptIntt{\tick}{x}$)} 
        \end{array}\hspace*{-.5em}\right)
        } \\
    \ \extchoice \isacode{get\_}\meta{l.name}\isacode{!v $\to\subscriptIntt{\tick}{v}$}
    %\isacode{$\to\subscriptIntt{\tick}{x}$)} 
    \end{array}\hspace*{-.5em}\right)
        \\
    %& \meta{memLocalVarCtrl(l: Variable, c: ControllerDef) = } 
    %    \isacode{ \cspkey{loop} ($\lambda v$.} 
    %    \isacode{get\_}\meta{l.name}\isacode{!v $\to\subscriptIntt{\tick}{v} \extchoice$}
    %    \isacode{ set\_}\meta{l.name}\isacode{?x}\isacode{$\to\subscriptIntt{\tick}{x}$)} \\
    & \meta{\semLC{c: ControllerDef}{Mem} = }\\
    & \quad \metanobar{
        \circblockbegin
        \left(\isacodebl{$\Extchoice$}\meta{v : allLocalVariables(c) @ memLocalVarCtrl(v)}\right) \isacodebl{$\extchoice$} \\
        \left(\isacodebl{$\Extchoice$}\meta{v : requiredVariables(c) @ memSharedVarCtrl(v,c)}\right) \\
        % \left(\isacodebl{$\Extchoice$}\meta{tr : allTransitions(stm) @ memTransition(rt)}\right)
        \circblockend
    }
\end{align*}
The memory $\meta{memSharedVarCtrl(s, c)}$ of a shared variable $\meta{s}$ in a controller $\meta{c}$ is an infinite loop. It accepts an update of $\meta{s}$ on channel \isacodebl{set\_EXT\_}$\meta{s.name}$ and then propagates the updated value $x$ to the state machines that require $\meta{s}$ through the corresponding channels, using a replicated sequential composition \isacode{$\fatsemi$}. The memory $\meta{memLocalVarCtrl(l, c)}$ of a local variable $\meta{l}$ also offers an update of $\meta{l}$ but on a different channel \isacodebl{set\_}$\meta{l.name}$, then propagates the update. Additionally, it offers access to the value of $\meta{l}$ through channel \isacodebl{get\_}$\meta{l.name}$. We also note that the loop state $v$ of $\meta{memSharedVarCtrl(s,c)}$ is dummy (that is, not used and updated) because $\meta{c}$ does not store the value of a shared variable, but the loop state $v$ of $\meta{memLocalVarCtrl(l,c)}$ is usual (for update and access).

%in a controller $\meta{c}$ is an infinite loop. It accepts an update of $\meta{v}$ on channel \isacodebl{set\_EXT\_}$\meta{v.name}$ and then propagates the updated value $x$ to the state machines that require $\meta{v}$ through the corresponding channels, using a replicated sequential composition \isacode{$\fatsemi$}. 

The memory $\meta{\semLC{c}{Mem}}$ of a controller $\meta{c}$ offers an external choice for the memories of all the local variables $\meta{allLocalVariables(c)}$, and all the shared variables $\meta{requiredVariables(c)}$.

\begin{example}[controller memory]
The memory of \rcitem{Ctrl} in Fig.~\ref{fig:robochart_patrol} is shown below. 
\newcommand{\CtrlMemory}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1104}}
\begin{alltt}
Memory_Ctrl = \cspkey{loop} (\(\lambda\)id. \(\CtrlMemory\)
    set_EXT_x_Ctrl?x \(\to\) set_EXT_x_Ctrl_CalSTM!x \(\to\) set_EXT_x_Ctrl_MoveSTM!x \(\to\) \(\subscriptIntt{\tick}{id}\)) \(\hfill\) \qed
\end{alltt}
% This process accepts an update to \rcitem{x} through an input event and propagates it to \rcitem{CalSTM} and \rcitem{MoveSTM} through two output events.
\end{example}

Each state machine in a controller has a different event alphabet or channel type. To compose state machines, their event alphabets must be transformed into the same channel type for the controller. We use renaming defined in Sect.~\ref{sec:itree} to achieve it.
%
\begin{align*}
    & \meta{STM\_renamedp(stm:StateMachineDef, c: ControllerDef) =~}\isacode{$\renamep{\meta{\left(\semLC{stm}{STM}\right)}}{\meta{stm2CtrlMap(stm,c)}}$}
\end{align*}
We use renaming with priority to resolve potential nondeterminism introduced from the renaming mapping list $\meta{stm2CtrlMap(stm,c)}$. This list contains event mappings between $\meta{stm}$ and $\meta{c}$ for the \isacode{terminate} channel, (local and shared) variable channels, event channels, and operation call channels. Additionally, it includes event channels that are used for internal communication between state machines, such as the \rcitem{update} event between \rcitem{CalSTM} and \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol}.

\begin{example}[state machine renaming]
    The renaming list for \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol} can be found online \isaref{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1118}.
    \qed
\end{example}

Renamed state machines are composed together using parallel composition.
\begin{align*}
    &\meta{composeMachines(ms: \seq StateMachineDef, c: Controllers) =} \\    
    & \quad \metanobar{
        \circblockbegin
        \meta{\IF \# ss = 1 \THEN\ }\\ 
        \quad \meta{STM\_renamedp(head~ms, c)}\\
        \meta{\ELSE\ }\\ 
        \quad \meta{STM\_renamedp(head~ms, c)} \isacodebl{~$\parallel_{\meta{connEvents(ms, c)}}$~} \meta{composeMachines(tail~ms, c)}
        \circblockend
    }
\end{align*}
Here, $\meta{ms}$ is a sequence of state machines. If there is only one machine in the sequence, the semantics is just that of the only machine (in the $\meta{head}$ of $\meta{ms}$). Otherwise, the semantics is the parallel composition of the behaviour of the $\meta{head}$ machine with the composed behaviour $\meta{composeMachines(tail~ms, c)}$ of the $\meta{tail}$ machines, synchronised on a set of events $\meta{connEvents(ms, c)}$ which includes the \isacode{terminate} channel and event channels used in all machines in $\meta{tail~ms}$ to communicate with the head machine. 

The events for internal communication between state machines are hidden.
\begin{align*}
    \meta{hiddenMachines(c) = composeMachines(\langle m: c.machine @ m\rangle, c)} \isacode{$\hidep$ } \meta{intConnEvents(c)}
\end{align*}
Here, $\meta{intConnEvents(c)}$ defines a set of events used for internal communication between state machines in $\meta{c}$.

The semantics of a controller is the parallel composition of that of its composed machines with its memory and also deals with its termination. 
\begin{align*}
    %& \meta{MemoryCTRL(c:ControllerDef) = } \metanobar{\left(\meta{hiddenMachines(c)} \isacodebl{ $\parallel_{\meta{ctrlMemEvents(c)}}$ } \meta{\semLC{c}{Mem}}\right) \isacodebl{$\hidep$ } ctrlMemEvents(c)}\\
    & \meta{\semLC{c:ControllerDef}{C}} = \\ 
    &\quad \metanobar{
        {\left(\left(\meta{hiddenMachines(c)} \isacodebl{ $\parallel_{\meta{ctrlMemEvents(c)}}$ } \meta{\semLC{c}{Mem}}\right) \isacodebl{$\hidep$ } ctrlMemEvents(c)\right)}
        ~\isacodebl{$\lbrack\mkern-3mu\lbrack$}
        {\isacodebl{\{terminate.()\}}}
        \isacodebl{$\rres$} 
        \isacodebl{\cspkey{skip}}
    }
    % &\quad \metanobar{\except{\left(\left(\meta{hiddenMachines(c)} \isacodebl{ $\parallel_{\meta{ctrlMemEvents(c)}}$ } \meta{\semLC{c}{Mem}}\right) \isacodebl{$\hidep$ } ctrlMemEvents(c)\right)}{\{\isacode{terminate.()}\}}{\cspkey{skip}}}
\end{align*}
The $\meta{ctrlMemEvents(c)}$ is a set of variable channel events in $\meta{c}$ used to access, update, and propagate variables.

\begin{example}[controller]
    The semantics of \rcitem{Ctrl} in Fig.~\ref{fig:robochart_patrol} can be found online \isaref{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1190}. \qed
\end{example}
% Parallel composition of the heterogeneous state machine processes (\rcitem{D\_CalSTM} and \rcitem{D\_MoveSTM}, for example, have different event alphabets) for a controller requires they all share a common event type $E$, and so we rename them. The events of the state machines are renamed to the corresponding events in the controller alphabet according to the connections between the controller and its state machines. For example, \rcitem{D\_CalSTM} is renamed based on a renaming relation that maps the events of \rcitem{D\_CalSTM} to the events of \rcitem{D\_Ctrl}, such as \isacode{(set\_x\_CalSTM.v, set\_x\_Ctrl.v)} and \isacode{(update\_CalSTM.(dout, v), update\_Ctrl.(dout, v))}. \rcitem{D\_MoveSTM} is similarly renamed but its renaming relation contains a mapping \isacode{(update\_MoveSTM.(din, v), update\_Ctrl.(dout, v))} with opposite directions \isacode{din} and \isacode{dout}. Finally, both \isacode{update\_CalSTM.(dout, v)} and \isacode{update\_MoveSTM.(din, v)} are renamed to the same event \isacode{update\_Ctrl.(dout, v)}, which allows the two state machines to communicate on the channel \isacode{update} through parallel composition according to the directions (\rcitem{CalSTM} uses it for output and \rcitem{MoveSTM} uses it for input) of the event \rcitem{update} in the connection between the state machines.

% The semantics of a controller is a parallel composition of the composed state machine processes and its memory with appropriate event hiding and termination. The process for \rcitem{Ctrl} is given as follows.
% \newcommand{\DCtrl}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1179}}
% \newcommand{\CtrlParallelE}{\parallel_{\isacode{stms\_events}}}
% \newcommand{\CtrlMemParallelE}{\parallel_{\isacode{mem\_events}}}
% %
% \begin{alltt}
% 1 D_Ctrl = ((((\(\rename{\isacode{D\_CalSTM }}{\isacode{CalSTM\_events\_map}}\) \(\DCtrl\)
% 2              \(\CtrlParallelE\) 
% 3              \(\rename{\isacode{D\_MoveSTM }}{\isacode{MoveSTM\_events\_map}}\)
% 4             ) \(\hide\) (stms\_events - \{terminate_Ctrl.()\})
% 5            ) \(\CtrlMemParallelE\) Memory_Ctrl
% 6           ) \(\hide\) mem_events
% 7          ) \(\except{\isacode{}}{\{\isacode{terminate_Ctrl.()}\}}{\cspkey{skip}}\)
% \end{alltt}
% The parallel composition of the two state machines of \rcitem{Ctrl} is defined on lines 1 to 3, where the events of the two machine processes (\isacode{D\_CalSTM} and \isacode{D\_MoveSTM}) are renamed to those of \isacode{Ctrl} and \isacode{smts\_events} are a set of events including the termination event \isacode{terminate\_Ctrl} and the events \isacode{update.(dout,v)} used for communication between the machines. The events used for communication are then hidden on line 4. The process after hiding is then composed in parallel with the memory of \rcitem{Ctrl} on line 5 where \isacode{mem\_event} is a set of variable events used for propagating the update of shared variables to the state machines, including \isacode{set\_EXT\_x\_Ctrl\_CalSTM.v} and \isacode{set\_EXT\_x\_Ctrl\_MoveSTM.v}. These events are also hidden on line 6. Finally, the exception on line 7 deals with the termination of \rcitem{Ctrl}. 
% %
%For \rcitem{MicroController} in Fig.~\ref{fig:robochart_acd_module}, the \isacode{terminate} channel, the event channels, and the operation call channels of the process for \rcitem{Movement} are mapped to the corresponding controller channels. 
% \begin{alltt}
%     Renamed_D_CalSTM = \(\rename{D_CalSTM }{\{(terminate_CalSTM, terminate_Ctrl)\}}\) 
% \end{alltt}

% In particular, for a connection \rcitem{c} from an event \rcitem{e} of a state machine \rcitem{stm1} to an event \rcitem{e} of another state machine \rcitem{stm2} of a controller, we declare a channel \isacode{e\_ctrl} in the event alphabet of the controller. The channel in the process for  \rcitem{stm1} is renamed to that of the controller with the same direction \isacode{dout}. Then, the channel in the process for \rcitem{stm2} is renamed to that of the controller but with the opposite direction (\isacode{din} to \isacode{dout}). Finally, the processes (\isacode{D\_stm1} and \isacode{D\_stm2}) for both \rcitem{stm1} and \rcitem{stm2} synchronise on the channels of the controller with direction \isacode{dout}, which is sketched below.
% \newcommand{\parallelE}{\parallel_{\isacode{\{e\_ctrl dout, ...\}}}}
% %
% \begin{alltt}
%   D__stm1\([\![\)\{(e_stm1 dout, e_ctrl dout),...\}\(]\!]\)
%     \(\parallelE\)
%   D__stm2\([\![\)\{(e_stm2 din, e_ctrl dout),...\}\(]\!]\)
% \end{alltt}
%     %\(\parallel\)\(\Searrow\)\{e_ctrl dout, ...\} \(\Swarrow\)
% %
% Here $\parallel_E$ is parallel composition over event synchronisation set $E$. In this way, the output of \rcitem{e} in \rcitem{stm1} synchronises with the input of \rcitem{e} in \rcitem{stm2}, which is the semantics of connection \rcitem{c}.

\subsection{Modules}
\label{ssec:semantics_module}
%\paragraph*{Modules.}

Similar to the event alphabet of the process for a controller, the process for a module also contains a termination channel, shared variable channels, event channels, and operation call channels. The event channels include the events of its platform and the events in connections between its controllers for the same reason. 

The process for a module is a parallel composition of the renamed processes for its controllers, memory processes, and buffer processes for asynchronous connections between its controllers, such as the connection on event \rcitem{turn} from \rcitem{MainController} to \rcitem{MicroController} in Fig.~\ref{fig:robochart_acd_module}. 
The semantics for an asynchronous connection is a one-place buffer.
\begin{align*}
    & \meta{singleBuffer(efrom: Event, eto: Event) = } \\ 
    & \quad \isacode{\cspkey{loop}} 
        \circblockbegin
            \isacodebl{$\lambda lv$.} 
            \circblockbegin
                \circblockbegin
                    \isacodebl{guard (length lv $\geq$ 0 $\land$ length lv $\leq$ 1); } \\
                    \meta{efrom.name}\isacodebl{?x:}\meta{\left\{v:efrom.type @ \right.}\isacodebl{(dout,}\meta{v}\isacodebl{)}\meta{\left.\right\}} \isacodebl{$\to\subscriptIntt{\tick}{[snd~x]}$}
                \circblockend \isacodebl{$\extchoice$} \\
                \circblockbegin
                    \isacodebl{guard (length lv > 0); } \meta{eto.name}\isacodebl{!(din, hd lv)}\isacodebl{$\to\subscriptIntt{\tick}{[]}$}
                \circblockend \\ 
            \circblockend \\
        \circblockend \\
\end{align*}
The connection is from a $\meta{efrom}$ event to a $\meta{eto}$ event. The semantics is an infinite loop whose state is a list \isacodebl{lv} in Isabelle. It offers two choices: either accepting a write operation if the list is empty or contains one element, using channel $\meta{efrom.name}$  and then updating the state to a list containing the write value \isacodebl{snd x} in the second part of \isacodebl{x}, or accepting a read operation, if the list is not empty, using channel $\meta{eto.name}$ with current element \isacodebl{hd lv} and then updating the list to be empty \isacodebl{[]}.
%
% \newcommand{\buffer}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous.thy\#L89}}
% %  \begin{alltt}
% %  \isakwmaj{definition} buffer::"Chemical_Angle list \(\Rightarrow\) \(\buffer\)
% %    (Chan_ChemicalDetector, Chemical_Angle list) \IsaKey{itree}" \isakwmin{where}
% %  "buffer = \cspkey{loop} (\(\lambda\)la. (do \{\cspkey{guard}((length la\(\geq\)0)\(\land\)(length la\(\leq\)1)); 
% %      v \(\gets\) \cspkey{inp} turn (set [(dout,a). a \(\gets\)Chemical_Angle_list]); 
% %      \Ret [snd v] \}) \(\extchoice\) (do \{
% %      \cspkey{guard}(length la>0); \cspkey{outp} turn (din, hd la); \Ret [] \})
% %    )"
% %  \end{alltt}
% \begin{alltt}
% buffer = \cspkey{loop} (\(\lambda\)la. \(\buffer\)
%     (((length la \(\geq\) 0)\(\land\)(length la \(\leq\) 1))\(\guard\)turn?(dout, a\(\in\)Chemical_Angle) \(\to\) \(\subscriptIntt{\tick}{[a]}\)) \(\extchoice\) 
%     ((length la > 0)\(\guard\)turn!(din, hd la) \(\to \subscriptIntt{\tick}{[]}\))
%   )
% \end{alltt}
%  The state of a buffer process is of type \isacode{V list} where \isacode{V} is the value type (\isacode{Chemical\_Angle}) of the event channel (\isacode{turn}) corresponding to the event (\rcitem{turn}) of the connection (\rcitem{c}), which this buffer process is for. The buffer process is an infinite \isacode{loop} whose body is an external choice of two processes:
%  \begin{inparaenum}[(1)]
%  \item if the length of its state (a list) is either 0 or 1, it accepts an input (\isacode{a}) on the channel \isacode{turn} whose event direction is \isacode{dout} (and so the output from \rcitem{MainController}) and then terminates with the updated state (a new list \isacode{[a]} with the only element \isacode{a}); and
%  \item if its state is not an empty list, it outputs the head element (\isacode{hd la}) of the list on the channel \isacode{turn} whose event direction is \isacode{din} (and so the input to \rcitem{MicroController}) and then terminates with the update state (an empty list \isacode{[]}).
%  \end{inparaenum}

% We also note that when renaming the processes for controllers, it is not necessary to swap the direction of the event channels for the events of the controllers that are connected asynchronous. This is because a buffer has connected the event's output on one controller and the input of the event on another controller through shared buffer elements. This is different from renaming the processes for state machines where one side uses an opposite direction.

The memory of a module deals with the update of shared variables and the propagation of the update to its controllers, which is similar to that of a controller.   
The definition of the process for a module is omitted for simplicity. It can be found online (\isacode{D\_ChemicalDetector} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous.thy\#L110} for the autonomous chemical detector and \isacode{D\_PatrolMod} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/98a6268ea827d6da98db843d2525520afead0d0c/RoboChart/examples/Patrol_Robot/Patrol_Robot.thy\#L1300} for the patrol robot). 
% Next, we discuss the animation of RoboChart through code generation and mainly show two animation scenarios of the chemical detector example. 

\section{Code generation, animation, and case studies}
\label{sec:animation}

As discussed previously in \cite[Sect.~5]{Foster2021}, the animation of ITrees is achieved through code generation~\cite{Haftmann2010} in Isabelle. 
Infinite corecursive definitions over ITrees are implemented using lazy evaluation in Haskell. 
Associative lists are used to implement partial functions in ITrees, and a simple animator in Haskell is presented. 
Using the same approach for animation, we can animate the two RoboChart models shown in Sect.~\ref{sec:robochart}. 

\subsection{Autonomous chemical detector}
\label{ssec:animation_chemical}
We illustrate two scenarios \changed[\C{2}]{\textbf{SCE-ACD-1} and \textbf{SCE-ACD-2}} of the animation of the autonomous chemical detector in Figs.~\ref{fig:animate_stop} and \ref{fig:animate_resume}. %{We, additionally, highlight and number the actions taken in the scenarios in Figure~\ref{fig:robochart_acd_movement_ann} where the font for the numbers of the first scenario is red and normal, and that for the second scenario is blue and italic.} 
Here, we instantiate \isacode{Chem} and \isacode{Intensity} to be a numeral type \isacode{2} and the sequence of \isacode{GasSensor} is bounded to 2, which is the same as the instantiations for the verification with FDR4.
An animation scenario represents the interaction of the model with its environment: the lines starting with \lstinline[language=Animation]{Events} are produced by the model and describe all enabled events, and the lines beginning with \lstinline[language=Animation]{[Choose: 1-n]} represents a user's choice of enabled events from number 1 to n. In Fig.~\ref{fig:animate_resume}, we omit the lines for enabled events and append the chosen event to the selected number for simplicity. 

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:animation_acd_1}]
Starting ITree animation...
Events: (1) RandomWalkCall (); (2) Gas (Din, []); ...;
[Choose: 1-22]: 1
Events: (1) Gas []; (2) Gas [(0,0)]; (3) Gas [(0,1)]; (4) Gas [(1,0)]; 
  (5) Gas [(1,1)]; (6) Gas [(0,0),(0,0)]; (7) Gas [(0,0),(0,1)]; (8) Gas 
  [(0,0),(1,0)]; (9) Gas [(0,0),(1,1)]; ...; (21) Gas [(1,1),(1,1)];
[Choose: 1-21]: 9
Events: (1) MoveCall (0,Chemical_Angle_Front);
[Choose: 1-1]: 1
Events: (1) Flag Dout;
[Choose: 1-1]: 1
Terminated: ()
\end{lstlisting}
\caption{\label{fig:animate_stop} \changed[\C{2}]{\textbf{SCE-ACD-1}:} animation of the example when dangerous chemical detected.}
\vspace{-3ex}
\end{figure}

% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=1.0\textwidth]{Movement_annotated.pdf}%
%   \vspace{-2ex}
%   \caption{Movement state machine of the autonomous chemical detector model with annotation.}%
%   \vspace{-4ex}
%   \label{fig:robochart_acd_movement_ann}%
% \end{figure}

%Events: (1) Gas (Din, []); (2) Gas (Din, [(0, 0)]); (3) Gas (Din, [(0, 1)]); (4) Gas (Din, [(1, 0)]); (5) Gas (Din, [(1, 1)]); (6) Gas (Din, [(0, 0),(0, 0)]); (7) Gas (Din, [(0, 0),(0, 1)]); (8) Gas (Din, [(0, 0),(1, 0)]); (9) Gas (Din, [(0, 0),(1, 1)]); ...; (21) Gas (Din, [(1, 1),(1, 1)]);

%On line \verb+#4+ of Fig.~\ref{fig:animate_stop}, we display partially enabled \isacode{Gas} (corresponding to the \rcitem{gas} event in the model and the use of capital \isacode{G} due to the naming convention in Haskell) events: 10 out of 21. The value carried on the \isacode{Gas} channel is a pair whose first element is the direction of the connection on which the event \rcitem{gas} is, and whose second element is a bounded sequence of records which are of type \isacode{GasSensor}. A record is also represented by a pair whose first element denotes whether a chemical is detected or not (\lstinline[language=Animation]{0}  for no and  \lstinline[language=Animation]{1} for yes) and whose second element denotes the intensity of the detected chemical (\lstinline[language=Animation]{0}  for low and  \lstinline[language=Animation]{1} for high). On line \verb+#2+, we omit 20 more enabled \isacode{Gas} events. 
\paragraph{\textbf{\changed[\C{2}]{SCE-ACD-1}}}
Figure~\ref{fig:animate_stop} illustrates the behaviour of the model when detecting a dangerous chemical: 
\begin{inparaenum}[(1)]
\item initially the controller calls the platform to perform a random walk: the number \lstinline[language=Animation]{1} event is chosen on line \verb+#3+, which corresponds to the call of the during action \rcitem{randomWalk()} 
    %{(\color{red}{1} in Figure~\ref{fig:robochart_acd_movement_ann})} 
    of state \rcitem{Waiting} in Fig.~\ref{fig:robochart_acd_movement};
    \item then a sequence of gas sensor readings is received through the \rcitem{gas} event, and we choose number \lstinline[language=Animation]{9} (among 21 enabled \rcitem{gas} events shown on lines \verb+#4-6+ where the first element \lstinline[language=Animation]{Din} of each event is omitted) on line \verb+#7+: \lstinline[language=Animation]{Gas [(0,0),(1,1)]},  representing a chemical being detected and its intensity is high in the second pair of the sequence;
    \item the controllers call the \rcitem{move} operation with speed 0 (on line \verb+#9+), provided by the platform, to stop the robot; 
    \item the controllers indicate the platform to drop a flag (on line \verb+#11+); and finally 
    \item the controllers terminate (on line \verb+#12+).
\end{inparaenum}


\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:animation_acd_2}]
/*Starting ITree animation...
*/[Choose: 1-22]: 1   RandomWalkCall ()
[Choose: 1-21]: 4   Gas (Din,[(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 2   Obstacle (Din,Location_Loc_right)
[Choose: 1-23]: 1   Odometer (Din,0)
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Left)
[Choose: 1-21]: 8   Gas (Din,[(0, 0),(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 1   Obstacle (Din, Location_Loc_left)
[Choose: 1-23]: 2   Odometer (Din,1)
[Choose: 1-23]: 1   Odometer (Din,0)
/*[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Right)
[Choose: 1-21]: 4   Gas (Din,[(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 2   Obstacle (Din,Location_Loc_right)
[Choose: 1-23]: 1   Odometer (Din,0)
[Choose: 1-22]: 1   Stuck_timeout Din
[Choose: 1-22]: 1   ShortRandomWalkCall ()
*/[Choose: 1-22]: ...
\end{lstlisting}
\caption{\label{fig:animate_resume} \changed[\C{2}]{\textbf{SCE-ACD-2}:} animation of the example when chemical detected with low intensity.}
\vspace{-3ex}
\end{figure}

\paragraph{\textbf{\changed[\C{2}]{SCE-ACD-2}}}
In Fig.~\ref{fig:animate_resume}, we illustrate another scenario: a chemical is detected, but its intensity is low for the two readings on lines \verb+#2+ and \verb+#7+. The model behaves as follows: 
\begin{inparaenum}[(1)]
    \item the initial behaviour is the same: calling the platform to request a random walk;
    \item a sequence of gas sensor readings is received (online \verb+#2+);
    \item the controllers call the \rcitem{move} operation (the entry action of the state \rcitem{Going} in Fig.~\ref{fig:robochart_acd_movement}) to request the robot to move forward at speed 1 (on line \verb+#3+);
    \item an obstacle on its right is encountered (on line \verb+#4+);
    \item the odometer reading is 0 (on line \verb+#5+);
    \item the controllers call \rcitem{move} (the action of a transition in the defined operation \rcitem{changeDirection}) to request the robot to move towards its opposite direction (left here) to the obstacle at speed 1 (online \verb+#6+);
    \item another reading of the gas sensor shows there is still a chemical detected with low intensity (on line \verb+#7+);
    \item the controllers call \rcitem{move} (the entry action of state \rcitem{TryingAgain} in machine \rcitem{Movement}) to request the robot to move towards its front at speed 1 (on line \verb+#8+);
    \item an obstacle on its left is encountered (on line \verb+#9+);
    \item the odometer reading (the action of the transition from state \rcitem{TryingAgain} to state \rcitem{AvoidingAgain}) is 1 (on line \verb+#10+);
    \item there is another odometer reading (0) on line \verb+#11+, which corresponds to the entry action of state \rcitem{Avoiding} (the entering of this state has resulted from the transition taken from state \rcitem{AvoidingAgain} to state \rcitem{Avoiding} due to its guard \rcitem{d1-d0>stuckDist} is true where the values of \rcitem{d0} and \rcitem{d1} are the previous two odometer readings 0 and 1, and the value of \rcitem{stuckDist} is set 0 in this animation);
    \item we omit further interactions.
\end{inparaenum}

Based on the animation, we also observe that if no chemical is detected, the model returns to its initial state. 
If the low-intensity chemical is detected, even without progress of \rcitem{MicroController}, the model can continuously read through the \rcitem{gas} event without blocking. This is due to the connection between the controllers on event \rcitem{turn} being asynchronous, and so \rcitem{MainController} can continuously send a \rcitem{turn} event without waiting for the synchronisation of \rcitem{MicroController}. 
In our implementation in ITrees, the buffer process defined previously for the connection reflects this behaviour: overwriting the buffer is always allowed.

\subsection{The patrol robot}
\label{ssec:animation_patrol}
In this example, we instantiate \isacode{MAX\_INT} to 3 and \isacode{MAX} to 2 and illustrate three scenarios \changed[\C{2}]{\textbf{SCE-PR-1}, \textbf{SCE-PR-2}, and \textbf{SCE-PR-3}} of the animation of the patrol robot corresponding to the three sections (S1, S2, and S3) of the corridor in Fig.~\ref{fig:robochart_patrol_sections}.

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:animation_pr_1}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 2 Cal_PatrolMod (Din,-3)
[Choose: 1-1]: Right_PatrolMod (Dout,-2)
[Choose: 1-1]: Right_PatrolMod (Dout,-2)
[Choose: 1-1]: Right_PatrolMod (Dout,-1)
[Choose: 1-1]: Right_PatrolMod (Dout,-1)
[Choose: 1-1]: Right_PatrolMod (Dout,0)
Events: (1) Right_PatrolMod (Dout,0); (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 1 Right_PatrolMod (Dout,0)
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]:
\end{lstlisting}
\caption{\label{fig:animate_patrol_s1} \changed[\C{2}]{\textbf{SCE-PR-1:}} animation of the patrol robot when the calibrated position is in S1.}
%\vspace{-3ex}
\end{figure}

\paragraph{\textbf{\changed[\C{2}]{SCE-PR-1}}}
We show the first scenario in Fig.~\ref{fig:animate_patrol_s1}, related to the calibrated position in S1. The model behaves as follows: 
\begin{inparaenum}[(1)]
\item initially, the controller provides eight events on lines \verb+#2-4+ for users to choose: one to reset the position and another seven to set the calibrated position to an integer value between -3 and 3;
\item the second event (\lstinline[language=Animation]{2}) is chosen on line \verb+#5+, denoting the calibrated position is \lstinline[language=Animation]{-3} and so the robot is in S1;
\item the only available event on lines \verb+#6-10+ is \lstinline[language=Animation]{Right_PatrolMod}\footnote{The change of the name from \isacode{right\_PatrolMod} to \lstinline[language=Animation]{Right_PatrolMod} is due to the code generation in Isabelle to generate Haskell. In Haskell, it is conventional to use capitalised names for data types.} which corresponds to the \rcitem{right} event in the RoboChart model, denoting the movement of the robot towards the right side of the corridor at the new positions (\lstinline[language=Animation]{-2}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0} respectively);
\item since the new position on line \verb+#10+ is 0 now, the controller could accept a \rcitem{right} event and calibration events on lines \verb+#11-13+;
\item the \rcitem{right} event is chosen on line \verb+14+, and after that, 
\item the controller returns to its initial state: having the same available events on lines \verb+#15-17+ as initially available events on lines \verb+2-4+.
\end{inparaenum}
%
When \rcitem{x} is equal to -3 and -2 (in section S1), the robot moves towards the right side, and \rcitem{x} is increased by 1, as illustrated on line \verb+#6-9+. This behaviour is consistent with the semantics of the model. After \rcitem{x} becomes -1 (in section S2), the model nondeterministically chooses to move towards the left or right side. However, our animation on lines \verb+#6-10+, and \verb+#14+ shows only the right side is chosen. This is because of the use of renaming with priority in \isacode{Renamedp\_MemorySTM\_MoveSTM} and the higher priority of the \rcitem{update} event on \rcitem{t1} than \rcitem{t3} to resolve the nondeterminism (and so the priority is given to the movement towards the right side).

In the RoboChart model, we expect each \rcitem{left} or \rcitem{right} event to correspond to decrease or increase \rcitem{x} by 1. The animation, however, shows that the new positions (\lstinline[language=Animation]{-2}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0}) on the \rcitem{right} event on lines \verb+#7+, \verb+#9+, and \verb+#14+ stay the same as their previous positions on lines \verb+#5+, \verb+#8+, and \verb+#10+. This is actually due to the semantics of shared variables in RoboChart, specifically, the mechanism used to update shared variables and propagate the updates, which is subtle. We illustrate the implemented mechanism in our semantics in Fig.~\ref{fig:basic_shared_variables} where the exchange of the value of \rcitem{x} in the module, the controller, and the two machines is through communication (labelled with an identifier, a channel, and a message over the channel).

\begin{figure}[t]
  \centering%
  \includegraphics[width=0.70\textwidth]{shared_variables.pdf}%
  \caption{The update of the shared variable \rcitem{x} and its propagation in the patrol robot model.}%
  \label{fig:basic_shared_variables}%
\end{figure}

The communications 1 to 4 show that the change of \rcitem{x} to -2 in \rcitem{CalSTM} is updated to the module \rcitem{PatrolMod}, and then this update is propagated down the memory hierarchy to the controller \rcitem{Ctrl}, subsequently to the state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. The update and propagation, however, are not atomic. The memories can be accessed and evaluated between these communications using the outdated value. This is further demonstrated by communications 5 to 11. Consider a new update of \rcitem{x} to -1 (by communication 5) in the memory of \rcitem{MoveSTM}. The update and propagation are similar to the previous update (to -2). We here, however, consider the value of \rcitem{x} in \rcitem{CalSTM} is accessed (by the event \isacode{get\_x} on communication 8) and evaluated in the guard \rcitem{[x!=0]} of the transition in the machine before the new value -1 is propagated to the machine (on communication 9). This means the action of the transition still outputs -2 on the event \rcitem{update!-2}, not the -1, because the new value has not been seen in this machine. As a consequence, the input trigger \rcitem{update?l} in the machine \rcitem{MoveSTM} will receive a value -2, and so \rcitem{x} is set to -1 (\rcitem{x=l+1}) again, as indicated on communication 11. The updates of \rcitem{x} to -1 on communications 5 and 11 correspond to the action \rcitem{x=l+1} (\isacode{rc.Plus l 1 rc.core\_int\_set} in our semantics) in the self transition of \rcitem{MoveSTM}, which is followed by an output event \rcitem{right!x}. The animation, therefore, shows two \lstinline[language=Animation]{Right_PatrolMod} events on lines \verb+#8+ and \verb+#9+.

It is worth mentioning that the RoboChart semantics in this model with the shared variable \rcitem{x} has a high degree of nondeterminism because of the interleaving of events between the module, the controller, and the state machines, and eventually nondeterminism due to the hiding of these interleaving events. Our implementation of the semantics reduces nondeterminism in a particular way: the maximal progress assumption (internal events $\tau$ have a higher priority)~\cite{Foster2021}. We also note that the animated behaviour of two \isacode{Right\_PatrolMod} events for a position is one behaviour of the RoboChart's standard semantics. This has been verified using FDR that this scenario is a trace refinement of the standard semantics (generated in RoboTool). For the verification, we encode the scenario in Fig.~\ref{fig:animate_patrol_s1} in a CSP process \lstinline[language=CSP]{Scenario1} below and then use FDR to check the assertion satisfied.
%
\begin{lstlisting}[language=CSP, caption={}]
Scenario1 = PatrolMod::cal.in.-3    -> PatrolMod::right.out.-2 -> PatrolMod::right.out.-2 ->
	           PatrolMod::right.out.-1 -> PatrolMod::right.out.-1 -> PatrolMod::right.out.0  -> 
              PatrolMod::right.out.0  -> Scenario1
assert PatrolMod [T= Scenario1  
\end{lstlisting}
In the assertion, \lstinline[language=CSP]{PatrolMod} is the CSP process for the module \rcitem{PatrolMod} in the generated CSP semantics in RoboTool.

Though semantically allowed, the model does not reflect the optimal way to use shared variables \changed[\C{28}]{in terms of the unnecessary interleaving behaviour by updating the shared variables from multiple state machines}. We could, for example, design models to allow only one state machine to update a shared variable and other state machines to access its value or add additional events (such as start\_update and end\_update) to enforce a synchronisation of updates to shared variables. Our patrol robot model here is presented to reveal the subtle semantics of using shared variables.

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:animation_pr_2}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 6 Cal_PatrolMod (Din,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: ... 
\end{lstlisting}
\caption{\label{fig:animate_patrol_s2} \changed[\C{2}]{\textbf{SCE-PR-2:}} animation of the patrol robot when the calibrated position is in S2.}
%\vspace{-3ex}
\end{figure}
\paragraph{\textbf{\changed[\C{2}]{SCE-PR-2}}}
In Fig.~\ref{fig:animate_patrol_s2}, we consider the second scenario where the calibrated position is 1 (in S2). The model behaves as follows:
\begin{inparaenum}[(1)]
\item the sixth event (\lstinline[language=Animation]{6}) is chosen on line \verb+#5+, denoting the calibrated position is \lstinline[language=Animation]{1} and so the robot is in S2;
\item then the robot moves towards the right side at position 2 (lines \verb+#6+ and \verb+#7+); 
\item subsequently the robot moves towards the left direction to position 1 (lines \verb+#8+ and \verb+#9+); and 
\item finally, the robot repeats steps (2) and (3) to patrol between position 1 and position 2.
\end{inparaenum}
%
We also verified this scenario is a trace refinement of the standard semantics, shown below. 
\begin{lstlisting}[language=CSP, caption={}]
Repeat = PatrolMod::right.out.2 -> PatrolMod::right.out.2 ->
          PatrolMod::left.out.1 -> PatrolMod::left.out.1 -> Repeat
Scenario2 = PatrolMod::cal.in.1 -> Repeat
assert PatrolMod [T= Scenario2
\end{lstlisting}


\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:animation_pr_3}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 8 Cal_PatrolMod (Din,3)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: ... 
\end{lstlisting}
\caption{\label{fig:animate_patrol_s3} \changed[\C{2}]{\textbf{SCE-PR-3:}} animation of the patrol robot when the calibrated position is in S3.}
%\vspace{-3ex}
\end{figure}

\paragraph{\textbf{\changed[\C{2}]{SCE-PR-3}}}
The third scenario we consider is shown in Fig.~\ref{fig:animate_patrol_s3} where the calibrated position is initially 3 (in S3) on line \verb+#5+. The robot starts to move towards the left side to position 2 (on lines \verb+#6+ and \verb+#7+) and position 1 (on lines \verb+#8+ and \verb+#9+), and then towards the right side back to position 2 (on lines \verb+#10+ and \verb+#11+). After that, the behaviour is the same as in the second scenario in Fig.~\ref{fig:animate_patrol_s2}. Similarly, we verified this scenario is a trace refinement of the standard semantics.
%
\begin{lstlisting}[language=CSP, caption={}]
Scenario2 = PatrolMod::cal.in.3 -> PatrolMod::left.out.2 -> PatrolMod::left.out.2 -> 
	           PatrolMod::left.out.1 -> PatrolMod::left.out.1 -> Repeat 
assert PatrolMod [T= Scenario3
\end{lstlisting}

\paragraph{Summary}
From the three scenarios, we have seen that the event \isacode{Reset\_PatrolMod} (\rcitem{reset} in the model) is only enabled when the current position (the value of \rcitem{x} on the event \rcitem{left} or \rcitem{right}) is 0. The events enabled on lines \verb+#2+ and \verb+#15+ in Fig.~\ref{fig:animate_patrol_s1} and on line \verb+#2+ in Figs.~\ref{fig:animate_patrol_s2} and \ref{fig:animate_patrol_s3} are such examples. The standard CSP semantics, however, allows \rcitem{reset} when the current position is other than 0. The following analysis using FDR illustrates it clearly.

\begin{lstlisting}[language=CSP, caption={}]
Reset = PatrolMod::cal.in.-2 -> PatrolMod::left.out.-1 -> 
		     PatrolMod::reset.in -> PatrolMod::right.out.0 -> 
		     PatrolMod::right.out.1 -> PatrolMod::reset.in -> Reset
assert PatrolMod [T= Reset
\end{lstlisting}
In this example, \rcitem{reset} is enabled when \rcitem{x} is -1 (on line \verb+#2+) and 1 (on line \verb+#3+).
This difference is due to the maximal progress assumption in the definition of external choice and hiding in our approach: internal events have priority over external events. In this patrol robot model, the event \rcitem{update} is internal and \rcitem{reset} is external, so \rcitem{update} has priority over \rcitem{reset}. When \rcitem{x} is not 0, the guard \rcitem{[x!=0]} in the self transition of \rcitem{Cal} in the machine \rcitem{CalSTM} is true, which enables \rcitem{CalSTM} to communicate with the machine \rcitem{MoveSTM} on \rcitem{update}, and then the transition with the trigger \rcitem{reset} cannot be taken due to its lower priority than \rcitem{update}. Therefore, the \rcitem{reset} is only enabled when \rcitem{x} is 0.


%%%%%%%%%% This commented description corresponds to MAX_INT 2 an dMAX 1.
% \begin{figure}[t]
% \begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
% Starting ITree Animation...
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 2 Cal_PatrolMod (Din,-2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,-1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,-1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,0)
% Events: (1) Right_PatrolMod (Dout,0); (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 1 Right_PatrolMod (Dout,0)
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% \end{lstlisting}
% \caption{\label{fig:animate_patrol_s1} Animation of the patrol robot when the calibrated position is at S1.}
% \vspace{-3ex}
% \end{figure}
% 
% We show the first scenario in Fig.~\ref{fig:animate_patrol_s1}, which is related to the calibrated position in S1. The model behaves as follows: 
% \begin{inparaenum}[(1)]
% \item initially, the controller provides six events on lines \verb+#2-3+ for users to choose: one to reset the position and other five to set the calibrated position to an integer value between -2 and 2;
% \item the second event (\lstinline[language=Animation]{2}) is chosen on line \verb+#4+, denoting the calibrated position is \lstinline[language=Animation]{-2} and so the robot is in S1;
% \item the only available event on lines \verb+#5-7+ is \lstinline[language=Animation]{Right_PatrolMod}\footnote{The change of the name from \isacode{right\_PatrolMod} to \lstinline[language=Animation]{Right_PatrolMod} is due to the code generation in Isabelle to generate Haskell. In Haskell, it is conventional to use capitalised names for data types.} which corresponds to the \rcitem{right} event in the RoboChart model, denoting the movement of the robot towards the right of the corridor at the new positions (\lstinline[language=Animation]{-1}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0} respectively);
% \item since the new position is 0 now, the controller could accept calibration events and a \rcitem{right} event on lines \verb+#8-9+;
% \item the \rcitem{right} event is chosen on line \verb+10+; and after that 
%     \item the controller returns to its initial state: having the same available events on lines \verb+#11-12+ as initially available events on lines \verb+2-3+.
% \end{inparaenum}
% %
% When \rcitem{x} is equal to -2 (in section S1), the robot will move towards the right side, and \rcitem{x} is increased by 1, as illustrated on line \verb+#5+. This behaviour is consistent with the model. After \rcitem{x} becomes -1 (in section S2), the model nondeterministically chooses to move towards the left or right side. However, our animation on lines \verb+6+, \verb+7+, and \verb+10+ shows the right side is still chosen. This is because of the use of renaming with priority in \isacode{Renamedp\_MemorySTM\_MoveSTM} and the higher priority of the \rcitem{update} event on \rcitem{t1} than \rcitem{t3} to resolve the nondeterminism and give priority to the movement towards the right side.
% 
% In the RoboChart model, we expect each \rcitem{left} or \rcitem{right} event corresponds to decrease or increase \rcitem{x} by 1. The animation, however, shows that the destination positions (\lstinline[language=Animation]{-1} and \lstinline[language=Animation]{0}) of the \rcitem{right} event on lines \verb+#6+ and \verb+#10+ stay the same as their previous positions (\lstinline[language=Animation]{-1} and \lstinline[language=Animation]{0} on lines \verb+#5+ and \verb+#7+). This is actually due to the semantics of shared variables in RoboChart, specifically, the mechanism used to update shared variables and propagate the updates, which is subtle. We illustrate the implemented mechanism in our semantics in Fig.~\ref{fig:basic_shared_variables} where the exchange of the value of \rcitem{x} in the module, the controller, and the two machines is through communication (labelled with an identifier, a channel, and a message over the channel).
% 
% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=0.70\textwidth]{shared_variables.pdf}%
%   \caption{The update of the shared variable \rcitem{x} and its propagation in the patrol robot model.}%
%   \label{fig:basic_shared_variables}%
% \end{figure}
% 
% The communications 1 to 4 show that the change of \rcitem{x} to -2 in \rcitem{CalSTM} is updated to the module \rcitem{PatrolMod}, and then this update is propagated down the memory hierarchy to the controller \rcitem{Ctrl}, subsequently to the state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. The update and propagation, however, are not atomic. The memories can be accessed and evaluated between these communications using the outdated value. This is further demonstrated by communications 5 to 11. Consider a new update of \rcitem{x} to -1 (by communication 5) in the memory of \rcitem{MoveSTM}. The update and propagation are similar to the previous update (to -2). We here, however, consider the value of \rcitem{x} in \rcitem{CalSTM} is accessed (by the event \isacode{get\_x} on communication 8) and evaluated in the guard \rcitem{[x!=0]} of the transition in the machine before the new value -1 is propagated to the machine (on communication 9). This means the action of the transition still outputs -2 on the event \rcitem{update!-2}, not the -1, because the new value has not been seen in this machine. As a consequence, the input trigger \rcitem{update?l} in the machine \rcitem{MoveSTM} will receive a value -2, and so \rcitem{x} is set to -1 (\rcitem{x=l+1}) again, as indicated on communication 11. The updates of \rcitem{x} to -1 on communications 5 and 11 correspond to the action \rcitem{x=l+1} (\isacode{rc.Plus l 1 rc.core\_int\_set} in our semantics) in the self transition of \rcitem{MoveSTM}, which is followed by an output event \rcitem{right!x}. The animation, therefore, shows two \lstinline[language=Animation]{Right\_PatrolMod} events on lines \verb+#5+  and \verb+#6+.
% 
% It is worth mentioning that the RoboChart semantics in this model with the shared variable \rcitem{x} has a high degree of nondeterminism because of the interleaving of internal events between the module, the controller, and the state machines, and eventually nondeterminism due to the hiding of these interleaving events. Our implementation of the semantics reduces nondeterminism in a particular way: the maximal progress (internal events $\tau$ have a higher priority)~\cite{Foster2021}. We also note that the animated behaviour of two \isacode{Right\_PatrolMod} events for a position is consistent with RoboChart's semantics. The model, however, does not reflect the optimal way to use shared variables. We could, for example, design models to allow only one state machine to update a shared variable and other state machines to access its value or add additional events (such as start\_update and end\_update) to enforce a synchronisation of updates to shared variables. Our patrol robot model here is presented to reveal the subtle semantics of using shared variables.
% 
% \begin{figure}[t]
% \begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
% Starting ITree Animation...
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 5 Cal_PatrolMod (Din,1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% \end{lstlisting}
% \caption{\label{fig:animate_patrol_s2} Animation of the patrol robot when the calibrated position is at S2.}
% \vspace{-3ex}
% \end{figure}
% In Fig.~\ref{fig:animate_patrol_s2}, we consider the second scenario where the calibrated position is 1 (in S2). The model behaves as follows:
% \begin{inparaenum}[(1)]
% \item the fifth event (\lstinline[language=Animation]{5}) is chosen on line \verb+#4+, denoting the calibrated position is \lstinline[language=Animation]{1} and so the robot is in S2;
% \item then the robot moves towards the right boundary at position 2 (lines \verb+#5+ and \verb+#6+); 
% \item subsequently the robot moves towards the left direction to position 1 (lines \verb+#7+ and \verb+#8+); and 
% \item finally, the robot repeats steps (2) and (3) to patrol between position 1 and position 2.
% \end{inparaenum}
% 
% If the robot's calibrated position is 2 in S3, it will start to move towards the left side first to position 1 and then towards the right side back to position 2, which is the same as the behaviour after line \verb+#7+ in Fig.~\ref{fig:animate_patrol_s2}.

\section{Related work}
\label{sec:related}
%Previously, we have compared ITrees with other semantic approaches in~\cite{Foster2021}. 
%Here, we set our work in the context of animation of formal specifications, which is discussed in several  work~\cite{Fuchs1992,Malik2005,Leuschel2014,Oda2015,Mashkoor2017} for the Z notation, B and Event-B machines~\cite{Abrial2005,Abrial2010}, CSP, and VDM~\cite{Jones1991}. %Our work here is specifically for the animation of CSP (for RoboChart).
%
%Both Probe in FDR and ProB~\cite{prob} can animate machine-readable CSP, or CSP-M, which supports a restricted subset of RoboChart types and expressions and cannot deal with function definitions (by preconditions and postconditions) in RoboChart directly (and so users are required to supply explicit implementation). Our encoding of CSP processes in ITrees addresses these issues thanks to the mechanisation of Z mathematical toolkits (to support rich RoboChart types and expressions) and code generation (to solve preconditions and postconditions effectively) in Isabelle/HOL.

{Animation is a lightweight formal method. Kazmierczak et al.~\cite{Kazmierczak1998} describe the advantages of using animation to \changed[\C{29}]{test} models. It is highly automated and cheap to perform. It provides an insight into the specification and its implicit assumptions and is very suitable for demonstrating the system. It is a form of interactive testing of the model and its properties. It requires little expertise: less than model checking and much less than theorem proving. However, its biggest drawback is that it cannot verify consistency, correctness, or completeness.

Animation can be tailored to specific application domains. For example, Boichut et al.~\cite{Boichut2007} report on using animation to improve the formal specifications of security protocols. They animate these specifications to draw diagrams of typical executions of the protocols. They use this to visualise protocol termination and understand interleaved execution. They experiment with the animation to detect unwanted side effects. Finally, they use visualisation to simulate intruders to find attacks not detected by other protocol analysis tools.

We use ITrees to implement a framework for the animation of formal specifications. The ProB animator and model checker provide a different framework~\cite{Leuschel2003}. ProB contains model and constraint-based checkers that can detect errors in B specifications. It implements a back-end in a framework for various specification languages, including the B language, Event-B, CSP-M, TLA+, and Z.

De Souza~\cite{Souza2011} provides another framework: Joker. This is a tool for producing animators for formal languages. The application is based on general labelled transition systems and provides graphical animation, supporting B, CSP, and Z.}

{Rosu et al.~\cite{Rosu2010} develop K,\footnote{\url{https://kframework.org/}} a rewriting-based executable semantic framework. The operational semantics of programming languages such as C~\cite{Ellison2012} and Java~\cite{Bogdanas2015} are proposed based on K. Our ITree-based approach is also an executable semantic framework enabling the definition of operational semantics but for both abstract specification languages and concrete refinements. Thus, program development by refinement is supported in our framework. Higher-order logic and nondeterminism are some features of interaction trees, but not \changed[\C{67}]{of} K.}

Stateflow is a graphical language integrated into Matlab's Simulink to model and simulate decision logic using state machines and flow charts. During simulation, transitions in state machines are evaluated, by default, based on the order in which they are created~\cite{MathWorks2022}. This is the same as our approach to resolving nondeterministic choices between transitions using the prioritised renaming operator.
%The support of nondeterminism is one of our future works, but it is not included in K. 

%The automatically generated CSP semantics of a RoboChart model in RoboTool targets at verification with FDR4 and so uses machine-readable CSP or CSP-M with modules. This naturally makes Probe in FDR the first choice for the animation of RoboChart. 
%Here, we set ITrees in the context of animation for RoboChart. 
\changed[\C{1}]{The automatically generated CSP semantics of a RoboChart model in RoboTool targets at verification with FDR4 and so uses CSP-M with modules. This naturally makes Probe in FDR the first choice for the animation of RoboChart. 
The benefits of Probe include 
\begin{inparaenum}[(1)]
    \item the consistency of the standard and timed semantics of RoboChart between verification and animation because they use the same generated CSP code; and
    \item various compression methods in FDR are also used for animation, which could potentially reduce the size of state space and improve the efficiency of animation.
\end{inparaenum}
 Probe presents all internal behaviours to users to let them choose each nondeterministic choice, making the animation challenging even for experts. Our animation, presented in this paper, simplifies the process by eliminating internal behaviours so only observable events are visible to users, which makes our animation accessible to normal users. 

ProB~\cite{prob} also supports CSP-M for model checking and animation without modules. It also has some limitations \footnote{\url{prob.hhu.de/w/index.php?title=CSP-M}} in terms of supported CSP constructors. ProB cannot directly model check and animate the generated CSP code (in the new CSP-M version) in RoboTool because ProB only supports early versions of CSP-M. To use the user-friendly (GUI-based) animator in ProB, we need to encode the CSP semantics of RoboChart in the CSP-M supported by ProB.  
It is possible to encode the CSP semantics of RoboChart in the CSP-M supported by ProB, but we have not investigated it yet. The GUI-based animation in ProB is straightforward and easily used even by normal users. This is an advantage of ProB in terms of animation. 
}
%
% To achieve semantic consistency, the main restriction of our current approach in this paper is the handling of nondeterminism. We focus on the deterministic systems and avoid nondeterminism by excluding potential events. Support of nondeterminism in ITrees is our immediate future work. 
% In ITrees, we implement compression of the process to some extent, such as .... (ask Simon about it?)
% The significant advantage of the focus on deterministic programs is the improved efficiency of animation for users. The animation scenarios in Sect.~\ref{sec:animation} show the minimum interactions required for users because internal activities are automatically computed. The animation of CSP with FDR and ProB does need the user's inputs to resolve internal $\tau$ actions, making the animation difficult for users and regular users without knowledge of CSP.

%Different from the semantics of RoboChart in CSP-M, is limited to a subset of RoboChart types and expressions and requires users to supply an implementation of functions, our encoding of CSP processes in ITrees supports almost all RoboChart types and expressions as well as functions defined using preconditions and postconditions.   
%(benefiting from the mechanisation of Z mathematical toolkits in Isabelle) 
% and characterise systems with infinite states symbolically. 
%Furthermore, a function defined using preconditions and postconditions in RoboChart could not automatically and consistently implement the function in CSP-M. Its implementation is the user's responsibility. In our approach, however, its preconditions and postconditions can be effectively solved using code generation, which is beneficial for the completeness of models and their semantics. 
%Our animation is also formally verified concerning the semantics of RoboChart given in ITrees, thanks to code generation in Isabelle/HOL.
%For example, a function defined using preconditions and postconditions in RoboChart could not automatically and consistently implement the function in CSP-M (its implementation is the users' responsibility). Still, it is possible in our ITrees mechanisation. 

% Regarding integration with existing tools, our approach could be automated to generate RoboChart theories for ITrees in RoboTool. This semantics generator can essentially reuse the current CSP-M semantics generator in RoboTool. Because of our open approach, it also has the potential to integrate the Haskell code-based animation seamlessly with RoboTool to use animation, for example, to debug state machines or communicate with stakeholders. This is not possible currently with FDR4 because there are no open interfaces to access its animation in programs.

\section{Conclusions \changed[\C{6}]{ and future work}}
\label{sec:concl}

{This work gives RoboChart an ITree-based operational semantics and enables the animation of RoboChart using code generation in Isabelle/HOL.}
% We showed how the semantics of RoboChart is implemented in recently mechanised CSP in Isabelle, whose semantics is given on ITrees. 
To provide animation support, we extend ITree-based CSP with extra operators
%: interrupt, exception, and renaming,
 and present their definitions. We describe how the semantics of RoboChart %, including types, instantiations, functions, state machines, controllers, and modules,
 is implemented in ITree-based CSP and illustrate it with an autonomous chemical detector model and a patrol robot model.
%
With the semantics of a RoboChart model in Isabelle, we generate Haskell code and animate it using a simple simulator. Using animation, we show two concrete scenarios of the chemical detector example and three concrete scenarios of the patrol robot model.
The FDR analysis shows these scenarios are trace refinements of the standard RoboChart CSP semantics, so our approach gives and animates a refinement of the original models.

This work targets deterministic RoboChart and nondeterministic RoboChart models (but nondeterminism is resolved in a priority way in the semantics and so deterministic semantics eventually). Our work covers many RoboChart features (but not all). 
Our immediate future work is to investigate the support of nondeterminism in semantics and give semantics to more features, such as hierarchical state machines and timed semantics.
% and several possible approaches have been discussed in the previous work~\cite[Sect.~7]{Foster2021}. 

%This work covers many RoboChart features, but not all, such as hierarchical state machines and timed semantics in RoboChart. We will give semantics to these features in the future. 

In this paper, we manually translate the RoboChart semantics to Isabelle. 
Mainly, we take RoboChart's CSP semantics generated in RoboTool into account to define consistent and restricted semantics based on an optimised version of the CSP semantics. This practical consideration could entitle us to reuse the current CSP semantics generator in RoboTool to generate ITree-based CSP semantics automatically. 
Then, the workflow from RoboChart models to Haskell code can be fully automated, and our work brings insights into it. This is part of our future work. 
% The simple animator will be improved to allow the visualisation of RoboChart models in RoboTool directly.

With the RoboChart semantics in ITrees, we can also conduct verification in Isabelle/HOL and animation in this paper. We will investigate using temporal logic as a property language for verifying ITrees. We note that verification can also capitalise on the contributions of this work. 

ITrees can also be extended to other semantic domains. Further work would be of great help in extending ITrees with probability and linking them to discrete-time Markov chains (DTMCs)~\cite{Kemeny1976c,Kemeny1983}, which will allow us to give an ITree-based probabilistic semantics to RoboChart.

Our work has many potential applications in robotics. Further research could investigate the development of verified ROS nodes using code generation here for a concrete implementation of RoboChart controllers. We could also use this approach to automatically generate a sound runtime monitor from RoboChart models to observe the behaviour of systems derived from the models.

We use a basic textual animation in this work. This will be improved to allow the visualisation of RoboChart models in RoboTool for animation. Eventually, RoboTool users can animate a state machine, a controller, or a whole model by clicking transitions or events.


\section*{Acknowledgements}

This work is funded by the EPSRC projects CyPhyAssure%
\footnote{%
  CyPhyAssure Project: \url{www.cs.york.ac.uk/circus/CyPhyAssure/}.%
} (Grant EP/S001190/1), RoboCalc (Grant EP/M025756/1), and RoboTest (Grant EP/R025479/1).
The icons used in RoboChart have been made by Sarfraz Shoukat, Freepik, Google, Icomoon and Madebyoliver from \url{www.flaticon.com} and are licensed under CC 3.0 BY.

%\vspace{-2ex}

%\bibliographystyle{elsarticle-num-names} 

\bibliographystyle{elsarticle-num} 
\bibliography{main}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifdefined \CHANGES \indexprologue{%
  This index lists for each comment the pages where the text has been modified to address the comment. Since the same page may contain multiple changes, the page number contains the index of the change in superscript to identify different changes. Finally, the page number contains a hyperlink that takes the reader to corresponding change.%
}%
\printindex[changes] \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
