%\documentclass[envcountsect,envcountsame,runningheads,a4paper]{elsarticle} 
\documentclass[preprint,
    10pt,
%    authoryear,
    3p,
    fleqn,
%    times
]{elsarticle}

\usepackage{main}

% \allowdisplaybreaks

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
% \usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\newcommand{\cmt}[1]{\textnormal{\color{Maroon}\{#1\}}}
% Useful packages

%\usepackage[colorlinks=true,allcolors=blue]{hyperref}

\begin{document}

\begin{frontmatter}

  \title{Formally Verified Animation for RoboChart using Interaction Trees\tnoteref{t1,t2}}

  \tnotetext[t1]{This document presents results from the research project CyPhyAssure (\url{www.cs.york.ac.uk/circus/CyPhyAssure/}) funded by EPSRC.}

  \author[1]{Kangfeng Ye\corref{cor1}}

  \ead{kangfeng.ye@york.ac.uk}

  \author[1]{Simon Foster}

  \ead{simon.foster@york.ac.uk}

  \author[1]{Jim Woodcock}

  \ead{jim.woodcock@york.ac.uk}

  \cortext[cor1]{Corresponding author}

  % \fntext[fn1]{This is the first author footnote.}
  % \fntext[fn2]{Another author footnote, this is a very long 
  % footnote and it should be a really long footnote. But this 
  % footnote is not yet sufficiently long enough to make two 
  % lines of footnote text.}
  % \fntext[fn3]{Yet another author footnote.}

  \affiliation[1]{%
    organization={Department of Computer Science, University of York},
    addressline={Deramore Lane, Heslington},
    postcode={YO10 5GH},
    city={York},
    country={United Kingdom}
  }%
  
  \begin{abstract}
    RoboChart is a core notation in the RoboStar framework. It is a timed and probabilistic domain-specific and state machine-based language for robotics. RoboChart supports shared variables and communication across entities in its component model. It has formal denotational semantics given in CSP. The semantic technique of Interaction Trees (ITrees) represents behaviours of reactive and concurrent programs interacting with their environments. Recent mechanisation of ITrees, along with ITree-based CSP semantics and a Z mathematical toolkit in Isabelle/HOL, bring new applications of verification and animation for state-rich process languages, such as RoboChart. In this paper, we use ITrees to give RoboChart a novel operational semantics, implement it in Isabelle, and use Isabelle's code generator to generate verified and executable animations. We illustrate our approach using an autonomous chemical detector model and a patrol robot model additionally exhibiting nondeterminism and using shared variables. With animation, we show two concrete scenarios for the chemical detector when the robot encounters different environmental inputs and three concrete scenarios for the patrol robot when its calibrated position is in different sections of a corridor. We also verify that the animated scenarios are truly trace refinements of the CSP denotational semantics of the RoboChart models using FDR, a refinement model checker for CSP. This supports the soundness of our approach that the use of CSP operators with priority resolves nondeterminism correctly.
    % \\
    % \textbf{Keywords}: interaction trees, CSP, animation, theorem proving, RoboChart, code generation, robotic software, operational semantics
  \end{abstract}
  
  \begin{keyword}
    Interaction trees\sep CSP\sep animation\sep theorem proving\sep RoboChart\sep code generation\sep robot software\sep operational semantics\sep nondeterminism.
  \end{keyword}
  
\end{frontmatter}

% \maketitle % not necessary 

\section{Introduction}
\label{sec:intro}

The RoboStar%
\footnote{%
  \url{robostar.cs.york.ac.uk}.%
} framework~\cite{Cavalcanti2021} brings modern modelling and verification technologies into software engineering for robotics.  In this framework, models of the platform, environment, design, and simulations are given formal semantics in a unified semantic framework~\cite{Hoare1998}.  Correctness of simulation is guaranteed with respect to particular models using a variety of analytical technologies including model checking, theorem proving, and testing.  Additionally, modelling, semantics generation, verification, simulation, and testing are automated and integrated into an Eclipse-based tool, RoboTool.%
\footnote{%
  \url{robostar.cs.york.ac.uk/robotool/}.%
} The core of RoboStar is RoboChart~\cite{Miyazawa2019,Ye2021}, a timed and probabilistic domain-specific language for robotics, which provides UML-like architectural and state machine modelling notations.  RoboChart is distinctive in its formal semantics~\cite{Miyazawa2019,Woodcock2019,Ye2021}, which enables automated verification using model checking and theorem proving~\cite{Ye2021a}.

Previous work~\cite{Miyazawa2019} gives RoboChart a denotational semantics based on the CSP process algebra~\cite{Hoare1985,Roscoe2011}.  This paper defines direct operational semantics for RoboChart using Interaction Trees (ITrees)~\cite{Xia2019}. ITrees are coinductive structures that can model infinite behaviours of a reactive system interacting with its environment.  ITrees have been mechanised in both Coq~\cite{Xia2019} and Isabelle/HOL~\cite{Foster2021}.  ITrees are a powerful semantic technique for the development of formal semantics that can unify trace-based failures-divergences semantics~\cite{Brookes1984,Roscoe2011} for CSP and transition-based operational semantics, and so unifies verification and animation~\cite{Foster2021}.  In previous work~\cite{Foster2021}, we have proved a formal correspondence between the failures-divergences model and our ITree-based semantics.

% Recent work~\cite{Foster2021} on mechanisation of Interaction Trees (ITrees)~\cite{Xia2019} in Isabelle/HOL introduces a verification and animation framework for state-rich process languages. In particular, the CSP process algebra~\cite{Hoare1985,Woodcock2004} has been given an ITree-based semantics.  , which is formally linked to the standard failures divergences semantic model.  This brings new applications for the work. Such an application is verification and animation of

% This work aims at the animation and verification of RoboChart using ITrees, which is based on code generation~\cite{Haftmann2010} in Isabelle/HOL. Existing potential accounts of animation of a RoboChart model through its CSP semantics include Probe in FDR~\cite{GABR14} and the ProB animator~\cite{Leuschel2003}.\footnote{\url{https://prob.hhu.de/w/index.php?title=Main_Page}} %, expose all internal choices (nondeterministic choice) to users, which makes the animation at a very low level and not efficient because users need to make so many choices of events. This is not convenient even for experts, not alone for normal users.
%
% These animators support machine-readable CSP (or CSP-M) and can only deal with a subset of RoboChart's types and expressions which are based on the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}~\cite{Spivey1992,Woodcock1996}. They also cannot solve preconditions and postconditions in function definitions, and so require users to supply explicit implementations.

The existing implementation of RoboChart's semantics in RoboTool is restricted to machine-readable CSP (or CSP-M) for verification with FDR~\cite{GABR14}, and so only a subset of RoboChart's rich types and expressions can be supported and quantified predicates cannot be solved.  Our contribution here is a richer ITree-based CSP semantics for RoboChart to address these restrictions.
%
% We use ITree-based CSP to implement RoboChart's semantics in Isabelle/HOL, and then utilise the code generator~\cite{Haftmann2010} to produce Haskell code for animation. Our approach supports all types and expressions of RoboChart %(thanks to the mechanised Z mathematical toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.}~\cite{Spivey1992} in Isabelle/HOL)
% and can solve preconditions and postconditions of function definitions effectively.
Our semantics also allows us to characterise systems with an infinite number of states symbolically, avoiding the need to generate an explicit transition system.
% (though we cannot directly animate them).
%
% Different from the standard CSP which is stateless, the ITree-based CSP is stateful and a process may return a value (or state) in addition to normal interactions through events.  The data model of the ITree-based CSP is based on that of Isabelle/HOL and the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}~\cite{Spivey1992,Woodcock1996}. Because RoboChart is state-rich and also has its data model in Z, our approach supports more data types and expressions than other animation methods.  that are based on RoboChart's CSP semantics, such as Probe and ProB.  Functions of RoboChart, defined by preconditions and postconditions that usually involve quantifier or lambda expressions, also cannot be implemented in the CSP semantics for these animation methods automatically. Our approach, however, can solve these preconditions and postconditions, and so function definitions can be automated.
%
We mechanise the semantics in Isabelle/HOL and then utilise the code generator~\cite{Haftmann2010} to produce Haskell code for animation. Isabelle's code generator~\cite{Haftmann2010} translates executable definitions in the source HOL logic to target functional languages (such as SML and Haskell) and the translation preserves semantic correctness using high-order rewrite systems~\cite{Mayr1998}.
% in two stages via an intermediate language. The source and the intermediate language in the first stage are both given equational semantics in terms of higher-order rewrite systems~\cite{Mayr1998}. Then in the second stage, a semantic preservation dictionary translation [12] is applied to the intermediate language.
As a result, the semantics of the source logic in Isabelle is preserved during code generation via translation to target functional languages. Our animation, therefore, is formally verified with respect to RoboChart's semantics in ITrees. Thanks to the equational logic, functional algorithms and data refinement are supported in code generation, so less efficient algorithms and data structures, that are used for verification in Isabelle, can be replaced with more efficient ones for animation.
% For example, associative lists are used in our animation as an implementation of partial functions.

% Code generation also provides a concrete implementation of RoboChart controllers, which could enable us to develop verified ROS~\cite{Quigley2009} nodes using RoboChart.  %because of guaranteed partial correctness~\cite{Haftmann2010} in code generation.

% Unlike ProBE and ProB which must be used completely from the generated CSP code for a RoboChart model, our approach leverages the model itself. The counterpart of the model in ITrees benefits from this approach in that some information lost during the generation of CSP code is still present, such as Z types and expressions.  (such as primitive types.)

Our technical contributions are as follows: we %
\begin{inparaenum}[(1)] \item implement extra CSP operators (generalised choice, interrupt, exception, and renaming) which are required to support the RoboChart semantics, and new CSP operators with priority (hiding with priority and renaming with priority) to resolve nondeterminism in RoboChart based on an order; %
\item implement a bounded sequence type for code generation; %
\item use the new concepts to define an ITree-based operational semantics for RoboChart; %
\item implement the semantics of two RoboChart models for case studies; and %
\item apply our animator to explore the behaviour of the models. %
\end{inparaenum}
%
With our mechanisation and animation, we have detected a number of issues in one RoboChart model, explored the semantics of shared variables in RoboChart, and resolved nondeterminism in a particular way. Specifically, the prioritised renaming operator uses the order in which transitions are given in the renaming mappings to resolve nondeterminism. The benefit of resolving nondeterminism statically in semantics, instead of dynamically in the animator, is that animation becomes more automatic, since the user only needs to resolve external choice and not nondeterministic choice. There is no need to overcome the big $\tau$ diamonds~\cite{Roscoe2011} as in the animator of ProB~\cite{Leuschel2003} and FDR~\cite{GABR14}. All definitions and theorems in this paper are mechanised and accompanying icons (\isalogo) link to corresponding repository artefacts.
%

The remainder of this paper is organised as follows. In Sect.~\ref{sec:robochart}, we introduce RoboChart through two examples: an autonomous chemical detector model and a patrol robot model.
% and discuss its CSP semantics.
Section~\ref{sec:itree} briefly describes the mechanisation of ITrees in Isabelle and presents the extra CSP operators in detail. Then we present the RoboChart semantics in ITrees in Sect.~\ref{sec:rc_to_itrees}, exemplified using the two models, and illustrate several scenarios for the two models in Sect.~\ref{sec:animation} using animation. We review related work in Sect.~\ref{sec:related} and conclude in Sect.~\ref{sec:concl}.

This paper is an extension of \cite{Ye2022}. It adds a new generalised choice operator, redefines the CSP external choice operator using the generalised choice, and introduces biased external choice operators in Sect.~\ref{ssec:itree_genchoice}. This work also gives the ITrees-based semantics to shared variables in RoboChart and resolves nondeterminism in the semantics using the new CSP operators with priority defined in Sects.~\ref{ssec:itree_hiding_with_priority} and \ref{ssec:itree_renaming_with_priority}. The semantics for shared variables and nondeterminism are exemplified in a new case study introduced in Sect.~\ref{ssec:robochart_patrol} and illustrated in Sect.~\ref{ssec:animation_patrol} for its animation. We also add substantial details in Sect.~\ref{sec:rc_to_itrees} to give a clear understanding of our semantics for RoboChart with examples from the two models, including new subsections: Sect.~\ref{ssec:semantics_overview} to give an overview of RoboChart semantics, Sect.~\ref{ssec:semantics_channels} about channels and alphabet transformation, and Sect.~\ref{ssec:semantics_operation} to give semantics to operations in RoboChart. For the existing subsections, we give more details and examples to illustrate the semantics. In particular, Sect.~\ref{ssec:semantics_stm} is substantially extended to give semantics to state machines, not only its sketch but also its detailed definitions and examples for memories, different kind of nodes, and their composition in parallel. Similarly, Sects.~\ref{ssec:semantics_ctrl} and \ref{ssec:semantics_module} are also extended with examples.

\section{RoboChart}
\label{sec:robochart}

\changed[\C{0}]{
RoboChart is a state machine-based notation for the modelling of robotic applications. RoboChart also has a component model with notions of controller and module, in addition to state machines, to foster reuse. 
In a RoboChart model, physical robots are abstracted into robotic platforms through variables, events, and operations. 
%
We describe features of RoboChart for modelling controllers of robots using as two examples: an autonomous chemical detector~\cite{Hilder2012,Miyazawa2019,RoboChartRef} in Sect.~\ref{ssec:robochart_chemical} and a patrol robot in Sect.~\ref{ssec:robochart_patrol}.
We refer to the RoboChart reference manual~\cite{RoboChartRef} for a complete account of the notation and its semantics.
}

\subsection{Autonomous chemical detector}
\label{ssec:robochart_chemical}
The robot is equipped with sensors to 
\begin{inparaenum}[(1)]
\item analyse the air to detect dangerous gases;  
\item detect obstacles; and
\item estimate change in position (using an odometer).
\end{inparaenum}
The controller of the robot performs a random walk with obstacle avoidance. Upon detecting a chemical with its intensity above a threshold, the robot drops a flag and stops there.
This model\footnote{\url{https://robostar.cs.york.ac.uk/case_studies/autonomous-chemical-detector/autonomous-chemical-detector.html}}~\cite{Miyazawa2019} has been studied and analysed in RoboTool, using FDR4,\footnote{\url{https://cocotec.io/fdr/}} a CSP refinement checker.
%, but not particularly studied in the animation aspect as we do here. We consider a specific version 3 of the models because it is the latest with more features of RoboChart at the time when we conducted this work. 

The top-level structure of a RoboChart model, a module, is shown in Fig.~\ref{fig:robochart_acd_module}. 
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=.90\textwidth]{Module.pdf}%
  \vspace{-2ex}
  \caption{The module of the autonomous chemical detector model.}%
\vspace{-4ex}
  \label{fig:robochart_acd_module}%
\end{figure}
%
The module \rcitem{ChemicalDetector} contains a robotic platform \rcitem{Vehicle} and two controller references \rcitem{MainController} and 
\rcitem{MicroController}. The physical robot is abstracted into the robotic platform through variables, events, and operations. The platform provides the controllers with services  
\begin{inparaenum}[(1)]
\item to read its sensor data through three events: \rcitem{gas}, \rcitem{obstacle}, and \rcitem{odometer};
\item for movement through three operations: \rcitem{move}, \rcitem{randomWalk}, and \rcitem{shortRandomWalk} as grouped in an interface \rcitem{Operations}; and 
\item to drop a flag through receiving a \rcitem{flag} event.
\end{inparaenum}
\changed[\C{0}]{These services represent observable behaviour or external interaction of the controllers with the physical robot. The controllers \rcitem{MainController} is responsible for gas analysis and \rcitem{MicroController} accounts for the robot movement with obstacle avoidance. 
}

A platform and controllers communicate using directional connections. {For example, the platform is linked to \rcitem{MainController} through an asynchronous connection on event \rcitem{gas} of type \rcitem{seq(GasSensor)}, sequences of type \rcitem{GasSensor}.} Furthermore, the \rcitem{MainController} and \rcitem{MicroController} interact using the events \rcitem{turn}, \rcitem{stop}, and \rcitem{resume} \changed[\C{0}]{to allow \rcitem{MainController} to instruct \rcitem{MicroController} to \emph{turn} towards the location where the gas is detected, \emph{stop} the robot if the gas is dangerous, or \emph{resume} its movement behaviour (by ignoring the current movement operation) if no gas is detected. These interactions are the internal behaviour of controllers and are not observable.}

% \changed[\C{0}]{
% Generally, the robot controllers behave as follows:
% \begin{inparaenum}[(1)]
% \item \rcitem{MainController} gets the gas sensor reading via event \rcitem{gas} and then analyses it to decide whether a chemical is detected or not, and upon detection, whether the intensity is over or below a threshold;
% \item if no chemical is detected, the controller \rcitem{resumes} and is ready to continue to read and analyse;
% \item if a chemical is detected but the intensity is low, the controller sends an asynchronous communication to \rcitem{MicroController} to \rcitem{turn} towards the spot and the controller itself continues to read and analyse;
% \item otherwise, the controller requests \rcitem{MicroController} to \rcitem{stop} the robot, and then \rcitem{MicroController} requests the platform to drop a \rcitem{flag} on the spot.
% \end{inparaenum} 
% }

\changed[\C{0}]{
\begin{figure}
  \centering%
  \includegraphics[width=.95\textwidth]{Chemical.pdf}%
  \caption{The Chemical package of the autonomous chemical detector model.}%
  \label{fig:robochart_acd_chemical}%
\end{figure}
}

The types used in the module are defined in the two imported packages: \rcitem{Chemical} and \rcitem{Location} %(whose diagrams are omitted here for simplicity). 
\changed[\C{0}]{shown in Figures~\ref{fig:robochart_acd_chemical} and~\ref{fig:robochart_acd_location}. 
The \rcitem{Chemical} package declares primitive types \rcitem{Chem} and \rcitem{Intensity}, enumerations \rcitem{Status} and \rcitem{Angle}, a record \rcitem{GasSensor} containing two fields (\rcitem{c} of type \rcitem{Chem} and \rcitem{i} of type \rcitem{Intensity}), and five functions specified using preconditions and postconditions (in the original model, two are specified and three are unspecified).
%An operation \rcitem{changeDireciton} in Fig.~\ref{fig:robochart_acd_location}, with a parameter \rcitem{l} of type \rcitem{Loc} and a constant \rcitem{lv}, is also defined using a state machine. 
%
\begin{figure}
  \centering%
  \includegraphics[width=.65\textwidth]{Location.pdf}%
  \caption{The Location package of the autonomous chemical detector model.}%
  \label{fig:robochart_acd_location}%
\end{figure}
%
The \rcitem{Location} package declares an enumeration \rcitem{Loc} and defines an operation \rcitem{changeDireciton} using a state machine. The operation has a parameter \rcitem{l} of type \rcitem{Loc} and a constant \rcitem{lv}.
Basically, this operation aims to move the robot in the opposite direction of the currently detected gas location \rcitem{l} using a constant linear velocity \rcitem{lv}.

\rcitem{MainController}, defined in the left diagram of Fig.~\ref{fig:robochart_acd_gasanalysis},  is implemented using a state machine \rcitem{GasAnalysis} (by a contained reference to the machine), presented in the right diagram of Fig.~\ref{fig:robochart_acd_gasanalysis}.
}
%\changed[\C{0}]
{
\begin{figure}[t]
  \centering%
  \includegraphics[width=0.4\textwidth]{MainController.pdf}%
  \includegraphics[width=0.6\textwidth]{GasAnalysis.pdf}%
  \vspace{-2ex}
  \caption{\rcitem{MainController} and GasAnalysis state machine of the autonomous chemical detector model.}%
  \vspace{-4ex}
  \label{fig:robochart_acd_gasanalysis}%
\end{figure}
}
\changed[\C{0}]{
\noindent
The machine \rcitem{GasAnalysis} declares one constant \rcitem{thr} of type \rcitem{Intensity} for the intensity threshold, and four variables (\rcitem{gas} of \rcitem{Seq(GasSensor)}, \rcitem{st} of \rcitem{Status}, \rcitem{i} of \rcitem{Intensity}, and \rcitem{a} of \rcitem{Angle}) for a sequence of gas sensor readings (from the platform), and the gas analysis results including its status (either no gas \rcitem{NoGas} or a gas \rcitem{gasD} detected), intensity and angle. 
The machine also contains a variety of nodes: one initial junction (\includegraphics[align=c,height=8pt]{initial.pdf}), seven normal states such as \rcitem{NoGas} and \rcitem{Analysis}, and a final state (\includegraphics[align=c,height=8pt]{final24.png}). A state may have an \rcitem{entry} action such as an assignment of \rcitem{st} from an application of function \rcitem{analysis} to \rcitem{gs} in the state \rcitem{Analysis}, an exit action, or a \rcitem{during} action.

In state machines, transitions connect states and junctions. Transitions have a label with optional features: a trigger event, a clock reset, a guard condition, and an action. For example, 
the transition of \rcitem{GasAnalysis} from \rcitem{NoGas} to \rcitem{Analysis} has an input trigger \rcitem{gas?gs} enabling the machine to receive sensor readings from the channel \rcitem{gs} and store the value in the variable \rcitem{gs}, and the transition from \rcitem{GasDetected} to \rcitem{Reading} has a guard (\rcitem{not goreq(i, thr)}) and an action (\rcitem{a=location(gs); turn!a}) which is a sequential composition of an assignment and an output communication (\rcitem{turn!a}) enabling the machine to send the angle \rcitem{a} of the detected gas over the channel \rcitem{turn}.

This machine gives the behaviour of the robot's gas analysis: 
\begin{inparaenum}[(1)]
\item enter the state \rcitem{NoGas} after the transition from the initial junction is taken;
\item wait for the gas sensor to be ready on channel \rcitem{gs}, then receive readings, recorded in \rcitem{gs}, on the channel from the platform (via connections from \rcitem{MainController}), and at the same time the transition to state \rcitem{Analysis} is taken;
\item upon entering the state \rcitem{Analysis} whose entry action is executed first to analyse the sensor readings by the function \rcitem{analysis} and to record the result in variable \rcitem{st}; 
\item signal the event \rcitem{resume} if no gas is detected (guard [\rcitem{st == noGas]}) and return to state \rcitem{NoGas};
\item go to state \rcitem{GasDetected} otherwise (guard [\rcitem{st == gasD]});
\item upon entering the state \rcitem{GasDetected} whose entry action is executed to determine the intensity by the function \rcitem{intensity} and to record the result in variable \rcitem{i}; 
\item {signal \rcitem{stop} if the intensity \rcitem{i} is larger than or equal to (implemented in function \rcitem{goreq}) the intensity threshold \rcitem{thr}, and terminate by going to the final state;}
\item {take the transition to state \rcitem{Reading} otherwise with the action of the transition being executed to determine the angle \rcitem{a} of the detected gas and signal \rcitem{turn} towards the angle;}
\item {try to read the gas sensor again at state \rcitem{Reading} with its only outgoing transition, and if the transitions is taken, the machine is back to state \rcitem{Analysis}.}
\end{inparaenum}
}

\rcitem{MicroController}, defined in Fig.~\ref{fig:robochart_acd_microcontroller},  is implemented using a state machine \rcitem{Movement} (by a contained reference), presented in Fig.~\ref{fig:robochart_acd_movement}, and a reference to the operation \rcitem{changeDireciton}.
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=0.6\textwidth]{MicroController.pdf}%
  %\vspace{-2ex}
  \caption{\rcitem{MicroController} of the autonomous chemical detector model.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_microcontroller}%
\end{figure}
%
\begin{figure}[t]
  \centering%
  \includegraphics[width=1.0\textwidth]{Movement.pdf}%
  %\vspace{-2ex}
  \caption{Movement state machine of the autonomous chemical detector model.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_movement}%
\end{figure}
%
\noindent
The machine \rcitem{Movement} declares various constants such as \rcitem{lv} for linear velocity, four variables (\rcitem{a}, \rcitem{d0}, \rcitem{d1}, and \rcitem{l}) for the preservation of values (angle, odometer readings, and location) carried on communication, and a clock \rcitem{T}. The machine also contains one initial junction, seven normal states such as \rcitem{Waiting} and \rcitem{Going}, and a final state. Notably, the state \rcitem{Waiting} has a \rcitem{during} action, an operation call \rcitem{randomWalk()}, which provides parallelism in a machine and means the robot is doing a random walk at the state. This operation can be interrupted at any time as long as a transition from the state is taken.  
The transitions of this machine have labels with various features. The transition from \rcitem{Going} to \rcitem{Avoiding} has an input trigger \rcitem{obstable?l} and a clock reset \rcitem{\rcreset T}, and the transition from \rcitem{TryingAgain} to \rcitem{AvoidingAgain} has an input trigger and an action \rcitem{odometer?d1} (an input communication). The transition from \rcitem{AvoidingAgain} to \rcitem{Avoiding} has a clock reset \rcitem{\rcreset T} and a {disjunctive} guard in which \rcitem{since(T)} counts the elapsed time since the last reset of \rcitem{T}.

This machine gives the behaviour of the robot's response to outcomes of the chemical analysis: 
\begin{inparaenum}[(1)]
\item \rcitem{resume} to state \rcitem{Waiting} {if no gas is detected (implemented in \rcitem{GasAnalysis})};
\item \rcitem{stop} to state \rcitem{Found} and then terminate {, if a gas above the threshold is detected};
\item \rcitem{turn} {to the direction, where a gas is detected but not above the threshold, with obstacle avoidance in state \rcitem{Going}};
\item {upon the first detection of an \rcitem{obstacle}, reset \rcitem{T} and start \rcitem{Avoiding} with an initial \rcitem{odometer} reading and the movement direction changed (software \rcitem{wait}s for \rcitem{evadeTime} for the effect of that change);}
\item {if a gas is still detected after the changed direction, \rcitem{TryingAgain} to \rcitem{turn} and \rcitem{move} to the gas direction;}
\item {if another obstacle is detected during avoidance, \rcitem{AvoidingAgain} by reading the \rcitem{odometer} to check the distance of two obstacles;}
\item {if the robot has moved far enough between the two obstacles or not got stuck long enough, go back to continue \rcitem{Avoiding};}
\item {otherwise, the robot has got stuck in a corner, use a \rcitem{shortRandomWalk} for \rcitem{GettingOut} of the area, then resume normal activities.}
\end{inparaenum}

% Next, we describe RoboChart's semantics and return to this model in Sect.~\ref{sec:rc_to_itrees}.
% 
% %\subsection{CSP Semantics}
% %\label{ssec:robochart_csp}
% RoboChart~\cite{Miyazawa2019,RoboChartRef} has formal semantics in CSP.
% % of its core language in CSP and its timed language in tock-CSP~\cite{Baxter2021}. 
% Its untimed semantics ignores timed constructs, such as \rcitem{\#T}, \rcitem{since(T)}, and \rcitem{wait}. 
% %When RoboTool generates the core semantics of RoboChart models, it ignores timed constructs. For example, the clock reset \rcitem{\#T}, the two guards having a timed expression \rcitem{since(T)}, and the \rcitem{wait} action are ignored. 
% Our animation in this paper is based on untimed semantics which is also generated and used for untimed analysis with FDR in RoboTool.
% 
% The CSP semantics of RoboChart modules, controllers, and state machines is given by processes. The semantics of a model is just the semantics of its module, a CSP process defined by a parallel composition of the processes for its controllers and a memory process for its platform (to record the variables 
% of the platform for sharing between the controllers), synchronising the events according to the connections between the controllers and the platform. 
% 
% Similarly, the semantics of a controller is the parallel composition of the processes for its state machines and memory processes for its variables, synchronising events according to the connections between state machines and the controller.
% %
% The semantics of a state machine is the parallel composition of a process for its state machine behaviour and memory processes for its variables and transitions. We also note the semantics of operations, such as \rcitem{changeDirection}, that are defined using a state machine, provided by a controller, and called in this state machine, are also part of that of this state machine: not only the state machine behaviour but also the memory processes.

%The next section describes interaction trees in Isabelle/UTP, on which the CSP semantics of RoboChart is implemented in this paper.

\changed[\C{0}]{
\subsection{One-dimensional patrol robot}
\label{ssec:robochart_patrol}

\begin{figure}[t]
  \centering%
  \includegraphics[width=0.7\textwidth]{patrol.pdf}%
  \vspace{0ex}
  \caption{Sections for the patrol robot: S1 - adjacent to the left boundary; S2 - central area; S3 - adjacent to the right boundary.}%
  \vspace{0ex}
  \label{fig:robochart_patrol_sections}%
\end{figure}
In addition to the features introduced in the chemical detector example, RoboChart also supports abstraction via nondeterministic choice and interaction via shared variables, which is exemplified in the model for a one-dimensional patrol robot on a corridor. 
The corridor, as shown in Fig.~\ref{fig:robochart_patrol_sections}, is split into three sections by four boundaries, denoted by their coordinates: \rcitem{-MAX\_INT}, \rcitem{-MAX}, \rcitem{MAX}, and \rcitem{MAX\_INT}. The left and right boundaries are hard and represent the walls, and the other two are soft and represent controlled limits. Section S2, soft boundaries exclusive, is the central working area. The sections S1 and S3, soft boundaries inclusive, are limited sections and the robot will tend to move to S2 if it is in these sections. 

Basically, the control software of this patrol robot behaves as follows: 
\begin{inparaenum}[(1)]
\item it maintains a belief state ($x$) of the robot, default at 0 (denoting the centre of the corridor) and able to reset to 0 by an event \rcitem{reset};
\item when $x$ is 0, it can be calibrated to the actual position of the robot from its sensor by a \rcitem{cal} event; 
\item when $x$ is within S2, it can be either increased or decreased by 1, denoting the robot moves either to the left or to the right nondeterministically;  
\item when $x$ is within S1, it can only be increased by 1, denoting the robot moves to the right; and 
\item when $x$ is within S3, it can only be decreased by 1, denoting the robot moves to the left.
\end{inparaenum}

\begin{figure}[t]
  \centering%
  \includegraphics[width=1.0\textwidth]{system.pdf}%
  \vspace{0ex}
  \caption{A RoboChart model for a patrol robot with nondeterministic behaviour and interaction using shared variables.}%
  \vspace{0ex}
  \label{fig:robochart_patrol}%
\end{figure}
We illustrate in Fig.~\ref{fig:robochart_patrol} the RoboChart model for this patrol robot. The module \rcitem{PatrolMod} contains a robotic platform \rcitem{RP} and a controller \rcitem{Ctrl} composed of two state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. \rcitem{RP} declares two output events \rcitem{cal} of type \rcitem{int} and \rcitem{reset}, and two inputs events \rcitem{left} and \rcitem{right} (to indicate the direction of moving and its new position) of type \rcitem{int} through the interface \rcitem{eventsInf}, and provides a variable \rcitem{x} of type \rcitem{int} through the interface \rcitem{dataInf}. This variable is shared in \rcitem{Ctrl} and also to the two machines by requesting \rcitem{dataInf}.

The machine \rcitem{CalSTM} sets \rcitem{x} to 0 in the action (\rcitem{x=0}) of its default transition \rcitem{t0} to state \rcitem{cal}, and then it is ready for calibration from the input trigger \rcitem{cal?l} of the transition \rcitem{t1} if \rcitem{[x==0]}, or to update $x$ (the action \rcitem{update!x} of the transition \rcitem{t2} ) to \rcitem{MoveSTM} through a connection on event \rcitem{update} of type \rcitem{int} otherwise \rcitem{[x!=0]}. We note that it is not mandatory to use this communication mechanism to update \rcitem{x} to \rcitem{MoveSTM} because \rcitem{x} is shared in \rcitem{MoveSTM} too. We use this way here to illustrate how nondeterminism is introduced in \rcitem{MoveSTM} and how it interleaves with the shared variable. 

The machine \rcitem{MoveSTM} is responsible for resetting \rcitem{x} (\rcitem{x=0}) by the self-transition \rcitem{t2} of state \rcitem{move} with trigger \rcitem{reset}, and the robot movement around the corridor based on the value (of variable \rcitem{x}) which passes on \rcitem{update} and stored in a local variable \rcitem{l} by the other two self-transitions (\rcitem{t1} and \rcitem{t3}) from state \rcitem{move}. If \rcitem{l} is larger than \rcitem{-MAX} (guard \rcitem{[l>-MAX]} of \rcitem{t3} where \rcitem{MAX} is a constant variable), denoting sections S2 and S3, \rcitem{x} is updated to \rcitem{l-1}, followed by a \rcitem{left!x} event. If \rcitem{l} is less than \rcitem{MAX} (guard \rcitem{[l<MAX]} of \rcitem{t1}), denoting sections S2 and S1, \rcitem{x} is updated to \rcitem{l+1}, followed by a \rcitem{right!x} event. Consequently, if \rcitem{l} is in section S2, the choice between the two transitions is nondeterministic. We note that \rcitem{MAX\_INT} is not explicitly declared in the model and will be given in verification or animation where \rcitem{int} is bounded. 

Next, we describe the extra ITree-based CSP operators in order for the RoboChart semantics and return to the two models in Sect.~\ref{sec:rc_to_itrees}.
}

\section{Interaction trees}
\label{sec:itree}
In this section, we briefly introduce interaction trees and extend our existing CSP semantics with additional operators to support the RoboChart semantics. These include three operators (interrupt,  exception,  and renaming) that are introduced in the previous work~\cite{Ye2022}, one generalised choice operator and two prioritised variants of hiding and renaming operators introduced in this extension paper.
%\begin{inparaenum}[(1)]
%\item three operators (interrupt,  exception,  and renaming) that are introduced in the previous work~\cite{Ye2022}, 
%\item one generalised choice operator that is useful to define various choice operators such as redefined external choice and newly introduced biased choice operators, % to statically resolve nondeterminism, 
%\item the prioritised variants of hiding and renaming to statically resolve nondeterminism based on an order.
%This section describes the definition of interaction trees, its data model, and existing CSP constructs briefly first, %in Sect.~\ref{ssec:itree_background}, and then gives semantics to three newly defined CSP operators (interrupt,  exception,  and renaming).% in Sect.~\ref{ssec:itree_csp}.
%\end{inparaenum}

%\subsection{Preliminaries}
%\label{ssec:itree_background}
Interaction trees (ITrees)~\cite{Xia2019} are a data structure for modelling reactive systems that interact with their environment through events. They are potentially infinite and defined as coinductive trees%~\cite[Definition 1]{Foster2021}
~\cite{Blanchette2014} 
in Isabelle/HOL.
% through the command \isakwmaj{codatatype}. %shown in Definition~\ref{def:itrees}.
%\begin{definition}[Interaction Trees]
%\label{def:itrees}
\newcommand{\itreedef}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/Interaction_Trees.thy\#L22}}
\begin{alltt}
\isakwmaj{codatatype} (\textquotesingle{e}, \textquotesingle{r}) itree = \(\itreedef\) 
  Ret \textquotesingle{r} | Sil "(\textquotesingle{e}, \textquotesingle{r}) itree" | Vis "\textquotesingle{e} \(\pfun\) (\textquotesingle{e}, \textquotesingle{r}) itree"
\end{alltt}
%\end{definition}
\noindent ITrees are parameterised over two types: \texttt{\textquotesingle e} for events ($E$), and \texttt{\textquotesingle r} for return values or states ($R$) . Three possible interactions are provided: 
\begin{inparaenum}[(1)]
	\item $\Ret~x$: termination ($\tick_x$) with a value $x$ of type $R$ returned;
	\item $\Sil~P$: an internal silent event ($\tau P$,  for a successor ITree $P$); or
	\item $\Vis~F$: a choice among several visible events represented by a partial function $F$ of type $E \pfun (E,R) \cspkey{itree}$.
%; the choice of visible events and their continuation are represented as a partial function $F$ of type $E \pfun (E,R) \cspkey{itree}$.
\end{inparaenum}
Partial functions are part of the Z toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.}~\cite{Spivey1992} which is also mechanised in Isabelle/HOL.

Deterministic CSP processes can be given executable semantics using ITrees. The determinism is inherent, since we use a partial function to model events and their continuations. Specifically, each unique event must map to at most one continuation. The benefit of this approach is that ITrees are easy to implement and animate, since the behaviour depends solely on provided input events. Therefore, our CSP operators cannot introduce nondeterminism, which must be statically resolved.

Our animator takes a model with an ITree-based semantics in Isabelle/HOL, and generates Haskell code for the underlying ITree. Though this often an infinite structure, Haskell's intrinsic use of lazy evaluation allows to model and partially evaluate infinite objects. We can therefore step through an ITree's behaviour by unfolding the various constructors of the underlying algebraic (co)datatype. When a $\Vis$ constructor is encountered, the user is presented with a choice for one of the enabled events. When a $\Sil$ is encountered, it is simply removed and the successor ITree animated. This allows us to compress long sequences of $\tau$ events, and so simplified animation. Finally, $\Ret$ leads to termination of the animation.

%These processes are parametrised over a type $E$ of events, which is declared through the \isakwmaj{chantype} command, representing the event alphabet ($\Sigma$) of the CSP processes. $E$ is expressed by a finite set of channels declared in the command.  
%Each channel $c$ is modelled by a prism~\cite{Pickering2017}: $V \pto E$ where $V$ is the value type of $c$. Each prism contains two functions~\cite[Definition 5]{Foster2021}: a destructor \IsaKey{match} and a constructor \IsaKey{build}. We use \IsaKey{c\_C} for \IsaKey{build}$_c$. %Example~\ref{ex:chantype} illustrates the creation of such an event alphabet \texttt{chan}.
%
%\begin{example}[Event alphabet and channels]\label{ex:chantype}
%\isalink{https://github.com/isabelle-utp/interaction-trees/blob/666527fb6e860ea79e94a8258f87e2669c1eddf8/examples/ITree_CSP_Examples.thy\#L25}
%\begin{alltt}
%\isakwmaj{chantype} chan = 
%  	Input::integer     Output::integer     State::"integer list"
%\end{alltt}
%\end{example}
%
%\noindent This \texttt{chan} is expressed by three channels: \texttt{Input} and \texttt{Output} of type \texttt{integer}, and \texttt{State} of type integer lists. These channels are characterised through prisms~\cite{Pickering2017} ($V \pto E$ where $V$ is the value type of a channel). Each channel in \texttt{chan} is modelled by a prism. For example, the channel \texttt{Input},  carrying a value of \texttt{integer}, has a type \texttt{integer~}$\pto$\texttt{~chan}. 
%
%CSP processes usually do not return a value and are typically of type \texttt{(E, unit) itrees}. Internal components of a CSP process, such as \texttt{input?x \(\then\) output!x \(\then\) skip}, however, could pass a value to the subsequent process in scope through binding in CSP.
%

Previously, the following CSP processes and operators have been defined: 
\begin{inparaenum}[(1)]
	\item basic processes: \cspkey{skip}, \cspkey{stop}, and \cspkey{div}; % and  \cspkey{run};
    \item input prefixing: $\cspkey{inp}~c~V$ (communicate any value from $A$ over the channel $c$);%$\cspkey{inp}::(E \pto V) \Rightarrow \power V \Rightarrow (E, V) \cspkey{itree}$; 
	%\item \cspkey{inp}: an input event; 
	%\item \cspkey{outp}: an output event;
	%\item input prefixing $c?x$;
	\item output prefixing $c!v$;
	%\item $\cspkey{guard}~::~\Bool \Rightarrow (E, unit) \cspkey{itree}$;
	\item $\cspkey{guard}~b$;
	%\item $b \& P$
	\item external choice $P \extchoice Q$; 
	\item parallel composition $P \parallel_A Q$;
	\item hiding $P \hide A$; 
	\item sequential composition $P \fatsemi Q$; %$P \mbind Q$;
	%\item \cspkey{while} and two special cases: \cspkey{loop} and \cspkey{iter}.
	\item \cspkey{loop} and \cspkey{iterate}.
\end{inparaenum} Though operators like external choice and parallelism can introduce nondeterminism, we restrict this by construction. Nevertheless, different strategies can be employed for statically resolving nondeterminsim, which we explore further in this section.

%\subsection{Data model}
%The data model of ITrees is based on that of Isabelle/HOL and also the Z notation\footnote{\url{http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_IS O_IEC_13568_2002(E).zip}.}. For example, partial functions used in the definition of ITrees are part of the Z toolkit\footnote{\url{https://github.com/isabelle-utp/Z_Toolkit}.} which is also mechanised in Isabelle/HOL. Other examples in the toolkit that are mechanised for this work include partial injections ($\pinj$, \isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/b78103d556a528d5a7739c10fdcfdbe81a9396d7/Partial_Inj.thy}) and bounded lists: \texttt{('a, 'n::finite) blist} \isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/52c815c7f6b1c4f9259eacae4a23b020db58f6e9/Bounded_List.thy\#L10}, denoting a set of all lists of type \texttt{'a} 
%\verb+'a+ $'a$ \isa{\isacharprime a}
%, in which the length of each list is bounded by the cardinality of a finite type \texttt{'n}. A numeral type \texttt{2} is such a finite type that contains two elements: zero (\texttt{0::2}) and one (\texttt{1::2}).

%\subsection{CSP operators}
%\label{ssec:itree_csp}
Here, we give an ITree semantics to extra CSP operators to allow us to give an ITree-based semantics to RoboChart. We 
\begin{inparaenum}[(1)]
    \item generalise external choice; 
    \item introduce three new operators---interrupt, exception, and renaming operators---used in the RoboChart's semantics to allow interruption of a during-action, termination of a state machine, a controller, or a module, and alphabet transformation of processes; and 
    \item add prioritised variants of renaming and hiding to statically resolve nondeterminism based on an order.
\end{inparaenum}
% for parallel composition.
% The interrupt operator is used in the RoboChart's semantics to allow interruption of a during action by a taken transition.  The exception operator allows termination of a state machine,  a controller,  or a module.  Synchronisation and communication are defined via connections in RoboChart and they are realised in semantics using the renaming operator to rename events of corresponding processes because CSP relies on the name of events for synchronisation.
We restrict ourselves to deterministic operators as it makes the animation of large models more efficient. 

\subsection{Generalised choice and external choice}
\label{ssec:itree_genchoice}

Previously~\cite{Foster2021}, we have given a semantics to CSP's external choice operator as a corecursive definition. Our mechanisation of ITrees intrinsically supports external choice through the use of partial functions to model visible events. However, our definition of choice can be generalised to support more flexible choice schemes. For example, priority can be given to one branch of the choice, in order to statically resolve any nondeterminism. We achieve this through a novel generalised choice operator, $\genchoice{P}{\mathcal{M}}{Q}$. For this, we use a merge function $\mathcal{M}$, which merges two choice functions of type $E \pfun (E, R)\textit{itree}$. The operator is defined as a corecursive function using the equations listed below.

\begin{definition}[Generalised choice]\label{def:genchoice}
%$P \interrupt Q$ is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L169}
\begin{align*}
\arraycolsep=1.4pt
\begin{array}{rlrl}
    \genchoice{\left(\Vis~F\right)}{\mathcal{M}}{\left(\Vis~G\right)} &= \Vis~\left(\mathcal{M}~F~G\right)
    &\qquad \genchoice{\left(\Ret~x\right)}{\mathcal{M}}{\left(\Ret~y\right)} &= \left(\IF x = y \THEN \Ret~x \ELSE \cspkey{stop}\right)  \\ [3pt]
%
 \genchoice{\left(\Sil~P'\right)}{\mathcal{M}}{Q} &= \Sil~\left(\genchoice{P'}{\mathcal{M}}{Q}\right) 
 &\qquad \genchoice{P}{\mathcal{M}}{\left(\Sil~Q'\right)} &= \Sil~\left(\genchoice{P}{\mathcal{M}}{Q'}\right) \\ [3pt]
 \genchoice{\left(\Ret~v\right)}{\mathcal{M}}{\left(\Vis~G\right)} &= \Ret~v 
 &\qquad \genchoice{\left(\Vis~F\right)}{\mathcal{M}}{\left(\Ret~v\right)} &= \Ret~v\\ %[2pt]
%\qquad P \interrupt \left(\Sil~Q'\right) = \Sil~\left(P \interrupt Q'\right) \\ [1pt]
%\left(\Ret~x\right) \interrupt Q = \Ret~x 
%\qquad\qquad\quad\  P \interrupt \left(\Ret~x\right) = \Ret~x \\[1pt]
%\left(\Vis~F\right) \interrupt \left(\Vis~G\right)  = \Vis \left(
%\begin{array}{l}
%\left\{ e \mapsto \left(P' \interrupt Q\right) | \left(e \mapsto P' \right) \in \left(\ZKey{$\dom$}(G) \ndres F\right) \right\} 
%\oplus G
%%\\
%%\left\{ e \mapsto Q' | \left(e \mapsto Q' \right) \in G \right\}
%\end{array}
%\right) 
\end{array}
\end{align*}
\end{definition}

\noindent When making a choice between two visible event functions, $\Vis~F$ and $\Vis~G$, the merge function is applied to combine the two. When combining two return value ITrees, $\Ret~x$ and $\Ret~y$, we require that the two possible values are identical, and otherwise deadlock, to avoid nondeterminism. For silent events ($\tau$) and returns, we also prioritise their occurrence before any visible activity can occur. In particular, any $\tau$ events are greedily consumed before any visible event or return can occur.

With generalised choice, we can define external choice using a merge function $F \odot G \defs \left(\dom(G) \ndres F\right) \oplus \left(\\dom(F) \ndres G\right)$, and defining $P \extchoice Q \defs \genchoice{P}{\odot}{Q}$. This function combines all event maplets from $F$ and $G$, whilst ignoring any maplets whose events occur in the intersection $\dom(F) \cap \dom(G)$. For example $\{e_1 \mapsto P_1, e_2 \mapsto P_2\} \odot \{e_3 \mapsto P_3, e_2 \mapsto P_4\} = \{e_1 \mapsto P_1, e_3 \mapsto P_3\}$, since $e_2$ is ignored. This again avoids nondeterminism, and when the two domains are disjoint the operator can be considered as a union.

Another benefit of the generalised choice operator is that, as with Hoare and He's parallel-by-merge operator~\cite{Hoare1998}, properties of the choice operator reduce to properties of the merge function itself. This simplifies proofs of algebraic properties for choice functions. The most basic property of a merge function is well-formedness:

\begin{definition}[Wellformed merge function]
A merge function $\mathcal{M}$ is well-formed provided that for any choice function $F$, $\mathcal{M}~\emptyset~F = \mathcal{M}~F~\emptyset = F$.
\end{definition}

\noindent A wellformed merge function has the empty choice function $\emptyset$ as a left and right identity. For example, it is clear that $\odot$ is wellformed because $\dom(\emptyset) = \emptyset$. From this definition of wellformedness, we obtain the following properties.

\begin{thm}[Generalised choice] If $\mathcal{M}$ is well-formed, then 
\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L238}
\begin{align*}
    \genchoice{P}{\mathcal{M}}{\cspkey{stop}} =\,& \genchoice{\cspkey{stop}}{\mathcal{M}}{P} = P \\ 
    \genchoice{P}{\mathcal{M}}{\cspkey{div}} =\,& \genchoice{\cspkey{div}}{\mathcal{M}}{P} = \cspkey{div} \\
    \genchoice{P}{\mathcal{M}}{Q} =& \genchoice{Q}{\mathcal{M}^{\sim}}{P}
\end{align*}
\end{thm}

\noindent Generalised choice has $\cspkey{stop}$ as a unit, since it can add no further behaviour. Moreover, $\cspkey{div}$ is a zero since $\tau$ events always take priority, and so a diverge process prevents choices being made. We can commute a choice by taking the converse of the merge function, where $\mathcal{M}^{\sim} = (\lambda F~G.\, \mathcal{M}~G~F)$. As a result of the final law, if $\mathcal{M}$ is symmetric, that is $\mathcal{M} = \mathcal{M}^{\sim}$, then choice is commutative: $\genchoice{P}{\mathcal{M}}{Q} = \genchoice{Q}{\mathcal{M}}{P}$. From these properties, we can conclude that external choice is commutative and has $\cspkey{stop}$ as a unit. The former follows because $f \oplus g = g \oplus f$ whenever $\dom{f} \cap \dom{g} = \emptyset$, a property that is ensured by the construction of $\odot$.

We now consider how we can derive alternative choice schemes. In some circumstances, it may be undesirable that possible events are lost by the external choice. For example, $a \then P \extchoice a \then Q$ actually ends up as $\cspkey{stop}$, since the two processes both have $a$ as an initial event. We can instead resolve any nondeterminism by choosing to prioritise the addition of events from either the left, or the right branch. We introduce a biased choice operator, $P \extchoicel Q \defs \genchoice{Q}{\oplus}{P}$, which chooses events from $P$ whenever initial events are present in both $P$ and $Q$. For example, $a \then P \extchoicel a \then Q = a \then P$, since the event from the left branch is prioritised.

%\begin{definition}[External choice and biased external choice]\label{def:extchoice}
%$P \interrupt Q$ is defined corecursively by the following equations: 
% \begin{align*}
%    & f \odot g = \left(\ZKey{$\dom$}(g) \ndres f\right) \oplus \left(\ZKey{$\dom$}(f) \ndres g\right)  \tag*{[Product of partial functions]\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L368}} \label{def:map_prod}\\
%    & P \extchoice Q = \genchoice{P}{\odot}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L435}}\\
%    & P \extchoicel Q = \genchoice{P}{\left(\lambda f\,g \bullet g \oplus f\right)}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP_Biased.thy\#L11}}\\ 
%    & P \extchoicer Q = \genchoice{P}{\oplus}{Q} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP_Biased.thy\#L14}}\\ 
%\end{align*}
%\end{definition}

%\subsection{Biased external choice and biased parallel composition}

\subsection{Interrupt}
The second operator we introduce is interrupt~\cite{Hoare1985,Roscoe2011}, $P \interrupt Q$, which behaves like $P$ except that if at any time $Q$ performs one of its initial events then it takes over. We present partial functions as sets below. This operator, along with the other two, is defined corecursively, which allows them to operate on the infinite structure of an ITree. In corecursive definitions, every corecursive call on the right-hand side of each equation must be guarded by an ITree constructor. 
%
\begin{definition}[Interrupt]\label{def:interrupt}
%$P \interrupt Q$ is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L952}
\begin{align*}
\begin{array}{l}
\left(\Sil~P'\right) \interrupt Q = \Sil~\left(P' \interrupt Q\right)
\qquad P \interrupt \left(\Sil~Q'\right) = \Sil~\left(P \interrupt Q'\right) \\ [1pt]
\left(\Ret~x\right) \interrupt Q = \Ret~x 
\qquad\qquad\quad\  P \interrupt \left(\Ret~x\right) = \Ret~x \\[1pt]
\left(\Vis~F\right) \interrupt \left(\Vis~G\right)  = \Vis \left(
\begin{array}{l}
\left\{ e \mapsto \left(P' \interrupt Q\right) | \left(e \mapsto P' \right) \in \left(\ZKey{$\dom$}(G) \ndres F\right) \right\} 
\oplus G
%\\
%\left\{ e \mapsto Q' | \left(e \mapsto Q' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\end{align*}
\end{definition}
%
In the definition, $\ndres$ is called the domain anti-restriction, and $A \ndres R$ denotes the domain restriction of relation $R$ to the complement of set $A$. 
The $\Sil$ cases allow $\tau$ events to happen independently with priority and without resolving $\interrupt$. The $\Ret$ cases terminate with the value $x$ returned from either the left or right side of $\interrupt$.

For the $\Vis$ cases, it is also $\Vis$ constructed from an overriding $\oplus$ of the further two sets, representing two partial functions.  In the partial function,  $(\ZKey{$\dom$}(G) \ndres F)$ restricts the domain of $F$ to the complement of the domain of $G$.  %Here $\ndres$ is called the domain anti-restriction. 
The first partial function denotes that an initial event $e$ of $P$, that is not the initial event of $Q$, can occur independently (without resolving the interrupt) and its continuation is a corecursive call $P' \interrupt Q$.  
The second function is just $G$,  which 
denotes that the initial events of $Q$ can happen no matter whether they are in $F$ or not. 
%Then the subsequent process $Q'$ will take over. 
This means if $P$ and $Q$ share events, $Q$ has priority.  This prevents nondeterminism.
%In the partial functions, the operator $merge_E(F, G)$, defined in the recent work~\cite{Foster2021} for parallel composition, merges two event functions by tagging each event with $\IsaKey{Left}$, $\IsaKey{Right}$, or $\IsaKey{Both}$ depending on whether this event occurs on $F$ only (not in $E$), $G$ only (not in $E$), or both (also in $E$). In the merge expression $merge_{\emptyset}(\ZKey{dom}(G) \ndres F, G)$, $E$ is $\emptyset$ and so  $\IsaKey{Both}$ is not possible. This, together with the first or left expression $\ZKey{dom}(G) \ndres F$ which restricts the domain of $F$ to the complement of the domain ($\ZKey{dom}$, the domain of a partial function) of $G$, also called domain anti-restriction $\ndres$, is necessary to prevent nondeterminism by giving priority to the right side if both sides share the same events.  For example, $(a \then P) \interrupt (a \then Q) = a \then Q$.

\subsection{Exception}
Next, we present the exception operator, $\except{P}{A}{Q}$, which behaves like $P$ initially, but if $P$ ever performs an event from the set $A$, then $Q$ takes over. 
%
\begin{definition}[Exception]\label{def:exception}
%$\except{P}{A}{Q}$ is defined corecursively by the following equations:
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L1012}
\begin{align*}
\begin{array}{l}
\except{\left(\Ret~x\right)}{A}{Q} = \Ret~x \qquad 
\except{\left(\Sil~P'\right)}{A}{Q} = \Sil~\left( \except{P'}{A}{Q} \right) \\[1pt]
\except{\left(\Vis~F\right)}{A}{Q}
 = %\left(
%\begin{array}{l}
%\LET m = merge_{\emptyset}(A \ndres F, \{e \mapsto Q | e \in (A \cap \ZKey{dom}(F))\}) \\
\Vis \left(
\begin{array}{l}
\left\{ e \mapsto \left(\except{P'}{A}{Q}\right) | \left(e \mapsto P' \right) \in (A \ndres F) \right\} 
\oplus \\
\left\{ e \mapsto Q | e \in (A \cap \ZKey{$\dom$}(F)) \right\}
\end{array}
\right) 
%\end{array}
%\right)
\end{array}
\end{align*}
\end{definition}
%
The $\Ret$ case terminates immediately with the value $x$ returned, and $Q$ will not be performed. The $\Sil$ case allows the $\tau$ event to be consumed.

%In the $\Vis$ case, we use the $\LET$ expression to declare a local variable $m$ to be used in the expression after $@$. This is merely for the sake of presentation. The variable $m$ is  a merge  of two event functions. For the events of $F$ that are not in $A$, $A \ndres F$, they are tagged with $\IsaKey{Left}$. And for the events $(A \cap (\ZKey{dom}(F)))$ of $F$ that are in $A$, they are tagged with $\IsaKey{Right}$ and the subsequent process after these events is $Q$, because the right side of the merge is a partial function, $\{e \mapsto Q | e \in (A \cap \ZKey{dom}(F))\}$. Additionally, as $E$ in $merge$ is $\emptyset$, the tag $\IsaKey{Both}$ is also not possible. 

Similar to Definition~\ref{def:interrupt}, the $\Vis$ case is also represented by the overriding of two partial functions. The first partial function represents that an initial event $e$ of $P$, that is not in $A$ (that is, $e \in \ZKey{$\dom$}(A \ndres F)$),  can occur independently and its continuation is a corecursive call $\except{P'}{A}{Q}$. Following the execution of an initial event $e$ of $P$ that is in $A$ (that is,  $e \in (A \cap \ZKey{$\dom$}(F)$),  the exception behaves like $Q$, which is expressed by the second partial function.

\subsection{Renaming}
\label{ssec:itree_renaming}
The other new operator we define for this work is renaming, $\rename{P}{\rho}$, which renames events of $P$ according to the renaming relation $\rho:E_1 \rel E_2$. 
We note this relation is possibly heterogeneous, and so $E_1$ and $E_2$ are different types of events.
 %has each event $e_1$ of $P$ renamed to $e_2$ where $\left(e_1 \mapsto e_2\right)$ is in the renaming relation $\rho$. 
%The objective here is to define the operator so that it does not introduce nondeterminism. 
First, we define an auxiliary function for making a relation functional by removing any pairs that have duplicate distinct values. This is the case when the renaming relation, restricted to the initial events of $P$, is functional.
%
\begin{align*}
mk\_functional(R) = \{(x, y) \in R. \forall y'. (x, y') \in R \implies y=y' \}
\end{align*}
%
This produces the minimal functional relation that is consistent with $R$. For example, 
\begin{align*}
mk\_functional \left(\{e_1 \mapsto e_2, e_1 \mapsto e_3, e_2 \mapsto e_3 \}\right) = \{e_2 \mapsto e_3\}
\end{align*}
This function is used to avoid nondeterminism introduced by renaming multiple events to the same event. We use this function to define the renaming operator.
\begin{definition}[Renaming]\label{def:rename}
%$\rename{P}{\rho}::(E_1, R) \cspkey{itree} \Rightarrow (E_1 \rel E_2) \Rightarrow (E_2, R) \cspkey{itree}$ 
% is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/UTP/ITree_CSP.thy\#L1048}
\begin{align*}
\begin{array}{l}
\rename{\left(\Ret~x\right)}{\rho} = \Ret~x \\[1pt] 
\rename{\left(\Sil~P'\right)}{\rho} = \Sil~\left( \rename{P'}{\rho} \right) \\[1pt]
\rename{\left(\Vis~F\right)}{\rho}
 = \left(
\begin{array}{l}
\LET 
G = F \circ mk\_functional\left( (\ZKey{$\dom$}(F) \dres \rho)^{\inv}\right) \\
@ \Vis \left(
\begin{array}{l}
\left\{ e_2 \mapsto \left(\rename{P'}{\rho}\right) | \left(e_2 \mapsto P' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\right)
\end{array}
\end{align*}
\end{definition}
The $\Ret$ case behaves like $P$ and the renaming has no effect on it. The $\Sil$ case allows $\tau$ events to be consumed since they are not subject to renaming. 

In the $\Vis$ case, $G$ is a partial function ($E_2 \pfun (E_1, R)\cspkey{itree}$) that is the backward partial function composition $\circ$ of $F$ and a partial function made using $mk\_functional$ from the inverse $\inv$ of the relation $(\ZKey{$\dom$}(F) \dres \rho)$ which is the domain restriction $\dres$ of $\rho$ to the domain $\ZKey{$\dom$}(F)$ of $F$. 
%We note the function made by $mk\_functional$ is a relation (a set of pairs), and not a partial function. 
%Since we use sets to represent partial functions for the sake of presentation, another function to turn this relation into a partial function is omitted here. 
%We also note that $R^{-1}$ is the inverse of a general relation and the corresponding one in Z is $\inv$ ($R^{-1}$ in Z is the inverse of a homogeneous relation from a set $X$ to itself: $X \rel X$). 
Basically, the multiple events of $E_1$ that are mapped to the same event of $E_2$ in $\rho$ and also are the initial events of $P$, or in $\ZKey{$\dom$}(F)$, are removed in $G$. %This prevents nondeterminism.
The renaming result is a partial function in which each event $e_2$ in the domain of $G$ is mapped to a renamed process by a corecursive call $\rename{P'}{\rho}$ where $\left(e_2 \mapsto P'\right) \in G$. 

\changed[\C{0}]{
 Because many-to-one mappings in $\rho$ are removed by $mk\_functional$ in $G$, the potential nondeterminism is excluded. For example, 
 \begin{align*}
 &\rename{\left(
% \begin{array}{l}
 e_1 \then P \extchoice 
 e_2 \then Q \extchoice 
 e_3 \then R
% \end{array}
 \right)}{
 \{
% \begin{array}{l}
 e_1 \mapsto e, 
 e_2 \mapsto e, 
 e_3 \mapsto ea,
 e_4 \mapsto eb
% \end{array}
 \}} \\
 =& \left(ea \then \rename{R}{\{
% \begin{array}{l}
 e_1 \mapsto e, 
 e_2 \mapsto e, 
 e_3 \mapsto ea,
 e_4 \mapsto eb
% \end{array}
 \}}\right) \tag*{(renaming excludes nondeterminism)} \label{eqn:renaming_example}
 \end{align*}
 Here, the only available initial event after renaming is $ea$ because the relation $(\ZKey{$\dom$}(F) \dres \rho)^{\inv}$ is equal to $\{e \mapsto e_1, e \mapsto e_2, ea \mapsto e_3\}$ and $mk\_functional$ removes the first two pairs (because of duplicate distinct values), and so results in $\{ea \mapsto e_3\}$.

\begin{rmk}
Roscoe~\cite{Roscoe2011} defines three ways for renaming in CSP. Injective functional renaming will not change the behaviour of a CSP process and is an alternative to parametrised CSP processes on channels. Non-injective functional renaming may change the behaviour of a process by ignoring some level of detail or introducing nondeterminism. Relational renaming, a more general and powerful operator than the other two functional renamings, allows many-to-one (may introduce nondeterminism), or one-to-many (to offer more choice) mappings. What machine-readable CSP (CSPM) supports and FDR implements is relational renaming. We investigated all these approaches and chose to implement here the relational renaming with many-to-one and one-to-many mappings. This is mainly because RoboChart's semantics is defined using CSPM and verified using FDR. For many-to-one mappings, our definition here, however, blocks these many events and the definition of renaming with priority in Sect.~\ref{ssec:itree_renaming_with_priority}, as follows, chooses one of these many events according to their priority.
\end{rmk}

\subsection{Hiding with priority}
\label{ssec:itree_hiding_with_priority}
The current semantics~\cite{Foster2021} of hiding $P \hide A$ is deadlock if more than one initial events of $P$ are in $A$. This is to avoid nondeterminism caused by hiding of two possible events. This restriction can be relaxed by placing events to be hidden in an order. For example, $\left(a \then P \extchoice b \then Q\right) \hide \{a, b\} = stop$, but $\left(\left(a \then P \extchoice b \then Q\right) \hide \{a\} \right) \hide \{b\} = \tau \left(\left(P\hide \{a\}\right) \hide \{b\}\right)$, and $\left(\left(a \then P \extchoice b \then Q\right) \hide \{b\} \right) \hide \{a\} = \tau \left(\left(Q\hide \{b\}\right) \hide \{a\}\right)$. Hiding events in a different order, therefore, resolves the external choice differently without deadlock. This difference is due to the maximal progress assumption of hiding: $\left(a \then P \extchoice b \then Q\right) \hide \{a\}$ is actually equal to $\tau \left(P\hide \{a\}\right)$.

We define hiding with priority, $P \hidep el$ (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L17}), to put these events to be hidden in an order based on their order in a list $el$.
%
\begin{align*}
    & P \hidep el = foldl\left(\left(\lambda Q~e.~Q \hide \{e\}\right), P, el\right) &
\end{align*}
The $foldl$ builds a return value by applying the function $\left(\lambda Q~e.~Q \hide \{e\}\right)$ (say $f$) to the combined result (initially $P$) and elements in $el$ based on their orders. For example, $foldl\left(f, P, [a,b]\right)$ will be expanded to $f(f(P, a), b)$, which is just $\left(P \hide \{a\}\right) \hide \{b\}$.
%
The above examples now can be expressed as $\left(a \then P \extchoice b \then Q\right) \hidep [a,b]$ and $\left(a \then P \extchoice b \then Q\right) \hidep [b,a]$.

\subsection{Renaming with priority}
\label{ssec:itree_renaming_with_priority}
Because the relation $\rho$ of type $E_1 \rel E_2$ in the renaming definition~\ref{def:rename} is possibly heterogeneous (so $E_1$ and $E_2$ are different types), renaming cannot be like hiding with priority to place the events to be renamed in an order to rename events one by one. This is because renaming a process changes its event type from $E_1$ to $E_2$, and so we cannot rename other events of type $E_1$ anymore. For this reason, we define renaming with priority, $\renamep{P}{\varrho}$, which renames events of $P$ according to a finite sequence $\varrho$ of type $\seq\left(E_1 \cross E_2\right)$. We use the finite sequence type here to describe the mathematical definition of this operator and its representation in Isabelle is actually lists. A finite sequence of type $\seq X$ is a finite partial function $\nat \ffun X$ from natural numbers $\nat$ to $X$. With $\varrho$, a priority is given based on the indices of pairs in the sequence in order to resolve potential nondeterminism in a particular way. For those pairs that have the same second element (in other words, many-to-one mappings), the pair with the smallest index has the highest priority. This renaming with a priority operator will only rename the event with the highest priority and block other events with lower priority. 
%The pair with a small index number in $\varrho$, has a higher priority. If two or more events are renamed to the same event, the event in the mapping pair with the highest priority will be retained and others are blocked.

Prior to the definition of $\renamep{P}{\varrho}$, we need to define another two functions. 
%one is the domain restriction $\dresl$ of $\varrho$ to a set $A$ and another is similar to the range anti-restriction $\nrres$ of $\varrho$ to $A$, but 
The first function is the domain restriction $\dresl$ of $\varrho$ to a set $A$. %As for the domain restriction $\dres$ for relations, $\dresl$ for an associative list $\varrho$ %of type \texttt{(\textquotesingle{a} \(\times\) \textquotesingle{b}) list} 
%based on a set $A$
%of type .
\begin{align*}
    % A \dresl \varrho = [p.~ p \leftarrow \varrho, fst~p \in A] \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/1a01b17004b7115eaca8b504ee96df46c7186478/RoboChart/ITree_RoboChart.thy\#L28}}
    A \dresl \varrho = squash~\left\{s : \seq\left(E_1 \cross E_2\right) | s \in \varrho \bullet (s.2).1 \in A\right\} \tag*{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L31}}
\end{align*}
This produces a new sequence, compacted from a function, or a set of ordered pairs, in which each member $s$ is in $\varrho$ and the first element $(s.2).1$ (of type $E_1$) of the second element $s.2$ (of type $E_1 \cross E_2$) of $s$ is in $A$, by the $squash$ function~\cite{Spivey1992}. When a type is obvious, we use a short form $x \in A \bullet P(x)$ for $x : T | x \in A \bullet P(x)$. This could be used in set comprehension, quantification, etc.
%
%\newcommand{\dreslloc}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/1a01b17004b7115eaca8b504ee96df46c7186478/RoboChart/ITree_RoboChart.thy\#L28}}
%\begin{alltt}
%    \isakwmaj{definition} \(\dresl\) :: "\textquotesingle{a} set \(\implies\) (\textquotesingle{a} \(\times\) \textquotesingle{b}) list \(\implies\) (\textquotesingle{a} \(\times\) \textquotesingle{b}) list" 
%    \(\\\qquad\) \isakwmin{where} A \(\dresl\) \(\varrho\) = [p. p \(\leftarrow\) \(\varrho\), fst p \(\in\)A] \(\dreslloc\)
%\end{alltt}
%This produces a new associative list using list comprehension in Isabelle/HOL by just preserving the pair $p$ in $\varrho$ whose first element is in $A$. 

We give an example below to illustrate how $\dresl$ works.
%
\begin{align*}
    \{e_1, e_2, e_4\} \dresl \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle = \langle (e_1 , e), (e_2 , e), (e_4 , eb) \rangle
\end{align*}
%
For the second function $drop\_dup(\varrho)$, we need to drop the pairs with lower priority (and so bigger indices). We define an auxiliary $least$ function first. 
\begin{align*}
    & least(\varrho, p) \defs \left(\nexists q \in \varrho \bullet q.1 < p.1 \land (q.2).2 = (p.2).2\right) \tag*{($least$ definition)} \label{def:drop_least}
\end{align*}
This function characterises if $p$ (of type $\nat \cross (E_1 \cross E_2)$) has the least index number $p.1$ in the members $q$ of $\varrho$ that have the same target event $(q.2).2$ (of type $E_2$) as that $(p.2).2$ of $p$. In other words, $p$ has the least index number in a set of renaming pairs that have multiple events renamed to the same event as in $p$. Now $drop\_dup(\varrho)$ is defined below.
% keeps only the pair $(x, y)$ with the smallest index number for each element $y$ in the image of $\varrho$ based on the order of these pairs $(_, y)$.
%The second function $drop\_dup(\varrho, A)$ aims to drop the pairs in $\varrho$ whose second element is in set $A$. This function is defined recursively.
%
% \begin{align*}
%     & drop\_dup ([~], A) = [~] \\ 
%     &drop\_dup(x\#xs, A) = \left(\IF\ snd~x \in A \THEN drop\_dup(xs, A)\ \ELSE\ x \# drop\_dup \left(xs, A \cup \{snd~x\}\right)\right)
% \end{align*}
\begin{align*}
    %& \left(
    %\begin{array}[]{l}
        %\varrho \nrres \subseteq \varrho \\
        %\forall p : \seq~(X \times Y) \bullet p \in \varrho \nrres \implies \lnot \exists q : \seq (X \times Y) | q \in \varrho \bullet q.1 < p.1 \land (q.2).2 = (p.2).2 \\ 
    & \left(\forall p \in drop\_dup(\varrho) \bullet least(\rho, p)\right) \land \tag*{(maximal)} \label{def:drop_maximal}\\ 
    & \left(\forall p \in \varrho \bullet least(\varrho, p) \implies p \in drop\_dup(\varrho)\right) \tag*{(minimal)} \label{def:drop_minimal}
    %\end{array}
    %\right) \\
    % &drop\_dup(x\#xs, A) = \left(\IF\ snd~x \in A \THEN drop\_dup(xs, A)\ \ELSE\ x \# drop\_dup \left(xs, A \cup \{snd~x\}\right)\right)
\end{align*}
The first predicate \ref{def:drop_maximal} in the conjunction states that every element in the resultant $drop\_dup(\varrho)$ is $least$ in $\varrho$, and the second predicate \ref{def:drop_minimal} states that every least element in $\varrho$ must be in the resultant $drop\_dup(\varrho)$. 
% If $\varrho$ is an empty list $[~]$, the result is also an empty list. Otherwise, $\varrho$ is a concatenation of a pair $x$ and a list $xs$. If the second element $(snd~x)$ of $x$ is in $A$, then $x$ is dropped. Otherwise, $x$ is preserved but $drop\_dup$ now is applied to $xs$ with an update set $A \cup \{snd~x\}$ (so the subsequent pair, whose second element is $snd~x$, becomes duplicate and is finally dropped). 
For example, 
%
\begin{align*}
    drop\_dup\left( \langle (e_1 , e), (e_2 , e), (e_4 , eb) \rangle \right) = \langle (e_1 , e), (e_4 , eb) \rangle
\end{align*}
Here, the pair $(e_2 , e)$ is dropped because it does not have the highest priority in terms of the target event $e$ (due to the fact that $e$ appears early in $(e_1, e)$). With the two functions given above, we can define $\renamep{P}{\varrho}$ corecursively.
%

\begin{definition}[Renaming with priority]\label{def:rename_priority}
%$\rename{P}{\rho}::(E_1, R) \cspkey{itree} \Rightarrow (E_1 \rel E_2) \Rightarrow (E_2, R) \cspkey{itree}$ 
% is defined corecursively by the following equations: 
$ $\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L56}
\begin{align*}
\begin{array}{l}
\renamep{\left(\Ret~x\right)}{\varrho} = \Ret~x \\[1pt] 
\renamep{\left(\Sil~P'\right)}{\varrho} = \Sil~\left( \renamep{P'}{\varrho} \right) \\[1pt]
\renamep{\left(\Vis~F\right)}{\varrho}
 = \left(
\begin{array}{l}
\LET 
G = F \circ mk\_functional\left( \left(\ZKey{$\ran$}\left(drop\_dup\left(\ZKey{$\dom$}(F) \dresl \varrho\right)\right)\right)^{\inv}\right) \\
@ \Vis \left(
\begin{array}{l}
\left\{ e_2 \mapsto \left(\renamep{P'}{\varrho}\right) | \left(e_2 \mapsto P' \right) \in G \right\}
\end{array}
\right) 
\end{array}
\right)
\end{array}
\end{align*}
\end{definition}

This definition is similar to Definition~\ref{def:rename} except that $\varrho$ here is a sequence of renaming pairs and the relation in the inverse now has all its domain elements mapped to distinct values by $drop\_dup$. Because $drop\_dup$ defines a sequence of type $\nat \ffun (E_1 \cross E_2)$, we get the range of the sequence by the $\ZKey{$\ran$}$ function, which is a relation. 

The difference between renaming and renaming with priority is exemplified below. 
 \begin{align*}
 &\renamep{\left(
% \begin{array}{l}
 e_1 \then P \extchoice 
 e_2 \then Q \extchoice 
 e_3 \then R
% \end{array}
 \right)}{
     \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle
 } \\
 = &\left(
 \begin{array}[]{l}
 e \then \renamep{P}{ \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle }  \extchoice  \\
 ea \then \renamep{R}{ \langle (e_1 , e), (e_2 , e), (e_3 , ea), (e_4 , eb) \rangle }
 \end{array}
\right) \tag*{(renaming resolves nondeterminism)} \label{eqn:renaming_priority_example}
 \end{align*}

Compared to \ref{eqn:renaming_example}, the potential nondeterminism introduced by renaming both $e_1$ and $e_2$ to $e$ is resolved by giving priority to the renaming map $(e_1, e)$. If $(e_1 , e)$ and $(e_2 , e)$ are swapped, then the renaming will give priority to $e_2$ and its continuation is $Q$ (instead of $P$).

}

% \changed[\C{0}]{
% \begin{rmk}
%     New syntax for renaming: $\isasymlbrace \varg \mapsto \varg | \varg \in \varg. \varg\isasymrbrace$ and the definition of \isacode{rncollect} 
%    We also explored several implementations of the renaming operator, and why we choose this one. Give some insights, discussion of the renaming operator in CSPM and FDR. And also pros and cons of our approach.
%    \begin{itemize}
%        \item Channel or event parametrisation like $COPY(left, right)$ where $left$ and $right$ are parametrised channel names,
%        \item Renaming with a relational map using partial injection,
%        \item Renaming with a relational map using partial functions.
%    \end{itemize}
% \end{rmk}
% }

\section{RoboChart semantics in interaction trees}
\label{sec:rc_to_itrees}

%We base our implementation of the RoboChart semantics in ITrees on the CSP semantics generated by RoboTool, and so we also consider the practical details of the semantics generation in RoboTool. %For example, a CSP file \cspcode{instantiation.csp} is used to record the parameters to the generation and the customisation by users for the constants and definitions in models. 
In this section, we describe how we give semantics to RoboChart in terms of ITrees in Isabelle/HOL. These include types, instantiations, functions, state machines, controllers, and modules. In the implementation of RoboChart's semantics, we also take into account the practical details of the CSP semantics generation in RoboTool, such as naming and bounded primitive types. 

In particular, nondeterministic choice between transitions, for example in Fig.~\ref{fig:robochart_patrol}, is resolved by the use of the prioritised renaming operator defined earlier through ordered transition event mappings. This is not covered in the previous work~\cite{Ye2022} and is the new contribution of this paper.
% Use of bounded types is necessary for model checking with FDR and also for animation of this work, and so we can achieve consistency between the semantics in RoboTool and that in Isabelle/HOL. This consistency enables both tools to work in a complementary way. For example, animation is used for debugging and then FDR for verification during model development and analysis.

\changed[\C{0}]{
\subsection{Overview of RoboChart semantics}
\label{ssec:semantics_overview}

The RoboChart CSP semantics is sketched in Fig.~\ref{fig:robochart_semantics}. The semantics for modules, controllers, state machines, and (either composite or basic) states are CSP processes. The semantics for a robotic platform, however, is different from  controllers and state machines in that it does not have a particular behaviour and so its semantics is not a CSP process because the platform is an abstraction of a physical robot through variables, events, and operations.
\begin{figure}[t]
  \centering%
  \includegraphics[width=1.00\textwidth]{RoboChart_semantics.pdf}%
  %\vspace{-3ex}
  \caption{From~\cite[Fig.~11]{Miyazawa2019}. Structure of the RoboChart semantics: stacked components and parallel lines indicate parallel composition; bordered boxes indicate points of interaction; the semantics of a container is composed of the semantics of its contained components.}%
  %\vspace{-4ex}
  \label{fig:robochart_semantics}%
\end{figure}

Semantically, RoboChart has a hierarchical memory model with a memory for the robotic platform at the top, memories for controllers in the middle, and memories for state machines inside their container controllers. A memory process records the reads and writes of variables for components (the platform, controllers, and state machines) in scope. The memory for a state machine caches the (both local and shared) variables it requires, and so the semantics of the machine is independent of the location where these variables are declared. The memory for a controller or the platform, however, is different from that of a state machine in that it not only accepts updates to the variables in the memory but also propagates the updates down the hierarchy to the memories of state machines that require the updated variables.

The RoboChart semantics of the autonomous chemical detector model in Sect.~\ref{ssec:robochart_chemical} is shown in Fig.~\ref{fig:robochart_acd_semantics}. The semantics of the module is a parallel composition of the two controllers with the robotic platform memory (RP memory) and a buffer process (Buffer). 
The buffer process models the asynchronous connection from \rcitem{MainController} to \rcitem{MicroController} on event \rcitem{turn} in Fig.~\ref{fig:robochart_acd_module}. This semantics for asynchronous connections is omitted in Fig.~\ref{fig:robochart_semantics} for simplicity.

\begin{figure}[t]
  \centering%
  \includegraphics[width=1.00\textwidth]{Autonomous_RoboChart_semantics.pdf}%
  %\vspace{-3ex}
  \caption{RoboChart semantics of the autonomous chemical detector.}%
  %\vspace{-4ex}
  \label{fig:robochart_acd_semantics}%
\end{figure}

The platform memory and the controller memories for this chemical detector model are simply the CSP process \cspkey{skip} because the platform and the controllers do not provide any variables for sharing. The platform memory and the controller memory for the one-dimensional patrol robot in Sect.~\ref{ssec:robochart_patrol}, nevertheless, record the access and update of the shared variable $x$ and propagate its update to the controller, and finally to the state machines in the controller.

The semantics of \rcitem{MainController} (or \rcitem{MicroController}) is the composition of the CSP process for the semantics of its contained state machine \rcitem{GasAnalysis} (or \rcitem{Movement}) with the controller memory. We note the CSP processes for the controllers are renamed, such as {Renamed MainController}. This is because RoboChart uses directed connections for communication, but CSP's parallel composition requires composites to have the same channel names for communication. We, therefore, need to rename the exported channels of the controller CSP processes to ensure the channel names for the two controllers in a connection are the same, and so they can communicate with each other.

Similarly, the CSP processes for the semantics of the state machines (\rcitem{GasAnalysis} and \rcitem{Movement}) are also renamed for the same reason to ensure the state machines in a controller can communicate on directed connections. The renaming is not compulsory for the chemical detector model because each controller contains only one state machine, but it is mandatory for the patrol robot because the controller contains two state machines connected on event \rcitem{update}. So in general, we always rename them.

The semantics of the state machine \rcitem{GasAnalysis} is a parallel composition of the node (including the junction \rcitem{i0} and the states \rcitem{NoGas}, etc.) processes with the machine memory recording the access and update of the local variables of the machine. The semantics of the machine \rcitem{Movement} has a similar structure. The memories of the state machines \rcitem{CalSTM} and \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol}, nonetheless, record not only their local variables \rcitem{l} but also the shared variable \rcitem{x}.
}

\changed[\C{0}]{
\paragraph{Practical consideration}
Our ITree-based semantics for RoboChart in this paper aims for consistency with the restricted CSP semantics generated in RoboTool.
Here the restriction particularly refers to bounded types for basic RoboChart types and corresponding closed arithmetic operators. In the future, we could use unbounded basic types with usual operators, then enforce enumerations just in the animator, not in the semantics like this work.
%another restriction is finite type for channels, due to the command chantype,
One advantage of using this restricted semantics is the possibility to reuse the current CSP semantics generator in RoboTool to generate corresponding ITrees-based theories for Isabelle to automatically generate Haskell code.

RoboTool automatically generates multiple versions of CSP semantics for a RoboChart model, including a standard version (\textbf{S}), an optimised version (\textbf{D}) that reduces internal interaction to some extent, an optimised and visible version (\textbf{VS}) that further exposes internal interaction, and an optimised and compressed version (\textbf{O}) with compressions using strong bisimulation and diamond elimination~\cite{Roscoe2011}. All these versions use some compressions. Our ITree-based semantics for RoboChart in this paper is based on the \textbf{D} version because RoboTool uses this version for verification. Our semantics here does not support compressions in the \textbf{D} version. Instead, we implement a form of compression for internal events in the animator.  

}

\subsection{Types}
%\paragraph*{{Types.}}
\label{ssec:semantics_type}
RoboChart has its type system based on that of the Z notation~\cite{Toyn2002}. It supports basic types: \rcitem{PrimitiveType}, \rcitem{Enumeration}, records (or schema types), and other additional types from the mathematical toolkits of Z.%: \rcitem{SetType}, \rcitem{SeqType}, \rcitem{ProductType}, function and relation types. 

The \rcitem{core} package of RoboTool provides five primitive types: boolean, naturals, integers, real numbers, and string. 
%Their corresponding types in Isabelle are shown in Table~\ref{table:types}. 
We map integers, naturals, and strings onto the corresponding types in Isabelle/HOL, but with support for code generation to target language types. This improves the efficiency of evaluation and thus animation.
%For integers and naturals, we use numeric types \IsaKey{integer} and  \IsaKey{natural} in Isabelle, which are isomorphic to \IsaKey{nat} and \IsaKey{int} but mapped to build-in integers of target languages for code generation. For the similar reason, we use \IsaKey{String.literal} for strings of RoboChart. 
%% Because CSP (specifically CSP-M) does not have a type for real numbers, we also use \IsaKey{integer} for real numbers of RoboChart, which is the same as the CSP semantics generated in RoboTool, but we could equally use the Isabelle's real type.
%% We note the use of \IsaKey{integer} for real numbers here is to make our animation consistent with the generated CSP semantics, and it is possible to use \IsaKey{real} in Isabelle for real numbers for the purpose of verification (instead of code generation here). 
%
RoboChart models can also have abstract primitive types with no explicit constructors, such as \rcitem{Chem} and \rcitem{Intensity} in the chemical detector model presented in Sect.~\ref{sec:robochart}. 
We map primitive types to finite enumerations for the purpose of code generation.
%In the CSP semantics of models in RoboTool, their implementations are supplied by users. For example, the verification of the model has both types instantiated to a set \cspcode{\{0,1\}}.
% with two elements: \cspcode{0} and \cspcode{1} 
We define a finite type \isacode{PrimType} parametrised over two types: 
\isacode{\textquotesingle{t}} for specialisation and a numeral type \isacode{\textquotesingle{a}} for the number of elements.
% 
\newcommand{\PrimType}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L74}}
\begin{alltt}
\isakwmaj{datatype} (\textquotesingle{t}, \textquotesingle{a}::finite) PrimType = PrimTypeC \textquotesingle{a} \(\PrimType\)
\end{alltt}
%
%We note that \isacode{\textquotesingle{t}} does not appear in the right side of the definition because it is introduced only to distinguish between different primitive types. 
For example, \rcitem{Chem} is implemented as a generic type \isacode{\textquotesingle{a} Chem = (ChemT, \textquotesingle{a}) PrimType} (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L122}).
%\isacode{Chemical\_Chem} (a specialisation of \isacode{PrimType} by type \isacode{Chemical\_ChemT}) defined below.
%
%\newcommand{\ChemicalChem}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L121}}
%\begin{alltt}
%\isakwmaj{typedef} Chemical\_ChemT = "{()}"  \(\ChemicalChem\)
%\isakwmaj{type_synonym} ('a) Chemical\_Chem = "(Chemical\_ChemT, 'a) PrimType"
%\end{alltt}
%\isakwmaj{abbreviation} Chemical\_ChemC::"('a::finite \(\Rightarrow\) 'a Chemical\_Chem)"
%  \isakwmin{where} "Chemical\_ChemC \(\equiv\) PrimTypeC"
%
%The constructor for this new type is \isacode{Chemical\_ChemC} which is just  \isacode{PrimTypeC}, but with type constraint. 
%
An example of a finite type \isacode{\textquotesingle{a}} is the numeral type in Isabelle, such as type \isacode{2} which contains two elements: zero (\texttt{0::2}) and one (\texttt{1::2}). In order to construct an element of type \rcitem{Chem}, we define a dedicated constructor \isacode{ChemC} which is simply a type cast of \isacode{PrimTypeC}. Finally, we use \isacode{(ChemC 0::2)} and \isacode{(ChemC 1::2)} to construct such two elements of type \isacode{(2 Chem)}.
%, which contains two elements: \isacode{0::2} and \isacode{1::2}. %A type \isacode{(2 Chem)}, therefore, corresponds to the instantiation of \rcitem{Chem} in RoboTool.

%
%\begin{table}[h!]
%\centering
% \caption{RoboChart core primitive types to Isabelle types.}
% \begin{tabular}{||c |c || c| c || c | c||} 
% \hline
% \textbf{RoboChart} & \textbf{Isabelle} & \textbf{RoboChart} & \textbf{Isabelle} & \textbf{RoboChart} &  \textbf{Isabelle} \\ %[0.5ex] 
% \hline%\hline
% \rcitem{bool} & \IsaKey{bool} & \rcitem{nat}& \IsaKey{natural} & \rcitem{int} & \IsaKey{integer}  \\ %[1ex] 
% \hline
 % \rcitem{real} & \IsaKey{integer} & \rcitem{string}& \IsaKey{String.literal} & & \\ 
 %\hline
 %\rcitem{datatype} & \IsaKey{record} & records & \rcitem{set(T)}& \IsaKey{T~set} &  & \rcitem{Seq(T)} & \IsaKey{T~blist[n]} & bounded \\ 
 %\hline
% \rcitem{T1$\cross$T2} & \IsaKey{T1 $\cross$ T2} &  & \rcitem{}& \IsaKey{T~set} &  & \rcitem{Seq(T)} & \IsaKey{T~blist[n]} & bounded \\ 
% \hline
% \end{tabular}
%\label{table:types}
%\end{table}

For enumerations and records, we use \isakwmaj{datatype} and \isakwmaj{record} in Isabelle. The \isacode{Status} and \isacode{GasSensor} below are such examples for the corresponding types in the \rcitem{Chemical} package shown in Fig.\ref{fig:robochart_acd_chemical}%. 
%
\newcommand{\ChemicalStatus}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L190}}
\newcommand{\ChemicalGasSensor}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L266}}
%
\begin{alltt}
\isakwmaj{datatype} Status = Status_noGas | Status_gasD \(\ChemicalStatus\)
\isakwmaj{record} \textquotesingle{a} GasSensor = gs\_c :: "\textquotesingle{a} Chem"   gs\_i :: "\textquotesingle{a} Intensity" \(\ChemicalGasSensor\)
\end{alltt}
An instantiation type \isacode{(2 GasSensor)} is a record containing two fields of finite types \isacode{(2 Chem)} and \isacode{(2 Intensity)}, both of which have two elements. We now can construct an element \isacode{\(\lparr\)gs\_c = Chem (1::2), gs\_i = IntensityC (0::2)\(\rparr\)} of this type: the chemical is q and the intensity is 0.

For finite sequences such as \rcitem{Seq(GasSensor)}, we also bound the length of each sequence in this type. We define bounded lists or sequences \isacode{(\textquotesingle{a}, \textquotesingle{n}::finite) blist} 
%(\isaref{https://github.com/isabelle-utp/Z_Toolkit/blob/90eefcdbc0dfd93cb1db6342a916add57a174381/Bounded_List.thy\#L10}) 
 over two parametrised types: \isacode{\textquotesingle{a}} for the type of elements and a finite type \isacode{\textquotesingle{n}} for the maximum length of each list.

\newcommand{\blist}{\isalink{https://github.com/isabelle-utp/Z_Toolkit/blob/90eefcdbc0dfd93cb1db6342a916add57a174381/Bounded_List.thy\#L10}}
\begin{alltt}
\isakwmaj{typedef} (\textquotesingle{a},\textquotesingle{n}::finite) blist = \{xs::\textquotesingle{a} list. length xs \(\leq\) CARD(\textquotesingle{n})\} \(\blist\)
\end{alltt}
%
\noindent 
\isacode{CARD} here retrieves the cardinality of \isacode{\textquotesingle{n}}. We introduce a notation \isacode{\textquotesingle{a} blist[\textquotesingle{n}]} for this type and also define several functions: 
\begin{inparaenum}[(a)]
\item \isacode{blength} to get the length of a bounded sequence; 
\item \isacode{bnth} to get the nth element of a bounded sequence; 
\item \isacode{bappend} ($\text{@}_s$) to concatenate two bounded sequence; and 
\item \isacode{bmake} to construct a bounded sequence from a finite list. 
\end{inparaenum}

For the type \rcitem{Seq(GasSensor)} in RoboChart, its bounded type in Isabelle is \isacode{(2 GasSensor) blist[2]} which denotes the length of sequences bounded to 2 and elements (in the sequences) of type \isacode{(2 GasSensor)}.
We now can use \isacode{bmake TYPE(2) [\(\lparr\)gs\_c = Chem (0::2), gs\_i = IntensityC (0::2)\(\rparr\), \(\lparr\)gs\_c = Chem (1::2), gs\_i = IntensityC (1::2)\(\rparr\)]} to construct a sequence containing two sensor readings.

For other types, we have their counterparts in the Z toolkit. %The type of partial functions \(\pfun\), used for the definition of ITrees, is such an example.

%\subsection{Constants}
\subsection{Instantiations}
%\paragraph*{{Instantiations.}}
\label{ssec:semantics_inst}
The \cspcode{instantiation.csp} file of the CSP semantics contains common definitions used by all models for verification using FDR. These include the definitions of bounded core types (named types in CSP) and arithmetic operators under which these bounded types are closed. We show below one example for type \rcitem{core\_int} and three for the arithmetic operators, closed under a bounded type \cspcode{T}.
\begin{alltt}
  \cspkey{nametype} core_int = \{-2 .. 2\}
  Plus(e1, e2, T) = if member(e1 + e2, T) then (e1 + e2) else e1
  Minus(e1, e2, T) = if member(e1 - e2, T) then (e1 - e2) else e1
  Neg(e, T) = if member(-e, T) then (-e) else e
\end{alltt}
In the definition of \cspcode{Plus}, if \cspcode{e1+e2} is within \cspcode{T} then this is the result, otherwise, it is \cspcode{e1}. Other definitions \cspcode{Minus} and \cspcode{Neg} are similar. We use \isacode{\isakwmaj{locale}}~\cite{Ballarin2004} in Isabelle to define these for reuse in all models.
 Locales allow us to characterise abstract parameters (such as \isacode{min\_int} and \isacode{max\_int}, to define bounded core type \rcitem{core\_int}) and assumptions in a local theory context.
%, sketched below. 
 %\vspace{-1em}
 %
 \newcommand{\RoboChartConf}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L115}}
 %\begin{figure}[h!]
 \begin{alltt}
\isakwmaj{locale} robochart_confs = 	\(\RoboChartConf\)
  \isakwmin{fixes} min_int::"integer" \isakwmin{and} max_int::"integer" \isakwmin{and} max_nat::"natural" \isakwmin{and} 
        min_real::"integer" \isakwmin{and} max_real::"integer"
\isakwmin{begin}
  \isakwmaj{abbreviation} "core_int_list \(\equiv\) [min_int .. max_int]"
  \isakwmaj{abbreviation} "core_int_set \(\equiv\) set core_int_list"
  \isakwmaj{definition} Plus \isakwmin{where} "Plus e1 e2 T = (if (e1+e2) \(\in\) T then (e1+e2) else e1)"
  \isakwmaj{definition} Minus \isakwmin{where} "Minus e1 e2 T = (if (e1-e2) \(\in\) T then (e1-e2) else e1)"
  \isakwmaj{definition} Neg \isakwmin{where} "Neg e T = (if -e \(\in\) T then -e else e)"
  ...
\isakwmin{end}
 \end{alltt}
% \label{fig:locale}
% \caption{Instantiations as locale and its interpretation.}
 %\end{figure}
\vspace{-2ex}
We define bounded core types as sets by ranges given by a lower limit and an upper limit, such as parameters \isacode{min\_int} and \isacode{max\_int}. Additionally, in code generation, we use lists to implement sets, and so we define a list of ranges first in \isacode{core\_int\_list} and then convert it into a set \isacode{core\_int\_set}.

We note a named type in CSP can be used as a type as well as a set expression, and so a bounded core type is a type and also an expression. Isabelle, however, has different concepts for types and expressions, and they cannot be used interchangeably. For this reason, we have core types in Sect.~\ref{ssec:semantics_type} and bounded sets for these types here. 
The definition \isacode{Plus} illustrated above corresponds to that in the \cspcode{instantiation.csp} file and is an example to define a closure operator. 
%% %

In the theory of Isabelle for a RoboChart model, we instantiate this locale using \isakwmaj{interpretation} (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L97}), which allows us to assign concrete values for the parameters. 
An example is shown below which instantiates the parameters (limits) of the locale to \isacode{-2, 2, ...}  etc. 
\newcommand{\LocaleInter}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L97}}
 \begin{alltt} 
 \isakwmaj{interpretation} rc: robochart_confs "-2" "2" "2" "0" "1". \(\LocaleInter\)
 \end{alltt}
\vspace{-1em}
Then we can use \isacode{rc.core\_int\_set} and \isacode{rc.Plus} to access the instantiated definitions.
 
\subsection{Functions}
%\paragraph*{{Functions.}}
\label{ssec:semantics_funcs}
Functions in RoboChart benefit from the rich expressions in Isabelle and the Z toolkit in Isabelle. The expressions that are not supported in CSP-M such as logical quantifications 
%, definite descriptions, and lambda expressions 
are naturally present in Isabelle. 
% In order to support code generation, these expressions are required to be implemented (code equations) for the types they operate on. 
 % For example, \isacode{list\_all} is an implementation of $\forall$ for lists. 
 Using the code generator, the preconditions and postconditions of a function definition can be solved effectively, while this is not possible in CSP-M and FDR.
 %Functions, defined by preconditions and postconditions, therefore, can be specified in RoboChart models and implemented in ITrees. 
% This guarantees the semantics of functions is consistent in the models and in its implementation. 
% Since CSP-M cannot support these expressions, in order for verification with FDR, users need to supply a customised implementation. The consistency between the specification of a function and its customisation may not be guaranteed. This consistency, however, is important and also useful to detect errors in models.

 As mentioned in Sect.~\ref{ssec:robochart_chemical}, three (\rcitem{goreq}, \rcitem{angle}, and \rcitem{analysis}) among the five functions defined in the Chemical package of the autonomous chemical detector model in Fig.~\ref{fig:robochart_acd_chemical} are unspecified, and two (\rcitem{analysis} and \rcitem{intensity}) among them are specified in the original model. 
 Our model presented in Fig.~\ref{fig:robochart_acd_chemical} specify all five functions.
 With the capability of solving preconditions and postconditions of functions introduced in our work, we detect two problems in the definitions of the two specified functions in the original model, which are corrected in our model. Next, we present the semantics of the two functions (\rcitem{intensity} and \rcitem{location}) in our implementation.

%An example function is \rcitem{intensity}, shown in Fig.~\ref{fig:robochart_acd_chemical_intensity}, defined in %the \rcitem{Chemical} package of 
 The \rcitem{intensity} function defined in Fig.~\ref{fig:robochart_acd_chemical} has a precondition (\includegraphics[align=c,height=8pt]{pre.pdf}) that the length (\rcitem{size}) of the parameter \rcitem{gs} is larger than 0, and two postconditions (\includegraphics[align=c,height=8pt]{post.pdf}) involving universal and existential quantifications {where \rcitem{@} separates constraint and predicate parts, and \rcitem{goreq} is a $\geq$ relation on intensities.  The \rcitem{result} of the function is the largest intensity in \rcitem{gs}}.
For verification with FDR in RoboTool, an explicit implementation of this function must be supplied.
%
% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=.65\textwidth]{Chemical_intensity.pdf}%
%   \vspace{-3ex}
%   \caption{The specification of function  \rcitem{intensity}.}%
%   \vspace{-4ex}
%   \label{fig:robochart_acd_chemical_intensity}%
% \end{figure}
%
Our definition of this function in Isabelle, however, is directly from its specification and is shown below.
%
\newcommand{\pregs}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L341}}
\newcommand{\postgs}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L348}}
 \begin{alltt}
\isakwmaj{definition} "pre\_Chemical\_intensity\ gs = (blength gs > 0)" \(\pregs\)
\isakwmaj{definition} "Chemical\_intensity gs = (THE result. \(\postgs\)
    (\(\forall\)x::nat < blength gs. Chemical\_goreq(result, gs\_i (bnth gs x)))\(\land\)
    (\(\exists\)x::nat < blength gs. result = gs\_i (bnth gs x)))"
 \end{alltt}
\vspace{-3ex}
%
\noindent In the definitions, \isacode{blength gs} gives the length of a bounded sequence \isacode{gs}, \isacode{bnth gs n} gives the nth element in \isacode{gs}, and \isacode{gs\_i} returns the field value in a record of type \rcitem{GasSensor}. The two definitions are straightforward except that a definite description ({\isacode{THE result}, denoting the unique \isacode{result} such that the predicate holds}) is used to return the \isacode{result}.
We have two definitions here corresponding to the definition of \rcitem{intensity}: one for its precondition and one for its postconditions. This is due to the semantics of such a function \rcitem{f} in RoboChart: a boolean guard \cspcode{(pre(f)$\guard$~P)} where \cspcode{pre(f)} is the preconditions of \rcitem{f} and \rcitem{f} is called in process $P$, and so if the preconditions are not satisfied, the semantics deadlocks. 

We note that there is an error in the definition of \rcitem{intensity} in the original model where $\leq$ (instead of $<$) is used for comparison between \rcitem{x} (and \rcitem{y}) and \rcitem{size(gs)}. {This is because sequences are zero-indexed.} Our animation detects this error 
%(Isabelle raises an exception) 
and so we have fixed it. 
%Similarly, we also found another error in the postcondition of the function \rcitem{location}: the postcondition is not strong enough to identify a unique \rcitem{result} of the function.% for the same input. 

%The \rcitem{analysis} function defined in Fig.~\ref{fig:robochart_acd_chemical} has only one postcondition and its corresponding definition in Isabelle is shown below.
%\newcommand{\panalysis}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#2283}}
%\begin{alltt}
%\isakwmaj{definition} "Chemical\_analysis gs = (if blength gs > 0 then  \(\panalysis\)
%   (if (\(\exists\)x::nat<blength gs. \(\lnot\)gs\_i (bnth gs x) = 0) then Status_gasD else Status_noGas)
%   else Status_noGas)"
%\end{alltt}
%\vspace{-3ex}
%

The \rcitem{location} function defined in Fig.~\ref{fig:robochart_acd_chemical} has one precondition and one postcondition and their corresponding definitions in Isabelle are shown below. The \rcitem{result} of this function is the location (on the right or in the front of the robot, according to the definition of the \rcitem{angle} function) where the largest intensity in \rcitem{gs} is detected.
\newcommand{\prelocation}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L386}}
\newcommand{\postlocation}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_general.thy\#L389}}
 \begin{alltt}
\isakwmaj{definition} "pre\_Chemical\_location\ gs = (blength gs > 0)" \(\prelocation\)
\isakwmaj{definition} "Chemical\_location gs = (THE result. (\(\exists\)x::nat<blength gs. \(\postlocation\)
    (Chemical\_intensity(gs) = gs\_i (bnth gs x)) \(\land\)
    (\(\lnot\) (\(\exists\)y::nat < x. (Chemical\_intensity(gs) = gs\_i (bnth gs y)))) \(\land\)
    (\(\forall\)x::nat < blength gs. Chemical\_goreq(result, gs\_i (bnth gs x)))
    (result = Chemical\_angle(x))))"
 \end{alltt}
\vspace{-3ex}
%
Inside the definite description is an existential quantification over an index \isacode{x} of \isacode{gs} such that (a conjunction of three conjuncts)  
\begin{inparaenum}[(1)]
\item the intensity \isacode{gs\_i (bnth gs x)} of the sensor reading at index \isacode{x} is the largest intensity (\isacode{Chemical\_intensity(gs)}) in \isacode{gs}; 
\item there does not exist an index \isacode{y} such that \isacode{y} is less than \isacode{x} and the intensity at \isacode{y} is also the largest intensity in \isacode{gs} (in other word, \isacode{x} is the smallest index whose intensity is the largest); and   
\item the result of the function is just the angle \isacode{Chemical\_angle(x)} of \isacode{x}.
\end{inparaenum}

We also found another error in the postcondition of \rcitem{location} in the original model: the postcondition is not strong enough to identify a unique \rcitem{result} of the function for the same input (and so the result is a relation and not a function). Our definition of the function fixes this problem by specifying that \isacode{x} is the smallest index.

While there are problems with the definitions of \rcitem{intensity} and \rcitem{location} in the original model, their implementations in CSP for verification with FDR previously, however, are correct. This leads to an inconsistency between models and their semantic implementation for verification. Our approach presented here translates the specification of functions from models to their semantic implementation in Isabelle directly, and so the consistency is preserved. This is one benefit of our approach.
 
\changed[\C{0}]{
\subsection{Channels and alphabet transformation}
\label{ssec:semantics_channels}
% \begin{rmk}
%    Different approaches discussed to mechanise channel types and why we choose this approach. 
%    \begin{itemize}
%        \item A monolithic channel type for a whole model,
%        \item Or current approach to have a channel type for each state machin, controllor, or module.
%    \end{itemize}
% \end{rmk}
% 
% \paragraph{Channel type and declaration}
A CSP process in our semantics is an interaction tree of type $(E,R) \cspkey{itree}$, parametrised over a type $E$ of events representing the event alphabet ($\Sigma$) of the CSP process and a type $R$ of return values. 
$E$ is declared through the \isakwmaj{chantype} command and expressed as a finite set of channels declared in the command.  
Each channel $c$ is modelled by a prism~\cite{Pickering2017}: $V \pto E$ where $V$ is the value type of $c$. Each prism contains two functions~\cite[Definition 5]{Foster2021}: a destructor \IsaKey{match}: $E \pfun V$ and a constructor \IsaKey{build}: $V \Rightarrow E$. 
%We use \IsaKey{c\_C} for \IsaKey{build}$_c$. 
We show an example to illustrate the creation of such an event alphabet \isacode{chan}.
%
\begin{alltt}
\isakwmaj{chantype} chan = 
  Input::integer \(\qquad\) Output::integer \(\qquad\)State::"integer list"
\end{alltt}
%
\noindent 
This \isacode{chan} declares three channels: \isacode{Input} and \isacode{Output} of type \isacode{integer}, and \isacode{State} of type \isacode{integer list}. Each channel is modelled by a prism. For example, the channel \isacode{Input}, carrying a value of \isacode{integer}, has a type \isacode{integer~}$\pto$\isacode{~chan}. We use \IsaKey{build}$_{Input}~1$ (a notation \isacode{Input\_C 1} introduced for it) to construct an event (\isacode{Input 1}) of type \isacode{chan}.  

External choice $P \extchoice Q$ requires that $P$ and $Q$ have the same type $(E,R) \cspkey{itree}$ and so the same event type $E$. 
Parallel composition $P \parallel_A Q$ additionally requires that the type $R$ of return values is empty (\isacode{()} or \isacode{unit} in Isabelle) because CSP processes in parallel usually do not return data, and so both $P$ and $Q$ should be the type of $(E, ()) \cspkey{itree}$. $A$ here is a set of events and of type $\power E$.

For the CSP processes that have different types, they need to be transformed into the same type prior to composition. The alphabet transformation of a process $P$ of type $(E_1,R) \cspkey{itree}$ is through renaming (or renaming with priority) according to a renaming relation $\rho$ of type $E_1 \rel E_2$ (or a finite sequence $\varrho$ of type $\seq\left(E_1 \cross E_2\right)$), and the resultant process $\rename{P}{\rho}$ (or $\renamep{P}{\varrho}$) is of type $(E_2,R) \cspkey{itree}$.

We also note that the renaming relation or the finite sequence for the renaming operators is ``total'' --- only events of type $E_1$ in the relation or the sequence are renamed and others are blocked --- no matter whether this is a homogeneous ($E_1$ and $E_2$ are the same) or heterogeneous ($E_1$ and $E_2$ are different) renaming. This is different from the relational renaming operator in CSPM where the relation is partial and so the events that are not in the renaming relation are not affected by the renaming. This difference is due to the fact that ITrees or Isabelle's terms are strongly typed. 

In our ITree-based semantics for RoboChart, illustrated in Fig.~\ref{fig:robochart_acd_semantics} for the autonomous chemical detector model, each state machine, controller, or module has a different event alphabet by declaring an individual channel type. For example, the state machine \rcitem{GasAnalysis}, the controller \rcitem{MainController}, and the module \rcitem{ChemicalDetector} declare channel types \isacode{Chan\_\-GasAnalysis}, \isacode{Chan\_\-MainController}, and \isacode{Chan\_\-ChemicalDetector}. The renamed {GasAnalysis} transforms the event alphabet of \rcitem{GasAnalysis} from \isacode{Chan\_\-GasAnalysis} to \isacode{Chan\_\-MainController}, and so it can be composed in parallel with the controller memory (whose event type is \isacode{Chan\_\-MainController}). Similarly, the two controllers are renamed to the event alphabet \isacode{Chan\_\-ChemicalDetector} of the module, and so they are able to be composed in parallel with the robotic platform memory and buffer processes.

% \paragraph{Sets of events}
% Currently explicitly enumerate all events using the \isacode{map} function, another options are syntax $\isasymlbrace \isasymrbrace$ where the value type of an event must be enumerable in order for code generation. %and equal

}

\subsection{State machines}
\label{ssec:semantics_stm}
%\paragraph*{State machine definitions.}
The RoboChart semantics of a state machine is a parallel composition of memory processes for its variables (\cspcode{MemoryVar}) and transitions (\cspcode{MemoryTrans}), and a process (\cspcode{STM}) for its behaviour with internal events hidden and also catering for its termination using the exception operator. 

\cspcode{STM} is a parallel composition of the behaviour (\cspcode{STM\_I}) for its initial junction and the restricted behaviour (\cspcode{S\_R}) for each state \cspcode{S} synchronising on state entering and exiting events. A state's behaviour \cspcode{S} involves the entering of this state, the execution of its during-action, and the execution of one of its transitions. The execution of a transition exits the state, executes the action of the transition, and enters the target state of the transition. {Not all transitions are available for \cspcode{S}, such as the transitions from sibling states of \rcitem{S} and substates of \rcitem{S}. These transitions are excluded in the restricted behaviour \cspcode{S\_R}.}

The state machine semantics uses a general type \cspcode{InOut} for the direction of an event in a connection, two data types for state and transition identifiers (\cspcode{SIDS} and \cspcode{TIDS}), and an event alphabet ($E$) for the process of this state machine. %The event alphabet is represented by the parametrised type $E$ of events which is declared through the \isakwmaj{chantype} command. %$E$ is expressed by a finite set of channels declared in the command.
%In CSP-M, the event alphabet is denoted by \cspcode{Event} and is expressed by multiple channel declarations. 
%In Isabelle, we use a command \isakwmaj{chantype} to create a channel type \isacode{Chan} to group all channels. 
We show below an example of these data types for the \rcitem{Movement} machine in Fig.~\ref{fig:robochart_acd_movement}.
%
\newcommand{\InOut}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L162}}
\newcommand{\SIDSMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L77}}
\newcommand{\TIDSMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L104}}
\newcommand{\ChanMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L227}}
%
 \begin{alltt} 
\isakwmaj{datatype} InOut = din | dout \(\InOut\)
\isakwmaj{datatype} SIDS_Movement = SID_Movement | SID_Movement_Waiting | ... \(\SIDSMovement\)
\isakwmaj{datatype} TIDS_Movement = TID_Movement_t1 | TID_Movement_t2 | ...\(\TIDSMovement\)
\isakwmaj{chantype} Chan_Movement =   \(\ChanMovement\)
  internal_Movement :: TIDS_Movement
  terminate_Movement:: unit
  enter_Movement    :: "SIDS_Movement\(\cross\)SIDS_Movement" ...
  get_l_Movement    :: "Location_Loc"  
  set_l_Movement    :: "Location_Loc"
  obstacle__Movement:: "TIDS_Movement\(\cross\)InOut\(\cross\)Location_Loc"
  obstacle_Movement :: "InOut\(\cross\)Location_Loc" ...
  moveCall_Movement :: "core_real\(\cross\)Chemical_Angle" ...
\end{alltt}
The channel type of \rcitem{Movement} includes four kinds of channels.
%\begin{inparaenum}[(1)]
%\item 
Firstly, flow control channels include 
\begin{inparaenum}[(a)]
\item \isacode{internal}\footnote{In the Isabelle code, we include suffixes to ensure that names do not collide, but omit them here} for transitions without a trigger;
\item \isacode{enter}, \isacode{entered}, \isacode{exit}, and \isacode{exited} for the entering and exiting of a state; and
\item \isacode{terminate} for the termination of the machine.
\end{inparaenum}
Secondly,
%\item 
 variable channels contain a \isacode{set} and a \isacode{get} channel for each variable with an additional \isacode{set\_EXT} for each shared variable to accept an external update.
%\item 
Thirdly, event channels include two channels for each event of the machine, one such as \isacode{obstacle} for the event \rcitem{obstacle} used in actions of RoboChart and another such as \isacode{obstacle\_} (with an additional \isacode{TIDS} for its type) for the event \rcitem{obstacle} used as triggers of transitions.
%\end{inparaenum}
%
The distinction of two event channels (\isacode{obstacle} and \isacode{obstacle\_}) for each event (\rcitem{obstacle}) is necessary because the guard of a transition is evaluated in \cspcode{MemoryTrans}, and so only the trigger event (not action event) of  the transition is subject to the guard evaluation, and, therefore, has a new channel (\isacode{obstacle\_}) with a transition id. We note, however, that events \isacode{obstacle\_.tid} of this new channel are eventually renamed to the event channel \isacode{obstacle} in the process for the machine.
%
Fourthly, operation call channels include a channel such as \isacode{moveCall} for each call to the operation \rcitem{move} provided by the platform.
 
\subsubsection{Memory for variables and transitions}
%
The memory process \isacode{Memory\_x} for a shared variable \rcitem{x}, such as \rcitem{x} in the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}, is shown below.
%
\newcommand{\MemorySharedV}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/ITree_RoboChart.thy\#L292}}
\begin{alltt}
  \cspkey{loop} (\(\lambda\)v. get_x!v \(\to\) \(\subscriptIntt{\tick}{v}\) \(\extchoice\) set_x?x \(\to\) \(\subscriptIntt{\tick}{x} \extchoice\) set_EXT_x?x \(\to\) \(\subscriptIntt{\tick}{x}\)) \(\MemorySharedV\)
\end{alltt}
%
\noindent The process is an infinite loop. It provides three choices: output the value \isacode{v} on \isacode{get\_x} without updating the variable and
    accept a local (or external) update of the variable through \isacode{set\_x} (or \isacode{set\_EXT\_x}). For a local variable of the state machine, its memory process does not provide an external update.

The memory process for transitions of the state machine \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement} is partially (3 in 24 transitions) illustrated below.
%
\newcommand{\MovementMemoryTrans}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L747}}
\begin{alltt}
  Movement_MemoryTrans = \cspkey{loop} (\(\lambda\)id.  \(\MovementMemoryTrans\)
    internal!TID_t1 \(\to\) \(\subscriptIntt{\tick}{id}\) \(\extchoice\) 
    resume_!(TID_t0, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    turn_?(TID_t3, din, a\(\in\)Chemical_Angle) \(\to\) \(\subscriptIntt{\tick}{id}\) \(\extchoice\) 
    ...  \(\extchoice\) 
    get_d1?d1 \(\to\) get_d0?d0 \(\to\) 
      ((rc.Minus d1 d0 rc.core_int) > stuckDist)\(\guard\)(internal!TID_t12 \(\to\) \(\subscriptIntt{\tick}{id}\)) \(\extchoice\) 
    ...
\end{alltt}
%
The state of this loop process is a constant \isacode{id} (used to identify a RoboChart module). Each choice corresponds to a transition: 
\begin{inparaenum}[(1)]
    \item the first choice for the default transition \rcitem{t1} from the initial junction to state \rcitem{Waiting} which has no trigger (hence \isacode{internal}); 
    \item the second for the self transition of state \rcitem{Waiting} whose trigger is an output \rcitem{resume} (\rcitem{din} because the \rcitem{resume} event acts as an input in the state machine according to the connection in Fig.~\ref{fig:robochart_acd_microcontroller}); and   
    \item the third for the transition from \rcitem{Waiting} to state \rcitem{Going} which has an input trigger \rcitem{turn?a} where we use a notation \isacode{turn\_?(TID\_t3, din, a$\in$Chemical\_Angle)} to denote \isacode{\cspkey{inp} turn\_ \{(TID\_t3, din, a) | a$\in$Chemical\_Angle\}} (input values from a set of triples by set comprehension over a channel \isacode{turn\_}); and   
    \item the fourth for the transition from \rcitem{AvoidingAgain} to \rcitem{Avoiding} whose guard is \rcitem{(d1-d0>stuckDist)} (time semantics is ignored, \rcitem{-} becomes a closed operator \isacode{rc.Minus} under \isacode{core\_int}) and evaluated in this memory transition process.
\end{inparaenum}
We note that these choices will not lead to nondeterminism because their initial input or output events are parametrised over a distinct \isacode{TID} (for each choice).

For the transition with an input trigger and a guard together, such as the self transition of the state \rcitem{move} in Fig.~\ref{fig:robochart_patrol} with a trigger \rcitem{update?l} and a guard \rcitem{[l>=-MAX]}, its semantics in CSP is a constrained input prefix: \cspcode{update?l:(l$\geq$-MAX)} where \cspcode{(l$\geq$-MAX)} is a constraint on \cspcode{l}. So the memory process for transitions of the state machine \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol}  has choices illustrated below.
%
\newcommand{\MoveSTMMemoryTrans}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L725}}
\begin{alltt}
  MoveSTM_MemoryTrans = \cspkey{loop} (\(\lambda\)id. \(\MoveSTMMemoryTrans\)
    internal!(TID_t0, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    reset_!(TID_t2, din) \(\to\) \(\subscriptIntt{\tick}{id}\extchoice\) 
    inp update\_ \{(TID\_t1, din, l) | l \(\in\) rc.core\_int. l \(\geq\) (rc.Neg MAX rc.core\_int)\} \(\extchoice\) 
    inp update\_ \{(TID\_t3, din, l) | l \(\in\) rc.core\_int. l \(\leq\) MAX\})
\end{alltt}
%
In Isabelle, we encode constraints in the predicate part of set comprehension.
\subsubsection{Nodes}
The semantics of each node in a state machine is a CSP process. In this paper, we consider three kinds of nodes: initial junctions, basic states, and final states, which are used in the two RoboChart models. Semantics for other nodes including normal junctions and composite states are part of our future work.

\paragraph{Initial junctions}
We show the semantics for the initial junction \rcitem{i0} in the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}, which has an outgoing transition \rcitem{t0} with an action \rcitem{x=0} to set the variable \rcitem{x} to 0. 
%
\newcommand{\ICalSTMij}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L306}}
\begin{alltt}
  I_i0 = internal!(TID_t0, din) \(\to\) set_x!0 \(\to\) \(\ICalSTMij\) 
    enter!(SID_CalSTM, SID_CalSTM_cal) \(\to\) entered!(SID_CalSTM, SID_CalSTM_cal) \(\to\) \(\subscriptIntt{\tick}{}\)
\end{alltt}
%
\noindent The process outputs 
\begin{inparaenum}[(1)]
    \item a pair \isacode{(TID\_t0, din)} on the channel \isacode{internal}, denoting the empty trigger of \rcitem{t0} from \rcitem{i0} to state \rcitem{cal}; 
    \item 0 on the channel \isacode{set\_x}, denoting the initialisation of \rcitem{x} to 0 (by parallel composition with the memory for \isacode{x} presented later), which corresponds to the action of \rcitem{t0};
    \item a pair \isacode{(SID\_CalSTM, SID\_CalSTM\_cal)} on the channel \isacode{enter}, denoting the start of entering the state \rcitem{cal}; and
    \item a pair \isacode{(SID\_CalSTM, SID\_CalSTM\_cal)} on the channel \isacode{entered}, denoting the completion of entering \rcitem{cal}.
\end{inparaenum}

\paragraph{States}
The process $S$ for the behaviour of a state \rcitem{S} is sketched below.
%as \isacode{\cspkey{inp} update\_ \{(TID\_t1, din, l) | l$\in$rc.core\_int. l$\geq$rc.Neg MAX rc.core\_int\}} where \isacode{rc.Neg} is an arithmetic negation operator closed under a bounded integer type implemented in a locale \isacode{robochart\_confs} (see Sect.~\ref{ssec:inst}).

% The process \cspcode{S} for the behaviour of a state \rcitem{S} contains two recursions (one is nested) and its CSP code is sketched below.
% %
% \begin{alltt}
% S(id) = \cspkey{let}
%   S_execute(id,sr) = S_entry; entered.sr!SID_S\(\to\)(
%     ... [] ... -> S_execute(id,st1) ... [] ... -> S(id) ...)
% \cspkey{within} enter?sr:oSIDs!SID_S -> S_execute(id,sr)
% \end{alltt}
% %
% The process \cspcode{S} is a recursion because \cspcode{S\_execute} can be a recursion (by calling itself) or a mutual recursion (by calling \cspcode{S}).
% 
% ITrees supports a tail-recursive iteration: \isacode{(iterate b P s)} which iterates whilst the condition \isacode{b} is satisfied by state \isacode{s} and, otherwise, returns the current state \isacode{s}. A \isacode{loop} is a special iteration in which the condition is always true, and so it never terminates. For the process \cspcode{S} shown above, its corresponding implementation in Isabelle is given below.
% 
\begin{align*}
&S(id) = enter?sd:OSIDS \to S\_exec(id, fst~sd)\\
&S\_exec(id, s) = S\_entry \fatsemi entered!(s,SID\_S) \fatsemi\\
&%\left(
%\begin{array}{l}
	\left(
	    \begin{array}{l}
	    (S\_during \fatsemi stop) \interrupt \\
	    \left(
	        \begin{array}{l}
	    	\Extchoice t:sTrans @ \left(
	    		\begin{array}{l}
	    		    e\_t?(TID\_t, \_) \to exit!pSID\_S \to S\_exit \fatsemi \\
	    		    exited!pSID\_S \to enter!pSID\_S \to \\
	    		    S\_exec(id, SID\_S)
	    		\end{array}\right)
 \extchoice \\
	    	\Extchoice t:oTrans @ \left(
	    		\begin{array}{l}
	    		    %e\_t?(TID\_t, \_) \to exit!pSID\_S \to S\_exit; \\
	    		    ... \fatsemi exited!pSID\_S \to enter!(SID\_S, SID\_td) \\
	    		    \to entered!(SID\_S, SID\_td) \to S(id)
	    		\end{array}\right) \extchoice\\
	    		\Extchoice e\_:EvtChs @ \left(
	    		\begin{array}{l}
	    		e\_?(TID\_t,\_) \to exit?sd:OSIDS \to \\ (S\_exit \fatsemi exited?(fst~sd, SID\_S) \to S(id))
	    		 \end{array}
	    		\right)
	        \end{array}
	    \right)
	    \end{array}
	\right)
%\end{array}
%\right)
\end{align*}
$S$ and $S\_exec$ are defined by mutual recursion. Initially, $S$ accepts $enter$ing from other nodes of the state machine containing \rcitem{S} where $OSIDS$ denotes a set of pairs $(oSID, SID\_S)$ ($oSID$ is $SID$ for one of the other nodes and $SID\_S$ is $SID$ for \rcitem{S}). Afterwards, the behaviour of \rcitem{S} is given by $S\_exec$ with its second argument being the other node (the first element of $sd$). 

$S\_exec$, with a parameter $s$ denoting the node entering \rcitem{S}, executes the entry action of \rcitem{S} first, if any, denoted by $S\_entry$. Then \rcitem{S} is $entered$.
% by outputting a pair $(s, SID\_S)$
After that, the behaviour is given by an interrupt. The during-action of \rcitem{S} ($S\_during$) can be executed if none of the initial events of the right side (external choices) of the interrupt is performed, that is, none of the self transitions $sTrans$ of \rcitem{S} or other transitions $oTrans$ from \rcitem{S} is taken, or none of the trigger events $EvtChs$ of the state machine containing \rcitem{S} is signalled. If, however, any of these transitions is taken or any of these trigger events is signalled, then the during-action is interrupted. A $stop$ process after $S\_during$ prevents the interrupt from being terminated and so interruption is always possible.

For each $t$ of $sTrans$, it behaves as follows: 
\begin{inparaenum}[(1)]
    \item the corresponding event channel $e\_t$ for its trigger event, such as \isacode{obstacle\_}, synchronises on $t$ (identified by $TID\_t$) only;
    \item \rcitem{S} starts to $exit$ by itself where $pSID\_S$ denotes $(SID\_S, SID\_S)$;
    \item the exit action of \rcitem{S}, denoted by $S\_exit$, is executed;
    \item \rcitem{S} is $exited$;
    \item $t$ starts to $enter$ \rcitem{S} again because it is a self transition; and 
    \item finally $S\_exec$ is recursively called with the source state $s$ being $SID\_S$.
\end{inparaenum}

For each $t$ of $oTrans$, the early behaviour is the same as above and so it is omitted ($...$). After \rcitem{S} is $exited$, $t$ starts to $enter$ its target from \rcitem{S}, identified by $SID\_td$, and then the target is $entered$. Finally, \rcitem{S} returns to its initial state ($S(id)$ is called) and accepts a further $enter$ request.

For each trigger event \rcitem{e} of the state machine containing \rcitem{S}, there is a corresponding additional event channel \isacode{e\_} declared in the channel type of the machine. The set of these channels is denoted by $EvtChs$. If this event $e$ of a transition $t$ is signalled ($e?(TID\_t,\_)$), the during-action is interrupted and \rcitem{S} accepts an $exit$ from one of the other nodes. Then its exit action, denoted by $S\_exit$, is executed. Afterwards, \rcitem{S} is $exited$ from the node ($fst~sd$). Finally, \rcitem{S} returns to its initial state ($S(id)$ is called) and accepts a further $enter$ request.

$S$ and $S\_exec$ are implemented in ITrees through nested iterations: the outer iteration, corresponding to $S$, is an infinite \cspkey{loop} and the inner, corresponding to $S\_exec$, is a conditional iteration by the \cspkey{iterate} constructor. The condition is true for self-transitions and false otherwise. 

An example of the process for state \rcitem{Waiting} in \rcitem{Movement} in Fig.~\ref{fig:robochart_acd_movement} is shown below.
% can be found online (\isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}).
% \begin{align*}
% &S(id) = \cspkey{loop} \left(\lambda id. enter?sd:OtSIDS \to S\_exec(id, fst~sd); \tick_{id} \right)\\
% &S\_exec(id, s) = \\
% &\left(
% \begin{array}{l}
% 	S\_entry; entered!(s,SID\_S); \\
% 	\left((S\_during; stop) \interrupt \left(
% 	\begin{array}{l}
% 		(selfTransFromS; S\_exec(id, s)) \extchoice \\
% 		(otherTransFromS; S(id)) \extchoice\\		
% 	\end{array}
% 	\right)
% 	\right)
% \end{array}
% \right)\\
% \end{align*}
% \begin{alltt}
% S = \cspkey{loop} (\(\lambda\)id::integer. do \{ 
%   enter?sd:Other_SIDS_to_Waiting \(\to\) (
%   ret \(\gets\) \Ret (True, id, fst sd);  
%   (\cspkey{iterate} (\(\lambda\)s. fst s) (\(\lambda\)s. do \{ 
%     outp entered (snd (snd s), SID_Waiting);
%     (({CALL__randomWalk(id); stop}) \(\interrupt\)
%       (
%       \(\extchoice\)
%       ; \Ret (True, fst (snd s), st1)\(\extchoice\) 
%       ...; \Ret (False, fst (snd s), _)
%       )
%     )
%     \}) (ret)); 
%   \Ret (id))
% \})
% \end{alltt}
\newcommand{\StateWaiting}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}}
\begin{alltt}
1 State_Waiting = \cspkey{loop} (\(\lambda\)id::integer. \(\StateWaiting\)
2   sd \(\gets\) inp enter \{(s, SID_Waiting) | s. \(\lnot\) s \(\in\) SIDS_Movement_no_Waiting\} ;
3   ret \(\gets\) \Ret (True, id, fst sd);  
4   (\cspkey{iterate} (\(\lambda\)r. fst r) (\(\lambda\)r. 
5     entered!(snd (snd r), SID_Waiting); (
6     ({CALL__randomWalk(id); stop}) \(\interrupt\) (
7       (resume_!(TID_t0, din) \(\to\) exit!(SID_Waiting, SID_Waiting) \(\to\) 
8        exited!(SID_Waiting, SID_Waiting) \(\to\) enter!(SID_Waiting, SID_Waiting); 
9        \Ret (True, fst (snd r), SID_Waiting)) \(\extchoice\)
10      (turn_?(TID_t2, din, a\(\in\)Chemical_Angle) \(\to\) set_a!a \(\to\) 
11       exit!(SID_Waiting, SID_Waiting) \(\to\) exited!(SID_Waiting, SID_Waiting) \(\to\) 
12       enter!(SID_Waiting, SID_Going) \(\to\) entered!(SID_Waiting, SID_Going) ; 
13       \Ret (False, fst (snd r), SID_Waiting)) \(\extchoice\) 
14       ...
15  ))) (ret)); \Ret (id))
\end{alltt}
Basically, \isacode{State\_Waiting} is an infinite loop, an ITree, whose state (a state of an ITree is its carried data or its return value) is an integer \isacode{id} (corresponding to the parameter \cspcode{id}), with a nested conditional iteration by \isacode{iterate} (corresponding to \cspcode{S\_exec}). The state of the iteration is a triple such as \isacode{(True, id, fst sd)}, whose first element is a boolean value to indicate if this iteration terminates or not, whose second element is \isacode{id}, and whose third element is the RoboChart state (for example \isacode{fst sd}, see lines 2 and 3)  that initiates entering of the state \rcitem{Waiting} of \cspcode{S\_exec}. Initially, the state of the iteration is passed from its preceding \isacode{Ret} construct and recorded in a variable \isacode{ret} (also the third argument of \isacode{iterate}, see line 15). 

In the iteration body, \isacode{snd (snd r)} on line 5 is the third element of the tuple \rcitem{r} and is a RoboChart state.
\isacode{CALL\_\_randomWalk(id)} on line 6 corresponds to the call to an operation \rcitem{randomWalk} (provided by the robotic platform) in the during-action of \rcitem{Waiting}. Lines 7 to 9 correspond to the self transition \rcitem{t0} of \rcitem{Waiting}, whose trigger is \rcitem{resume}, and lines 10 to 13 correspond to the transition \rcitem{t2} (from \rcitem{Waiting} to \rcitem{Going}) whose trigger is \rcitem{turn?a}. We note that there is no \isacode{entered} event for \rcitem{t0} and the first element in the return value \isacode{\Ret (True, fst (snd r), SID\_Waiting)} is \isacode{True}. This is because \rcitem{t0} is a self transition and it does not need to wait for entering shown on line 2. The first element \isacode{True} makes \isacode{iterate} continue its inner iteration, and the third element \isacode{SID\_Waiting} means this is entering from the state \rcitem{Waiting} itself.
The transition \rcitem{t2} is different from \rcitem{t0} in that it 
\begin{inparaenum}[(1)]
\item has an input trigger to get the angle and record it in the local variable \rcitem{a}, as shown on line 10; and 
\item will exit \rcitem{Waiting} (on line 11) and enter \rcitem{Going} (on line 12). 
\end{inparaenum}
The execution of this transition will leave the inner iteration by setting the first element of the return value to \isacode{False} (on line 13).

The restricted behaviour of \rcitem{Waiting} is shown below.
\newcommand{\StateWaitingR}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L}}
\newcommand{\WaitingRParallelE}{\parallel_{\isacode{{internal\_events - trigger\_events}}}}
\begin{alltt}
State_Waiting_R = \(\lambda\)id. State_Waiting(id) \(\WaitingRParallelE\) \cspkey{skip} \(\StateWaitingR\)
\end{alltt}
\isacode{State\_Waiting\_R} is a parallel composition of \isacode{State\_Waiting} and a \cspkey{skip} process over a set of events for synchronisation which is the set difference of all internal events \isacode{internal\_event} (including \isacode{e\_} events and \isacode{internal\_} events) and all trigger events \isacode{trigger\_events} of the machine \rcitem{Movement}. The parallel composition with \cspkey{skip} blocks all events in the synchronisation set and leaves all events in \isacode{trigger\_events} to proceed independently.
We note that for a basic state such as \rcitem{Waiting}, its restricted process will not change its behaviour \isacode{State\_Waiting}. The reason why restricted behaviour is needed is because of composite states. We will deal with it in the future.
%\isacode{Ret (True,fst (snd s),st1)} corresponds to \cspcode{S\_execute(id,st1)} where the iteration continues (\isacode{True}) with the same \isacode{id} (the second element of its state) and a new \isacode{st1} as the state of the next iteration. \isacode{Ret (False,fst (snd s),\_)} corresponds to the call \cspcode{S(id)} in the definition of \cspcode{S\_execute}. Because the first element is \isacode{False}, the iteration will terminate and return this triple. In this case, the only state carried on is \isacode{id} and so we represent here \isacode{\_}. This unnecessary state is discarded after the termination of the iteration when the body of the loop returns \isacode{id} only by \isacode{Ret (id)}.

%The behaviour of each state of the \rcitem{Movement} machine is implemented as such a loop.

%The process for a state machine also needs to rename event channels, such as from \isacode{obstacle\_} to \isacode{obstacle}, to forget the extra \isacode{TID} because \isacode{TID} is introduced inside a state machine for the trigger of transitions. In order to form a renaming relation for forgetting \isacode{TID}, we define several functions in Isabelle.
%
%\newcommand{\mapf}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L94}}
%\newcommand{\mapfc}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L91}}
%\newcommand{\forgettwo}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/81ca0b6ded0cfaf8e4ea1744520daed3d79fd441/RoboChart/ITree_RoboChart.thy\#L150}}
%
% \begin{alltt}
% \isakwmaj{definition} mapf::"('b \(\Rightarrow \)'a) list \(\Rightarrow\) 'b list \(\Rightarrow\) 'a list" \isakwmin{where}
% "mapf fs xs = concat (map (\(\lambda\)f. map f xs) fs" \(\mapf\)
% \isakwmaj{definition} mapfc::"('c\(\cross\)'a\(\Rightarrow\)'b) list\(\Rightarrow\)'c list \(\Rightarrow\)('a\(\Rightarrow\)'b) list"  \(\mapfc\)
% \isakwmin{where} "mapfc fs xs = concat (map (\(\lambda\)f. map f xs) (map curry fs))"
% \isakwmaj{definition} forget_first2::"('e\(\cross\)'a\(\cross\)'b\(\Rightarrow\)'c)\(\Rightarrow\)('a\(\cross\)'b\(\Rightarrow\)'d) 
%   \(\Rightarrow\)'e list \(\Rightarrow\)'a\(\cross\)'b \(\Rightarrow \)'c\(\cross\)'d list" \isakwmin{where} \(\forgettwo\)
% "forget_first2 e_ e xs = 
%   \(\lambda\)(dir, n). mapf [(\(\lambda\) tid. (e_ (tid, dir, n), e (dir,n))] xs"
% \end{alltt} 
% The function \isacode{mapf} applies each function in a list \isacode{fs} of functions to each element of a list \isacode{xs} and has all results concatenated. The function \isacode{mapfc} is similar to \isacode{mapf} except that the domain of each function \isacode{f} in \isacode{fs} is a pair and then \isacode{f} is converted into a curried version like \isacode{('c\(\Rightarrow\)'a\(\Rightarrow\)'b)} by \isacode{curry}. The function \isacode{mapfc} defines a list of functions. The function \isacode{forget\_first2} defines a list of pairs in which each pair has the first element of \isacode{e\_} ignored when mapped to \isacode{e}.
% As an example, we consider renaming of \isacode{obstacle\_\_Movement} to \isacode{obstacle\_Movement} below.
% \begin{alltt}
% mapf (mapfc [forget_first2 obstacle__Movement_C obstacle_Movement_C 
%   TIDS_Movement_list]) InOut_list Location_Loc_list
% \end{alltt}
% %Here we use a symbol \isacode{c_C} for \isacode{build_c}.
% The result is a list of event maps such as
% \begin{alltt}
% [(obstacle__Movement_C (TID_Movement_t0, din, Location_Loc_left),
%   obstacle_Movement_C (din, Location_Loc_left)), ...]
% \end{alltt}
% We define \isacode{rename\_Movement\_events} for such event maps for each event channel in \isacode{Chan\_Movement} defines. All other channels that will not be renamed have each event of these channels mapped to itself, defined in \isacode{rename\_Movement\_events\_others}. Finally, the renaming relation of \isacode{Movement} is a set of pairs given below where \isacode{set} is the set representation of a list.
% \begin{alltt}
% set (rename_Movement_events @ rename_Movement_events_others)
% \end{alltt}
%\sloppy For the implementation of actions of RoboChart in ITrees, we illustrate two examples here. One example is the during action of state \rcitem{Waiting}: an operation call \rcitem{randomWalk()} and its implementation is \isacode{randomWalkCall!()}, an event  synchronisation. Another example is an assignment \rcitem{i=intensity(gs)} where \rcitem{i} is a local variable and \rcitem{intensity} is a function described previously. The implementation of this assignment in ITrees is \isacode{pre\_Chemical\_intensity(gs) \(\&\) (set\_i!(Chemical\_intensity(gs)) \(\to \tick\))}, and so if the precondition does not hold, this guarded process deadlocks.

\subsubsection{Composition of STM and memory processes}
As sketched in Figs~\ref{fig:robochart_semantics} and~\ref{fig:robochart_acd_semantics}, the semantics of a state machine is the parallel composition of the composed processes for its nodes and its memory.
We show below the composed processes for the nodes of the state machine \rcitem{CalSTM} in Fig.~\ref{fig:robochart_patrol}.
\newcommand{\StateCalR}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988}}
\begin{alltt}
STM_CalSTM = \(\lambda\)id. I_i0(id) |[ flow_events_from_other_states ]| State_cal_R \(\StateWaitingR\)
\end{alltt}
The composed process \isacode{STM\_CalSTM} (called the node process) is a parallel composition of the process \isacode{I\_i0} for the initial junction and the restricted process \isacode{State\_cal\_R} for the state \isacode{cal} over all the flow events \isacode{flow\_events\_from\_other\_states} that enter \rcitem{cal} from other states.

Then the node process of a state machine is composed in parallel with the memory of the machine with proper event hiding. The definitions of such composition (called the node memory process) are omitted here for simplicity and can be found online (\isacode{MemorySTM\_Movement} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988} for the machine \rcitem{Movement} and \isacode{MemorySTM\_CalSTM} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/43f32468b51a349c588bf687ef9560af713def8a/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L988} for the machine \rcitem{CalSTM}). We note that in such a process, the \isacode{internal} events used for synchronisation between the node process and the memory, the \isacode{get} events of all variables, and the \isacode{set} events of all local variables are hidden because these events are used to synchronise between the node process and the memory and are internal. The \isacode{set} events of shared variables are not hidden because the update to shared variables by the \isacode{set} events needs to be propagated to other state machines.

As discussed previously, each event \rcitem{e} of a state machine has two corresponding event channels \isacode{e\_} (for triggers) and \isacode{e} (for actions) in the semantics of the machines, such as \isacode{obstacle\_} and \isacode{obstacle} for the event \rcitem{obstacle} of the machine \rcitem{Movement}. Trigger event channels \isacode{e\_} in the composition of the nodes and the memory of a machine are renamed to \isacode{e} by forgetting the first element (a transition identifier) of the value carried on \isacode{e\_}. For example, \isacode{MemorySTM\_Movement} is renamed according to a renaming relation \isacode{event\_map}.
%
\newcommand{\RenamedMemorySTMMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L2051}}
\begin{alltt}
Renamed_MemorySTM_Movement = \(\rename{\isacode{MemorySTM\_Movement }}{\isacode{event\_map}}\) \(\RenamedMemorySTMMovement\)
\end{alltt}
%
The \isacode{event\_map} contains the mappings not only for the trigger events like \isacode{(obstacle\_.(TID\_t6, din, Loc\_left), obstacle.(din, Loc\_left))} but also for other event channels (events for actions, \isacode{terminate}, shared variable channels \isacode{set} and \isacode{set\_EXT}, and operation call) that will not be renamed like \isacode{(obstacle.(din, Loc\_left), obstacle.(din, Loc\_left))} and \isacode{(terminate.(), terminate.())} because the renaming relation is total.

Renaming, however, may result in nondeterminism in the RoboChart semantics, which is excluded in our renaming operator. For example, the renaming of \isacode{MemorySTM\_MoveSTM} for the state machine \rcitem{MoveSTM} in Fig.~\ref{fig:robochart_patrol} blocks both self transitions of the state \rcitem{move} that have an input trigger \rcitem{update?l}.
%
\newcommand{\RenamedMemorySTMMoveSTM}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1020}}
\begin{alltt}
Renamed_MemorySTM_MoveSTM = \(\rename{\isacode{MemorySTM\_MoveSTM }}{\isacode{event\_map}}\) \(\RenamedMemorySTMMoveSTM\)
\end{alltt}
%
The \isacode{event\_map} contains the mappings like \isacode{(update\_.(TID\_t1, din, v), update.(din, v))} and \isacode{(update\_. (TID\_t3, din, v), update.(din, v))} where \isacode{v} is a literal integer number in \isacode{core\_int}.
For \isacode{v} that is between \isacode{-MAX} and \isacode{MAX}, the two events \isacode{update\_.(TID\_t1, din, v)} and \isacode{update\_.(TID\_t3, din, v)} are both enabled for communication (see the definition of \isacode{MoveSTM\_MemoryTrans} where both predicates in the two set comprehensions are satisfied) and they are mapped to a same event \isacode{update.(din, v)} in this relation. According to the definition of renaming in Sect.~\ref{ssec:itree_renaming}, both events are blocked and so the state \rcitem{move} is not able to take the two self transitions. This problem can be solved by using the renaming with priority defined in Sect.~\ref{ssec:itree_renaming_with_priority}.
%
\newcommand{\RenamedpMemorySTMMoveSTM}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1028}}
\begin{alltt}
Renamedp_MemorySTM_MoveSTM = \(\renamep{\isacode{MemorySTM\_MoveSTM }}{\isacode{event\_map\_list}}\) \(\RenamedpMemorySTMMoveSTM\)
\end{alltt}
%
The \isacode{event\_map\_list} has the same mappings as \isacode{event\_map}, but it is a list (and so the mappings are ordered) instead of a relation. This renaming gives priority to the event at the front of the list. If \isacode{(update\_.(TID\_t3, din, v), update.(din, v))} is after \isacode{(update\_.(TID\_t1, din, v), update.(din, v))}, then \rcitem{t1} has a priority and so the nondeterminism is resolved. This corresponds to moving towards only one direction (to the left) when the robot is in Section S2 in Fig.~\ref{fig:robochart_patrol_sections}, instead of the nondeterministic choice of two directions. If we change the order of the two mappings, then \rcitem{t3} will have a priority and the direction  of the movement to the right will be chosen.

The semantics of a state machine also needs to take its termination (for example the final state is reached) into consideration. This is shown in the process for \rcitem{MoveSTM} below. 
%
\newcommand{\DMoveSTMp}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1056}}
\begin{alltt}
D\_MoveSTM = (\(\except{\isacode{Renamedp\_MemorySTM\_MoveSTM}}{\{\isacode{terminate.()}\}}{\cspkey{skip}}\)) \(\hide\) internal_events \(\DMoveSTMp\)
\end{alltt}
%
Based on the definition of the exception operator, if \isacode{Renamedp\_MemorySTM\_MoveSTM} ever performs a \isacode{terminate} event, then \cspkey{skip} will take over and so the process terminates. The process also hides all \isacode{internal} events and flow control events, defined in \isacode{internal\_events}.

%% \subsubsection{Nondeterminism}
%% Nondeterminism in RoboChart (excluding during actions and composite states):
%% \begin{itemize}
%%     \item Within state machines 
%%         \begin{itemize}
%%             \item More than two transitions from a state are enabled at the same time, and they must have overlapped guards,
%%                 \begin{itemize}
%%                     \item they have the same trigger (external events or events to and from RP). In this case, nondeterminism is introduced by renaming \verb+e.t1.v1+ and \verb+e.t2.v2+ to \verb+e.v1+ and \verb+e.v2+ respectively by removing the first TID; or 
%%                     \item they have the same trigger (internal independent events of machines, without connections to other state machines). In this case, nondeterminism is introduced by renaming \verb+e.t1.v1+ and \verb+e.t2.v2+ to \verb+e.v1+ and \verb+e.v2+ respectively by removing the first TID, then possibly hiding; or 
%%                     \item they have no triggers or the same \verb+internal__+ trigger. In this case, nondeterminism is introduced by hiding \verb+internal__.t1+; should hide a list of events, or
%%                     \item they have different triggers but these triggers are internal. Nondeterminism is introduced by hiding events. 
%%                 \end{itemize}
%%             \item Interleaving behaviours between state machines,
%%         \end{itemize}
%%     \item Inter-machines (within a controller)
%%     \item Inter-machines (within a module, or different controllers)
%% \end{itemize}

\subsection{Operations}
\label{ssec:semantics_operation}

Operations in RoboChart can be provided by robotic platforms such as \rcitem{move} and \rcitem{randomWalk} in Fig.~\ref{fig:robochart_acd_module}, or defined by state machines such as \rcitem{changeDirection} in Fig.~\ref{fig:robochart_acd_location}.

The semantics of a call (an action) to an operation that is provided by a robotic platform is an event to record the call with appropriate parameters. For example, the semantics of \rcitem{move(lv,a)}, the entry action of the state \rcitem{Going} in Fig.~\ref{fig:robochart_acd_movement}, is \isacode{get\_a?a $\to$ moveCall!(const\_lv, a) $\to \subscriptIntt{\tick}{}$} where the message on the channel \isacode{moveCall} contains the value \isacode{const\_lv} of the constant variable \rcitem{lv} and the value of the local variable \rcitem{a}, retrieved from the memory through \isacode{get\_a}.

%In general, the semantics of a state machine-defined operation has a similar structure to that of a state machine in that both of them are the composition of node processes and memory processes. 
The semantics of a state machine-defined operation is different from that of a state machine because an operation is not an independent execution element like a state machine. Its behaviour is within the scope of the state machine that calls the operation. 
For this reason, the semantics of the operation does not include a separate channel type (or an event alphabet) and does not have a separate memory. Instead, all channels required for the operation are declared along with the channels for the caller state machine in a channel-type declaration. For example, the channel type \isacode{Chan\_Movement} of \rcitem{Movement} has the following additional channels for the operation \rcitem{changeDirection}.
%
 \begin{alltt} 
\isakwmaj{chantype} Chan_Movement =   \(\ChanMovement\)
  ...
  internal_changeDirection :: TIDS_changeDirection
  enter_changeDirection    :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  entered_changeDirection  :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  exit_changeDirection     :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  exited_changeDirection   :: "SIDS_changeDirection\(\cross\)SIDS_changeDirection"
  terminate_changeDirection:: unit
  get_l_changeDirection    :: "Location_Loc"
  set_l_changeDirection    :: "Location_Loc"
\end{alltt}
The \isacode{get\_l} and \isacode{set\_l} channels are for the parameter \rcitem{l} of the operation and not for a local variable \rcitem{l} (indeed, there is no such local variable). Different from local variables, \rcitem{l} is only set once (\isacode{set\_l}) by the caller of the operation for passing its value, not inside the operation like local variables. The call \rcitem{changeDirection(l)} to the operation in the entry action of the state \rcitem{Avoiding} has its semantics in CSP as follows.

\newcommand{\CallChangeDirectionMovement}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous_microcontroller.thy\#L670}}
\begin{alltt}
CALL__changeDirection_Movement = \(\CallChangeDirectionMovement\)
  \isacode{get\_l\_Movement?l \(\to\) set\_l\_changeDirection!l \(\to\) \(\subscriptIntt{\tick}{}\); D\_changeDirection } 
\end{alltt}
The first input event gets the value of the local variable \rcitem{l} of \rcitem{Movement} and the value is recorded in \isacode{l}. The second event updates the value of the parameter \rcitem{l} (in the memory) of \rcitem{changeDirection} to \isacode{l}. Finally, the process for this call behaves like the process \isacode{D\_changeDirection} for \rcitem{changeDirection}. 

We note that the process \isacode{D\_changeDirection} is not similar to the process \isacode{D\_MoveSTM} to have a composition of the node process and the memory process of the machine. \isacode{D\_changeDirection} basically is a node process with appropriate event hiding and termination. The memory of \rcitem{changeDirection} is part of the memory of \rcitem{Movement} and so it is composed in parallel with the node process of \rcitem{Movement} like the memory of \rcitem{Movement}.

% The semantics of an operation, however, is different in terms of how behaviour and memory processes are composed or used. Its memory is part of the memory of the state machine that calls the operation, and so its memory processes are composed in parallel with those of the caller state machine. Its behaviour process is part of the calls (actions in RoboChart) to this operation. For this reason, the channel type of a state machine such as \isacode{Chan\_Movement} also contains flow control and variable channels for the  \rcitem{changeDirection} operation. We note there is no event and operation call channels like those for state machines because events and operations used in a defined operation must be required by the caller state machine and so those channels are declared with the semantics of the state machine.
%  
% We also note that the values passed to an operation from its caller through parameters are simulated using extra parameter variables  (one for each parameter) in its memory for exchange. For example, the process for \rcitem{changeDirection} contains a variable \isacode{l} in its memory. Then the call \rcitem{changeDirection(l)} to this operation is implemented as a function shown below.
% %
% \begin{alltt}
% CALL__changeDirection_Movement id l = do \{
%   outp set_l_changeDirection l; D__changeDirection id\}
% \end{alltt}
% %
% Here a parameter variable in the memory is updated to the value of \isacode{l} by channel \isacode{set\_l\_changeDirection}, and \isacode{D\_\_changeDirection} is the process for the operation which contains the state machine behaviour and termination of the operation, but no memory processes. The memory for this parameter variable is set only upon a call to this operation and not by the processes for this operation, which implements passing by value.

% How to access local and shared variables provided by its containing state machine.

\subsection{Controllers}
\label{ssec:semantics_ctrl}
%\paragraph*{Controllers.}
%\changed[\C{0}]{
%\subsubsection{Memory}
%\subsubsection{Channels}
%\subsubsection{Composition of state machines with its memory}
%}

The event alphabet of the process for a controller  % is also declared using the \isakwmaj{chantype} command, 
contains a termination channel, shared variable channels, event channels, and operation call channels. The event channels include not only the events of the controller but also those in connections between its state machines. The channel type of the controller \rcitem{Ctrl} in Fig.~\ref{fig:robochart_patrol} is such one example.
\newcommand{\ChanCtrl}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1071}}
\begin{alltt}
\isakwmaj{chantype} Chan_Ctrl = \(\ChanCtrl\)
  terminate_Ctrl         :: unit 
  set_x_Ctrl             :: core_int
  get_x_Ctrl             :: core_int
  set_EXT_x_Ctrl         :: core_int
  set_EXT_x_Ctrl_CalSTM  :: core_int
  set_EXT_x_Ctrl_MoveSTM :: core_int
  rec_Ctrl               :: "InOut\(\cross\)core_int"
  reset_Ctrl             :: "InOut"
  update_Ctrl            :: "InOut\(\cross\)core_int"
\end{alltt}
This channel type includes a \isacode{terminate} channel, two \isacode{get} and \isacode{set} channels for the required shared variable \rcitem{x}, three \isacode{set\_EXT} channels for accepting the update of \rcitem{x} (through \isacode{set\_EXT\_x\_Ctrl}) and then propagating the update to the state machines of the controller that require \rcitem{x}: \rcitem{CalSTM} and \rcitem{MoveSTM} (through \isacode{set\_EXT\_x\_Ctrl\_CalSTM} and \isacode{set\_EXT\_x\_Ctrl\_MoveSTM}), and three event channels. The event channels are not only for the events \rcitem{rec} and \rcitem{reset} of \rcitem{Ctrl}   but also for the event \rcitem{update} that is used for communication between the two state machines.

The memory of a controller deals with the update of shared variables. The memory of \rcitem{Ctrl} is such an example. 
\newcommand{\CtrlMemory}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1104}}
\begin{alltt}
Memory_Ctrl = \cspkey{loop} (\(\lambda\)id. 
    set_EXT_x_Ctrl?x \(\to\) set_EXT_x_Ctrl_CalSTM!x \(\to\) set_EXT_x_Ctrl_MoveSTM!x \(\to\) \(\subscriptIntt{\tick}{id}\)) 
\end{alltt}
This process accepts an update to \rcitem{x} through an input event and propagates it to \rcitem{CalSTM} and \rcitem{MoveSTM} through two output events.

Parallel composition of the heterogeneous state machine processes (\rcitem{D\_CalSTM} and \rcitem{D\_MoveSTM}, for example, have different event alphabets) for a controller requires they all share a common event type $E$, and so we rename them. The events of the state machines are renamed to the corresponding events in the controller alphabet, according to the connections between the controller and its state machines. For example, \rcitem{D\_CalSTM} is renamed based on a renaming relation that maps the events of \rcitem{D\_CalSTM} to the events of \rcitem{D\_Ctrl}, such as \isacode{(set\_x\_CalSTM.v, set\_x\_Ctrl.v)} and \isacode{(update\_CalSTM.(dout, v), update\_Ctrl.(dout, v))}. \rcitem{D\_MoveSTM} is similarly renamed but its renaming relation contains a mapping \isacode{(update\_MoveSTM.(din, v), update\_Ctrl.(dout, v))} with opposite directions \isacode{din} and \isacode{dout}. Finally, both \isacode{update\_CalSTM.(dout, v)} and \isacode{update\_MoveSTM.(din, v)} are renamed to the same event \isacode{update\_Ctrl.(dout, v)}, which allows the two state machines to communicate on the channel \isacode{update} through parallel composition according to the directions (\rcitem{CalSTM} uses it for output and \rcitem{MoveSTM} uses it for input) of the event \rcitem{update} in the connection between the state machines.

The semantics of a controller is a parallel composition of the composed state machine processes and its memory with appropriate event hiding and termination. The process for \rcitem{Ctrl} is given as follows.
\newcommand{\DCtrl}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1179}}
\newcommand{\CtrlParallelE}{\parallel_{\isacode{stms\_events}}}
\newcommand{\CtrlMemParallelE}{\parallel_{\isacode{mem\_events}}}
%
\begin{alltt}
1 D_Ctrl = ((((\(\rename{\isacode{D\_CalSTM }}{\isacode{CalSTM\_events\_map}}\) \(\DCtrl\)
2              \(\CtrlParallelE\) 
3              \(\rename{\isacode{D\_MoveSTM }}{\isacode{MoveSTM\_events\_map}}\)
4             ) \(\hide\) (stms\_events - \{terminate_Ctrl.()\})
5            ) \(\CtrlMemParallelE\) Memory_Ctrl
6           ) \(\hide\) mem_events
7          ) \(\except{\isacode{}}{\{\isacode{terminate_Ctrl.()}\}}{\cspkey{skip}}\)
\end{alltt}
The parallel composition of the two state machines of \rcitem{Ctrl} is defined on lines 1 to 3 where the events of the two machine processes (\isacode{D\_CalSTM} and \isacode{D\_MoveSTM}) are renamed to those of \isacode{Ctrl} and \isacode{smts\_events} are a set of events including the termination event \isacode{terminate\_Ctrl} and the events \isacode{update.(dout,v)} used for communication between the machines. The events used for communication then are hidden on line 4. The process after hiding is then composed in parallel with the memory of \rcitem{Ctrl} on line 5 where \isacode{mem\_event} is a set of variable events used for propagating the update of shared variables to the state machines, including \isacode{set\_EXT\_x\_Ctrl\_CalSTM.v} and \isacode{set\_EXT\_x\_Ctrl\_MoveSTM.v}. These events are also hidden on line 6. Finally, the exception on line 7 deals with the termination of \rcitem{Ctrl}. 
%
%For \rcitem{MicroController} in Fig.~\ref{fig:robochart_acd_module}, the \isacode{terminate} channel, the event channels, and the operation call channels of the process for \rcitem{Movement} are mapped to the corresponding controller channels. 
% \begin{alltt}
%     Renamed_D_CalSTM = \(\rename{D_CalSTM }{\{(terminate_CalSTM, terminate_Ctrl)\}}\) 
% \end{alltt}

% In particular, for a connection \rcitem{c} from an event \rcitem{e} of a state machine \rcitem{stm1} to an event \rcitem{e} of another state machine \rcitem{stm2} of a controller, we declare a channel \isacode{e\_ctrl} in the event alphabet of the controller. The channel in the process for  \rcitem{stm1} is renamed to that of the controller with the same direction \isacode{dout}. Then the channel in the process for \rcitem{stm2} is renamed to that of the controller but with the opposite direction (\isacode{din} to \isacode{dout}). Finally, the processes (\isacode{D\_stm1} and \isacode{D\_stm2}) for both \rcitem{stm1} and \rcitem{stm2} synchronise on the channels of the controller with direction \isacode{dout}, which is sketched below.
% \newcommand{\parallelE}{\parallel_{\isacode{\{e\_ctrl dout, ...\}}}}
% %
% \begin{alltt}
%   D__stm1\([\![\)\{(e_stm1 dout, e_ctrl dout),...\}\(]\!]\)
%     \(\parallelE\)
%   D__stm2\([\![\)\{(e_stm2 din, e_ctrl dout),...\}\(]\!]\)
% \end{alltt}
%     %\(\parallel\)\(\Searrow\)\{e_ctrl dout, ...\} \(\Swarrow\)
% %
% Here $\parallel_E$ is parallel composition over event synchronisation set $E$. In this way, the output of \rcitem{e} in \rcitem{stm1} synchronises with the input of \rcitem{e} in \rcitem{stm2}, which is the semantics of connection \rcitem{c}.

\subsection{Modules}
\label{ssec:semantics_module}
%\paragraph*{Modules.}

Similar to the event alphabet of the process for a controller, that of the process for a module also contains a termination channel, shared variable channels, event channels, and operation call channels. The event channels include not only the events of its platform but also the events in connections between its controllers for the same reason. 

The process for a module is a parallel composition of the renamed processes for its controllers, memory processes, and buffer processes for asynchronous connections between its controllers such as the connection on event \rcitem{turn} from \rcitem{MainController} to \rcitem{MicroController} in Fig.~\ref{fig:robochart_acd_module}. 
The semantics for this connection is a one-place buffer.
%
\newcommand{\buffer}{\isalink{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous.thy\#L89}}
%  \begin{alltt}
%  \isakwmaj{definition} buffer::"Chemical_Angle list \(\Rightarrow\) \(\buffer\)
%    (Chan_ChemicalDetector, Chemical_Angle list) \IsaKey{itree}" \isakwmin{where}
%  "buffer = \cspkey{loop} (\(\lambda\)la. (do \{\cspkey{guard}((length la\(\geq\)0)\(\land\)(length la\(\leq\)1)); 
%      v \(\gets\) \cspkey{inp} turn (set [(dout,a). a \(\gets\)Chemical_Angle_list]); 
%      \Ret [snd v] \}) \(\extchoice\) (do \{
%      \cspkey{guard}(length la>0); \cspkey{outp} turn (din, hd la); \Ret [] \})
%    )"
%  \end{alltt}
\begin{alltt}
buffer = \cspkey{loop} (\(\lambda\)la. \(\buffer\)
    (((length la \(\geq\) 0)\(\land\)(length la \(\leq\) 1))\(\guard\)turn?(dout, a\(\in\)Chemical_Angle) \(\to\) \(\subscriptIntt{\tick}{[a]}\)) \(\extchoice\) 
    ((length la > 0)\(\guard\)turn!(din, hd la) \(\to \subscriptIntt{\tick}{[]}\))
  )
\end{alltt}
 The state of a buffer process is of type \isacode{V list} where \isacode{V} is the value type (\isacode{Chemical\_Angle}) of the event channel (\isacode{turn}) corresponding to the event (\rcitem{turn}) of the connection (\rcitem{c}) which this buffer process is for. The buffer process is an infinite \isacode{loop} whose body is an external choice of two processes:
 \begin{inparaenum}[(1)]
 \item if the length of its state (a list) is either 0 or 1, it accepts an input (\isacode{a}) on the channel \isacode{turn} whose event direction is \isacode{dout} (and so the output from \rcitem{MainController}) and then terminates with the updated state (a new list \isacode{[a]} with the only element \isacode{a}); and
 \item if its state is not an empty list, it outputs the head element (\isacode{hd la}) of the list on the channel \isacode{turn} whose event direction is \isacode{din} (and so the input to \rcitem{MicroController}) and then terminates with the update state (an empty list \isacode{[]}).
 \end{inparaenum}

We also note that when renaming the processes for controllers, it is not necessary to swap the direction of the event channels for the events of the controllers that are connected asynchronous. This is because of the usage of a buffer having connected the output of the event on one controller and the input of the event on another controller through shared buffer elements. This is different from renaming the processes for state machines where one side uses an opposite direction.

The memory of a module deals with the update of shared variables and also the propagation of the update to its controllers, which is similar to that of a controller.   
The definition of the process for a module is omitted for simplicity and can be found online (\isacode{D\_ChemicalDetector} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_ChemicalDetector_autonomous/RoboChart_ChemicalDetector_autonomous.thy\#L110} for the autonomous chemical detector and \isacode{D\_PatrolMod} \isaref{https://github.com/isabelle-utp/interaction-trees/blob/418b37554f808828610f10b40c051a562fe0c716/RoboChart/examples/RoboChart_basic_v1/RoboChart_basic_v1_1.thy\#L1300} for the patrol robot). 
% Next, we discuss the animation of RoboChart through code generation.% and particularly show two animation scenarios of the chemical detector example. 

\section{Code generation, animation, and case studies}
\label{sec:animation}

As discussed previously in \cite[Sect.~5]{Foster2021}, the animation of ITrees is achieved through code generation~\cite{Haftmann2010} in Isabelle. 
Infinite corecursive definitions over ITrees are implemented using lazy evaluation in Haskell. 
Associative lists are used as an implementation for partial functions in ITrees and a simple animator in Haskell is presented. 
Using the same approach for animation, we are able to animate the two RoboChart models shown in Sect.~\ref{sec:robochart}. 

\subsection{Autonomous chemical detector}
\label{ssec:animation_chemical}
We illustrate two scenarios of the animation of the autonomous chemical detector in Figs.~\ref{fig:animate_stop} and \ref{fig:animate_resume}. %\changed[\C{2}]{We, additionally, highlight and number the actions taken in the scenarios in Figure~\ref{fig:robochart_acd_movement_ann} where the font for the numbers of the first scenario is red and normal, and that for the second scenario is blue and italic.} 
Here, we instantiate \isacode{Chem} and \isacode{Intensity} to be a numeral type \isacode{2} and the sequence of \isacode{GasSensor} is bounded to 2, which is the same as the instantiations for the verification with FDR4.
An animation scenario represents the interaction of the model with its environment: the lines starting with \lstinline[language=Animation]{Events} are produced by the model and represent all enabled events; and the lines starting with \lstinline[language=Animation]{[Choose: 1-n]} represents a user's choice of enabled events from number 1 to n. In Fig.~\ref{fig:animate_resume}, we omit the lines for enabled events and append the chosen event to the chosen number for simplicity. 

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
Starting ITree animation...
Events: (1) RandomWalkCall (); (2) Gas (Din, []); ...;
[Choose: 1-22]: 1
Events: (1) Gas []; (2) Gas [(0,0)]; (3) Gas [(0,1)]; (4) Gas [(1,0)]; 
  (5) Gas [(1,1)]; (6) Gas [(0,0),(0,0)]; (7) Gas [(0,0),(0,1)]; (8) Gas 
  [(0,0),(1,0)]; (9) Gas [(0,0),(1,1)]; ...; (21) Gas [(1,1),(1,1)];
[Choose: 1-21]: 9
Events: (1) MoveCall (0,Chemical_Angle_Front);
[Choose: 1-1]: 1
Events: (1) Flag Dout;
[Choose: 1-1]: 1
Terminated: ()
\end{lstlisting}
\caption{\label{fig:animate_stop} Animation of the example when dangerous chemical detected.}
\vspace{-3ex}
\end{figure}

% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=1.0\textwidth]{figures/autonomous_chemical_detector/Movement_annotated.pdf}%
%   \vspace{-2ex}
%   \caption{Movement state machine of the autonomous chemical detector model with annotation.}%
%   \vspace{-4ex}
%   \label{fig:robochart_acd_movement_ann}%
% \end{figure}

%Events: (1) Gas (Din, []); (2) Gas (Din, [(0, 0)]); (3) Gas (Din, [(0, 1)]); (4) Gas (Din, [(1, 0)]); (5) Gas (Din, [(1, 1)]); (6) Gas (Din, [(0, 0),(0, 0)]); (7) Gas (Din, [(0, 0),(0, 1)]); (8) Gas (Din, [(0, 0),(1, 0)]); (9) Gas (Din, [(0, 0),(1, 1)]); ...; (21) Gas (Din, [(1, 1),(1, 1)]);

%On line \verb+#4+ of Fig.~\ref{fig:animate_stop}, we display partially enabled \isacode{Gas} (corresponding to the \rcitem{gas} event in the model and the use of capital \isacode{G} due to the naming convention in Haskell) events: 10 out of 21. The value carried on the \isacode{Gas} channel is a pair whose first element is the direction of the connection on which the event \rcitem{gas} is, and whose second element is a bounded sequence of records which are of type \isacode{GasSensor}. A record is also represented by a pair whose first element denotes whether a chemical is detected or not (\lstinline[language=Animation]{0}  for no and  \lstinline[language=Animation]{1} for yes), and whose second element denotes the intensity of the detected chemical (\lstinline[language=Animation]{0}  for low and  \lstinline[language=Animation]{1} for high). On line \verb+#2+ we omit 20 more enabled \isacode{Gas} events. 
Figure~\ref{fig:animate_stop} illustrates the behaviour of the model when detecting a dangerous chemical: 
\begin{inparaenum}[(1)]
\item initially the controller calls the platform to perform a random walk: the number \lstinline[language=Animation]{1} event is chosen on line \verb+#3+, which corresponds to the call of the during action \rcitem{randomWalk()} 
    %\changed[\C{2}]{(\color{red}{1} in Figure~\ref{fig:robochart_acd_movement_ann})} 
    of state \rcitem{Waiting} in Fig.~\ref{fig:robochart_acd_movement};
    \item then a sequence of gas sensor readings is received through the \rcitem{gas} event, and we choose number \lstinline[language=Animation]{9} (among 21 enabled \rcitem{gas} events shown on lines \verb+#4-6+ where the first element \lstinline[language=Animation]{Din} of each event is omitted) on line \verb+#7+: \lstinline[language=Animation]{Gas [(0,0),(1,1)]},  representing a chemical being detected and its intensity is high in the second pair of the sequence;
    \item the controllers call the \rcitem{move} operation with speed 0 (on line \verb+#9+), provided by the platform, to stop the robot; 
    \item the controllers indicate the platform to drop a flag (on line \verb+#11+); and finally 
    \item the controllers terminate (on line \verb+#12+).
\end{inparaenum}


\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
/*Starting ITree animation...
*/[Choose: 1-22]: 1   RandomWalkCall ()
[Choose: 1-21]: 4   Gas (Din,[(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 2   Obstacle (Din,Location_Loc_right)
[Choose: 1-23]: 1   Odometer (Din,0)
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Left)
[Choose: 1-21]: 8   Gas (Din,[(0, 0),(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 1   Obstacle (Din, Location_Loc_left)
[Choose: 1-23]: 2   Odometer (Din,1)
[Choose: 1-23]: 1   Odometer (Din,0)
/*[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Right)
[Choose: 1-21]: 4   Gas (Din,[(1, 0)])
[Choose: 1-22]: 1   MoveCall (1,Chemical_Angle_Front)
[Choose: 1-24]: 2   Obstacle (Din,Location_Loc_right)
[Choose: 1-23]: 1   Odometer (Din,0)
[Choose: 1-22]: 1   Stuck_timeout Din
[Choose: 1-22]: 1   ShortRandomWalkCall ()
*/[Choose: 1-22]: ...
\end{lstlisting}
\caption{\label{fig:animate_resume} Animation of the example when chemical detected with low intensity.}
\vspace{-3ex}
\end{figure}

In Fig.~\ref{fig:animate_resume}, we illustrate another scenario: a chemical is detected but its intensity is low for the two readings on lines \verb+#2+ and \verb+#7+. The model behaves as follows: 
\begin{inparaenum}[(1)]
    \item the initial behaviour is the same: calling the platform to request a random walk;
    \item a sequence of gas sensor readings is received (online \verb+#2+);
    \item the controllers call the \rcitem{move} operation (the entry action of the state \rcitem{Going} in Fig.~\ref{fig:robochart_acd_movement}) to request the robot to move forward at speed 1 (on line \verb+#3+);
    \item an obstacle on its right is encountered (on line \verb+#4+);
    \item the odometer reading is 0 (on line \verb+#5+);
    \item the controllers call \rcitem{move} (the action of a transition in the defined operation \rcitem{changeDirection}) to request the robot to move towards its opposite direction (left here) to the obstacle at speed 1 (online \verb+#6+);
    \item another reading of the gas sensor shows there is still a chemical detected with low intensity (on line \verb+#7+);
    \item the controllers call \rcitem{move} (the entry action of state \rcitem{TryingAgain} in machine \rcitem{Movement}) to request the robot to move towards its front at speed 1 (on line \verb+#8+);
    \item an obstacle on its left is encountered (on line \verb+#9+);
    \item the odometer reading (the action of the transition from state \rcitem{TryingAgain} to state \rcitem{AvoidingAgain}) is 1 (on line \verb+#10+);
    \item there is another odometer reading (0) on line \verb+#11+, which corresponds to the entry action of state \rcitem{Avoiding} (the entering of this state is resulted from the taken transition from state \rcitem{AvoidingAgain} to state \rcitem{Avoiding} due to its guard \rcitem{d1-d0>stuckDist} is true where the values of \rcitem{d0} and \rcitem{d1} are the previous two odometer readings 0 and 1, and the value of \rcitem{stuckDist} is set 0 in this animation);
    \item we omit further interactions.
\end{inparaenum}

Based on the animation, we also observe that if no chemical is detected, the model returns to its initial state. 
If the low-intensity chemical is detected, even without progress of \rcitem{MicroController}, the model can continuously read through the \rcitem{gas} event without blocking. This is due to the connection between the controllers on event \rcitem{turn} being asynchronous, and so \rcitem{MainController} can continuously send a \rcitem{turn} event without waiting for the synchronisation of \rcitem{MicroController}. 
In our implementation in ITrees, the buffer process defined previously for the connection reflects this behaviour: overwriting the buffer is always allowed.

\subsection{The patrol robot}
\label{ssec:animation_patrol}
In this example, we instantiate \isacode{MAX\_INT} to 3 and \isacode{MAX} to 2 and illustrate three scenarios of the animation of the patrol robot corresponding to the three sections (S1, S2, and S3) of the corridor in Fig.~\ref{fig:robochart_patrol_sections}.

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 2 Cal_PatrolMod (Din,-3)
[Choose: 1-1]: Right_PatrolMod (Dout,-2)
[Choose: 1-1]: Right_PatrolMod (Dout,-2)
[Choose: 1-1]: Right_PatrolMod (Dout,-1)
[Choose: 1-1]: Right_PatrolMod (Dout,-1)
[Choose: 1-1]: Right_PatrolMod (Dout,0)
Events: (1) Right_PatrolMod (Dout,0); (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 1 Right_PatrolMod (Dout,0)
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]:
\end{lstlisting}
\caption{\label{fig:animate_patrol_s1} Animation of the patrol robot when the calibrated position is in S1.}
%\vspace{-3ex}
\end{figure}

We show the first scenario in Fig.~\ref{fig:animate_patrol_s1}, which is related to the calibrated position in S1. The model behaves as follows: 
\begin{inparaenum}[(1)]
\item initially the controller provides eight events on lines \verb+#2-4+ for users to choose: one to reset the position and another seven to set the calibrated position to an integer value between -3 and 3;
\item the second event (\lstinline[language=Animation]{2}) is chosen on line \verb+#5+, denoting the calibrated position is \lstinline[language=Animation]{-3} and so the robot is in S1;
\item the only available event on lines \verb+#6-10+ is \lstinline[language=Animation]{Right_PatrolMod}\footnote{The change of the name from \isacode{right\_PatrolMod} to \lstinline[language=Animation]{Right_PatrolMod} is due to the code generation in Isabelle to generate Haskell. In Haskell, it is conventional to use capitalised names for data types.} which corresponds to the \rcitem{right} event in the RoboChart model, denoting the movement of the robot towards the right side of the corridor at the new positions (\lstinline[language=Animation]{-2}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0} respectively);
\item since the new position on line \verb+#10+ is 0 now, the controller could accept a \rcitem{right} event and calibration events on lines \verb+#11-13+;
\item the \rcitem{right} event is chosen on line \verb+14+, and after that 
\item the controller returns to its initial state: having the same available events on lines \verb+#15-17+ as initially available events on lines \verb+2-4+.
\end{inparaenum}
%
When \rcitem{x} is equal to -3 and -2 (in section S1), the robot moves towards the right side and \rcitem{x} is increased by 1, as illustrated on line \verb+#6-9+. This behaviour is consistent with the semantics of the model. After \rcitem{x} becomes -1 (in section S2), the model nondeterministically chooses to move towards the left side or the right side.  Our animation on lines \verb+#6-10+, and \verb+#14+, however, shows only the right side is chosen. This is because of the use of renaming with priority in \isacode{Renamedp\_MemorySTM\_MoveSTM} and the higher priority of the \rcitem{update} event on \rcitem{t1} than \rcitem{t3} to resolve the nondeterminism (and so the priority is given to the movement towards the right side).

In the RoboChart model, we expect each \rcitem{left} or \rcitem{right} event corresponds to decrease or increase \rcitem{x} by 1. The animation, however, shows that the new positions (\lstinline[language=Animation]{-2}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0}) on the \rcitem{right} event on lines \verb+#7+, \verb+#9+, and \verb+#14+ stay the same as their previous positions on lines \verb+#5+, \verb+#8+, and \verb+#10+. This is actually due to the semantics of shared variables in RoboChart, specifically the mechanism used to update shared variables and propagate the updates, which is subtle. We illustrate the implemented mechanism in our semantics in Fig.~\ref{fig:basic_shared_variables} where the exchange of the value of \rcitem{x} in the module, the controller, and the two machines is through communication (labelled with an identifier, a channel, and a message over the channel).

\begin{figure}[t]
  \centering%
  \includegraphics[width=0.70\textwidth]{shared_variables.pdf}%
  \caption{The update of the shared variable \rcitem{x} and its propagation in the patrol robot model.}%
  \label{fig:basic_shared_variables}%
\end{figure}

The communications 1 to 4 show that the change of \rcitem{x} to -2 in \rcitem{CalSTM} is updated to the module \rcitem{PatrolMod}, and then this update is propagated down the memory hierarchy to the controller \rcitem{Ctrl}, subsequently to the state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. The update and propagation, however, are not atomic. Between these communications, the memories can be accessed and evaluated using the outdated value. This is further demonstrated by communications 5 to 11. Consider a new update of \rcitem{x} to -1 (by communication 5) in the memory of \rcitem{MoveSTM}, the update and propagation are similar to the previous update (to -2). We here, however, consider the value of \rcitem{x} in \rcitem{CalSTM} is accessed (by the event \isacode{get\_x} on communication 8) and evaluated in the guard \rcitem{[x!=0]} of the transition in the machine before the new value -1 is propagated to the machine (on communication 9). This means the action of the transition still outputs -2 on the event \rcitem{update!-2}, not the -1 because the new value has not been seen in this machine. As a consequence, the input trigger \rcitem{update?l} in the machine \rcitem{MoveSTM} will receive a value -2 and so \rcitem{x} is set to -1 (\rcitem{x=l+1}) again, as indicated on communication 11. The updates of \rcitem{x} to -1 on communications 5 and 11 correspond to the action \rcitem{x=l+1} (\isacode{rc.Plus l 1 rc.core\_int\_set} in our semantics) in the self transition of \rcitem{MoveSTM}, which is followed by an output event \rcitem{right!x}. The animation, therefore, shows two \lstinline[language=Animation]{Right_PatrolMod} events on lines \verb+#8+ and \verb+#9+.

It is worth mentioning that the RoboChart semantics in this model with the shared variable \rcitem{x} has a high degree of nondeterminism because of the interleaving of events between the module, the controller, and the state machines, and eventually nondeterminism due to the hiding of these interleaving events. Our implementation of the semantics reduces nondeterminism in a particular way: the maximal progress assumption (internal events $\tau$ have a higher priority)~\cite{Foster2021}. We also note that the animated behaviour of two \isacode{Right\_PatrolMod} events for a position is one behaviour of the RoboChart's standard semantics. This has been verified using FDR that this scenario is a trace refinement of the standard semantics (generated in RoboTool). In order for the verification, we encode the scenario in Fig.~\ref{fig:animate_patrol_s1} in a CSP process \lstinline[language=CSP]{Scenario1} below and then use FDR to check the assertion satisfied.
%
\begin{lstlisting}[language=CSP, caption={}]
Scenario1 = PatrolMod::cal.in.-3    -> PatrolMod::right.out.-2 -> PatrolMod::right.out.-2 ->
	           PatrolMod::right.out.-1 -> PatrolMod::right.out.-1 -> PatrolMod::right.out.0  -> 
              PatrolMod::right.out.0  -> Scenario1
assert PatrolMod [T= Scenario1  
\end{lstlisting}
In the assertion, \lstinline[language=CSP]{PatrolMod} is the CSP process for the module \rcitem{PatrolMod} in the generated CSP semantics in RoboTool.

Though semantically allowed, the model does not reflect the optimal way to use shared variables. We could, for example, design models to allow only one state machine to update a shared variable and other state machines to access its value or add additional events (such as start\_update and end\_update) to enforce a synchronisation of updates to shared variables. Our patrol robot model here is presented to reveal the subtle semantics of using shared variables.

\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 6 Cal_PatrolMod (Din,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: ... 
\end{lstlisting}
\caption{\label{fig:animate_patrol_s2} Animation of the patrol robot when the calibrated position is in S2.}
%\vspace{-3ex}
\end{figure}
In Fig.~\ref{fig:animate_patrol_s2}, we consider the second scenario where the calibrated position is 1 (in S2). The model behaves as follows:
\begin{inparaenum}[(1)]
\item the sixth event (\lstinline[language=Animation]{6}) is chosen on line \verb+#5+, denoting the calibrated position is \lstinline[language=Animation]{1} and so the robot is in S2;
\item then the robot moves towards the right side at position 2 (lines \verb+#6+ and \verb+#7+); 
\item subsequently the robot moves towards the left direction to position 1 (lines \verb+#8+ and \verb+#9+); and 
\item finally, the robot repeats steps (2) and (3) to patrol between position 1 and position 2.
\end{inparaenum}
%
We also verified this scenario is a trace refinement of the standard semantics, shown below. 
\begin{lstlisting}[language=CSP, caption={}]
Repeat = PatrolMod::right.out.2 -> PatrolMod::right.out.2 ->
          PatrolMod::left.out.1 -> PatrolMod::left.out.1 -> Repeat
Scenario2 = PatrolMod::cal.in.1 -> Repeat
assert PatrolMod [T= Scenario2
\end{lstlisting}


\begin{figure}[t]
\begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
Starting ITree Simulation...
Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-3); (3) Cal_PatrolMod (Din,-2); 
         (4) Cal_PatrolMod (Din,-1); (5) Cal_PatrolMod (Din,0); (6) Cal_PatrolMod (Din,1); 
         (7) Cal_PatrolMod (Din,2); (8) Cal_PatrolMod (Din,3);
[Choose: 1-8]: 8 Cal_PatrolMod (Din,3)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
[Choose: 1-1]: ... 
\end{lstlisting}
\caption{\label{fig:animate_patrol_s3} Animation of the patrol robot when the calibrated position is in S3.}
%\vspace{-3ex}
\end{figure}

The third scenario, we consider, is shown in Fig.~\ref{fig:animate_patrol_s3} where initially the calibrated position is 3 (in S3) on line \verb+#5+. The robot starts to move towards the left side to position 2 (on lines \verb+#6+ and \verb+#7+) and position 1 (on lines \verb+#8+ and \verb+#9+), and then towards the right side back to position 2 (on lines \verb+#10+ and \verb+#11+). After that, the behaviour is the same as that in the second scenario in Fig.~\ref{fig:animate_patrol_s2}. Similarly, we verified this scenario is a trace refinement of the standard semantics.
%
\begin{lstlisting}[language=CSP, caption={}]
Scenario2 = PatrolMod::cal.in.3 -> PatrolMod::left.out.2 -> PatrolMod::left.out.2 -> 
	           PatrolMod::left.out.1 -> PatrolMod::left.out.1 -> Repeat 
assert PatrolMod [T= Scenario3
\end{lstlisting}

From the three scenarios, we have seen that the event \isacode{Reset\_PatrolMod} (\rcitem{reset} in the model) is only enabled when the current position (the value of \rcitem{x} on the event \rcitem{left} or \rcitem{right}) is 0. The events enabled on lines \verb+#2+ and \verb+#15+ in Fig.~\ref{fig:animate_patrol_s3} and on line \verb+#2+ in Figs.~\ref{fig:animate_patrol_s3} and \ref{fig:animate_patrol_s3} are such examples. The standard CSP semantics, however, allows \rcitem{reset} when the current position is other than 0. The following analysis using FDR illustrates it clearly.

\begin{lstlisting}[language=CSP, caption={}]
Reset = PatrolMod::cal.in.-2 -> PatrolMod::left.out.-1 -> 
		     PatrolMod::reset.in -> PatrolMod::right.out.0 -> 
		     PatrolMod::right.out.1 -> PatrolMod::reset.in -> Reset
assert PatrolMod [T= Reset
\end{lstlisting}
In this example, \rcitem{reset} is enabled when \rcitem{x} is -1 (on line \verb+#2+) and 1 (on line \verb+#3+).
This difference is due to the maximal progress assumption in the definition of external choice and hiding in our approach: internal events have priority over external events. In this patrol robot model, the event \rcitem{update} is internal and \rcitem{reset} is external, so \rcitem{update} has priority over \rcitem{reset}. When \rcitem{x} is not 0, the guard \rcitem{[x!=0]} in the self transition of \rcitem{Cal} in the machine \rcitem{CalSTM} is true, which enables \rcitem{CalSTM} to communicate with the machine \rcitem{MoveSTM} on \rcitem{update}, and then the transition with the trigger \rcitem{reset} cannot be taken due to its lower priority than \rcitem{update}. The \rcitem{reset}, therefore, is only enabled when \rcitem{x} is 0.


%%%%%%%%%% This commented description corresponds to MAX_INT 2 an dMAX 1.
% \begin{figure}[t]
% \begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
% Starting ITree Animation...
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 2 Cal_PatrolMod (Din,-2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,-1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,-1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,0)
% Events: (1) Right_PatrolMod (Dout,0); (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 1 Right_PatrolMod (Dout,0)
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% \end{lstlisting}
% \caption{\label{fig:animate_patrol_s1} Animation of the patrol robot when the calibrated position is at S1.}
% \vspace{-3ex}
% \end{figure}
% 
% We show the first scenario in Fig.~\ref{fig:animate_patrol_s1}, which is related to the calibrated position in S1. The model behaves as follows: 
% \begin{inparaenum}[(1)]
% \item initially the controller provides six events on lines \verb+#2-3+ for users to choose: one to reset the position and other five to set the calibrated position to an integer value between -2 and 2;
% \item the second event (\lstinline[language=Animation]{2}) is chosen on line \verb+#4+, denoting the calibrated position is \lstinline[language=Animation]{-2} and so the robot is in S1;
% \item the only available event on lines \verb+#5-7+ is \lstinline[language=Animation]{Right_PatrolMod}\footnote{The change of the name from \isacode{right\_PatrolMod} to \lstinline[language=Animation]{Right_PatrolMod} is due to the code generation in Isabelle to generate Haskell. In Haskell, it is conventional to use capitalised names for data types.} which corresponds to the \rcitem{right} event in the RoboChart model, denoting the movement of the robot towards the right of the corridor at the new positions (\lstinline[language=Animation]{-1}, \lstinline[language=Animation]{-1}, and \lstinline[language=Animation]{0} respectively);
% \item since the new position is 0 now, the controller could accept calibration events and a \rcitem{right} event on lines \verb+#8-9+;
% \item the \rcitem{right} event is chosed on line \verb+10+; and after that 
%     \item the controller returns to its initial state: having the same available events on lines \verb+#11-12+ as initially available events on lines \verb+2-3+.
% \end{inparaenum}
% %
% When \rcitem{x} is equal to -2 (in section S1), the robot will move towards the right side and \rcitem{x} is increased by 1, as illustrated on line \verb+#5+. This behaviour is consistent with the model. After \rcitem{x} becomes -1 (in section S2), the model nondeterministically chooses to move towards the left side or the right side.  Our animation on lines \verb+6+, \verb+7+, and \verb+10+, however, shows the right side is still chosen. This is because of the use of renaming with priority in \isacode{Renamedp\_MemorySTM\_MoveSTM} and the higher priority of the \rcitem{update} event on \rcitem{t1} than \rcitem{t3} to resolve the nondeterminism and give the priority to the movement towards the right side.
% 
% In the RoboChart model, we expect each \rcitem{left} or \rcitem{right} event corresponds to decrease or increase \rcitem{x} by 1. The animation, however, shows that the destination positions (\lstinline[language=Animation]{-1} and \lstinline[language=Animation]{0}) of the \rcitem{right} event on lines \verb+#6+ and \verb+#10+ stay the same as their previous positions (\lstinline[language=Animation]{-1} and \lstinline[language=Animation]{0} on lines \verb+#5+ and \verb+#7+). This is actually due to the semantics of shared variables in RoboChart, specifically the mechanism used to update shared variables and propagate the updates, which is subtle. We illustrate the implemented mechanism in our semantics in Fig.~\ref{fig:basic_shared_variables} where the exchange of the value of \rcitem{x} in the module, the controller, and the two machines is through communication (labelled with an identifier, a channel, and a message over the channel).
% 
% \begin{figure}[t]
%   \centering%
%   \includegraphics[width=0.70\textwidth]{shared_variables.pdf}%
%   \caption{The update of the shared variable \rcitem{x} and its propagation in the patrol robot model.}%
%   \label{fig:basic_shared_variables}%
% \end{figure}
% 
% The communications 1 to 4 show that the change of \rcitem{x} to -2 in \rcitem{CalSTM} is updated to the module \rcitem{PatrolMod}, and then this update is propagated down the memory hierarchy to the controller \rcitem{Ctrl}, subsequently to the state machines \rcitem{CalSTM} and \rcitem{MoveSTM}. The update and propagation, however, are not atomic. Between these communications, the memories can be accessed and evaluated using the outdated value. This is further demonstrated by communications 5 to 11. Consider a new update of \rcitem{x} to -1 (by communication 5) in the memory of \rcitem{MoveSTM}, the update and propagation are similar to the previous update (to -2). We here, however, consider the value of \rcitem{x} in \rcitem{CalSTM} is accessed (by the event \isacode{get\_x} on communication 8) and evaluated in the guard \rcitem{[x!=0]} of the transition in the machine before the new value -1 is propagated to the machine (on communication 9). This means the action of the transition still outputs -2 on the event \rcitem{update!-2}, not the -1 because the new value has not been seen in this machine. As a consequence, the input trigger \rcitem{update?l} in the machine \rcitem{MoveSTM} will receive a value -2 and so \rcitem{x} is set to -1 (\rcitem{x=l+1}) again, as indicated on communication 11. The updates of \rcitem{x} to -1 on communications 5 and 11 correspond to the action \rcitem{x=l+1} (\isacode{rc.Plus l 1 rc.core\_int\_set} in our semantics) in the self transition of \rcitem{MoveSTM}, which is followed by an output event \rcitem{right!x}. The animation, therefore, shows two \lstinline[language=Animation]{Right\_PatrolMod} events on lines \verb+#5+  and \verb+#6+.
% 
% It is worth mentioning that the RoboChart semantics in this model with the shared variable \rcitem{x} has a high degree of nondeterminism because of interleaving of internal events between the module, the controller, and the state machines, and eventually nondeterminism due to the hiding of these interleaving events. Our implementation of the semantics reduces nondeterminism in a particular way: the maximal progress (internal events $\tau$ have a higher priority)~\cite{Foster2021}. We also note that the animated behaviour of two \isacode{Right\_PatrolMod} events for a position is consistent with RoboChart's semantics. The model, however, does not reflect the optimal way to use shared variables. We could, for example, design models to allow only one state machine to update a shared variable and other state machines to access its value or add additional events (such as start\_update and end\_update) to enforce a synchronisation of updates to shared variables. Our patrol robot model here is presented to reveal the subtle semantics of using shared variables.
% 
% \begin{figure}[t]
% \begin{lstlisting}[language=Animation, caption={}, label={lst:ass_bnf_1}]
% Starting ITree Animation...
% Events: (1) Reset_PatrolMod Din; (2) Cal_PatrolMod (Din,-2); (3) Cal_PatrolMod (Din,-1); 
%          (4) Cal_PatrolMod (Din,0); (5) Cal_PatrolMod (Din,1); (6) Cal_PatrolMod (Din,2);
% [Choose: 1-6]: 5 Cal_PatrolMod (Din,1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Right_PatrolMod (Dout,2)
% [Choose: 1-1]: 1 Left_PatrolMod (Dout,1)
% \end{lstlisting}
% \caption{\label{fig:animate_patrol_s2} Animation of the patrol robot when the calibrated position is at S2.}
% \vspace{-3ex}
% \end{figure}
% In Fig.~\ref{fig:animate_patrol_s2}, we consider the second scenario where the calibrated position is 1 (in S2). The model behaves as follows:
% \begin{inparaenum}[(1)]
% \item the fifth event (\lstinline[language=Animation]{5}) is chosen on line \verb+#4+, denoting the calibrated position is \lstinline[language=Animation]{1} and so the robot is in S2;
% \item then the robot moves towards the right boundary at position 2 (lines \verb+#5+ and \verb+#6+); 
% \item subsequently the robot moves towards the left direction to position 1 (lines \verb+#7+ and \verb+#8+); and 
% \item finally, the robot repeats steps (2) and (3) to patrol between position 1 and position 2.
% \end{inparaenum}
% 
% If the robot's calibrated position is 2 in S3, it will start to move towards the left side first to position 1 and then towards the right side back to position 2, which is the same as the behaviour after line \verb+#7+ in Fig.~\ref{fig:animate_patrol_s2}.
\section{Related work}
\label{sec:related}
%Previously, we have compared ITrees with other semantic approaches in~\cite{Foster2021}. 
%Here, we set our work in context of animation of formal specifications, which is discussed in a number of  work~\cite{Fuchs1992,Malik2005,Leuschel2014,Oda2015,Mashkoor2017} for the Z notation, B and Event-B machines~\cite{Abrial2005,Abrial2010}, CSP, and VDM~\cite{Jones1991}. %Our work here is specifically for the animation of CSP (for RoboChart).
%
%Both Probe in FDR and ProB~\cite{prob} are able to animate machine readable CSP, or CSP-M, which supports a restricted subset of RoboChart types and expressions and cannot deal with function definitions (by preconditions and postconditions) in RoboChart directly (and so users are required to supply explicit implementation). Our encoding of CSP processes in ITrees addresses these issues thanks to the mechanisation of Z mathematical toolkits (to support rich RoboChart types and expressions) and code generation (to solve preconditions and postconditions effectively) in Isabelle/HOL.

{Animation is a lightweight formal method. Kazmierczak et al.~\cite{Kazmierczak1998} describe the advantages of using animation to verify models. It is highly automated and cheap to perform. It provides an insight into the specification and its implicit assumptions and is very suitable for demonstrating the system. It is a form of interactive testing of the model and its properties. It requires little expertise: less than model checking and much less than theorem proving. But its biggest drawback is that it cannot prove consistency, correctness, or completeness.

Animation can be tailored to specific application domains. For example, Boichut et al.~\cite{Boichut2007} report on using animation to improve the formal specifications of security protocols. They animate these specifications to draw diagrams of typical executions of the protocols. They use this to visualise protocol termination and understand interleaved execution. They experiment with the animation to detect unwanted side effects. Finally, they use visualisation to simulate intruders to find attacks not detected by other protocol analysis tools.

We use ITrees to implement a framework for the animation of formal specifications. The ProB animator and model checker provides a different framework~\cite{Leuschel2003}. ProB contains a model checker and a constraint-based checker, both of which can be used to detect various errors in B specifications. It implements a back-end in a framework for a variety of different specification languages, including the B language, Event-B, CSP-M, TLA+, and Z.

De Souza~\cite{Souza2011} provides another framework: Joker. This is a tool for producing animators for formal languages. The application is based on general labelled transition systems and provides graphical animation, supporting B, CSP, and Z.}

\changed[\C{6}]{Rosu et al.~\cite{Rosu2010} develop K,\footnote{\url{https://kframework.org/}} a rewriting-based executable semantic framework. The operational semantics of programming languages such as C~\cite{Ellison2012} and Java~\cite{Bogdanas2015} are proposed based on K. Our ITree-based approach is also an executable semantic framework enabling the definition of operational semantics, but for both abstract specification languages and concrete refinements. And so program development by refinement is supported in our framework. Higher-order logic and nondeterminism are some features of interaction trees, but not for K.}

Stateflow is a graphical language integrated in the Simulink of Matlab to model and simulate decision logic using state machines and flow charts. During simulation, transitions in state machines are evaluated, by default, based on the order in which they are created~\cite{MathWorks2022}. This is the same as our approach to resolve nondeterministic choice between transitions using the prioritised renaming operator.
%The support of nondeterminism is one of our future works, but it is not included in K. 

%The automatically generated CSP semantics of a RoboChart model in RoboTool targets at verification with FDR4 and so uses machine-readable CSP or CSP-M with modules. This naturally makes Probe in FDR the first choice for the animation of RoboChart. 
%Here, we set ITrees in the context of animation for RoboChart. The automatically generated CSP semantics of a RoboChart model in RoboTool targets at verification with FDR4 and so uses machine-readable CSP or CSP-M with modules. This naturally makes Probe in FDR the first choice for the animation of RoboChart. 
%The benefits of this approach include 
%\begin{inparaenum}[(1)]
%    \item the consistency of the standard and timed semantics of RoboChart between verification and animation because of the same generated CSP code use; and
%    \item various methods of compression in FDR are also used for animation, which could potentially reduce the size of state space and improve the efficiency of animation.
%\end{inparaenum}
%ProB~\cite{prob} also supports CSP-M for model checking and animation, but without modules. It also has some limitations.\footnote{\url{prob.hhu.de/w/index.php?title=CSP-M}} ProB, therefore, cannot directly model check and animate the generated CSP code in RoboTool. In order to use the user-friendly (GUI-based) animator in ProB, we need to encode the CSP semantics of RoboChart in the CSP-M supported by ProB.  
%It is possible to encode the CSP semantics of RoboChart in the CSP-M supported by ProB, but it is not investigated yet. The GUI-based animation in ProB is straightforward and easily used even by normal users. This is a big advantage of ProB in terms of animation. 

%
% To achieve semantic consistency, the main restriction of our current approach in this paper is the handling of nondeterminism. We focus on the deterministic systems and avoid nondeterminism by excluding potential events. Support of nondeterminism in ITrees is our immediate future work. 
% In ITrees, we implement compression of the process to some extent, such as .... (ask Simon about it?)
% The big advantage of the focus on deterministic programs is the improved efficiency of animation for users. The animation scenarios in Sect.~\ref{sec:animation} show the minimum interactions required for users because internal activities are automatically computed. The animation of CSP with FDR and ProB does need the user's inputs to resolve internal $\tau$ actions, which makes the animation difficult for users and not possible for normal users without knowledge of CSP.

%Different from the semantics of RoboChart in CSP-M is limited to a subset of RoboChart types and expressions and requires users to supply an implementation of functions, our encoding of CSP processes in ITrees supports almost all RoboChart types and expressions as well as functions defined using preconditions and postconditions.   
%(benefiting from the mechanisation of Z mathematical toolkits in Isabelle) 
% and characterise systems with infinite states symbolically. 
%Furthermore, a function defined using preconditions and postconditions in RoboChart could not have an automatic and consistent implementation of the function in CSP-M and its implementation is the user's responsibility. In our approach, however, its preconditions and postconditions can be effectively solved using code generation, which is beneficial for the completeness of models and their semantics. 
%Our animation is also formally verified with respect to the semantics of RoboChart given in ITrees thanks to code generation in Isabelle/HOL.
%For example, a function defined using preconditions and postconditions in RoboChart could not have an automatic and consistent implementation of the function in CSP-M (its implementation is the users' responsibility), but it is possible in our ITrees mechanisation. 

%In terms of integration with existing tools, our approach could be automated to generate RoboChart theories for ITrees in RoboTool. This semantics generator can largely reuse the current CSP-M semantics generator in RoboTool. Because of our open approach, it is also potential to integrate the Haskell code-based animation seamlessly with RoboTool to use animation, for example, to debug state machines or communicate with stakeholders. This is not possible currently with FDR4 because there are no open interfaces to access its animation in programs.

\section{Conclusions}
\label{sec:concl}

{This work gives RoboChart an ITree-based operational semantics and enables the animation of RoboChart using code generation in Isabelle/HOL.}
%We showed how the semantics of RoboChart is implemented in recently mechanised CSP in Isabelle whose semantics is given on ITrees. 
To provide animation support, we extend ITree-based CSP with extra operators
%: interrupt, exception, and renaming,
 and present their definitions. We describe how the semantics of RoboChart %including types, instantiations, functions, state machines, controllers, and modules,
 is implemented in ITree-based CSP, and illustrate it with an autonomous chemical detector model and a patrol robot model.
%
With the semantics of a RoboChart model in Isabelle, we generate Haskell code and animate it using a simple simulator. We show two concrete scenarios of the chemical detector example and three concrete scenarios of the patrol robot model using animation.
The analysis using FDR shows these scenarios are trace refinements of the standard RoboChart CSP semantics, and so our approach gives and animates a refinement of the original models.

This work targets deterministic RoboChart models and also nondeterministic RoboChart models (but nondeterminism is resolved in a priority way in the semantics and so deterministic semantics eventually). Our work covers a large part of RoboChart features (but not all). 
Our immediate future work is to investigate the support of nondeterminism in the semantics and give semantics to more features such as hierarchical state machines and timed semantics.
%, and several possible approaches have been discussed in the previous work~\cite[Sect.~7]{Foster2021}. 

%This work covers a large part of RoboChart features, but not all, such as hierarchical state machines and timed semantics in RoboChart. We will give semantics to these features in the future. 

In this paper, we manually translate the RoboChart semantics to Isabelle. 
Particularly, we take RoboChart's CSP semantics generated in RoboTool into account to define consistent and also restricted semantics based on an optimised version of the CSP semantics. This practical consideration could entitle us to largely reuse the current CSP semantics generator in RoboTool to automatically generate ITree-based CSP semantics. 
Then the whole workflow from RoboChart models to Haskell code can be fully automated and our work here brings insights into it. This is part of our future work. 
% The simple animator will be improved to directly allow the visualisation of RoboChart models in RoboTool.

With the RoboChart semantics in ITrees, we can also conduct verification in Isabelle/HOL, in addition to animation in this paper. We will investigate the use of temporal logic as a property language for the verification of ITrees. We note that verification can also capitalise on the contributions of this work. 

ITrees can also be extended to other semantic domains. Further work would be of great help in extending ITrees with probability and linking them to discrete-time Markov chains (DTMCs)~\cite{Kemeny1976c,Kemeny1983}, which will allow us to give an ITree-based probabilistic semantics to RoboChart.

Our work has many potential applications in robotics. Further research could investigate the development of verified ROS nodes using code generation here for a concrete implementation of RoboChart controllers. We also could use this approach to automatically generate a sound runtime monitor from RoboChart models to observe the behaviour of systems that are derived from the models.

We use a basic textual animation in this work. This will be improved to directly allow the visualisation of RoboChart models in RoboTool for animation. Eventually, users of RoboTool are able to animate a state machine, or a controller, or a whole model by clicking transitions or events.



\section*{Acknowledgements}

This work is funded by the EPSRC projects CyPhyAssure%
\footnote{%
  CyPhyAssure Project: \url{www.cs.york.ac.uk/circus/CyPhyAssure/}.%
} (Grant EP/S001190/1), RoboCalc (Grant EP/M025756/1), and RoboTest (Grant EP/R025479/1).
The icons used in RoboChart have been made by Sarfraz Shoukat, Freepik, Google, Icomoon and Madebyoliver from \url{www.flaticon.com}, and are licensed under CC 3.0 BY.

%\vspace{-2ex}

%\bibliographystyle{elsarticle-num-names} 

\bibliographystyle{elsarticle-num} 
\bibliography{main}

\end{document}
