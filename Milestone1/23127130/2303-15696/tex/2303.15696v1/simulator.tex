To both design optimized stochastic analyses and understand our sensitivity to different categories of signals, it is essential to be able to readily simulate realistic interferometer data. %
To this end, the {\tt simulator} module is primarily designed to generate data that corresponds to an isotropic \gls{sgwb} with a given \gls{psd}. %

The \gls{gwb} data in a network of interferometers satisfy a  specific correlation matrix, which includes the set of \glspl{orf} of the entire detector network to account for the spatial separation and relative orientation of the detectors. %
Given a generic signal \gls{psd}, $S_h$, the correlation matrix ${\bm C}(f)$ is given by
\begin{equation}
    C_{IJ}(f) = \delta_{IJ} P_I(f) + \gamma_{IJ}S_h(f). 
\end{equation}
Here $\gamma_{IJ}(f)$ is the normalized \gls{orf} of the baseline $IJ$ as shown in Eq.~\eqref{eq:orf}, hence $\gamma_{II}(f)\equiv 1$, and $P_{I}$ is the noise \gls{psd} of interferometer $I$. %
We have introduced a boldface notation which indicates matrices and vectors which span the detector space. %
The fact that the cross-correlation between detectors for $I\neq J$ only depends on the signal \gls{psd} assumes the noise is uncorrelated across all detectors. %

The simulation of data correlated according to ${\bm C}(f)$ proceeds as follows. %
First, a vector of white, uncorrelated frequency-domain data are generated, ${\bm v}_f$, with a certain frequency resolution $\Delta f$. %
Then, the data are linearly transformed into the correlated ${\bm C}$ space by, 
\begin{equation}
{\bm x}^T_f={\bm v}^T_f~{\sqrt{\bm\Lambda}_f}~{\bm E}^T_f\,,
\end{equation}
where ${\bm \Lambda}$ and ${\bm E}$ are the eigenvalue and eigenvector matrices of $\bm C$, respectively, calculated in each frequency bin. %
This transformation results in data ${\bm x}_f$ that presents the correct correlation, and has been colored with the injected noise and signal power spectra, where appropriate. %
Finally, the frequency-domain data vector is \glspl{ift} to obtain a data vector in the time domain. %


Data generation in the frequency domain, followed by the \gls{ift} to the time domain, can introduce edge-effects in the simulated data segments. %Nevertheless, 
These may be avoided by \textit{splicing} multiple data segments \cite{TheoryDigitalProcessing}. %, which is implemented in {\tt splice\_segments()}, 
%and forms the last step in the simulation of the data. %
The splicing procedure combines neighboring data segments by windowing and overlapping them, and thus requires more data segments than the actual desired number of segments. %. 

Concretely, we consider the example where $N_{\rm seg}=1$ and detail the splicing procedure below. %
As the number of desired segments is 1, $2N_{\rm seg}+1=3$ data segments are simulated. %
Assuming these are simulated following the procedure outlined above, we denote these three time-domain data segments by ${\bm x}_0$, ${\bm x}_1$ and ${\bm x}_2$. %
A sine window, defined as
\begin{equation}
    w_j=\sin\left(\frac{\pi j}{N}\right),
\end{equation}
for $0\le j < N$, where $N$ is the number of samples per segment, is used to window the data, %One then applies this window to the data segments (in this case ${\bm x}_0$, ${\bm x}_1$ and ${\bm x}_2$):
which are then combined as
\begin{align}
    y_{0j}&= w_j x_{0j},~~~~~~~~~~~~~{\bm z}_0=({\bm y}_0[N/2:N],{\bm{0}})\,,\\
    y_{1j}&= w_j x_{1j},~~~~~~~~~~~~~{\bm z}_1={\bm y}_1\,,\\
    y_{2j}&= w_j x_{2j},~~~~~~~~~~~~~{\bm z}_2=(\mathbf{0},{\bm y}_2[0:N/2])\,,
\end{align}
and finally we obtain a single segment of time domain data $\bf z$,
\begin{equation}
    {\bm z} = {\bm z}_0+{\bm z}_1+{\bm z}_2\,.
\end{equation}
In the above expressions, $\mathbf{0}$ represents an array of zeros with length $N/2$, used to pad the segments, whereas the bracket notation stands for {\tt python} array slicing. %

\begin{figure}
    \centering
\includegraphics[width=.55\textwidth]{simulator_1.pdf}
    \caption{Example of injection using the {\tt simulator} module. The noise \gls{psd} (orange) and the injected signal (red) are clearly discernible as a part of the \gls{psd} of the simulated data (blue).}
    \label{fig:ExampleInjection}
\end{figure}

The splicing procedure can introduce a bias in the simulated power spectrum due to the spectral properties of the window that is applied. %
However, the {\tt simulator} module was tested for several values of the spectral index of a power-law signal \gls{psd}, ranging between $-3$ and 3, yielding a correct injection for these spectral indices. %
The user should nevertheless exercise caution when using the {\tt simulator} module and be aware of the possible introduction of a bias outside the range of tested spectral indices due to splicing.

We show an example of simulated data in Fig.~\ref{fig:ExampleInjection}. %
The injected signal and noise \gls{psd}s are plotted together with the calculated \gls{psd} of a simulated data segment. %
A thorough testing of the {\tt simulator} module is performed in Sec.~\ref{MDCSimulator}. %
