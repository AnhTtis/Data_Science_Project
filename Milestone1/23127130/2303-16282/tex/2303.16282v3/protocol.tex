\begin{figure*}[t]%!ht]
	\abovedisplayskip=0pt
	\abovedisplayshortskip=0pt
	\belowdisplayskip=0pt
	\belowdisplayshortskip=0pt
\centering
\scriptsize
\begin{tabular}{|p{.34\textwidth} p{.20\textwidth} p{.36\textwidth}|} 
\hline
\multicolumn{1}{|c}{\textbf{Verifier} (\vrf)} & & \multicolumn{1}{c|}{\textbf{Prover} (\prv)} \\
\hline
%& & \\

& & 1) When \tcb is invoked (either by \trigger \textbf{[T1]-[T3]} or by a manual call in software), \prv executes \tcb-Att to compute \RA measurement:

\begin{equation*}
	H := \cfattest_\attkey(PMEM, METADATA, \log)
\end{equation*} \\

& & where \attkey is the \RA key pre-shared between \vrf and \vrased~\RA RoT in \prv. Then enter \tcb-Wait.\\

% OAK: we need to send METADATA to \vrf because log pointer is in METADATA and if its not sent, \vrf has to enumerate/guess log pointer, which might not be convenient
3) Receive ($H$, $METADATA$ and \log) and extract $\chal$ from $METADATA$
& \sendmessageleft{top={$\acron$ report}} & 2) In \tcb-Wait: Create and send \acron report $:= H||METADATA||\log$ and wait for approval.\\

& & \\

4) Run verification (including analysis of \log) to determine whether to approve the report:

\begin{equation*}
app:=\vrfy(H, \attkey, PMEM', METADATA, \log)
\end{equation*} & & \\

where $PMEM'$ is the expected software for \prv $PMEM$ and $app \in \{0,1\}$ is an approval bit. & & \\
& & \\
5) Generate a new challenge $\chal'$, a memory region to be monitored ($\er_{min}, \er_{max}$) and an authentication token \auth, where: 

\begin{equation*}
	\auth := \cfattest_\attkey(\chal', \er_{min}, \er_{max}, app)
\end{equation*}

\begin{equation*}
	\chal' := \chal + 1
\end{equation*}
& & \\

6) Create and send \acron response
& & \\
$response := app || \chal' || \er_{min} || \er_{max} || \auth$ & \sendmessageright{top={\acron response}} &  7) In \tcb-Wait: Authenticate the response, producing a one-bit output:

\begin{equation*}
	out := \authen(\attkey, \acron \text{ response})
\end{equation*} \\

& &
Based on $out$ and $app$, it decides the next transition:
\begin{compactitem}
	\item If $out=0$: Re-enter \tcb-Wait. {\it Jump to Step 2}.
	\item Else if $app=0$: Save ($\chal'$, $\er_{min}$ and $\er_{max}$ to $METADATA$) and enter \textit{\tcb-Heal}. {\it Jump to Step 8}.
	\item Else: Save ($\chal'$, $\er_{min}$ and $\er_{max}$) to $METADATA$, exit \tcb and resume execution of $\er$. {\it Jump to Step 9}. 
\end{compactitem}~\\

& & 8) In \tcb-Heal: Execute remediation software (e.g., reboot, reset, software update), then re-start \tcb-Att. {\it Jump to Step 1}. \\

& & \\

& & 9) Resume Application Execution:
    \begin{compactitem}
    \item Whenever executing $\er$: append control-flow transfers to \log.
    \item Whenever a \trigger occurs, \acron causes execution to enter \tcb-Att. {\it Jump to Step 1}.
    \end{compactitem}\\
%& & \\

\hline
\end{tabular}
\vspace{-1em}
\caption{\acron protocol.}
\label{fig:prot}
\vspace{-1.5em}
\end{figure*}
