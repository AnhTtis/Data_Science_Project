
The need for the computation of ERIs stems from the explicit inclusion of the electron-electron interaction Hamiltonian in hybrid DFT calculations or correlated electronic structure methods. This section describes the mathematical background of ERIs, starting from the basis functions, Cartesian GTOs, used for the representation of the wave functions. %

\subsection{Cartesian GTO}\label{subsec:gto}
A normalized primitive Cartesian GTO is defined as
\begin{IEEEeqnarray}{c}
  g_{\vb{a},\vb{R}_{A}}(\vb{r}) = N \cdot e^{-\alpha \abs{\vb{r} - \vb{R}_A}^2}\prod_{\xi \in \{x,y,z\}} \left(r_\xi - R_{A_\xi}\right)^{a_\xi} 
\end{IEEEeqnarray}
\noindent with the orbital exponent $\alpha$ and at the center $\vb{R}_A = [R_{A_x}, R_{A_y}, R_{A_z}]$.
$N$ is a normalization factor chosen so that the axis-aligned Cartesian GTOs are normalized~\cite{Kenny08}. The orbital angular momentum of $g_{\vb{a},\vb{R}_{A}}(\vb{r})$ is defined as $L_a = a_x + a_y + a_z$.
The Cartesian components of $L_a$ form an integer vector $\vb{a} = [a_x, a_y, a_z]$.
A set of all Cartesian GTOs that differ in the elements of $\vb{a}$, but share the same $L_a$, constitutes a \emph{shell} and is denoted as $a = \{ g_{\vb{a},\vb{R}_{A}}(\vb{r}) \}$.
The number of Cartesian GTOs in a shell $a$ is determined by $n_{g_a} = (L_a + 1) (L_a + 2) / 2$. The most commonly used shells in AIMD simulations are $s$, $p$, $d$, and $f$, i.e.\ $L_a = 0$, 1, 2, and 3, respectively.

\subsection{ERI Quartets}\label{subsec:bg:quartets}

An ERI describes the repulsion between the densities of two electrons, one at $\vb{r}$ and the other at $\vb{r}'$.
The density of the electron at $\vb{r}$ is the weighted sum of products of two Cartesian GTOs. Hence, an ERI is defined as
\begin{align}
  [ab|cd] = \iint \ud \vb{r} \ud \vb{r}'\,
  \frac{g_{\vb{a},\vb{R}_{A}}(\vb{r})  g_{\vb{b},\vb{R}_{B}}(\vb{r}) g_{\vb{c},\vb{R}_{C}}(\vb{r}') g_{\vb{d},\vb{R}_{D}}(\vb{r}')}
  {\abs{\vb{r} - \vb{r}'}},
  \label{eq:eri}
\end{align}
\noindent which is a 6-dimensional integral over the Cartesian coordinates of both electrons~\cite{Boys50}.
$[ab|cd]$ is the conventional notation for an ERI quartet class consisting of 4 normalized primitive Cartesian GTOs, which forms the first set of inputs to the ERI computation (Fig.~\ref{fig:fpga_design})
\begin{IEEEeqnarray}{c}
  \label{eq:input_g_abcd}
  G_{abcd} = \qty{g_{\vb{a},\vb{R}_{A}}(\vb{r}),  g_{\vb{b},\vb{R}_{B}}(\vb{r}),
                  g_{\vb{c},\vb{R}_{C}}(\vb{r}'), g_{\vb{d},\vb{R}_{D}}(\vb{r}')}.
\end{IEEEeqnarray}
Due to the eightfold permutation symmetry, an $[ab|cd]$ quartet class is mathematically identical to the variants
\begin{IEEEeqnarray}{Cl}
    & [ab|cd] = [ba|cd] = [ab|dc] = [ba|dc] \nonumber\\
  = & [cd|ab] = [cd|ba] = [dc|ab] = [dc|ba], \nonumber
\end{IEEEeqnarray}
A quartet class $[ab|cd]$ with arbitrary $a$, $b$, $c$, and $d$ is called a \emph{generic}, whereas a \emph{canonical} $[ab|cd]$ quartet class is uniquely defined by the conditions
\begin{IEEEeqnarray}{c}
  \IEEEyesnumber\label{eq:can_abcd}
  L_a \ge L_b, L_c \ge L_d, \text{ and } n_{g_a} n_{g_b} \ge n_{g_c} n_{g_d}.
\end{IEEEeqnarray}
For angular momenta up $L_a=3$ there are 55 \emph{canonical} $[ab|cd]$ quartet classes for 256 \emph{generic} quartet classes.


\subsection{ERI Computation}

In the past several decades, plenty of algorithms for the ERI computation were devised~\cite{HJO_ch9}.
These algorithms can be classified into three major categories based on the mathematical formulations: Rys quadrature~\cite{dupuis1976DKR, king1976DKR, Rys83}, Obara-Saika schemes~\cite{Obara86, headgordon1988HGPRR}, and McMurchie-Davidson schemes~\cite{mcmurchie1978McMurchieDavidson}.
In the current work, we have implemented the Rys quadrature algorithm, which is favorable for FPGA acceleration because of a low memory footprint for intermediates enabling the use of fast FPGA on-chip memory to achieve parallel loads and stores. In addition, compared to the other approaches, the Rys quadrature tends to need fewer floating-point operations for the quartet classes with higher angular momenta. Due to the numerical stability of the performance relevant stages in the Rys approach, one can make use of the single-precision floating-point arithmetic operation on FPGAs\footnote{The Rys roots and weights are calculated in double-precision on the CPU in this work.}.
The flow of the computation is shown in Fig.~\ref{fig:fpga_design}.

\begin{figure}
\centering
\includegraphics[width=0.98\columnwidth]{FPGA_kernel/FPGA_kernel}
\caption{FPGA design for ERI computation and compression.}
\label{fig:fpga_design}
\end{figure}

The central principle of the Rys quadrature is to reduce the 6-dimensional integration in ERI computation (Eq.~\ref{eq:eri}) to a sum of many 1-dimensional integrations.
These 1-dimensional integrations are then solved by using Gaussian quadrature in conjunction with a set of orthonormal Rys polynomials.
The roots $t_{\mu}$ and weights $w_{\mu}$ of the Rys polynomials form the second set of input data for ERI computation (Fig.~\ref{fig:fpga_design})
\begin{IEEEeqnarray}{c}
  \label{eq:input_r_rys}
  R_{\text{Rys}} = \qty{t_{\mu}, w_{\mu} \mid \mu \in [1, n_{\text{Rys}}]},
\end{IEEEeqnarray}
\noindent where $n_{\text{Rys}}$ is the order of the Rys polynomials. %

After preparation of the inputs $G_{abcd}$ and $R_{\text{Rys}}$, our implementation of the Rys algorithm~\cite{Rys83} consists of three stages.

\subsubsection{Setup Stage}
Two auxiliary arrays $\vb{B} \in \mathbb{R}^{3 \times n_{\text{Rys}}}$ and $\vb{C} \in \mathbb{R}^{6 \times n_{\text{Rys}}}$ need to be set up using the inputs of the ERI computation and can be found in the original paper~\cite{Rys83}.

\subsubsection{Recurrence Relation Stage}
The recursive intermediates are quantities arranged in a 6-dimensional array denoted as $I(i, j, k, l, \mu, \xi)$, where the indices $i$, $j$, $k$, and $l$ are for the shells $a$, $b$, $c$, and $d$, respectively. $\mu$ enumerates the Rys polynomials and $\xi$ represents the $x$, $y$, or $z$-axis.
 

Starting with the initial intermediates at the ``origins'', $I(0, 0, 0, 0, \mu, \xi)$, whose numerical values depend on the $\mu$-th root and weight of the Rys polynomials and $x$, $y$, and $z$-axes, the entire $I(i, j, k, l, \mu, \xi)$ array can be built by using two distinct sets of multi-dimensional recurrence relations (RRs).

Firstly, the vertical recurrence relations (VRRs) are used, which rely on both orbital angular momenta $n$, $m$ and Cartesian axes $\xi$ of shells $a$, $b$, $c$, and $d$:
\begin{IEEEeqnarray}{rCl}
  \IEEEyesnumber\label{eq:vrrs}
                        I(i + 1, 0, k    , 0, \mu, \xi) & = &
        n B_{2, \mu}    I(i - 1, 0, k    , 0, \mu, \xi) \nonumber \\
& & +\: m B_{1, \mu}    I(i    , 0, k - 1, 0, \mu, \xi) \nonumber \\
& & +\:   C_{\xi, \mu}  I(i    , 0, k    , 0, \mu, \xi) \IEEEyessubnumber \\
                        I(i    , 0, k + 1, 0, \mu, \xi) & = &
        m B_{3, \mu}    I(i    , 0, k - 1, 0, \mu, \xi) \nonumber \\
& & +\: n B_{1, \mu}    I(i - 1, 0, k    , 0, \mu, \xi) \nonumber \\
& & +\:   C_{2\xi, \mu} I(i    , 0, k    , 0, \mu, \xi) \IEEEyessubnumber.
\end{IEEEeqnarray}
\noindent Afterwards, the horizontal recurrence relations (HRRs) are applied to build the entire $I(i, j, k, l, \mu, \xi)$ array
\begin{IEEEeqnarray}{rCl}
  \IEEEyesnumber\label{eq:hrrs}
                            I(i    , j    , k    , 0    , \mu, \xi) & = &
                            I(i + 1, j - 1, k    , 0    , \mu, \xi) \nonumber \\
& & \kern-2ex + (R_{A_{\xi}} - R_{B_{\xi}}) I(i    , j - 1, k    , 0    , \mu, \xi) \IEEEyessubnumber \\
                            I(i    , j    , k    , l    , \mu, \xi) & = &
                            I(i    , j    , k + 1, l - 1, \mu, \xi) \nonumber \\
& & \kern-2ex + (R_{C_{\xi}} - R_{D_{\xi}}) I(i    , j    , k    , l - 1, \mu, \xi).\IEEEyessubnumber
\end{IEEEeqnarray}
\noindent Unlike VRRs, the HRRs only depend on the Cartesian coordinates of the 4 shells in $[ab|cd]$.
These RRs can be implemented with iterative loops, but all of them contain read-after-write (RAW) dependencies on previous iterations.

\subsubsection{Quadrature Stage}
All ERIs of an $[ab|cd]$ quartet class are computed by Gaussian quadrature
\begin{IEEEeqnarray}{c}
  [ab|cd] = \sum_{\mu = 1}^{n_{\text{Rys}}} w_{\mu} \left[\prod_{\xi \in \{x, y, z\}} I(a_{\xi}, b_{\xi}, c_{\xi}, d_{\xi}, \mu, \xi)\right],
  \label{eq:gauq}
\end{IEEEeqnarray}
\noindent where the indices $a_{\xi}$, $b_{\xi}$, $c_{\xi}$, and $d_{\xi}$ are the angular momenta components of the GTOs $a$, $b$, $c$, and $d$, respectively.

\subsection{ERI Compression}

A real-world AIMD simulation may need to compute several billions up to trillions of ERIs in each time step~\cite{Kuehne2020}.
In order to reduce the high demand on memory usage, several different algorithms for ERI compression were developed in the past~\cite{FÃ¼lscher93, Guidon08, Ying15}.
In this work, we adapt the ERI compression algorithm of Guidon et~al.~\cite{Guidon08} which is also used by the quantum chemistry software package CP2K~\cite{Kuehne2020} and directly integrated with the ERI calculation as fourth stage to make use of FPGA pipelining.

After computing all ERIs for one $[ab|cd]$ quartet, the maximum absolute value is denoted as $b_{\text{max}}$.
Targeting an $n$-bit encoding, the maximum representable signed integer is $2^{n-1}-1$ and the ``quantum value'' for representing the ERIs of $[ab|cd]$ is
\begin{IEEEeqnarray}{c}
  \epsilon = b_{\text{max}} \cdot ({2^{n - 1} - 1})^{-1}.
  \label{eq:calc_epsilon}
\end{IEEEeqnarray}
Then the compressed ERIs in $n$-bit signed integers can be represented as multiples of the quantum value
\begin{IEEEeqnarray}{c}
  [ab|cd]_{n\text{-bit}} = \text{ANINT}([ab|cd]\cdot\epsilon^{-1}),
\end{IEEEeqnarray}
\noindent where the function ANINT returns the nearest integer number of its argument.
An $[ab|cd]_{n\text{-bit}}$ array together with the scaling factor $\epsilon$ form the outputs of combined ERI computation and compression for one ERI quartet (Fig.\ref{fig:fpga_design}).

During an AIMD simulation, $[ab|cd]_{n\text{-bit}}$ will be decompressed to floating-point numbers on the host as
\begin{IEEEeqnarray}{c}
  \widetilde{[ab|cd]} = [ab|cd]_{n\text{-bit}} \cdot \epsilon.
  \label{eq:decomp_eris}
\end{IEEEeqnarray}
\noindent It can be shown that the maximum absolute error between original $[ab|cd]$ and $\widetilde{[ab|cd]}$ is bound by $\epsilon / 2$ for a quartet, because the rounding error of ANINT is $\pm 1/2$.
