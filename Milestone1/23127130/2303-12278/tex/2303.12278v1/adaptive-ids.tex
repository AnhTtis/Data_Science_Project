% i.e., e.g,, textit 여부
\documentclass[journal]{IEEEtran}
%%%%%%%%% SHJ %%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage{amsmath}
\interdisplaylinepenalty=2500
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\ifCLASSOPTIONcompsoc
  \usepackage[caption=false, font=footnotesize, labelfont=sf, textfont=sf, labelformat=simple]{subfig}
\else
  \usepackage[caption=false, font=footnotesize, labelformat=simple]{subfig}
\fi

\usepackage{xspace}
\newcommand{\BfPara}[1]{{\noindent\bf#1.}\xspace}
\usepackage{xcolor}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, citecolor=green, linkcolor=purple, pdfborder={0 0 0},}
\usepackage{tabularx}
\def\Snospace~{\S{}}
\renewcommand*\sectionautorefname{\Snospace}
\let\subsectionautorefname\sectionautorefname
\let\subsubsectionautorefname\sectionautorefname
\def\figureautorefname{Fig.}
\newcommand{\subfigureautorefname}{\figureautorefname}
\renewcommand\thesubfigure{(\alph{subfigure})}

\newcommand{\labelsubseccounter}[1]{
    \renewcommand\thesubsubsection{\Alph{subsection}.\arabic{subsubsection}}
    \addtocounter{subsubsection}{-1}
    \refstepcounter{subsubsection}
    \label{#1}
    \renewcommand\thesubsubsection{\thesection.\Alph{subsection}.\arabic{subsubsection}}
}

% for the rotated column header
\usepackage{adjustbox}
\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    r%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{90}{.8em}}}
% for the checkmark
\usepackage{pifont}
\newcommand{\checkmark}{\ding{52}}

\usepackage{amsfonts}
\usepackage{multirow}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\renewcommand{\algorithmautorefname}{Algorithm}
\usepackage[noabbrev,nameinlink]{cleveref}
% \let\orgtheequation\theequation
% \def\theequation{(\orgtheequation)}
% \def\EQnospace~{{}}
% \renewcommand{\equationautorefname}{\EQnospace}
\crefname{equation}{}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hyphenation{X-CANIDS}
\begin{document}
\title{X-CANIDS: Signal-Aware Explainable Intrusion Detection System for Controller Area Network-Based In-Vehicle Network}
\author{Seonghoon Jeong, Sangho Lee, Hwejae Lee, and Huy Kang Kim
% \thanks{Manuscript received Jan. 10, 2023.
%This research was supported by the 2021 autonomous driving development innovation project of the Ministry of Science and ICT, ``Development of technology for security and ultra-high-speed integrity of the next-generation internal network of autonomous vehicles'' (No. 2021-0-01348).
% \textit{(Corresponding author: Huy Kang Kim)}}% <-this % stops a space
\thanks{The authors are with the School of Cybersecurity, Korea University, Seoul 02841, Republic of Korea (e-mail: \{seonghoon, lee35, hwejae94, cenda\}@korea.ac.kr.)}% <-this % stops a space
% \thanks{Digital Object Identifier 10.1109/TVT.0000.0000000}%
}
% \markboth{IEEE Transactions on Vehicular Technology,~Vol.~OO,~No.~OO,~2023}{Jeong \MakeLowercase{\textit{et al.}}: X-CANIDS: Signal-Aware Explainable Intrusion Detection System for Controller Area Network-Based In-Vehicle Network}
\maketitle

\begin{abstract}
Controller Area Network (CAN) is an essential networking protocol that connects multiple electronic control units (ECUs) in a vehicle. However, CAN-based in-vehicle networks (IVNs) face security risks owing to the CAN mechanisms. An adversary can sabotage a vehicle by leveraging the security risks if they can access the CAN bus. Thus, recent actions and cybersecurity regulations (e.g., UNR 155) require carmakers to implement intrusion detection systems (IDSs) in their vehicles. An IDS should detect cyberattacks and provide a forensic capability to analyze attacks. Although many IDSs have been proposed, considerations regarding their feasibility and explainability remain lacking. This study proposes X-CANIDS, which is a novel IDS for CAN-based IVNs. X-CANIDS dissects the payloads in CAN messages into human-understandable signals using a CAN database. The signals improve the intrusion detection performance compared with the use of bit representations of raw payloads. These signals also enable an understanding of which signal or ECU is under attack. X-CANIDS can detect zero-day attacks because it does not require any labeled dataset in the training phase. We confirmed the feasibility of the proposed method through a benchmark test on an automotive-grade embedded device with a GPU. The results of this work will be valuable to carmakers and researchers considering the installation of in-vehicle IDSs for their vehicles.
\end{abstract}
\begin{IEEEkeywords}
CAN database, explainability, in-vehicle intrusion detection, self-supervised anomaly detection, UN Regulation No. 155 (UNR 155)
\end{IEEEkeywords}

\section{Introduction}
In-vehicle networks (IVNs) are essential for vehicles that are operated by several electronic control units (ECUs). Among the various networking protocols that have been designed for vehicles, Controller Area Network (CAN), which replaces the mesh-like wiring harness with a bus topology, is the most successful. CAN 2.0A, which was released in 1991, is currently employed in almost all vehicles because it meets the crucial requirements of IVNs with which conventional networking protocols such as Ethernet do not comply. In particular, the bus topology, arbitration mechanism, and short frame enable broadcasting, interconnect multiple ECUs, and prevent medium occupation, respectively. However, these mechanisms are the root cause of security risks in CAN-based IVNs, which allow an adversary to eavesdrop on in-vehicle communication, inject arbitrary messages, and cause denial of service of a specific ECU~\cite{Cho2016a} or an entire CAN bus~\cite{LeeJK17}. 

Until the early 2010s, adversaries were considered negligible because they must have physical access to a CAN-based IVN to leverage the security risks. However, this situation has changed with the widespread use of connected vehicles, as the connectivity broadens the remote attack surfaces of connected vehicles~\cite{MillerV15, KimKJPK21}. Compromised in-vehicle infotainment systems may allow the adversaries to obtain access to IVNs remotely. Previous studies supported this concern~\cite{JoCNWL17, Gayou18, TeamFluoroacetate19, CostantinoM19, TencentMBUX21}. In particular, Miller and Valasek~\cite{MillerV15} jumpstarted cybersecurity studies on vehicles with the proof of concepts of remote hacking into a CAN-based IVN of a Jeep Cherokee.

It is crucial to protect vehicles from cyberattacks to safeguard passengers and pedestrians against unexpected vehicle behavior. Nevertheless, it is impossible to remedy the security risks of CAN-based IVNs without revising the protocol specifications. Intrusion detection systems (IDSs) have been proposed to identify anomalies in CAN-based IVNs~\cite{KimKJPK21, JoC21}. In the early research stages, statistical approaches and conventional machine-learning algorithms were considered. As deep-learning techniques have evolved, recent studies have tended to adapt such techniques for precise intrusion detection. IDSs are currently becoming an essential component of vehicles. For example, United Nations Regulation No. 155 (UNR 155), which is a recent automotive cybersecurity regulation that will take effect in many countries from 2024, states that \textit{``the vehicle manufacturer shall implement measures for the vehicle type to (a) detect and prevent cyber-attacks against vehicles of the vehicle type; (b) support the monitoring capability of the vehicle manufacturer with regards to detecting threats; (c) provide data forensic capability to enable an analysis of attempted or successful cyber-attacks''} (see \S 7.3.5 in \cite{UNR155}).

In this study, we propose a practical IDS named X-CANIDS to address the following three limitations with respect to IDSs for CAN-based IVNs. 
First, previous IDSs did not provide forensic capabilities. Most carmakers have their own pattern database to distinguish a malfunction. The data forensic capability is a key factor in understanding ongoing attacks to prepare a remedy and update their database.
To this end, an IDS should provide explainability to distinguish an abnormal ECU or sensor value. Several methods (e.g., \cite{HossainIOFK20, TariqLKW20}) have been designed to distinguish the type of attack. However, they require ground-truth labels and only distinguish predefined attack types.
Second, the evaluations have lacked a feasibility perspective. Evaluation is necessary because an IDS works on an ECU or an in-vehicle component. Regardless of the effectiveness of an IDS, it may be useless owing to bottlenecks.
Finally, limited studies have considered the use of signals rather than raw payloads. Signals help to improve the detection performance of an IDS because they reflect the context of the vehicle. Nevertheless, the use of signals has rarely been discussed because of a lack of knowledge regarding payload deserialization methods. To date, two studies have used sensor values through the on-board diagnostics (OBD)-II feature~\cite{WasicekPWBS17} and several reverse-engineered signals~\cite{ShahriarXMLH22}.


The contributions of this study are summarized as follows:

\BfPara{1. Self-supervised intrusion detection with signals} We propose X-CANIDS, which is a novel method that consists of a feature generator and intrusion detection model. The feature generator builds a time-series representation of signals that are deserialized from the payloads of the CAN messages. We use a CAN database to train X-CANIDS with 107 signals. The detection model is trained using an attack-free dataset. X-CANIDS can detect zero-day attacks, of which we are unaware at the time of implementation.

\BfPara{2. Explainability} X-CANIDS provides the forensic capability to distinguish a specific signal that is targeted by an adversary, even if no ground-truth labels or intrusion datasets are available in the training phase. To this end, we leverage the signalwise reconstruction error combined with an autoencoder.

\BfPara{3. Feasibility} Our method is benchmarked on our NVIDIA Jetson AGX Xavier, which is an automotive-grade embedded device. The benchmark results confirm that X-CANIDS is promising for real-world use cases. X-CANIDS achieves a deterministic detection latency of 52.4--202.4 ms on the embedded device with a feature generation frequency and batch size of 100 Hz and 16, respectively.

The remainder of this paper is organized as follows. 
In \autoref{sec:preliminaries}, we provide the background for this study.
In \autoref{sec:methodology}, we describe the proposed X-CANIDS.
\autoref{sec:dataset} outlines the CAN datasets that are used in the experiment.
The experimental results are presented and the detection performance, explainability, and feasibility are discussed in \autoref{sec:experimental_result}. 
In \autoref{sec:related_work}, we categorize prior studies based on the features that are used to detect in-vehicle intrusion.
Finally, we conclude the study in \autoref{sec:conclusion}.


\section{Preliminaries}
\label{sec:preliminaries}
\subsection{Terminology}
We present the terminology used in this paper.
The \textit{payload} is a bit sequence that is encapsulated in the data field of a CAN frame (see \autoref{fig:CAN_frame_structure}). The \textit{signal} indicates a sensor value that is deserialized from a portion of the payload. A \textit{stream} is a set of CAN messages with a particular arbitration ID. The aim of this study is to develop an \textit{explainable} and a \textit{feasible} IDS. We can state that the proposed IDS is explainable when a detection result allows us to understand which signal or ECU is affected by attacks. We can state that the proposed IDS is feasible when it can evaluate all given inputs within a predictable delay on an ECU or an automotive-grade embedded device.

\subsection{CAN Frame}
\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figure/CAN_frame_structure-eps-converted-to.pdf}
\caption{CAN 2.0A frame structure. An ECU application refers to the arbitration and data field.}
\label{fig:CAN_frame_structure}
\end{figure}

The CAN frame is a communication unit between two in-vehicle ECUs that are connected by a CAN bus. \autoref{fig:CAN_frame_structure} depicts the CAN 2.0A frame structure. Among the fields, the ECU firmware uses the 11-bit arbitration identifier (AID) field and a 64-bit data field. The AID is considered as a categorical value for determining the message type as well as a numerical value that represents the priority of the message. The data field contains a payload that represents various signals that are used to operate vehicles, such as sensor values, Booleans, inter-ECU procedure calls, cyclic redundancy check values, sequential counters, and zero padding. As a CAN frame does not contain a transmission timestamp, the CAN receiver assigns a timestamp for each inbound CAN message using its internal clock. In the ECU firmware, a transmitted CAN frame is represented as a CAN message $m \rightarrow (t, a, {\bf p})$, where the timestamp $t \geq 0$, AID $a\in\{0, 1, \cdots, 2047\}$, and bit sequence vector of the payload ${\bf p}=\{p_i\ | p_i \in \{0, 1\}~\text{for}~i=1..n\}$, with $n \in \{0, 8, 16, \cdots, 64\}$.

The ECU firmware serializes one or more signals in the data field prior to transmission. Each receiver can deserialize the payload of the data field to use the original values. Researchers can easily obtain a CAN dataset $\mathcal{M}=\{m_1, m_2, m_3, \cdots\}$ through their CAN nodes by leveraging the broadcast nature of the CAN. However, it is difficult for them to understand the specific meaning of $m$ owing to the lack of information regarding the exact representation of the given $a$ and ${\bf p}$. Meanwhile, researchers who wish to build after-market autonomous driving kits or use in-vehicle signals for specific purposes, such as building a payload-based IDS for CAN buses~\cite{ShahriarXMLH22}, are motivated to reverse engineer CAN message payloads. Because manual reverse engineering requires substantial effort, several automated methods have been proposed for this purpose~\cite{VermaBSHI21, YoungSZ20, PeseSCNCS19, KangSJK18, VermaBH18, HuybrechtsVBBH17, MarkovitzW17}, and  increasingly sophisticated results have been achieved in recent years. However, these methods remain insufficient for deserializing hundreds of signals precisely.

\subsection{CAN Database}
\label{subsec:can_database}
The CAN database is a network dissector that consists of formal payload deserialization descriptions. We introduce the CAN database using a straightforward example, because signals that are deserialized from CAN messages are crucial inputs for the proposed method. A CAN database describes the specification of a certain CAN-based IVN, including the bitrate, list of ECUs, signals, and Tx-Rx ECU relationships. The CAN database specifies the bit indices, endianness, signness, scale, offset, value range, units, and list of ECUs that refer to each signal. In general, CAN databases are composed by carmakers at the time of the IVN design.

\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{figure/snippet_candb-eps-converted-to.pdf}
\caption{Snippet of CAN database \textit{hyundai\_2015\_ccan.dbc}~\cite{opendbc}.}
\label{fig:snippet_CAN_database}
\end{figure}

Recently, Comma.ai, which is a company that develops after-market autonomous driving kits, released CAN databases that work with some commercialized vehicles in a public Git repository known as OpenDBC~\cite{opendbc}. The CAN databases are formatted in the well-known DBC file format that was introduced by Vector Informatik GmbH. \autoref{fig:snippet_CAN_database} presents a snippet of a CAN database that was obtained from the repository. The first line states that an ECU named ABS (i.e., anti-lock braking system) transmits the message WHL\_SPD\_11, which consists of $a=902$ and $|{\bf p}|=64$ (i.e., 8 bytes). The remainder defines eight signals of rotation speeds (front left, front right, rear left, and rear right wheels) that are represented in km/h units, two checksum values, and two alive counters. The meanings of the CAN database syntax are annotated at the bottom of the figure. 

\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output

\begin{algorithm}[t]
\DontPrintSemicolon

\KwInput{$a, {\bf p}$: AID and payload of CAN message}
\KwData{${\rm DBC}$: CAN database} % \tcc{Now this is an if...else conditional loop}
\KwOutput{${\bf s}=\{s_i |{i=1..n}\}$: List of deserialized signals}

signals $\leftarrow$ get\_signal\_specification(DBC, $a$) \;
$n \leftarrow |{\rm signals}|$ \tcp*{Number of signals}
Initialize a new vector ${\bf s} \in \mathbb{R}^{|n|}$ \;
% \tcc{Now this is an if...else conditional loop}
\For{$i\leftarrow1$ \KwTo $n$}
{
    \tcp{Parse the specification of a signal}    
bit\_idx, bit\_len, endianness, signness, scale, offset, min, max $\leftarrow {\rm signal}_{i}$  \;
    \tcp{Obtain a subset of bit sequence}
    ${\bf p}' \leftarrow \{p_{\rm bit\_idx}, \cdots, p_{\rm bit\_idx+bit\_len} \}$ \;    
    \tcp{Decode the bit sequence into an integer}
    $s_i \leftarrow {\rm int}({\bf p}', {\rm endianness}, {\rm signness})$ \;
    \tcp{Scale the signal}
    $s_i \leftarrow s_i / {\rm scale} + {\rm offset}$ \;
    \If{not ${\rm min} \leq s_i \leq {\rm max}$}
    {
        Raise an error. \;
    }
}
\caption{Deserialization of a CAN message.}
\label{algo:deserialization}
\end{algorithm}

The deserialization procedure $D$ is described in \autoref{algo:deserialization}. The deserialization procedure can be represented by $D(a, {\bf p}) = {\bf s} = \{s_i | s_i \in \mathbb{R}~\text{for}~i=1..n\}$, where $n$ is the number of signals that are defined in the given DBC (see lines 1--2). The output vector {\bf s} contains human-understandable signals. The loop (lines 4--10) can be executed concurrently because $s_i$ are independent of one another. 

\subsection{Adversary and Attack Model}

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{figure/diagram-eps-converted-to.pdf}
  \caption{Considered in-vehicle network architecture.} 
  \label{fig:diagram}
  \vspace{-.0in}
\end{figure}

In this study, we consider an adversary who wants to sabotage a vehicle by injecting arbitrary CAN messages. \autoref{fig:diagram} depicts the supposed adversary in the CAN-based IVN. The adversary must obtain access to the target CAN-based IVN to conduct an attack. The adversary may consider physical hacking by installing a CAN dongle at the OBD-II port. The attacker may also consider the remote exploitation of vehicle-to-everything communication-enabled ECUs, such as an infotainment system~\cite{Gayou18, TeamFluoroacetate19, CostantinoM19, TencentMBUX21}. Once the adversary obtains access, they can conduct four types of attacks ~\cite{Cho2016a, ShahriarXMLH22}, as follows:

\subsubsection{Fuzzing Attack} It manipulates various ECUs with random payloads and it can be performed with CAN messages that contain random AIDs and payloads. The attack can cause a malfunction of the target vehicle even if the adversary does not have prior knowledge of the in-vehicle communications.
\subsubsection{Fabrication Attack} A specific ECU is manipulated as the intention of the adversary, and it can be performed using well-crafted CAN messages with a specific AID and payload. As a legitimate ECU periodically transmits CAN messages with the same AID, an adversary can transmit their CAN message directly after every benign message.
\subsubsection{Suspension Attack} It neutralizes an ECU by exploiting the error-handling mechanism of the CAN~\cite{Cho2016a}. A target ECU does not transmit any CAN messages during the attack.
\subsubsection{Masquerade Attack} It is a combination of the fabrication and suspension attacks. A stream from a specific ECU is replaced with arbitrary messages that are generated by the adversary during the attack.

% \begin{itemize}
%   \item The \textit{fuzzing attack} involves manipulating various ECUs with random payloads and it can be performed with CAN messages that contain random AIDs and payloads. The attack can cause a malfunction of the target vehicle even if the adversary does not have prior knowledge of the in-vehicle communications.
%   \item In the \textit{fabrication attack}, a specific ECU is manipulated as the intention of the adversary, and it can be performed using well-crafted CAN messages with a specific AID and payload. As a legitimate ECU periodically transmits CAN messages with the same AID, an adversary can transmit their CAN message directly after every benign message.
%   \item The \textit{suspension attack} neutralizes an ECU by exploiting the error-handling mechanism of the CAN~\cite{Cho2016a}. A target ECU does not transmit any CAN messages during a suspension attack.
%   \item The \textit{masquerade attack} is a combination of the fabrication and suspension attacks. A stream from a specific ECU is replaced with arbitrary messages that are generated by the adversary during the attack.
% \end{itemize}

\section{Methodology}
\label{sec:methodology}

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{figure/framework-eps-converted-to.pdf}
  \caption{Proposed framework. In the training phase, the proposed framework uses attack-free CAN messages to train the autoencoder and to determine the threshold. In the inference phase, the proposed framework determines the signal that is affected by the adversary if the CAN bus is under attack.}
  \label{fig:framework}
\end{figure*}

In this section, we present X-CANIDS, which consists of a message receiver, a feature generator, an autoencoder, and a decision-maker. As illustrated in \autoref{fig:diagram}, the proposed in-vehicle IDS is directly connected to the CAN-based IVN to receive all CAN messages instantly. It is a preferable architecture for prior CAN IDSs, while maintaining a simple topological structure. \autoref{fig:framework} outlines the proposed framework. In the training phase, X-CANIDS uses benign CAN messages to train the autoencoder ${\bf AE}$ towards small global errors. At the end of the training phase, X-CANIDS determines the thresholds using signalwise errors. In the inference phase, X-CANIDS determines whether a given input is affected by an adversary using pretrained weights and thresholds. Signalwise errors are considered to explain the detected attack. The CAN database is required in both phases for the feature generator to deserialize the signals from the CAN messages.

\subsection{Message Receiver}
The message receiver is connected to the CAN bus to monitor all CAN messages. The message receiver contains the matrix ${\bf P}\in \{\emptyset, 0, 1\}^{|N \times M|}$ to cache the latest payload of each stream, where $N$ is the number of streams in the CAN bus and $M$ is the maximum length of the payload (64 for the CAN 2.0A bus and 512 for the CAN-FD bus). 

\begin{equation} \label{eq:P}
  {\bf P} = 
    \begin{pmatrix}
    {\bf p}_1 \\
    {\bf p}_2 \\
    \vdots \\
    {\bf p}_{N}
    \end{pmatrix} 
    =
    \begin{pmatrix}
    p_{11} & p_{12} & \cdots & p_{1M} \\
    p_{21} & p_{22} & \cdots & p_{2M} \\
    \vdots  & \vdots  & \ddots & \vdots  \\
    p_{N1} & p_{N2} & \cdots & p_{NM} \\ 
    \end{pmatrix}
\end{equation}
In \cref{eq:P}, the $n$-th row of the matrix ${\bf P}$ represents the latest payload of a certain stream for each ${\bf p}_{n}$. Initially, $p_{n, m}=\emptyset \forall_{n\in\{1..N\},m\in\{1..M\}}$. As the message receiver monitors each CAN message from the CAN bus, $p_{n, m}$ becomes 0 or 1. It should be noted that ${\bf P}$ is volatile because the elements change continuously upon the arrival of CAN messages.

\subsection{Feature Generator}
\label{subsec:feature_generator}
The feature generator interprets each ${\bf P}$ into a feature matrix ${\bf S}$, which is fed to the autoencoder. The feature generator pipeline consists of the following: (1) the payload sampler, (2) deserializer, (3) feature scaler, and (4) time-series feature generator. 

\subsubsection{Payload Sampler}
The payload sampler captures ${\bf P}_{\rm copy}$, which is a static copy of ${\bf P}$, from the message receiver in every time interval $t$. The payload sampler begins working when ${\bf P}$ satisfies $p_{n,1}\neq\emptyset \forall_{n\in\{1..N\}}$, which means that the message receiver observes each stream at least once. Each copy is forwarded to the deserializer.

\subsubsection{Deserializer}
The deserializer converts a given ${\bf P}_{\rm copy}$ into a vector ${\bf s} \in \mathbb{R}$ that contains human-understandable signals, such as the engine speed and steering wheel angle. The deserialization procedure for ${\bf P}_{\rm copy}$ can be represented as

\begin{equation} \label{eq:deserialization_payload}
  {\bf P}_{\rm copy} = 
    \begin{pmatrix}
      {\bf p}_1 \\
      {\bf p}_2 \\
      \vdots \\
      {\bf p}_{N} \\
    \end{pmatrix}
    \begin{matrix}
      \xrightarrow{D(a_1, {\bf p}_1)} \\
      \xrightarrow{D(a_2, {\bf p}_2)} \\
      \xrightarrow{\text{deserialize}} \\
      \xrightarrow{D(a_N, {\bf p}_N)} \\
    \end{matrix}
    \begin{pmatrix}
      {\bf s}_1 \\
      {\bf s}_2 \\
      \vdots \\
      {\bf s}_{N} \\
    \end{pmatrix}
    \xrightarrow{\text{concatenate}}
    {\bf s}
\end{equation}

The streamwise deserialization procedure calculates \autoref{algo:deserialization}. Thus, the output vectors ${\bf s}_1, {\bf s}_2, \cdots, {\bf s}_n$ are dependent on the given CAN database and ${\bf P}_{\rm copy}$. In particular, the CAN database determines the number of elements in ${\bf s}_i$. The vector ${\bf s}=\Vert_{n=1}^{N}{\bf s}_n$ represents the concatenation of all deserialized signals and is fed to the feature scaler.

\subsubsection{Feature Scaler} 
The feature scaler is crucial because the elements of ${\bf s}$ have various value ranges. For example, the engine speed and steering wheel angle can be represented within $[0, 8191]$ RPM and $[-1024, 1023]$ degrees, respectively. Furthermore, a binary value (0 or 1) can be used to represent whether a foot brake is engaged. The variation in signal ranges may result in unstable training of $\bf{AE}$ because it can be considered as a weight (i.e., feature importance).

We design a lightweight feature scaler to achieve robust performance. The signal scaler is designed to normalize a given ${\bf s}$ to ${\bf\hat s}=\{{\hat s_i}|{\hat s_i}\in[0, 1], {i=1..x}\}$, where $x=|{\bf s}|$ is the number of concatenated signals. The proposed feature scaling procedure is presented in \cref{eq:signal_scaling}, where the parameters ${\rm min}_i$ and ${\rm max}_i$ are the minimum and maximum values, respectively, of the $i$-th signal described in the CAN database. 

\begin{equation}
  \label{eq:signal_scaling}
	{\hat s_i} = \frac{s_i-{\rm min}_i}{{\rm max}_i-{\rm min}_i}
\end{equation}

The proposed scaling procedure is the same as the conventional min-max scaling procedure, except for the determination method of the parameters ${\rm min}_i$ and ${\rm max}_i$. The min-max scaler fits the parameters according to observations in the training phase (i.e., a training set). A downside of the min-max scaler is that it does not correctly handle outliers that are over the maximum or under the minimum values that may be observed in the inference phase. We leverage the minimum and maximum values that are predefined in the CAN database to overcome this drawback. Note that a scaled signal ${\hat s_i}$ is always represented by 0--1 because $s_i$ satisfies ${\rm min}_i \leq s_i \leq {\rm max}_i$ (cf. lines 9--10 of \autoref{algo:deserialization}). The scaled vector ${\bf\hat s}$ is fed to the time-series feature generator.

\subsubsection{Time-Series Feature Generator}
The time-series feature generator builds an input for the autoencoder in a sliding-window manner. It temporarily remembers the most recent $w$ input vectors and returns a two-dimensional matrix ${\bf S} \in [0, 1]^{w \times x}$ by stacking them. The window size $w$ is a parameter that determines the number of time steps that are contained by the feature. The time-series feature generator returns ${\bf S}$ every $t$ as the payload sampler feeds ${\bf P}_{\rm copy}$. The matrix representation helps the autoencoder to understand the time series and lateral relationships between the signals.

\subsection{Autoencoder}
In the proposed framework, the autoencoder ${\bf AE}$ is adapted to model the attack-free state of a moving vehicle. The autoencoder is a self-supervised neural network that consists of an encoder and a decoder, as expressed by 

\begin{equation}\label{eq:autoencoder}
  {\bf AE}({\bf S}) = {\rm Decoder}({\rm Encoder}({\bf S}))= {\rm Decoder}(h)={\bf S}'
\end{equation}
The encoder compresses the input feature ${\bf S}$ into a low-dimensional latent vector $h$. Subsequently, the decoder attempts to reconstruct the original input data as far as possible using the latent vector. In the training phase, ${\bf AE}$ is fitted with features from benign datasets using backpropagation to reduce the global mean squared error (MSE). The global MSE is calculated as follows:
\begin{equation}\label{eq:mse_global}
  \mathcal{L}_g({\bf S}, {\bf S}') = \frac{1}{wx} \sum_{j=1}^w\sum_{i=1}^x ({\bf S}_{ji}-{\bf S}_{ji}')^2
\end{equation}
It is also referred to as the reconstruction error in terms of an autoencoder. The goal of ${\bf AE}$ is to exhibit a small reconstruction error in the inference phase, particularly when a given sample is attack free. However, ${\bf AE}$ is required to exhibit a high reconstruction error when the input ${\bf S}$ is affected by an adversary.

${\bf AE}$ is supposed to be computed on an automotive-grade embedded device. Therefore, the model complexity should be considered while minimizing the reconstruction error. We conceive the six candidate layers for ${\bf AE}$ as follows: the fully connected, 1D and 2D convolutional, 1D separable convolutional, long short-term memory (LSTM), and bidirectional LSTM (BiLSTM) layers. We evaluate the layers using training and validation datasets.

\subsection{Intrusion Detection and Explanation}
The global MSE can be used solely to distinguish anomalies. Nevertheless, we measure the signalwise MSE to obtain explainable intrusion detection results. In this section, we define the inference function $f({\bf S})$ that calculates the signalwise MSE. Thereafter, we introduce the threshold determinator and intrusion detector.

\subsubsection{Inference Function}
Once ${\bf AE}$ has been fitted, the signalwise loss function $\mathcal{L}_s$ is combined with ${\bf AE}$ to formulate the inference function $f({\bf S})$. Equation \cref{eq:detection_function} presents the inference function that returns the loss vector ${\bf l}$. The element $l_i$ is the loss of the $i$-th signal.

\begin{equation}\label{eq:detection_function}
  \begin{aligned}
  f({\bf S}) = & \mathcal{L}_s({\bf S}, {\bf AE}({\bf S})) = \mathcal{L}_s({\bf S}, {\bf S}') \\ = 
 & \frac{1}{w} \sum_{j=1}^w({\bf S}_j-{\bf S}_j')^2 = {\bf l} = \{l_1, l_2, \cdots, l_x\}
  \end{aligned}
\end{equation}

\subsubsection{Threshold Determination}
The threshold determinator is used during the training phase. This module aims to determine $\theta_i$ for the error rate calculation of the $i$-th signal and the detection threshold $\Theta$ to raise the alarm. 

First, the module calculates a set of loss vectors $\{\bf{l}_1, \bf{l}_2, \cdots\}$ using the entire training set. Second, $\theta_i = \overline{l_i} + 3\sigma_i$ is considered for the $i$-th signal, where $\overline{l_i}$ and $\sigma_i$ are the mean and standard deviation of $l_i$s in the set, respectively. Third, the module measures a set of error-rate vectors $\{\bf{r}_1, \bf{r}_2, \cdots\}$ using the entire validation set. The error rate vector {\bf r} is derived as follows:
\begin{equation}\label{eq:error_rate}
  {\bf r} = \{r_i | r_i = l_i/\theta_i~\text{for}~ i=1..x\}
\end{equation}
Finally, $\Theta$ is determined by the $q$-th percentile of ${\rm max}({\bf r})$ for all ${\bf r}$s in the set, where $0.95 \leq q \leq 1$ and $q$ is a hyperparameter that determines the detection sensitivity.

\subsubsection{Intrusion Detection and Explanation}
The intrusion detection module uses the $\theta_i$s and $\Theta$ from the threshold determinator at the beginning of the inference phase. The intrusion detector obtains ${\bf r}$ for each ${\bf S}$ using \cref{eq:detection_function} and \cref{eq:error_rate}. The module raises an alarm if ${\bf r}$ satisfies $\rm{max}({\bf r}) > \Theta$. If an intrusion is identified, the intrusion detector identifies the affected signal index $i$ using $\rm{argmax}({\bf r})$.

\section{Datasets}
\label{sec:dataset}
\begin{table}[t]
  \caption{List of CAN datasets.} 
  \label{table:list_dataset}
  \centering
  \begin{tabular}{rrrll}
  \hline
  Dataset & \# CAN msg. & Duration & Context & Used for\\
  \hline
  $\mathcal{M}_1$ &  3,123,784 &  23 m 52 s &   Driving (18.7 km) & Training \\
  $\mathcal{M}_2$ &  4,134,495 &  31 m 35 s &   Driving (19.3 km) & Training \\
  $\mathcal{M}_3$ &  3,233,752 &  24 m 42 s &   Driving (19.4 km) & Training \\
  $\mathcal{M}_4$ &  4,761,315 &  36 m 23 s &   Driving (21.7 km) & Training \\\
  $\mathcal{M}_5$ &  2,915,969 &  22 m 17 s &   Driving (18.8 km) & Validation \\
  $\mathcal{M}_6$ &  4,279,902 &  32 m 42 s &   Driving (18.8 km) & Testing  \\
  $\mathcal{M}_7$ &  4,817,589 &  36 m 54 s &   Stationary (0 km) & Training \\\hline
  \end{tabular}
  \vspace{-0in}
\end{table}

The datasets used in the experiment are discussed in this section. Publicly available CAN intrusion datasets~(e.g., \cite{LeeJK17, VermaIBHMKC22}) exist. However, they could not be utilized because the datasets were stationary or prepared using a dynamometer. Therefore, we captured CAN messages from the Hyundai LF Sonata 2017. We used a Kvaser Memorator Pro 2xHS to leverage the high-precision embedded clock while capturing the in-vehicle CAN messages. The device was connected to our vehicle through an OBD-II port, which allowed us to access the chassis--CAN bus. We prepared the seven CAN datasets that are listed in \autoref{table:list_dataset}. We captured six datasets while driving a vehicle on urban roads in Seoul, Republic of Korea. One dataset was captured while the vehicle was stationary. 

We used the CAN database \textit{hyundai\_2015\_ccan.dbc} that is available on OpenDBC~\cite{opendbc} to deserialize the payloads of the datasets into signals. We manually confirmed that the CAN database allowed us to acquire appropriate sensor values, such as the steering wheel angle, temperature, velocity, tire pressure, and door open state.

\subsubsection{Overview of Datasets}
\begin{table}[t]
  \caption{Summary of $\mathcal{M}_1$ that consists of 62 streams.}
  \label{table:dataset_summary}
  \centering
  \begin{adjustbox}{width=\linewidth,center}
  \setlength{\tabcolsep}{6pt} % default: 6pt
  \begin{tabular}{rlrrrrr}
  \hline
  AID &           Sender ECU  &  Mean $\Delta t$ &  Std. $\Delta t$ &  DLC &  \# signals &  \# uniq. ${\bf p}$ \\\hline
  042h &        DATC12 &          1.00 &      0.000261 &    8 &         7 &              1 \\
  043h &        DATC13 &          1.00 &      0.000261 &    8 &        24 &              1 \\
  044h &        DATC11 &          0.96 &      0.180892 &    8 &         6 &             14 \\
  07Fh &          CGW5 &          1.00 &      0.000124 &    8 &        25 &              1 \\
  080h &     EMS\_DCT11 &          0.01 &      0.000304 &    8 &        10 &        105,446 \\\hline
  081h &     EMS\_DCT12 &          0.01 &      0.000356 &    8 &         6 &          1,000 \\
  111h &         TCU11 &          0.01 &      0.000191 &    8 &        13 &            555 \\
  112h &         TCU12 &          0.01 &      0.000201 &    8 &        12 &          6,083 \\
  113h &         TCU13 &          0.01 &      0.000203 &    8 &        18 &            441 \\
  153h &         TCS11 &          0.01 &      0.000132 &    8 &        29 &             15 \\\hline
  162h &     TCU\_DCT13 &          0.01 &      0.000207 &    3 &         3 &          6,185 \\
  164h &         VSM11 &          0.01 &      0.000220 &    4 &         6 &             16 \\
  18Fh &       EMS\_H12 &          0.01 &      0.000449 &    8 &        21 &          2,117 \\
  200h &         EMS20 &          0.01 &      0.000370 &    6 &         3 &            348 \\
  220h &         ESP12 &          0.01 &      0.000211 &    8 &        14 &        130,706 \\\hline
  251h &        MDPS12 &          0.01 &      0.000311 &    8 &        11 &        116,572 \\
  260h &         EMS16 &          0.01 &      0.000664 &    8 &        15 &         41,585 \\
  2B0h &         SAS11 &          0.01 &      0.000683 &    5 &         5 &         17,265 \\
  316h &         EMS11 &          0.01 &      0.000823 &    8 &        13 &         63,371 \\
  329h &         EMS12 &          0.01 &      0.000352 &    8 &        19 &          7,776 \\\hline
  381h &        MDPS11 &          0.02 &      0.000530 &    8 &        13 &         32,040 \\
  383h &        FATC11 &          0.02 &      0.000395 &    8 &        19 &            320 \\
  386h &     WHL\_SPD11 &          0.02 &      0.000399 &    8 &         8 &         61,540 \\
  387h &     WHL\_PUL11 &          0.02 &      0.000418 &    6 &         9 &         60,269 \\
  410h &      CGW\_USM1 &          0.20 &      0.000522 &    8 &        17 &              1 \\\hline
  436h &         PAS11 &          0.05 &      0.000661 &    4 &        12 &              1 \\
  47Fh &         ESP11 &          0.02 &      0.000256 &    6 &        11 &            256 \\
  490h &         EPB11 &          0.05 &      0.000515 &    7 &        14 &              1 \\
  492h &         EMS19 &          0.05 &      0.000460 &    8 &        13 &              4 \\
  4F1h &         CLU11 &          0.02 &      0.000446 &    4 &        12 &         14,476 \\\hline
  500h &         ACU14 &          0.10 &      0.000504 &    1 &         3 &              1 \\
  502h &         TCU14 &          0.10 &      0.000374 &    4 &         7 &              1 \\
  507h &         TCS15 &          0.10 &      0.000288 &    4 &        11 &              1 \\
  50Ch &         CLU13 &          0.10 &      0.000463 &    8 &        17 &          1,484 \\
  520h &          CGW3 &          0.10 &      0.000850 &    8 &         4 &              1 \\\hline
  522h &   GW\_IPM\_PE\_1 &          0.20 &      0.000558 &    8 &        10 &              1 \\
  52Ah &         CLU15 &          0.10 &      0.076209 &    8 &        15 &             94 \\
  533h &           --- &          0.10 &      0.000706 &    8 &      --- &             29 \\
  534h &           --- &          0.10 &      0.000704 &    8 &      --- &            517 \\
  535h &           --- &          0.10 &      0.000674 &    8 &      --- &          1,249 \\\hline
  541h &          CGW1 &          0.10 &      0.014478 &    8 &        43 &              4 \\
  544h &           --- &          0.20 &      0.000422 &    8 &      --- &              1 \\
  545h &         EMS14 &          0.10 &      0.000335 &    8 &         8 &            234 \\
  547h &         EMS15 &          0.10 &      0.000545 &    8 &        12 &             38 \\
  549h &         BAT11 &          0.10 &      0.000570 &    8 &         9 &          6,635 \\\hline
  54Ch &     TCU\_DCT14 &          0.20 &      0.000385 &    8 &         2 &              1 \\
  553h &          CGW2 &          0.20 &      0.013671 &    8 &        41 &              6 \\
  555h &        FPCM11 &          0.10 &      0.000507 &    8 &         9 &            670 \\
  556h &   EngFrzFrm11 &          0.10 &      0.000578 &    8 &         6 &         11,649 \\
  557h &   EngFrzFrm12 &          0.10 &      0.000587 &    8 &         6 &          4,932 \\\hline
  559h &          CGW4 &          0.20 &      0.000655 &    8 &        23 &              1 \\
  57Fh &  HU\_MON\_PE\_01 &          2.00 &      0.000782 &    8 &         1 &              1 \\
  587h &         TMU11 &          0.20 &      0.000347 &    8 &         8 &             15 \\
  58Bh &         LCA11 &          0.10 &      0.001104 &    8 &        18 &              7 \\
  593h &        TPMS11 &          0.20 &      0.000554 &    6 &        12 &             11 \\\hline
  5A0h &         ACU11 &          1.00 &      0.001139 &    8 &        14 &              2 \\
  5B0h &         CLU12 &          1.00 &      0.000780 &    4 &         1 &            184 \\
  5B4h &           --- &          1.00 &      0.000776 &    8 &      --- &              1 \\
  5BEh &           --- &          1.00 &      0.000834 &    8 &      --- &              1 \\
  5C0h & GW\_Warning\_PE &          1.00 &      0.000810 &    8 &         7 &              1 \\\hline
  5D3h & HU\_DATC\_PE\_00 &          1.00 &      0.000806 &    8 &         3 &              1 \\
  5FAh &         ODS11 &          1.00 &      0.000965 &    8 &        10 &              1 \\\hline
  \end{tabular}
  \end{adjustbox}
  \vspace{-0in}
  \end{table}

The dataset $\mathcal{M}_1$ is summarized in \autoref{table:dataset_summary} to introduce our CAN datasets. The chassis--CAN bus consisted of 62 unique streams. We denote the name of the transmitting ECU using the CAN database for each stream. The ECU names; for example, engine management system (EMS), transmission control unit (TCU), and motor-driven power steering system (MDPS), imply that the streams take charge of the communications among critical vehicular applications. 

We measured the mean and standard deviation of the message intervals for each stream. ECUs transmit their messages periodically through a well-known mechanism. Thus, it can be observed that the mean time intervals of the streams were approximately one of .01, .02, .05, .1, .2, 1, and 2 s. However, several streams consisted of nonperiodic messages, namely 044h, 52Ah, 541h, and 553h (where the standard deviation $ \geq .01$). These streams may not be covered by time-interval-based intrusion detection methods (e.g., \cite{SongKK16, TomlinsonBSK18, OlufowobiYZB19, OlufowobiYZB19, YoungOBZ19}) that leverage the periodicity.

The number of signals that were defined in each stream is also summarized. In total, there were 688 types of signals. Furthermore, the number of unique payloads for each stream is presented. Interestingly, although we captured $\mathcal{M}_1$ while we drove the vehicle for more than 18 km, certain streams (e.g., 042h, 043h, and 5D3h) had a static payload.

\subsubsection{Payload Dynamics}
We expected that the payloads in the CAN messages would change more dynamically when the vehicle moved. To prove this hypothesis, we calculated the bitwise Hamming distance vector ${\bf d}$ for each stream, as follows:

\newcommand{\legendsquare}[1]{\textcolor[RGB]{#1}{\rule{1.5ex}{1.5ex}}}
\begin{figure*}[!t]
\centering
\includegraphics[width=.9\linewidth]{figure/02_payload_hammingdistance_cbar-eps-converted-to.pdf}\\\vspace{-.2cm}
\subfloat[Stationary dataset $\mathcal{M}_7$ with 764 bits flipped. $\Sigma\Sigma {\bf d}=105.91$.]{\includegraphics[width=.49\linewidth]{figure/02_payload_hammingdistance_idling-eps-converted-to.pdf}%\label{subfig:__MODITY__}% (19.25\%)
}
\hfil
\subfloat[Driving dataset $\mathcal{M}_1$ with 968 bits flipped. $\Sigma\Sigma {\bf d}=135.45$.]{\includegraphics[width=.49\linewidth]{figure/02_payload_hammingdistance_naebu_city_highway1-eps-converted-to.pdf}%\label{subfig:__MODIFY__}%(26.61\%) 
}
\caption{Bitwise Hamming distance measurements to compare the payload dynamics of two CAN datasets captured during idling and driving. Each cell represents a value [0, 1] calculated by the number of bits flipped over the observation count. A dark cell~\legendsquare{43,27,52} means that a bit was flipped nearly every time a message arrived. A light green cell~\legendsquare{186,225,210} means that a bit was flipped only once or several times. A blank cell~\legendsquare{231,231,240} indicates no bit flips. A comparison of the two datasets reveals that the payloads changed more dynamically while the vehicle moved.}
\label{fig:hammingdistance}
\end{figure*}

\begin{equation}
  {\bf d} = \frac{1}{n-1} \sum\limits_{i=2}^{n} \left({\bf p}_i \oplus {\bf p}_{i-1}\right)
\end{equation}
where $\oplus$ is the bitwise XOR operator, ${\bf p}_i$ is the payload of the $i$-th message in a stream, and $n$ is the number of messages in a stream. For comparison, we measured the Hamming distance using the stationary dataset $\mathcal{M}_7$ and driving dataset $\mathcal{M}_1$. The measurements are shown in \autoref{fig:hammingdistance}. Note that $\mathcal{M}_7$ contains more CAN messages than $\mathcal{M}_1$. However, a higher Hamming distance can be observed for $\mathcal{M}_1$. Specifically, 968 bits were flipped once or more while the vehicle was moving, whereas only 764 bits were flipped while the vehicle was stationary. Moreover, the sum of the Hamming distance differed; $\approx 23\%$ of bit flips occurred more frequently while the vehicle was moving.

\section{Experimental Results}
\label{sec:experimental_result}
The detection performance, feasibility, and explainability of X-CANIDS are discussed in this section. First, the parameters used in the experiment are described. \autoref{table:dataset_summary} displays 62 streams and a maximum DLC of 8. Thus, we set $N=62$ and $M=64$ for the message receiver. Considering that the minimum and maximum values of the average time intervals were .01 s and 2 s, we assigned $t=0.01{\rm s}$ and $w=200$. As noted in the previous section, there were 688 signal types. Thus, we initially achieved a $200 \times 688$-sized ${\bf S}$ every .01 s. We assigned the parameter $\Theta=40$ (where $q=0.9869$) for the intrusion detection.

We observed that X-CANIDS did not need to examine all signals in our vehicles to detect intrusions. Many static signals (e.g., the 10 signals of stream 5FAh in \autoref{table:dataset_summary}) can be inspected using a simple rule, whether or not a change occurs. Moreover, certain signals contain checksums or sequential counters that are easily predictable. We excluded static signals and signals that contained the following keywords: \textit{sum}, \textit{alive}, \textit{msgcount}, \textit{msgcnt}, \textit{paritybit}, and \textit{mul\_code}. After excluding these signals, we obtained 107 signals from the 35 streams. Thus, the final feature shape of ${\bf S}$ was $200 \times 107$.

\subsection{Autoencoder Layer}

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{figure/13_loss-eps-converted-to.pdf}
  \caption{Learning curves of six types of autoencoders. Each training run was terminated using the early-stopping strategy. The BiLSTM-based autoencoder exhibited the smallest reconstruction error of 4.686e-4, at epoch 948.}
  \label{fig:trainloss}
\end{figure}
  
First, we examine the optimal layer for ${\bf AE}$. We used six types of layers to implement the autoencoders and trained them for up to 2,000 epochs with an early-stopping patience of 50 epochs. The Adam optimizer fitted the models with a learning rate of 0.0001. A smaller MSE indicated better performance provided by a layer to ${\bf AE}$. The experimental results are presented in \autoref{fig:trainloss}. The BiLSTM layer enabled the best performance in our experiment, followed by the LSTM and Conv2D layers. 

\autoref{table:ae_model} outlines the BiLSTM-based ${\bf AE}$, which was used for the remainder of the experiments. The encoder compresses a ${200 \times 107}$-sized matrix ${\bf S}$ into a $250$-sized latent vector $h$ (compression rate $\approx 1.17\%$). The decoder reconstructs ${\bf S}'$ using $h$.

\begin{table}[t]
  \caption{Layout of BiLSTM-based ${\bf AE}$.}
  \label{table:ae_model}
  \centering
  \begin{tabular}{lrrc}
  \hline
  Layer & \# parameters & Output shape & Symbol \\\hline
  Input & 0 & $200 \times 107$ & ${\bf S}$ \\
  BiLSTM & 184,040 & $200 \times 214$ & \\
  BiLSTM & 340,000 & $250$ & $h$ \\\hline
  Repeat input 200 times & 0 & $200 \times 250$ & \\
  BiLSTM & 306,448 & $200 \times 214$ & \\
  BiLSTM & 275,632 & $200 \times 214$ & \\
  Time-distributed dense & 23,005 & $200 \times 107$ & ${\bf S}'$\\\hline
  \end{tabular}
  \vspace{-.1in}
\end{table}

\subsection{Intrusion Detection Performance}
We tested the proposed method using the test set $\mathcal{M}_6$. We conducted an attack simulation in the period 480--1440 s to evaluate the intrusion detection performance with a label-balanced test set. We denoted the ground-truth labels as ``attack'' if a given ${\bf S}$ was affected by the attack. As each input was generated every $t=0.01 \text{s}$, the detection result was also labeled every 0.01 s. We used the precision, recall, and F1-score as the performance evaluation metrics. 

\begin{table}[t]
  \caption{Intrusion detection performance against fuzzing attacks.}
  \label{table:fuzz_detection}
  \centering
  \begin{tabular}{rr|rrr}
    \hline
    Fuzzing rate &  Bus load (\%) &  Precision &   Recall &  F1-score \\\hline
    10 msg./s &    100.4584 &   0.992762 & 0.955380 &  0.973712 \\
    20 msg./s &    100.9168 &   0.993057 & 0.996247 &  0.994650 \\
    30 msg./s &    101.3752 &   0.993081 & 0.999699 &  0.996379 \\
    40 msg./s &    101.8336 &   0.993082 & 0.999844 &  0.996452 \\
    50 msg./s &    102.2920 &   0.993080 & 0.999491 &  0.996275 \\
    60 msg./s &    102.7504 &   0.993083 & 0.999958 &  0.996509 \\
    70 msg./s &    103.2088 &   0.993083 & 0.999896 &  0.996478 \\
    80 msg./s &    103.6672 &   0.993021 & 0.999927 &  0.996462 \\
    90 msg./s &    104.1256 &   0.992970 & 0.999948 &  0.996447 \\
   100 msg./s &    104.5840 &   0.992960 & 0.999979 &  0.996457 \\
   200 msg./s &    109.1681 &   0.992960 & 0.999969 &  0.996452 \\
   300 msg./s &    113.7521 &   0.992971 & 0.999979 &  0.996463 \\
   400 msg./s &    118.3362 &   0.992479 & 0.999990 &  0.996220 \\
   500 msg./s &    122.9202 &   0.992971 & 0.999990 &  0.996468 \\
  1,000 msg./s &    145.8404 &   0.992151 & 1.000000 &  0.996060 \\
  1,500 msg./s &    168.7606 &   0.992151 & 1.000000 &  0.996060 \\
  2,000 msg./s &    191.6808 &   0.992162 & 1.000000 &  0.996065 \\
    \hline
    \end{tabular}
    \vspace{-.0in}
  \end{table}  

\autoref{table:fuzz_detection} presents the intrusion detection performance against fuzzing attacks with various fuzzing rates. The bus load column indicates the change in the number of CAN messages during the fuzzing attack. Note that the average number of CAN messages per second was $\approx 2181.48$ in the CAN bus. It can be observed that the overall detection performance was outstanding. In particular, X-CANIDS distinguished small-scale attacks with a fuzzing rate of 10 messages per second. Even when 0.4584\% of the bus load increased compared with the attack-free state, the proposed method achieved a recall of 0.955380. As the fuzzing rate increased, X-CANIDS identified nearly all intrusions, with a recall of $\approx 1$. The precision was always higher than 0.992, indicating a false positive rate of less than 0.008.

\begin{table*}[t]
  \caption{Intrusion detection performance against fabrication, masquerade, and suspension attacks.}
  \label{table:injection_detection}
  \centering
  \begin{tabular}{r|rrr|rrr|rrr}
    \hline
    %  AID &  Precision &   Recall &  f1-score &  Precision &   Recall &  f1-score &  Precision &   Recall &  f1-score \\\hline
    \multicolumn{1}{l|}{\multirow{2}{*}{Target AID}} & \multicolumn{3}{l|}{Fabrication attack} & \multicolumn{3}{l|}{Masquerade attack} & \multicolumn{3}{l}{Suspension attack} \\ \cline{2-10} 
\multicolumn{1}{r|}{} & \multicolumn{1}{r}{Precision} & \multicolumn{1}{r}{Recall} & \multicolumn{1}{r|}{F1-score} & \multicolumn{1}{r}{Precision} & \multicolumn{1}{r}{Recall} & \multicolumn{1}{r|}{F1-score} & \multicolumn{1}{r}{Precision} & \multicolumn{1}{r}{Recall} & \multicolumn{1}{r}{F1-score} \\ \hline
044h &   0.992069 & 0.999990 &  0.996013 &   0.992069 & 0.999990 &  0.996013 &   0.963529 & 0.184259 &  0.309358 \\
080h &   0.992706 & 0.947952 &  0.969813 &   0.993083 & 1.000000 &  0.996530 &   0.988034 & 0.575100 &  0.727024 \\
081h &   0.992784 & 0.958149 &  0.975159 &   0.993083 & 1.000000 &  0.996530 &   0.982371 & 0.388112 &  0.556403 \\
111h &   0.992623 & 0.937089 &  0.964057 &   0.993083 & 1.000000 &  0.996530 &   0.991439 & 0.806536 &  0.889480 \\
112h &   0.992731 & 0.951195 &  0.971519 &   0.993083 & 1.000000 &  0.996530 &   0.992162 & 0.881579 &  0.933607 \\\hline
113h &   0.992874 & 0.970436 &  0.981527 &   0.993083 & 1.000000 &  0.996530 &   0.987749 & 0.561534 &  0.716015 \\
162h &   0.992805 & 0.961049 &  0.976669 &   0.993083 & 0.999979 &  0.996519 &   0.979828 & 0.338309 &  0.502959 \\
18Fh &   0.992925 & 0.977505 &  0.985155 &   0.993083 & 0.999979 &  0.996519 &   0.985538 & 0.474620 &  0.640693 \\
200h &   0.993070 & 0.998046 &  0.995552 &   0.993083 & 1.000000 &  0.996530 &   0.963547 & 0.184098 &  0.309132 \\
220h &   0.993002 & 0.988264 &  0.990627 &   0.993083 & 0.999990 &  0.996525 &   0.963526 & 0.183983 &  0.308969 \\\hline
251h &   0.992672 & 0.943482 &  0.967452 &   0.993081 & 0.999615 &  0.996337 &   0.963466 & 0.183671 &  0.308526 \\
260h &   0.993069 & 0.997859 &  0.995458 &   0.993083 & 0.999990 &  0.996525 &   0.985963 & 0.489215 &  0.653952 \\
2B0h &   0.993049 & 0.994948 &  0.993997 &   0.993082 & 0.999823 &  0.996441 &   0.963512 & 0.183910 &  0.308866 \\
316h &   0.993057 & 0.996206 &  0.994629 &   0.993083 & 1.000000 &  0.996530 &   0.992133 & 0.878346 &  0.931778 \\
329h &   0.993083 & 0.999979 &  0.996519 &   0.993083 & 1.000000 &  0.996530 &   0.991464 & 0.809000 &  0.890987 \\\hline
381h &   0.963535 & 0.184037 &  0.309046 &   0.963535 & 0.184037 &  0.309046 &   0.963535 & 0.184037 &  0.309046 \\
383h &   0.993083 & 0.999979 &  0.996519 &   0.993083 & 0.999990 &  0.996524 &   0.963496 & 0.183829 &  0.308751 \\
386h &   0.993083 & 1.000000 &  0.996530 &   0.993073 & 1.000000 &  0.996525 &   0.992000 & 0.864935 &  0.924120 \\
387h &   0.990087 & 0.695641 &  0.817149 &   0.989267 & 0.641968 &  0.778646 &   0.988719 & 0.610408 &  0.754814 \\
47Fh &   0.984029 & 0.429115 &  0.597620 &   0.964230 & 0.187750 &  0.314301 &   0.964217 & 0.187677 &  0.314198 \\\hline
4F1h &   0.993083 & 1.000000 &  0.996530 &   0.993073 & 1.000000 &  0.996525 &   0.991667 & 0.830069 &  0.903701 \\
50Ch &   0.993001 & 1.000000 &  0.996488 &   0.992990 & 1.000000 &  0.996483 &   0.963526 & 0.184008 &  0.309004 \\
52Ah &   0.992898 & 1.000000 &  0.996436 &   0.992888 & 1.000000 &  0.996431 &   0.991916 & 0.878922 &  0.932007 \\
541h &   0.993073 & 0.999927 &  0.996488 &   0.993062 & 0.999927 &  0.996483 &   0.985743 & 0.481564 &  0.647033 \\
545h &   0.993011 & 0.999979 &  0.996483 &   0.993011 & 0.999979 &  0.996483 &   0.963692 & 0.184872 &  0.310230 \\\hline
547h &   0.993021 & 0.999958 &  0.996478 &   0.993021 & 0.999958 &  0.996478 &   0.984437 & 0.440592 &  0.608739 \\
549h &   0.992991 & 1.000000 &  0.996483 &   0.992991 & 1.000000 &  0.996483 &   0.963535 & 0.184050 &  0.309065 \\
553h &   0.990161 & 0.714547 &  0.830074 &   0.990147 & 0.714544 &  0.830067 &   0.985703 & 0.480181 &  0.645776 \\
555h &   0.993011 & 0.999979 &  0.996483 &   0.993011 & 0.999979 &  0.996483 &   0.963527 & 0.184015 &  0.309014 \\
556h &   0.992991 & 1.000000 &  0.996483 &   0.992991 & 1.000000 &  0.996483 &   0.992019 & 0.877421 &  0.931208 \\\hline
557h &   0.993021 & 0.999969 &  0.996483 &   0.993021 & 0.999969 &  0.996483 &   0.966738 & 0.202441 &  0.334777 \\
58Bh &   0.993042 & 0.999948 &  0.996483 &   0.993042 & 0.999948 &  0.996483 &   0.963823 & 0.185566 &  0.311214 \\
593h &   0.967559 & 0.207788 &  0.342107 &   0.967401 & 0.206748 &  0.340687 &   0.967401 & 0.206748 &  0.340687 \\
5A0h &   0.992688 & 0.999354 &  0.996010 &   0.992688 & 0.999354 &  0.996010 &   0.963486 & 0.184066 &  0.309084 \\
5B0h &   0.992067 & 1.000000 &  0.996018 &   0.992067 & 1.000000 &  0.996018 &   0.963531 & 0.184076 &  0.309100 \\\hline
Average &   0.990913 & 0.910068 &  0.931330 &   0.990395 & 0.912386 &  0.927607 &   0.976485 & 0.424050 &  0.545980 \\\hline
\end{tabular}
\vspace{-0in}
\end{table*}

\autoref{table:injection_detection} presents the intrusion detection performance against fabrication, masquerade, and suspension attacks. In total, 105 experiments were conducted in 35 streams. The average precision was higher than 0.99 for the fabrication and masquerade attacks. The recall values were polarized but excellent in general. However, the proposed method achieved unsatisfactory recall values against fabrication and masquerade attacks in five streams, namely 381h, 387h, 47Fh, 553h, and 593h. Meanwhile, poor performance against suspension attacks was observed and the average recall value was 0.424050. Unfortunately, this means that more than half of the intrusion samples were misclassified as benign on average. Our method effectively detected the suspension of streams 112h, 316h, 386h, 4F1h, 52Ah, and 556h (F1-score $\geq 0.9$).

\subsection{Performance Comparison with Prior Research}
As it is difficult for researchers to obtain CAN databases, previous payload-based studies~\cite{KangK16, TaylorLJ16, TariqLKW20, HossainIOFK20, LongariVZCZ20} used the raw payloads of CAN messages as inputs. For a comparison of the detection performance with prior research, we implemented a method known as CANnolo proposed by Longari \textit{et al.}~\cite{LongariVZCZ20} because the concept of the study is similar to that of our method. They proposed a self-supervised IDS using an LSTM-based autoencoder. CANnolo is supposed to be trained with benign time-series payloads in the bit representation. Consequently, we trained the model using our training set. 

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{figure/20_roc_curve-eps-converted-to.pdf}
  \caption{ROC curves. X-CANIDS (curve 1) exhibited better intrusion detection performance compared to the previous work (curve 2)~\cite{LongariVZCZ20}.}
  \label{fig:roc_curve}
  \vspace{-0in}
\end{figure}

We prepared a test set with six attacks to compare the detection performances. The reader is referred to \autoref{subesc:explanation} for further information regarding the attacks. \autoref{fig:roc_curve} depicts five receiver operating characteristic (ROC) curves, each of which was rendered while adjusting the detection threshold $\Theta$. Curves 1 and 2 represent the detection performances of X-CANIDS and CANnolo, respectively. X-CANIDS was superior to CANnolo, with a 0.0722 gain in the area under the curve (AUC). Furthermore, we revised CANnolo by replacing the LSTM layers with BiLSTM layers as BiLSTM exhibits a smaller reconstruction error than LSTM (see \autoref{fig:trainloss}). A comparison of curves 2 and 3 reveals that the BiLSTM layer helped CANnolo to detect anomalies more accurately. However, X-CANIDS still performed better than the revised CANnolo. We conclude that the signals that were deserialized from the raw payloads were more helpful in detecting anomalies.

\subsection{Advantages of Using Driving Dataset and Signals}
The proposed method should be trained with a driving dataset rather than a stationary or simulated dataset to ensure high detection performance. We conducted further experiments with a stationary dataset to confirm the importance of using the driving dataset in the training phase. In \autoref{fig:roc_curve}, curve 4 indicates the performance of X-CANIDS when it was trained with $\mathcal{M}_7$. A comparison of curves 1 and 4 demonstrates that the use of the driving dataset significantly improved the detection performance. 

Moreover, we assume that it is necessary to train ${\bf AE}$ with raw payloads, owing to the lack of a CAN database. Curve 5 shows the detection performance under this assumption. A comparison of curves 4 and 5 confirms that the signals aided in achieving better detection performance.


\subsection{Feasibility Consideration}
It is necessary to ensure that no bottleneck occurs owing to the computation time. The computation time is dependent on the complexity of the method and the computational power that is provided by an in-vehicle component. We selected an NVIDIA Jetson AGX Xavier, which is an automotive-grade embedded device equipped with a GPU and CAN shield, to investigate the feasibility. This device is plausible because it is used in automotive applications in the vehicle industry. We implemented X-CANIDS on the device. The device could monitor the CAN bus in the vehicle using the CAN shield. The GPU allowed us to compute $f(\cdot)$ concurrently with a small batch of features. Owing to the device supporting TensorFlow natively, we could port the pretrained weights of $f(\cdot)$ from our PC. 

We measured the throughput as the inference time per input. The throughput must be shorter than the feature-creation interval $t$, which was 10 ms in our study. We determined the throughput using
\begin{equation}
  \text{Throughput}=t_\alpha + \frac{t_\beta}{\text{batch size}}
\end{equation}
where $t_\alpha$ is the process time of the feature generation and $t_\beta$ is the computation time of $f(\cdot)$ (i.e., \cref{eq:detection_function}). 

The device required $t_\alpha=5.1$~ms per input. The $t_\beta$ values are listed in \autoref{table:inference_time_gpu}. When we selected a batch size of 16, the throughput was $8.06~(=5.1 + 2.96)$ ms, which was shorter than $t$. Thus, we can conclude that the proposed IDS is feasible when the batch size is 16 or larger.

\begin{table}[t]
  \caption{Inference time on NVIDIA Jetson AGX Xavier.}
  \centering
  \label{table:inference_time_gpu}
  \begin{tabular}{rrr}
  \hline
  Batch size & Time (ms/batch), $t_\beta$ & Time (ms/sample) \\\hline
4    & 48.61   & 12.15 \\
8    & 48.21   & 6.03  \\
16   & 47.30   & 2.96  \\
32   & 47.21   & 1.48  \\
64   & 70.24   & 1.10  \\
128  & 110.39  & 0.86  \\
256  & 195.82  & 0.76  \\
512  & 357.70  & 0.70  \\
1,024 & 682.29  & 0.67  \\
2,048 & 1604.17 & 0.78  \\
4,096 & 4854.17 & 1.19  \\\hline
  \end{tabular}
  \end{table}

The detection latency is the time gap between the attack and alert. When a batch size of 16 was selected, the detection latency was derived as follows:
\begin{equation}
  \begin{aligned}
  &\text{Detection latency} = zt + t_\alpha + t_\beta
  \\&= z\cdot10\text{~ms} + 5.1 \text{~ms} + 47.30\text{~ms}
  \\&= \begin{cases}
    \phantom{0}
      52.4 \text{~ms}, & \text{if $z=0$, the batch is full on arrival.}\\
      202.4 \text{~ms}, & \text{if $z=15$, the batch is empty.}\\
    \end{cases}
  \end{aligned}
\end{equation}
In the above, $z\in\{0..(\text{batch size}-1)\}$ is the number of inputs that are required to complete a batch; thus, $zt$ represents the batch completion time. We conclude that X-CANIDS provides an intrusion alert with a deterministic latency of no greater than 202.4 ms.

\subsection{Explanation of Detection Results}
\label{subesc:explanation}
\begin{figure*}[!t]
\centering
\includegraphics[width=\linewidth]{figure/explanation-eps-converted-to.pdf}
\caption{Error rates over test dataset $\mathcal{M}_6$. The error rates are depicted as $4{\cdot}10^1=\Theta \le$ blue $\le 10^2 \le$ green $\le 10^3 \le$ red $\le 10^4+$. We conducted attacks in six periods. In attack period 1, the error rates were exceeded on many signals owing to intensive fuzzing. In attack periods 2--6, we could distinguish the exact target signals showing a maximum error rate at a certain time. The reader is referred to the color version of this page for interpretation of the figure.
}
\label{fig:signal_prediction}
\end{figure*}

In this section, we discuss the explainability of our proposed framework. A heatmap that plots the error rates of the 107 signals over time is presented in \autoref{fig:signal_prediction}. We conducted six attacks on our test set and measured their error rates. The figure shows only the error rates that exceeded the detection threshold $\Theta=40$. That is, the marked points in the figure represent the predicted intrusions. The attack period and description are indicated at the top of the heatmap. The moving average of the detection accuracy is also provided.

\subsubsection{Period 1---Fuzzing} An intensive fuzzing attack was conducted during 480--720 s and the error rate exceeded the detection threshold for almost all signals. The $\rm{argmax}({\bf r})$ function continuously pointed out signal 5B0\_CF\_Clu\_Odometer. Nevertheless, an expert who is responsible for forensics would be able identify the type of attack as fuzzing because of the multiple simultaneous errors. Unfortunately, during this period, the proposed framework did not work for the following signals: 081\_BRAKE\_ACT, 112\_VS\_TCU\_DECIMAL, 329\_BRAKE\_ACT, and 4F1\_CF\_Clu\_VanzDecimal.

\subsubsection{Period 2---Fabrication} We considered an adversary who attempts to fabricate a portion of the payloads for signal 556\_PID\_0Ch during 840--960 s. The signal is part of the OBD-II freeze frame containing the parameter ID 0Ch. That is, the signal represents the current engine RPM~\cite{obd_ii_pids}. The experimental results showed that 556\_PID\_0Ch reached the highest error rate of $\approx 10^4$ during this period. Three signals representing the RPM, namely 080\_N, 162\_Cluster\_Driving\_RPM, and 316\_N, also exhibited high error rates.

\subsubsection{Period 3---Fabrication} An adversary who injects CAN messages with AID = 162h was assumed during 1080--1200 s. The accuracy decreased owing to several false negatives at the beginning of the period. Shortly thereafter, three signals belonging to the AID exhibited high error rates. In particular, $\rm{argmax}({\bf r})$ successfully pointed out signal 162\_Cluster\_Enging\_RPM.

\subsubsection{Period 4---Masquerade} We considered an adversary who attempts to report a fraudulent current velocity to the driver via an instrumental cluster. For this purpose, we simulated a masquerade attack that changes signal 316\_VS during 1320--1440 s. As shown in the figure, the signal exhibited the highest error rate. Furthermore, other speed-related signals exhibited high error rates simultaneously, including the four wheel speed signals that are defined in stream 386h. 

\subsubsection{Period 5---Suspension} We performed a suspension attack for stream 556h during 1560--1680 s. As demonstrated in \autoref{table:injection_detection}, the proposed method is ineffective against suspension attacks. The figure also confirms this weakness. We observed that the detection accuracy increased and decreased during this period. The proposed framework identified anomalies in signal 556\_PID\_0Dh, which represents the current velocity (see the description of parameter ID 0Dh in \cite{obd_ii_pids}). The error rate of the signal exceeded the detection threshold when the vehicle velocity differed from 68 km/h (cf., the red-filled area in the velocity chart and change in the moving accuracy.

\subsubsection{Period 6---Fabrication} Finally, motivated by previous works~\cite{ShahriarXMLH22, VermaIBHMKC22}, we considered a max coolant temperature attack. In our dataset, signal 329\_TEMP\_ENG deals with the engine coolant temperature. Thus, we conducted a fabrication attack on the signal. It can be observed that $\rm{argmax}({\bf r})$ successfully pointed out the signal during this period.

\subsubsection{Understanding false positives} We could diagnose false positive cases by leveraging the explainability. We could observe false positives in four signals relevant to stream 593h (TPMS) during 30--120 s. We manually confirmed that the false positives were caused by uninitialized values, which were initialized when the TPMS module started to report the tire pressures. Once the signals were filled with valid values, they no longer caused false positives.

\section{Related Works}
\label{sec:related_work}

\begin{table}[t]
\caption{Previous work that proposed in-vehicle IDSs for CAN buses.}
\label{table:related_work}
\setlength{\tabcolsep}{4pt} % default: 6pt
\centering
\begin{tabular}{lcccclr}
\hline
Research & \rot{Timestamp} & \rot{AID sequence} & \rot{Payload} & \rot{Signal} & Output & \rot{Inference time~~} \\ \hline
Müter and Asaj~\cite{MuterA11} & \checkmark &  & \checkmark &  & Binary & --- \\
Kang and Kang~\cite{KangK16} &  &  & \checkmark &  & Binary & 2--5 ms$^\dagger$ \\
Marchetti and Stabili~\cite{MarchettiS17} &  & \checkmark &  &  & Binary & --- \\
Taylor \textit{et al.}~\cite{TaylorJL15} & \checkmark &  & \checkmark &  & Binary & --- \\
Song \textit{et al.}~\cite{SongKK16} & \checkmark &  &  &  & Binary & 1 ms$^\dagger$ \\
Taylor \textit{et al.}~\cite{TaylorLJ16} &  &  & \checkmark &  & Binary & --- \\
Marchetti \textit{et al.}~\cite{MarchettiSGC16} & \checkmark &  &  &  & Binary & --- \\
Stabili \textit{et al.}~\cite{StabiliMC17} &  &  & \checkmark &  & Binary & --- \\
Markovitz and Wool~\cite{MarkovitzW17} &  &  &  & \checkmark & Binary & --- \\
Wasicek \textit{et al.}~\cite{WasicekPWBS17} &  &  &  & \checkmark & Real number & --- \\
Tomlinson \textit{et al.}~\cite{TomlinsonBSK18} & \checkmark &  &  &  & Binary & --- \\
Olufowobi \textit{et al.}~\cite{OlufowobiYZB19} & \checkmark &  &  &  & Binary & 9--10 ms$^\dagger$ \\
Young \textit{et al.}~\cite{YoungOBZ19} & \checkmark &  &  &  & Binary & --- \\
Katragadda \textit{et al.}~\cite{KatragaddaDRG20} &  & \checkmark &  &  & Binary & 151 ms$^\ddagger$ \\
Song \textit{et al.}~\cite{SongWK20} &  & \checkmark &  &  & Binary & 5--6.7 ms$^\dagger$ \\
Longari \textit{et al.}~\cite{LongariVZCZ20} &  &  & \checkmark &  & Binary & --- \\
Hossain \textit{et al.}~\cite{HossainIOFK20} &  & \checkmark & \checkmark &  & Category & --- \\
Tariq \textit{et al.}~\cite{TariqLKW20} & \checkmark & \checkmark & \checkmark &  & Category & 14--73 ms$^\dagger$ \\
Song and Kim~\cite{SongKim21} &  & \checkmark &  &  & Binary & --- \\
Shahriar \textit{et al.}~\cite{ShahriarXMLH22} &  &  &  & \checkmark & Real number & --- \\
Hoang and Kim~\cite{HoangK22} &  & \checkmark &  &  & Binary & 0.63 ms$^\dagger$ \\
X-CANIDS (this work) &  &  &  & \checkmark & Real number & 8.06 ms$^{\ddagger}_*$ \\ \hline
\end{tabular}
\\[.075in]
\begin{minipage}[t]{\linewidth}
$^\dagger$per CAN message \hspace{.075in} $^\ddagger$per feature \hspace{.075in} $^*$measured on an embedded device
\end{minipage}
\vspace{-0in}
\end{table}

In this section, related works on in-vehicle IDSs for CAN buses are reviewed. \autoref{table:related_work} lists 21 previous studies, with the input type used to detect the intrusion, output type, and inference time presented in the respective paper. In many cases, an IDS returns a binary for each input to indicate whether the vehicle is attacked. Meanwhile, two studies~\cite{HossainIOFK20, TariqLKW20} proposed IDSs that return a categorical value. This category refers to the type of attack. These IDSs require labeled training sets to recognize the attack type. Two signal-aware IDSs (\cite{WasicekPWBS17, ShahriarXMLH22}) return a real number that can be used as the detection result and confidence score.

The primary goal of an in-vehicle IDS is to detect anomalies effectively. Moreover, an IDS should be implemented on an ECU or embedded device that provides limited computational power. Therefore, IDSs should be tested on these devices to confirm their feasibility. In particular, the inference time should be compared with the feature-creation frequency. However, excluding this work, only seven studies measured the inference time. Moreover, none of the studies mentioned that the inference time was measured using an embedded device.

An in-vehicle IDS assesses the in-vehicle traffic using the timestamp, AID sequence, payload, and/or signal. In the remainder of this section, we categorize the related studies according to the input type.

\subsection{Time Interval-Based IDS}
A timestamp is not an officially supported field in the CAN frame. Nevertheless, an ECU can measure the relative time of the transmission itself because every ECU that shares the same medium is time synchronized bit by bit. ECUs tend to report their status periodically. Time-interval-based IDSs exploit these mechanisms. The measurement of timestamps is an efficient means of detecting anomalies. This also enables the detected intrusions to be understood. In contrast, a time-interval-based IDS does not work for the sporadic transmission of CAN messages.

Most early studies leveraged the periodic transmission mechanism. For example, in 2011, Müter and Asaj~\cite{MuterA11} explored the applicability of the entropy-based anomaly detection method. The proposed method takes advantage of the periodicity of IVN traffic. They measured the normal probability distribution of attack-free CAN data and compared it with that of abnormal CAN data. However, the study lacked an explicit threshold determination method or evaluation result, such as the detection accuracy. In 2016, Song \textit{et al.}~\cite{SongKK16} proposed a rule-based intrusion detection method that measures the time interval of two adjacent CAN messages. When the time interval of a new CAN message is shorter than the threshold, the proposed IDS considers the message as an intrusion. The experimental results demonstrated high detection performance with handcrafted thresholds. However, the method for determining the threshold remains to be improved. Marchetti \textit{et al.}~\cite{MarchettiSGC16} proposed an entropy-based anomaly detector for CAN buses. Tomlinson \textit{et al.}~\cite{TomlinsonBSK18} adopted the ARIMA model and Z-score to identify CAN message timing anomalies in a time window. Olufowobi \textit{et al.}~\cite{OlufowobiYZB19} proposed an intrusion detection method known as SAIDuCANT, which leverages the periodic message behavior in the CAN bus. Young \textit{et al.}~\cite{YoungOBZ19} adopted  fast Fourier transform to measure CAN message update frequency in a stream.


\subsection{Sequence-Based IDSs}
Sequence prediction is a well-known machine-learning problem. A sequence predictor predicts the next symbol based on previously observed categorical data. A sequence of AIDs can be used as sequence predictors to model the attack-free state of IVNs for in-vehicle traffic monitoring. Sequence-based IDSs can be used in all types of CAN-based IVNs because it is easy to compile AID sequences. However, these methods exhibit several drawbacks. Particularly, it is difficult to understand why a given sequence is classified as abnormal. Moreover, an adversary may falsify a legitimate sequence by conducting an intensive replay attack.

Marchetti and Stabili~\cite{MarchettiS17} compiled a transition matrix to represent the recurring patterns of two adjacent AIDs. The transition matrix is used to evaluate the CAN bus stream in the inference phase. Katragadda \textit{et al.}~\cite{KatragaddaDRG20} proposed a message sequence-based anomaly detection method that builds a frequent sequence tree, where each node represents a subsequence and each edge measures an observation count. 
The sequence length should be carefully selected because detection performance and feasibility are dependent thereon. Tariq \textit{et al.}~\cite{TariqLKW20} combined the benefits of rule-based models and neural networks. They claimed that their heuristic model works for known attack signatures, whereas neural networks can cope with unknown attacks. This is the only work that simultaneously examined the timestamp, payload, and AID sequences. Indeed, their method requires a substantially longer inference time than those of other approaches. Song \textit{et al.}~\cite{SongWK20} proposed a CNN that is a variation of Inception-ResNet to examine AID sequences. Their detection model outperformed conventional detection methods. However, a limitation of the proposed method is that it requires a labeled dataset to train the model. To overcome this drawback, they proposed another training method~\cite{SongKim21} to train their CNN model in an unsupervised manner. Hoang and Kim~\cite{HoangK22} proposed an adversarial autoencoder that attempts to reconstruct $29\times29$-sized features, which represent 29 continuous AIDs in bits.

\subsection{Payload-Based IDSs}
Payload-based IDSs evaluate the payloads in CAN messages, where each payload is represented as bit sequences. The training set needs to be carefully prepared to use payload-based IDSs in real-world scenarios; otherwise, the payload dynamics could cause false alarms. 

Taylor \textit{et al.}~\cite{TaylorJL15} measured the number of packets and average Hamming distance of the CAN message payloads in a sliding window. The statistical features that were derived from these two values were used to train a one-class support vector machine. Their experimental results were dependent on the window size for feature generation. Unfortunately, the unsupervised method exhibited a considerable false positive rate with the incorrect window size. Kang and Kang~\cite{KangK16} proposed a binary intrusion detection method based on a fully connected neural network, which uses 64-dimensional bit sequences (i.e., a payload of CAN messages) and then returns a logistic value of 0 or 1. They used a packet generator known as OCTANE to evaluate the proposed method. Despite the high performance of the experimental results, this work exhibits two limitations: (1) the method was evaluated using only three streams and (2) the simulated payloads that were used in the experiment may not reflect real-world situations. Taylor \textit{et al.}~\cite{TaylorLJ16} proposed an intrusion detector that consists of LSTM-based models for each stream. Each model uses a $20\times64$-sized matrix that comprises 20 subsequences of CAN payloads in the bit representation. Subsequently, the model predicts the next payload of a stream. They considered five loss metrics to measure the anomaly score. Stabili \textit{et al.}~\cite{StabiliMC17} measured the Hamming distance for each stream. They classified each stream into the no distance, small distance, and mid-distance ranges. When a stream exceeds a given distance range in the inference phase, it is classified as an anomaly. However, the method was evaluated using only fuzzing attacks. Hossain \textit{et al.}~\cite{HossainIOFK20} developed a supervised IDS using an LSTM model that considers the raw payloads of a CAN message. Longari \textit{et al.}~\cite{LongariVZCZ20} deployed an anomaly detection system based on LSTM autoencoders. They implemented an LSTM model for each stream to reconstruct a time-series bit sequence of payloads.

\subsection{Signal-Aware IDSs}
A signal is the only feature that enables an IDS to understand the current state of a vehicle. The three methods that are used to obtain signals are as follows:

\BfPara{Reverse engineering} One study \cite{MarkovitzW17} attempted payload slicing in a heuristic manner to detect intrusions more effectively. Several studies have focused on the automatic reverse engineering of payloads~\cite{VermaBSHI21, YoungSZ20, PeseSCNCS19, KangSJK18, VermaBH18, HuybrechtsVBBH17, MarkovitzW17}. 

\BfPara{OBD-II queries} The service mode \texttt{01h} that is defined in the OBD-II standard SAE J1979 enables powertrain-relevant signals~\cite{obd_ii_pids} to be obtained in a standardized manner. This is the most promising operational method in many vehicles. However, an IDS must transmit OBD-II queries, which may affect the nature of the IVN traffic. 

\BfPara{CAN database} Refer to \autoref{subsec:can_database} for further information.

To the best of our knowledge, Markovitz and Wool~\cite{MarkovitzW17} were the first to use portions of the payload in CAN messages to detect intrusions, as opposed to using an entire payload. They divided a 64-bit payload into several fields, each of which was assigned as a constant, categorical, counter, or sensor type. A rule-based detection algorithm was considered for each data type. Wasicek \textit{et al.}~\cite{WasicekPWBS17} proposed an IDS that uses 54 types of signals that are obtained via OBD-II PIDs. They reported that a fully connected network with a bottleneck can be used to measure the anomaly score (i.e., the reconstruction error). In 2022, Shahriar \textit{et al.}~\cite{ShahriarXMLH22} proposed a signal-aware IDS known as CANShield. A 2D CNN was designed to reconstruct the signals that were deserialized from raw payloads. They used CAN-D~\cite{VermaBSHI21}, which is an automatic dissector for CAN traffic, to obtain these signals. A limitation of this method is that CANShield is designed to keep track of several preselected signals, which means that their IDS cannot protect the remaining signals that are available in a vehicle.

\section{Discussion and Conclusions}
\label{sec:conclusion}
In this study, we have proposed X-CANIDS, in which the feature generator is designed to process live streams and create a time-series representation of the signals. A CAN database is combined with X-CANIDS to deserialize the signals from the CAN message payloads. We tested six types of autoencoders. The LSTM layer has often been considered in the literature \cite{TaylorLJ16, TariqLKW20, HossainIOFK20, LongariVZCZ20}. A Conv2D-based autoencoder has also been employed to model signals~\cite{ShahriarXMLH22}. However, we demonstrated that the BiLSTM-based autoencoder outperformed the LSTM and 2D-CNN autoencoders. In summary, the experimental results suggest that X-CANIDS detects zero-day intrusions that are not observed during the training phase. In particular, the proposed method offers an advantage for masquerade attacks that cannot be detected by time-interval- or sequence-based IDSs.

Cybersecurity regulations, including UNR 155, enforce the installation of an IDS inside vehicles and the analysis of cyberattacks. Therefore, the feasibility and explainability of in-vehicle IDSs are important for vehicle industries. We tested X-CANIDS on an embedded device to confirm its feasibility. Furthermore, we empirically demonstrated its explainability. We claim that carmakers can use X-CANIDS because they can access CAN databases for their vehicles.

This study exhibits two limitations. First, we used only one vehicle to evaluate X-CANIDS. We found it difficult to arrange another car owing to the lack of a CAN database. We encourage carmakers to share their CAN databases with academia for research purposes. Otherwise, providing an application programming interface that allows researchers to obtain signals can be an alternative solution. Second, X-CANIDS is insufficient for detecting suspension attacks that can be detected by time-interval- or sequence-based IDSs. To this end, our future work will expand the proposed method to examine time-interval-based features along with signal features.

\bibliographystyle{IEEEtran}
\bibliography{bibliography.bib}
\vspace{-.5in}
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bib_jeong.jpg}}]{Seonghoon Jeong}
received a Ph.D. degree in information security from Korea University, Seoul, Republic of Korea.
He is currently a Postdoctoral Researcher at the School of Cybersecurity, Korea University, Korea. His current research involves in-vehicle network security, including intrusion detection systems for Controller Area Networks and automotive Ethernet.
\end{IEEEbiography}
\vspace{-.5in}
\begin{IEEEbiography}[{\includegraphics[width=1in, height=1.25in, clip, keepaspectratio]{bib_sangho.jpg}}]{Sangho Lee}
received a B.S. degree in electronic engineering from Soongsil University, Republic of Korea, in 2018. He is currently pursuing an M.S. degree at the School of Cybersecurity, Korea University. He has been a Security Engineer at Samsung Research, Samsung Electronics, since 2018. His research interests include data-driven security, user behavior analysis, and privacy.
\end{IEEEbiography}
\vspace{-.5in}
\begin{IEEEbiography}[{\includegraphics[width=1in, height=1.25in, clip, keepaspectratio]{bib_hwejae.jpg}}]{Hwejae Lee}
received a B.S. degree in mechanical engineering from Kyung Hee University in 2020 and is a Ph.D. student in information security at the School of Cybersecurity, Korea University, Seoul, Republic of Korea. His research interests include vehicle security, data-driven security, intrusion detection, machine learning, and deep learning.
\end{IEEEbiography}
\vspace{-.5in}
\begin{IEEEbiography}[{\includegraphics[width=1in, height=1.25in, clip, keepaspectratio]{bib_kim.jpg}}]{Huy Kang Kim}
received a Ph.D. degree in industrial and system engineering from the Korea Advanced Institute of Science and Technology (KAIST), Republic of Korea. He founded A3 Security Consulting in 1999 and AI Spera, which is a data-driven cyber threat intelligence service company, in 2017. He is currently a Professor at the School of Cybersecurity, Korea University, Korea. His recent research has focused on anomaly detection in intelligent transportation systems, online gaming, and internet banking using data analytics and machine-learning techniques.
\end{IEEEbiography}
\end{document}

%\begin{figure}[!t]
%\centering
%\includegraphics[width=\linewidth]{example-image-a}
%\caption{Simulation results for the network.}
%\label{fig:__MODITY__}
%\end{figure}
%
%\begin{table}[!t]
%\caption{An Example of a Table}
%\label{table:__MODIFY__}
%\centering
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{table}
%\end{tabular}
