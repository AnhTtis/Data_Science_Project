\section{Background}
Instrumentation, the process of transparently adding functionality to a program, is often used in dynamic program analyses. For instance, to capture the runtime properties of a program. Instrumentation in Java often uses bytecode manipulation, facilitated by the availability of bytecode engineering libraries like \textit{asm} and \textit{javassist}. In addition, the Java Virtual Machine (JVM) supports instrumentation directly through agents, which can be deployed statically (via a JVM argument) or attached dynamically.

Instrumentation can cause interference in the behaviour of a program. By interference, we mean that execution is affected by the instrumentation of the program's code. Unavoidably, instrumentation does interfere with available resources as additional instructions use CPU/memory. Some cases of interference include: race conditions caused by timing issues introduced by instrumentation  \cite{ivankoviFSE2019}; instrumentation interfering with shared resources; classpath issues where the agent uses a different version of classes that are also part of the classpath of the program and its tests\footnote{In practice, those issues are often avoided by using dependency shading when building agents}.%\todo[]{need a ref for the footnote.}. no appropriate ref for this

Interference caused by instrumentation can change the outcome of tests, resulting in test flakiness. We use the following definition of test flakiness here: \textit{tests having different results on multiple executions for the same version of program code; or transitions of test outcomes for the same test across runs}. Here is an example that illustrates flakiness introduced by telemetry instrumentation from MockServer\footnote{\url{https://www.mock-server.com/}}. MockServer features functionality to mock HTTP/HTTPS, REST or RPC services for testing purposes. The test runs MockServer as a JUnit 5 extension, configured with the annotation \texttt{@MockServerSettings} to use port 8888 for the mocked service. The same port is used by the OpenTelemetry\footnote{\url{https://opentelemetry.io/}} APM collector service. When the test is executed with OpenTelemetry instrumentation, it fails with the exception that the port is already in use. A dependency on local network resources causes this flakiness.

\begin{lstlisting}[
    basicstyle=\ttfamily \scriptsize]
@ExtendWith({
    MockServerExtension.class,
    TestLoggerExtension.class,
})
@MockServerSettings(ports = {8787, 8888})
class MockServerExtensionConstructorInjectionWithSettings ...
\end{lstlisting}

%MockServerExtensionConstructorInjectionWithSettingsMultiplePortTest
