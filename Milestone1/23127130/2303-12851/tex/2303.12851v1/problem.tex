\section{The Semi-Oblivious Chase Procedure}\label{sec:semi}
%

The semi-oblivious chase (or simply chase) takes as input a database $D$ and a set $\dep$ of TGDs, and constructs an instance that contains $D$ and satisfies $\dep$.
%
A central notion in this context is that of trigger.
%are those of trigger, active trigger, and trigger application.

\begin{definition}%[\textbf{Trigger Application}]
	Given a set $\dep$ of TGDs and an instance $I$, a {\em trigger} for $\dep$  on $I$ is a pair $(\sigma,h)$, where $\sigma \in \dep$ and $h$ is a homomorphism from $\body{\sigma}$ to $I$.
	%
	The {\em result} of $(\sigma,h)$, denoted $\result{\sigma}{h}$, is the set $\mu(\head{\sigma})$, where $\mu : \var{\head{\sigma}} \ra \ins{C} \cup \ins{N}$ is defined as follows:
	%
	%$\mu(x) = h(x)$ if $x \in \fr{\sigma}$, and $\mu(x) = \bot_{\sigma,h_{|\fr{\sigma}}}^{x}$ otherwise,
	\[
	\mu(x)\
	=\ \left\{
	\begin{array}{ll}
	h(x) & \quad \text{if } x \in \fr{\sigma}\\
	&\\
	\bot_{\sigma,h_{|\fr{\sigma}}}^{x} & \quad \text{otherwise}
	\end{array} \right.
	\]
	where $\bot_{\sigma,h_{|\fr{\sigma}}}^{x} \in \ins{N}$.  Let $T(\dep,I)$ be the set of triggers for $\dep$ on $I$.	\hfill\markfull
\end{definition}




Observe that in the definition of $\result{\sigma}{h}$, each existentially quantified variable $x$ of $\head{\sigma}$ is mapped by $\mu$ to a null value of $\ins{N}$ whose name is uniquely determined by the trigger $(\sigma,h)$ and the variable $x$ itself. This means that, given a trigger $(\sigma,h)$, we can unambiguously construct the set of atoms $\result{\sigma}{h}$.
%
The central idea of the chase is, starting from a database $D$, to exhaustively apply triggers for the given set $\dep$ of TGDs on the instance constructed so far.
%
More precisely, given a database $D$ and a set $\dep$ of TGDs, let
\[
\mathsf{chase}^{0}(D,\dep)\ =\ D,
\]
and for each $i>0$, let
\[
\mathsf{chase}^{i}(D,\dep)\ =\ \mathsf{chase}^{i-1}(D,\dep)\ \cup\ \bigcup_{(\sigma,h) \in S} \result{\sigma}{h},
\]
where $S = T(\dep,\mathsf{chase}^{i-1}(D,\dep))$. 
%
We finally define {\em the result of the chase of $D$ w.r.t.~$\dep$} as the (possibly infinite) instance
\[
\chase{D}{\dep}\ =\ \bigcup_{i \geq 0} \mathsf{chase}^{i}(D,\dep).
\]


\ignore{
The semi-oblivious chase procedure (or simply chase) takes as input a database $D$ and a set $\dep$ of TGDs, and constructs an instance that contains $D$ and satisfies $\dep$.
%
Central notions in this context are those of trigger, active trigger, and trigger application.

\begin{definition}%[\textbf{Trigger Application}]
	Given a set $\dep$ of TGDs and an instance $I$, a {\em trigger} for $\dep$  on $I$ is a pair $(\sigma,h)$, where $\sigma \in \dep$ and $h$ is a homomorphism from $\body{\sigma}$ to $I$.
	%
	The {\em result} of $(\sigma,h)$, denoted $\result{\sigma}{h}$, is the set $\mu(\head{\sigma})$, where $\mu : \var{\head{\sigma}} \ra \ins{C} \cup \ins{N}$ is defined as follows:
	%
	%$\mu(x) = h(x)$ if $x \in \fr{\sigma}$, and $\mu(x) = \bot_{\sigma,h_{|\fr{\sigma}}}^{x}$ otherwise,
	\[
	\mu(x)\
	=\ \left\{
	\begin{array}{ll}
	h(x) & \quad \text{if } x \in \fr{\sigma}\\
	&\\
	\bot_{\sigma,h_{|\fr{\sigma}}}^{x} & \quad \text{otherwise}
	\end{array} \right.
	\]
	where $\bot_{\sigma,h_{|\fr{\sigma}}}^{x}$ is a null value from $\ins{N}$.
	%
	The trigger $(\sigma,h)$ is {\em active} if $\result{\sigma}{h} \not\subseteq I$.
	%
	The {\em application} of $(\sigma,h)$ to $I$ returns the instance $J = I \cup \result{\sigma}{h}$ and is denoted as $I \app{\sigma}{h} J$.
	\hfill\markfull
\end{definition}


Observe that in the definition of $\result{\sigma}{h}$ above, each existentially quantified variable $x$ of $\head{\sigma}$ is mapped by $\mu$ to a null value of $\ins{N}$ whose name is uniquely determined by the trigger $(\sigma,h)$ and the variable $x$ itself. This means that, given a trigger $(\sigma,h)$, we can unambiguously extract the set of atoms 
$\result{\sigma}{h}$.



%\medskip

%\noindent
%\textbf{Semi-Oblivious Chase.}
The central idea of the chase is, starting from a database $D$, to exhaustively apply active triggers for the given set $\dep$ of TGDs on the instance constructed so far. This is formalized via the notion of (semi-oblivious) chase derivation, which can be finite or infinite.


\begin{definition}
	Consider a database $D$ and a set $\dep$ of TGDs.
	%We consider the two cases where a derivation is finite or infinite:
	\begin{itemize}
		\item A finite sequence $(I_i)_{0 \leq i \leq n}$ of instances, with $D = I_0$ and $n \geq 0$, is a {\em chase derivation} of $D$ w.r.t.~$\dep$ if, for each $i \in \{0,\ldots,n-1\}$, there is an active trigger $(\sigma,h)$ for $\dep$ on $I_i$ with $I_i \app{\sigma}{h} I_{i+1}$, and there is no active trigger for $\dep$ on $I_n$. The {\em result} of such a chase derivation is the instance $I_n$.
		
		
		\item An infinite sequence $(I_i)_{i \geq 0}$ of instances, with $D = I_0$, is a {\em chase derivation} of $D$ w.r.t.~$\dep$ if, for each $i \geq 0$, there is an active trigger $(\sigma,h)$ for $\dep$ on $I_i$ such that $I_i \app{\sigma}{h} I_{i+1}$. Moreover, $(I_i)_{i \geq 0}$ is {\em fair} if, for each $i \geq 0$, and for every active trigger $(\sigma,h)$ for $\dep$ on $I_i$, there exists $j > i$ such that $(\sigma,h)$ is not an active trigger for $\dep$ on $I_j$. 
		%The latter is known as the {\em fairness condition}, and guarantees that all the active triggers will be deactivated. %
		The {\em result} of such a chase derivation is the instance $\bigcup_{i \geq 0} \, I_i$.
	\end{itemize}
	%
	%The {\em result} of a chase derivation is defined as the union of all the instances occurring in it. 
	A chase derivation is {\em valid} if it is finite or infinite and fair.  \hfill\markfull
\end{definition}


Let us stress that infinite but unfair chase derivations are not considered as valid ones since they do not serve the main purpose of the chase, that is, to build an instance that satisfies the given set of TGDs. Indeed, given the set $\dep$ consisting of the TGDs
\[
\sigma\ =\ R(x,y) \ra \exists z \, R(y,z) \qquad \sigma'\ =\ R(x,y) \ra P(x,y),
\]
the result of the unfair chase derivation of $D = \{R(a,b)\}$ w.r.t.~$\dep$ that involves only triggers of the form $(\sigma,\cdot)$, i.e., only the TGD $\sigma$ is used, does not satisfy $\sigma'$, and thus, it does not satisfy $\dep$.
%
Interestingly, for every database $D$ and set $\dep$ of TGDs, any two valid chase derivations of $D$ w.r.t.~$\dep$ have always the same result, which implies that all valid chase derivations are either finite or infinite~\cite{GrOn18}. Therefore, in the rest of the paper, we can safely refer to {\em the} result of the chase of $D$ w.r.t. $\dep$, which we will denote by $\chase{D}{\dep}$. 
}


%\subsection{Non-Uniform Chase Termination}\label{sec:problem}
%

\medskip

\noindent
\textbf{Chase Termination.}
The result of the chase may be infinite even for very simple settings: it is easy to see that for $D = \{R(a,b)\}$ and $\dep = \{R(x,y) \ra \exists z \, R(y,z)\}$, $\chase{D}{\dep}$ is infinite.
%; in particular, $\chase{D}{\dep} = \{R(a,b),R(b,\bot_1),R(\bot_1,\bot_2),R(\bot_2,\bot_3),\ldots\}$, where $\bot_1,\bot_2,\ldots$ are null values.
%
This leads to the following problem, parameterized by a class $\class{C}$ of TGDs such as $\class{SL}$ (the class of simple-linear TGDs) and $\class{L}$ (the class of linear TGDs):


\medskip

\begin{center}
	\fbox{
		\begin{tabular}{ll}
			%{\small PROBLEM} : & %$\mathsf{ChaseTermination}(\class{C})$
			%\\
			{\small INPUT} : & A database $D$ and a set $\dep$ of TGDs from $\class{C}$.
			\\
			{\small QUESTION} : &  Is the instance $\chase{D}{\dep}$ finite?
	\end{tabular}}
\end{center}

\medskip

\noindent This problem has been recently studied in~\cite{CaGP22} for the classes of simple-linear and linear TGDs. Interestingly, for both classes, the finiteness of the result of the chase has been syntactically characterized by exploiting the notion of non-uniform weak-acyclicity. 
%
We proceed to recall this acyclicity notion, and then present the characterizations established in~\cite{CaGP22}, which in turn lead to simple algorithms for checking the finiteness of the result of the chase.
%
Note that, for the sake of clarity, in the rest of the paper we assume TGDs with a non-empty frontier, i.e., we assume that there is at least one variable in a TGD $\sigma$ that occurs both in $\body{\sigma}$ and $\head{\sigma}$. This assumption can be made without loss of generality since, given a database $D$ and a set $\dep$ of TGDs, we can easily construct a set $\dep'$ of TGDs with a non-empty frontier by slightly modifying $\dep$ such that $\chase{D}{\dep}$ is finite iff $\chase{D}{\dep'}$ is finite.


\medskip

\noindent
\textbf{Non-Uniform Weak-Acyclicity.} Weak-acyclicity was introduced in~\cite{FKMP05} as the main formalism for data exchange purposes, which guarantees the finiteness of the result of the chase for {\em every} input database. Non-uniform weak-acyclicity is the database-dependent variant of weak-acyclicity introduced in~\cite{CaGP22}. We proceed to give the formal definitions.
%
We first need to recall the notion of the {\em dependency graph} of a set $\dep$ of TGDs, 
%which symbolically encodes how terms may propagate during the chase.
%The {\em dependency graph} of set $\dep$ of TGDs 
defined as a directed multigraph $\depg{\dep}=(N,E)$, where $N = \pos{\sch{\dep}}$ and $E$ contains {\em only} the following edges.
%
For each TGD $\sigma \in \dep$ with $\head{\sigma} = \{\alpha_1,\ldots,\alpha_k\}$, for each $x \in \frontier{\sigma}$, and for each position $\pi \in \posvar{\body{\sigma}}{x}$:
\begin{itemize}
	\item For each $i \in [k]$ and for each $\pi' \in \posvar{\alpha_i}{x}$, there exists a \emph{normal} edge $(\pi,\pi') \in E$.
	%
	\item For each existentially quantified variable $z$ in $\sigma$, $i \in [k]$, and $\pi' \in \posvar{\alpha_i}{z}$, there is a \emph{special} edge $(\pi,\pi') \in E$.
\end{itemize}
%
We further need to define when a predicate is reachable from another predicate. 
%
Given predicates $R,P \in \sch{\dep}$, {\em $P$ is reachable from $R$ (w.r.t.~$\dep$)} if $R = P$, or there exists a path in $\depg{\dep}$ from a position of the form $(R,i)$ to a position of the form $(P,j)$.
%
%we write $R \ra_\dep P$  if $R = P$, or there exists a TGD $\sigma \in \dep$ such that $R$ occurs in $\body{\sigma}$ and $P$ occurs in $\head{\sigma}$. We say that {\em $P$ is reachable from $R$ (w.r.t.~$\dep$)}, denoted $R \reach{\dep} P$, if (i) $R \ra_\dep P$, or (ii) there exists $T \in \sch{\dep}$ such that $R \reach{\dep} T$ and $T \ra_\dep P$.
%in $\depg{\dep}$, denoted $R \reach{\dep} P$, if there exists a path in $\depg{\dep}$ from a position $(R,i)$ to a position $(P,j)$, for some $i \in [\arity{R}]$ and $j \in [\arity{P}]$.
Given a database $D$, we say that a (not necessarily simple and possibly cyclic) path $C$ in $\depg{\dep}$ is \emph{$D$-supported} if there exists an atom $R(\bar t) \in D$ and a node of the form $(P,i)$ in $C$ such that $P$ is reachable from $R$.
%
We are now ready to recall (non-uniform) weak-acyclicity.



\begin{definition}\label{def:dwa}
	Consider a database $D$ and a set $\dep$ of TGDs. We say that $\dep$ is {\em weakly-acyclic w.r.t.~$D$}, or {\em $D$-weakly-acyclic}, if there is no $D$-supported cycle in $\depg{\dep}$ with a special edge. 
	%
	We say that $\dep$ is {\em weakly-acyclic} if there is no cycle in $\depg{\dep}$ with a special edge. \hfill\markfull
\end{definition}


\smallskip

\noindent
\textbf{Characterizing the Finiteness of the Chase.}
It is not very difficult to show that whenever a set $\dep$ of TGDs (not necessarily linear) is $D$-weakly-acyclic, then the instance $\chase{D}{\dep}$ is finite. In other words, the $D$-weak-acyclicity of $\dep$ is a sufficient condition for the finiteness of $\chase{D}{\dep}$. What is more interesting is that, assuming that $\dep$ is a set of simple-linear TGDs, the $D$-weak-acyclicity of $\dep$ is also a necessary condition for the finiteness of $\chase{D}{\dep}$. This leads to the following characterization established in~\cite{CaGP22}:

\begin{theorem}\label{the:characterization-simple-linear}
	Consider a database $D$ and a set $\dep \in \class{SL}$ of TGDs. It holds that $\chase{D}{\dep}$ is finite iff $\dep$ is $D$-weakly-acyclic.
\end{theorem}

For linear TGDs, it turned out that non-uniform weak-acyclicity is not powerful enough for characterizing the finiteness of the chase instance. Here is an example given in~\cite{CaGP22} that illustrates this fact:
%This is illustrated by the following example.


\begin{example}
	Consider the database $D = \{R(a,b)\}$ and the singleton set $\dep$ consisting of the (non-simple) linear TGD
	\[
	R(x,x)\ \ra\ \exists z \, R(z,x). 
	\]
	It is easy to see that there is no trigger for $\dep$ on $D$. This means that $\chase{D}{\dep} = D$ is finite, whereas $\dep$ is {\em not} $D$-weakly-acyclic. \hfill\markfull
\end{example}


To obtain a characterization analogous to Theorem~\ref{the:characterization-simple-linear}, the authors of~\cite{CaGP22} used the technique of {\em simplification} to convert linear TGDs into simple-linear TGDs, while preserving the finiteness of the chase instance. We proceed to recall this technique.
%
Let $\bar t = (t_1,\ldots,t_n)$ be a tuple of (not necessarily distinct) terms. We write $\unique{\bar t}$ for the tuple obtained from $\bar t$ by keeping only the first occurrence of each term in $\bar t$.
%
For example, if $\bar t = (x,y,x,z,y)$, then $\unique{\bar t} = (x,y,z)$.
%
For each $i \in [n]$, the \emph{identifier of $t_i$ in $\bar t$}, denoted $\id{\bar t}{t_i}$, is the integer that identifies the position of $\unique{\bar t}$ at which $t_i$ appears. 
%
We write $\id{}{\bar t}$ for the tuple $(\id{\bar t}{t_1},\ldots,\id{\bar t}{t_n})$.
%
For example, if $\bar t = (x,y,x,z,y)$, then $\id{}{\bar t} = (1,2,1,3,2)$.
%
For an atom $\alpha = R(\bar t)$, the {\em simplification of $\alpha$}, denoted $\simple{\alpha}$, is the atom $R_{\id{}{\bar t}}(\unique{\bar t})$, whereas the {\em shape of $\alpha$}, denoted $\shape{\alpha}$, is the predicate $R_{\id{}{\bar t}}$. We can naturally refer to the simplification and the shape of a set of atoms.
%
For a tuple of variables $\bar x = (x_1,\ldots,x_n)$, a \emph{specialization of $\bar x$} is a function $f$ from $\bar x$ to $\bar x$ such that $f(x_1) = x_1$, and $f(x_i) \in \{f(x_1),\ldots,f(x_{i-1}),x_i\}$, for each $i \in \{2,\ldots,n\}$.
We write $f(\bar x)$ for $(f(x_1),\ldots,f(x_n))$. We are now ready to recall how a set of linear TGDs is converted into a set of simple-linear TGDs.

\begin{definition}\label{def:simplification}
	Consider a linear TGD $\sigma$ of the form
	\[
	R(\bar x) \ra \exists \bar z\, \psi(\bar y,\bar z), 
	\]
	where $\bar y \subseteq \bar x$, and a specialization $f$ of $\bar x$. The {\em simplification of $\sigma$ induced by $f$} is the simple-linear TGD
	\[
	\simple{R(f(\bar x))} \rightarrow \exists \bar z\, \simple{\psi(f(\bar y),\bar z)}.
	\]
	We write $\simple{\sigma}$ for the set of all simplifications of $\sigma$ induced by some specialization of $\bar x$.
	%
	For a set $\dep \in \class{L}$ of TGDs, the {\em simplification of $\dep$} is defined as the set
	\[
	\simple{\dep}\ =\ \bigcup_{\sigma \in \dep} \simple{\sigma}
	\]
	consisting only of simple-linear TGDs. \hfill\markfull
\end{definition}

We can now recall the characterization for the finiteness of the chase instance for linear TGDs, established in~\cite{CaGP22}, which is similar to the one for simple-linear TGDs, with the key difference that first we need to simplify both the database and the set of linear TGDs:

\begin{theorem}\label{the:characterization-linear}
	Consider a database $D$ and a set $\dep \in \class{L}$ of TGDs. Then, $\chase{D}{\dep}$ is finite iff $\simple{\dep}$ is $\simple{D}$-weakly-acyclic.
\end{theorem}

It is clear that Theorems~\ref{the:characterization-simple-linear} and~\ref{the:characterization-linear} provide simple algorithms for checking whether the chase instance is finite. In particular, given a database $D$ and a set $\dep$ of simple-linear TGDs, we simply need to check whether $\dep$ is $D$-weakly-acyclic, in which case the algorithm returns \true; otherwise, it returns \false. The same holds when $\dep$ is a set of linear TGDs, with the difference that the algorithm first needs to simplify $D$ and $\dep$, and then perform the acyclicity check.
%
Our goal is to experimentally evaluate the above algorithms with the aim of understanding which input parameters affect their performance, clarifying whether they can be applied in a practical context, and revealing their performance limitations. Of course, a naive implementation of the above algorithms, especially for linear TGDs where the expensive simplification must be applied, will lead to poor performance, and thus, will not be very useful towards our goal. Hence, we need to somehow convert the above theoretical algorithms into practical algorithms that are amenable to efficient implementations. This is the subject of the next section.