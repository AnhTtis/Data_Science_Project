\section{Introduction}\label{sec:intro}
%


The \emph{chase procedure} (or simply chase) is a fundamental algorithmic tool that has been successfully applied to several database problems such as checking logical implication of constraints~\cite{BeVa84,MaMS79}, containment of queries under constraints~\cite{AhSU79}, computing data exchange solutions~\cite{FKMP05}, and ontological query answering~\cite{CaGL12}, to name a few.
%
The chase takes as input a database $D$ and a set $\dep$ of constraints, which, for this work, are \emph{existential rules} (a.k.a. {\em tuple-generating dependencies} (TGDs)) of the form	$\forall \bar x \forall \bar y \left(\phi(\bar x,\bar y) \ra \exists \bar z\, \psi(\bar x,\bar z)\right)$,
where $\phi$ (the body) and $\psi$ (the head) are conjunctions of relational atoms, and it produces an instance $D_\dep$ that is a {\em universal model} of $D$ and $\dep$, i.e., a model that can be homomorphically embedded into every other model of $D$ and $\dep$. Somehow $D_\dep$ acts as a representative of all the models of $D$ and $\dep$. This is the reason for the ubiquity of the chase in databases, as discussed in~\cite{DeNR08}. Indeed, many database problems can be solved by simply exhibiting a universal model.
%
%{\color{red} Despite the fact that the instance constructed by the chase can be very large, efficient implementations of the chase procedure have been successfully applied during the last few years in many different contexts [4, 19, 23, 24].}


\subsection{The Chase in a Nutshell}

Roughly, the chase adds new tuples to the database $D$ (possibly involving null values that act as witnesses for the existentially quantified variables), as dictated by the TGDs of $\dep$, and it keeps doing this until all the TGDs of $\dep$ are satisfied.
%
There are, in principle, three different ways for formalizing this simple idea, which lead to different versions of the chase procedure:

\medskip

\noindent
\textbf{Oblivious Chase.} The first one, which leads to the {\em oblivious chase}, is as follows: for each pair $(\bar t,\bar u)$ of tuples of terms from the instance $I$ constructed so far, apply a TGD $\sigma = \forall \bar x \forall \bar y \left(\phi(\bar x,\bar y) \ra \exists \bar z\, \psi(\bar x,\bar z)\right)$ if $\phi(\bar t,\bar u) \subseteq I$, and $\sigma$ has not been applied in a previous chase step due to the same pair $(\bar t,\bar u)$, and add to $I$ the set of atoms $\psi(\bar t,\bar v)$, where $\bar v$ is a tuple of new terms not occurring in $I$.

\medskip

\noindent
\textbf{Semi-Oblivious Chase.} The second one, which is a refinement of the oblivious chase, and it gives rise to the {\em semi-oblivious chase}, is as follows: for each pair $(\bar t,\bar u)$ of tuples of terms from the instance $I$ constructed so far, apply a TGD $\sigma = \forall \bar x \forall \bar y \left(\phi(\bar x,\bar y) \ra \exists \bar z\, \psi(\bar x,\bar z)\right)$ if $\phi(\bar t,\bar u) \subseteq I$, and $\sigma$ has not been applied in a previous chase step due to a pair of tuples $(\bar t,\bar u')$, where $\bar u$ and $\bar u'$ might be different, and add to $I$ the set of atoms $\psi(\bar t,\bar v)$, where $\bar v$ is a tuple of new terms not in $I$.
%
In other words, a TGD $\sigma$ of the above form is applied only once due to a certain witness $\bar t$ for the variables $\bar x$.

\medskip

\noindent
\textbf{Restricted Chase.} The third one, which leads to the {\em restricted} (a.k.a.~{\em standard}) {\em chase}, is as follows: for each pair $(\bar t,\bar u)$ of tuples of terms from the instance $I$ constructed so far, apply a TGD $\sigma = \forall \bar x \forall \bar y \left(\phi(\bar x,\bar y) \ra \exists \bar z\, \psi(\bar x,\bar z)\right)$ if $\phi(\bar t,\bar u) \subseteq I$, and there is no tuple $\bar u'$ of terms from $I$ such that $\psi(\bar t,\bar u') \subseteq I$, i.e., the TGD is not already satisfied, and add to $I$ the set of atoms $\psi(\bar t,\bar v)$, where $\bar v$ is a tuple of new terms not in $I$.

\medskip

Summing up, the key difference between the (semi-)oblivious and restricted versions of the chase procedure is that the former apply a TGD whenever the body is satisfied, while the latter applies a TGD if the body is satisfied but the head is not.
	
	
	
%\paragraph{Restricted vs. (Semi-)Oblivious Chase.}
\subsection{Restricted vs. (Semi-)Oblivious Chase.}
%
%Moreover, although the oblivious and the semi-oblivious versions of the chase are similar in spirit, i.e., unlike the restricted chase, they are insensible to the fact that a TGD is already satisfied, the latter is more efficient in the sense that it avoids some redundant applications.
	
	
It is not difficult to verify that the restricted chase, in general, builds smaller instances than the (semi-)oblivious one. In fact, it is easy to devise an example where, according to the restricted chase, none of the TGDs should be applied, while the (semi-)oblivious chase builds an infinite instance. Here is such an example taken from~\cite{CaPi21}:
	
\begin{example}
	Consider the database $D = \{R(a,a)\}$ and the TGD 
	\[
	\forall x \forall y (R(x,y)\ \ra\ \exists z\, R(z,x)).
	\] 
	The restricted chase will detect that the database already satisfies the TGD, while the (semi-)oblivious chase will build the instance
	\[
	\{R(a,a),R(\bot_1,a),R(\bot_2,\bot_1),R(\bot_3,\bot_2),\ldots\},
	\]
	where $\bot_1,\bot_2,\bot_3,\ldots$ are (labeled) nulls. \hfill\markfull
\end{example}
	
It is also easy to devise examples where the semi-oblivious chase does not apply any TGD, whereas the oblivious chase builds an infinite instance.
%
%Here is an example illustrating this fact taken from~\cite{CaPi21}:
%
\ignore{	
\begin{example}\label{exa:so-vs-o}
	Consider the database $D = \{R(a,a)\}$ and the TGD 
	\[
	\forall x \forall y (R(x,y)\ \ra\ \exists z\, R(x,z)), 
	\]
	The semi-oblivious chase will build the instance $\{R(a,a),R(a,\bot)\}$, where $\bot$ is a null, whereas the oblivious chase will build the instance 
	\[
	\{R(a,a),R(a,\bot_1),R(a,\bot_2),R(a,\bot_3),\ldots\},
	\]
	where $\bot_1,\bot_2,\bot_3,\ldots$ are nulls. \hfill\markfull
\end{example}
}
%
It is generally agreed that the oblivious version of the chase, although a very useful theoretical tool, has no practical applications due to the fact that it infers a lot of redundant information, which in turn leads to very large instances that are very often infinite. 
%
Concerning the other variants of the chase, the restricted one has a clear advantage over the semi-oblivious one as it generally builds smaller instances. But, of course, this advantage does not come for free: at each step, the restricted chase has to check that there is no way to satisfy the head of the TGD at hand, and this can be very costly in practice.
%
It has been recently observed that for RAM-based implementations the restricted chase is the indicated approach since the benefit from producing smaller instances justifies the additional effort for checking whether a TGD is already satisfied; see, e.g.,~\cite{BKMMPST17,KrMR19}. However, as discussed in~\cite{BKMMPST17}, an RDBMS-based implementation of the restricted chase is quite challenging, whereas an efficient implementation of the semi-oblivious chase is feasible.
%
Hence, both the semi-oblivious and restricted versions of the chase are relevant tools for practical implementations.
	
	
	
\subsection{Linear TGDs and Chase Termination}
%
	
	
There are indeed efficient implementations of the semi-oblivious and restricted chase that allow us to solve central database problems by adopting a materialization-based approach~\cite{BKMMPST17,KrMR19,NPMHWB15,UKJDC18}.
%
Nevertheless, for this to be feasible in practice we need a guarantee that the chase terminates, which is not always the case.
%
This fact motivated a long line of research on the chase termination problem, that is, given a database $D$ and a set $\dep$ of TGDs, to check whether the semi-oblivious or restricted chase of $D$ with $\dep$ terminates.
%
It is known that, in general, this is an undecidable problem. This has been established in~\cite{DeNR08} for the restricted chase, and it was observed a year later in~\cite{Marn09} that the same proof shows undecidability also for the semi-oblivious chase.
%
The undecidability proof given in~\cite{DeNR08}, however, constructs a sophisticated set of TGDs that goes beyond existing well-behaved classes of TGDs that enjoy certain syntactic properties. This observation leads to the obvious question: is the chase termination problem algorithmically solvable whenever we focus on well-behaved classes of TGDs?



A well-behaved class of TGDs, which attracted a considerable attention due to its simplicity, and also the fact that it strikes a good balance between expressiveness and complexity, is that of linear TGDs proposed in~\cite{CaGL12}. A TGD is {\em linear} if it has only one atom in its body, whereas the head can be an arbitrary conjunction of atoms. Such a TGD is called {\em simple-linear} if each variable in its body occurs only once, whereas variables in its head can repeat without any restriction.
%
Although, at first glance, (simple-)linear TGDs may look very inexpressive, it turns out that they are powerful enough to express database integrity constraints, as well as ontological axioms. In particular, we know that referential integrity constraints (a.k.a. inclusion dependencies) that form a central class of constraints~\cite{AbHV95}, can be easily expressed as simple-linear TGDs. 
%
Moreover, the important ontology language DL-Lite$_R$~\cite{CDLL*07}, which is based on Description Logics and forms the logical underpinning of OWL 2 QL, one of the popular profiles of the W3C committeeâ€™s Web Ontology
Language (OWL) standard for ontology languages, can be easily embedded into the class of simple-linear TGDs.


The chase termination problem in the presence of (simple-)linear TGDs has been extensively studied the last few years. Concerning the semi-oblivious version of the chase, there is a mature body of theoretical work that provides syntactic characterizations of when the chase terminates based on suitable acyclicity notions, algorithms for checking chase termination, precise complexity results, and worst-case optimal bounds on the size of the chase instance (whenever is finite)~\cite{CaGP22}. On the other hand, for the restricted version of the chase, we only have a decidability result via an algorithm that runs in double-exponential time, under the assumption that the head of the linear TGDs consists of a single atom~\cite{LMTU19}.
%
This striking difference on the progress that has been achieved should be attributed to the fact that the chase termination problem is significantly more challenging in the case of the restricted chase.



\subsection{Main Objective}
%

Having a complete theoretical understanding of the semi-oblivious chase termination problem in the presence of (simple-)linear TGDs, the next step is to experimentally evaluate the proposed algorithms with the aim of understanding which input parameters affect their performance, clarifying whether they can be applied in a practical context, and revealing their performance limitations. This is precisely the main objective of this work. Note that we do not consider the restricted chase as this will be very premature due to the lack of a good theoretical understanding of the problem in question; the latter is the subject of an ongoing research activity.



From the chase termination literature, we can inherit two types of algorithms for the semi-oblivious chase termination problem in the presence of (simple-)linear TGDs, that is, {\em materialization-based} and {\em acyclicity-based}~\cite{CaGP22}, which can be described as follows:

\medskip

\noindent \textbf{Materialization-Based.}
The materialization-based algorithms exploit the existence of worst-case optimal bounds on the size of the chase instance (whenever is finite). In particular, given a database $D$ and a set $\dep$ of (simple-)linear TGDs, we have an integer $k_{D,\dep}$ such that the chase of $D$ with $\dep$ terminates iff the size of the chase instance (i.e., the number of its atoms) is at most $k_{D,\dep}$. This immediately leads to a conceptually simple chase termination algorithm: simply run the semi-oblivious chase of $D$ with $\dep$ and keep a counter for the number of generated atoms, and if the count exceeds $k_{D,\dep}$, then conclude that the chase does not terminate; otherwise, it does.

\medskip

\noindent \textbf{Acyclicity-Based.} On the other hand, the acyclicity-based algorithms exploit the syntactic characterizations of when the chase terminates via suitable acyclicity notions. In particular, given a database $D$ and a set $\dep$ of (simple-)linear TGDs, we know that the chase of $D$ with $\dep$ terminates iff the dependency graph of $\dep$ (a standard way of representing a set of TGDs as a graph, which is defined in Section~\ref{sec:semi}) does not contain a ``bad'' cycle, where a ``bad'' cycle witnesses the fact that during the chase of $D$ with $\dep$ we eventually fall in a cyclic chase derivation that leads to non-termination. This again leads to a conceptually simple chase termination algorithm: construct the dependency graph of $\dep$, and if it has a ``bad'' cycle, then conclude that the chase does not terminate; otherwise, it does.

\medskip

An exploratory analysis showed that the materialization-based algorithms are simply too expensive for a chase termination check. This is because the worst-case upper bounds on the size of the result of the chase from~\cite{CaGP22} are very large, and thus, the algorithms are forced, in general, to construct extremely  large instances before being able to safely recognize that the chase does not terminate.
%Such a check should be a very fast pre-processing step that indicates whether a materialization-based approach for the main reasoning services, e.g., ontological query answering, can be adopted. The reason for the inefficiency of the
On the other hand, we have observed that the acyclicity-based algorithms were reasonably efficient with a lot of room for optimizations and improvements. Therefore, towards our main objective, we focused our attention on the acyclicity-based algorithms.


\subsection{Main Outcome and Challenges} 
%
Our experimental analysis revealed that for simple-linear TGDs the primary parameter impacting the runtime of the acyclicity-based algorithm is the size of the input set of TGDs, whereas the size of the input database does not play any crucial role. Interestingly, the algorithm is very fast (in the order of seconds) even for large sets of simple-linear TGDs (with up to 100K TGDs).
%
Now, concerning the more interesting case of linear TGDs, our analysis showed that the acyclicity-based algorithm consists of two components that are of different nature. In particular, there is a database-dependent component, whose performance is solely impacted by the size of the database, and a database-independent component, whose runtime is primarily affected by the size of the set of TGDs.
%
Interestingly, the overall runtime of the algorithm is quite reasonable, which is a strong evidence that fast checking for the termination of the semi-oblivious chase in the case of linear TGDs is not an unrealistic goal. Note that most of the total end-to-end runtime of the algorithm is taken by the database-dependent component, which indicates that our future efforts should be focused on improving that component.

\medskip


\noindent
\textbf{Technical Challenges.} Towards the above outcome concerning the acyclicity-based algorithms, we had to overcome a couple of technical challenges that led to results of independent interest:

\begin{itemize}
	\item It would not be possible to obtain the above insightful conclusions by naively implementing the algorithms in question as this would lead to poor performance; this is discussed in Section~\ref{sec:alg}. Hence, we had to revisit and refine the theoretical algorithms from~\cite{CaGP22} in order to obtain algorithms that are amenable to efficient implementations. The low-level implementation details of the refined algorithms are in Section~\ref{sec:implementation}.
	
	\item In order to stress test the algorithms in question, we had to synthetically generate databases and sets of TGDs. However, as discussed in Section~\ref{sec:setting}, existing data and TGD generators are not suitable for our purposes as they do not allow us to tune certain parameters that are crucial for evaluating our chase termination algorithms. To this end, we developed our own data and TGD generators, and used them to carefully generate the databases and TGDs that have been employed in our experimental analysis.
\end{itemize}


\medskip

\noindent{\em The experimental infrastructure and the source code can be found at https://github.com/mostafamilani/chase-termination.}