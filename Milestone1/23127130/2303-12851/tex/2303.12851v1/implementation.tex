% TODO 1- add the explicit name of Supports function, 2- Explain the abstract notion of adjacency list 3- single is enough, but we use a doubly linked list to reverse order for the performance, 4- dummy for a special edge on top of the stack for edges that are ignored, 5- add more explanation for 5.3 about the two sets of extensional positions and special SCC positions, 6- any shape can be translated to SQL of the form

% 1- explaining the Tarjan's stack in more detail, 2- why we use Tarjan's, 3- mentioning that we don't simplify the whole database

\section{Implementation Details}\label{sec:implementation}
%

We proceed to discuss the implementation details of the algorithms for checking the finiteness of the chase instance presented in Section~\ref{sec:alg}. In particular, we discuss the implementation choices that help to improve the performance of the algorithms, but are missing from the descriptions given in Section~\ref{sec:alg}.
%
In Sections~\ref{sec:bgarph}, \ref{sec:scc}, and \ref{sec:support} we discuss the procedures $\mathsf{BuildDepGraph}$, $\mathsf{FindSpecialSCC}$, and $\mathsf{Supports}$, respectively, used in Algorithm~\ref{alg:slinear}. The details of $\mathsf{DynSimplification}$ used in Algorithm~\ref{alg:dterm} are discussed in  Section~\ref{sec:d-simplification}.


\subsection{Build Dependency Graphs}\label{sec:bgarph}


The procedure $\mathsf{BuildDepGraph}$ takes as input a set $\dep$ of TGDs, and returns the dependency graph of $\dep$ in the form of an adjacency list. Recall that an adjacency list for a directed graph is a list of lists. Each list corresponds to a node $v$ of the graph, and the members in such a list represent the outgoing edges of $v$. Towards an implementation of such an adjacency list, we store a dependency graph as a list of {\em node objects}. Each node object represents a node in the graph, and has a list of {\em edge objects} representing the edges of the graph. For each edge object, we additionally store a binary value that specifies whether the corresponding edge is special or not. Although a singly linked list suffices for storing a dependency graph, we implement a dependency graph's adjacency list as a doubly linked list for performance purposes. By implementing a doubly linked list, each node object, in addition to a list of edge objects, has a list of reverse edge objects representing the edges in the opposite direction. These reverse edge objects enable traversing the graph in the opposite direction of the edges, which significantly helps when checking the support of positions in special SCCs, as we explain in Section~\ref{sec:support}. 
%
Now, given a set $\dep$ of simple-linear TGDs, $\mathsf{BuildDepGraph}$ iterates over all TGDs and constructs the dependency graph of $\dep$ by creating new elements for newly visited positions and linking them as dictated by the TGDs. To speed up the process of building dependency graphs, the procedure also uses an index structure that maps predicate positions to their corresponding elements in the adjacency list. This index allows for fast access to the elements (nodes) for adding new links (edges) while parsing new TGDs. Using the index structure, the procedure creates dependency graphs in linear time w.r.t. the size of the input set of TGDs.


\subsection{Find Special SCCs}\label{sec:scc}

To implement $\mathsf{FindSpecialSCC}$ we adapt the well-known {\em Tarjan's algorithm} for finding SCCs in directed graphs~\cite{tarjan1972depth}, which we briefly recall below.
%
Other algorithms for finding SCCs can be found in the literature (see, e.g., \cite{dijkstra1982finding,sharir1981strong}), some of which are simpler than Tarjan's algorithm such as Kosaraju's algorithm~\cite{sharir1981strong}. We nevertheless build on Tarjan's algorithm as it is more efficient in practice. 


\medskip

\noindent 
\textbf{Tarjan's Algorithm.} Given a directed graph, Tarjan's algorithm constructs a {\em spanning forest}, that is, a set of trees that contains all the nodes of the graph, while each tree corresponds to an SCC. 
%
To find the trees, the algorithm runs a depth-first search starting from an arbitrary node in the graph and creates the trees by traversing the nodes in each tree and then moving to the next tree. 
%
During the search for nodes in a tree, the algorithm traverses two categories of edges: (i) edges that lead to new nodes, and (ii) edges that lead to already visited nodes. The edges of the first category are called {\em tree edges} as they add new nodes to the tree. The edges of the second category are classified into three subcategories: (ii.a) the edges that move from an ancestor in the tree to one of its descendants, which are ignored by the algorithm, (ii.b) the edges that move from a descendant to its ancestor, called {\em fronds}, and (ii.c) the edges that move from one subtree to another subtree in the same tree, called {\em cross-links}.
%
Tarjan's algorithm assigns numbers to the nodes in the order they are visited during the search (i.e., a node with a smaller number is visited first) and pushes them in a stack. This stack, which we call {\em SCC stack}, differs from the stack used to implement the depth-first search. A visited node is removed from the search stack during backtracking when all its child nodes are visited in the depth-first search. However, such a node remains in the SCC stack as long as there is a path from it to a node below it in the stack. This allows the SCC stack to keep track of the nodes in the current tree. 
%
The algorithm uses the assigned numbers to understand whether a node is a root node after visiting all its children. This is done by checking if the traversed edges, while visiting the descendant nodes, are fronds and cross-links. After finding a root, the algorithm creates an SCC by popping nodes from the top of the SCC stack and adding them to the SCC until it reaches the root of the current tree. The algorithm continues until all the nodes in the graph are visited and returns the obtained trees (i.e., the SCCs of the graph). 

%An edge $(u,v)$ is a cross-link or a frond by checking if $\nit{Number}(u)>\nit{Number}(v)$. To decide if a node is a root, the algorithm uses the notion of \nit{lowlink}. For a node $v$, $\nit{Lowlink}(v)$ is the smallest node in the tree of $v$ that is reachable from $v$ using zero or more tree edges and, at most, one cross-link or frond. A node $v$ is a root if $\nit{Lowlink}(v)=v$ because it means no cross-link or frond goes to an ancestor of $v$ in the same tree. During the depth-first search, the algorithm computes the lowlink of each node when it backtracks after visiting its adjacent nodes. For a node $v$, its lowlink is the minimum of the lowlinks of the nodes reached by a tree edge and the numbers assigned to the nodes that are reached by a cross-link or frond. After computing lowlink, the algorithm checks if $v$ is a root (e.g., $\nit{Lowlink}(v)=\nit{Number}(v)$), and creates a new SCC consisting of $v$ and all the nodes visited after it if $v$ is a root. 



\medskip
\noindent \textbf{The Procedure FindSpecialSCC.} It is a simple extension of Tarjan's algorithm for finding the special SCCs in a dependency graph. Such an extension is needed as we need a mechanism that allows us to check whether a SCC obtained by Tarjan's algorithm is indeed special. This is done by pushing a dummy token in the stack (the stack that stores the visited nodes in the current component) whenever the algorithm traverses a special edge. Note that the algorithm pushes this dummy token even if the special edge is ignored, as we explained in Targan's algorithm. After finding the root of the current SCC and popping the nodes to create the SCC, the algorithm labels the SCC as special if there is a dummy token between the popped nodes. Only the special SCCs are stored and returned. 



\subsection{Check for Positions Support} \label{sec:support}

The procedure $\mathsf{Supports}$ consists of two steps: (1) query the database to find the positions of the extensional predicates, and (2) traverse the dependency graph starting from the positions in the special SCCs in the reverse order to reach the positions computed in the first step. 
%
Step (1) has been implemented via a single SQL query that returns the list of non-empty relations, which we then use to create the set of positions of the extensional predicates, denoted $P_D$. The SQL query has been implemented using the catalog of the DBMS that stores the database, which allows the query to find the set of relations names faster and without accessing the actual data.
%
For step (2), we start from the given set of positions $P$, i.e., the set of positions in the special SCCs, and traverse the graph in the reverse order using the reverse links in the adjacency list of the dependency graph, as explained in Section~\ref{sec:bgarph}. The procedure returns \true if the graph traversal in the second step reaches a node (i.e., a position) in $P_D$ from an extensional predicate; otherwise, it returns \false.



\subsection{Dynamic Simplification}\label{sec:d-simplification} 
%

The procedure $\mathsf{DynSmplification}$ takes as input a database $D$ and a set $\dep$ of linear TGDs, and returns the set $\dsimple{D}{\dep}$ of simple-linear TGDs. It is an iterative procedure that uses two sub-procedures: $\mathsf{FindShapes}$ that computes the set of shapes $S$ of the atoms of $D$, and $\mathsf{Applicable}$ that computes the simplified TGDs using the shapes of $S$. We discuss the implementation details of those two sub-procedures.



\medskip

\noindent 
\textbf{The Procedure $\mathsf{FindShapes}$.} 
We have two kinds of implementations for this procedure, that is, {\em in-memory} and {\em in-database}, which we discuss below. In Sections~\ref{sec:linear-ex} and~\ref{sec:rw-kb}, we conduct experiments comparing the performance of the two implementations of $\mathsf{FindShapes}$, and we discuss when one outperforms the other.

\medskip
\noindent \underline{\textbf{In-memory Implementation}}
\smallskip

\noindent For the in-memory implementation, we run an SQL query for each relation $R$ of $D$ to load all the tuples of $R$ into the main memory. We then construct the set of shapes of the atoms in each relation $R$ by iterating over its tuples $\bar c$, and generating the shape of each atom $R(\bar c)$. For relations that cannot be entirely loaded into the main memory, we split them into smaller relations processed separately. 


\medskip
\noindent \underline{\textbf{In-database Implementation}}
\smallskip

\noindent The in-database implementation does not load the relations, but instead runs SQL queries to find the shapes of the atoms in each relation. In particular, we translate each possible shape to a Boolean query that evaluates to \true if the shape exists in the database. The query for a shape of a predicate $R$ is of the following general form:


\vspace{2mm}
\begin{Verbatim}[commandchars=\\\{\}]
  \textcolor{blue}{SELECT CASE WHEN EXISTS} 
    (\textcolor{blue}{SELECT} * \textcolor{blue}{FROM} \textcolor{violet}{R} \textcolor{blue}{WHERE} \textcolor{violet}{Equality\_Conditions} 
                     \textcolor{blue}{AND} \textcolor{violet}{Diseqality\_Conditions})
            \textcolor{blue}{THEN} 1 \textcolor{blue}{ELSE} 0 \textcolor{blue}{END} 
\end{Verbatim}
\vspace{2mm}

\noindent where the equality and disequality conditions are consistency checks according to the given shape. For example, the shape $R_{[1,1,2]}$ translates to the following SQL query $Q$:

\vspace{2mm}
\begin{Verbatim}[commandchars=\\\{\}]
  \textcolor{blue}{SELECT CASE WHEN EXISTS} 
        (\textcolor{blue}{SELECT} * \textcolor{blue}{FROM} \textcolor{violet}{R} \textcolor{blue}{WHERE} \textcolor{violet}{a1}=\textcolor{violet}{a2} \underline{\textcolor{blue}{AND} \textcolor{violet}{a2}!=\textcolor{violet}{a3}})
            \textcolor{blue}{THEN} 1 \textcolor{blue}{ELSE} 0 \textcolor{blue}{END} 
\end{Verbatim}
\vspace{2mm}

\noindent where we assume that the predicate $R$ comes with the attributes \textcolor{violet}{\texttt{a1}}, \textcolor{violet}{\texttt{a2}}, and \textcolor{violet}{\texttt{a3}}.
%
Of course, running an SQL query per shape results in many queries for predicates with high arity. However, depending on the database $D$, many of these queries may be unnecessary since do not find any shapes. To avoid running some of those queries, we use the Apriori algorithm's idea to find association rules~\cite{agrawal1994fast}. We start by running queries for checking the existence of more general shapes (e.g., $R_{(1,1,2)}$) before we check more specific shapes (e.g., $R_{(1,1,1)}$). For each shape, we run a pair of queries. The first query is a relaxed version of the general query explained above without the disequality conditions. For example, the first query $Q'$ for $R_{(1,1,2)}$ is the query $Q$ above without the underlined condition. We only continue to run $Q$ if $Q'$ evaluates to \true. Additionally, we do not run the query for more specific shapes, e.g., $R_{(1,1,1)}$, if $Q'$ evaluates to \false. This allows us to avoid the execution of many queries for specific shapes by running a single query for more general shapes.



\medskip

\noindent 
\textbf{The Procedure $\mathsf{Applicable}$.} Recall that $\mathsf{Applicable}$ takes as input a set $S$ of shapes and a set $\dep$ of linear TGDs, and returns the set of TGDs of $\simple{\dep}$ such that the predicate of their body belongs to $S$. As explained in Section~\ref{sec:alg}, this is done by iterating over all TGDs $\sigma \in \dep$ of the form $R(\bar x) \ra \exists \bar z\, \psi(\bar y,\bar z)$ and homomorphisms $h$ from $\{R(\bar x)\}$ to $\mi{DB}[S]$, and collecting the simplification of $\sigma$ induced by the $h$-specialization of $\bar x$. Applying the above iterative process with a large set of shapes and a large set of TGDs can be very costly. Thus, to improve the performance of this process, the implementation uses an index structure that enables fast access to the TGDs. The index structure maps each predicate $R \in \sch{\dep}$ to the set of TGDs of $\dep$ that their body-atom uses $R$. This allows the procedure to iterate over the current shapes in each iteration and quickly access the relevant TGDs in the index.
%
However, checking whether a relevant TGD is applicable remains costly. This task requires checking the shapes of the body-atoms in all the simplified TGDs obtained from the TGD with the current shape. To facilitate this, we generate and store the shape of the body-atom of each TGD. Additionally, we store an array of strings representing all possible identifiers of tuples up to the maximum arity of the schema that allows us to quickly find the shapes of the body-atoms in simplified TGDs.

%The dynamic simplification in Algorithm~\ref{alg:dsimplify} iteratively applies the immediate operator $\Gamma_\Sigma$ to generate new shapes using the existing shapes and the tgds in $\Sigma$. Applying these iterations with many tgds and shapes can be costly as it requires checking the body of the tgds with the shapes to find the applicable tgds in each iteration. To improve the algorithm's performance, we implement it using an index structure that enables fast access to the tgds. The index structure maps each predicate to the set of tgds for which the predicate appears in the tgds' body atoms. This allows the algorithm to iterate on the current shapes in each iteration and quickly access the relevant tgds in the index to find the applicable ones. 

%We end this section by noting that in our implementation of \nit{LinearTerm} in Algorithm~\ref{alg:dterm}, we avoid the costly task of simplifying $D$ by modifying \nit{SimpleTerm} in Line~\ref{ln:return-3} to receive only $\Sigma'$. Here, \nit{SimpleTerm} works without $\nit{Simplify}(D)$ because it does not require checking for the support of the positions that appear in $\Sigma'$. The tgds in $\Sigma'$ are obtained from dynamic simplification, and, as a result, the positions that appear in $\Sigma'$ are trivially supported by $\nit{Simplify}(D)$. Therefore, we can simply implement \nit{SimpleTerm} in \nit{LinearTerm} by building the dependency graph of $\Sigma'$ and checking if it has any special SCCs. 


%index for: 1- predicate and its shapes, 2- predicate and its tgds
% (for delta shapes) 




