\begin{figure*}[t]
    \centering
\begin{adjustbox}{width=.95\textwidth}
\begin{tikzpicture}
\node[inner sep=0pt]  (title) at (0,-.25) {\textbf{Active Learning}};

\node[inner sep=0pt,below=0.5cm of title] (desc)  {
\parbox{6.2cm}{\small\em Given an input, return its label e.g. for Imagenet: 
\texttt{\scriptsize\\- Tinca tinca\\- Carassius auratus\\- Carcharodon carcharias\\- \dots}}};

\node[inner sep=0pt, below left=2.5cm and -0.7cm of title] (q1title) {$\texttt{query}_{\texttt{1}}$};
\node[inner sep=0pt,below=0.1cm of q1title] (q1){\includegraphics[width=2cm,height=2cm]{figures/teaser/ILSVRC2012_val_00038928.jpg}};

\node[inner sep=0pt,below right=2.5cm and -0.7cm of title] (q2title)  {$\texttt{query}_{\texttt{2}}$};
\node[inner sep=0pt,below=.1cm of q2title] (q2) {\includegraphics[width=2cm,height=2cm]{figures/teaser/ILSVRC2012_val_00008373.jpg}};


\node[inner sep=0pt,below=0.3cm of q1] (option1)  {\parbox{2cm}{\centering$\texttt{response}_{\texttt{1}}$\\ aligator}};

\node[inner sep=0pt,below=0.3cm of q2] (option2)  {\parbox{2cm}{\centering$\texttt{response}_{\texttt{2}}$\\aligator}};

\node[inner sep=0pt,below=6cm of title,color=red] (comment)  {\parbox{7cm}{\centering
Expansive oracle (expert knowledge)}};
    
\draw[black,thick,rounded corners] ($(desc.north west)+(-0.2,1)$)  rectangle ($(comment.south east)+(-0.1,-0.1)$);

%%%%%%%%%%%%%%%%%%%%%%%%
\node[inner sep=0pt]  (title_PAL) at (9,0) {\textbf{Positive Active Learning (PAL)}};

\node[inner sep=0pt,below=0.1cm of title_PAL] (desc_PAL)  {
\parbox{7.8cm}{\small\em Given inputs, choose if they are semantically related: \texttt{yes}/\texttt{no}}};

\node[inner sep=0pt, below left=0.6cm and 0.4cm of title_PAL] (q1title_PAL) {$\texttt{query}_{\texttt{1}}$};
\node[inner sep=0pt,below=0.1cm of q1title_PAL] (q1_PAL){\includegraphics[width=2cm,height=2cm]{figures/teaser/ILSVRC2012_val_00038928.jpg}};
\node[inner sep=0pt, below=0.1cm of q1_PAL] (and1) {$and$};
\node[inner sep=0pt,below=0.1cm of and1] (q1_PAL2){\includegraphics[width=2cm,height=2cm]{figures/teaser/ILSVRC2012_val_00008373.jpg}};
\node[inner sep=0pt,below=0.3cm of q1_PAL2] (option1_PAL)  {\parbox{2cm}{\centering$\texttt{response}_{\texttt{1}}$\\ yes}};



\node[inner sep=0pt,below right=0.6cm and -4cm of title_PAL] (q2title_PAL)  {$\texttt{query}_{\texttt{2}}$};
\node[inner sep=0pt,below=.1cm of q2title_PAL] (q2_PAL) {\includegraphics[width=2cm,height=2cm]{figures/teaser/dog.png}};
\node[inner sep=0pt, below=0.1cm of q2_PAL] (and2) {$and$};
\node[inner sep=0pt,below=0.1cm of and2] (q2_PAL2){\includegraphics[width=2cm,height=2cm]{figures/teaser/cat.png}};

\node[inner sep=0pt,below=0.3cm of q2_PAL2] (option2_PAL)  {\parbox{2cm}{\centering$\texttt{response}_{\texttt{2}}$\\no}};

\node[inner sep=0pt,below right=-2.8cm and 1.4cm of and2] (recap){\includegraphics[width=4cm,height=5.75cm]{figures/recaptcha.png}};

    
\node[inner sep=0pt,below=6.5cm of title_PAL,color=blue] (comment_PAL)  {\centering
Low-cost relationships information (reduced expertise)
};
\draw[black,thick,rounded corners] ($(desc_PAL.north west)+(-.8,0.6)$)  rectangle ($(comment_PAL.south east)+(1.6,-0.2)$);

\node[right=1cm of and2] (a) {\rotatebox{90}{\textit{ or (recaptcha)}}};
\node[below=1cm of a] (b) {};
\node[above=1cm of a] (c) {};

\draw (b) -- (a) -- (c);

\end{tikzpicture}
\end{adjustbox}
\vspace{.25em}
    \caption{Active Self-Supervised Learning  introduces PAL ({\bf right box}), an alternative to active learning ({\bf left box}) where the oracle is asked if a collection of inputs are semantically related or not. 
    As opposed to active learning, expert knowledge is reduced as one need not to know all the possible classes but only how to distinguish inputs from different classes. 
    % As such, PAL proves to be a low-cost alternative acting upon the similarity graph $\mG$ \cref{eq:G_ssl}; by querying enough samples, the learned representations of SSL or supervised learning are identical (recall \cref{thm:recovery}). 
    PAL querying is flexible, as an illustrative example we exhibit an \`{a} la captcha version where a given input is presented along with a collection of other inputs, and the oracle can select among those inputs the positive ones.}
    \label{fig:pal}
\end{figure*}

\section{Introduction}

Learning representations of data that can be used to solve multiple tasks, out-of-the-box, and with minimal post-processing is one of the main goals of current AI research \cite{pan2010survey,lecun2015deep,foundation}. 
Such representations are generally found by processing given inputs through Deep neural Networks (DNs). 
The main question of interest around which contemporary research focuses on deals with the choice of the training setting that is employed to tune the DN's parameters. 
A few different strategies have emerged such as layerwise \cite{bengio2006greedy}, reconstruction based \cite{vincent2008extracting}, and more recently, based on Self-Supervised Learning (SSL) \cite{chen2020simple,misra2020self}. 
In fact, due to the cost of labeling and the size of datasets constantly growing, recent methods have tried to drift away from traditional supervised learning \cite{settles2011theories}. 
From existing training solutions, joint-embedding SSL has emerged as one of the most promising ones \cite{jepa}.
It consists in learning representations that are invariant along some known transformations while preventing dimensional collapse of the representation. 
Such invariance is enforced by applying some known Data-Augmentation (DA), e.g. translations for images, to the same input and making sure that their corresponding representations are the same.

Despite tremendous progress, several limitations remain in the way of a widespread deployment of SSL.
% First, it separates itself entirely from supervised learning i.e. progresses made in each of those fields do not transfer to one another. 
In particular, it is not clear how to incorporate {\em a priori} knowledge into SSL frameworks beyond the usual tweaking of the loss and DAs being employed, although some efforts are being made \cite{chen2020big,zheltonozhskii2022contrast,zhai2019s4l}.
Indeed, it is not surprising that vision-language pre-training has replaced SSL as the state-of-the-art to learn image representation \cite{gan2022visionlanguage}, as those models are better suited to incorporate information stemming from captions that often come alongside images collected on the Internet.

% For example, if one has access to (some) label information, \cite{chen2020big,zheltonozhskii2022contrast} propose to use SSL for pretraining, and to then fine-tune with supervised learning; alternatively, \cite{zhai2019s4l} proposes to use the label information to sample the positive pairs during SSL training although without guarantee that this variant provides any benefit into the trained DN. 

% In this study, we propose to alleviate those two pitfalls by redefining existing SSL and supervised losses in terms of a similarity graph --where nodes represent data samples and edges reflect known inter-sample relationships.
In this study, we propose to redefine existing SSL losses in terms of a similarity graph --where nodes represent data samples and edges reflect known inter-sample relationships.
Our first contribution stemming from this formulation provides a {\em generic framework to think about learning in terms of similarity graph}: it yields a spectrum on which SSL and supervised learning can be seen as two extremes. 
Within this realm, those two extremes are connected through the similarity matrix, and in fact can be made equivalent by varying the similarity graph.
% In particular, we will obtain that when that similarity graph aligns with the underlying labels, SSL variants such as VICReg \cite{bardes2021vicreg}, BarlowTwins \cite{zbontar2021barlow} and SimCLR \cite{chen2020simple} learn representation akin to mean-square error, discriminant analysis \cite{klecka1980discriminant}, and cross-entropy supervised learning respectively.
Our second contribution naturally emerges from using such a similarity graph, unveiling an elegant framework to reduce the cost and expert requirement of active learning summarized by:
\begin{center}
\begin{minipage}{0.6\linewidth}
\centering
\em
Tell me who your friends are,\\ and I will tell you who you are.
\end{minipage}
\end{center}
Active learning, which aims to reduce supervised learning cost by only asking an oracle for sample labels when needed \cite{Settles2010,Dasgupta2011,Hanneke2014,Karzand2020}, can now be formulated in term of relative sample comparison, rather than absolute sample labeling.
This {\em much more efficient and low-cost approach is exactly the active learning strategy stemming from our framework}: rather than asking for labels, one rather asks if two (or more) inputs belong to the same classes or not, as depicted in \cref{fig:pal}. We coin such a strategy as {\em Positive Active Learning (PAL)}, and we will present some key analysis on the benefits of PAL over traditional active learning. We summarize our contributions below:
\begin{itemize}
    \item We provide a {\em unified learning framework} based on the concept of similarity graph, which encompasses both self-supervised learning, supervised learning, as well as semi-supervised learning and many variants.
    \item We derive a {\em generic PAL algorithm} based on an oracle to query the underlying similarity graph \cref{alg:pal}.
    The different learning frameworks (SSL, supervised, and so forth) are recovered by different oracles, who can be combined to benefit from each framework distinction.
    \item We show how PAL extends into an {\em active learning framework} based on similarity queries that provides low-cost efficient strategies to annotate a dataset (\cref{fig:pal}).
\end{itemize}
All statements of this study are proven in \cref{proof:section}, code to reproduce experiments is provided at \url{https://github.com/facebookresearch/pal}.


\begin{figure*}[t!]
    \centering
    \begin{minipage}{.45\linewidth}
    \includegraphics[width=\linewidth]{figures/teaser/ssl3_screen-fs8.png}
    \end{minipage}
    \hspace{.05\linewidth}
    \begin{minipage}{.45\linewidth}
    \includegraphics[width=\linewidth]{figures/G_matrix.jpeg}
    \hspace{.5\linewidth}
    \begin{minipage}{0.32\linewidth}\small
    \centering
    supervised
    \end{minipage}
    \begin{minipage}{0.32\linewidth}\small
    \centering
    semi-sup.
    \end{minipage}
    \begin{minipage}{0.32\linewidth}\small
    \centering
    PAL
    \end{minipage}
    \end{minipage}
    \vspace{.5em}
    \caption{\small {\bf Left:} Depiction of the ``knowledge graph'' arising from binary classification with supervised learning.
    Notice the two connected components, each corresponding to a single class. 
    Each sample is associated with a node of the graph (blue circle) and the known positive relation between samples is represented by an edge. This knowledge is summarized into the $\mG$ matrix depicted on the right.
    {\bf Right:} Examples of the $N \times N$ symmetric graph-adjacency matrices $\mG$ for the case of binary classification with supervised (same graph as on the left), semi-supervised and active learning. 
    Each nonzero entry $(\mG)_{i,j}$ represents the known positive relation between sample $i$ and $j$. 
    % The insight that will play a key role in our analysis is that knowing $\mG$ is equivalent to knowing the underlying per-sample labels. 
    % As such, when PAL is employed ({\bf right column}) and all the entries are recovered, SSL training will lead to the same representation as supervised training. 
    % Any a priori knowledge e.g. as in semi-supervised learning ({\bf middle column}) can be incorporated into $\mG$ prior PAL.
    }
    \label{fig:G}
\end{figure*}

\section{Background on Self-Supervised Learning}
\label{sec:background}

This section provides a brief reminder of the main self-supervised learning (SSL) methods, their associated losses, and common notations for the remainder of the study.

A common strategy to learn a model in machine learning is to curate labeled examples $(\vx_n,y_n)_n$, and to learn a model that given $\vx_n \in \X \triangleq \R^D$ as input, outputs $y_n \in [C]$, hoping that this model will learn to recognize patterns and relations that generalizes to new, unseen input data. 
Yet, as the dataset grew larger, and annotating data has become a major bottleneck, machine learning has shifted its attention to learning methods that do not require knowledge of $y_n$.
SSL has emerged as a powerful solution to circumvent the need for expensive and time-consuming labeling.
It learns a embedding $f:\X\to\R^K$ for a small $K$ by enforcing either reconstruction properties, or some invariance and symmetry onto a learned representation. 
SSL also relies on a set of observations $\mX = \{\vx_n\}_{n=1}^{N} \in \R^{N\times D}$, yet instead of labels $y_n$, it requires known {\em pairwise positive relation} that indicates whether two samples are semantically similar or not. 
For simplicity, we shall focus on the joint-embedding framework, where those positive pairs are artificially generated on the fly by applying Data Augmentations (DA), e.g. adding white noise, masking, on the same input.
Let denote $\gT_1, \gT_2:\X\to\X$ the generators of two (random) DAs $\gT_1(\vx)$ and $\gT_2(\vx)$ from an input $\vx$, $f_{\theta}:\mathbb{R}^{D} \to \mathbb{R}^{K}$ the  parametric model to be learned, and
\begin{align}
\mZ^{(1)} \triangleq \begin{bmatrix}
f_{\theta}(\gT_1(\vx_1))\\
\vdots\\
f_{\theta}(\gT_1(\vx_N))\\
\end{bmatrix},
\mZ^{(2)} \triangleq \begin{bmatrix}
(f_{\theta}(\gT_2(\vx_1))\\
\vdots\\
(f_{\theta}(\gT_2(\vx_N))\\
\end{bmatrix},\label{eq:Z}
\end{align}
where $(\vz^{(1)}_n,\vz^{(2)}_n)$, the $n^{\rm th}$ row of $\mZ^{(1)}$ and $\mZ^{(2)}$ respectively, form the $n^{\rm th}$ positive pair associated to sample $\vx_n$. Using \eqref{eq:Z}, different SSL losses will employ different measures of invariance and dimensional collapse. 
Typically, the losses are minimized with gradient descent and backpropagation to learn $\theta$.

{\bf VICReg.}~With the above notations, the VICReg loss \cite{bardes2021vicreg} reads, with hyper-parameter $\alpha, \beta > 0$,
\begin{align}
\nonumber
&\gL_{\rm VIC} = \alpha \sum_{k=1}^{K}\relu\left(1-\sqrt{\mC_{k,k}}\right)+\beta \sum_{k\neq l}\mC^2_{k,l} 
\\&\quad+ \frac{1}{N}\|\mZ^{(1)}-\mZ^{(2)}\|_2^2,
\qquad\mC \triangleq \Cov(\begin{bmatrix} \mZ^{(1)}\\\mZ^{(2)} \end{bmatrix}).
\label{eq:VICReg}
\end{align}

{\bf SimCLR.}~The SimCLR loss \cite{chen2020simple} with temperature hyper-parameter $\tau > 0$ reads
\begin{align}
    \nonumber
    &\gL_{\rm Sim}=-\sum_{i=1}^{N}\frac{\mC_{i,i}}{\tau}+\log\left(\sum_{i\neq j}^{N}\exp\paren{\frac{\mC_{i,j}}{\tau}}\right),
    \\& \mC_{i,j} \triangleq \CosSim(\mZ^{(1)}, \mZ^{(2)})_{ij} \triangleq \frac{\scap{\vz^{(1)}_i}{\vz^{(2)}_j}}{\|\vz^{(1)}_i\| \,\|\vz^{(2)}_j\|},\label{eq:simCLR}
\end{align}

{\bf BarlowTwins.}~BarlowTwins \cite{zbontar2021barlow} is built on the cross-correlation matrix $\mC_{ij} = \CosSim(\mZ^{(1)}{}^\top, \mZ^{(2)}{}^\top)$, with the hyper-parameter $\lambda$ it reads
\begin{align}
    \label{eq:BT}
    \gL_{\rm BT} = \sum_{k=1}^K (1 - \mC_{ii})^2 + \lambda \sum_{i\neq j} \mC_{ij}^2.
\end{align}
% It requires $\gO(Nk^2)$ flops to be computed.

{\bf Spectral Contrastive Loss.}~Finally, the spectral contrastive loss \cite{haochen2021provable} is theory-friendly proxy for SSL reading 
\begin{align}
    \label{eq:scl}
    \gL_{\rm VIC^2} = -2\scap{\mZ^{(1)}}{\mZ^{(2)}} + \frac{1}{N}\sum_{i\neq j} \scap{\vz^{(1)}_i}{\vz^{(2)}_j}^2.
\end{align}
In particular, as proven in \cref{proof:vic-2}, \eqref{eq:scl} recovers VICReg \eqref{eq:VICReg} when the ReLU-hinge loss is replaced by the mean-square error, hence the denomination VIC$^2$.

{\bf The Commonality between SSL Losses.}~%
All the above \cref{eq:VICReg,eq:simCLR,eq:scl,eq:BT} losses combine two terms: (i) a matching term between positive pairs, and (ii) a term to avoid collapse towards predicting a constant solution for all inputs.
(i) can take different forms such as the squared norm between $\mZ^{(1)}$ and $\mZ^{(2)}$ \eqref{eq:VICReg}, the opposite of their scalar product \eqref{eq:scl}, or of their cosine \eqref{eq:simCLR}, or the square norm between the centered-cosine and one \eqref{eq:BT}.
(ii) can also take different forms such as the infoNCE softmax \eqref{eq:scl}, or an energy that enforces richness of the learn feature, such as the variance-covariance regularization in \eqref{eq:VICReg} forcing the different coordinates of $f_\theta$ to be orthogonal \cite{cabannes2023ssl}.

While at face-value those losses seem distinct, they actually all simply consist and combine some variants of (i) and (ii), and even more importantly, they all rely on the exact same information of positive inter-sample relation for (i). This is exactly what the next \cref{sec:unify} will dive into, as a means to unify SSL losses, along with supervised learning methods.

\section{The Ubiquity of Similarity Graphs}\label{sec:unify}

The goal of this section is to unify SSL and supervised learning through the introduction of a special object: a {\em similarity graph}.

\subsection{The Graphs for (Self-)Supervised Learning}

Throughout this study, a similarity graph denotes a graph for which nodes represent data samples, and edges reflect similarity relationships. 
Formally, such a graph is expressed through its symmetric adjacency matrix $\mG \in \R^{N \times N}$, the semantic relation between inputs $i$ and $j$ being encoded in the real entry $\mG_{i,j}$. The remainder of this section will demonstrate how (i) SSL losses are implicitly based on a similarity graph (ii) how those losses tackle the supervised learning problem when provided a richer graph $\mG$.

{\bf Supervised learning.}~%
In addition to the $N$ input samples $\mX \in \R^{N\times D}$, supervised learning has access to paired labels $\vy \triangleq [y_1,\dots,y_N]$.
For clarity, we focus here on categorical labels  i.e. $y_n$ belongs to $\{1,\dots,C\}$ for $C$ the number of classes.\footnote{%
    While we focus here on classification for simplicity, our approach is easily extendable for generic problems involving a loss $\ell$ by defining the graph as $\mG_{ij} = -\ell(y_i, y_j)$. 
    In the classification, $\ell$ could be the zero-one loss $\ell(y_i, y_j) = \ind{y_i\neq y_j}$, and $\mG_{ij} \simeq 1 - \ell(y_i, y_j)$.
    See \cref{app:recovery} for details.
}
The one-hot encoding of $\vy$ will be denoted by the matrix $\mY \in \R^{N\times C}$.
In terms of the similarity graph $\mG$, the label-based relation becomes naturally encoded as $\mG_{i,j} = \ind{y_i\neq y_j}$, or equivalently
\begin{align}
    \label{eq:G_sup_easy}
    \mG(\mY) = \mY \mY^\top
\end{align}
A key observation that we must emphasize is that the graph $\mG$ almost explicitly encodes for the labels $\mY$, which will be made explicit with Theorem \ref{thm:recovery}.


{\bf Multiple Epochs with Data Augmentation.}~%
When DA is employed, and training is carried for $E$ epochs, the original $N$ input samples are transformed into $N\times E$ ``augmented'' samples. For more generality, since DA will also be used in SSL, let's denote by $A \in \mathbb{N}^*$ the number of augmentations --where here $A=E$. We now have the augmented dataset
\begin{align*}
    \mX^{(A)} &\triangleq [\underbrace{\gT(\vx_1),\dots,\gT(\vx_1)}_{\text{repeated $A$ times}} ,\dots, \gT(\vx_N),\dots,\gT(\vx_N)]^\top,
\end{align*}
where each $\gT$ has its own randomness. When available, i.e. for supervised learning, the corresponding ``augmented'' labels $\mY^{(A)}$ are given by repeating $A$ times each row of $\mY$, formally written with the Kronecker product $\mY^{(\sup)}\triangleq \mY \otimes \1_A$, and from that, we can now define the supervised dataset and associated graph extending \eqref{eq:G_sup_easy} to the case of multiple epochs and DA training
\begin{align}
    \label{eq:G_sup}
    \mX^{(\sup)}\triangleq \mX^{(E)},\qquad
    \mG^{(\sup)} \triangleq {\mY^{(\sup)}}^\top \mY^{(\sup)}.
\end{align}
The resulting graph \eqref{eq:G_sup} is depicted on the left part of \cref{fig:G}.

{\bf Self-Supervised Learning.}~%
SSL does not rely on labels, but on positive pairs/tuples/views generated at each epoch. 
Let us denote by $V$ the number of positive views generated, commonly $V=2$ for positive pairs as modeled in \eqref{eq:Z}.
With $E$ the total number of epochs, SSL produces $V \times E$ samples semantically related to each original sample $\vx_n$ through the course of training {\em i.e.} in SSL $A= V\times E$ while in supervised learning $A=E$. 
The total number of samples is thus $N\times E\times V$, defining the dataset and associated graph
\begin{align}
\mX^{(\ssl)} \triangleq\mX^{(V\times E)},\,
     \mG^{(\ssl)}_{i,j} = \Indic_{\{\floor{i/VE}=\floor{j/VE}\}},\label{eq:G_ssl}
\end{align}
where the associated similarity graph $\mG^{(\ssl)}$ --now of size $NEV\times NEV$-- captures if two samples were generated as DA of the same original input.

\subsection{Self-Supervised Learning on a Graph}

This section reformulates the different SSL losses through the sole usage of the similarity graph $\mG^{(\ssl)}$. 
To lighten notations, and without loss of generality, we {\em redefine} $\mX \in \R^{N\times D}$ to denote the full dataset, i.e. $N \leftarrow NEV$ with $\mX = \mX^{(\sup)}$ for supervised learning with $V \times E$ epochs, or with $\mX = \mX^{(\ssl)}$ in SSL with $E$ epochs with $V$ views for the SSL case.
The model embedding is shortened to $\mZ \triangleq f_\theta(\mX) \in \R^{N\times K}$ as per \cref{eq:Z}.

\begin{theorem}
\label{lemma:characterization}
VICReg \eqref{eq:VICReg}, SimCLR \eqref{eq:simCLR}, and BarlowTwins \eqref{eq:BT} losses can be expressed in term of the graph $\mG$ \eqref{eq:G_ssl}
\begin{align*}
    \\ \gL_{\rm VIC^2}(\mZ;\mG)=&\| \mZ\mZ^T  - \mG \|_F^2,
    \\ \gL_{\rm Sim}(\mZ;\mG)=&-\hspace{-0.2cm}\sum_{i,j\in[N]}\mG_{i,j}\log\paren{\frac{\exp(\tilde\vz_i^\top \tilde\vz_j)}{\sum_{k\in[N]} \exp(\tilde\vz_i^\top \tilde\vz_k)}},
    \\ \gL_{\rm BT}(\mZ;\mG)=& \norm{\tilde\mZ^\top \mG \tilde\mZ - I}^2,
\end{align*}
where $\mD = \diag(\mG \1)$ is the degree matrix of $\mG$; with $\tilde\vz \triangleq \vz / \norm{\vz}$ and $\tilde\mZ$ the column normalized $\mZ$ so that each column has unit norm.
\end{theorem}

In essence, SSL is about making sure that sample's representations match for samples that were deemed similar through the design of data augmentation.
As such, it is not surprising that one can rewrite SSL losses through the sole usage of the similarity graph.
From \cref{lemma:characterization}, the attentive observer would notice how VICReg is akin to Laplacian Eigenmaps or multidimensional scaling, SimCLR is akin to Cross-entropy and BarlowTwins is akin to Canonical Correlation Analysis; observations already discovered in the literature \cite{balestriero2022contrastive} and reinforced above. 

Beyond recovering such representation learning losses, our goal is to go one step further and to tie SSL and supervised learning through the lens of $\mG$, which follows in the next section.

\subsection{Self-Supervised is a G Away from Supervised}

What happens if one takes the different SSL losses, but replaces the usual SSL graph $\mG^{({\rm ssl})}$ with the supervised one $\mG^{({\rm sup})}$?

It turns out that the learned representations emerging from such losses are identical --up to some negligible symmetries that can be corrected for when learning a linear probe-- to the one hot-encoding of $\mY$.
To make our formal statement (\cref{thm:recovery}) clearer, we introduce the set of optimal representations that minimize a given loss:
\begin{align*}
        \gS_{\rm method}(\mG) \triangleq \argmin_{\mZ \in \R^{N \times K}} \gL_{\rm method}(\mZ;\mG),
    \end{align*}
where ``method'' refers to the different losses. 

\begin{theorem}[Interpolation optimum]
    \label{thm:recovery}
    When $K \geq C$, and $\mZ = f_\theta(\mX)$ is unconstrained (e.g. interpolation regime with a rich functions class), the SSL losses as per \cref{lemma:characterization} with the supervised graph \eqref{eq:G_sup} solve the supervised learning problem with:
    \begin{align*}
        \gS_{\rm VIC^2}(\mG^{(\sup)}) &= \brace{\mY \mR \midvert \mR \in \R^{C\times K}; \mR \mR^\top = \mI_C},\\
        \gS_{\rm Sim}(\mG^{(\sup)}) &= \brace{\mD\mY\mR\mM^{-1}\midvert \mD \in \diag_+, \mR \in O},\\
        \gS_{\rm BT}(\mG^{(\sup)}) &= \brace{\mY\mR \mD \midvert \mD \in \diag_+, \mR \in O},
    \end{align*}
    where $\mR \in O$ means that $\mR$ is a rotation matrix as defined for the VICReg loss, $\diag_+ = \diag(\R^N_+)$ are the set of diagonal matrix with positive entries, i.e. renormalization matrices, and $\mM$ is a matrix that maps a deformation of the simplex into the canonical basis.
    Moreover, provided class templates, i.e. $C$ data points associated with each of the $C$ classes, $\mY$ is easily retrieved from any methods and $\mZ \in \gS_{\rm method}$.
\end{theorem}

In essence, \cref{thm:recovery} states that SSL losses solve the supervised learning problem when the employed graph $\mG$ is $\mG^{(\sup)}$.
Moreover, the matrix $\mD$ appearing in \cref{thm:recovery} captures the fact that SimCLR solutions are invariant to rescaling logit and is akin to the cross-entropy loss, while BarlowTwin is invariant to column renormalization of $\mZ$ and is akin to discriminant analysis.
Lastly, VICReg might be thought of as a proxy for the least-squares loss.
At a high-level, \cref{thm:recovery} suggests fruitful links between spectral embedding techniques captured in \cref{lemma:characterization} and supervised learning.
We let for future work the investigation of this link and translation of spectral embedding results in the realm of supervised learning.

While \cref{thm:recovery} describes what we have coined as the ``interpolation optimum'', i.e. solution in the interpolation regime with rich models, we ought to highlight that classical statistical learning literature analyzes losses under the light of ``Bayes optimum'', i.e. solutions in noisy context-free setting \cite{Bartlett2006}.
Those Bayes optima do not make as much sense for losses that intrinsically relate different inputs, yet for completeness we provide such a proposition on Bayes optimum in \cref{app:bayes}.

\section{PAL: Positive Active Learning}
\label{sec:PAL}

Now that we demonstrated how one should focus on the graph $\mG$, rather than the (self-)supervised loss, we turn our focus into getting that graph $\mG$. 
In particular, we propose an active learning framework that discovers $\mG$ through efficient, low-cost queries.

\subsection{One Framework to Rule Them All}

From our understanding (\cref{thm:recovery}), the difficulties of both supervised learning and SSL are the same: they need a correct graph $\mG$, i.e they need to identify samples that are semantically similar, either through label annotations or through the right design of DA.

\begin{algorithm}[ht]
\KwData{$\mX\in\R^{N\times D}$; unknown graph $\mG = \mG^{(\sup)}$.}
\KwResult{Embedding $f_\theta:\R^D \to \R^K$.}
Initialization: weights $\theta_0$, scheduler $(\gamma_t)$; $T\in\N$;\\
\For{$t \in [T]$}{
Collect $I_t, J_t\leftarrow$ from {\color{blue} sampler};\\
Collect $(\mG_{ij} = \ind{y_i=y_j})_{(i,j)\in I_t}$ from {\color{blue} labelers};\\
Update $\theta_{t+1} \leftarrow \theta_t - \gamma_t \nabla_{\theta} \mL(\theta_t; \mG, I_t, J_t)$.
}
\caption{PAL framework with {\color{blue} oracle}}
\label{alg:pal}
\end{algorithm}

Our framework suggests a generic way to proceed, having fixed the samples $\mX$ in advance, and without much {\em a priori} knowledge on the similarity graph $\mG$.
In an active learning spirit, one would like to design a query strategy to discover $\mG$, and an update rule for the learned parameter $\theta$.
To ground the discussion, let us focus on VICReg.
The variance-covariance term can be rewritten with $R(a, b) = (a^\top b)^2 - \norm{a}^2 - \norm{b}^2$, this leads to the formula, proven in \cref{proof:vic-2},
\begin{gather}
    \gL_{\rm VIC^2}(\theta; \mG, I, J) = \sum_{(i,j)\in I} \mG_{i,j} \norm{f_\theta(\vx_i) - f_\theta(\vx_j)}^2
    \\+ \sum_{(i,j)\in J} R(f_\theta(\vx_i), f_\theta(\vx_j)),
    \label{eq:vic_sgd}
\end{gather}
where $I = J = [N]^2$.
An oracle would typically consider two small sets of indices $I, J \subset [N]^2$, asks labelers to provide $\mG_{ij}$ for $i,j\in I$, and, given a step size $\gamma_t$, update the weights with
\begin{align}
    \theta_{t+1} = \theta_t - \gamma_t \nabla_{\theta} \mL(\theta_t; \mG, I, J),
    \label{eq:weight_update}
\end{align}
which could be performed with the sole access to $(\mG_{ij})_{(i,j)\in I}$.
The pairs in $J$ are used to avoid dimensional collapse, and in particular for the VICReg loss, to compute the variance-covariance regularization term.
The complete picture leads to PAL, \cref{alg:pal}.
A particularly useful features of SGD for active learning is its robustness to labeling noise \cite{Cabannes2022active}.
In other terms, {\em \cref{alg:pal} is robust to noise in the query answers}.

We will now dive more in-depth into two variants of oracles: passive and active ones. As we will see, passive oracles can recover traditional SSL as special cases, but will be much less efficient in learning good representation than active strategies.

\subsection{Passive Oracles}

Passive variations of the PAL algorithm consist in fixing the oracle behavior at iterations $t\in [T]$ before starting the training. This formulation, under which the oracle does not leverage any information collected along training, recovers both SSL and supervised learning, based on the different querying strategies.

{\bf Self-Supervised Oracle.}~%
Probably the simplest oracle to describe is the one corresponding to the SSL strategy.
The original VICReg algorithm \cite{bardes2021vicreg} is made of $t$ gradient updates over $T = N_0 E$ iterations with $N = N_0 V E$ samples, where $N_0$ is the number of original samples, $E$ is the number of epochs, $V$ the number of views.
At time $t\in[T]$, $I_t$ is chosen as $\brace{(2t+1, 2(t+1))}$, describing a positive pairs generated on the fly from one original sample $\vx_i$ for $i = t \,\operatorname{mod. }\, N_0$; and $J_t$ is chosen as some mini-batch to estimate the covariance matrix of the features at the current epoch.
Because it has been built to remove human feedback, SSL actually does not need to ask for labelers to query $\mG_{s,s+1}$ (where $s = 2t+1$), since it is known by construction that those entries are going to be one.

{\bf Supervised Oracle.}~When it comes to a supervised learning oracle, the supervised learning loss provided in \cref{lemma:characterization} --which is known to recover $\mY$ (given class templates) as per \cref{thm:recovery}-- is easily minimized with gradient descent based on \eqref{eq:vic_sgd}.
Hence a simple oracle to solve the supervised learning problem based on stochastic gradient descent: at time $t$, consider a random pair of indices $(i_t, j_t)$ and set $I_t = J_t \leftarrow \brace{(i_t,j_t)}$.
The querying of $\mG_{i_t,j_t}$ can either be done on the fly, or if the dataset is already annotated, it can be deduced from the knowledge of $\mG_{i_t, j_t} = \ind{y_{i_t} = y_{j_t}}$.

\begin{algorithm}[ht]
    SSL oracle: \\
    \hspace{.3cm} Sampler: $I_t = \brace{(i_{2t+1}, i_{2(t+1)})}$, $J_t$ a minibatch,\\
    \hspace{.3cm} Labeler: $\mG_{2t+1,2(t+1)} = 1$.\\
    Supervised oracle: \\
    \hspace{.3cm} Sampler: $I_t = J_t = \brace{(i_t, j_t)}$ random in $[N]^2$,\\
    \hspace{.3cm} Labeler: $\mG_{i,j} = \ind{y_i = y_j}.$
    \caption{Passive Oracle Specifications}
    \label{alg:passive}
\end{algorithm}

{\bf Theoretical Remarks.}~%
Remarking that \eqref{eq:vic_sgd} is an unbiased formulation of VICReg, in the sense that
\[
    \gL_{\rm VIC^2}(\mZ) = \E_{I,J\sim \uniform{[N]^2}}\bracket{\gL_{\rm VIC^2}(\mZ; I, J)}.
\]
As a consequence, when $\theta \mapsto \norm{f_\theta(\mX) f_\theta(\mX)^\top - \mG}^2$ is strongly convex, \cref{alg:active} with either the self-supervised or the supervised oracle will converge to the minimizer of the VICReg loss in $O(1/T)$ \cite{Bubeck2015}.
Moreover, while this results holds for the empirical loss with resampling, it is equally possible to get a similar result for the minimization of the infinite-data (aka population) version of the VICReg loss and the recovery of the ideal embedding representation, when performing a single pass over the data.
In particular, by making sure that $J$ only charges pairs $(i, j)$ for $i$ and $j$ in two disjoint  subsets of $[N]$, one can prove convergence rates in $O(1/N)$ (Theorem 3 in \cite{cabannes2023ssl}).

Moreover, because the VICReg loss in \cref{thm:recovery} is nothing but a matrix factorization problem, one can directly translate results from this literature body into PAL. In particular, recent works have derived theoretical results regarding the matrix factorization problem based on toy models of neural networks, which might be plugged directly in here to claim theoretical results about the soundness of the PAL algorithm with neural networks \cite{Ye2021,Du2018,Jian2022}.
Since those results hold for any graph $\mG$, such results directly apply to both SSL and supervised learning, highlighting how PAL jointly derives results for SSL and supervised learning. 

\begin{figure}[t]
    \centering
\begin{tikzpicture}
\node[inner sep=0pt]  (title) at (0,-.1) {Level lines of $\ve_3^\top f_\theta$ at snapshots (learned with VICReg)};

\node (fig11) at (-3, -1.25)  {
    \includegraphics[width=.2\linewidth]{figures/active_empty.pdf}
};

\node[right=0.2cm of fig11] (fig12)  {
    \includegraphics[width=.2\linewidth]{figures/passive_mixed.pdf}
};

\node[right=0.2cm of fig12] (fig13)  {
    \includegraphics[width=.2\linewidth]{figures/active_mixed.pdf}
};

\node[right=0.2cm of fig13] (fig14)  {
    \includegraphics[width=.2\linewidth]{figures/active_full.pdf}
};

\node[inner sep=0pt]  (title2) at (0,-2.5) {Optimal linear probe $w^\top f_\theta$ for downstream task};

\node (fig1) at (-3, -3.65)  {
    \includegraphics[width=.2\linewidth]{figures/learned_empty.pdf}
};

\node[right=0.2cm of fig1] (fig2)  {
    \includegraphics[width=.2\linewidth]{figures/learned_passive.pdf}
};

\node[right=0.2cm of fig2] (fig3)  {
    \includegraphics[width=.2\linewidth]{figures/learned_mixed.pdf}
};

\node[right=0.2cm of fig3] (fig4)  {
    \includegraphics[width=.2\linewidth]{figures/learned_full.pdf}
};


\node (main) at (0, -7) {\includegraphics{figures/active.pdf}};

\draw[<-, very thick, draw opacity=.5] (fig1.south) -- ([shift=({-2.15,3.65})]main.south); 
\draw[<-, very thick, draw opacity=.5] (fig2.south) -- ([shift=({-.95,2.35})]main.south); 
\draw[<-, very thick, draw opacity=.5] (fig3.south) -- ([shift=({-.95,1.7})]main.south); 
\draw[<-, very thick, draw opacity=.5] (fig4.south) -- ([shift=({3.22,1.25})]main.south); 

\draw[->, draw opacity=.25] ([shift=({0,.3})]fig11.south) -- ([shift=({0,-.1})]fig1.north); 
\draw[->, draw opacity=.25] ([shift=({0,.3})]fig12.south) -- ([shift=({0,-.1})]fig2.north); 
\draw[->, draw opacity=.25] ([shift=({0,.3})]fig13.south) -- ([shift=({0,-.1})]fig3.north); 
\draw[->, draw opacity=.25] ([shift=({0,.3})]fig14.south) -- ([shift=({0,-.1})]fig4.north); 

\end{tikzpicture}
    \caption{Comparison the active oracle of \cref{alg:active} and the passive supervised one of \cref{alg:passive}.
    Given $q$ queries made, and the consequent reconstructed graph $\mG_q$, we learn $f_{\theta_t}:\X\to\R^C$ by minimizing $\gL_{\rm VIC^2}$, and plot the downstream mean-square error of the optimal a linear classifier $w^\top f_{\theta_t}$ for the best $w\in \R^C$.
    Here $\X = \R^2$, and $y\in[4]$ spans four concentric circles (represented by the blue, red, green and orange classes), $N=100$, query batches are chosen of size 10 and results are average over 100 trials (standard deviations being represented by the colorized regions). 
    Snapshots at different points on the curve show the third coordinates of the reconstructed $f_{\theta_t}$, and the ideal linear classifier that can be learned based on this embedding.
    }
    \label{fig:active}
\end{figure}

\subsection{Active Oracles}
Seen through the eyes of PAL, supervised and SSL --which employ passive querying-- can be improved by refining the oracle to choose the next indices $I_t$ and $J_t$ to process at time $t$.

{\bf Low-Cost and Efficient Active Learning.}~%
A crucial point of this study is that the active learning framework stemming from PAL differs fundamentally from classic active learning.
In the latter, at time $t$, one asks for a fresh label $y_{i_t}$ for some chosen index $i_t$.
Instead, PAL considers a batch of data $I_t$ and asks for pairwise comparisons $\ind{y_i\sim y_j}$ for $(i, j) \in I$.
Rather than asking labelers for fine-grained labels, such as ``caracal'' or ``numbfish'' on ImageNet, PAL would rather asks labelers if two images are related, or even to spot outliers in a set of images compared to a template, as illustrated on \cref{fig:pal}.\footnote{This ``spot-the-outliers'' strategy is formalized with $I_t = \{(i_t, j)\,\vert\, j \in \tilde{I}_t\}$ for $i_t$ representing the class template, and $\tilde{I}_t$ capturing the batch of data to spot outliers in.}
This is particularly useful when the cost of spotting a few outliers in a batch of $M$ images is much less costly than annotating $M$ data points.
On such instances, Criteo engineers found that batches of 15 images was a sweet spot in terms of labeling efficiency \cite{criteo}; while ImageNet was annotated by querying images on search engines, and spotting outliers among the results \cite{ImageNet}.
Meanwhile, reCaptcha (illustrated on \cref{fig:pal}) is said to have helped annotate millions of images \cite{captcha}.
We refer the curious reader to \cite{Simard2017} and references therein regarding the design of efficient user interfaces for those labeling tasks.

{\bf Zoo of Active Learning Strategies.}~%
By introducing PAL, we open a way to match the practice of active learning and its theory through a grounded framework that encompasses current heuristics to annotate big chunks of data.
While the optimal oracle depends on the problem idiosyncrasies, as well as the labeling cost model, the vast literature body on active learning provides many heuristics to design sophisticated or intricate oracles under different structural assumptions.
One could query information based on the least certain predictions \cite{Hanneke2014,Ash2020}; based on the distance to the decision boundaries \cite{pruning2022}; by comparing predictions made by different methods in an ensemble \cite{Bilgic2010active,ensemble2021}; or by finding the queries whose answers are the most likely to modify the current guess for $f_\theta$ \cite{Yang2016active,Knuth1977,Karzand2020}.
We refer the curious reader to Appendix \ref{app:active} for further discussion on the matter.
Throughout reviews, adaptations to PAL, ablation studies and comparisons on different benchmarks of those strategies is left for future work.

{\bf PAL {\em \`a la} Captcha.}~%
A natural and easy property to leverage in order to build active learning strategies is the fact that the $N^2$-entry matrix $\mG$ is actually derived from the $NC$-entry matrix $\mY$.
In particular, one can recover the full graph $\mG = \mG^{(\sup)}$ with less than $NC$ pairwise queries, and in the best case only $N$ queries --compare this to the $N^2$-entries that are queried by the supervised learning oracle.
This idea is captured formally with the oracle described in \cref{alg:active}, where the matrix $\mQ$ remembered past queries, and illustrated on \cref{fig:active}.
At time $t$, this oracle chooses to query against the class with the least numbers of known instances, and choose $M$ data points, ask if they match this class, and update known labels as a consequence.
An advantage of the query strategy of \cref{alg:active} is that one can stop at any time $t$ and have a balanced labeled dataset to learn with.

\begin{algorithm}[ht]
    \KwData{Class templates $(\vmu_1, \cdots, \vmu_C) \in \X^C$, $\mQ \in \R_{N\times C}$ initialized at zero.}
    Choose the class with least known examples $j = \argmin_j {\bf 1}^\top \mQ_t \ve_j \in [C]$;\\
    Collect pairwise comparison $\mQ_{ij} \leftarrow \ind{\vx_i \sim \mu_j}$ for $i$ in a batch $B \subset [N] \setminus \mK_t$ where $\mK_t$ remove queries with known results based on $\mQ_t$;\\
    Sampler: $I_t = J_t$ all the new entries deduced in $\mG$.\\
    Labeler: Human feedback $\mQ_{ij}$; deduction to fill $\mG$.
    \caption{Oracle {\em \`a la} Captcha}
    \label{alg:active}
\end{algorithm}

The basic \cref{alg:active} can be improved in several ways.
First, class templates can be deduced based on initial queries: the first data point $\mu_1 = \vx_1$ provides a first class template; after querying $\ind{\vx_2\sim \vx_1}$ if the answer is negative, $\mu_2 = \vx_2$ provides a second class template (otherwise it is part of class one); so forth and so on (if $\ind{\vx = \mu_1} = \cdots = \ind{\vx=\mu_k} = 0$, set $\mu_{k+1} = \vx$).
Those templates could be refined during training by defining the templates as the example the most at the center of the classes examples with some well-thought notion of distance (either in the input space or the embedding space).
Second, when classes are unbalanced and class probabilities are roughly known, one should rather choose $y(t)$ to be the class that minimizes the number of known examples in this class divided by the probability of this class.
Third, if $C$ the number of classes is small, random sampling of the batch $B$ will work well enough.
Yet, when $C$ is big, random sampling will mainly lead to negative observations and too few positive ones.
In this situation, the algorithm is improved by training a classifier based on known labels at time $t$ (eventually incorporating unlabeled data with semi-supervised learning techniques), and querying labels that were classified as the same class.
Finally, to avoid only getting negative pairs on datasets with many classes, one could leverage hierarchy in the labels: if dealing with the classes of ImageNet, one can first ask reviewers coarse-grained information, e.g. flag pictures that are not fishes; before going deeper in the taxonomy.

\section{Experiments}
\label{sec:experiments}

This section provides experimental details to validate the various theoretical results derived in previous sections. In order to remove confounding effects linked with architecture, optimization, data curation and other design choices that might impact the different empirical validation we focus here on closed-form solution based on kernel methods with synthetic dataset.
Further real-world empirical validations are provided in \cref{app:expe}.
In particular, \cref{tab:nnclr} reminds the reader how NNCLR \cite{dwibedi2021little} succeed to beat state-of-the-art SSL methods on ImageNet thanks to an active labeler oracle, which defines positive pairs as nearest neighbors in the embedding space $f_{\theta_t}(\X)$.

\begin{table}[t]
    \centering
    \begin{tabular}{|c|c|c|c|}
    \hline
         Modality & Oracle & \@1 accuracy & \@5 accuracy  \\
    \hline
         Passive & SimCLR \cite{simclrv2} & 71.7 & - \\
         Passive & VICReg \cite{bardes2021vicreg} & 73.2 & 91.1 \\
         {\bf Active} & NNCLR \cite{dwibedi2021little} & {\bf 75.6} & {\bf 92.4}\\ 
    \hline
    \end{tabular}
    \vspace{1em}
    \caption{Best known performance on ImageNet for state-of-the-art SSL methods.
    Notice how NNCLR \cite{dwibedi2021little} derives states of the art performance on ImageNet thanks to an active rule for labelers in \cref{alg:pal}, which consists in defining positive pairs as nearest neighbors in the embedding space as detailed in \cref{alg:nnclr}.
    This rule allows to beat the passive strategy that are provided by SimCLR and VICReg.
    }
    \label{tab:nnclr}
\end{table}

Kernel methods are rich ``linear'' parametric models defined as $f_\theta = \theta^\top \phi(\vx)$, for $\phi(\vx)$ and $\theta$ belonging to a separable Hilbert space ${\cal H}$.
Because those model can approximate any function \cite{Micchelli2006}, it is important to regularize $\theta$ in practice, either with early stopping in SGD, or with Tikhonov regularization, which can be written as $\lambda\trace(\mZ^\top \mK^{-1}\mZ)$ where $\lambda > 0$ is a regularization parameter and $\mK \in \R^{N\times N}$ is the kernel matrix defined as $\mK_{ij} = k(\vx_i, \vx_j) = \phi(\vx_i)^\top\phi(\vx_j)$.
In this setting, rather than matching the top of the spectral decomposition of $\mG$, the solution recovered by VICReg amounts to the top spectral decomposition of $\mG - \lambda \mK^{-1}$ \cite{cabannes2023ssl}.
This allows to compute the ideal representation of $f_\theta$ in closed-form given any graph $\mG$ based on the regularized kernel model $f_\theta = \theta^\top \phi(\vx)$, hence ablating the effects that are unrelated to the theory described in this study.
In this controlled setting, the superiority of active algorithms is undeniable, and illustrated on \cref{fig:active}, where we illustrate the optimal downstream error one can achieve with linear probing of the minimizer $f_\theta$ of the VICReg loss.
Experimental details and more extensive validations are provided in \cref{app:expe}: in particular, the use of non-contrastive versus contrastive graphs, i.e. that set $\mG_{ij} = -1$ when $y_i \neq y_j$, is studied on \cref{fig:contrastive}; the ability to incorporate label knowledge in SSL methods is the object of \cref{fig:interpolation}; robustness to noise is shown on \cref{fig:noise}; and relations between test error and the number of connected components of the reconstructed $\mG$ is analyzed on \cref{fig:comp}.

\begin{figure}[ht]
    \centering
    \includegraphics{figures/interpolation.pdf}
    \caption{
    A major motivation of this paper is to be able to add prior information on sample relationships in SSL methods, and more in particular, to have a simple way to leverage known labels.
    We do by considering $\mY$ containing one-hot encoding of known labels, and rows being zero otherwise and the mixed graph
    \(
        \mG = (1-\alpha) \cdot \mG^{(\ssl)} + \alpha \cdot \hat\mY\hat\mY^\top.
    \)
    The setting is the same as \cref{fig:setup_toy} with $N=200$ and two augmentations per sample.
    When zero labels are known (left of the plot), we are in the full SSL regime, while when all the 200 labels are known (right of the plot), we recover supervised learning performance.
    When few labels are given the effect of the supervised graph can be counterproductive if the mixing coefficient $\alpha$ is too big.
    However, when mixed properly, adding prior label information in SSL methods allows to improve performance.
    }
    \label{fig:interpolation}
\end{figure}

\section{Conclusions}

This work introduces PAL, a learning framework that revolves around the central concept of similarity graph.
We first showed how similarity graphs are the implicit backbone of self-supervised learning methods, and how this concept extends to tackle supervised learning problems.
This observation does not solely unveil a rich learning framework, but also provides a single algorithm based on a querying oracle that can describe both SSL and supervised learning techniques, opening the way to new oracles that benefit from techniques stemming from both the supervised and self-supervised learning literature.
Finally, PAL leads to an efficient formalization of active learning as performed in practice to annotate large datasets, potentially enabling fruitful exchanges between the practice and the theory of active learning.
Promising directions for future works include empirical validations on large-scale datasets, as well as theoretical study of the newly introduced active learning framework.