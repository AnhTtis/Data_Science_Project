\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{LSFA 2022}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{bbm}
\usepackage{subfigure}
\usepackage{tikz}
\usepackage{enumerate}

%Pacotes inclusos por Erick:
%--- pacote para figuras
\usepackage{epsf}
\usepackage[dvips]{epsfig,graphicx}
\usepackage{subfigure}
\usepackage{float}
\usepackage[utf8x]{inputenc}


%--- pacote de simbolos
\usepackage{latexsym}
\usepackage{textcomp}

%--- simbolos matematicos
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}


%--- outros pacotes
\usepackage{url}
\usepackage{longtable}
\usepackage{lscape}


%Tabela Colorida
\usepackage{colortbl}
\usepackage[boxruled,longend,linesnumbered,norelsize]{algorithm2e}

\usepackage{xcolor}

\usepackage{multicol}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{listings}

%---- Pacotes adicionais
\usepackage{enumitem}
%\usepackage{microtype}



%-------- Pacotes inclu√≠dos pelo autor
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{topaths,calc}
\usepackage{tikz-qtree}
\usetikzlibrary{fit}
\usetikzlibrary{automata, positioning, arrows}
\usepackage{multicol}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{definition}
\newtheorem{example}{Example}
\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}
%\theoremstyle{coro}
%\newtheorem{coro}{Corol\'{a}rio}
%\theoremstyle{info}
%\newtheorem{info}{Informa\c c\~ao}
%\theoremstyle{dem}
%\newtheorem{dem}{Demonstra\c c\~ao}
%\theoremstyle{prop}
%\newtheorem{prop}{Proposi\c c\~ao}
\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}
\usepackage{xcolor}
\usepackage{syntax}
\usepackage{newfloat}
%\newtheorem*{theorem*}{Teorema}
\usepackage{blindtext}
\usepackage[final]{pdfpages}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{reo}
\usepackage{varwidth}
\usepackage{enumitem}
\usepackage{bussproofs}
\usepackage{prooftrees}
\usepackage[color]{coqdoc}
\usepackage{booktabs}

\usepackage{epsf}
\usepackage[dvips]{epsfig,graphicx}
\usepackage{subfigure}
\usepackage{float}

\usepackage{latexsym}
\usepackage{textcomp}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}

\usepackage{url}
\usepackage{longtable}
\usepackage{lscape}

\usepackage{multicol}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{listings}

\usepackage{xcolor}
\usepackage{syntax}
\usepackage{newfloat}
\usepackage{blindtext}
\usepackage[final]{pdfpages}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{reo}
\usepackage{varwidth}
\usepackage{enumitem}
\usepackage{bussproofs}
\usepackage{prooftrees}
\usepackage[color]{coqdoc}
\usepackage{booktabs}
\usepackage[boxruled,longend,linesnumbered,norelsize]{algorithm2e}

%---- Pacotes adicionais
\usepackage{enumitem}
%\usepackage{microtype}

\usetikzlibrary{arrows,shapes,decorations,petri}
\tikzset{every node/.style={scale=.71}}

%\def\Prop{\Phi}
%\def\then{\rightarrow}
%\def\ifonlyif{\leftrightarrow}
%\def\Nat{\mathbbm N}
%
%\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}
%\newcommand{\Set}[1]{\ensuremath{\{#1\}}}
%
%\newcommand{\define}[1]{\emph{#1}}
%
%\newcommand{\pp}[1]{{\mathcal{#1}}}
%\newcommand{\problem}[1]{\langle #1 \rangle}
%
%\newcommand{\snf}[1]{{\sf DSNF\raisebox{-0.75ex}{\scriptsize #1}}}
%\newcommand{\ap}[1]{\alpha(#1)}
%\newcommand{\calculus}[1]{{\sf RES\raisebox{-0.75ex}{\scriptsize #1}}}
%\newcommand{\rulename}[1]{{\sf (#1)}}
%\newcommand{\jus}[3]{[\mbox{\set{#1}\!,\rulename{#2},#3}]}
%\newcommand{\jusinit}[1]{[\mbox{\set{#1}}]}
%
%\newcommand{\model}[1]{{\mathcal #1}}
%\newcommand{\modelst}[2]{\model{#1}{,}#2}
%
%\newcommand{\St}{S} %% the set of states
%\newcommand{\st}{s} %% a state

\newcommand{\relo}{$ReLo$}

\title{\relo: a Dynamic Logic to Reason About Reo Circuits\thanks{This work was supported by CNPq and FAPERJ.}}
\author{Erick Grilo
\institute{Instituto de Computa\c c\~ao}
\institute{Universidade Federal Fluminense}
\email{simas\_grilo@id.uff.br}
\and
Bruno Lopes
\institute{Instituto de Computa\c c\~ao}
\institute{Universidade Federal Fluminense}
\email{bruno@ic.uff.br}
}

\def\titlerunning{\relo\: a Dynamic Logic to Reason About Reo Circuits}
\def\authorrunning{E.\ Grilo \& B.\ Lopes}

%\newcounter{definition}[theorem]
%\setcounter{definition}{0}
%\renewcommand{\thedefinition}{\thesection.\arabic{definition}}
%  
%\renewenvironment{definition}{\stepcounter{definition}\textit{Definition \thedefinition.}\itshape}{}

\begin{document}

\maketitle


\begin{abstract}
	
Critical systems require high reliability and are present in many domains. They are systems in which failure may result in financial damage or even loss of lives. Standard
techniques of software engineering are not enough to ensure the absence of unacceptable
failures and/or that critical requirements are fulfilled.
Reo is a component-based modelling language that aims to provide a framework to build software based on existing pieces of software, which has been used in a wide variety of domains. Its formal semantics provides grounds to certify that systems based on Reo models satisfy specific requirements (i.e., absence of deadlocks). %It enables the modelling of systems that require guarantees regarding specific properties that they must meet. These guarantees may be obtained by formal verification of the system (or its required parts).
Current logical approaches for reasoning over Reo require the conversion of formal semantics into a logical framework. \relo\ is a dynamic logic that naturally subsumes Reo's semantics. It provides a means to reason over Reo circuits.
This work extends \relo\ by introducing the iteration operator, and soundness and completeness proofs for its axiomatization.%, and a Coq implementation of
The core aspects of this logic are also formalized in the Coq proof assistant. %We show how one can obtain a \relo\ model in the Coq implementation system and how to address the concepts \relo\ implements in Coq. %\relo\ serves as a Reo formal semantics with soundness and completeness proofs, a tableaux-based deductive system followed by its soundness and completeness proofs, and an implementation of \relo\ in the Coq proof assistant. The Coq implementation provides means to the modelling and verification of \relo\ models in a computational environment.	
\end{abstract}


%
%\input{01.introduction.tex}
%\input{02.petri.tex}
%\input{03.petri-pdl.tex}
%\input{04.calculus.tex}
%\input{05.conclusion.tex}


\input{intro} %ok claudia
\input{propositionalLogic}
%\input{coq}
\input{reo}
\input{relo}
%\input{approach}
%\input{usageEx}
\input{conclusions}

% --- -----------------------------------------------------------------
% --- Referencias Bibliograficas. (Obrigatorio)
% --- -----------------------------------------------------------------

%\bibliographystyle{acm-2} % abbrv - abnt-num
\bibliographystyle{eptcs}
\bibliography{ref} % arquivo fonte com a bibilografia

%% Bibliography
%\bibliographystyle{ACM-Reference-Format}
%\bibliography{pdlref,pdlrefINTRO,pdlref2}

% History dates
%\received{March 2007}{March 2009}{June 2009}

\end{document}
% End of v2-acmsmall-sample.tex (March 2012) - Gerry Murray, ACM


