%\chapter{Related Logic Formalisms} \label{chap:rlf}
%
%The present work proposes a logic-based approach to reason over Reo models in Coq. In this chapter, the main aspects of the underlying logic theory present in Coq are recovered, with a focus on the logic formalisms that Coq employs. It also provides an overview of logical frameworks upon which \relo\ is based.

\section{Background} \label{sec:rlf}

This section provides a succinct overview of Reo~\cite{Arbab2004,Arbab2006}, considering its main characteristics and a modelling examples as it is the target language \relo\ provides a formal semantic to reason over. %We also briefly introduce the main aspects of one popular formal semantics for Reo, Constraint Automata as proposed by Baier et al.~\cite{Baier2006}.

%This section introduces some related logical formalisms which \relo\ is inspired upon. We start by briefly discussing propositional and modal logic, followed by the proof assistant Coq.

%\subsection{Classical Propositional logic}
%
%Propositional Logic is a mathematical model which enables the reasoning of logical sentences (propositions) which contain truth values (such as true or false). Propositions can be combined to produce more complex propositions out of simpler ones~\cite{Aho1992}. As part of a branch of logic that studies methods to reason about relationship and$\backslash$or how to compose propositions out of other propositions, Classical Propositional Logic is a logical system that provides the necessary apparatus to deal with such study. 
%
%Being a relatively simple mathematical model, Classical Propositional Logic allows reasoning over statements such as ``Charlie is a nice boy'', represented in the logic as a propositional symbol $\alpha$. Therefore, $\alpha \equiv$ ``Charlie is a nice boy'' denotes the attribution to $\alpha$ the proposition mentioned the same way variables are used to represent numbers in mathematics. 
%%
%%
%%%novo
%%Its roots date back to the third century B.C., with Aristotle's logical works composing the earliest form of logic's formal study registered. By around the second century B.C., an early version of what is known as Propositional Logic was formalized by Chrysippus, an Greek philosopher~\cite{Hitchcock2005}. The Sophists, and later Plato (early 4th century B.C.) displayed an interest in sentence analysis, truth and fallacies by means that no one could have any doubt about these properties on sentences. Propositional Logic was later then reinvented by Peter Abelard, a French philosopher in the twelfth century B.C.~\cite{Marenbon2006}.
%%%endnovo
%
%Propositions in this logic can be separated into two structural types: atomic propositions, propositions with no logical connectives, and molecular propositions, which are propositions built from other propositions using logical connectives. Logical connectives can be found in the spoken language as conjunctions such as ``or", ``and", and the negation adverb ``not". Such connectives lead to the possibility of reasoning about connected molecular propositions.
%
%To formally reason about these propositions, a formal system is defined to translate written sentences into propositional symbols as shown above (these are called well-formed formulae, which in the propositional calculus are atomic or molecular formulae) and inference rules, which are rules used to reason over these propositions.
%
%In Classical Propositional Logic, both atomic and molecular propositions may denote only two truth-values: true and false. At any moment, a given proposition may either be true or false, not being able to be both at the same time.
%
%Formally, the language of Propositional Logic can be described as follows.
%\begin{definition}[Language of Classical Propositional Logic] \label{def:propositionalLogic}
%The language of Propositional Logic can be described by
%\begin{description}
%%\item a set of propositional symbols which stands for the formalized propositions;
%\item an enumerable set $\Phi$ of propositional symbols;
%\item a set of connectives which are interpreted as operator symbols, composing molecular statements out of other molecular or atomic propositions, namely the connectives $\land$ (and), $\lor$ (or), $\to$ (implies), $\leftrightarrow$ (biconditional) and $\neg$ (not).
%\end{description}
%\end{definition}
%
%In what follows we discuss the semantics of Classical Propositional Logic as in~~\cite{Fitting2012}. It considers a space of truth values $Tv = \{t,f\}$ which can be assigned to propositions: $t$ denoting truth and $f$, falsehood. The negation $\neg$ is a unary connective which semantically can be seen as a map $\neg\colon Tv \to Tv$, $\neg(t) = f$ and $\neg(f) = t$. The semantics of binary connective ($\land,\lor,\to, and \leftrightarrow$) propositions that follows from Definition~\ref{def:propositionalLogic} are shown in Table~\ref{tab:semanticsPropLogic}, where $\varphi$ and $\psi$ are formulae.
%
%\begin{table}[!htb]
%
%	\centering\begin{tabular}{p{1cm} | p{1cm} || p{1cm} | p{1cm} | p{1cm} | p{1cm} }
%		\toprule
%		$\varphi$ & $\psi$  & $\land$ & $\lor$ & $\to$ & $\leftrightarrow$ \\\midrule
%		
%		$t$ & $t$ & $t$ & $t$ & $t$ & $t$ \\\midrule
%		
%		$t$ & $f$ & $f$ & $t$ & $f$ & $f$ \\\midrule
%		
%		$f$ & $t$ & $f$ & $t$ & $t$ & $f$ \\\midrule
%		
%		$f$ & $f$ & $f$ & $f$ & $t$ & $t$ \\\bottomrule
%	\end{tabular}
%	\caption{Classical Propositional Logic connectives}
%	\label{tab:semanticsPropLogic}
%\end{table}
%
%Classical Propositional Logic has an inference rule as follows, called ``Modus ponens''. Any inference in which any well-formed furmula of its language is substituted uniformly for the schematic letters in this rule is an instance of it.
%
%\begin{prooftree}
%	\AxiomC{$\varphi$} \AxiomC{$\varphi \rightarrow \psi$}
%	\BinaryInfC{$\psi$} 
%\end{prooftree}
%
%
%
%A well formed formula in Classical Propositional Logic is expressed by employing the language in Definition~\ref{def:propositionalLogic} as in the following grammar, with $p \in \Phi$:
%$p \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \to \psi \mid \varphi \leftrightarrow \psi \mid \neg \varphi$.
 
%\subsection{Modal Logic}
%
%Modal logics are defined as logics in which the notion of modality is added to formulae, employing the usage of terms ``necessarily''($\Box$) and ``possibly'' ($\Diamond$) to denote the truth of a statement~\cite{Chellas1980,SEP2021}. Although the term ``Modal Logic'' can be used to describe a family of logics, considering other modalities of other logics~\cite{SEP2021}, we will focus on the two modalities presented. The structure of the language of modal logics is the one presented in Definition~\ref{def:propositionalLogic} with the modality operators $\Box$ and $\Diamond$ added as follows.
%
%\begin{definition}[Language of Modal Logics]
%	
%	\item an enumerable set $\Phi$ of propositional symbols;
%	
%	\item $p \in \Phi$:
%	$p \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \to \psi \mid \varphi \leftrightarrow \psi \mid \neg \varphi \mid \Box \varphi \mid \Diamond \varphi$;
%	
%%	\item The following rewritings are standard in modal logic: $\top \equiv \neg \bot, \phi \lor \psi \equiv \neg(\neg \phi \land \neg \psi), \phi \to \psi \equiv \neg\phi \lor \psi$ and $\Box \varphi \equiv \neg \Diamond \neg \phi$.
%\end{definition}
%
%The notion of truth in modal logics depends on whether a formula $\varphi$ has a modality, and if the modality is either $\Box$ or $\Diamond$. A formula $\Box \varphi$ denotes that ``it is necessary that $\varphi$ holds in every possible world'', while $\Diamond \varphi$ stands for ``it is possible that $\varphi$ holds at some possible world''. Worlds can be seen as ``places'' where the logical sentences hold, and they can model a variety of situations, like the current state of the execution of some machinery. 
%
%Notions of truth in modal logics rely on a structure called Kripke frames, in honor of Saul Kripke\footnote{\url{https://www.gc.cuny.edu/faculty/core-bios/saul-kripke}}. A Kripke frame $\mathcal{F}$ is defined as a pair $\mathcal{F} = \langle W, R \rangle$, where $W$ is a set (of possible worlds), and $R \subseteq W \times W$ a relation over $W$ denoting how the worlds relate with each other (i.e., how can one world reach another world). Then, a model in modal logics is $\mathcal{M} = \langle \mathcal{F}, {\bf V} \rangle$, where $V\colon W \to 2^\Phi$ is the valuation function: for each world $w \in W$, $V(w)$ is the set of all atomic propositional symbols that hold in $w$.
%
%The semantic notion related to formulae in modal logic is stated in Definition~\ref{def:semanticNotionModal}. Let $\mathcal{M} = \langle \mathcal F, \textbf{V} \rangle$ a model in modal logic, and $p, \varphi_1$ and $\varphi_2$ be propositional formula. The notion of satisfaction of a formula $\varphi$ in $\mathcal{M}$ at a state $w \in W$ of the model, denoted by $\mathcal{M},w \Vdash p$ is defined as follows.
%
%\begin{definition}[Semantic notion of standard Modal Logic] \mbox{} \label{def:semanticNotionModal}
%	\begin{itemize}[noitemsep]
%		\item $\mathcal{M}{,}w \Vdash p \text{ iff } p \in V(w)$%\bruno{,\textnormal{ponha sempre a vírgula entre chaves nesses casos, pra remover o espaço posterior desnecessário}}
%		%\item $\mathcal{M}{,}w \Vdash \top$ always
%		\item $\mathcal{M}{,}w \Vdash \neg \varphi \text{ iff } \mathcal{M},s \nVdash \varphi$
%		\item $\mathcal{M}{,}w \Vdash \varphi_1 \land \varphi_2 \text{ iff } \mathcal{M}{,}w \Vdash \varphi_1$ and $\mathcal{M}{,}s \Vdash \varphi_2$
%		\item $\mathcal{M}{,}w \Vdash \varphi_1 \lor \varphi_2 \text{ iff } \mathcal{M}{,}w \Vdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$
%		\item $\mathcal{M}{,}w \Vdash \varphi_1 \to \varphi_2 \text{ iff } \mathcal{M}{,}w \nVdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$
%		\item $\mathcal{M}{,}w \Vdash \varphi_1 \leftrightarrow \varphi_2 \text{ iff } \mathcal{M}{,}w \nVdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$ and $\mathcal{M}{,}w \Vdash \varphi_1$ or $\mathcal{M}{,}s \nVdash \varphi_2$ 
%		
%		\item $\mathcal{M}{,}w \Vdash \Diamond \varphi$ if there exists a state $v \in W$, $wRv$ and $\mathcal{M}{,}v \Vdash \varphi$
%		
%		\item $\mathcal{M}{,}w \Vdash \Box \varphi$ if for all states $v \in W$ such that $wRv$ and $\mathcal{M}{,}v \Vdash \varphi$
%	\end{itemize}
%	We denote by $\mathcal M\Vdash\varphi$ if $\varphi$ is satisfied in all states of $\mathcal M$. By $\Vdash\varphi$ we denote that $\varphi$ is valid in any state of any model.
%\end{definition}

%\subsection{Propositional Dynamic Logic}
%
%Propositional Dynamic Logic (PDL) is a Dynamic Logic tailored to reason about programs. It describes how programs interact between themselves and the propositions which are not bound to a specific domain of computation~\cite{Harel2001}. Intuitively, it can be understood as a special case of a modal logic tailored to reason about programs.  PDL's language is introduced by Definition~\ref{def:pdlSyntax}.
%
%%There are numerous variants of PDL which focus on employing PDL to reason over specific domains, like PDL with converse~\cite{Giacomo2000} or PDL without iteration~\cite{Harel2000}, but we will focus on regular PDL. The syntax of PDL considers elements from Classical Logic, Modal logic, and the algebra of regular expressions (to define iteration of programs). 
%%PDL's syntactic elements must be of one of the following types: formulas (or atomic propositions) $\varphi, \psi,  \dots$, programs $\alpha, \beta, \dots$, and modalities $\Box$ and $\Diamond$ indexed by programs $\pi$ as $\lbrack \pi \rbrack$ and $\langle \pi \rangle$. Atomic propositions are symbols $p, q, \dots$ the same way they are defined in Classical or Modal logic. PDL's syntax is formally introduced by Definition~\ref{def:pdlSyntax}.
%
%\begin{definition}[PDL language] \label{def:pdlSyntax} PDL language is composed by\mbox{}%\\
%	\begin{itemize}[noitemsep]
%	\item an enumerable set $\Phi$ of propositional symbols;
%	
%	\item $p \in \Phi$:
%	$p \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \to \psi \mid \varphi \leftrightarrow \psi \mid \neg \varphi \mid \lbrack \pi \rbrack \varphi \mid \langle \pi \rangle \varphi$;
%	
%%	\item The following rewritings are standard in PDL: $\top \equiv \neg \bot, \phi \lor \psi \equiv \neg(\neg \phi \land \neg \psi), \phi \to \psi \equiv \neg\phi \lor \psi$ and $\lbrack \pi \rbrack \varphi \equiv \neg \langle \pi \rangle \neg \phi$;
%	
%	\item a program $\pi$ may be an atomic program $\gamma$ or the result of one of the following operations over one (or more) programs $\alpha, \beta$: $\alpha ; \beta$ as the sequential composition operator, $\alpha \cup \beta$ as the nondeterministic choice operator $\alpha^\star$ as the iteration operator, and $\varphi?$ as the test operator.
%	\end{itemize}
%\end{definition}

%Intuitively, formulas in PDL can be interpreted as the following: $\lbrack \pi \rbrack \varphi$ denotes ``It is necessary that after executing $\pi$, $\varphi$ holds''. The execution of PDL programs can be interpreted as follows.
%
%\begin{itemize}[noitemsep]
%	\item $\lbrack \pi \rbrack \varphi$: ``It is necessary that after executing $\pi$, $\varphi$ holds''
%	
%	\item $\alpha;\beta$: ``Execute $\alpha$, followed by the execution of $\beta$''
%	
%	\item $\alpha \cup \beta$: ``Either $\alpha$ or $\beta$ will be nondeterministically selected to be executed''
%	
%	\item $\alpha^\star$: ``$\alpha$ will be executed zero or a finite number of times ''
%	
%	\item $\varphi?$: ``if $\varphi$ is true, then proceed with the execution, otherwise abort''	
%\end{itemize}

%The semantics of PDL comes from modal logics~\cite{Harel2001}. Execution of programs $\pi$ in PDL are seen as relations $R_\pi$ over a set of states $W$, $R_\pi \subseteq W \times W$, which describes the program's execution. Notation $uR_{\pi}v$ means that $(u,v) \in R_\pi$. The relation of the iteration of a program $\alpha^\star$ $R_{\alpha^\star}$ is the reflexive transitive closure of $R_\alpha$ as $R^\star_{\alpha}$.
%
%PDL also employs Kripke frames $\mathcal{F} = \langle S, R_\pi \rangle$, where $S$ is a set of states and $R_\pi$ is an indexed binary relation over a set of worlds in PDL for each atomic program $\pi$. A PDL model is a model $\mathcal{M} = \langle \mathcal{F}, V \rangle$, $V$ as the valuation function which addresses for states $s \in S$ each formula which is valid on them, $V \subseteq S \times 2^\Phi$. 
%
%The relation $R$ for compound programs is as follows.
%
%\begin{itemize}[noitemsep]
%	\item $u R_{(\alpha; \beta)} v$ iff there exists a world $w$ such that $u R_\alpha w$ and $w R_\beta v$
%	
%	\item $u R_{(\alpha \cup \beta)} v$ iff $u R_\alpha v$ or $u R_\beta v$
%	
%	\item $u R_{(\varphi)?} v$ iff $u = v$ and $\varphi \in V(v)$
%\end{itemize}



%Let us consider the following: the statement ``While $x$ do $\alpha$'' can be modelled as a PDL program $\pi = ((x? ; \alpha) \cup \neg x?)$, where $(x? ; y)$ is the successful case of the loop, while its right hand side models the failure to enter the loop, as the test denoted by $x?$ fails. Also program statements like ``if $x$ then $\alpha$ else $\beta$'' may also be formalized as $\pi = ((x? ; \alpha) \cup (\neg x?; \beta))$.

%Let us consider Algorithm~\ref{alg:PDLexample} as a PDL modelling example. We will denote each atomic statement as a different symbol. Consider the following symbolization, where $\varphi$ and $\psi$ are the tests respectively used in the ``while'' and ``if'' statements in the algorithm, and $\alpha, \beta$, and $\gamma$ are the atomic program statements.
%
%\begin{algorithm}[!htb]
%	\While{a != 100}{ 
%		a = a + 1\; 
%		\eIf{x < 100}{
%			printf(``a's value is \%d'', a)\;
%		}{
%			y = 100 - x\;
%		}
%	}
%	\caption{An imperative program}
%	\label{alg:PDLexample}
%\end{algorithm}
%
%
%\begin{itemize}[noitemsep]
%	\item ``a != 100'' $\rightarrow \varphi$
%	\item ``a = a + 1;'' $\rightarrow \alpha$
%	\item ``x < 100'' $\rightarrow \psi$
%	\item ``printf("a's value is \%d", a);'' $\rightarrow \beta$
%	\item ``y = 100 - x;'' $\rightarrow \gamma$
%\end{itemize} 
%
%Therefore, Algorithm~\ref{alg:PDLexample} is modelled in PDL as follows. The ``if'' code block can be formalized as $\pi' = ((\psi? ; \beta) \cup (\neg \psi?; \gamma))$, where the nondeterministic choice operator $\cup$ models both outcomes of the ``if'' condition: if $y$ holds, then $\beta$ is executed, otherwise $\gamma$ is executed. The ``while'' statement can be modelled as $\pi = ((\varphi? ; \alpha; \pi') \cup \neg x?)$, where $(\varphi? ; \alpha ; \pi')$ models the execution of the ``while'' code block (lines 2-7), and $\neg x$ models the case the program execution does not enter in the ``while'' code block, where the program execution would begin from line 8.

%Let $\mathcal{M} = \langle \mathcal F, \textbf{V} \rangle$ a model in PDL, and $p, \varphi_1$ and $\varphi_2$ be propositional formula. The notion of satisfaction of a formula $p$ in $\mathcal{M}$ at a state $s \in S$ of the model, denoted by $\mathcal{M}{,}s\Vdash p$ is defined as follows.
%
%\begin{definition}[Semantic notion of PDL] \mbox{} \label{def:semanticNotionPDL}
%	\begin{itemize}[noitemsep]
%		\item $\mathcal{M}{,}s \Vdash p \text{ iff } p \in V{(s)} $%\bruno{,\textnormal{ponha sempre a vírgula entre chaves nesses casos, pra remover o espaço posterior desnecessário}}
%		%\item $\mathcal{M}{,}s \Vdash \top$ always
%		\item $\mathcal{M}{,}s \Vdash \neg \varphi \text{ iff } \mathcal{M},s \nVdash \varphi$
%		\item $\mathcal{M}{,}s \Vdash \varphi_1 \land \varphi_2 \text{ iff } \mathcal{M}{,}s \Vdash \varphi_1$ and $\mathcal{M}{,}s \Vdash \varphi_2$
%	 	\item $\mathcal{M}{,}w \Vdash \varphi_1 \lor \varphi_2 \text{ iff } \mathcal{M}{,}w \Vdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$
%	 	\item $\mathcal{M}{,}w \Vdash \varphi_1 \to \varphi_2 \text{ iff } \mathcal{M}{,}w \nVdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$
%	 	\item $\mathcal{M}{,}w \Vdash \varphi_1 \leftrightarrow \varphi_2 \text{ iff } \mathcal{M}{,}w \nVdash \varphi_1$ or $\mathcal{M}{,}s \Vdash \varphi_2$ and $\mathcal{M}{,}w \Vdash \varphi_1$ or $\mathcal{M}{,}s \nVdash \varphi_2$ 
%		\item $\mathcal{M}{,}s \Vdash \langle \pi \rangle \varphi$ if there exists a state $w \in S$, $sR_{\pi}w$, and $\mathcal{M}{,}s \Vdash \varphi$
%		\item $\mathcal{M}{,}s \Vdash \lbrack \pi \rbrack \varphi$ if for all states $v \in W$ such that $wRv$ (i.e., $(w,v) \in R$), $\mathcal{M}{,}v \Vdash \varphi$
%	\end{itemize}
%	We denote by $\mathcal M\Vdash\varphi$ if $\varphi$ is satisfied in all states of $\mathcal M$. By $\Vdash\varphi$ we denote that $\varphi$ is valid in any state of any model.
%\end{definition}

%\subsection{Calculus of Inductive Constructions} \label{sec:coc}
%The Calculus of Constructions (CoC)~\cite{Coquand1985} is conceived as a formalism for constructive proofs in natural deduction style, where every proof is a $\lambda$-expression typed with propositions of the implemented logic. Calculus of Constructions is based on Intuitionistic Type Theory (as proposed by Martin-Löf~\cite{Martin1984}): by removing types the result is a pure $\lambda$-expression with its associated algorithm. The Calculus of Constructions therefore leads to a high-level functional programming language that lets their users formalize definitions and prove properties about them in the same computational environment~\cite{Coquand1985}.
%
%The idea behind the Calculus of Constructions is a formalism that relies heavily on the Curry-Howard Correspondence among proposition and types. Calculus of Constructions provides a powerful language to formalize constructions as a notion of a high-level fully functional programming language containing enough expressibility to allow the specification of complex algorithms, as well as the notion of data types as present in programming languages.
%
%The Calculus of Constructions was conceived to show how powerful the Curry-Howard Correspondence is to Computer Science. In the Calculus of Constructions, every term is a $\lambda$-expression. All expressions in CoC are typed: there are types for functions, proofs, atomic types, and types for types themselves. Every object formalized in CoC must belong to a type. Quantifiers such as the existential quantifier \ensuremath{\exists} and \ensuremath{\forall} are formalized with respect to a type and has form ``exists $a$ of type $P$" and ``for all $a$ of type $P$'', respectively. Expressions of type $x$ of type $P$ are written as $x\colon P$ and can be informally read as ``$x$ belongs to $P$''.
%
%Object types in the Calculus of Constructions hold logical propositions, individual terms denoting data types, and function types. Therefore all terms in the Calculus of Constructions are formalized within the same context, where both data types and function types can be thought of as proofs of their types. As an example, the $\lambda$-abstraction ($\lambda x \colon M$)$N$ can be interpreted as a proof for [$x \colon M$]$P$ when $M$ is a proof of $P$ considering $N$ as a hypothesis.
%
%Calculus of Constructions was then extended to a variant that enables the formalization of (co-)inductive definitions. This extension was provided in 1989 as Calculus of Inductive Constructions (CiC)~\cite{Coquand1990}, a result of research on the extraction of programs from proofs in the Calculus of Constructions. An important aspect for this extension relies on the idea that inductively defined propositions and data types play a core role in any application~\cite{Pfenning1989}. Calculus of Inductive Constructions is the current logical formalism behind the Coq system. This extension enables inductively defined data types as well as principles such as proofs by induction and recursively defined functions.
%
%Sorts in CiC have types and there is a well-founded hierarchy of types. Calculus of Inductive Constructions introduces three base sorts:
%
%\begin{itemize}[noitemsep]
%\item[\coqdockw{Prop}] is the sort of logical propositions. Let $P$ be a logical proposition. Therefore $P$ stands for the type of proofs of $P$. An element $p \in P$ is an evidence that $P$ is provable (namely, $p$ is a proof of $P$).
%
%\item [\coqdockw{Set}] is the set of small data types, such as booleans, natural numbers, operations and functions over them.
%
%\item [\coqdockw{Type}] is the type of all types. \coqdockw{Type} also contains all data types defined by \coqdockw{Set} and their operation, as well as larger types and operations over them. \coqdockw{Type} is defined because assuming \coqdockw{Set} is of type \coqdockw{Set} leads to an inconsistency. CiC provides an infinite well-founded hierarchy of sorts where \coqdockw{Set} and \coqdockw{Type (i)} belongs to a \coqdockw{Type (j)}, where $\coqdockw{i} < \coqdockw{j}$. 
%\end{itemize}
%
%Terms in CiC may be constructed from sorts, variables, constants, functions and their applications. They are syntactically built from the following rules:
%\begin{enumerate}
%	
%\item the types \coqdockw{Prop}, \coqdockw{Set} and \coqdockw{Type} (the well-founded infinite hierarchy is hereby implicit) are terms.
%
%\item variables and constants are terms,
%
%\item if $x$ is a variable, with $T$ and $U$ terms, then $\forall x\colon T, U$ is also a term.
%
%\item if $x$ is a variable, with $T$ and $u$ terms, then $\lambda x\colon T.u$ denoting a function that maps elements from $T$ to $u$ is also a term.
%
%\item if $t$ and $u$ are terms, then ($t u$) is also a term. This term denotes the application of $t$ on $u$.
%
%\end{enumerate}
%%adicionado: p/ v0 regras de contextos (tipos lógicos)
%CoC is conceived with an objective which is to provide in the same environment means to formalize both proofs and programs. The inference rules of CoC are defined as follows. Let $\Gamma$ a context (set of logical types, propositions) and $\Delta$ a logical type. The symbol $\cong$ denotes the congruence over propositions, contexts and terms by means of $\beta$-conversion.
%
%%\begin{description} ERICK: regras erradas, eu acho (aqui são da pagina 5 do pdf)
%%\item \begin{prooftree}
%%\AxiomC{$\Gamma \vdash \Delta$}
%%\UnaryInfC{$\Gamma[x : \Delta] \vdash * $}
%%\end{prooftree}
%%denoting that if $\Delta$ holds from $\Gamma$, the type of types $*$ is derivable from $\Gamma$ concatenated with $x$ as variable of type $\Delta$.
%%
%%\item \begin{prooftree}
%%\AxiomC{$ \vdash *$}
%%\end{prooftree} meaning that $*$ as the type of all types is always derivable.
%%
%%\item \begin{prooftree}
%%\AxiomC{$\Gamma \vdash M\colon *$}
%%\UnaryInfC{$\Gamma[x\colon M] \vdash * $}
%%\end{prooftree}
%%meaning that if $M\colon *$ holds from $\Gamma$, the type of all types $*$ also holds from $\Gamma[x\colon M]$.
%%
%%\item \begin{prooftree}
%%	\AxiomC{$\Gamma \vdash M\colon *$}
%%	\UnaryInfC{$\Gamma[x\colon M] \vdash * $}
%%\end{prooftree}
%%
%%
%%\item \begin{prooftree}
%%	\AxiomC{$\Gamma \vdash M\colon *$}
%%	\UnaryInfC{$\Gamma[x\colon M] \vdash * $}
%%\end{prooftree}
%
%
%\begin{description}
%\item \begin{prooftree}
%\AxiomC{$\Gamma \vdash \Delta$}
%\UnaryInfC{$\Gamma \vdash \Delta \cong \Delta $}
%\end{prooftree} which is the identity for (logical) types.
%
%\item \begin{prooftree}%*
%	\AxiomC{$\Gamma \vdash M\colon N$}
%	\UnaryInfC{$\Gamma \vdash M \cong M $}
%\end{prooftree} as the identity for terms, where $M$ is a well typed term of type $N$.
%
%\item  \begin{prooftree}
%	\AxiomC{$\Gamma \vdash M \cong N$}
%	\UnaryInfC{$\Gamma \vdash N \cong M $}
%\end{prooftree} as the rule that states that the congruence over propositions is symmetric.
%
%\item \begin{prooftree}
%	\AxiomC{$\Gamma \vdash M \cong N$}
%	\AxiomC{$\Gamma \vdash N \cong P$}
%	\BinaryInfC{$\Gamma \vdash M \cong P$}
%\end{prooftree} denoting the transitivity of congruence over propositions, where $M$,$N$ and $P$ are terms. 
%
%\item \begin{prooftree}
%	\AxiomC{$\Gamma \vdash P_1 \cong P_2$}
%	\AxiomC{$\Gamma[x \colon P_1] \vdash M_1 \cong M_2$}
%	\BinaryInfC{$\Gamma \vdash [x \colon P_1]M_1 \cong [x \colon P_2]M_2$}
%\end{prooftree} as the conversion rules between types $P_1$ and $P_2$.
%
%\item \begin{prooftree}%*
%	\AxiomC{$\Gamma \vdash P_1 \cong P_2$}
%	\AxiomC{$\Gamma[x \colon P_1] \vdash M_1 \cong M_2$}
%	\AxiomC{$\Gamma[x : P_1] \vdash M_1 : N_1$}
%	\TrinaryInfC{$\Gamma \vdash (\lambda{x} \colon P_1)M_1 \cong (\lambda{x} \colon P_2)M_2$}
%\end{prooftree}
%
%\item \begin{prooftree}%*
%	\AxiomC{$\Gamma \vdash (M N : P)$}
%	\AxiomC{$\Gamma \vdash M \cong M_1$}
%	\AxiomC{$\Gamma \vdash N \cong N_1$}
%	\TrinaryInfC{$\Gamma \vdash (M N) \cong (M_1 N_1)$}
%\end{prooftree} as the conversion between $\lambda$-applications, with $M$, $M_1$, $N$ and $N_1$ are well typed terms of type $P$.
%
%\item \begin{prooftree}%*
%	\AxiomC{$\Gamma[x \colon A] \vdash M \colon P$}
%	\AxiomC{$\Gamma \vdash N \colon A$}
%	\BinaryInfC{$\Gamma \vdash ((\lambda{x} \colon A) M N) \cong [N/x]M'$}
%\end{prooftree} denoting the compositionally of $\lambda$-terms by means of $\beta$-reduction.
%\item \begin{prooftree}
%	\AxiomC{$\Gamma \vdash M \colon P$}
%	\AxiomC{$\Gamma \vdash P \cong Q$}
%	\BinaryInfC{$\Gamma \vdash M \colon Q$}
%\end{prooftree} as the type conversion rule, $P$ and $Q$ types and $M$ a well formed term of type $P$
%%\erick{eu acho que o que tá entre [] se refere á variáveis e entre () à $\lambda$ termos}
%\end{description}
%For further details regarding CoC, the work presented in \cite{Coquand1985} provide a full overview on the rules and the general aspects of this system.
%
%
%%\erick{comentar daqui pra baixo}
%%CoC's objective is to provide in the same environment means to formalize both proofs and programs. Therefore the rules that defines the type system may be depicted as follows.
%%
%%\begin{enumerate}[(i)]
%%\item The set of terms : $A = A_i \cup A_\sigma$, $A_i$ as the set of individual types and $A_\sigma$ the set of logical propositions.
%%
%%\item The set of individual types as $A_i = \bigcup_{n \geq 0} A_{i}^{n}$ as the infinite type hierarchy.
%%
%%\item The set of logical propositions as $A_\sigma = \bigcup_{n \geq 0} A_{\sigma}^{n}$ which also follows the infinite type hierarchy.
%%
%%\item The sets $A_{\sigma}^{n}$ are generated by means of the following inductive rules:
%%\begin{enumerate}
%%\item $* \in A_{\sigma}^{n}$, where $*$ is the universe of all types, with $*$ denoting the type of all types, consequently the type of all propositions. This rule introduces the universe hierarchy of types in CoC.
%%
%%\item $[x : M]N \in A_{\sigma}^{n}$ if $M \in A^{n}, N \in A_{\sigma}^{n + 1}$ N is a logical proposition and $M$ a type where $a$ belongs to it. This rule introduces the notion of quantification over propositions in CoC.
%%\end{enumerate}
%%
%%\item The sets $A_{i}^{n}$ are generated by means of the following inductive rules:
%%
%%\begin{itemize}[noitemsep]
%%\item $k \in A_{i}^{n}$ if $1 \leq k \leq n$ as the variables. CoC introduces variables by meas of De Brujin's indexes\erick{citar?}
%%
%%\item $[x : M] N \in A_i^{n}$ if $A^{n}, N \in A_{i}^{n + 1}$ with $N$ as a data type and $M$ a type with $a \in M$.
%%
%%\item $(\lambda x : M) \in A_i^{n}$ if $M \in A^{n}, N \in A_{i}^{n + 1}$ denoting lambda abstractions in CoC.
%%
%\item $(M N) \in A_i^{n}$ if $M,N \in A_i^{n}$ as function applications.
%\end{itemize}
%
%
%
%\end{enumerate}
%Calculus of Inductive Constructions is a Pure Type System. 

