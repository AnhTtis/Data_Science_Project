
\section{Introduction}

In software development, service-oriented computing~\cite{Papazoglou2003} and model-driven development~\cite{Atkinson2003} are examples of techniques that take advantage of software models. The first technique advocates computing based on preexisting systems (services) as described by Service-Oriented Architecture (SOA), while the latter is a development technique that considers the implementation of a system based on a model. A model is an abstraction of a system (or some particular portion of it) in a specific language, which will be used as a specification basis for the system's implementation. It can be specified in languages such as Unified Modeling Language (UML) or formal specification languages like B~\cite{Abrial1991} or Alloy~\cite{Jackson2002}. Researchers also have applied approaches such as formal methods in software development to formalize and assure that certain (critical) systems have some required properties~\cite{Knight2002,Ostro1992}.

Reo~\cite{Arbab2004} is a prominent modelling language, enabling coordination of communication between interconnected systems without focusing on their internal properties. Reo models are compositionally built from base connectors, where each connector in Reo stands for a specific communication pattern. Reo has proven to be successful in modeling the organization of concurrent systems' interaction, being used in a variety of applications, from process modeling to Web-Services integration~\cite{Arbab2008A} and even in the construction of frameworks to verify specifications in Reo~\cite{Kokash2012,Tasharofi2009}.

%Standard software engineering techniques are not designed to deal with fault non-tolerant systems, namely critical systems.
%In many domains, such systems need a way to ensure their safety to guarantee that they indeed meet the required reliability.
%Formal systems compose a theoretical and implemented background able to model and reason about systems, ensuring (mathematically) that requirements are fulfilled and that systems behave as expected.
%
%Proof assistants~\cite{Loveland2014}, like Coq~\cite{Coq1995} and Isabelle~\cite{Nipkow2002}, lead to the possibility of automatizing the verification of such systems and provide certified code.
%They are computational tools that implement logic systems.
%Their design is tailored to automatize many (when possible) steps of proofs.
%Some of them have a theoretical background that leads to see proofs as programs and programs as proofs.

%Coordination models are models used mainly to describe concurrent and distributed computational systems. The purpose of such models is to enable software engineering based on heterogeneous software components, providing means on how these components interact with each other. Among other advantages, this enables fast deployment of new systems, by reusing already existing software that has been tested and is in a productive environment, which also reduces development costs. Building software following this idea requires a way to coordinate how their components will interact with each other.

%The development of systems based on SOA employing model-driven development has been proved to be a valuable approach~\cite{papazoglou2007service}. The formal verification of models that the development process is based upon enables the detection of errors that could appear only in posterior phases of software development, or even when the software reaches a productive environment, thus avoiding unplanned costs and even greater losses.

Reo's ability to model communication between software interfaces has also attracted research on verification of Reo circuits, resulting in many different formal semantics~\cite{Jongmans2012} like automata-based models~\cite{Arbab2006,Baier2005,Kokash2010}, coalgebraic models~\cite{Arbab2004}, Intuitionistic Logic with Petri Nets~\cite{Clarke2007} (to name a few), and some of their implementations~\cite{Kokash2012,Sun2014,Li2016,Li2017,Li2018,Zhang2019,Kokash2010}. However, as far as the authors are concerned, there is no logic apart from \relo~\cite{Grilo2020-2} to specific reason about Reo models naturally, where the usage of other logic-based approaches requires conversion between different formal semantics.

%The adopted approach here proposed is twofold.
This work extends \relo~\cite{Grilo2020-2} by introducing an iteration operator and the soundness and completeness proofs of its axiomatic system. A prototypical implementation of this framework in Coq proof assistant, enabling the verification of properties of Reo programs in \relo\ within a computerized environment is available at \url{http://github.com/frame-lab/ReoLogicCoq}.%, and (iii) the definition of a tableau-based syntactic proof system for this logic, followed by the implementation of core definitions of this tableau, enabling the syntactic reasoning of \relo\ in Coq.

This work is structured as follows. Section~\ref{sec:rlf} discusses briefly a related logic formalism with the one hereby proposed and introduces Reo modelling language, along with some examples. %and a brief introduction to two of Reo's formal semantics: Timed Data Streams and Constraint Automata.
 Section~\ref{sec:reloDef} discuss \relo's main aspects, from its core definitions (such as language, models, transitions firing) and its soundness and completeness proofs.
 %Section~\ref{sec:reloApproach} discuss thoroughly a \relo\ formalization in Coq proof assistant of the core concepts defined in Section~\ref{sec:reloDef}. Section~\ref{sec:usageEx} introduces some usage examples of \relo\ and its Coq implementation.
 Finally, Section~\ref{sec:conclusions} closes the work by discussing the obtained results and assessing possible future work.


\section{Related Work} \label{sec:related}

The fact that Reo can be used to model many real-world situations has attracted attention from researchers all around the world, resulting in a great effort directed in formalizing means to verify properties of Reo models~\cite{Klein2011,Pourvatan2009,Kokash2011,Kokash2012,Mousavi2006,Li2019,Jongmans2012}. Such effort also resulted in the proposal of several formal semantics for this modelling language~\cite{Jongmans2012}, varying from operational semantics to coalgebric models.

One of the most known formal semantics for Reo consists of Constraint Automata~\cite{Baier2006}, an operational semantic in which Reo connectors are modelled as automata for $TDS$-languages~\cite{Arbab2002A}. It enables reasoning over the data flow of Reo connectors and when they happened. Constraint Automata have been extended to some variants which aim to enrich the reasoning process by capturing properties like the timing of the data flows or possible actions over the data, respectively as Timed Constraint Automata~\cite{Kokash2012} and Action Constraint Automata~\cite{Kokash2010-2}. Some of them are briefly discussed below, along with other formal semantics for Reo.

The approach presented by Klein et al.~\cite{Klein2011} provides a platform to reason about Reo models using Vereofy,\footnote{\url{http://www.vereofy.de}} a model checker for component-based systems, while Pourvatan et al.~\cite{Pourvatan2009} propose an approach to reason about Reo models employing symbolic execution of Constraint Automata. Kokash \& Arbab~\cite{Kokash2011} formally verify Long-Running Transactions (LRTs) modelled as Reo connectors using Vereofy, enabling expressing properties of these connectors in logics such as Linear Temporal Logic (LTL) or a variant of Computation Tree Logic (CTL) named Alternating-time Stream Logic (ASL). Kokash et al.~\cite{Kokash2012} use mCRL2 to encode Reo's semantics in Constraint Automata and other automata-based semantics, encoding their behaviour as mCRL2 processes and enabling the expression of properties regarding deadlocks and data constraints which depend upon time. mCRL2 also supports model-checking of Reo in a dynamic logic (with fixed points), where modalities are regular expressions, atomic actions are sets of nodes that fire at the same time. Mouzavi et al.~\cite{Mousavi2006} propose an approach based on Maude to model checking Reo models, encoding Reo's operational semantics of the connectors. %Li et al.~\cite{Li2019} propose a real-time extension to Reo, implementing new channels and relying on Stochastic Timed Automata for Reo (STA) as its formal semantics, also providing a translation of STA to PRISM\footnote{\url{https://www.prismmodelchecker.org}} for model checking. UPPAAL\footnote{\url{http://www.uppaal.org/}} model checker has also been employed in the verification of Reo connectors employing the usage of Timed Constraint Automata~\cite{Arbab2007} to build the corresponding UPPAAL model and in the simulation of Hybrid Reo Connectors~\cite{Ardeshir2020}.

Proof assistants have been used to reason about Reo connectors~\cite{Li2015,Li2017,Li2018,Li2016,Zhang2019,REOJAL}. The approaches adopted by Li et al.~\cite{Li2015,Li2016,REOJAL} are among the ones that employ Coq to verify Reo models formally. In~\cite{Li2015} a formalization of four of the Reo canonical connectors (Sync, FIFO1, SyncDrain, and LossySync) along with an LTL-based language defined as an inductive type in Coq is presented, while~\cite{Li2016} proposes the formalization of five Reo canonical channels
%: Sync, SyncDrain, FIFO1, Asyncdrain, and LossySync
and a procedure that creates composite channels by logical conjunction of the connectors modelled. 
%(Sync, Fifo, SyncDrain, AsyncDrain, LossySync and Merge)
%They are modelled as logical propositions in Coq, where their behavior is defined as conjunctions regarding data and time constraints on streams denoting input and output of the automaton. Both formalizations implement the notion of Timed Data Streams as the first formalization of semantics of Reo connectors~\cite{Jongmans2012}.

In~\cite{REOJAL}, a framework to provide means of graphically model Reo connectors and validate the generated model in Constraint Automata using Coq and NuSMV\footnote{\url{https://nusmv.fbk.eu/}} is discussed. It also enables the automatic generation of Coq code to a Haskell model employing the Coq code extraction apparatus.
%The implementation proposed by Li et al.~\cite{Li2015} formalizes a LTL-based language, which enables bounded model checking on these connectors. However, it lacks any automatic composition operation for formalized connectors. Therefore, the composition of Reo channels need to be manually written by the user. The approach employed by Li et al.~\cite{Li2016} implements the composition of Reo connectors employing logical conjunction of connectors' behaviour, denoted by their respective TDS.
%
When restricting the works considering logics and Reo, as far as the authors know there is only the work by~\cite{Clarke2007} which focuses on formalizing the semantics of Reo connectors Sync, LossySync, FIFO1, SyncDrain, AsyncDrain, Filter, Transform, Merger, and Replicator in terms of zero-safe Petri nets~\cite{Bruni2000}, a special class of Petri-nets with two types of places: zero and stable places. This encoding is then converted to terms in Intuitionistic Temporal Linear Logic, enabling reasoning about Reo connectors in this logic.

%\relo~\cite{Grilo2020-2} is a dynamic logic tailored to reason about Reo models, with a sound and complete axiomatization. Based on Kripke frames, \relo\ provides a framework in which one can directly formalize properties in its language, and check whether a Reo circuit as a \relo\ model satisfies such properties. Formulas in \relo\ are composed of symbols and indexed modalities, similar to other dynamic logics~\cite{Harel2001} to model program execution, and may be combined with logical connectives to compose other formulae. A formula $\lbrack t , \pi \rbrack \varphi$ in \relo\ captures a Reo model as a \relo\ program $\pi$, its data flow $t$ and a property $\varphi$, stating that ``$\varphi$ holds '' in every program state reached from the current state, by executing $\pi$ with $t$. The core concepts are formalized in the Coq proof assistant\footnote{\url{https://github.com/frame-lab/ReoLogicCoq}}.



