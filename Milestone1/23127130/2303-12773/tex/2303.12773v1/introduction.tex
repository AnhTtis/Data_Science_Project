\section{Introduction}\label{sec:introduction}
%

Datalog has emerged in the 1980s as a logic-based query language from Logic Programming and has been extensively studied since then~\cite{AbHV95}. The name Datalog reflects the intention of devising a counterpart of Prolog for data processing. It essentially extends the language of unions of conjunctive queries, which corresponds to the select-project-join-union fragment of relational algebra, with the important feature of recursion, much needed to express some natural queries.
%
Among numerous applications, Datalog has been heavily used in the context of ontological query answering. In particular, for several important ontology languages based on description logics and existential rules, ontological query answering can be reduced to the problem of evaluating a Datalog query (see, e.g.,~\cite{EOSTX12,BBGKM22}), which in turn enables the exploitation of efficient Datalog engines such as DLV~\cite{LPFEGPS06} and Clingo~\cite{GKKOSW16}.


As for any other query language, explaining why a result to a Datalog query is obtained is crucial towards explainable and transparent data-intensive applications. A standard way for providing such explanations to query answers is the so-called {\em why-provenance}~\cite{BuKT01}.
%
Its essence is to collect all the subsets of the input database that are sufficient to derive a certain answer. More precisely, in the case of Datalog queries, the why-provenance of an answer tuple $\bar t$ is obtained by considering all the possible proof trees $T$ of the fact ${\rm Ans}(\bar t)$, with ${\rm Ans}$ being the answer predicate of the Datalog query in question, and then collecting all the database facts that label the leaves of $T$. Recall that a proof tree of a fact $\alpha$ w.r.t.~a database $D$ and a set $\dep$ of Datalog rules forms a tree-like representation of a way for deriving $\alpha$ by starting from $D$ and executing the rules occurring in $\dep$~\cite{AbHV95}.


There are recent works that studied the concept of why-provenance for Datalog queries. In particular, there are theoretical studies on computing the why-provenance~\cite{DaAA13,DMRT14}, attempts to under-approximate the why-provenance towards an efficient computation~\cite{ZhSS20}, studies on the restricted setting of non-recursive Datalog queries~\cite{LeLG19}, attempts to compute the why-provenace by transforming the grounded Datalog rules to a system of equations~\cite{EsLS14}, and attempts to compute the why-provenance on demand via transformations to existential rules~\cite{ElKM22}.


Despite the above research activity on the concept of why-provenance for Datalog queries, to our surprise, there is still a fundamental question that remains unexplored: 

\medskip

\noindent {\em \textbf{Main Research Question:} What is the exact computational complexity of why-provenance for Datalog queries?}

\medskip

\noindent The goal of this work is to provide an answer to the above question. To this end, for a Datalog query $Q$, we study the complexity of the following algorithmic problem, dubbed $\mathsf{Why\text{-}Provenance}[Q]$: given a database $D$, an answer $\bar t$ to $Q$ over $D$, and a subset $D'$ of $D$, is it the case that $D'$ belongs to the why-provenance of $\bar t$ w.r.t.~$D$ and $Q$? Pinpointing the complexity of the above decision problem will let us understand the inherent complexity of why-provenance for Datalog queries w.r.t.~the size of the database, which is precisely what matters when using why-provenance in practice.



\medskip
\noindent \textbf{Our Contribution.} The takeaway of our complexity analysis is that explaining Datalog queries via why-povenance is, in general, an intractable problem. In particular, for a Datalog query $Q$, we show that $\mathsf{Why\text{-}Provenance}[Q]$ is in \NP, and there are queries for which it is \NP-hard.
%
We further analyze the complexity of the problem when $Q$ is linear (i.e., the recursion is restricted to be linear) or non-recursive, with the aim of clarifying whether the feature of recursion affects the inherent complexity of why-provenance.
%
We show that restricting the recursion to be linear does not affect the complexity, namely the problem is in \NP~and for some queries it is even \NP-hard. However, completely removing the recursion significantly reduces the complexity; in particular, we prove that the problem is in $\ACZ$.


It is clear that the notion of why-provenance for Datalog queries, and hence the problem $\mathsf{Why\text{-}Provenance}[Q]$, heavily rely on the notion of proof tree. However, as already discussed in the literature (see, e.g., the recent work~\cite{BBPT22}), there are proof trees that are counterintuitive since they represent unnatural derivations (e.g., a fact is used to derive itself, or a fact is derived in several different ways), and this also affects the why-provenance.
%
With the aim of overcoming this conceptual limitation of proof trees, we propose the class of unambiguous proof trees. All occurrences of a fact in such a proof tree must be proved via the same derivation. We then study the problem $\mathsf{Why\text{-}Provenance}[Q]$ focusing on unambiguous proof trees, and show that its complexity remains the same.
%, namely it is in~\NP for (linear) Datalog queries, and in $\ACZ$ for non-recursive Datalog queries. 
This should be perceived as a positive outcome as we can overcome the limitation of arbitrary proof trees without increasing the complexity.


We finally verify that unambiguous proof trees, apart from their conceptual advantage, also help to exploit off-the-shelf SAT solvers towards an efficient computation of the why-provenance for Datalog queries. In particular, we discuss a proof-of-concept implementation that exploits the state-of-the-art SAT solver Glucose (see, e.g.,~\cite{Audemard18}), and present encouraging results based on queries and databases that are coming from the Datalog literature.


\medskip

\noindent {\em An extended version with further details, as well as the experimental scenarios and the source code, can be found at https://gitlab.com/mcalautti/datalog-why-provenance.}





\begin{comment}
Here is a simple example that illustrates the notion of why-provenance in the case of Datalog queries:

\begin{example}
	Consider the reachability query that can be expressed via the Datalog query consisting of the rules
	\[
	T(x,y)\ \emph{\assign}\ E(x,y)  \qquad T(x,y)\ \emph{\assign}\ T(x,z),E(z,y),
	\]
	where $E$ stores a directed graph and the answer is the content of the binary relation $T$ after executing the above rules on the input database, i.e., $T(a,b)$ means that $b$ is reachable from $a$. Consider also the database
	\[
	D\ =\ \{E(a,b),E(b,c),E(c,d)\}. 
	\]
	It is clear that the tuple $(a,c)$ is an answer to $Q$ over $D$, which is witnessed by the proof tree
	
	\centerline{\includegraphics[width=.27\textwidth]{proof-tree-1.pdf}}
\end{example}
\end{comment}



