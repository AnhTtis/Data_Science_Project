\section{Data Complexity of Why-Provenance}\label{appsec:all-trees}

In this section, we provide the missing details for Section~\ref{sec:complexity}.

\subsection{Recursive Queries}
%

We proceed to give the full proof of Theorem~\ref{the:recursive-complexity}, which we recall here for convenience:

\begin{manualtheorem}{\ref{the:recursive-complexity}}
	\therecursivecomplexity
\end{manualtheorem}


To prove the above result, it suffices to show that:
\begin{itemize}
	\item $\mathsf{Why\text {-}Provenance[\DAT]}$ is in \NP~in data complexity.
	\item $\mathsf{Why\text {-}Provenance[\LDAT]}$ is \NP-hard in data complexity.
\end{itemize}



\medskip
\noindent \underline{\textbf{Upper Bound}}
\smallskip

\noindent Our main task is to prove Proposition~\ref{pro:characterization-all-trees}, which we recall below, that will allow us to devise a guess-and-check procedure that runs in polynomial time in the size of the database.

\begin{manualproposition}{\ref{pro:characterization-all-trees}}
	\procharacterizationalltrees
\end{manualproposition}

The direction $(2)$ implies $(1)$ is shown by ``unravelling'' the proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ into a proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = \support{G}$. 
More precisely, we go over the nodes of $G$ starting from its root and ending at its leaves using breadth-first search. Whenever we encounter a node $v$ that has $k$ incoming edges, we create $k$ copies of its subDAG. The subDAG of a node $v$ contains $v$ itself and every node reachable from $v$, and an edge $(u_1,u_2)$ if there is an edge $(w_1,w_2)$ in $G$, where $u_1$ is a copy of $w_1$ and $u_2$ is a copy of $w_2$. Note that these copies preserve the labels of the nodes. We then replace each incoming edge of $v$ with an edge to the root of a distinct copy of its subDAG. Note that since $G$ is acyclic, the above operation on $v$ has no impact on the nodes that have been processed before $v$.
It is rather straightforward that the result is a tree $T$ with a root $v$ that has the same label as the root of $G$, and where the leaves have the same labels as the leaves of $G$ (hence, for each leaf $v$ of the tree we have that $\lambda(v)\in D$, as the same holds for the labels of the leaves of the proof DAG). Moreover, it is easy to verify that Property~(3) of Definition~\ref{def:proof-tree} holds since $G$ satisfies the equivalent property~$(3)$ of Definition~\ref{def:proof-dag} and our copies preserve the labels of the nodes. Therefore, the resulting tree is a proof tree of $\alpha$ w.r.t.~$D$ and $\Sigma$. 

Concerning the direction $(1)$ implies $(2)$, as discussed in the main body of the paper, the proof proceeds in three main steps captured by Lemmas~\ref{lem:depth-reduction},~\ref{lem:scount-reduction}, and~\ref{lem:from-trees-to-dags}, which we prove next.

\begin{manuallemma}{\ref{lem:depth-reduction}}
	\lemmadepthreduction
\end{manuallemma}
\begin{proof}
	We prove the claim for $f(|D|)=|\base{D,\dep}|\times |D|$ by induction on $n = \depth{T}$.
	
	\medskip
	\noindent \textbf{Base Case.} For any $n\le |\base{D,\dep}|\times |D|$, the claim holds trivially.
	
	\medskip
	\noindent \textbf{Inductive Step.} We assume that the claim holds for $n \in \{|\base{D,\dep}|\times |D|,\dots,p\}$, and prove that it holds for $n=p+1$. Let $T$ be a proof tree of $\alpha$ w.r.t.~$D$ and $\Sigma$ with $\depth{T} = p+1$. Since $p+1>|\base{D,\dep}|\times |D|$, there exists a path $v_1\rightarrow v_2\dots\rightarrow v_{p+2}$ of length $p+1$ in $T$ and a label $\beta$, such that $\beta$ is the label of $k>|D|$ nodes $v_{i_1},\dots,v_{i_k}$ along the path. (Note that $|\base{D,\dep}|$ is an upper bound on the number of distinct labels in $T$.) We assume, without loss of generality, that $i_1<i_2<\dots<i_k$.
	We will show that for some $v_{i_j}$ and $v_{i_r}$ with $j< r$, it holds that
	\[
	\support{T[v_{i_j}]}\ =\ \support{T[v_{i_r}]}. 
	\]
	Recall that for a node $v$, $T[v]$ is the subtree of $T$ rooted at $v$.
	
	An easy observation is that for $T_1,T_2$ such that $T_2$ is a subtree of $T_1$, it holds that $\support{T_2}\subseteq\support{T_1}$.
	Hence, for all $j<r$, we have that: 
	\[
	\support{T[v_{i_r}]}\subseteq\support{T[v_{i_j}]}.
	\]
	Now assume, towards a contradiction, that for every $j<r$,
	\[\support{T[v_{i_r}]}\subsetneq\support{T[v_{i_j}]}.\] 
	We then conclude that
	\[
	\support{T[v_{i_k}]}\subsetneq\dots\subsetneq \support{T[v_{i_1}]}.
	\]
	This means that $\support{T[v_{i_1}]}$ contains $k>|D|$ distinct facts, which in turn means that $\support{T}$ contains at least $k>|D|$ distinct facts. This is a contradiction to the fact that $\support{T}=D'$ for some $D'\subseteq D$. 
	
	
	Therefore, for some $j<r$ it holds that 
	\[
	\support{T[v_{i_r}]}=\support{T[v_{i_j}]}.
	\]
	We can now shorten the path $v_1\rightarrow v_2\dots\rightarrow v_{p+2}$ in $T$ and obtain another proof tree $T_1$ with the same support $D'$, by replacing the subtree $T[v_{i_j}]$ with the subtree $T[v_{i_r}]$. An important observation here is that $T_1$ is still a proof tree of $\alpha$ w.r.t.~$D$ and $\Sigma$. Since we do not modify the root node $v$, it still holds that $\lambda(v)=\alpha$. Moreover, the set of leaves of $T_1$ is contained in the set of leaves of $T$; hence, for every leaf $v$ of $T_1$ it holds that $\lambda(v)\in D$. Finally, since $T[v_{i_r}]$ is a subtree of $T$, it satisfies property $(3)$ of Definition~\ref{def:proof-tree} (that is, if $v$ is a node with $n\ge1$ children $u_1,\ldots,u_n$, then there is a rule $R_0(\bar x_0)\ \assign\ R_1(\bar x_1),\ldots,R_n(\bar x_n) \in \dep$ and a function $h : \bigcup_{i \in [n]} \bar x_i \ra \ins{C}$ such that $\lambda(v) = R_0(h(\bar x_0))$, and $\lambda(u_i) = R_i(h(\bar x_i))$ for each $i \in [n]$). Therefore, this property also holds for every node $v$ of $T_1$ (for the parent of the node $v_{i_j}$ that we replace with the node $v_{i_r}$ the property holds because $\lambda(v_{i_j})=\lambda(v_{i_r})$).
	
	Clearly, when applying the above procedure, we eliminate at least one path of length $p+1$ and we do not introduce any new path of length $p+1$.
	If we repeat this process for every path of length $p+1$, we will eventually obtain a proof tree $T_2$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\depth{T_2} \le p$ and $\support{T_2} = D'$. The claim follows by the inductive hypothesis.
\end{proof}

Before proving Lemma~\ref{lem:scount-reduction}, we show the following result, where we do not consider the support of the proof tree. 

\begin{lemma}\label{lem:exists-unumbiguous-tree}
	For each Datalog program $\dep$, database $D$ over $\esch{\dep}$, and fact $\alpha$ over $\sch{\dep}$, if there exists a proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$, then there exists also such a proof tree $T'$ with $|\quot{T'[\beta]}| =1$ for every fact $\beta$ that occurs in $T'$.
\end{lemma}
\begin{proof}
	Let $T=(V,E,\lambda)$ be a proof tree of $\alpha$ w.r.t.~$D$ and $\dep$. We construct another proof tree $T'=(V',E',\lambda')$ of $\alpha$ w.r.t.~$D$ and $\dep$ with the desired property in the following way. Let $S$ be the set that contains, for every fact $\beta$ that occurs in $T$ (i.e., it is the label of some node in $V$), one subtree $T[v]$ of $T$ with $\lambda(v)=\beta$ of smallest depth among all such subtrees; if more than one such tree exists, we choose one arbitrarily. For every $1\le i\le \depth{T}$, let $S^i$ be the set that contains all the trees of $S$ of depth exactly $i$. We will now inductively construct a set of trees that will contain a single representative tree for every fact $\beta$ that occurs in $T$. Then, we will use the representative tree of $\alpha$ as the tree $T'$.
	
	We define:
	\begin{itemize}
		\item $Z_1 = S^1$;
		\item $Z_{i+1} = \mathsf{Op}^{i+1}(Z_i) \cup Z_i$, for $i\ge 1$.
	\end{itemize}
	where $\mathsf{Op}^{i+1}(Z_i)$ contains, for every tree $T''$ in $S^{i+1}$, the tree that is obtained from it using the following procedure. Let $u_1,\dots,u_n$ be the direct children of the root of $T''$. For every child $u_j$ with $\lambda(u_j)=\beta$, we replace the subtree $T''[u_j]$ with a tree of $Z_i$ whose root is labeled with $\beta$. Intuitively, the existence of such a tree is guaranteed because $S$ contains a smallest depth subtree for each fact, and since $T''[u_j]$ is of depth at most $i$, the set $S$ has a tree of depth at most $i$ rooted with a node labeled with $\beta$.
	Formally, we prove the following properties of the sets $Z_i$:
	\begin{enumerate}
		\item For every label $\beta$, if $S^i$ contains a tree with root $v$ such that $\lambda(v)=\beta$, then $Z_i$ contains a tree with root $u$ such that $\lambda(u)=\beta$.
		\item For every label $\beta$, if $Z_i$ contains a tree with root $u$ such that $\lambda(u)=\beta$, then there is a tree $T''$ with root $w$ such that $\lambda(w)=\beta$ and $T''\in S^{k}$ for some $k\le i$.
		\item For every label $\beta$, if $Z_i$ contains a tree with root $u$ such that $\lambda(u)=\beta$, then there is precisely one such tree.
		%\item If $T''\in S^i$, $v$ it the root of $T''$, and $u_1,\dots,u_n$ are the non-leaf children of $v$ in $T''$, then for every $u_j$ with $\lambda(u_j)=\beta$, there exists a tree in $Z_{i-1}$ with root $w$ such that $\lambda(w)=\beta$. 
		\item For every tree $T''$ of $Z_i$, if $u$ is a leaf node of $T''$, then $\lambda(u)\in D$.
		\item For every tree $T''$ of $Z_i$, if $u$ is a node of $T''$ with $n\ge1$ children $u_1,\ldots,u_n$, then there exists a rule $R_0(\bar x_0)\ \assign\ R_1(\bar x_1),\ldots,R_n(\bar x_n)$ in $\dep$ and a function $h : \bigcup_{i \in n} \bar x_i \ra \ins{C}$ such that $\lambda(u) = R_0(h(\bar x_0))$ and $\lambda(u_j) = R_j(h(\bar x_j))$, for $j \in [n]$.
		\item For every tree $T''$ of $Z_i$, $|\quot{T''[\beta]}| =1$, for each fact $\beta$ that occurs in $T''$.
	\end{enumerate}
	We prove all six properties by induction on $i$. 
	
	\medskip
	\noindent \textbf{Base Case.} For $i=1$, the first two properties trivially hold as $Z_1=S^1$ by definition. Since $S$ contains a single tree for each fact $\beta$ (i.e., a tree where the root is labeled with $\beta$), so does $S^1$, and the third property also holds. 
	The fourth and fifth properties hold because every tree of $S^1$ (and so every tree of $Z_1$) is a subtree of a proof tree, and these are properties of proof trees. The last property is satisfied since a tree of $Z_1$ contains one root node $v$ and its children $u_1,\dots,u_n$, and it cannot be the case that $\lambda(v)=\lambda(u_j)$ for some $j \in [n]$ (as the leaves correspond to extensional predicates, while the root corresponds to an intentional predicate).
	
	\medskip
	\noindent \textbf{Inductive Step.} We assume that the claim holds for $i=1,\dots,p$ and prove that it holds for $i=p+1$. 
	The first property holds by construction, since the set $\mathsf{Op}^{p+1}(Z_{p})$ contains, for every tree $T''$ of $S^{p+1}$, another tree with the same root (we only modify the subtrees of its children). Moreover, if the children of the root of $T''$ are $u_1,\dots,u_n$, then for every $r\in [n]$, the subtree $T''[u_r]$ (which is also a subtree of the original $T$) is of depth at most $p$. Hence, the smallest depth subtree for the label $\lambda(u_r)$ in $T$ occurs in $S_k$ for some $1\le k\le p$. By the inductive assumption, the set $Z_k$ contains a tree with root $v$ such that $\lambda(v)=\lambda(u_r)$, and since $Z_k\subseteq Z_{p}$, this tree also appears in $Z_{p}$; hence, our construction is well-defined.
	
	
	The second property is satisfied since every tree of $Z_{p+1}$ with root $u$ such that $\lambda(u)=\beta$ either occurs in $Z_p$ or is obtained from a tree of $S_{p+1}$. In the first case, the inductive assumption implies that there is a tree $T''$ with a root $w$ and $\lambda(w)=\beta$ in $S^k$ for some $k\le p$. In the second case, the definition of $\mathsf{Op}^{p+1}(Z_{p})$ implies that there is a tree $T''$ with a root $w$ and $\lambda(w)=\beta$ in $S^{p+1}$.
	
	The third property holds because $S^{p+1}$ contains a single tree per fact, and so the same holds for $\mathsf{Op}^{p+1}(Z_{p})$. Moreover, $Z_p$ contains a single tree per fact due to the inductive assumption. We will show that it cannot be the case that there is a label $\beta$ and two trees $T_1,T_2$ such that: \textit{(1)} $\lambda(v_1)=\beta$ for the root $v_1$ of $T_1$, \textit{(2)} $\lambda(v_2)=\beta$ for the root $v_2$ of $T_2$, \textit{(3)} $T_1\in Z_p$, and \textit{(4)} $T_2\in \mathsf{Op}^{p+1}(Z_{p})$. Assume, towards a contradiction, that such two trees exist. Then, $S^{p+1}$ contains a tree $T_3$ with root $v_3$ such that $\lambda(v_3)=\beta$ (this is the tree from which $T_2$ is obtained). Moreover, the inductive assumption and property $(2)$ imply that there is a tree $T_4$ with root $v_4$ in $S^k$ for some $k\le p$ such that  $\lambda(v_4)=\beta$. We conclude that $S$ contains two trees whose root is labeled with $\beta$ -- one with depth $p+1$ and one with depth $k\le p$. This is a contradiction to the fact that $S$ only contains one smallest depth subtree of $T$ whose root is labeled with $\beta$.
	
	As for the fourth property, as aforementioned, every tree $T''$ of $Z_{p+1}$ either occurs in $Z_p$ or is obtained from a tree of $S_{p+1}$. In the first case, the claim immediately follows from the inductive assumption. In the second case, let $T''$ be a tree of $\mathsf{Op}^{p+1}(Z_{p})$. Assume that the root of $T''$ is $u$ and its children are $u_1,\dots,u_n$. Then, every leaf node of $T''$ is also a leaf node of $T''[u_j]$ for some $j\in [n]$, and since $T''[u_j]$ is a tree of $Z_p$ by construction, we have that $\lambda(u_j)\in D$ by the inductive assumption.
	
	The fifth property holds for every tree of $Z_p$ by the inductive assumption. We will show that it also holds for every tree $T''$ of $\mathsf{Op}^{p+1}(Z_{p})$.
	Each tree of $S^{p+1}$ is a subtree of $T$; hence, it satisfies the desired property (which is a property of proof trees). In particular, the property is satisfied by the root node, and since we do not modify the label of the root node or the labels of its children, the root of the obtained tree $T''$ also satisfies this property. For every child of the root, its subtree is replaced with a tree from $Z_{p}$ that satisfies the desired property by the inductive assumption, and so every node of $T''$ satisfies this property.
	
	Finally, for a tree of $Z_{p+1}$ that also occurs in $Z_p$, the last property holds from the inductive assumption. For a tree $T''$ of $Z_{p+1}$ that comes from $\mathsf{Op}^{p+1}(Z_{p})$, the last property holds for every label $\delta$ that occurs in $T''$ and is not the label of the root, due to the inductive assumption (since we replace the subtrees under the children of the root with trees from $Z_p$). Note that the label $\beta$ of the root of $T''$ cannot occur in a tree of $Z_p$ (and, in particular, as the label of one of its children). This holds since $Z_p\subseteq Z_{p+1}$ and due to property $(3)$ that we have already proved. Thus, it also holds that $|\quot{T''[\beta]}| =1$.
	This concludes our proof for the six properties.
	
	Now, by definition, $S$ contains a tree $T_1$ whose root is labeled with $\alpha$. Assume that the depth of this tree is $k$, then $T_1\in S^k$. Property $(1)$ then implies that $Z_k$ contains a tree $T_2$ whose root is labeled with $\alpha$. It is only left to show that this tree is a proof tree of $\alpha$ w.r.t.~$D$ and $\dep$ that satisfies the desired properties, and then we will define $T'=T_2$, and that will conclude our proof. The first property of proof trees (Definition~\ref{def:proof-tree}) is clearly satisfied as $\lambda(v)=\alpha$ for the root node $v$ of $T_2$. Properties $(2)$ and $(3)$ of proof trees are satisfied due to properties $(4)$ and $(5)$, respectively, of the sets $Z_i$. Hence, $T_2$ is indeed a proof tree of $\alpha$ w.r.t.~$D$ and $\dep$. Property $(6)$ of the sets $Z_i$ implies that $|\quot{T_2[\beta]}| =1$, for each fact $\beta$ that occurs in $T_2$. Therefore, we can indeed define $T'=T_2$ and obtain the desired proof tree.
\end{proof}

We now proceed to prove Lemma~\ref{lem:scount-reduction}, which we recall here:

\begin{manuallemma}{\ref{lem:scount-reduction}}
	\lemmascountreduction
\end{manuallemma}
\begin{proof}
	Given a proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\depth{T}\le f(|D|)$ and $\support{T}=D'$, we construct another proof tree $T'$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\scount{T'} \leq g(|D|)$ and $\support{T'}=D'$ in two steps. First, for every fact of $D'$, we select one path in $T$ from the root to a leaf labeled with this fact. Then, we ``freeze'' those paths (i.e., we do not modify them in $T'$) in order to preserve the support. However, it is not sufficient to keep only these paths, but we also need to keep the siblings of each node along these paths to obtain a valid proof tree, and, in particular, to satisfy the last property of Definition~\ref{def:proof-tree}. The second step is then to reduce, for every sibling node $v$ and for every fact $\beta$ in $T[v]$, the number of equivalence classes in $\quot{T[v][\beta]}$.
	
	Let $v$ be a node of $T$. An easy observation is that if $\lambda(v)=\beta$ for some fact $\beta$, then $T[v]$ is a proof tree of $\beta$ w.r.t.~$D$ and $\dep$. Then, Lemma~\ref{lem:exists-unumbiguous-tree} implies that there exists another proof tree $T_v$ of $\beta$ w.r.t.~$D$ and $\dep$ whose root node is labeled with $\beta$, such that $|\quot{T_v[\delta]}| =1$, for every fact $\delta$ that occurs in $T_v$. We can then replace the subtree $T[v]$ of $T$ with the tree $T_v$. We do that for each sibling node. Clearly, the tree $T'$ that we obtain via this procedure remains a proof tree of $\alpha$ w.r.t.~$D$ and $\dep$. This holds since we do not modify the label of the root; hence, Property~$(1)$ of Definition~\ref{def:proof-tree} holds. Moreover, Property~$(2)$ of Definition~\ref{def:proof-tree} holds because the set of leaves of $T'$ is a subset of the set of leaves of $T$ (due to the construction in the proof of Lemma~\ref{lem:exists-unumbiguous-tree}). Finally, Property~$(3)$ of Definition~\ref{def:proof-tree} is satisfied for every node in a subtree $T_v$ since, as aforementioned, every $T_v$ is a proof tree of some fact w.r.t.~$D$ and $\dep'$. Moreover, this property holds for every node along the frozen paths because for each such path $v_1\ra\dots\ra v_n$, if $u_1,\dots,u_m$ are the children of $v_j$, then one of these children is $v_{j+1}$ and we do not modify its label or the labels of its siblings (we only replaces the subtrees underneath them).
	It is only left to show that $T'$ satisfies the desired property.
	
	To this end, we observe that: \textit{(1)} every fact $\beta$ in $T'$ occurs polynomialy many times on the frozen paths, and \textit{(2)} there are polynomialy many such sibling nodes. Property $(1)$ holds since $\depth{T} \le f(|D|)$ for some polynomial $f$; hence, there are polynomialy many nodes on a path (at most $f(|D|)+1$). Moreover, since we freeze one path per fact of $D'$, there are $|D'|$ paths. Hence, each fact occurs at most $[f(|D|)+1]\times |D'|$ times on the frozen paths. Property $(2)$ holds because each node on a frozen path has at most $b-1$ siblings, where $b$ is the maximal number of atoms occurring in the body of some rule in $\Sigma$. Therefore, the number of sibling nodes is bounded by $[f(|D|)+1]\times |D'|\times (b-1)$. Due to our construction, for every fact $\beta$ that occurs in a subtree $T''$ of some sibling node, it hold that $|\quot{T''[\beta]}|=1$. Therefore, 
	\[|\quot{T'[\beta]}|\ \le\ [f(|D|)+1]\times |D'| \times b \]
	(one equivalence class for each node on the frozen paths, and one equivalence class for each sibling node). The claim then follows with:
	\[g(|D|)\ =\ [f(|D|)+1]\times |D'| \times b.\]
	This concludes our proof.
\end{proof}

Finally, we prove Lemma~\ref{lem:from-trees-to-dags}, which we recall here:

\begin{manuallemma}{\ref{lem:from-trees-to-dags}}
	\lemmafromtreestodags
\end{manuallemma}
\begin{proof}
	Our goal here is to construct a DAG $G=(V,E,\lambda)$ that contains, for every fact $\beta$ that occurs in $T$, and every equivalence class of $\quot{T[\beta]}$, a single DAG representing this class. To this end, we first add, for every fact $\beta$ that occurs in $T$, and every equivalence class $C_{\beta}$ of $\quot{T[\beta]}$, $k$ nodes $v^{C_{\beta}}_1,\dots,v^{C_{\beta}}_k$ to $V$, where $k$ is the maximal number of occurrences of the trees of $C_{\beta}$ under a single node of $T$. Clearly, $k\le b$, where $b$ is the maximal number of atoms occurring in the body of some rule in $\Sigma$. We then define $\lambda(v^{C_{\beta}}_j)=\beta$ for every $j\in [k]$. Note that the tree $T$ itself belongs to some equivalence class $C\in\quot{T[\alpha]}$ (since $\lambda(v)=\alpha$ for the root node $v$ of $T$ by the definition of proof trees), and this tree does not appear under any node of $T$; hence, for this equivalence class we have that $k=0$. In this case, we add a single node $v^{C}$ to $V$.
	
	Next, we add the edges $(v^{C_{\beta}}_j,v^{C'_{\beta'}}_{1}),\dots,(v^{C_{\beta}}_j,v^{C'_{\beta'}}_{p})$ to $E$ if for every tree $T'$ of $C$ with root $v$, we have that $T'[u]\in C'$ for precisely $p$ children $u$ or $v$. (Observe that this either holds for all trees of $C$ or none of them, since $C$ is an equivalence class.) The number of nodes in $V$ is bounded by $|\base{D,\dep}|\times f(|D|)\times b$ as the number of facts that occur in $T$ is bounded by $|\base{D,\dep}|$, there are at most $f(|D|)$ equivalence classes for each fact, and we have at most $b$ nodes for each combination of a fact and its equivalence class; hence, by defining 
	\[
	g(|D|)\ =\ |\base{D,\dep}|\times f(|D|)\times b,
	\]
	$|V|\le g(|D|)$. It remains to show that $G$ is a proof DAG.
	
	Let $v$ be the root of the proof tree $T$. As aforementioned, the subtree of $v$ (which is $T$ itself) belongs to some equivalence class $C$ of $\quot{T[\alpha]}$, and we have a node $v^C$ in $V$ with $\lambda(v^C)=\alpha$. Clearly, there is no other node $u\neq v$ in $T$ such that $T[u]\in C$; hence, by the definition of $E$, the node $v^C$ has no incoming edges. Contrarily, for every other equivalence class $C_\beta$ of some fact $\beta$, if $V$ contains precisely $k$ nodes $v^{C_\beta}_1,\dots,v^{C_\beta}_k$ corresponding to this class, then there exists, by definition, a node $u$ in $T$ with $\lambda(u)=\delta$ for some $\delta$ that has $k$ children $u_1,\dots,u_k$ whose subtrees all belong to $C_\beta$. In this case, $E$ contains the edges  $(v^{C_{\delta}}_1,v^{C_{\beta}}_{1}),\dots,(v^{C_{\delta}}_1,v^{C_{\beta}}_{k})$, where $C_{\delta}$ is the equivalence class of the subtree $T[u]$. We conclude that $G$ has a single node with no incoming edges, and the label of this node is $\alpha$; hence, property $(1)$ of Definition~\ref{def:proof-dag} holds.
	
	We can similarly show that every leaf $v\in V$ corresponds to a leaf $v'$ of $T$ labelled with the same fact. That is, if $v$ is a leaf of $G$, then it is of the form $v^{C_\beta}_j$, where $\beta$ is the label of some leaf of $T$ and $C_\beta$ is an equivalence class that contains trees with a single node labeled with $\beta$. Since $T$ is a proof tree, we have that $\lambda(v')\in D$ for every leaf $v'$ of $T$ and so $\lambda(v)\in D$ for every leaf $v$ of $G$, and property $(2)$ of Definition~\ref{def:proof-dag} holds. 
	
	Finally, we show that property $(3)$ of Definition~\ref{def:proof-dag} is satisfied by $G$. Let $v^{C_\beta}_j$ be a node in $V$ with $n\ge 1$ outgoing edges $(v^{C_\beta}_j,v^{C_{\delta_1}}_{j_1}),\dots,(v^{C_\beta}_j,v^{C_{\delta_n}}_{j_n})$. By the definition of $V$, there exists a node $u$ in $T$ with $\lambda(u)=\beta$ such that $T[u]\in C_\beta$. 
	By the definition of $E$, if among the equivalence classes $C_{\delta_1},\dots,C_{\delta_n}$ there are precisely $p$ occurrences of some class $C$ (corresponding to some fact $\gamma$), then for every tree of $C_\beta$ (in particular, for $T[u]$), the root node of the tree (in particular, the node $u$) has precisely $p$ children $u_1,\dots,u_p$ such that $T[u_\ell]\in C$ for every $\ell\in[p]$. This also means that $\lambda(u_\ell)=\gamma$ for every $\ell\in[p]$ by the definition of $V$. We conclude that there is a node $u$ of $T$ with children $u_1,\dots,u_n$ such that $\lambda(u)=\beta$ and $\lambda(u_i)=\delta_i$ for every $i\in[n]$. 
	Since $T$ is a proof tree, this means that there exists a rule $R_0(\bar x_0)\ \assign\ R_1(\bar x_1),\ldots,R_n(\bar x_n) \in \dep$ and a function $h : \bigcup_{i \in [n]} \bar x_i \ra \ins{C}$ such that $\lambda(v) = R_0(h(\bar x_0))$, and $\lambda(u_i) = R_i(h(\bar x_i))$ for $i \in [n]$.
	Therefore, we also have that $\lambda(v^{C_\beta}_j)=R_0(h(\bar x_0))$ and $\lambda(v^{C_{\delta_i}}_{j_i})=R_i(h(\bar x_i))$ for every $i\in [n]$, and property $(3)$ indeed holds. We conclude that $G$ is a proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$ with $|V|\le g(|D|)$.
\end{proof}

\medskip
\noindent \textbf{Finalize the Proof.} With the above technical lemmas in place, it is now easy to show the NP upper bound. Fix a Datalog query $Q = (\dep,R)$. Given a database $D$ over $\esch{\dep}$, a tuple $\bar t \in \adom{D}^{\arity{R}}$, and a subset $D'$ of $D$, to decide whether $D' \in \why{\bar t}{D}{Q}$ we simply need to check for the existence of a proof tree $T$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$. By Proposition~\ref{pro:characterization-all-trees}, this is tantamount to the existence of a compact proof DAG $G$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$.
%
It is clear that the existence of such a proof DAG can be checked by simply guessing a polynomially-sized (w.r.t.~$|D|$) labeled directed graph $G = (V,E,
\lambda)$, and then checking whether $G$ is acyclic, rooted, and a proof DAG of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$. Since both steps can be carried out in polynomial time, $\mathsf{Why\text {-}Provenance}[Q]$ is in \NP, and thus, $\mathsf{Why\text {-}Provenance[\DAT]}$ is in \NP~in data complexity.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\medskip

\noindent \underline{\textbf{Lower Bound}}
\smallskip

\noindent We proceed to establish that $\mathsf{Why\text {-}Provenance[\LDAT]}$ is \NP-hard in data complexity. To this ends, we need to show that there exists a linear Datalog query $Q$ such that the problem $\mathsf{Why\text {-}Provenance}[Q]$ is \NP-hard. The proof is via a reduction from $\mathsf{3SAT}$, which takes as input a Boolean formula $\varphi = C_1 \wedge \ldots \wedge C_m$ in 3CNF, where each clause has exactly 3 literals (a Boolean variable $v$ or its negation $\neg v$), and asks whether $\varphi$ is satisfiable.


\medskip
\noindent \textbf{The Linear Datalog Query.}
We start by defining the linear Datalog query $Q = (\dep,R)$. If the name of a variable is not important, then we use $\_$ for a fresh variable occurring only once in $\dep$. By abuse of notation, we use semicolons instead of commas in a tuple expression in order to separate terms with a different semantic meaning. The program $\dep$ follows:
\begin{eqnarray*}
\sigma_1 &:& R(x)\,\, \assign\,\, {\rm Var}(x;z,\_),{\rm Assign}(x,z), \\
\sigma_2 &:& R(x)\,\, \assign\,\, {\rm Var}(x;\_,z), {\rm Assign}(x,z),\\
%\\
\sigma_3 &:& {\rm Assign}(x,y)\,\, \assign\,\, C(x,y;\_,\_;\_,\_),{\rm Assign}(x,y), \\
\sigma_4 &:& {\rm Assign}(x,y)\,\, \assign\,\, C(\_,\_;x,y;\_,\_),{\rm Assign}(x,y), \\
\sigma_5 &:& {\rm Assign}(x,y)\,\, \assign\,\, C(\_,\_;\_,\_;x,y),{\rm Assign}(x,y), \\
%\\
\sigma_6 &:& {\rm Assign}(x,z)\,\, \assign\,\, {\rm Next}(x,y;z,\_),R(y), \\
\sigma_7 &:& {\rm Assign}(x,z)\,\, \assign\,\, {\rm Next}(x,y;\_,z),R(y), \\
%\\
\sigma_8 &:& R(x)\,\, \assign\,\, {\rm Last}(x).
\end{eqnarray*}	
It is easy to verify that $\dep$ is indeed a linear Datalog program.
%
The high-level idea underlying the program $\dep$ is, for each variable $v$ occurring in a given Boolean formula $\varphi$, to non-deterministically assign a value ($0$ or $1$) to $v$, and then check whether the global assignment makes $\varphi$ true.
%
The rules $\sigma_1$ and $\sigma_2$ are responsible for assigning $0$ or $1$ to a variable $v$; the last two positions of the relation ${\rm Var}$ always store the values $0$ and $1$, respectively.
%
The rules $\sigma_3$, $\sigma_4$, and $\sigma_5$ are responsible for checking whether an assignment for a certain variable $v$ makes a literal that mentions $v$ in some clause $C$ (and thus, $C$ itself) true.
%
The rules $\sigma_6$ and $\sigma_7$ are responsible, once we are done with a certain variable $v$, to consider the variable $u$ that comes after $v$; the relation ${\rm Next}$ provides an ordering of the variables in the given 3CNF Boolean formula.
%
Finally, once all the variables of the formula have been considered, $\sigma_8$ brings us to the last variable, which is a dummy one, that indicates the end of the above process.




\medskip
\noindent \textbf{From $\mathsf{3SAT}$ to  $\mathsf{Why\text {-}Provenance}[Q]$.} We now establish that $\mathsf{Why\text {-}Provenance}[Q]$ is \NP-hard by reducing from $\mathsf{3SAT}$.
%
Consider a 3CNF Boolean formula $\varphi = C_1 \wedge \cdots \wedge C_m$ with $n$ Boolean variables $v_1,\ldots,v_n$. For a literal $\ell$, we write $\lvar{\ell}$ for the variable occurring in $\ell$, and $\lsign{\ell}$ for the number $1$ (resp., $0$) if $\ell$ is a variable (resp., the negation of a variable).
%
We define $D_\varphi$ as the database over $\esch{\dep}$
\begin{eqnarray*}
	&& \{{\rm Var}(v_i;0,1) \mid i \in [n]\}\\
	&\cup& \{{\rm Next}(v_i,v_{i+1};0,1) \mid i \in [n-1]\}\\
	&\cup& \{{\rm Next}(v_n,\bullet;0,1), {\rm Last}(\bullet)\}\\
	&\cup& \{C(\lvar{\ell_1},\lsign{\ell_1};\lvar{\ell_2},\lsign{\ell_2};\lvar{\ell_3},\lsign{\ell_3}) \mid \\
	&& \hspace{28mm} (\ell_1 \vee \ell_2 \vee \ell_3) \text{ is a clause of } \varphi \},
\end{eqnarray*}
which essentially stores the clauses of $\varphi$ and provides an ordering of the variables occurring in $\varphi$, with $\bullet$ being a dummy one.
%
We can show the next lemma, which essentially states that the above construction leads to a correct polynomial-time reduction from $\mathsf{3SAT}$ to $\mathsf{Why\text {-}Provenance}[Q]$:

\begin{lemma}\label{lem:reduction-from-3sat}
	%The following hold:
	%\begin{enumerate}
		%\item 
		$D_\varphi$ can be constructed in polynomial time in $\varphi$. Furthermore,
		%\item 
		$\varphi$ is satisfiable iff $D_\varphi \in \why{(v_1)}{D_\varphi}{Q}$.
	%\end{enumerate}
\end{lemma}
\begin{proof}
Clearly, $D_{\varphi}$ is over $\esch{\dep}$, and $D_{\varphi},(v_1)$ can be constructed in polynomial time w.r.t.~$\varphi$. We now show that $\varphi$ is satisfiable if and only if there exists a proof tree $T$ of $R(v_1)$ w.r.t.~$D_{\varphi}$ and $\Sigma$ such that $\support{T} = D_{\varphi}$.


We start with the $(\Rightarrow)$ direction. Assume $\varphi$ is satisfiable via the truth assignment $\mu$. For every variable $v_i$, we denote by $S_{v_i}$ the set of facts of the form $C(v_i,\mu(v_i);\_,\_;\_,\_)$, $C(\_,\_;v_i,\mu(v_i);\_,\_)$, and $C(\_,\_;\_,\_;v_i,\mu(v_i))$. We define the labeled rooted tree $T=(V,E,\lambda)$ where the root $v \in V$ is labeled with $\lambda(v) = R(v_1)$, and inductively:
	\begin{enumerate}
		\item if $v \in V$ is labeled with $\lambda(v) = R(v_i)$, for $i \in [n]$, then $v$ has two children $u_1,u_2$, where 
		$\lambda(u_1)$ is the (only) fact in $D_{\varphi}$ of the form $Var(v_i;0,1)$ and  $\lambda(u_2) = {\rm Assign}(v_i,\mu(v_i))$.
	\item if $v \in V$ is labeled with $\lambda(v) = {\rm Assign}(v_i,\mu(v_i))$ for $i \in [n]$, and $S_{v_i}$ is not empty, then $v$ 
has two children $u_1,u_2$, where $\lambda(u_1)=f$ for some fact $f\in S_{v_i}$ and $\lambda(u_2) = {\rm Assign}(v_i,\mu(v_i))$. We then remove $f$ from $S_{v_i}$. 
\item if $v \in V$ is labeled with $\lambda(v) = {\rm Assign}(v_i,\mu(v_i))$ for $i \in [n-1]$, and $S_{v_i}$ is empty, then $v$ 
has two children $u_1,u_2$, where $\lambda(u_1)={\rm Next}(v_i,v_{i+1};0,1)$ and $\lambda(u_2) = R(v_{i+1})$.
\item if $v \in V$ is labeled with $\lambda(v) = {\rm Assign}(v_n,\mu(v_n))$ and $S_{v_n}$ is empty, then $v$
has two children $u_1,u_2$, where $\lambda(u_1)={\rm Next}(v_n,\bullet;0,1)$ and and $\lambda(u_2) = R(\bullet)$.
\item if $v \in V$ is labeled with $\lambda(v) = R(\bullet)$, then $v$ has one child $u_1$, where $\lambda(u_1)={\rm Last}(\bullet)$.
	\end{enumerate}
	One can verify that $T$ is indeed a proof tree of $R(v_1)$ w.r.t.~$D_\varphi$ and $\Sigma$. In particular, the root is labeled with $R(v_1)$ by construction, and it is easy to see that the labels of the leaves all occur in $D_\varphi$. Furthermore, since $\dep$ is linear, at each level of $T$ there exists at most one non-leaf node. The edges from this node are defined in items~$(1)-(5)$ above. The edges defined in item~(1) are obtained by considering rules $\sigma_1,\sigma_2$, the edges defined in item~(2) are obtained by considering rules $\sigma_3,\sigma_4,\sigma_5$, and the edges defined in items~(3) and~(4) are obtained by considering rules $\sigma_6,\sigma_7$. Finally, the edge defined in item~(5) is obtained by considering rule $\sigma_8$. Hence, Property~$(3)$ of Definition~\ref{def:proof-tree} holds.
 
 Regarding the support of $T$, since $\mu$ is a satisfying assignment, every clause of $\varphi$ contains at least one literal $\ell_j$ such that $\mu(\lvar{\ell_j})=\lsign{\ell_j}$. Item~(1) ensures that we follow this satisfying assignment (i.e., add a node labeled with ${\rm Assign}(v_i,\mu(v_i))$ under a node $R(v_i)$ corresponding to the variable $v_i$). Item~(2) ensures that whenever we consider a variable $v_i$, we touch every atom over the predicate $C$ corresponding to a clause that contains the variable $v_i$ with the correct sign (positive if $\mu(v_i)=1$ or negated if $\mu(v_i)=0$); that is, every clause satisfied by the assignment to this variable. Items~(3) and~(4) ensure that we go over all the variables, as the atoms over the predicate ${\rm Next}$ only allow us to move from a variable $v_i$ to the next variable $v_{i+1}$. This, in turn, ensures that we touch every atom over the predicate ${\rm Var}$ by item~(1), every atom over the predicate $C$ by item~(2) (since, as aforementioned, each such clause contains a literal with a sign that is consistent with the assignment to the corresponding variable), and every atom over the predicate ${\rm Next}$ by items~(3) and~(4). Finally, item~(5) ensures that we touch the atom ${\rm Last}(\bullet)$. Hence, we conclude that $\support{T} = D_{\varphi}$.
	

Next, we prove the $(\Leftarrow)$ direction. Assume that $T=(V,E,\lambda)$ is a proof tree for $R(v_1)$ w.r.t.~$D_\varphi$ and $\Sigma$ such that $\support{T}=D_{\varphi}$. 
	Note that by linearity of $\dep$, at each level of $T$, besides the last one, there exists precisely one non-leaf node. These nodes thus form a path $u_0,u_1,\ldots$ in $T$. Note that $u_0$, i.e., the root, is necessarily labeled with the fact $R(v_1)$ by the definition of $Q$. Then, the children of the root are labeled with ${\rm Var}(v_1;0,1)$ and ${\rm Assign}(v_1,b_1)$ (this is the node $u_1$) for some $b_1\in\{0,1\}$, based on rule $\sigma_1$ or $\sigma_2$, as these are the only options. At this point, either the node $u_2$ is labeled with $R(v_2)$ based on rule $\sigma_6$ or $\sigma_7$, or $u_2,\dots,u_j$ for some $j\ge 2$ are all labeled with ${\rm Assign}(v_1,b_1)$, and then $u_{j+1}$ is labeled with $R(v_2)$. Then, the same reasoning applies to $v_2$ and all the variables that come next.

    Since the atoms over the predicate ${\rm Next}$ only consider consecutive variables, it is only possible to move from $v_i$ to $v_{i+1}$ along the path, and since $\support{T}=D_\varphi$, the set $\support{T}$ contains all the atoms over ${\rm Next}$, and we conclude that we go over all variables. Moreover, for every variable $v_i$, once we select the label ${\rm Assign}(v_i,b_i)$ for the child of the node labeled with $R(v_i)$, there is no rule that allows us to obtain the label ${\rm Assign}(v_i,1-b_i)$, and so the labels over the predicate ${\rm Assign}$ correspond to a truth assignment $\mu$ to the variables $v_1,\dots,v_n$. Finally, since all the atoms over the predicate $C$ appear in the support, the rules $\sigma_3,\sigma_4,\sigma_5$ imply that for every clause $(\ell_1\vee\ell_2\vee\ell_3)$, either ${\rm Assign}(\lvar{\ell_1},\lsign{\ell_1})$, or ${\rm Assign}(\lvar{\ell_2},\lsign{\ell_2})$, or ${\rm ssign}(\lvar{\ell_3},\lsign{\ell_3})$ appears as a label along the path. Hence, $\mu$ is a satisfying truth assignment.
\end{proof}

By Lemma~\ref{lem:reduction-from-3sat}, $\mathsf{Why\text {-}Provenance}[Q]$ is \NP-hard, and thus, $\mathsf{Why\text {-}Provenance[\LDAT]}$ is \NP-hard in data complexity.


\subsection{Non-Recursive Queries}

We now focus on non-recursive Datalog queries, and give the full proof of Theorem~\ref{the:non-recursive-complexity}, which we recall here:

\begin{manualtheorem}{\ref{the:non-recursive-complexity}}
	\thenonrecursivecomplexity
\end{manualtheorem}

Given a non-recursive Datalog query $Q$, we have already explained in the main body how the FO query $Q_{\mi{FO}}$ is constructed. Our main task here is to establish the correctness of this construction, i.e., Lemma~\ref{lem:fo-tree-equiv}, which we recall here:


\begin{manuallemma}{\ref{lem:fo-tree-equiv}}
	\lemmaforewriting
\end{manuallemma}

\begin{proof}
	We first discuss the $(\Rightarrow)$ direction. There is a proof tree $T$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$. Thus, $T$ is a $Q$-tree, the set $\cq{Q}$ contains the CQ $\cq{T}$, that is, the CQ induced by $T$, and the set $\cqeq{Q}$ contains a CQ $\varphi(\bar y)$ that is the same as $\cq{T}$ up to variable renaming. It is then an easy exercise to show that that $D'$ satisfies the sentence $\psi_{\varphi(\bar y)}[\bar x / \bar t]$. This in turn implies that $\bar t \in Q_{\mi{FO}}(D')$.
	
	We now discuss the $(\Leftarrow)$ direction. There is a CQ $\varphi(\bar y) \in \cqeq{Q}$ such that $D'$ satisfies the sentence $\psi_{\varphi(\bar y)}[\bar x / \bar t]$. It is then an easy exercise to show that there exists a proof tree of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$. This in turn implies that $D \in \why{R(\bar t)}{D}{Q}$.
\end{proof}