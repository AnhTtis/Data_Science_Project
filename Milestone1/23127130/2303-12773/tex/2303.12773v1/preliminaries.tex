\section{Preliminaries}\label{sec:preliminaries}
%

We consider the disjoint countably infinite sets $\ins{C}$ and $\ins{V}$ of {\em constants} and {\em variables}, respectively. We may refer to constants and variables as {\em terms}. For brevity, given an integer $n > 0$, we may write $[n]$ for the set of integers $\{1,\ldots,n\}$.

\medskip


\noindent 
\textbf{Relational Databases.} A {\em schema} $\ins{S}$ is a finite set of relation names (or predicates) with associated arity. We write $R/n$ to say that $R$ has arity $n \ge 0$; we may also write $\arity{R}$ for $n$.
%
A {\em (relational) atom} $\alpha$ over $\ins{S}$ is an expression of the form $R(\bar t)$, where $R/n \in \ins{S}$ and $\bar t$ is an $n$-tuple of terms. By abuse of notation, we may treat tuples as the \emph{set} of their elements. A {\em fact} is an atom that mentions only constants.
%
%Let $\var{\alpha}$ be the set of variables in $\alpha$; the notation $\var{\cdot}$ naturally extends to more complex objects with variables.
%
A {\em database} over $\ins{S}$ is a finite set of facts over $\ins{S}$. The {\em active domain} of a database $D$, denoted $\adom{D}$, is the set of constants in $D$.

\begin{comment}
\medskip
\noindent
\textbf{First-Order Queries.}
A {\em first-order (FO)} query $Q$ is an expression of the form $\varphi(\bar x)$, where $\varphi$ is an FO formula, $\bar x$ is a tuple of (not necessarily distinct) variables, and the set of variables occurring in $\bar x$ is precisely the set of free variables of $\varphi$.
%
The {\em answer} to $Q$ over a database $D$ is the set of tuples
$
Q(D) = \{\bar t \in \adom{D}^{|\bar x|} \mid D \models \varphi(\bar t)\}, 
$
where $|\bar x|$ denotes the length of $\bar x$, and $\models$ denotes the standard FO entailment. Let $\var{\varphi}$ be the set of variables occurring in $\varphi$.
%
A \emph{conjunctive query (CQ)} is an FO query $\varphi(\bar x)$, where $\varphi$ is of the form $\exists \bar y \, (R_1(\bar x_1) \wedge \cdots \wedge R_n(\bar x_n))$ with $\bar x \cap \bar y = \emptyset$ and $\bar x_i \subseteq \bar x \cup \bar y$.
\end{comment}

\medskip
\noindent
\textbf{Syntax and Semantics of Datalog Programs.} A {\em (Datalog) rule} $\sigma$ over a schema $\ins{S}$ is an expression of the form
\[
R_0(\bar x_0)\ \assign\ R_1(\bar x_1),\ldots,R_n(\bar x_n)
\]
for $n \geq 1$, where $R_i(\bar x_i)$ is a (constant-free) relational atom over $\ins{S}$ for $i \in \{0,\ldots,n\}$, and each variable in $\bar x_0$ occurs in $\bar x_k$ for some $k \in [n]$.
%
We refer to $R_0(\bar x_0)$ as the {\em head} of $\sigma$, denoted $\head{\sigma}$, and to the expression that appears on the right
of the\assign symbol as the {\em body} of $\sigma$, denoted $\body{\sigma}$, which we may treat as the set of its atoms.


A {\em Datalog program} over a schema $\ins{S}$ is defined as a finite set $\dep$ of Datalog rules over $\ins{S}$. 
%It is convenient to distinguish the predicates of $\ins{S}$ that appear only in the bodies of the rules of $\dep$ from those that appear in the head of at least one rule of $\dep$. 
%
%In particular, 
A predicate $R$ occurring in $\dep$ is called {\em extensional} if there is no rule in $\dep$ having $R$ in its head, and {\em intentional} if there exists at least one rule in $\dep$ with $R$ in its head.
%
The {\em extensional (database) schema} of $\dep$, denoted $\esch{\dep}$, is the set of all extensional predicates in $\dep$, while the {\em intentional
schema} of $\dep$, denoted $\isch{\dep}$, is the set of all intensional predicates in $\dep$. Note that, by definition, $\esch{\dep} \cap \isch{\dep} = \emptyset$. The {\em schema} of $\dep$, denoted $\sch{\dep}$, is the set $\esch{\dep} \cup \isch{\dep}$, which is in general a subset of $\ins{S}$ since some predicates of $\ins{S}$ may not appear in $\dep$.


There are interesting fragments of Datalog programs that somehow limit the recursion and have been extensively studied in the literature.
% 
A Datalog program $\dep$ is called {\em linear} if, for each rule $\sigma \in \dep$, there exists at most one atom in $\body{\sigma}$ over $\isch{\dep}$, namely $\body{\sigma}$ mentions at most one intensional predicate. Roughly, linear Datalog programs can have only linear recursion.
%
Another key fragment is the one that completely forbids recursion. A Datalog program $\dep$ is called {\em non-recursive} if its predicate graph, which encodes how the predicates of $\sch{\dep}$ depend on each other, is acyclic. Recall that the nodes of the predicate graph of  $\dep$ are the predicates of $\sch{\dep}$, and there is an edge from $R$ to $P$ if there is a rule of the form $P(\bar x)\ \assign\ \ldots, R(\bar y),\ldots$ in $\dep$.


An elegant property of Datalog programs is that they have three equivalent semantics: model-theoretic, fixpoint, and proof-theoretic~\cite{AbHV95}.
%The semantics of Datalog programs can be equivalently defined in three different ways: model-theoretically, via a fixpoint procedure, and proof-theoretically; see, e.g.,~\cite{AbHV95}. 
We proceed to recall the proof-theoretic semantics of Datalog programs since it is closer to the notion of why-provenance. To this end, we need the key notion of proof tree of a fact, which will anyway play a crucial role in our work.
%
For a database $D$ and a Datalog program $\dep$, let $\base{D,\dep} = \{R(\bar t) \mid R \in \sch{\dep} \text{ and } \bar t \in \adom{D}^{\arity{R}}\}$, the set of all facts that can be formed using predicates of $\sch{\dep}$ and terms of $\adom{D}$.


\begin{definition}[\textbf{Proof Tree}]\label{def:proof-tree}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. 
	%
	A {\em proof tree of $\alpha$ w.r.t.~$D$ and $\dep$} is a finite labeled rooted tree $T=(V,E,\lambda)$, with $\lambda : V \ra \base{D,\dep}$, such that:
	\begin{enumerate}
		\item If $v \in V$ is the root, then $\lambda(v) = \alpha$.
		
		\item If $v \in V$ is a leaf, then $\lambda(v) \in D$.
		
		\item If $v \in V$ is a node with $n\ge1$ children $u_1,\ldots,u_n$, then there is a rule $R_0(\bar x_0)\ \assign\ R_1(\bar x_1),\ldots,R_n(\bar x_n) \in \dep$ and a function $h : \bigcup_{i \in [n]} \bar x_i \ra \ins{C}$ such that $\lambda(v) = R_0(h(\bar x_0))$, and $\lambda(u_i) = R_i(h(\bar x_i))$ for each $i \in [n]$. \hfill\markfull
	\end{enumerate} 
\end{definition}


Essentially, a proof tree of a fact $\alpha$ w.r.t.~$D$  and $\dep$ indicates that we can prove $\alpha$ using $D$ and $\dep$, that is, we can derive $\alpha$ starting from $D$ end executing the rules of $\dep$. An example, which will also serve as a running example throughout the paper, that illustrates the notion of proof tree follows.

\begin{example}\label{exa:proof-tree}
	Consider the Datalog program $\dep$ consisting of
	\begin{eqnarray*}
		A(x) &\emph{\assign}& S(x)\\
		A(x) &\emph{\assign}& A(y), A(z),T(y,z,x)
	\end{eqnarray*}
	that encodes the {\em path accessibility problem}~\cite{Cook74}. The predicate $S$ represents source nodes, $A$ represents nodes that are accessible from the source nodes, and $T$ represents accessibility conditions, that is, $T(y,z,x)$ means that if both $y$ and $z$ are accessible from the source nodes, then so is $x$.
	%
	We further consider the database
	\[
	D\ =\ \{S(a), T(a,a,b),T(a,a,c), T(a,a,d), T(b,c,a)\}.
	\]
	A simple proof tree of the fact $A(d)$ w.r.t.~$D$ and $\dep$ follows:
	
	\centerline{\includegraphics[width=.27\textwidth]{proof-tree-1.pdf}}
	
	\noindent The following is another, slightly more complex, proof tree of the fact $A(d)$ w.r.t.~$D$ and $\dep$:
	
	\centerline{
	\includegraphics[width=.48\textwidth]{proof-tree-2.pdf}}

	\noindent Note that the above are only two out of the many proof trees of $A(d)$ w.r.t.~$D$ and $\dep$. In fact, there exist infinitely many as one can build larger and larger such proof trees: whenever we encounter a node labeled by $A(a)$, we can choose to apply the recursive rule instead of the rule $A(x)\ \emph{\assign}\ S(x)$. \hfill\markfull
\end{example}

\begin{comment}
\begin{figure}[t]
	\centering
	\includegraphics[width=.45\textwidth]{proof-tree.pdf}
	\caption{Proof Tree}
	\label{fig:proof-tree-1}
\end{figure}
\end{comment}


Now, given a Datalog program $\dep$ and a database $D$ over $\sch{\dep}$, the {\em semantics of $\dep$ on $D$}, denoted $\dep(D)$, is the set
\[
\dep(D)\ =\ \{\alpha \mid \text{ there is a proof tree of } \alpha \text{ w.r.t. } D \text{ and } \dep\},
\]
that is, the set of facts that can be proven using $D$ and $\dep$.


\medskip
\noindent
\textbf{Datalog Queries.} Having the syntax and the semantics of Datalog programs in place, it is now straightforward to recall the syntax and the semantics of Datalog queries.
%
A {\em Datalog query} is a pair $Q = (\dep,R)$, where $\dep$ is a Datalog program and $R$ a predicate of $\isch{\dep}$.
%
We further call $Q$ {\em linear} (resp., {\em non-recursive}) if the program $\dep$ is linear (resp., non-recursive).
%
Now, for a database $D$ over $\esch{\dep}$, the {\em answer} to $Q$ over $D$ is defined as the set of tuples
\[
Q(D)\ =\ \{\bar t \in \adom{D}^{\arity{R}} \mid R(\bar t) \in \dep(D)\},
\]
i.e., the tuples $\bar t$ such that the fact $R(\bar t)$ can be proven using $D$ and $\dep$. The class that collects all the Datalog queries is denoted $\DAT$. We also write $\LDAT$ and $\NRDAT$ for the classes of linear and non-recursive Datalog queries, respectively.


%A \emph{$k$-ary Datalog query} is a pair $Q=(\dep,P)$, where $\dep$ is a Datalog program, and $P \in \sch{\dep}$, with $\arity{P}=k$; $Q$ is \emph{Boolean} if $k = 0$.  We use $\class{DAT}$ to denote the class of all Datalog queries. 