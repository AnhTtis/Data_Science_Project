\section{Why-Provenance for Datalog Queries}\label{sec:why-provenance}
%


As already discussed in the Introduction, why-provenance is a standard way of explaining why a query result is obtained. It essentially collects all the subsets of the database (without unnecessary atoms) that allow us to prove (or derive) a query result. We proceed to formalize this simple idea, and then introduce the main problem of interest.

Given a proof tree $T = (V,E,\lambda)$ (of some fact w.r.t.~some database and Datalog program), the {\em support} of $T$ is the set
\[
\support{T}\ =\ \left\{\lambda(v) \mid v \in V \text{ is a leaf of } T\right\},
\]
which is essentially the set of facts that label the leaves of the proof tree $T$. Note that $\support{T}$ is a subset of the underlying database since, by definition, the leaves of a proof tree are labeled with database atoms.
%
The formal definition of why-provenance for Datalog queries follows.


\begin{definition}[\textbf{Why-Provenance for Datalog}]\label{def:why-provenance}
	Consider a Datalog query  $Q = (\dep,R)$, a database $D$ over $\esch{\dep}$, and a tuple $\bar t \in \adom{D}^{\arity{R}}$. The {\em why-provenance of $\bar t$ w.r.t.~$D$ and $Q$} is defined as the family of sets of facts 
	\[
	\{\support{T} \mid T \text{ is a proof tree of } R(\bar t) \text{ w.r.t. } D \text{ and } \dep\}
	\]
	which we denote by $\why{\bar t}{D}{Q}$. \hfill\markfull
\end{definition}

\begin{comment}
\begin{definition}[\textbf{Why-Provenance}]\label{def:why-provenance}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. The {\em why-provenance of $\alpha$ w.r.t.~$D$ and $\dep$} is the set 
	\[
	\{\lfacts{T} \mid T \text{ is a proof tree of } \alpha \text{ w.r.t. } D \text{ and } \dep\}
	\]
	denoted as $\why{\alpha}{D}{\dep}$. \hfill\markfull
\end{definition}
\end{comment}
 
Intuitively speaking, a set of facts $D' \subseteq D$ that belongs to $\why{\bar t}{D}{Q}$ should be understood as a ``real'' reason why the tuple $\bar t$ is an answer to the query $Q$ over the database $D$, i.e., $D'$ explains why $\bar t \in Q(D)$. By ``real'' we mean that all the facts of $D'$ are really used in order to derive the tuple $\bar t$ as an answer. Here is a simple example of why-provenance.

\begin{example}\label{exa:why-provenance}
	Let $Q = (\dep,A)$, where $\dep$ is the program that encodes the path accessibility problem as in Example~\ref{exa:proof-tree}, and let $D$ be the database from Example~\ref{exa:proof-tree}. 
	%
	It can be verified that the why-provenance of the unary tuple $(d)$ w.r.t.~$D$ and $Q$ consists of $\{S(a), T(a,a,d)\}$ and the database $D$ itself. The former set is actually the support of the first proof tree given in Example~\ref{exa:proof-tree}, while $D$ is the support of the second proof tree. 
	%
	Recall that $A(d)$ has infinitely many proof trees w.r.t.~$D$ and $\dep$, whereas $\why{(d)}{D}{Q}$ contains only two sets. Thus, in general, there is no 1-1 correspondence between proof trees of a fact $R(\bar t)$ and members of the why-provenance of $\bar t$. \hfill\markfull
\end{example}


We would like to pinpoint the inherent complexity of the problem of computing the why-provenance of a tuple w.r.t.~a database and a Datalog query.
%
To this end, we need to study the complexity of  recognizing whether a certain subset of the database belongs to the why-provenance, that is, whether a candidate explanation is indeed an explanation.
%forms such an explanation. 
This leads to the following algorithmic problem parameterized by a class $\class{C}$ of Datalog queries; $\class{C}$ can be, e.g., $\DAT$, $\LDAT$, or $\NRDAT$:

\smallskip

\begin{center}
	\fbox{\begin{tabular}{ll}
			{\small PROBLEM} : & $\mathsf{Why\text {-}Provenance[C]}$
			\\[2mm]
			{\small INPUT} : & A Datalog query $Q = (\dep,R)$ from $\class{C}$,\\
			& a database $D$ over $\esch{\dep}$,\\
			& a tuple ${\bar t} \in \adom{D}^{\arity{R}}$, and $D' \subseteq D$.\\[2mm]
			{\small QUESTION} : &  Does $D' \in \why{\bar t}{D}{Q}$?
	\end{tabular}}
\end{center}


\smallskip

Our goal is to study the above problem and pinpoint its complexity. We are actually interested in the {\em data complexity} of $\mathsf{Why\text {-}Provenance[C]}$, where the query $Q$ is fixed, and only the database $D$, the tuple $\bar t$, and $D'$ are part of the input, i.e., for each $Q = (\dep,R)$ from $\class{C}$, we consider the problem:

\smallskip

\begin{center}
	\fbox{\begin{tabular}{ll}
			{\small PROBLEM} : & $\mathsf{Why\text {-}Provenance}[Q]$
			\\[2mm]
			{\small INPUT} : & A database $D$ over $\esch{\dep}$,\\
			& a tuple ${\bar t} \in \adom{D}^{\arity{R}}$, and $D' \subseteq D$.\\[2mm]
			{\small QUESTION} : &  Does $D' \in \why{\bar t}{D}{Q}$?
	\end{tabular}}
\end{center}


\smallskip

%dubbed $\mathsf{Why\text {-}Provenance[Q]}$, which takes as input a database $D$ over $\esch{\dep}$, a tuple ${\bar t} \in \adom{D}^{\arity{R}}$, and $D' \subseteq D$, and asks whether $D' \in \why{\bar t}{D}{Q}$.
%
\noindent By the typical convention, the problem $\mathsf{Why\text {-}Provenance[C]}$ is in a certain complexity class $C$ in data complexity if, for every query $Q$ from $\class{C}$, $\mathsf{Why\text {-}Provenance}[Q]$ is in $C$.
%
On the other hand, $\mathsf{Why\text {-}Provenance[C]}$ is hard for a certain complexity class $C$ in data complexity if there exists a query $Q$ from $\class{C}$ such that $\mathsf{Why\text {-}Provenance}[Q]$ is hard for $C$.


%This is a practically relevant setting as the really large object is the database, while the query is typically small.
