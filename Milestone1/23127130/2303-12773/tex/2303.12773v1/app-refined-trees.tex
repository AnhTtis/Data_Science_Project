\section{Non-Recursive Proof Trees}\label{appsec:refined-trees}
%


As discussed in the main body of the paper (see Section~\ref{sec:refined-trees}), the standard notion of why-provenance, which was defined in Section~\ref{sec:why-provenance} and thoroughly analyzed in Section~\ref{sec:complexity}, relies on arbitrary proof trees without any restriction. Indeed, a subset of the input database $D$ belongs to the why-provenance of a tuple $\bar t$ w.r.t.~$D$ and a Datalog query $Q = (\dep,R)$ as long as it is the support of {\em any} proof tree of $R(\bar t)$ w.r.t.~$D$ and $\dep$.
%
However, as already discussed in the literature (see, e.g., the recent work~\cite{BBPT22}), there are proof trees that are counterintuitive. Such a proof tree is the second one in Example~\ref{exa:proof-tree} as the fact $A(a)$ is derived from itself.
%
Now, a member $D'$ of $\why{\bar t}{D}{Q}$, witnessed via such an unnatural proof tree, might be classified as a counterintuitive explanation of $\bar t$ as it does not correspond to an intuitive derivation process, which can be extracted from the proof tree, that derives from $D'$ the fact $R(\bar t)$.
%
This leads to the need of considering refined classes of proof trees that overcome the conceptual limitations of arbitrary proof trees, which in turn lead to conceptually intuitive explanations.
%
In this section, we focus on the class of non-recursive proof trees. Roughly, a non-recursive proof tree is a proof
tree that does not contain two nodes labeled with the same fact and such that one is the descendant of the other, which reflects the above discussion that using a fact to derive itself is a counterintuitive phenomenon. The formal definition follows:

\begin{definition}[\textbf{Non-Recursive Proof Tree}]\label{def:non-recursove-proof-tree}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. A {\em non-recursive proof tree of $\alpha$ w.r.t.~$D$ and $\dep$} is a proof tree $T = (V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that, for every two nodes $v,u \in V$, if there is a path from $v$ to $u$ in $T$, then $\lambda(v) \neq \lambda(u)$. \hfill\markfull
\end{definition}



We now define why-provenance relative to non-recursive proof trees. Given a Datalog query $Q = (\dep,R)$, a database $D$ over $\esch{\dep}$, and a tuple $\bar t \in \adom{D}^{\arity{R}}$, the {\em why-provenance of $\bar t$ w.r.t.~$D$ and $Q$ relative to non-recursive proof trees} is defined as the family of sets of facts
\begin{multline*}
\{\support{T} \mid T \text{ is a non-recursive proof tree of }\\
R(\bar t) \text{ w.r.t. } D \text{ and } \dep\}
\end{multline*}
denoted $\nrwhy{\bar t}{D}{Q}$.
%
Then, the algorithmic problems
\[
\mathsf{Why\text {-}Provenance_{NR}[C]} \quad \text{and} \quad  \mathsf{Why\text {-}Provenance_{NR}}[Q]
\] 
are defined in the exact same way as those in Section~\ref{sec:why-provenance} with the key difference that $\nrwhy{\bar t}{D}{Q}$ is used instead of $\why{\bar t}{D}{Q}$, i.e., the question is whether the given subset of the database belongs to $\nrwhy{\bar t}{D}{Q}$. 
%
We proceed to study the data complexity of $\mathsf{Why\text {-}Provenance_{NR}[C]}$ for each class $\class{C} \in \{\DAT,\LDAT,\NRDAT\}$. As shown in the case of arbitrary proof trees, for recursive queries, even if the recursion is restricted to be linear, the problem is in general intractable, whereas for non-recursive queries it is highly tractable. We first focus on recursive queries.



\subsection{Recursive Queries}
%

We show the following complexity result:

\begin{theorem}\label{the:complexity-non-recursive-proof-trees-np}
	$\mathsf{Why\text {-}Provenance_{NR}[C]}$ is \NP-complete in data complexity, for each class $\class{C} \in \{\DAT,\LDAT\}$.
\end{theorem}


To prove Theorem~\ref{the:complexity-non-recursive-proof-trees-np}, it suffices to show that:
\begin{itemize}
	\item $\mathsf{Why\text {-}Provenance_{NR}[\DAT]}$ is in \NP~in data complexity.
	\item $\mathsf{Why\text {-}Provenance_{NR}[\LDAT]}$ is \NP-hard in data complexity.
\end{itemize}
Let us first focus on the upper bound.


\medskip

\noindent \underline{\textbf{Upper Bound}}
\smallskip

\noindent The proof is similar to the proof of the analogous result for $\mathsf{Why\text {-}Provenance[\DAT]}$ established in Section~\ref{sec:why-provenance}.
%
Given a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$, we first define the notion of {\em non-recursive proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$}.
%
We then proceed to establish a result analogous to Proposition~\ref{pro:characterization-all-trees}: the existence of a non-recursive proof tree of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D' \subseteq D$ is equivalent to the existence of a polynomially-sized non-recursive proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$. This in turn leads to a guess-and-check algorithm that runs in polynomial time.
%
Let us formalize the above high-level description.



\begin{definition}[\textbf{Non-Recursive Proof DAG}]\label{def:non-recursive-proof-dag}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. 
	%
	A {\em non-recursive proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$} is a proof DAG $G=(V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that, for every two nodes $v,u \in V$, if there is a path from $v$ to $u$ in $G$, then $\lambda(v) \neq \lambda(u)$. \hfill\markfull
\end{definition}


The analogous result to Proposition~\ref{pro:characterization-all-trees} follows:



\begin{proposition}\label{pro:characterization-nr-trees}
		For a Datalog program $\dep$, there is a polynomial $f$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$ over $\sch{\dep}$, and $D' \subseteq D$, the following are equivalent:
	\begin{enumerate}
		\item There is a non-recursive proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$.
		\item There is a non-recursive proof DAG $G = (V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$ and $|V| \leq f(|D|)$.
	\end{enumerate}
\end{proposition}



The direction (2) implies (1) is shown by ``unravelling'' the non-recursive proof DAG $G$ into a non-recursive proof $T$ with $\support{G} = \support{T}$. We use the same ``unravelling'' construction as in the proof of direction (2) implies (1) of Proposition~\ref{pro:characterization-all-trees}, which {\em preserves non-recursiveness}.


We now proceed with (1) implies (2). The underlying construction proceeds in two main steps captured by Lemmas~\ref{lem:scount-reduction-nr} and~\ref{lem:from-trees-to-dags-nr} given below.

%whose essence is captured by three technical lemmas (Lemma~\ref{lem:depth-reduction},~\ref{lem:scount-reduction}, and~\ref{lem:from-trees-to-dags}).

\medskip 

$\bullet$ The \textbf{\textit{first step}} is to show that a non-recursive proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ can be converted into a non-recursive proof tree $T'$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T'} = D'$ that has ``small'' subtree count.


\begin{lemma}\label{lem:scount-reduction-nr}
		For each Datalog program $\dep$, there is a polynomial $f$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$ over $\sch{\dep}$, and $D' \subseteq D$, if there is a non-recursive proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$, then there is also such a proof tree $T'$ with $\scount{T'} \leq f(|D|)$.
\end{lemma}

\begin{proof}
	We first observe that the non-recursive proof tree $T$, by definition, has ``small'' depth. In particular, since no two nodes on a path of $T$ have the same label, the length of a path is bounded by the number of labels, that is, $|\base{D,\dep}|$, which is clearly polynomial in the size of the database $D$.
	%
	The other crucial observation is that the construction underlying Lemma~\ref{lem:scount-reduction}, which converts a proof tree of ``small'' depth into a proof tree of ``small`` subtree count with the same support {\em preserves non-recursiveness}.
	%
	Consequently, we can apply the construction underlying Lemma~\ref{lem:scount-reduction} to the non-recursive proof tree $T$ and get a non-recursive proof tree $T'$ with $\support{T} = \support{T'}$ such that $\scount{T'} \leq f(|D|)$, where $f$ is the polynomial provided by Lemma~\ref{lem:scount-reduction}.
\end{proof}


\smallskip

$\bullet$ The \textbf{\textit{second step}} shows that a non-recursive proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ of ``small'' subtree count can be converted into a compact non-recursive proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$.

\begin{lemma}\label{lem:from-trees-to-dags-nr}
	For each Datalog program $\dep$ and a polynomial $f$, there is a polynomial $g$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$, and $D' \subseteq D$, if there is a non-recursive proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ and $\scount{T} \leq f(|D|)$, then there is a non-recursive proof DAG $G = (V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$ and $|V| \leq g(|D|)$.
\end{lemma}

\begin{proof}
	We employ the construction underlying Lemma~\ref{lem:from-trees-to-dags}, which converts a proof tree of ``small'' subtree count into a non-recursive proof DAG of polynomial size with the same support, since it {\em preserves non-recursiveness}. The latter holds since, for each path of the proof tree, there is a path in the proof DAG with the same labels, and vice versa. 
\end{proof}

It is now clear that the direction (1) implies (2) of Proposition~\ref{pro:characterization-nr-trees} is an immediate consequence of Lemmas~\ref{lem:scount-reduction-nr} and~\ref{lem:from-trees-to-dags-nr}.


\medskip
\noindent
\textbf{Finalize the Proof.} We can now finalize the proof of the claim that $\mathsf{Why\text {-}Provenance_{NR}[\DAT]}$ is in \NP~in data complexity.
%
Fix a Datalog query $Q = (\dep,R)$. Given a database $D$ over $\esch{\dep}$, a tuple $\bar t \in \adom{D}^{\arity{R}}$, and a subset $D'$ of $D$, to decide whether $D' \in \nrwhy{\bar t}{D}{Q}$ we simply need to check for the existence of a non-recursive proof tree $T$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$. By Proposition~\ref{pro:characterization-nr-trees}, this is tantamount to the existence of a polynomially-sized non-recursive proof DAG $G$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$.
%
The existence of such a non-recursive proof DAG can be checked via a non-deterministic algorithm that runs in polynomial time in the size of the database as it was done for proving that $\mathsf{Why\text {-}Provenance[\DAT]}$ is in \NP~in data complexity (Theorem~\ref{the:recursive-complexity}). The only difference is that now we need to additionally check that the guessed DAG is also non-recursive.
%
This can be done by going over the nodes of the
DAG using depth-first search, and remembering all the labels that we have seen on the current path. Whenever we encounter a new node, we need to verify that its label does not belong to the set of labels that we have already seen on this path. If it does, then we reject; otherwise, we add its label to the set of labels and continue. Whenever we go ``back'' in the DAG (move from a node $u$ to a node $v$ when there is an edge $(v,u)$), we remove the label of the child node from the set. This requires $O(|V| \cdot |E|)$ time, where $V$ and $E$ are the sets of nodes and edges of the DAG, respectively.
%
Consequently, $\mathsf{Why\text {-}Provenance}[Q]$ is in \NP, and thus, $\mathsf{Why\text {-}Provenance[\DAT]}$ is in \NP~in data complexity.



\medskip

\noindent \underline{\textbf{Lower Bound}}
\smallskip

\noindent We proceed to establish that $\mathsf{Why\text {-}Provenance_{NR}[\LDAT]}$ is \NP-hard in data complexity. To this end, we need to show that there exists a linear Datalog query $Q$ such that the problem $\mathsf{Why\text {-}Provenance_{NR}}[Q]$ is \NP-hard. The proof is via a reduction from the problem $\mathsf{Ham\text{-}Cycle}$, which takes as input a directed graph $G = (V,E)$ and asks whether $G$ has a Hamiltonian cycle, i.e., whether there exists a cycle $v_1,\ldots,v_n,v_1$ in $G$ such that, for distinct integers $i,j \in [n]$, $v_i \neq v_j$, and $V = \{v_1,\ldots,v_n\}$.



\medskip
\noindent \textbf{The Linear Datalog Query.}
We start by defining the linear Datalog query $Q = (\dep,{\rm Path})$. If the name of a variable is not important, then we use $\_$ for a fresh variable occurring only once in $\dep$. By abuse of notation, we use semicolons instead of commas in a tuple expression in order to separate terms with a different meaning. The program $\dep$ follows:
\begin{eqnarray*}
\sigma_1 &:& {\rm MarkedE}(x)\,\, \assign \,\, {\rm First}(x)\\
\sigma_2 &:& {\rm MarkedE}(y)\,\, \assign \,\, E(\_,\_;x,y;\_), {\rm MarkedE}(x),\\
\sigma_3 &:& {\rm Path}(y)\,\, \assign \,\, E(x,y;\_,\_;z), {\rm MarkedE}(z), N(x), \\
\sigma_4 &:& {\rm Path}(y)\,\, \assign \,\, E(x,y;\_,\_;\_), {\rm Path}(x), N(x).
\end{eqnarray*}
It is easy to verify that $\dep$ is indeed a linear Datalog program.
\begin{comment}
The high-level idea underlying the program $\dep$ is, for each variable $v$ occurring in a given Boolean formula $\varphi$, to non-deterministically assign a value ($0$ or $1$) to $v$, and then check whether the global assignment makes $\varphi$ true.
%
The rules $\sigma_1$ and $\sigma_2$ are responsible for assigning $0$ or $1$ to a variable $v$; the last two positions of the relation ${\rm Var}$ always store the values $0$ and $1$, respectively.
%
The rules $\sigma_3$, $\sigma_4$, and $\sigma_5$ are responsible for checking whether an assignment for a certain variable $v$ makes a literal that mentions $v$ in some clause $C$ (and thus, $C$ itself) true.
%
The rules $\sigma_6$ and $\sigma_7$ are responsible, once we are done with a certain variable $v$, to consider the variable $u$ that comes after $v$; the relation ${\rm Next}$ provides an ordering of the variables in the given 3CNF Boolean formula.
%
Finally, once all the variables of the formula have been considered, $\sigma_8$ brings us to the last variable, which is a dummy one, that indicates the end of the above process.
\end{comment}



\medskip
\noindent \textbf{From $\mathsf{Ham\text{-}Cycle}$ to  $\mathsf{Why\text {-}Provenance_{NR}}[Q]$.} We now show that $\mathsf{Why\text {-}Provenance}[Q]$ is \NP-hard by reducing from $\mathsf{Ham\text{-}Cycle}$.
%
Consider a directed graph $G = (V,E)$ with $E = \{e_1,\ldots,e_m\}$.
%
Let $D_G$ be the database over $\esch{\dep}$
\begin{multline*}
\{{\rm First}(1)\} \cup \{N(v) \mid v \in V\}\ \cup \\
\{E(u,v;i,i+1;m+1) \mid i \in [m] \text{ and } e_i = (u,v)\},
\end{multline*}
which essentially stores the graph $G$ and provides an ordering of its edges.
%
We now show the next lemma, which states that the above construction leads to a correct polynomial-time reduction from $\mathsf{Ham\text{-}Cycle}$  to $\mathsf{Why\text {-}Provenance_{NR}}[Q]$.

\begin{lemma}\label{lem:reduction-from-hasm-cycle}
	The following hold:
	\begin{enumerate}
	\item $D_G$ can be constructed in polynomial time w.r.t.~$G$.
	\item $G$ has a Hamiltonian cycle iff $D_G \in \nrwhy{(v^*)}{D_G}{Q}$ for some arbitrary node $v^* \in V$.
	\end{enumerate}
\end{lemma}

\begin{proof}
	It is straightforward to see that $D_G$ can be constructed in polynomial time in the size of $G$. We proceed to establish item (2). We start with the direction $(\Rightarrow )$.
	%
	%\medskip
	%\noindent \underline{Direction $(\Rightarrow)$}
	%\smallskip
	%
	%\noindent 
	Assume that $G$ has a Hamiltonian cycle $v_1,\ldots,v_n,v_{n+1}$, and w.l.o.g.~let $v_1 = v_{n+1} = v^*$. Hence, there exist edges $(v_1,v_2),\ldots,(v_{n-1},v_n),(v_n,v_{n+1})$ in $G$. We define the labeled rooted tree $T=(V',E',\lambda)$: for the root $v \in V'$, let $\lambda(v) = {\rm Path}(v_{n+1}) = {\rm Path}(v^*)$, and inductively:
	\begin{enumerate}
		\item If $v \in V'$ is such that $\lambda(v) = {\rm Path}(v_{i+1})$, for $i \in \{2,\ldots,n\}$, then $v$ has 3 children $u_1,u_2,u_3$, where 
		$\lambda(u_1)$ is the (only) fact in $D_{G}$ of the form $E(v_i,v_{i+1};\cdot,\cdot;\cdot)$, $\lambda(u_2) = {\rm Path}(v_i)$, and $\lambda(u_3) = N(v_i)$.
		
		\item if $v \in V'$ is such that $\lambda(v) = {\rm Path}(v_2)$, $v$ has 3 children $u_1,u_2,u_3$, where $\lambda(u_1)$ is the (only) fact in $D_G$ of the form $E(v_1,v_2;\cdot,\cdot;m+1)$, $\lambda(u_2) = {\rm MarkedE}(m+1)$, and $\lambda(u_3) = N(v_1)$.
		
		\item if $v \in V'$ is such that $\lambda(v) = {\rm MarkedE}(i+1)$, for $i \in \{1,\ldots,m\}$, then $v$ has 2 children $u_1,u_2$, where $\lambda(u_1)$ is the (only) fact in $D_G$ of the form $E(\cdot,\cdot;i,i+1;\cdot)$, and $\lambda(u_2) = {\rm MarkedE}(i)$.
		
		\item if $v \in V'$ is such that $\lambda(v) = {\rm MarkedE}(1)$, then $v$ has only one child $u$, where $\lambda(u) = {\rm First}(1)$.
	\end{enumerate}
	This completes the construction of $T$.
	%
	We proceed to show that $T$ is a non-recursive proof tree of ${\rm Path}(v^*)$ w.r.t.~$D_G$ and $Q$ such that $\support{T} = D_G$, which in turn implies that $D_G \in \nrwhy{(v^*)}{D_G}{Q}$, as needed.
	%
	Since $\dep$ is linear, at each level of $T$ there exists at most one non-leaf node. Moreover, the edges in $T$ going from level $i$ to level $i+1$, with $i \in \{0,\ldots,n-1\}$, and the labels of the corresponding nodes, as defined in item~(1), are valid since they are obtained by considering rule $\sigma_4$ and there exist edges $(v_i,v_{i+1}) \in E$, for $i \in \{2,\ldots,n\}$. The edges in $T$ from level $n-1$ to $n$ are obtained considering $\sigma_3$, and the labels are again valid since $(v_1,v_2) \in E$. Then, for all the remaining levels, except the last one, we consider $\sigma_2$ in item~(3), and for the last level we consider $\sigma_1$, in item~(4). In these last two cases, it is easy to verify that the labels are valid.
	Crucially, by construction of $T$, for every non-leaf node there is no other node in $T$ with the same label, and thus, the proof tree is trivially non-recursive. Regarding the support, by item~(1), $N(v_i) \in \support{T}$, for $i \in \{2,\ldots,n\}$. By item~(2), $N(v_1) \in \support{T}$. Moreover, by item~(3), $E(u,v;i,i+1;m+1) \in \support{T}$, where $(u,v) = e_i$, for $i \in [m]$. Finally, by item~(4), ${\rm First}(1) \in \support{T}$. Therefore, $\support{T}=D_G$, and the claim follows.
	
	%\medskip
	%\noindent \underline{Direction $(\Leftarrow)$}
	%\smallskip
	
	%\noindent 
	We now proceed with the direction $(\Leftarrow)$. Assume that $D_G \in \nrwhy{(v^*)}{D_G}{Q}$, which in turn implies that there is a non-recursive proof tree $T=(V,E,\lambda)$ of $(v^*)$ w.r.t.~$D_G$ and $Q$ such that $\support{T}=D_{G}$. Let $n$ be the number of nodes in $G$, and assume w.l.o.g.\ that $n \ge 2$.
	Note that by linearity of $\dep$, at each level of $T$, besides the last one, there exists precisely one non-leaf node. Let $u_i$ be the non-leaf node at level $i$. Clearly, $u_0,u_1,\ldots$ is a path in $T$. Note that, by the definition of $Q$, $u_0$, i.e., the root, is necessarily labeled with a fact using the predicate ${\rm Path}$; this is also the case for $u_i$, at level $i \in \{1,\ldots,n-1\}$. Indeed, assume, towards a contradiction, that $i \in \{1,\ldots,n-1\}$ is the first level in $T$ where $u_i$ is \emph{not} labeled with a fact using the predicate ${\rm Path}$. Since $\sigma_3$ and $\sigma_4$ are the only rules in $\dep$ with a body-atom using the predicate $N$, and since these are the only rules where ${\rm Path}$ appears in the head, $\support{T}$ contains no more than $i < n$ facts using the predicate $N$, and thus, $\support{T} \neq D_G$, which is a contradiction.
	
	Since $u_0,\ldots,u_{n-1}$ is a path in $T$, and such nodes are all labeled with a fact using ${\rm Path}$, we conclude that such labels are obtained by using $\sigma_4$, as it is the only rule having the predicate ${\rm Path}$ both in its body and its head. Hence, because of the atom $E(x,y;\_,\_;\_)$ in $\body{\sigma_4}$, which uses an extensional predicate of $\dep$, and from the fact that $T$ is a proof tree, $\lambda(u_i) = {\rm Path}(v_i)$, where $v_i$ is some node of the graph $G$. Therefore, since $T$ is non-recursive, ${\rm Path}(v_0),{\rm Path}(v_1),\ldots,{\rm Path}(v_{n-1})$ are all distinct, and thus, $v_0,v_1,\ldots,v_{n-1}$ are distinct. Hence, again from the fact that the atom $E(x,y;\_,\_;\_)$ appears in $\body{\sigma_4}$ with an extensional predicate, the fact that $T$ is a proof tree, and by the construction of $D_G$, we conclude that $(v_{n-1},v_{n-2}),\ldots,(v_1,v_0)$ are all the edges of the graph $G$. Therefore, $v_0,\ldots,v_{n-1}$ is the reverse of a Hamiltonian path in $G$. 
	%
	Moreover, let $S_i \subseteq \support{T}$ be the set of facts using the predicate $N$ that label nodes of $T$ up to level $i$. Because of the atom $N(x)$ in the body of $\sigma_4$, we conclude that $S_{n-1} = \{N(v_1),\ldots,N(v_{n-1})\}$, that is, $S_{n-1}$ contains all nodes of the graph $G$, except for $v_0$.
	
	Let us focus now on the node $u_{n-1}$ of $T$. Recall that $\lambda(u_{n-1}) = {\rm Path}(v_{n-1})$. Note that the children of $u_{n-1}$ cannot be labeled using $\sigma_4$ anymore, since it contains the two body atoms ${\rm Path}(x),N(x)$, where $N$ is an extensional predicate. Hence, since $v_0,\ldots,v_{n-1}$ are precisely all the nodes of $G$, one of the children of $u_{n-1}$ would necessarily be labeled with a fact ${\rm Path}(v)$, where $v$ will necessarily coincide with some of the nodes in $v_0,\ldots,v_{n-1}$, and thus, $T$ would not be non-recursive. Hence, the only rule left is $\sigma_3$. As already discussed, up to level $n-1$, the set of facts in $\support{T}$ with predicate $N$ is $S_{n-1}=\{N(v_1),\ldots,N(v_{n-1})\}$. Hence, for $\support{T}$ to also contain ${\rm Path}(v_0) \in D_G$, there must be at least one more node below level $n-1$ in $T$ that is labeled with $N(v_0)$. Since $\sigma_3$ has no body atom with predicate ${\rm Path}$, necessarily one of the children of $u_{n-1}$ is labeled with $N(v_0)$. Hence, thanks to the atom $E(x,y;\_,\_;z)$ in the body of $\sigma_4$, we conclude that there is also an edge $(v_0,v_{n-1})$ in $G$, and thus, $v_0,v_1,\ldots,v_{n-1},v_0$ is the reverse of a Hamiltonian cycle of $G$, and the claim follows.
\end{proof}

By Lemma~\ref{lem:reduction-from-hasm-cycle}, $\mathsf{Why\text {-}Provenance_{NR}}[Q]$ is \NP-hard. Thus, $\mathsf{Why\text {-}Provenance_{NR}[\LDAT]}$ is \NP-hard in data complexity.




\subsection{Non-Recursive Queries}
%

We now focus on non-recursive Datalog queries, and show the following about the data complexity of why-provenance relative to non-recursive proof trees:

\begin{theorem}\label{the:non-recursive-complexity-nr}
	$\mathsf{Why\text {-}Provenance_{NR}[\NRDAT]}$ is in $\ACZ$ in data complexity.
\end{theorem}

\begin{proof}
This is shown via first-order rewritability as done for Theorem~\ref{the:non-recursive-complexity}. In fact, the construction of the target FO query is exactly the same as in the proof of Theorem~\ref{the:non-recursive-complexity} with the key difference that, for a Datalog query $Q$, the set of CQs $\cq{Q}$ is defined by considering only non-recursive proof trees, i.e., is the set $\{\cq{T} \mid T \text{ is a {\em non-recursive} $Q$-tree}\}$.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Minimal-Depth Proof Trees}\label{sec:minimal-depth-proof-trees}
%

We now focus on another refined class of proof trees that has been considered in the literature. Recall that the depth of a rooted tree $T$, denoted $\depth{T}$, is the length of the longest path from its root to a leaf node. Given a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha \in \dep(D)$, let $\mtd{\alpha}{D}{\dep}$ be the integer
\[
\min\{\depth{T} \mid T \text{ is a proof tree of } \alpha \text{ w.r.t. } D \text{ and } \dep\},
\]
i.e., the minimal depth over all proof trees of $\alpha$ w.r.t.~$D$ and $\dep$. The notion of minimal-depth proof tree follows:

\begin{definition}[\textbf{Minimal-Depth Proof Tree}]\label{def:min-depth-proof-tree}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. A {\em minimal-depth proof tree of $\alpha$ w.r.t.~$D$ and $\dep$} is a proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that $\depth{T}$ coincides with $\mtd{\alpha}{D}{\dep}$. \hfill\markfull
\end{definition}


Why-provenance relative to minimal-depth proof trees is defined as expected. Given a Datalog query $Q = (\dep,R)$, a database $D$ over $\esch{\dep}$, and a tuple $\bar t \in \adom{D}^{\arity{R}}$, the {\em why-provenance of $\bar t$ w.r.t.~$D$ and $Q$ relative to minimal-depth proof trees} is defined as the family of sets of facts
\begin{multline*}
\{\support{T} \mid T \text{ is a minimal-depth proof tree of }\\
R(\bar t) \text{ w.r.t. } D \text{ and } \dep\}
\end{multline*}
denoted $\mdwhy{\bar t}{D}{Q}$.
%
Then, the algorithmic problems
\[
\mathsf{Why\text {-}Provenance_{MD}[C]} \quad \text{and} \quad  \mathsf{Why\text {-}Provenance_{MD}}[Q]
\] 
are defined as expected. We proceed to study the data complexity of $\mathsf{Why\text {-}Provenance_{MD}[C]}$ for each class $\class{C} \in \{\DAT,\LDAT,\NRDAT\}$. As shown in the case of arbitrary and non-recursive proof trees, for recursive queries, even if the recursion is restricted to be linear, the problem is in general intractable, whereas for non-recursive queries it is highly tractable. We first focus on recursive queries.



\subsection{Recursive Queries}
%

We show the following complexity result:

\begin{theorem}\label{the:complexity-minimal-depth-proof-trees-np}
	$\mathsf{Why\text {-}Provenance_{MD}[C]}$ is \NP-complete in data complexity, for each class $\class{C} \in \{\DAT,\LDAT\}$.
\end{theorem}



To prove Theorem~\ref{the:complexity-non-recursive-proof-trees-np}, it suffices to show that:
\begin{itemize}
	\item $\mathsf{Why\text {-}Provenance_{MD}[\DAT]}$ is in \NP~in data complexity.
	\item $\mathsf{Why\text {-}Provenance_{MD}[\LDAT]}$ is \NP-hard in data compl.
\end{itemize}
Let us first focus on the upper bound.


\medskip

\noindent \underline{\textbf{Upper Bound}}
\smallskip

\noindent The proof is similar to the proof of the analogous result for $\mathsf{Why\text {-}Provenance_{NR}[\DAT]}$ (see Theorem~\ref{the:complexity-non-recursive-proof-trees-np}). 
%
Given a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$, we first define the notion of {\em minimal-depth proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$}.
%
We then establish a result analogous to Proposition~\ref{pro:characterization-nr-trees}: the existence of a minimal-depth proof tree of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D' \subseteq D$ is equivalent to the existence of a polynomially-sized minimal-depth proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$. This in turn allows us to devise a guess-and-check algorithm that runs in polynomial time. We proceed to formalize this high-level description.


The notion of depth can be naturally transferred to rooted DAGs. In particular, for a rooted DAG $G$, the {\em depth} of $G$, denoted $\depth{G}$, is defined as the length of the longest path from the root of $G$ to a leaf node of $G$.
%
Given a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha \in \dep(D)$, let $\mgd{\alpha}{D}{\dep}$ be the integer
\[
\min\{\depth{G} \mid G \text{ is a proof DAG of } \alpha \text{ w.r.t. } D \text{ and } \dep\},
\]
i.e., the minimal depth over all proof DAGs of $\alpha$ w.r.t.~$D$ and $\dep$. Before introducing minimal-depth proof DAGs, let us establish a key property of $\mgd{\alpha}{D}{\dep}$, which will play a crucial role in our complexity analysis. 




\begin{proposition}\label{pro:depth-ptime}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha \in \dep(D)$. The integer $\mgd{\alpha}{D}{\dep}$ can be computed in polynomial time in $|D|$.
\end{proposition}

\begin{proof}
	The proof relies on the well-known immediate consequence operator for Datalog. Roughly, the operator constructs in different steps all the facts that can be derived starting from $D$ and applying the rules of $\dep$. In particular, each fact is constructed ``as early as possible'', and we are going to show that the step at which a fact $\alpha$ is first obtained coincides with $\mgd{\alpha}{D}{\dep}$.
	
	A fact $R(\bar t)$ is an {\em immediate consequence of $D$ and $\dep$} if
	\begin{itemize}
		\item $R(\bar t) \in D$, or
		\item there exists a Datalog rule $R(\bar x)\,\assign\, R_1(\bar x_1),\ldots,R_n(\bar x_n)$ in $\dep$ and a function $h : \bigcup_{i \in [n]} \bar x_i \ra \ins{C}$ such that $\{R_1(h(\bar x_1)),\ldots,R_n(h(\bar x_n))\} \subseteq D$ and $h(\bar x) = \bar t$.
	\end{itemize}
	The immediate consequence operator for $\dep$ is defined as the function $T_\dep$ from the set $S$ of databases over $\sch{\dep}$ to $S$
	\begin{multline*}
	T_\dep(D)\ =\ \{R(\bar t) \mid R(\bar t) \text{ is an immediate}\\
	\text{consequence of } D \text{ and } \dep\}.
	\end{multline*}
	We then define
	\[
	T_\dep^0(D)\ =\ D, 
	\]
	and for each $i>0$, 
	\[
	T_\dep^i(D)\ =\ T_\dep( T_\dep^{i-1}(D)).
	\]
	Finally, we define
	\[
	T_\dep^\infty(D)\ =\ \bigcup_{i \ge 0} T_\dep^i(D).
	\]
	%It is well-known that for every $k$-ary query $Q=(\dep,P)$, database $D$ over $\esch{\dep}$, and tuple $\bar t \in \adom{D}^k$, $\bar t \in Q(D)$ iff $P(\bar t) \in T_{\dep}^\infty(D)$.
	%
	It is not difficult to see that 
	\[
	T_\dep^\infty(D)\ =\ T_\dep^{|\base{D,\dep}|}(D),
	\]
	which in turn implies that $T_\dep(D)$ can be computed in polynomial time in the size of $D$; see, e.g.,~\cite{DEGV01}. Hence, for each $i \ge 0$, $T_\dep^i(D)$ can be computed in polynomial time in the size of $D$.
	%
	Note that $T_\dep^\infty(D) = \dep(D)$~\cite{AbHV95}.
	%
	%Moreover, for every program $\dep$ and database $D$ over $\esch{\dep}$, there exists $n \ge 0$ that is a polynomial w.r.t.\ $D$, and it is such that $T_\dep^\infty(D) = T_\dep^n(D)$, since the number of facts in $\base{D,\dep}$ is at most polynomial w.r.t.\ $D$. Hence, for each $i \ge 0$, $T_\dep^i(D)$ can be computed in polynomial time w.r.t.\ $D$.
	
	The above discussion, together with the following auxiliary lemmas, will prove our claim. For a fact $\alpha \in T_\dep^\infty(D)$, we write $\rank{\alpha}{D,\dep}$ for the integer $\min\{i \mid \alpha \in T_\dep^i(D)\}$.
	
	\begin{lemma}\label{lem:rank-leq}
		%Consider a program $\dep$, and a database $D$ over $\esch{\dep}$. For every $n \ge 0$, and every $R(\bar t) \in T_\dep^\infty(D)$, $\mingdepth{D}{(\dep,R)}{\bar t}=n$ iff $\rank{R(\bar t)}{D,\dep} = n$.
		For every fact $\alpha \in T_\dep^\infty(D)$, $\rank{\alpha}{D,\dep} = \mgd{\alpha}{D}{\dep}$.
	\end{lemma}

	\begin{proof}
		Consider an arbitrary fact $\alpha \in T_\dep^\infty(D)$ and let $n = \mgd{\alpha}{D}{\dep}$. We proceed by induction on $n$.
		
		\medskip
		\noindent \textbf{Base Case.} For $n = 0$, the claim follows immediately by the definition of proof DAG and of $T_\dep$.
		
		\medskip
		\noindent \textbf{Inductive Step.} There is a proof DAG $G=(V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\depth{G} = n$. Let $u_1,\ldots,u_k$ be the out-neighbours of the root node $v$, and let $\lambda(u_i) = R_i(\bar u_i)$, for each $i \in [k]$. Since $\depth{G} =n$, for each $i \in [k]$, $\mgd{R_i(\bar u_i)}{D}{\dep} \le \depth{G_i} < n$, with $G_i$ being the subDAG of $G$ rooted at $u_i$. By inductive hypothesis, $\rank{R_i(\bar u_i)}{D,\dep} \leq \mgd{R_i(\bar u_i)}{D}{\dep}$, for each $i \in [k]$, and thus, $\{R_1(\bar u_1),\ldots,R_k(\bar u_k)\} \subseteq T_\dep^{n-1}(D)$. Moreover, by the definition of proof DAG, there exist a rule $R_0(\bar x_0) \assign R_1(\bar x_1),\ldots,R_k(\bar x_k)$ in $\dep$ and a function $h : \bigcup_{i \in [n]} \bar x_i \ra \ins{C}$ such that $\alpha = R_0(h(\bar x_0))$ and $h(\bar x_i) = \bar u_i$ for each $i \in [k]$. Consequently, $\rank{\alpha}{D,\dep} \leq \max_{i \in [k]} \{\rank{R_i(\bar u_i)}{D,\dep}\} + 1 \leq n$.
		%
		We further observe that $\alpha \not\in T_{\dep}^{n-1}(D)$ since, otherwise, by induction hypothesis we can conclude that $\mgd{\alpha}{D}{\dep} < n$, which is a contradiction. Hence, $\rank{\alpha}{D,\dep} = n$.
		%
		%$\alpha \in T_\dep^n(D)$. Observe that $\alpha \not\in T_\dep^{n-1}(D)$; otherwise, $\mgd{\alpha}{D}{\dep} < n$, which is a contradiction. Therefore, $\rank{\alpha}{D,\dep} \leq n$, as needed.
	\end{proof}
	
	\begin{comment}
	\begin{lemma}\label{lem:rank-geq}
		For every fact $\alpha \in T_\dep^\infty(D)$, $\rank{\alpha}{D,\dep} \geq \mgd{\alpha}{D}{\dep}$.
	\end{lemma}

	\begin{proof}
		Consider an arbitrary fact $\alpha \in T_\dep^\infty(D)$ and let $n = \rank{\alpha}{D,\dep}$. We proceed by induction on $n$.
		
		\medskip
		\noindent \textbf{Base Case.} For $n = 0$, the claim follows immediately by the definition of proof DAG and of $T_\dep$.
		
		\medskip
		\noindent \textbf{Inductive Step.} Assume that $\rank{\alpha}{D,\dep} = n$. There exist a rule $R_0(\bar x_0) \assign R_1(\bar x_1),\ldots,R_k(\bar x_k)$ in $\dep$ and a function $h : \bigcup_{i \in [n] \bar x_i} \ra \ins{C}$ such that $\alpha = R_0(h(\bar x_0))$ and $\{R_1(h(\bar x_1)),\ldots,R_k(h(\bar x_k))\} \subseteq T_\dep^{n-1}(D)$. Hence, $\rank{R_i(h(\bar x_i))}{D,\dep} < n$, for each $i \in [k]$.
		%
		Clearly, by inductive hypothesis, $\mgd{R_i(h(\bar x_i))}{D}{\dep} \leq \rank{R_i(h(\bar x_i))}{D,\dep}$, for each $i \in [k]$.
		%
		Let $G_i$ be a proof DAG of $R_i(h(\bar x_i))$ w.r.t.~$D$ and $\dep$ with $\depth{G_i} = \mgd{R_i(h(\bar x_i))}{D}{\dep}$, for each $i \in [k]$. Consider now the DAG $G$ obtained by adding to the joint union of $G_1,\ldots,G_k$ a node $v$, which is the root of $G$, labeled by $\alpha$ and its only out-neighbours are the roots of $G_1,\ldots,G_k$. It is easy to see that $G$ is a proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$ with $\depth{G} = \max_{i \in [k]} \{\depth{G_i}\} + 1 \leq n$. Therefore, $\mgd{\alpha}{D}{\dep} \leq n$, as needed.
	\end{proof}
	\end{comment}
	
	The claim follows by Lemma~\ref{lem:rank-leq}.
\end{proof}


The central notion of minimal-depth proof DAG follows:

\begin{definition}[\textbf{Minimal-Depth Proof DAG}]\label{def:minimal-depth-proof-dag}
	Consider a Datalog program $\dep$, a database $D$ over $\esch{\dep}$, and a fact $\alpha$ over $\sch{\dep}$. 
	%
	A {\em minimal-depth proof DAG of $\alpha$ w.r.t.~$D$ and $\dep$} is a proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that $\depth{G}$ coincides with $\mgd{\alpha}{D}{\dep}$. \hfill\markfull
\end{definition}


The analogous result to Proposition~\ref{pro:characterization-nr-trees} follows:



\begin{proposition}\label{pro:characterization-md-trees}
	For a Datalog program $\dep$, there is a polynomial $f$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$ over $\sch{\dep}$, and $D' \subseteq D$, the following are equivalent:
	\begin{enumerate}
		\item There is a minimal-depth proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$.
		\item There is a minimal-depth proof DAG $G = (V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$ and $|V| \leq f(|D|)$.
	\end{enumerate}
\end{proposition}



The direction (2) implies (1) is shown by ``unravelling'' the minimal-depth proof DAG $G$ into a minimal-depth proof tree $T$ such that $\support{G} = \support{T}$.
We use the same ``unravelling'' construction as in the proof of direction (2) implies (1) of Proposition~\ref{pro:characterization-all-trees}, which {\em preserves the minimality of the depth}.
%
We now proceed with the direction (1) implies (2). The underlying construction proceeds in two main steps captured by Lemmas~\ref{lem:scount-reduction-md} and~\ref{lem:from-trees-to-dags-md} given below.



\medskip 

$\bullet$ The \textbf{\textit{first step}} is to show that a minimal-depth proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ can be converted into a minimal-depth proof tree $T'$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T'} = D'$ that has ``small'' subtree count.


\begin{lemma}\label{lem:scount-reduction-md}
	For each Datalog program $\dep$, there is a polynomial $f$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$ over $\sch{\dep}$, and $D' \subseteq D$, if there is a minimal-depth proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$, then there is also such a proof tree $T'$ with $\scount{T'} \leq f(|D|)$.
\end{lemma}

\begin{proof}
	We first argue that the proof tree $T$ has ``small'' depth. In particular, by Lemma~\ref{lem:depth-reduction}, there exists a polynomial $f$ and a proof tree $T'$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\depth{T'} \leq f(|D|)$. Since, by hypothesis, $T$ is of minimal-depth, we conclude that $\depth{T} \leq f(|D|)$.
	%
	The other crucial observation is that the construction underlying Lemma~\ref{lem:scount-reduction}, which converts a proof tree of ``small'' depth into a proof tree of ``small`` subtree count with the same support {\em preserves the minimality of the depth}. It can be verified that the proof tree $T'$ obtained by applying on $T$ the construction underlying Lemma~\ref{lem:scount-reduction} is such that $\depth{T'} \leq \depth{T}$. Hence, since $T$ is a minimal-depth proof tree, then so is $T'$.
	%
	Consequently, we can apply the construction of Lemma~\ref{lem:scount-reduction} to the minimal-depth proof tree $T$ and get a minimal-depth proof tree $T'$ with $\support{T} = \support{T'}$ such that $\scount{T'} \leq f(|D|)$, where $f$ is the polynomial provided by Lemma~\ref{lem:scount-reduction}.
\end{proof}


\smallskip

$\bullet$ The \textbf{\textit{second step}} shows that a minimal-depth proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ of ``small'' subtree count can be converted into a compact minimal-depth proof DAG $G$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$.

\begin{lemma}\label{lem:from-trees-to-dags-md}
	For each Datalog program $\dep$ and a polynomial $f$, there is a polynomial $g$ such that, for every database $D$ over $\esch{\dep}$, fact $\alpha$, and $D' \subseteq D$, if there is a minimal-depth proof tree $T$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$ and $\scount{T} \leq f(|D|)$, then there is a minimal-depth proof DAG $G = (V,E,\lambda)$ of $\alpha$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$ and $|V| \leq g(|D|)$.
\end{lemma}

\begin{proof}
	We employ the construction underlying Lemma~\ref{lem:from-trees-to-dags}, which converts a proof tree of ``small'' subtree count into a non-recursive proof DAG of polynomial size with the same support, since it {\em preserves the minimality of the depth}. 
	%The latter holds since, for each path of the proof tree, there is a path in the proof DAG with the same labels, and vice versa. 
\end{proof}


It is now clear that the direction (1) implies (2) of Proposition~\ref{pro:characterization-md-trees} is an immediate consequence of Lemmas~\ref{lem:scount-reduction-md} and~\ref{lem:from-trees-to-dags-md}.


\medskip
\noindent
\textbf{Finalize the Proof.} We can now finalize the proof of the claim that $\mathsf{Why\text {-}Provenance_{MD}[\DAT]}$ is in \NP~in data complexity.
%
Fix a Datalog query $Q = (\dep,R)$. Given a database $D$ over $\esch{\dep}$, a tuple $\bar t \in \adom{D}^{\arity{R}}$, and a subset $D'$ of $D$, to decide whether $D' \in \mdwhy{\bar t}{D}{Q}$ we simply need to check for the existence of a minimal-depth proof tree $T$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$. By Proposition~\ref{pro:characterization-md-trees}, this is tantamount to the existence of a polynomially-sized minimal-depth proof DAG $G$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{G} = D'$.
%
The existence of such a non-recursive proof DAG can be checked via a non-deterministic algorithm that runs in polynomial time in the size of the database as it was done for proving that $\mathsf{Why\text {-}Provenance[\DAT]}$ is in \NP~in data complexity (Theorem~\ref{the:recursive-complexity}). The only difference is that now we need to additionally check that the guessed DAG $G$ is of minimal-depth, i.e., that $\depth{G}$ coincides with $\mgd{R(\bar t)}{D}{\dep}$.
%
It remains to argue that the latter can be done in polynomial time. The fact that $\mgd{R(\bar t)}{D}{\dep}$ can be computed in polynomial time follows from Proposition~\ref{pro:depth-ptime}. Now, $\depth{G}$ can be computed by converting $G$ into an edge-weighted graph $G'$ by assigning weight $-1$ to each edge, and then running Dijkstra's polynomial-time algorithm for finding the smallest weight of a path between two nodes.\footnote{We recall that Dijkstra's algorithm is correct on graphs with \emph{arbitrary} integer edge labels, only when the input graph is a DAG. Indeed, for general graphs, computing the length of the longest path between two nodes is $\NP$-hard.}
%
Consequently, $\mathsf{Why\text {-}Provenance_{MD}}[Q]$ is in \NP, and thus, $\mathsf{Why\text {-}Provenance_{MD}[\DAT]}$ is in \NP~in data complexity.


\medskip

\noindent \underline{\textbf{Lower Bound}}
\smallskip

\noindent We proceed to establish that $\mathsf{Why\text {-}Provenance_{MD}[\LDAT]}$ is \NP-hard in data complexity. To this ends, we need to show that there exists a linear Datalog query $Q$ such that the problem $\mathsf{Why\text {-}Provenance_{MD}}[Q]$ is \NP-hard. The proof is via a reduction from $\mathsf{3SAT}$, which takes as input a Boolean formula $\varphi = C_1 \wedge \ldots \wedge C_m$ in 3CNF, where each clause has exactly 3 literals (a Boolean variable $v$ or its negation $\neg v$), and asks whether $\varphi$ is satisfiable.


\medskip
\noindent \textbf{The Linear Datalog Query.}
We start by defining the linear Datalog query $Q = (\dep,R)$. We actually adapt the query $Q$ used in the proof of the fact that $\mathsf{Why\text {-}Provenance[\LDAT]}$ is \NP-hard in data complexity (see Theorem~\ref{the:recursive-complexity}) in such a way that every proof tree has the same depth.
%
As usual, we use $\_$ if the name of a variable is not important, and semicolons in a tuple expression in order to separate terms with a different semantic meaning. The program $\dep$ follows:
\begin{eqnarray*}
\sigma_1 &:& R(x)\,\, \assign \,\,{\rm Var}(x;y,\_;z),{\rm Assign}(x,y,z), \\
\sigma_2 &:& R(x)\,\, \assign \,\, {\rm Var}(x;\_,y;z),{\rm Assign}(x,y,z),\\
\sigma_3 &:& {\rm Assign}(x,y,z)\,\, \assign \,\, {\rm NextC}(x;z,w;k,\ell),\\
&& \hspace{10mm}  C(x,y;\_,\_;\_,\_;z,w;k,\ell), {\rm Assign}(x,y,w),\\
\sigma_4 &:& {\rm Assign}(x,y,z) \,\, \assign \,\, {\rm NextC}(x;z,w;k,\ell),\\
&& \hspace{10mm} C(\_,\_;x,y;\_,\_;z,w;k,\ell),{\rm Assign}(x,y,w), 
\end{eqnarray*}
\begin{eqnarray*}
\sigma_5 &:& {\rm Assign}(x,y,z) \,\, \assign \,\, {\rm NextC}(x;z,w;k,\ell),\\
&& \hspace{10mm} C(\_,\_;\_,\_;x,y;z,w;k,\ell), {\rm Assign}(x,y,w), \\
\sigma' &:& {\rm Assign}(x,y,z) \,\, \assign \,\, {\rm NextC}(x;z,w;y,\_),\\
&& \hspace{45mm}{\rm Assign}(x,y,w), \\
\sigma'' &:& {\rm Assign}(x,y,z) \,\, \assign \,\, {\rm NextC}(x;z,w;\_,y),\\
&& \hspace{45mm}{\rm Assign}(x,y,w), \\
\sigma_6 &:& {\rm Assign}(x,z,w) \,\, \assign \,\, {\rm Next}(x,y;z,\_;w),R(y), \\
\sigma_7 &:& {\rm Assign}(x,z,w) \,\, \assign \,\, {\rm Next}(x,y;\_,z;w),P(y), \\
\sigma_8 &:& R(x) \,\, \assign \,\, {\rm Last}(x).
\end{eqnarray*}
The key difference compared to the Datalog program used in the proof of Theorem~\ref{the:recursive-complexity} is that now, roughly speaking, the rules $\sigma_1, \sigma_2$ also attach the id of the first clause to the variable assignment; the last position of the relation ${\rm Var}$ stores the id of the first clause. The rules $\sigma_3,\sigma_4,\sigma_5,\sigma',\sigma''$, where $\sigma_3$, $\sigma_4$ and $\sigma_5$ are adapted from the previous proof, whereas $\sigma'$, $\sigma''$ are new, force a subtree to always to perform $m$ ``steps'', when going through those rules; {\rm NextC} provides an ordering of the clauses of the formula.
%
It is easy to verify that $\dep$ is indeed a linear Datalog program.
%



\medskip
\noindent \textbf{From $\mathsf{3SAT}$ to  $\mathsf{Why\text {-}Provenance_{MD}}[Q]$.} We now establish that $\mathsf{Why\text {-}Provenance_{MD}}[Q]$ is \NP-hard by reducing from $\mathsf{3SAT}$.
%
Consider a 3CNF Boolean formula $\varphi = C_1 \wedge \cdots \wedge C_m$ with $n$ Boolean variables $v_1,\ldots,v_n$. For a literal $\ell$, we write $\lvar{\ell}$ for the variable occurring in $\ell$, and $\lsign{\ell}$ for the number $1$ (resp., $0$) if $\ell$ is a variable (resp., the negation of a variable).
%
We define $D_\varphi$ as the database over $\esch{\dep}$
\begin{eqnarray*}
&& \{{\rm Var}(v_i;0,1;1) \mid i \in [n]\}\\
&\cup& \{{\rm Next}(v_i,v_{i+1};0,1;m+1) \mid i \in [n-1]\}\\
&\cup& \{{\rm Next}(v_n,\bullet;0,1;m+1), {\rm Last}(\bullet)\}\\
&\cup& \{C(\lvar{\ell_1},\lsign{\ell_1};\lvar{\ell_2},\lsign{\ell_2};\lvar{\ell_3},\lsign{\ell_3};i,i+1;0,1) \mid \\
&& \hspace{20mm} i \in [m] \text{ with } C_i = (\ell_1 \vee \ell_2 \vee \ell_3)\}\\
&\cup& \{{\rm NextC}(v_i;j,j+1;0,1) \mid i \in [n]\ \text{ and } j \in [m]\}.
\end{eqnarray*}
%
We can show the next lemma, which essentially states that the above construction leads to a correct polynomial-time reduction from $\mathsf{3SAT}$ to $\mathsf{Why\text {-}Provenance}[Q]$:

\begin{lemma}\label{lem:reduction-from-3sat-md}
	The following hold:
	\begin{enumerate}
		\item $D_\varphi$ can be constructed in polynomial time in $\varphi$. 
		\item $\varphi$ is satisfiable iff $D_\varphi \in \why{(v_1)}{D_\varphi}{Q}$.
	\end{enumerate}
\end{lemma}

\begin{proof}
	It is straightforward to see that $D_\varphi$ can be constructed in polynomial time in the size of $\varphi$. We proceed to establish item (2). But let us first state and prove an auxiliary technical lemma, which essentially states that all proof trees of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$ have the same depth. 
	
	\begin{lemma}\label{lem:same-depth}
		For every proof tree $T$ of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$, $\depth{T} = n \cdot (m+2) + 1$.
	\end{lemma}

	\begin{proof}
		A proof tree of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$ has a root node $v$ labeled with $R(v_1)$, and thus, its children are necessarily labeled with facts obtained by means of either rule $\sigma_1$ or $\sigma_2$. From these children, only one, say $u$, is labeled with an intensional fact, which is of the form ${\rm Assign}(v_1,\cdot,1)$ (the constant $1$ is due to the variable $z$ in the body of rules $\sigma_1,\sigma_2$). Then, the children of $u$ are necessarily labeled with facts obtained via one of $\sigma_3,\sigma_4,\sigma_5,\sigma',\sigma''$ (this is because of the constant $1$ in the fact labeling $u$). Moreover, due to the presence of the atom ${\rm NextC}(x;z,w;k,\ell)$ in the body of each such rule, only one child of $u$, say $u'$, is labeled with an intensional fact of the form ${\rm Assign}(v_1,\cdot,2)$. Applying the same reasoning, from this node with label ${\rm Assign}(v_1,\cdot,2)$, one of the rules $\sigma_3,\sigma_4,\sigma_5,\sigma',\sigma''$ will be used, and the id on the third position will be increased again, until it will coincide with $m+1$. Up to this point, the longest path in the tree from the root is of length $m$+1. It is not difficult to see now that the only rule that can be applied is either $\sigma_6$ or $\sigma_7$ due to the variable $w$ appearing in the atom ${\rm Next}(x,y;z,\_;w)$. After one of such rules is applied the only node labeled with an intensional fact has as label the fact $R(v_2)$, if $n>1$, and $R(\bullet)$ otherwise, and the total depth is $m+1+1 = m+2$. Thus, either $\sigma_1$ will then be used again, or $\sigma_8$. By applying the above reasoning for all the variables of $\varphi$, the total depth of a proof tree of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$ is precisely $n \cdot (m+2) + 1$, as needed.
	\end{proof}

	With Lemma~\ref{lem:same-depth} in place, to prove our claim it suffices to show that $\varphi$ is satisfiable iff there is a proof tree $T$ (regardless of its depth) of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$ such that $\support{T} = D_\varphi$. To prove this last claim, it is not difficult to see how one can adapt the proof given for Theorem~\ref{the:recursive-complexity}. The main difference is that we additionally need to argue that when a proof tree of $R(v_1)$ uses the rules $\sigma_3,\sigma_4,\sigma_5,\sigma',\sigma''$, and thus, we have a node in the proof tree labeled with a fact of the form ${\rm Assign}(v_i,\mathsf{val},j)$, if the truth value $\mathsf{val}$ chosen for $v_i$ does not make the clause $C_j$ true, then the proof tree will follow $\sigma'$ or $\sigma''$, depending on the value of $\mathsf{val}$. Hence, in any case, through rules $\sigma_3,\sigma_4,\sigma_5,\sigma',\sigma''$, any proof tree will be able to touch all facts with predicate ${\rm NextC}$ in the database. Since these are the only new facts w.r.t.~the ones used in the proof of Theorem~\ref{the:recursive-complexity} (all other facts have been only slightly modified), if $\varphi$ is satisfiable, then we have a proof tree $T$ of $R(v_1)$ w.r.t.~$D_\varphi$ and $\dep$ with the property that $\support{T} = D_\varphi$, and vice versa.
\end{proof}


By Lemma~\ref{lem:reduction-from-3sat-md}, $\mathsf{Why\text {-}Provenance_{MD}}[Q]$ is \NP-hard. Thus, $\mathsf{Why\text {-}Provenance_{MD}[\LDAT]}$ is \NP-hard in data complexity.


\subsection{Non-Recursive Queries}
%

We now focus on non-recursive Datalog queries, and show the following about the data complexity of why-provenance relative to minimal-depth proof trees:

\begin{theorem}\label{the:non-recursive-complexity-md}
	$\mathsf{Why\text {-}Provenance_{MD}[\NRDAT]}$ is in $\ACZ$ in data complexity.
\end{theorem}



This is shown via FO rewritability as done for Theorem~\ref{the:non-recursive-complexity}. Let us stress, however, that the target FO query cannot be obtained by simply refining the space of proof trees underlying the definition of $\cq{Q}$, for a Datalog query $Q$, as done in the case of non-recursive proof trees (see Theorem~\ref{the:non-recursive-complexity-nr}). The key reason is that the notion of minimal-depth is not over all proof trees, but over the proof trees of a certain fact. This dependency on the
fact (and indirectly, on the database) does not allow us to simply consider a refined family of proof trees as we did
for non-recursive proof-trees, and a slightly more involved construction is needed. Actually, we are going to adapt the FO query underlying Theorem~\ref{the:non-recursive-complexity}.

\medskip

\noindent \textbf{First-Order Rewriting.} Consider a non-recursive Datalog query $Q = (\dep,R)$. Recall that in the proof of Theorem~\ref{the:non-recursive-complexity}, for a CQ $\varphi(\bar y) \in \cqeq{Q}$, we defined an FO query $Q_{\varphi(\bar y)} = \psi_{\varphi(\bar y)}(x_1,\ldots,x_{\arity{R}})$, where $x_1,\ldots,x_{\arity{R}}$ are distinct variables that do not occur in any of the CQs of $\cqeq{Q}$, with the following property: for every database $D$ and tuple $\bar t \in \adom{D}^{\arity{R}}$, $\bar t \in Q_{\varphi(\bar y)}(D)$ iff $\bar t$ is an answer to $\varphi(\bar y)$ over $D$, and, in addition, {\em all} the atoms of $D$ are used in order to entail the sentence $\varphi[\bar y/\bar t]$, i.e., there are no other facts in $D$ besides the ones that have been used as witnesses for the atoms occurring in $\varphi[\bar y/\bar t]$.
%
We are going to extend $Q_{\varphi(\bar y)}$ into $Q^+_{\varphi(\bar y)} = \psi^+_{\varphi(\bar y)}(x_1,\ldots,x_{\arity{R}})$ that, in addition, performs the minimal depth check.
%
Recall that, with $\varphi$ being of the form $\exists \bar z \, (R_1(\bar w_1) \wedge \cdots \wedge R_n(\bar w_n))$, the formula $\psi_{\varphi(\bar y)}$, with free variables $\bar x = (x_1,\ldots,x_{\arity{R}})$, is of the form
\[
\exists \bar y \exists \bar z \left(\varphi_1\ \wedge\ \varphi_2\ \wedge\ \varphi_3\right),
\]
where $\varphi_1$ is defined as
\[
\bigwedge\limits_{i \in [n]}\, R_i(\bar w_i)\ \wedge\ (\bar x = \bar y)\ \wedge\ \bigwedge\limits_{\substack{u,v \in \var{\varphi}, \\ u \neq v}} \neg (u = v)
\]
$\varphi_2$ is defined as
\[
\bigwedge\limits_{P \in \{R_1,\ldots,R_n\}} \neg \left(\exists \bar u_{P} \left(P(\bar u_P)\ \wedge\ \bigwedge\limits_{\substack{i \in [n], \\ R_i = P}}\, \neg(\bar w_i = \bar u_P)\right)\right)
\]
and $\varphi_3$ is defined as
\[
\bigwedge\limits_{P \in \esch{\dep} \setminus \{R_1,\ldots,R_n\}} \neg \left(\exists \bar u_P \, P(\bar u_P)\right).
\]
Now, the formula $\psi^+_{\varphi(\bar y)}$ is
\[
\exists \bar y \exists \bar z \left(\varphi_1\ \wedge\ \varphi_2\ \wedge\ \varphi_3\ \wedge\ \varphi_4\right),
\]
where the additional conjunct $\varphi_4$ is defined as follows. For a CQ $\chi(\bar s) \in \cqeq{Q}$, we write $\depth{\chi(\bar s),Q}$ for the integer
\[
\min \{\depth{T} \mid T \text{ is a } Q\text{-tree with } \chi(\bar s) \eqtree \cq{T}\}
\]
that is, the smallest depth among all $Q$-trees whose induced CQ is isomorphic to $\chi(\bar s)$. Now, the formula $\varphi_4$ is
\begin{multline*}
	\bigwedge\limits_{\substack{\xi(\bar s) \in \cqeq{Q} \\ \text{with } \xi = \exists \bar u (P_1(\bar v_1),\ldots,P_m(\bar v_m)), \\ \depth{\xi(\bar s),Q} < \depth{\varphi(\bar y),Q}}} \neg \exists \bar s \exists \bar u \bigg(
	\bigwedge\limits_{i \in [m]}\, P_i(\bar v_i)\ \wedge\\
	(\bar x = \bar s)\ \wedge\ \bigwedge\limits_{\substack{u,v \in \var{\varphi}, \\ u \neq v}} \neg (u = v)\bigg)
\end{multline*}
which states that there is no other CQ $\xi(\bar s) \in \cqeq{Q}$ whose depth $d$ is smaller than the one of $\varphi(\bar y)$, and it witnesses the existence of a proof tree of depth $d$ of a fact $R(\bar t)$ w.r.t.~$D$ and $\dep$, where $\bar t$ is the tuple witnessed by $(x_1,\ldots,x_{\arity{R}})$.

\begin{comment}
\begin{multline*}
\exists \bar y  \exists \bar z\bigg(\bigwedge\limits_{i \in [n]}\, R_i(\bar w_i)\ \wedge\ (\bar x = \bar y)\ \wedge\ \bigwedge\limits_{\substack{u,v \in \var{\varphi}, \\ u \neq v}} \neg (u = v)\ \wedge\\
%
\bigwedge\limits_{P \in \{R_1,\ldots,R_n\}} \neg \left(\exists \bar u_{P} \bigwedge\limits_{\substack{i \in [n], \\ R_i = P}}\, \left(\neg(\bar w_i = \bar u_P)\ \wedge\ P(\bar u_P)\right)\right)\ \wedge \\
\bigwedge\limits_{P \in \esch{\dep} \setminus \{R_1,\ldots,R_n\}} \neg \left(\exists \bar u_P \, P(\bar u_P)\right)\bigg),
\end{multline*}
where, for two tuples of variables $\bar u = (u_1,\ldots,u_k)$ and $\bar v = (v_1,\ldots,v_k)$, $(\bar u = \bar v)$ is $\bigwedge_{i = 1}^{k} (u_i = v_i)$.
\end{comment}


With the FO query $Q^+_{\varphi(\bar y)}$ for each CQ $\varphi(\bar y) \in \cqeq{Q}$ in place, it should be clear that the desired FO query $Q^+_{\mi{FO}}$ is defined as $\Phi^+(x_1\ldots,x_{\arity{R}})$, where
\[
\Phi^+\ =\ \bigvee_{\varphi(\bar y) \in \cqeq{Q}} \psi^+_{\varphi(\bar y)}.
\]
We proceed to show the correctness of the construction.



\begin{lemma}\label{lem:fo-tree-equiv-md}
	Given a non-recursive Datalog query $Q=(\dep,R)$, a database $D$ over $\esch{\dep}$, $\bar t \in \adom{D}^{\arity{R}}$, and $D' \subseteq D$, $D' \in \mdwhy{\bar t}{D}{Q}$ iff $\bar t \in Q^+_{\mi{FO}}(D')$.
\end{lemma}

\begin{proof}
	We start with the $(\Rightarrow)$ direction. By hypothesis, there is a minimal-depth proof tree $T$ of $R(\bar t)$ w.r.t.~$D$ and $\dep$ such that $\support{T} = D'$.
	%
	By Lemma~\ref{lem:fo-tree-equiv}, we get that the CQ $\varphi(\bar y) \in \cqeq{Q}$ induced by $T$ is such that $\bar t \in Q_{\varphi(\bar y)}(D')$. Thus, to prove that $\bar t \in Q^+_{\varphi(\bar y)}(D')$, it suffices to show that $\bar t \in Q'(D')$, where $Q' = \varphi_4(x_1,\ldots,x_{\arity{R}})$ with $\varphi_4$ being
	\begin{multline*}
	\bigwedge\limits_{\substack{\xi(\bar s) \in \cqeq{Q} \\ \text{with } \xi = \exists \bar u (P_1(\bar v_1),\ldots,P_m(\bar v_m)), \\ \depth{\xi(\bar s),Q} < \depth{\varphi(\bar y),Q}}} \neg \exists \bar s \exists \bar u \bigg(
	\bigwedge\limits_{i \in [m]}\, P_i(\bar v_i)\ \wedge\\
	(\bar x = \bar s)\ \wedge\ \bigwedge\limits_{\substack{u,v \in \var{\varphi}, \\ u \neq v}} \neg (u = v)\bigg).
	\end{multline*}
	Towards a contradiction, assume that $\bar t \not\in Q'(D')$. This in turn implies that there exists a CQ $\xi(\bar s) \in \cqeq{Q}$ of the form $\exists \bar u (P_1(\bar v_1),\ldots,P_m(\bar v_m))$ with $\depth{\xi(\bar s),Q} < \depth{\varphi(\bar y),Q}$ such that the sentence
	\[
	\exists \bar s \exists \bar u \bigg(
	\bigwedge\limits_{i \in [m]}\, P_i(\bar v_i)\ \wedge\\
	(\bar t = \bar s)\ \wedge\ \bigwedge\limits_{\substack{u,v \in \var{\varphi}, \\ u \neq v}} \neg (u = v)\bigg)
	\]
	is satisfied by $D'$. This implies that there is an assignment $h$ to the variables in $\xi$ with $h(\bar s) = \bar t$, $h(u) \neq h(v)$, for each $u,v \in \var{\xi}$ with $u \neq v$, and, for each $i \in [m]$, $P_i(h(\bar v_i)) \in D'$.
	% 
	Since $\xi(\bar s)$ is induced by a $Q$-tree $T'$ with depth $d=\depth{\xi(\bar s),Q}$, $T'$ is a proof tree of $R(\bar t)$ w.r.t.~$D$ and $\dep$ of depth $d$ such that 
	\[
	\support{T'} = \{P_1(h(\bar v_1)),\ldots,P_m(h(\bar v_m))\}\ \subseteq\ D'.
	\]
	However, since
	\[
	\depth{T'}\ =\ \depth{\xi(\bar s),Q}\ <\ \depth{\varphi(\bar y),Q}
	\]
	and
	\[
	\depth{\varphi(\bar y),Q}\ \leq\ \depth{T}, 
	\]
	we conclude that $\depth{T'} < \depth{T}$, which contradicts the fact that $T$ is a minimal-depth proof tree.
	
	We now proceed with direction $(\Leftarrow)$. By hypothesis, $\bar t \in Q^+_{\mi{FO}}(D')$. Therefore, there exists a CQ $\varphi(\bar y) \in \cqeq{Q}$ such that $\bar t \in Q^+_{\varphi(\bar y)}(D')$. It is clear that $\bar t \in Q_{\mi{FO}}(D')$, and form the proof of Lemma~\ref{lem:fo-tree-equiv} we get that $\varphi(\bar y)$ is induced by a $Q$-tree $T$ that is also a proof tree of $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\support{T} = D'$. We assume w.l.o.g. that $\depth{T} = \depth{\varphi(\bar y),Q}$, i.e., $T$ is the proof tree of the smallest depth among those that induce $\varphi(\bar y)$. It remains to show that $T$ is a minimal-depth proof tree. Towards a contradiction, assume that $T$ is not a minimal-depth proof tree. Thus, there exists another proof tree $T'$ for $R(\bar t)$ w.r.t.~$D$ and $\dep$ with $\depth{T'} < \depth{T}$. Let $\xi(\bar s) \in \cqeq{Q}$ be the CQ induced by $T'$. It is clear that
	\[
	\depth{\xi(\bar s),Q}\ \leq\ \depth{T'}\ <\ \depth{\varphi(\bar y),Q}.
	\]
	This allows us to conclude that $\bar t \not\in Q^+_{\varphi(\bar y)}(D')$, which is a contradiction. Consequently, $T$ is a minimal-depth proof tree of $R(\bar t)$ w.r.t.~$D$ and $\dep$. Since $\support{T} = D'$, we get that $D' \in \mdwhy{R(\bar t)}{D}{Q}$, as needed.
\end{proof}