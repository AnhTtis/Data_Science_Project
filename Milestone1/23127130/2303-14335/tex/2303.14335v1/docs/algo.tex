\section{Algorithm}
\label{sec:algo}
The detailed formulation of the MPLD problem is introduced in \Cref{subsec:mpld_prob}.
Our algorithm is built on top of an open-sourced layout decomposer OpenMPL~\cite{openmpl},
which implements various CPU-based MPLD methods. The decomposition flow is introduced in \Cref{subsec:mpld_flow}.
As proposed in \Cref{subsec:gpu_mpld} We replace the decomposition solver with our GPU-accelerated matrix cover algorithm.

\subsection{Problem formulation}
\label{subsec:mpld_prob}

As depicted in \Cref{fig:stitch}, given an input layout specified by features in polygonal shapes, the layout can be translated into
an undirected layout graph $G=\{V,E\}$, where every node $v_i \in V$ corresponds to one feature in layout and each edge $e_{ij} \in E$ is used to characterize the relationships between features. 
Considering conflict and stitch relationships, $E$ is composed of these two kinds of edges, denoted by
$E=\{CE \cup SE\}$, where $SE$ is the set of stitch edges and $CE$ is the set of conflict edges.
The MPLD problem can be formulated as below:
\begin{subequations}  \label{formula:mpl}
    \begin{align}
        \underset{\vec{x}}{\min} \ \ & \sum   c_{ij} + \alpha\sum s_{ij},   \\
        \textrm{s.t.} \ \
        & c_{ij} = (x_i==x_j),          && \forall e_{ij} \in CE, \\
        & s_{ij} = (x_i \neq x_j),      && \forall e_{ij} \in SE, \\
        & x_i \in \{0, 1, \ldots ,k\},  && \forall x_i \in \vec{x},
    \end{align}
\end{subequations}
where $x_{i}$ is a variable for the $k$ available colors of the pattern $v_{i}$, $c_{ij}$ is a binary variable representing conflict edge $e_{ij}\in CE$,
$s_{ij}$ stands for stitch edge $e_{ij}\in SE$,
$\alpha$ is a user-defined parameter and is set as 0.1 by default in our framework to assign relative importance between the conflict cost and the stitch cost.
If two nodes, $x_{i}$ and $x_{j}$, within the minimal coloring distance are assigned the same color (i.e.~$x_i==x_j$), then $c_{ij}=1$.
On the contrary, $s_{ij}=1$ when two nodes connected by stitch edge are assigned a different color (i.e.~$x_i \neq x_j$).
The objective function is to minimize the weighted summation of the conflict number and the stitch number.

\subsection{The MPLD flow}
\label{subsec:mpld_flow}
As illustrated in \Cref{fig:flow}, we utilize a part of OpenMPL flow.
The chip layout will be first transformed into a layout graph (LG) by a vector of rectangle pointers.
The second step is to simplify the layout graph with stitch insertion, after which the layout graph will be decomposed into decomposed graph (DG) with stitches.
Then we can call the graph coloring solver to solve the MPLD problems.
As illustrated in \Cref{fig:flow}, in this step, we replace the EC-based solver with our GPU-accelerated matrix cover solver.
Finally, the framework will recover the nodes removed in simplification step and assigns the coloring results from the coloring solver.

\begin{figure}[tb!]
  \centering
  \includegraphics[width=.8\linewidth]{flow}
  \caption{The overall flow for our framework, the coloring solver is replaced with our GPU-accelerated matrix cover solver.}
  \label{fig:flow}
\end{figure}


\subsection{GPU-accelerated matrix cover for MPLD}
\label{subsec:gpu_mpld}
The original EC-based algorithm~\cite{TPL-TCAD2017-Jiang} models the MPLD as a matrix cover problem, as depicted in \Cref{fig:dancing_links}.
The input of the algorithm is a no-stitch graph $G_p = \{V_p, E_p\}$.
Since $G_p$ tends to be spare, Knuth~\cite{knuth2000dancing} suggested using DLX to solve it efficiently.
The original layout will be transformed into a homogeneous graph and further translated into a binary matrix of ``0''s and ``1''s.
Then the solution for the MPLD problem is transformed into solving the EC problem,
which means finding a set of rows containing exactly one ``1'' in each column (\Cref{fig:dancing_links}).
The cover and uncover operations can be transformed into the removal and recovery of a doubly linked list,
\begin{equation}
  \text{Cover}: L[R[x]] \rightarrow L[x], R[L[x]] \rightarrow R[x],\ \  \text{Uncover}: L[R[x]] \rightarrow x, R[L[x]] \rightarrow x
\end{equation}
where $L[x]$ and $R[x]$ point to the left and the right node of the linked list.

\begin{figure}[tb!]
  \centering
  \includegraphics[width=.55\linewidth]{dl1dl.pdf}
  \caption{
    Exact cover matrix for double patterning layout decomposition with basic coloring rule.
  }
  \label{fig:dancing_links}
\end{figure}

The hierarchical acceleration of GPU-based matrix cover solver is illustrated in \Cref{fig:mtxcover_gpu} and \Cref{alg:gpu-mpld}.
The three-dimensional indexing of CUDA programming model provides a natural way to index the matrix elements thus the DLX algorithm can be accelerated by GPU with the index $x$ set as:
\begin{equation}
  x = blockIdx.x \times blockNum + threadIdx.y
\end{equation}
where the $blockIdx$ and the $threadIdx$ are the indexer of CUDA programming model, the $blockNum$ is a pre-defined hyperparameter indicating the degree of parallelism.
As shown in \Cref{alg:gpu-mpld}, the original DG will be decomposed into sub-graphs for acceleration (line 1 - line 3).
Then the sub-graphs will be parallelly executed on different blocks (line 4) of a GPU to accelerate the DLX algorithm (line 4 - line 18).
The \textit{cover} and \textit{uncover} operations in line 8 and line 16 are implemented as CUDA kernel functions \eg, \texttt{delete\_rows\_and\_columns}, \texttt{recover\_results} and so on.
As depicted in \Cref{fig:mtxcover_gpu},
the kernel functions will be organized under the indexing and perform DLX in parallelization.
Moreover, the shared memory of GPU is also used for global communication of different threads for further acceleration.


\begin{algorithm}[h]
  \caption{GPU-accelerated matrix cover algorithm}
    \begin{algorithmic}[1]
        \Require Layout graph $G$ and converted exact cover matrix $M$
        \Ensure Colored graph and conflict features
        \State $graphID = blockIdx.x$
        \State $subgraphID = threadIdx.y$
        \State $idx = blockIdx.x * graph\_per\_block + subgraphID$
        \For{each subgraph}
          \If{ no column of $idx$ remains or all columns of $M$ are covered}
              \State Return \Comment{The solution has been found.}
          \EndIf
          \State Select an uncovered column $cl$ with only one related row or in BFS order of $G$
          \State Cover $cl(idx)$
          \If{no $cl$'s related rows remain}
              \State Mark $(cl, cl')$ as one conflict candidate
              \State where $cl$'s is the column that has covered final related row of $cl$
          \EndIf
          \For{each row $rw$ related to $cl$}
              \State Include $rw$ into the current solution
              \State Cover $rw$ and its affected rows
              \State Call GPU-accelerated matrix cover with $G$ and $M$
              \State Uncover $rw$ and its affected rows
              \State Exclude $rw$ from the current solution
          \EndFor
          \State Uncover $cl$
        \EndFor
        \State Return
    \end{algorithmic}
  \label{alg:gpu-mpld}
\end{algorithm}






