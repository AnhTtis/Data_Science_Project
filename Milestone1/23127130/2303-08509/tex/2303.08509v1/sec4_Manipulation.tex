
\section{ Malware manipulation} \label{sec:Adversarial manipulation design}
{
In this section, we first introduce the common requirements and the existing techniques \cite{DBLP:conf/sp/PierazziPCC20,DBLP:journals/corr/abs-2009-05602,chen2020android} of malware manipulation, and then propose a new malware manipulation technique.}

\subsection{Background of malware manipulation} \label{subsec: four R}
{Although the manipulation on malware is intuitively simple, the challenges come from the following requirements.} \\
\textbf{R1: Functional Consistency.} The malware functionality should keep consistently before and after manipulation.\\
% Therefore, malware manipulation should conform to smali syntax rules, and cannot change the functionality of malware. 
\textbf{R2: All-granularities influence.} Since the feature granularity (e.g., family level and package level) of malware detection is unknown, malware manipulation should be able to affect the features of all granularities \cite{DBLP:conf/ndss/MaricontiOACRS17}. \\
\textbf{R3: Resilience to static analysis.}  Malware manipulation 
% should be able to resist static analysis 
 {should not be hindered by static analysis inspection}
\footnote{{ In this work, the static analysis mainly refers to the program analysis techniques that only examine the source code but do not execute the program.}} \cite{DBLP:journals/tdsc/DemontisMBMARCG19,DBLP:conf/acsac/MoserKK07}, and cannot completely rely on dead codes  {(i.e., unreachable instruction blocks)}.\\
\textbf{R4: Non-stationary perturbation.} Manipulation  should be non-stationary and cannot be restricted to a fixed set of operations (e.g., a pre-determined white list  \cite{DBLP:journals/corr/abs-2009-05602}), {to reduce the risk of being identified. } \\
%  {\st{\textbf{R5: No-additional functions introduced.} When we add a certain API into the smali fils, there are no expected that other functions are inserted concomitantly. Because concomitantly functions may cause decrease of the attack success rate.}}

{Existing manipulation methods are summarized below.}\\
\textbf{Inserting dead codes}: To maintain functional consistency, \cite{chen2020android} chooses to insert dead codes (e.g., no-op calls) into smali files. {Unfortunately, these codes can be easily detected and filtered, violating the requirement \textbf{R3}. For example, \cite{DBLP:journals/tifs/Fan0LCTZL18} proposes a weighted sensitive-API-call-based Android malware family classification method, which can resist the impact of no-op calls. } \\
\textbf{Adding valueless calls}: \cite{chen2020android} creates user-defined classes and adds valueless calls (i.e., invoking empty functions) into them. {However, these calls may be susceptible to static analysis and cannot attack the class-granularity FCGs, violating the requirements \textbf{R2} and \textbf{R3}.  For example, the Android malware detection method proposed in \cite{DBLP:journals/tsmc/YuanJLC21} does not use self-defined functions as feature. Hence, this method is not influenced by the valueless calls inserted by adversaries. }\\
\textbf{Adding functions from a white list}: To change FCGs, the authors of \cite{DBLP:journals/corr/abs-2009-05602} add a function coming from a predetermined white list. However, once adversarial examples are captured, the white list will be revealed and adversarial attacks may fail. Please refer to  requirement \textbf{R4}.\\
{\textbf{Opaque predicates}: \cite{DBLP:conf/sp/PierazziPCC20} leverages opaque predicates to insert new APIs for malware detection evasion. Specifically, this method constructs obfuscated conditions where the outcome is always known in design phase but the truth value is difficult or impossible to determine by static analysis. Hence this method can effectively resist static analysis. However, it may introduce some undesired functions (e.g., the \textit{random} function), which impose unexpected impacts on FCGs. }

% For example, it may use the \textit{random} function to construct a 'if' conditions  that are almost impossible to meet. However, although the inserted functions in 'if' block evade the static analysis, it introduce unexpected function 'random' too, which may affect the attack performance. Please refer to the requirement \textbf{R5}  }

\subsection{The proposed manipulation method} \label{sec:adversarial manipulation method}
Here we design a new malware manipulation method to modify smali code. Clearly, we cannot remove nodes or edges from FCGs, according to the requirement \textbf{R1}. Hence, we only consider adding (or inserting) nodes or edges. However, adding isolated nodes (i.e., the functions that are not invoked or do not invoke others) is not recommended for two reasons. First, the isolated nodes are easily detected by static analysis {(e.g., some program analysis techniques that perform redundant code elimination would remove unreachable code \cite{guardsquare})}. Second, adding nodes usually cannot impact feature space, since lots of malware detectors utilize edges (instead of nodes) for classification. As a result, we select adding edges (i.e., calls) in our manipulation method. Then the rest of the problem includes:  how to create \textit{candidate} edges,  how to select desirable edges from the candidate edges, and  how to insert the selected edges.  {
In this section, we only consider the first and the third problems. The second problem will be solved in Section \ref{sec:method}.}

\textbf{(1) How to create candidate edges?}
\begin{figure}
	\centering
	\includegraphics[scale=0.85]{example.pdf}
	\caption{Selecting callers and callees from an FCG.}
	\label{fig:example}
\end{figure}


\begin{figure}
	\centering
	\includegraphics[scale=0.55]{Pseudo.pdf}
	\caption{An example of try-catch trap.}
	\label{fig:manipulation}
\end{figure}

 {Up to now, how to impose all-granularities influence (required by \textbf{R2}) on FCG with incomplete feature information (i.e., the feature granularity is unknown) has not been thoroughly studied. To tackle this problem, we propose to create an edge between two nodes of any type by adding a function call between a caller and a callee. This method changes the FCG no matter what kind of feature granularity is used. } Then the problem becomes how to determine the caller and the callee for every candidate edge. Due to the requirement \textbf{R4}, we cannot utilize a white list to generate callers and callees. Instead, we propose to generate them from the functions used by malware itself. In this way, we can ensure that the candidate edges created for different malware are diverse, hence satisfying the requirement \textbf{R4}.  

{Now we study where to place the added edges.} An FCG consists of \textit{non-leaf} nodes and \textit{leaf} nodes, as depicted in Fig. \ref{fig:example}. The non-leaf nodes are user-defined functions, and the leaf nodes correspond to Android standard functions (e.g., $java/io/File;-\textgreater exists()$) or the user-defined functions that do not invoke others. In our method, non-leaf nodes (i.e., user-defined functions) are selected as callers, since they are easily inserted with new function calls. Leaf nodes are chosen as callees,   since invoking a function that does not invoke others will not trigger unintended calls. Here we avoid generating unintended calls because they may further impose perturbations on the FCG, which is beyond our expectation. Furthermore, we supply more discussion on callee selection in Appendix \ref{sec:callees' limitation}. Now we can use the above method to create candidate edges. In Section \ref{sec:method}, we will propose an algorithm to select the most desirable edges for manipulation.

\textbf{(2) How to insert selected edges?}

 We assume that the desirable edges have been selected, and study how to insert the corresponding function calls into smali files under the requirements of \textbf{R1} and \textbf{R3}. Our proposed method is called \textbf{try-catch trap}. It first inserts a try-catch block into the caller, and places the statement of invoking callee in its try block. It then adds several statements in front of this function call statement. These statements are used to trigger a pre-selected exception (e.g., an arithmetic exception). Now we analyze why this method works. First, it inserts a function call statement in smali files, hence changing the FCG by adding a new edge. Second, the function call statement is never executed,  {hence preserving malware functionality}. For illustration, Fig. \ref{fig:manipulation} gives an example of try-catch trap. Suppose the codes in the left box come from a malware sample. The function \textit{callerEX()} is selected as our caller. We place a try-catch block in this function, and invoke the function callee() after the blue statement is executed. In this way, we can add a new edge into the FCG, as shown in Fig. \ref{fig:manipulation}. When the try-catch block is executed, an exception of \textit{IndexOutOfBoundsException} will be thrown, and the statement of function call will be skipped over. 
{In summary, our method can be considered as a variant of opaque predicates. It carefully constructs obfuscated conditions that are difficult to determine during static analysis, hence possessing the ability to resist static analysis.}

 {The main steps of inserting function calls are briefly described in Appendix \ref{appendix:smali}.}

 % The main steps of inserting function calls are briefly described below. First, we find the smali file related to the selected caller, according to the latter's full name. Second, we insert statements into the smali file to implement a try-catch trap. We can use five invocation types, including invoke-direct, invoke-virtual, invoke-static, invoke-super and invoke-interface. These invocation types result in different smali manipulations, due to their various requirements for register usage. To facilitate understanding, we provide several examples of invocation types in Fig. \ref{fig:direct} of Appendix \ref{appendix: smali example}. We also show how to modify the smali codes in Appendix \ref{appendix:smali}. Third, we use \textit{Apktool} to rebuild the modified smali files to APK file. In our work, the above operations are automatically conducted by a Python script. 

 
% \textcolor{green}{In summary, The key idea of our method and opaque predicates is similar, both we want to carefully constructed obfuscated conditions which are difficult to determine during a static analysis, hence {\ourtool}  has the ability to resist static analysis.}
	
% 	First of all, for API call graph, we can only add nodes or edges, but can not delete the original existing graph, because any deletion may affect the original APK function (\textbf{subject to C1}).
% 	Secondly, in order to ensure the diversity of perturbation, we do not set a fixed whitelist, but construct a perturbation candidate set according to the function used by each APK. So that the candidate perturbation of each different Android software are different and the attacker will not take a risk of whitelist leaking (\textbf{subject to C4}). What's more, because we immediately add a method to the api
%      call graph, it can  affect different granularity feature (\textbf{subject to C3}).
% 	Third, in order to ensure the automation and simplicity of the modification process,  we will record the statement method of each function (function-call notation, whether to use registers, etc.) during feature extraction of an Android APK. So there is no need to introduce human experience to achieve automatic perturbation. (\textbf{subject to C5}). 
% 	Finally, we supply a  new method to add these functions in smali code which can  evade being deleted by static analysis (\textbf{subject to C2}). This method will be discussed in next subsection.
	

% 	Based on the above considerations, our perturbation strategy is  adding edges to the existing API call graph. Specifically, when extracting the function call graph of a malware, the algorithm will construct the candidate perturbation pool that can be applied according to the existing functions in the graph. These candidate edges to be added involve the calling function and the called function:
	
% 	\begin{itemize}
% 		\item \textbf{Caller:} In order to facilitate subsequent modifications, we choose non-leaf nodes in the API call diagram as the keynote nodes. These non-leaf nodes are self-defined functions and can be  easily modified and injected new functions.
		
% 		\item \textbf{Callee:} The callee functions are selected from the existing leaf nodes in the API call graph. These callee functions have been used in the original apk, so it is easy to statement the function by following the original smali code. However, the selection of leaf nodes also should follow the android programming rules. 1) Access modifiers   restriction: For leaf nodes' access modifiers, we  only  remain those functions whose access modifier is 'public', so that the leaf nodes can be called in all other classes. 2) Parameter limitation:  When selecting leaf nodes, we also need to filter function according to the  input parameters. We will leave those whose input parameters are empty or  basic types(e.g., 'int','double', etc.)\footnote{This limitation is to ensure the ease of manipulation, }.
		
	
% 	\end{itemize}



	
	
	

	
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  


% \begin{table}[H]
%     \renewcommand\arraystretch{1.3}
% 	\caption{Common declaration examples.}
% 	\centering
% 	\scalebox{0.8}{
% 		\begin{tabular}{cc|cc}
% 			\hline
% 			Type   & Smali definition  & Type   & Smali definition            \\ \hline
% 			\cellcolor{cyan!60!gray!10}byte   &\cellcolor{cyan!60!gray!10} const/4 v1, 0x0    & \cellcolor{cyan!60!gray!10}long                & \cellcolor{cyan!60!gray!10}const-wide/1   v8, 0x1            \\ 
% 			char   & const/16 v1, 0x61  & float               & const v1, 0x3f8ccccd              \\ 
% 			\cellcolor{cyan!60!gray!10}short  & \cellcolor{cyan!60!gray!10}const/4 v1, 0x1    & \cellcolor{cyan!60!gray!10}  boolean            & \cellcolor{cyan!60!gray!10}   const/4 v1, 0x0         \\ 
% 			int    & const/4 v1, 0x1    &   double       &        \tabincell{c}{ const-wide v1,  \\ 0x4000000000000000L}           \\ 
% 			\cellcolor{cyan!60!gray!10} String   & \cellcolor{cyan!60!gray!10} const-string v1, "123"    & \cellcolor{cyan!60!gray!10}-             & \cellcolor{cyan!60!gray!10}-                   \\ \hline
% % 			\multicolumn{2}{c|}{double} & \multicolumn{2}{c}{const-wide v1,  0x4000000000000000L} \\ \hline
% 		\end{tabular}%
% 	}
% 	\label{tab:statement}
% \end{table}		
