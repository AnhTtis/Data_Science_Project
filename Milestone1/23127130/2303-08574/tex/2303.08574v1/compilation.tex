The DSL is specified as a list of primitives together with their types and semantics.
The compilation phase consists in obtaining an efficient representation of the set of programs in the form of a context-free grammar.
The right way to look at the grammar is as a generating model: it generates code. 
Thanks to the expressivity of context-free grammars, many syntactic properties can be ensured: primarily and most importantly, all generated programs are correctly typed.

The DSL we use in our experiments is tailored for string manipulation tasks Ã  la Flashfill. 
For the sake of presentation we slightly simplify it. 
We use two primitive types: \verb+STRING+ and \verb+REGEXP+, and one type constructor \verb+Arrow+.
We list the primitives below, they have the expected semantics.

\begin{minted}{python}
    $       : REGEXP                  # end of string
    .       : REGEXP                  # all
    [^_]+   : Arrow(STRING, REGEXP)   # all except X
    [^_]+$  : Arrow(STRING, REGEXP)   # all except X at the end
    compose : Arrow(REGEXP, Arrow(REGEXP, REGEXP))

    concat  : Arrow(STRING, Arrow(STRING, STRING))
    match   : Arrow(STRING, Arrow(REGEXP, STRING))

    # concat_if: concat if the second argument (constant) 
    #            is not present in the first argument
    concat_if    : Arrow(STRING, Arrow(STRING, STRING))  
    # split_fst: split using regexp, returns first result
    split_fst  : Arrow(STRING, Arrow(REGEXP, STRING))
    # split_snd: split using regexp, returns second result
    split_snd : Arrow(STRING, Arrow(REGEXP, STRING))
\end{minted} 

In the implementation we use two more primitive types: \verb+CONSANT_IN+ and \verb+CONSTANT_OUT+, which correspond to constants in the inputs and in the output. This is only for improving performances, it does not increase expressivity. Some primitives are duplicated to use the two new primitive types.
