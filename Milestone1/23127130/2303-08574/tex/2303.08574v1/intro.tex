Task automation is becoming increasingly important in the digital world we live in, yet writing software is still accessible only to a small share of the population. Program synthesis seeks to make coding more reliable and accessible by developing methods for automatically generating code~\cite{Gulwani2017}. For example, the FlashFill system~\cite{Gulwani2011} in Microsoft Excel makes coding more accessible by allowing nontechnical users to synthesize spreadsheet programs by giving input-output examples, and TF-coder~\cite{ShiBS22} assists developers with writing TensorFlow code for manipulating tensors.

Very impressive results have been achieved in the past five years employing machine learning methods to empower program synthesis.
Recent works have explored engineering neural networks for guiding program search~\cite{Balog2017,Devlin2017,Lee2018,Zhang2018,Polosukhin2018,Kalyan2018,ZoharW18,chen2018execution,EllisWNSMHCST21,Fijalkow2022ScalingNP} effectively by training the network to act as a language model over source code.
The most resounding success of this line of work is OpenAI's Codex system~\cite{abs-2107-03374} powering Github's Copilot and based on very large language models.
However, because it works at a purely syntactic level, program synthesis fails in a number of applications.

Let us consider as an example the following task:
\begin{minted}{python}
f("17", "United States") = "17 USD"
f("42", "France") = "42 EUR"
\end{minted}
The task is specified in the programming by example setting: the goal is to construct a function \texttt{f} mapping inputs to their corresponding outputs.
Solving this task requires understanding that the second inputs are countries and mapping them to their currencies.
This piece of information is not present in the examples and therefore no program synthesis tool can solve that task without relying on external information.
In other words, a solution program must be \textit{knowledge-powered}!
An example knowledge-powered program yielding a solution to the task above is given below in a Python-like syntax:
\begin{minted}{python}
def f(x,y):
    return x + " " + CurrencyOf(y)
\end{minted}
It uses a function \texttt{CurrencyOf} obtained from an external source of knowledge.

Knowledge-powered program synthesis extends classical program synthesis by targetting knowledge-powered programs.
The challenge of combining syntactical manipulations performed in program synthesis with semantical information was recently set out by~\cite{VerbruggenLG21}. They discuss a number of applications: string manipulations, code refactoring, and string profiling, and construct an algorithm based on very large language models (see related work section).

Our approach is different: the methodology we develop relies on knowledge graphs, which are very large structured databases organising knowledge using ontologies to allow for efficient and precise browsing and reasoning. There is a growing number of publicly available knowledge graphs, for instance Wikidata.org, which includes and structures Wikipedia data, and Yago~\cite{TanonWS20,HoffartSBW13}, based on Wikidata and schema.org. We refer to~\cite{2021Hogan} for a recent textbook and to~\cite{Hogan22} for an excellent survey on knowledge graphs and their applications, and to Figure~\ref{fig:knowledge_graph} for an illustration.

The recent successes of both program synthesis and knowledge graphs suggest that the time is ripe to combine them into the knowledge-powered program synthesis research objective.

\paragraph*{Our contributions:}
\begin{itemize}
	\item We introduce knowledge-powered program synthesis, which extends program synthesis by allowing programs to refer to external information collected from a knowledge graph.
	\item We identify a number of milestones for knowledge-powered program synthesis and propose a human-generated and publicly available dataset of 46 tasks to evaluate future progress on this research objective.
	\item We construct an algorithm combining state of the art machine learned program synthesizers with queries to a knowledge graph, which can be deployed on any knowledge graph.
	\item We implement a general-purpose knowledge program synthesis tool WikiCoder and evaluate it on various domains.
	WikiCoder solves tasks previously unsolvable by any program synthesis tool, while still operating at scale by integrating state of the art techniques from program synthesis.
\end{itemize}
