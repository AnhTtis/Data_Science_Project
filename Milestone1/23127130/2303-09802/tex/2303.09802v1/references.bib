@inproceedings{10.1145/1806596.1806598,
author = {Richards, Gregor and Lebresne, Sylvain and Burg, Brian and Vitek, Jan},
title = {{An Analysis of the Dynamic Behavior of JavaScript Programs}},
year = {2010},
isbn = {9781450300193},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1806596.1806598},
doi = {10.1145/1806596.1806598},
abstract = {The JavaScript programming language is widely used for web programming and, increasingly, for general purpose computing. As such, improving the correctness, security and performance of JavaScript applications has been the driving force for research in type systems, static analysis and compiler techniques for this language. Many of these techniques aim to reign in some of the most dynamic features of the language, yet little seems to be known about how programmers actually utilize the language or these features. In this paper we perform an empirical study of the dynamic behavior of a corpus of widely-used JavaScript programs, and analyze how and why the dynamic features are used. We report on the degree of dynamism that is exhibited by these JavaScript programs and compare that with assumptions commonly made in the literature and accepted industry benchmark suites.},
booktitle = {Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {1–12},
numpages = {12},
keywords = {dynamic behavior, execution tracing, dynamic metrics, program analysis, javascript},
location = {Toronto, Ontario, Canada},
series = {PLDI '10}
}

@inproceedings{10.1145/1985441.1985446,
author = {Parnin, Chris and Bird, Christian and Murphy-Hill, Emerson},
title = {{Java Generics Adoption: How New Features Are Introduced, Championed, or Ignored}},
year = {2011},
isbn = {9781450305747},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1985441.1985446},
doi = {10.1145/1985441.1985446},
abstract = {Support for generic programming was added to the Java language in 2004, representing perhaps the most significant change to one of the most widely used programming languages today. Researchers and language designers anticipated this addition would relieve many long-standing problems plaguing developers, but surprisingly, no one has yet measured whether generics actually provide such relief. In this paper, we report on the first empirical investigation into how Java generics have been integrated into open source software by automatically mining the history of 20 popular open source Java programs, traversing more than 500 million lines of code in the process. We evaluate five hypotheses, each based on assertions made by prior researchers, about how Java developers use generics. For example, our results suggest that generics do not significantly reduce the number of type casts and that generics are usually adopted by a single champion in a project, rather than all committers.},
booktitle = {Proceedings of the 8th Working Conference on Mining Software Repositories},
pages = {3–12},
numpages = {10},
keywords = {languages, generics, post-mortem analysis, java},
location = {Waikiki, Honolulu, HI, USA},
series = {MSR '11}
}

@inproceedings{10.5555/1862659.1862665,
author = {Holkner, Alex and Harland, James},
title = {{Evaluating the Dynamic Behaviour of Python Applications}},
year = {2009},
isbn = {9781920682729},
publisher = {Australian Computer Society, Inc.},
address = {AUS},
abstract = {The Python programming language is typical among dynamic languages in that programs written in it are not susceptible to static analysis. This makes efficient static program compilation difficult, as well as limiting the amount of early error detection that can be performed. Prior research in this area tends to make assumptions about the nature of programs written in Python, restricting the expressiveness of the language. One may question why programmers are drawn to these languages at all, if only to use them in a static-friendly style. In this paper we present our results after measuring the dynamic behaviour of 24 production-stage open source Python programs. The programs tested included arcade games, GUI applications and non-interactive batch programs. We found that while most dynamic activity occurs during program startup, dynamic activity after startup cannot be discounted entirely.},
booktitle = {Proceedings of the Thirty-Second Australasian Conference on Computer Science - Volume 91},
pages = {19–28},
numpages = {10},
keywords = {dynamic languages, Python and compilers},
location = {Wellington, New Zealand},
series = {ACSC '09}
}

@INPROCEEDINGS{9425916,
  author={Peng, Yun and Zhang, Yu and Hu, Mingzhe},
  booktitle={2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={{An Empirical Study for Common Language Features Used in Python Projects}}, 
  year={2021},
  volume={},
  number={},
  pages={24-35},
  doi={10.1109/SANER50967.2021.00012}}

@inproceedings{10.1145/3524842.3528467,
author = {Yang, Yi and Milanova, Ana and Hirzel, Martin},
title = {{Complex Python Features in the Wild}},
year = {2022},
isbn = {9781450393034},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3524842.3528467},
doi = {10.1145/3524842.3528467},
abstract = {While Python is increasingly popular, program analysis tooling for Python is lagging. This is due, in part, to complex features of the Python language---features with difficult to understand and model semantics. Besides the "usual suspects", reflection and dynamic execution, complex Python features include context managers, decorators, and generators, among others. This paper explores how often and in what ways developers use certain complex features. We analyze over 3 million Python files mined from GitHub to address three research questions: (i) How often do developers use certain complex Python features? (ii) In what ways do developers use these features? (iii) Does use of complex features increase or decrease over time? Our findings show that usage of dynamic features that pose a threat to static analysis is infrequent. On the other hand, usage of context managers and decorators is surprisingly widespread. Our actionable result is a list of Python features that any "minimal syntax" ought to handle in order to capture developers' use of the Python language. We hope that understanding the usage of Python features will help tool-builders improve Python tools, which can in turn lead to more correct, secure, and performant Python code.},
booktitle = {Proceedings of the 19th International Conference on Mining Software Repositories},
pages = {282–293},
numpages = {12},
keywords = {AST, Python},
location = {Pittsburgh, Pennsylvania},
series = {MSR '22}
}

@inproceedings{10.1145/2597073.2597103,
author = {\r{A}kerblom, Beatrice and Stendahl, Jonathan and Tumlin, Mattias and Wrigstad, Tobias},
title = {{Tracing Dynamic Features in Python Programs}},
year = {2014},
isbn = {9781450328630},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2597073.2597103},
doi = {10.1145/2597073.2597103},
abstract = {Recent years have seen a number of proposals for adding (retrofitting) static typing to dynamic programming languages, a natural consequence of their growing popularity for non-toy applications across a multitude of domains. These proposals often make assumptions about how programmers write code, and in many cases restrict the way the languages can be used. In the context of Python, this paper describes early results from trace-based collection of run-time data about the use of built-in language features which are inherently hard to type, such as dynamic code generation. The end goal of this work is to facilitate static validation tooling for Python, in particular retrofitting of type systems.},
booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
pages = {292–295},
numpages = {4},
keywords = {dynamic features, Python, Dynamic languages, open source},
location = {Hyderabad, India},
series = {MSR 2014}
}

@inproceedings{10.1145/2568225.2568295,
author = {Dyer, Robert and Rajan, Hridesh and Nguyen, Hoan Anh and Nguyen, Tien N.},
title = {{Mining Billions of AST Nodes to Study Actual and Potential Usage of Java Language Features}},
year = {2014},
isbn = {9781450327565},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2568225.2568295},
doi = {10.1145/2568225.2568295},
abstract = {Programming languages evolve over time, adding additional language features to simplify common tasks and make the language easier to use. For example, the Java Language Specification has four editions and is currently drafting a fifth. While the addition of language features is driven by an assumed need by the community (often with direct requests for such features), there is little empirical evidence demonstrating how these new features are adopted by developers once released. In this paper, we analyze over 31k open-source Java projects representing over 9 million Java files, which when parsed contain over 18 billion AST nodes. We analyze this corpus to find uses of new Java language features over time. Our study gives interesting insights, such as: there are millions of places features could potentially be used but weren't; developers convert existing code to use new features; and we found thousands of instances of potential resource handling bugs.},
booktitle = {Proceedings of the 36th International Conference on Software Engineering},
pages = {779–790},
numpages = {12},
keywords = {software mining, empirical study, Java, language feature use},
location = {Hyderabad, India},
series = {ICSE 2014}
}



@InProceedings{10.1007/978-3-540-70592-5_28,
author="Tempero, Ewan
and Noble, James
and Melton, Hayden",
editor="Vitek, Jan",
title={{How Do Java Programs Use Inheritance? An Empirical Study of Inheritance in Java Software}},
booktitle="ECOOP 2008 -- Object-Oriented Programming",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="667--691",
abstract="Inheritance is a crucial part of object-oriented programming, but its use in practice, and the resulting large-scale inheritance structures in programs, remain poorly understood. Previous studies of inheritance have been relatively small and have generally not considered issues such as Java's distinction between classes and interfaces, nor have they considered the use of external libraries.",
isbn="978-3-540-70592-5"
}

@article{10.1002/spe.2334,
author = {Wei, Shiyi and Xhakaj, Franceska and Ryder, Barbara G.},
title = {{Empirical study of the dynamic behavior of JavaScript objects}},
journal = {Software: Practice and Experience},
volume = {46},
number = {7},
pages = {867-889},
keywords = {JavaScript, study of websites, object behavioral metrics and patterns},
doi = {https://doi.org/10.1002/spe.2334},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.2334},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.2334},
abstract = {Summary Despite the popularity of JavaScript for client-side web applications, there is a lack of effective software tools supporting JavaScript development and testing. The dynamic characteristics of JavaScript pose software engineering challenges such as program understanding and security. One important feature of JavaScript is that its objects support flexible mechanisms such as property changes at runtime and prototype-based inheritance, making it difficult to reason about object behavior. We have performed an empirical study on real JavaScript applications to understand the dynamic behavior of JavaScript objects. We present metrics to measure behavior of JavaScript objects during execution (e.g., operations associated with an object, object size, and property type changes). We also investigated the behavioral patterns of observed objects to understand the coding or user interaction practices in JavaScript software. Copyright © 2015 John Wiley \& Sons, Ltd.},
year = {2016}
}

@InProceedings{10.1007/978-3-642-22655-7_4,
author="Richards, Gregor
and Hammer, Christian
and Burg, Brian
and Vitek, Jan",
editor="Mezini, Mira",
title={{The Eval That Men Do}},
booktitle="ECOOP 2011 -- Object-Oriented Programming",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="52--78",
abstract="Transforming text into executable code with a function such as JavaScript's eval endows programmers with the ability to extend applications, at any time, and in almost any way they choose. But, this expressive power comes at a price: reasoning about the dynamic behavior of programs that use this feature becomes challenging. Any ahead-of-time analysis, to remain sound, is forced to make pessimistic assumptions about the impact of dynamically created code. This pessimism affects the optimizations that can be applied to programs and significantly limits the kinds of errors that can be caught statically and the security guarantees that can be enforced. A better understanding of how eval is used could lead to increased performance and security. This paper presents a large-scale study of the use of eval in JavaScript-based web applications. We have recorded the behavior of 337 MB of strings given as arguments to 550,358 calls to the eval function exercised in over 10,000 web sites. We provide statistics on the nature and content of strings used in eval expressions, as well as their provenance and data obtained by observing their dynamic behavior.",
isbn="978-3-642-22655-7"
}

@misc{GitHub,
title={Github},
url={https://github.com/}
}

@misc{ECMAScript,
author={{ECMA TC39}},
title={ECMAScript},
url={https://www.ecma-international.org/publications-and-standards/standards/ecma-262/}
}

@misc{TypeScript,
title={TypeScript},
url={https://www.typescriptlang.org/}
}

@misc{Go,
title={Golang},
url={https://go.dev/}
}

@misc{Babel,
title={Babel},
url={https://babeljs.io/}
}

@misc{SourceForge,
title={SourceForge},
url={https://sourceforge.net/}
}

@misc{DefinitelyTyped,
title={DefinitelyTyped},
url={http://definitelytyped.org/}
}

@inproceedings{10.1145/3475738.3480941,
author = {Cristiani, Fernando and Thiemann, Peter},
title = {Generation of TypeScript Declaration Files from JavaScript Code},
year = {2021},
isbn = {9781450386753},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3475738.3480941},
doi = {10.1145/3475738.3480941},
abstract = {Developers are starting to write large and complex applications in TypeScript, a typed dialect of JavaScript. TypeScript applications integrate JavaScript libraries via typed descriptions of their APIs called declaration files. DefinitelyTyped is the standard public repository for these files. The repository is populated and maintained manually by volunteers, which is error-prone and time consuming. Discrepancies between a declaration file and the JavaScript implementation lead to incorrect feedback from the TypeScript IDE and, thus, to incorrect uses of the underlying JavaScript library.This work presents dts-generate, a tool that generates TypeScript declaration files for JavaScript libraries uploaded to the NPM registry. It extracts code examples from the documentation written by the developer, executes the library driven by the examples, gathers run-time information, and generates a declaration file based on this information. To evaluate the tool, 249 declaration files were generated directly from an NPM module and 111 of these were compared with the corresponding declaration file provided on DefinitelyTyped. All these files either exhibited no differences at all or differences that can be resolved by extending the developer-provided examples.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes},
pages = {97–112},
numpages = {16},
keywords = {Declaration Files, JavaScript, Dynamic Analysis, TypeScript},
location = {M\"{u}nster, Germany},
series = {MPLR 2021}
}

@inproceedings{10.1145/2676726.2676971,
author = {Rastogi, Aseem and Swamy, Nikhil and Fournet, C\'{e}dric and Bierman, Gavin and Vekris, Panagiotis},
title = {Safe \& Efficient Gradual Typing for TypeScript},
year = {2015},
isbn = {9781450333009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2676726.2676971},
doi = {10.1145/2676726.2676971},
abstract = {Current proposals for adding gradual typing to JavaScript, such as Closure, TypeScript and Dart, forgo soundness to deal with issues of scale, code reuse, and popular programming patterns. We show how to address these issues in practice while retaining soundness. We design and implement a new gradual type system, prototyped for expediency as a 'Safe' compilation mode for TypeScript. Our compiler achieves soundness by enforcing stricter static checks and embedding residual runtime checks in compiled code. It emits plain JavaScript that runs on stock virtual machines. Our main theorem is a simulation that ensures that the checks introduced by Safe TypeScript (1) catch any dynamic type error, and (2) do not alter the semantics of type-safe TypeScript code.Safe TypeScript is carefully designed to minimize the performance overhead of runtime checks. At its core, we rely on two new ideas: differential subtyping, a new form of coercive subtyping that computes the minimum amount of runtime type information that must be added to each object; and an erasure modality, which we use to safely and selectively erase type information. This allows us to scale our design to full-fledged TypeScript, including arrays, maps, classes, inheritance, overloading, and generic types.We validate the usability and performance of Safe TypeScript empirically by type-checking and compiling around 120,000 lines of existing TypeScript source code. Although runtime checks can be expensive, the end-to-end overhead is small for code bases that already have type annotations. For instance, we bootstrap the Safe TypeScript compiler (90,000 lines including the base TypeScript compiler): we measure a 15% runtime overhead for type safety, and also uncover programming errors as type safety violations. We conclude that, at least during development and testing, subjecting JavaScript/TypeScript programs to safe gradual typing adds significant value to source type annotations at a modest cost.},
booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {167–180},
numpages = {14},
keywords = {gradual typing, typescript, javascript, type safety},
location = {Mumbai, India},
series = {POPL '15}
}

@article{10.1145/2714064.2660215,
author = {Feldthaus, Asger and M\o{}ller, Anders},
title = {Checking Correctness of TypeScript Interfaces for JavaScript Libraries},
year = {2014},
issue_date = {October 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/2714064.2660215},
doi = {10.1145/2714064.2660215},
abstract = {The TypeScript programming language adds optional types to JavaScript, with support for interaction with existing JavaScript libraries via interface declarations. Such declarations have been written for hundreds of libraries, but they can be difficult to write and often contain errors, which may affect the type checking and misguide code completion for the application code in IDEs. We present a pragmatic approach to check correctness of TypeScript declaration files with respect to JavaScript library implementations. The key idea in our algorithm is that many declaration errors can be detected by an analysis of the library initialization state combined with a light-weight static analysis of the library function code. Our experimental results demonstrate the effectiveness of the approach: it has found 142 errors in the declaration files of 10 libraries, with an analysis time of a few minutes per library and with a low number of false positives. Our analysis of how programmers use library interface declarations furthermore reveals some practical limitations of the TypeScript type system.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {1–16},
numpages = {16},
keywords = {program analysis, type checking}
}

