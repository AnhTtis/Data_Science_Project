
\section{Methods}\label{sec:Background}
Table \ref{tab:lwc_summary} outlines some of the core specifications of the NIST finalists \cite{madushan2022review}.


\begin{table*}

\caption{\label{tab:lwc_summary} Outline specifications for NIST LWC finalist algorithms \cite{madushan2022review}}
\centering
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}
\hline
Name &  Type &  Variant &  Underlying Primitive &  State &  Key  &  Mode  &  Rate/Block  &  Tag  &  Security \\
 &   &   &   &   (Bits) &   (Bits) &    &  (Bits) &   (Bits) &   (Bits)\\
\hline\hline
Ascon &  Sponge &  Ascon-128 &  Ascon-p &  320 &  128 &  Duplex &  64 &  128 &  128\\
&&          Ascon-128a &  Ascon-p &  320 &  128 &  Duplex &  128 &  128 &  128\\
\hline
Elephant &  Sponge &  Jumbo &  Spongent &  176 &  128 &  Elephant &  176 &  64 &  127\\
&& Dumbo &  Spongent &  160 &  128 &  Elephant &  160 &  64 &  112\\
&&         Delirium &  Keccak &  200 &  128 &  Elephant &  176 &  128 &  127\\
\hline
GIFT-COFB &  Block &  GIFT-COFB &  GIFT-128 &  192 &  128 &  COFB &  128 &  128 &  128\\
\hline
Grain-128AEAD &  Stream &  Grain-128AEAD &  N/A &  256 &  128 &  N/A &  1 &  64 &  128\\
\hline
ISAP &  Sponge &  ISAP-A-128 &  Ascon-p &  320 &  128 &  ISAP &  64 &  128 &  128\\
&&          ISAP-K-128 &  Keccak &  400 &  128 &  ISAP &  144 &  128 &  128\\
&&          ISAP-K-128A &  Keccak &  400 &  128 &  ISAP &  144 &  128 &  128\\
&&          ISAP-A-128A &  Ascon-p &  320 &  128 &  ISAP &  64 &  128 &  128\\
\hline
PHOTON-Beetle &  Sponge &  PHOTON-Beetle-AEAD[128] &  PHOTON256 &  256 &  128 &  Beetle &  128 &  256 &  121\\
&&         PHOTON-Beetle-AEAD &  PHOTON256 &  256 &  128 &  Beetle &  32 &  256 &  128\\
\hline
Romulus &  Block &  Romulus-M &  Skinny-128-384 &  384 &  128 &  COFB &  128 &  128 &  128\\
&&          Romulus-N &  Skinny-128-384 &  384 &  128 &  COFB &  128 &  128 &  128\\
&&          Romulus-T &  Skinny-128-384 &  384 &  128 &  COFB &  128 &  128 &  128\\
\hline
SPARKLE &  Sponge &  SCHWAEMM256-128 &  SPARKLE &  384 &  128 &  SPARKLE &  256 &  128 &  120\\
&&          SCHWAEMM128-128 &  SPARKLE &  256 &  128 &  SPARKLE &  128 &  128 &  120\\
&&          SCHWAEMM192-192 &  SPARKLE &  384 &  192 &  SPARKLE &  192 &  192 &  184\\
&&          SCHWAEMM256-256 &  SPARKLE &  512 &  256 &  SPARKLE &  256 &  256 &  248\\
\hline
TinyJambu &  Sponge &  TinyJambu &  TinyJambu &  128 &  128 &  TinyJambu &  32 &  64 &  120\\
\hline
Xoodyak &  Sponge &  Xoodyak &  Xoodoo &  384 &  128 &  Cyclist &  352 &  128 &  128\\
\hline

\end{tabular}
\end{table*}


\subsection{ASCON}
ASCON \cite{dobraunig2016ascon, ASCON} was designed by Christoph Dobraunig, Maria Eichlseder, Florian Mendel and Martin Schläffer from Graz University of Technology, Infineon Technologies, and Radboud University. It is both a lightweight hashing and encryption method. ASCON uses a single lightweight permutation with Sponge-based modes of operation and an SPN (substitution–permutation network) permutation. Overall it has an easy method of implementing within hardware (2.6 gate equivalents) and software. A 5-bit S-box (as used in Keccak’s S-box core) is used to enable a lightweight approach, and it has no known side-channel attacks. It can also achieve high throughputs such as throughputs of between 4.9 and 7.3 Gbps. It stores its current state with 320 bits.


\subsection{Elephant}
Elephant is a light-weight crypto cipher created by Tim Beyne, Yu Long Chen, Christoph Dobraunig, and Bart Mennink \cite{beyne2020dumbo}. It is an authenticated encryption scheme, based on a nonce-based encrypt-then-MAC construction. We can provide a nonce (or IV) and which is the salt value for the cipher. Along with this it supports Authenticated Encryption with Associated Data (AEAD) and where we can provide additional data for the cipher. This additional data is not sent with the cipher or used within the cipher, but can be used to authenticate it. An example might be to link a packet sequence number to the additional data, so that the cipher could not be played-back for another sequence number. One of the strengths of Elephant is that it has a low footprint such as with a 160-bit permutation and can be parallelized.

 Within Elephant we have three different variations: Dumbo, Jumbo and Delirium (and which is a Belgian beer with a pink elephant logo). It was created by Tim Beyne, Yu Long Chen, Christoph Dobraunig, and Bart Mennink \cite{Elephant}. Tim and Yu are from KU Leuven and imec-COSIC, Belgium, and Christoph and Bart from Radboud University, The Netherlands.


One of the strengths of Elephant is that it has a low footprint and can use a 160-bit permutation. This small value reduces the footprint of the method within memory. In order to speed up the encryption process, the method can also be parallelized. There are three main methods:

\begin{itemize}
\item Dumbo: Elephant-Spongent-$\pi$[160]. This method is well-matched to hardware and gives the baseline level of security. The 160 value relates to the bit size of the permutation that is operated on. Overall it gives 112-bit security levels.
\item Jumbo: Elephant-Spongent-$\pi$[176]. This is an improved method and achieves 127-bit security.
\item Delirium: Elephant-Keccak-f[200]. This is a more software-focused approach with reasonably good hardware performance, and with 127-bit security.
\end{itemize}


\subsection{GIFT-COFB}
GIFT-COFB is a light-weight crypto cipher created by Subhadeep Banik, Avik Chakraborti, Tetsu Iwata, Kazuhiko Minematsu Mridul Nandi, Thomas Peyrin, Yu Sasaki, Siang Meng Sim and Yosuke Todo \cite{banik5gift, GIFT, asecuritysite_73133}. It uses a COFB (COmbined FeedBack) block cipher based AEAD mode using the GIFT-128 block cipher \cite{banik2017gift}. Overall GIFT is similar to a smaller version of PRESENT. It is thought that GIFT has better performance than SIMON and SKINNY. GIFT-COFB fixes some of the security weaknesses of PRESENT. As many systems are now looking to authenticate encryption with AEAD (Authenticated Encryption with Additional Data). With AEAD we add in extra data and which can be used to authenticate the connected cipertext. For example, with network packets, we could add the source port and sequence number into the additional data, and where these were used to perform the authentication. The AEAD addition was then added through a submission to the NIST competition for lightweight cryptography with GIFT-COFB. 

\subsection{Grain128-AEAD}
Grain is a Light Weight Stream Cipher and was written by Martin Hell, Thomas Johansson and Willi Meier \cite{hell2006stream, asecuritysite_58074}. It has a relatively low gate count, power consumption and memory. In its AEAD form, it has a 128-bit key, and has two shift registers (LFSR - Linear Feedback Shift Register and NFSR - Non-linear Feedback Shift Register) and a nonlinear output function. The gate equivalent (GE) relates to the level of parallelization defined. For the lowest level of parallization (s=1), we can achieve a GE of 3,638, and with the maximum parallelization level (s=32), we have a GE of 12,110. When running a maximum speed for the lowest level of parallelization we get a throughput of 560 Mbps, a power drain of 3.6~mW and an area of 5,258 $\mu m^2$. With the highest level of parallelization we can achieve a throughput of 10.59~Gbps. 

\subsection{ISAP}
Isap is a lightweight block cipher and was written by Christoph Dobraunig, Maria Eichlseder, Stefan Mangard, Florian Mendel, Bart Mennink, Robert Primas and Thomas Unterluggauer \cite{dobraunig2020isap, isap, asecuritysite_12892}. It is focused on robustness against power analysis and fault attacks and where there is a node for small code size. Overall it uses a sponge-based mode with SPN permutations. Isap has mechanisms to protect against fault attacks. Isap uses an Encrypt-then-MAC design with two keys for IsapMac and IsapEnc. 

\subsection{Photon-Beetle}
One of the great advantages of using a sponge method in cryptography is that you get the addition of hashing on top of encryption for very little overhead in the code size and the memory requirements. If we are using something like an 8-bit microcontroller, we might only have a few hundred bytes of ROM, and a similar space for RAM. The device on the left-hand side is an MC6811, and only has 8 KB of ROM and 256 bytes of on-chip RAM. We thus need efficient code for our encryption, as there needs to be space for the main application software, too.

One method which focuses on creating an extremely small footprint is the PHOTON-Beetle method \cite{chakraborti2018beetle, PHOTON, asecuritysite_19090}. Overall it is a lightweight block cipher and was written by Zhenzhen Bao, Avik Chakraborti, Nilanjan Datta, Jian Guo, Mridul Nandi, Thomas Peyrin, and Kan Yasuda. It uses the sponge-based mode Beetle with the P256 for the permutation and supports both authenticated encryption (AE) and hashing. PHOTON-Beetle AEAD and PHOTON-Beetle hashing are finalists for NIST's competition on lightweight cryptography.

The Beetle family of cryptography methods integrates a lightweight, sponge-based authenticated encryption. When this is linked with the PHOTON permutation (PHOTON-256), it achieves an extremely small footprint. In tests, a 64-bit security version of PHOTON-Beetle consumes less than 600 LUTs (LookUp Tables) on an FPGA, compared with 1,000 LUTs for COFB-AES (COmbined FeedBack-AES).

PHOTON-Beetle can be optimized for either a low ROM environment (where the code needs to be compact) or for speed. For PHOTON-Beetle AEAD, on 8-bit microcontrollers with low ROM sizes, the ROM code size is less than 2,200 bytes, and adding a hashing method on top of this, only adds another 300 bytes of ROM. The requirement for memory, too, is small and where it only requires 100 bytes of RAM. The average speed is around 8,200 cycles per byte for encryption. For the PHOTO-Beetle AEAD mode which focuses on speed, the ROM code size is less than 4,100 bytes, with hashing adding 300 bytes. The average speed is around 4,900 cycles per byte for encryption.
\subsection{Romulus}
Romulus is a lightweight block cipher and was written by Tetsu Iwata, Mustafa Khairallah, Kazuhiko Minematsu and Thomas Peyrin \cite{iwata2020duel, Rom, asecuritysite_36089}. The NIST competition for lightweight cryptography has reached the final stage, and with a shortlist of 10 candidates. Each differs in their approach, but they aim to create a cryptography method that is secure, has a low footprint, and is robust against attacks. So while many of the contenders, such as ASCON, GIFT and Isap, use the sponge method derived from the SHA-3 standard (Keccak), Romulus takes a more traditional approach and looks towards a more traditional lightweight crypto approach. Overall it is defined as a tweakable block cipher (TBC) and which supports authenticated encryption with associated data (AEAD). For its more traditional approach, it uses the SKINNY lightweight tweakable block cipher. 

SKINNY is a light-weight block cipher. It has a 64-bit or 128-bit block size, and a key size of 64 bits, 128 bits and 256 bits. The methods are SKINNY-64-64 (64-bit block, 64-bit key and 32 rounds); SKINNY-64-128 (64-bit block, 128-bit key, and 36 rounds); SKINNY-64-192 (64-bit block, 192-bit key, and 40 rounds); SKINNY-128-128 (128-bit block, 128-bit key, and 40 rounds); SKINNY-128-256 (128-bit block, 256-bit key, and 48 rounds); SKINNY-128-384 (128-bit block, 384 key, and 56 rounds). For a 64-bit block it uses a 4x4 matrix for nibbles, and a 4x4 matrix of bytes for a 128-bit block size. :

For a 64-bit block it uses a 4x4 matrix for nibbles (4 bits), and a 4x4 matrix of bytes for a 128-bit block size. For the 4x4 matrix, each round we have operations of SC (SubCells); AC (AddConstants); ShiftRows (SR); and MixColums (MC):

For the SubCells (SC) we either have a 4-bit S-box (for 64-bit block) or a 8-bit S-box (for 128-bit block):

The AddRoundTweakey (ART) process takes part of the key, and applies it within each round.


\subsection{Sparkle}

Sparkle is a family of permutations. Schwaemm \cite{beierle2019schwaemm} is a light-weight cryptography method and provides confidentiality, integrity and authentication, while Esch provides a hashing method that is preimage and collision resistant. Both methods use a sponge construction using a cryptographic permutation (as used in SHA-3). Esch256 (Efficient, Sponge-based, and Cheap Hashing) implements the hashing method for a 256-bit hash, and has a block size of 16 bytes, a security level of 128 bits and a data limit of up to 2132. It was designed by Christof Beierle, Alex Biryukov, Luan Cardoso dos Santos, Johann Großschädl, Léo Perrin, Aleksei Udovenko, Vesselin Velichkov, and Qingju Wang. Schwaemm stands for Sponge-based Cipher for Hardened but Weightless Authenticated Encryption on Many Microcontrollers, and is also the Luxembourgish word of "sponge". 

The submitted version for the NIST competition includes Schwaemm \cite{beierle2019schwaemm, asecuritysite_15221} which is a lightweight cryptography method and provides confidentiality, integrity and authentication and Esch which provides a hashing method that is preimage and collision-resistant. Both methods use a sponge construction using a cryptographic permutation (as used in SHA-3). Esch256 (Efficient, Sponge-based, and Cheap Hashing) implements the hashing method for a 256-bit hash and has a block size of 16 bytes, a security level of 128 bits and a data limit of up to $2^{132}$.


For Schwaemm, the name is derived from "Sponge-based Cipher for Hardened but Weightless Authenticated Encryption on Many Microcontrollers", and which is also the Luxembourgish word of "sponge". Esch256 is also a part of a name of a place in Luxembourg. SPARKLE is similar to SPARKX and its name derives from SPARx, but Key LEss.

For AEAD, we have Schwaemm128–128, Schwaemm256–128, Schwaemm192–192, and Schwaemm256–256, and which support block sizes of 16 (128 bits), 32 (256 bits), 24 (192 bits) and 64 bytes, respectively. These give a security level that ranges from 120 bits to 248 bits.



\subsection{TinyJambu}
TinyJAMBU defines a family of lightweight cryptography methods and was designed by Hongjun Wu and Tao Huang \cite{wutinyjambu}.

\subsection{Xoodyak}
Xoodyak comes from the Keccak research team \cite{daemen2020xoodyak, asecuritysite_96729}, and which was successful in the SHA-3 competition. Overall, Keccak was evaluated as the most efficient and secure hashing method.

Joan Daemon also co-authored the Rijndael cipher that eventually became AES. With Xoodoo permutation we can apply it with the Xoodyak function. With this, we store a 384-bit state for the encryption and which relates to the sequence of the input data. With this, we can create a fixed-length hash, a pseudo-random bit value, or an output of a variable length. This can thus produce either a hash function, a random bit stream, or an encryption method.