%% Full length research paper template
%% Created by Simon Hengchen and Nilo Pedrazzini for the Journal of Open Humanities Data (https://openhumanitiesdata.metajnl.com)

\documentclass{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{johd}
\usepackage{listings}
%\usepackage{html}
\usepackage[T1]{fontenc}
%\usepackage{tgbonum}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%
\usepackage{listings}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    %numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

%%%%%%%%%%%%%%

\title{ChatGPT for Programming Numerical Methods}

%\title{ChatGPT (OpenAI) for Programming Numerical Methods}


\author{Ali Kashefi $^{a}$$^{*}$, Tapan Mukerji $^{b}$  \\
        \small $^{a}$Department of Civil \& Environmental Engineering, Stanford University, Stanford, CA, 94305 USA \\
        \small $^{b}$Department of Energy Science \& Engineering, Stanford University, Stanford, CA, 94305 USA \\
 \\\\
        \small $^{*}$Corresponding author: Ali Kashefi, \tt{ kashefi@stanford.edu}\\
\\\
        \small ChatGPT (OpenAI): \url{https://chat.openai.com/chat}
}

\date{} %leave blank

\begin{document}

\maketitle

\begin{abstract} 
\noindent 
ChatGPT is a large language model trained by OpenAI. In this technical report, we explore for the first time the capability of ChatGPT for programming numerical algorithms. Specifically, we examine the capability of GhatGPT for generating codes for numerical algorithms in different programming languages, for debugging and improving written codes by users, for completing missed parts of numerical codes, rewriting available codes in other programming languages, and for parallelizing serial codes. Additionally, we assess if ChatGPT can recognize if given codes are written by humans or machines. To reach this goal, we consider a variety of mathematical problems such as the Poisson equation, the diffusion equation, the incompressible Navier-Stokes equations, compressible inviscid flow, eigenvalue problems, solving linear systems of equations, storing sparse matrices, etc. Furthermore, we exemplify scientific machine learning such as physics-informed neural networks and convolutional neural networks with applications to computational physics. Through these examples, we investigate the successes, failures, and challenges of ChatGPT. Examples of failures are producing singular matrices, operations on arrays with incompatible sizes, programming interruption for relatively long codes, etc. Our outcomes suggest that ChatGPT can successfully program numerical algorithms in different programming languages, but certain limitations and challenges exist that require further improvement of this machine learning model.


%In this technical report, we explore the capability of ChatGPT, a large language model trained by OpenAI, for programming numerical algorithms in different programming languages such as Python, C, Matlab, etc. Specifically, we examine the capability of GhatGPT for generating a code for certain numerical algorithms, for debugging a written code by users, and for identifying if a code is written by humans or by itself (i.e., ChatGPT). To reach this goal, we test various numerical algorithms such as finite-difference or finite volume methods for solving the Poisson equation, the diffusion equation, the incompressible Navier-Stokes equations, the inviscid compressible Euler equations as well as scientific machine learning methods such as physics-informed neural networks. Through these examples, we investigate the successes, failures, and challenges of ChatGPT. Our findings suggest that ChatGPT can successfully program numerical algorithms in different programming languages, but certain limitations and challenges exist that require further improvement of this machine learning model. This is the first version of this technical report and we plan to update it upon new findings. 


%This context of this abstract is initially written by ChatGPT and then modified by the authors.

\end{abstract}

\noindent\keywords{ChatGPT; Numerical algorithms; Scientific simulations; Programming languages; Automation of programming; Natural language processing}\\

\tableofcontents
 
\section{Introduction}
\label{Sect1}


Numerical algorithms play a vital role in scientific simulations, engineering design, and computational modeling. These algorithms are typically developed and implemented by human programmers using programming languages such as C, C\texttt{++}, Python, MATLAB, etc. Developing and implementing numerical algorithms can be a challenging task, requiring significant programming knowledge and expertise. 


Recently, there has been a growing interest in the potential of natural language processing and artificial intelligence (AI) to automate the programming of numerical algorithms. Among the various AI-based programming approaches, large language models such as ChatGPT, developed by OpenAI, have shown remarkable success in generating coherent and contextually relevant text. ChatGPT is a generative language model that is pre-trained on large amounts of text data and can generate natural language text with high accuracy and fluency. However, the application of ChatGPT for programming numerical algorithms is still in its infancy.


In this technical report, we investigate for the first time the capability of ChatGPT for programming numerical algorithms in different programming languages. Particularly, we test the ability of this artificial intelligence model by considering various scientific problems such as the two-dimensional
Poisson equation, the two-dimensional diffusion equation, the incompressible Navier-Stokes equations in two dimensions, compressible
inviscid flow in one dimension, finding the maximum eigenvalue of matrices, solving linear systems of equations, storing sparse matrices, etc. We also provide examples of scientific machine learning such as convolutional neural networks for supervised learning and physics-informed neural networks for weakly supervised learning in computational mechanics. We analyze the capacity of GhatGPT to debug and enhance user-written codes, complete missing numerical code segments, rewrite existing codes in different programming languages, and parallelize serial codes. Furthermore, we test ChatGPT's ability to determine if given codes were created by humans or machines. Our goal is to explore the successes, failures, and challenges of ChatGPT through these test cases.


The results of our exploration provide insight into the capability of ChatGPT for programming numerical algorithms and the potential of such models for automating the programming of complex scientific simulations. Moreover, this technical report can contribute to the development of new tools and techniques for programming numerical algorithms using natural language processing and artificial intelligence.


%We record the exact input and output of ChatGPT without providing any technical details about the underlying mathematical algorithms. Instead, we provide references to the relevant code in the report. In most cases, we provide the full code, but for longer code snippets, we only include the most important parts. However, the full code is available in the repository. 

%The rest of this technical report is structured as follows. ... . This subsection is initially generated by ChatGPT and then reviewed, edited, and modified by the authors.


\section{Programming numerical algorithms by ChatGPT}
\label{Sect2}

\subsection{A simple numerical method}\label{Sect21}

We start with a simple and basic numerical algorithm. There are various methods for finding the roots of a function. Among them, the secant method \cite{moin2010fundamentals} is an iterative numerical method used to find the root of a function $f(x)$ by approximating the derivative with a finite difference. The formula for the secant method is written as

\begin{equation}
x_{k+1} = x_k - \frac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})},
\label{EqSecant}
\end{equation}
where $x_k$ and $x_{k-1}$ are the last two approximations to the root. $x_{k+1}$ is the new approximation to the root. $f(x_k)$ and $f(x_{k-1})$ are the function values at $x_k$ and $x_{k-1}$, respectively. We ask ChatGPT to write a Python code for the secant method. The gray boxes below show the input prompt and output from ChatGPT.

\begin{tcolorbox}

{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code for root finding using the secant method.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure! Here is a Python code for root finding using the secant method:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\label{CodeSecant1}
\lstinputlisting[language=Python]{Secant1.py}

\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
Here is an example of how to use this function to find a root of a function:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\label{CodeSecant2}
\lstinputlisting[language=Python]{Secant2.py}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
This will output:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{Secant3.py}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
Note that the secant method is not guaranteed to converge, so it's important to check for convergence and to set a maximum number of iterations to avoid an infinite loop. In this implementation, if the method fails to converge within the maximum number of iterations, a \textbf{`ValueError'} is raised.}
\end{tcolorbox}

As can be seen from this example, the answer provided by ChatGPT is very comprehensive. The comment made by ChatGPT about the convergence of the secant method is valuable.

\subsection{Programming in different languages}\label{Sect22}

In this subsection, we examine the capability of ChatGPT for programming numerical methods in different languages. Specifically, we investigate the languages of C, C\texttt{++}, Python, MATLAB, and Julia. As an example, we consider the method of successive over-relaxation (SOR) \cite{darve2021numerical,moin2010fundamentals,wendland2017numerical}, which is an iterative numerical method for solving a system of linear equations $A \vec x = \vec b$. The numerical procedure for the SOR method is expressed as:
\begin{equation}
    x_i^{(k+1)} = (1-\omega)x_i^{(k)} + \frac{\omega}{a_{ii}} \left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - \sum_{j=i+1}^n a_{ij} x_j^{(k)}\right),
\label{EqSOR}
\end{equation}
where $x_i^{(k)}$ represents the $i$-th component of the solution vector at the $k$-th iteration.
$a_{ij}$ are the elements of the coefficient matrix. $b_i$ are the elements of the constant vector.
$n$ indicates the number of equations in the system. $\omega$ is the relaxation parameter. $a_{ii}$ shows the diagonal element of the coefficient matrix $A$. We ask ChatGPT to develop a code for solving a linear system of equations using the SOR algorithm, respectively, in the languages of MATLAB, C, C\texttt{++}, Python, and Julia. Our dialogues with ChatGPT and resulting codes are listed below.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a MATLAB code for solving a linear system of equations using the method of successive over-relaxation with an example.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's a MATLAB code for solving a linear system of equations using the method of successive over-relaxation with an example:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=MATLAB]{SOR_MATLAB.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont This code sets up the system of equations \textbf{`Ax = b'} using the matrix \textbf{A} and vector \textbf{`b'}, and initializes the initial guess \textbf{`x'} to be a vector of zeros. The code then uses a loop to perform the SOR method until either the residual is less than the tolerance or the maximum number of iterations is reached. The relaxation parameter \textbf{`omega'} and tolerance \textbf{`tol'} are also set at the beginning of the code.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a C code for solving a linear system of equations using the method of successive over-relaxation with an example.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Here's an example of C code for solving a linear system of equations using the method of successive over-relaxation (SOR):}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C]{SOR_C.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a C++ code for solving a linear system of equations using the method of successive over-relaxation with an example.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's an example of C++ code for solving a linear system of equations using the method of successive over-relaxation (SOR):}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{SOR_C_plus.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code for solving a linear system of equations using the method of successive over-relaxation with an example.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's an example of Python code for solving a linear system of equations using the method of successive over-relaxation (SOR):}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{SOR_Python.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Julia code for solving a linear system of equations using the method of successive over-relaxation with an example.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's an example of Julia code for solving a linear system of equations using the method of successive over-relaxation (SOR):}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{SOR_Julia.txt}
\end{tcolorbox}

\subsection{Specifying numerical problems with details}\label{Sect23}

The goal of this subsection is to examine the ability of ChatGPT for solving numerically a given problem with requested details, such as boundary conditions, domain size, etc. As a practical example, we consider the two-dimensional Poisson equation

%The 2D Poisson equation is a partial differential equation used to describe the steady-state behavior of diffusion and electrostatics phenomena. The equation relates the Laplacian of a scalar function to a source term:

\begin{equation}
    \frac{\partial^2 \phi}{\partial x^2} + \frac{\partial^2 \phi}{\partial y^2}= f(x,y),
    \label{EqPoisson1}
\end{equation}
where $\phi(x,y)$ is the scalar variable and $f(x,y)$ is a known source term. To numerically solve the Poisson equation, we discretize the domain into a grid of points and approximate the derivatives using a second-order finite difference method \cite{hoffmann2000computational,moin2010fundamentals,kim1985application}. The resulting discretized equation is written as

\begin{equation}
    \frac{\phi_{i+1,j} - 2\phi_{i,j} + \phi_{i-1,j}}{\Delta x^2} + \frac{\phi_{i,j+1} - 2\phi_{i,j} + \phi_{i,j-1}}{\Delta y^2} = f_{i,j},
    \label{EqPoisson2}
\end{equation}
where $\phi_{i,j}$ is the value of the scalar variable at grid point $(i,j)$, and $\Delta x$ and $\Delta y$ are the grid spacing in the $x$ and $y$ directions, respectively. Additionally, $f_{i,j}$ shows the value of the source term at grid point $(i,j)$. 

As a first example, we simply ask ChatGPT to solve the two-dimensional Poisson equation. We do not specify the source term, boundary conditions, domain size, etc. Figure \ref{FigPoisson1} shows the corresponding solution by ChatGPT.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code to solve the 2D Poisson equation. Plot the solution.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} To solve the 2D Poisson equation in Python, we can use the finite difference method, which approximates the differential equations using difference equations that can be solved numerically.

Here's an example Python code that solves the 2D Poisson equation using the finite difference method and plots the solution using Matplotlib:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{Poisson1.txt}
\end{tcolorbox}


\begin{figure}[h]
\centering
\includegraphics[width=7cm]{poisson1.pdf}
\caption{Solution of the Poisson equation (see Eq. \ref{EqPoisson1}) by ChatGPT, when we do not specify any detail in our request}
\label{FigPoisson1}
\end{figure}

In the next example, we again ask ChatGPT to solve the two-dimensional Poisson equation; however, we specify the source term to be $f(x,y) = \sin(x)\cos(y)$. Figure \ref{FigPoisson2} depicts the associated output with this request from ChatGPT.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code to solve the 2D Poisson equation with the source term of sin(x)*cos(y). Plot the solution.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Here's an updated version of the Python code that solves the 2D Poisson equation with the source term of sin(x)*cos(y) and plots the solution using Matplotlib:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{Poisson2.txt}
\end{tcolorbox}

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{poisson2.pdf}
\caption{Solution of the Poisson equation (see Eq. \ref{EqPoisson1}) by ChatGPT, when we specify the source term in our request}
\label{FigPoisson2}
\end{figure}


Eventually, we specify the domain size, boundary condition types, and the source term for solving the two-dimensional Poisson equation. The following chat-box shows our request in details.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code to solve the 2D Poisson equation with the source term of sin(x)*cos(y) in a rectangular domain (centered at the origin) with a length of 5 and a width of 3. Use the zero Dirichlet boundary condition for x=2.5 and x=-2.5. The gradient of the variable is zero on the other boundaries. Plot the solution.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Here's the Python code to solve the 2D Poisson equation with the source term of sin(x)*cos(y) in a rectangular domain with zero Dirichlet boundary condition for x=2.5 and x=-2.5, and zero Neumann boundary condition for y=-1.5 and y=1.5:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{Poisson3.txt}
\end{tcolorbox}

\begin{figure}[h]
\centering
\includegraphics[width=7cm]{poisson3.pdf}
\caption{Solution of the Poisson equation (see Eq. \ref{EqPoisson1}) by ChatGPT, when we specify the source term and boundary conditions in our request}
\label{FigPoisson3}
\end{figure}


Looking at our chat box, it is worthwhile to note that we wrote ``The gradient of the variable is zero on other boundaries''. And ChatGPT wrote in our response: ``zero Neumann boundary condition for $y=-1.5$ and $y=1.5$'', which is amazingly exactly equivalent to our request; however, in another wording! Figure \ref{FigPoisson3} exhibits the solution of the Poisson equation for this case.

\subsection{The button of ``Regenerate response''}\label{Sect24}

There is a ``Regenerate response'' button in ChatGPT. In this subsection, we investigate the role of this button in generating (programming) codes for a numerical algorithm. For instance, let us consider the diffusion equation. The two-dimensional diffusion equation for a variable $T(x,y,t)$ is written as

\begin{equation}
    \frac{\partial T}{\partial t} = D \left(\frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial y^2}\right) + s(x,y,t),
    \label{EqDif1}
\end{equation}
where $D$ is the diffusion coefficient and $s(x,y,t)$ is a known source term. To numerically solve the two-dimensional diffusion, we might use the forward-time central space (FTCS) method \cite{hoffmann2000computational}, which approximates the derivatives in time and space using a central difference approximation as follows

\begin{equation}
    \frac{\partial T}{\partial t} \approx \frac{T_{i,j}^{n+1} - T_{i,j}^n}{\Delta t},
    \label{EqDif2}
\end{equation}

\begin{equation}
\frac{\partial^2 T}{\partial x^2} \approx \frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\Delta x^2},   
\label{EqDif3}
\end{equation}

\begin{equation}
\frac{\partial^2 T}{\partial y^2} \approx \frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\Delta y^2},
\label{EqDif4}
\end{equation}
where $T_{i,j}^n$ is the value at grid point $(i,j)$ and time step $n$. Additionally, $\Delta x$, $\Delta y$, and $\Delta t$ are the grid spacing in the $x$ and $y$ directions and the time step, respectively. Substituting these approximations into the two-dimensional diffusion equation and rearranging, we obtain a finite difference equation for the value of $T_{i,j}^{n+1}$

\begin{equation}
T_{i,j}^{n+1} = T_{i,j}^n + D\frac{\Delta t}{\Delta x^2} (T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n) + D\frac{\Delta t}{\Delta y^2} (T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n) + s_{i,j}^n \Delta t,
\label{EqDif5}
\end{equation}
where $s_{i,j}^n$ is the value of the source term at grid point $(i,j)$. The FTCS method is numerically stable if and only if the following condition is satisfied
\begin{equation}
    \Delta t \leq \frac{1}{2D} \frac{1}{(\frac{1}{\Delta x^2} + \frac{1}{\Delta y^2})}.
    \label{EqDif6}
\end{equation}
Now we ask ChatGPT to numerically solve the two-dimensional diffusion equation (Eq. \ref{EqDif1}) using the FTCS method (see Eq. \ref{EqDif5}).


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code for solving the 2D diffusion equation in a square box using the FTCS (Forward Time Centered Space) method. Use Dirichlet boundary conditions such that the value of the variable is 0 on the right and left boundaries, while they are 1 on the top and bottom.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} 
Here is a Python code for solving the 2D diffusion equation in a square box using the FTCS method:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{FTCS_1.txt}
\end{tcolorbox}


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Diffusion1.pdf}
\caption{Solution of the two-dimensional diffusion equation (see Eq. \ref{EqDif1}) using the FTCS method (see Eq. \ref{EqDif5}) by ChatGPT}
\label{FigFTCS1}
\end{figure}


After receiving this response from ChatGPT, we immediately press the ``Regenerate response'' button. We receive the following response (i.e., code). 


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{FTCS_2.txt}
\end{tcolorbox}


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Diffusion2.pdf}
\caption{Solution of the two-dimensional diffusion equation (see Eq. \ref{EqDif1}) using the FTCS method (see Eq. \ref{EqDif5}) by ChatGPT after pressing the button of ``Regenerate response''}
\label{FigFTCS2}
\end{figure}



Comparing these two codes, we realize that they have completely different structures. In fact, it seems that the machine has been massively trained over a variety of texts. Another possible question is that if one presses the button of ``Regenerate response'' again, what the ChatGPT output would be, or how many different responses ChatGPT can generate for a unique question?!


\subsection{One-dimensional compressible inviscid flow}\label{Sect25}


We so far asked ChatGPT to program numerical solvers for a single partial differential equation such as the Poisson equation and the diffusion equation. In this subsection, we explore the capability of ChatGPT for more complicated partial differential equations. A valuable example is the Euler equations governing the one-dimensional compressible inviscid flow \cite{laney1998computational,godunov1959finite}. Because there is an exact solution to this problem \cite{fedkiw1999non,hu2009hllc}, it is widely used as a standard test case for the validation of numerical solvers. The equations of the conservation of mass, momentum, and energy in the $x$ direction for one-dimensional compressible inviscid flow are, respectively, written as

\begin{equation}
    \frac{\partial \rho}{\partial t} + \frac{\partial (\rho u_x)}{\partial x} = 0,
    \label{EqEuler1}
\end{equation}

\begin{equation}
    \frac{\partial (\rho u_x)}{\partial t} + \frac{\partial (\rho u_x^2 + p)}{\partial x} = 0,
    \label{EqEuler2}
\end{equation}

\begin{equation}
    \frac{\partial E}{\partial t} + \frac{\partial(Eu_x +pu_x)}{\partial x}  = 0,
    \label{EqEuler3}
\end{equation}
where $\rho$ shows the density. The velocity in the $x$ direction is indicated by $u_x$. The pressue is shown by $p$. Additionally, $E$ is the total energy per unit volume and is expressed as 

\begin{equation}
    E = \frac{p}{\gamma - 1} + \frac{1}{2}\rho u_x^2,
    \label{EqEuler4}
\end{equation}
where $\gamma$ is the specific heat ratio. We ask ChatGPT to write a code for us for obtaining a numerical solution to this problem.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Matlab code for solving 1D compressible Euler equation with an example that shock happens.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's a Matlab code for solving the 1D compressible Euler equations using the Godunov method, with an example that generates a shock wave:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=MATLAB]{Euler1D.txt}
\end{tcolorbox}


\begin{figure}[h]
\centering
\includegraphics[width=5cm]{Density.pdf}
\includegraphics[width=5cm]{Velocity.pdf}
\includegraphics[width=5cm]{Pressure.pdf}
\caption{Solution of the density, velocity, and pressure variables for the one-dimensional compressible inviscid flow (see Eqs. \ref{EqEuler1}--\ref{EqEuler3}) by the MATLAB code generated by ChatGPT}
\label{FigCompressibleFLow}
\end{figure}

\section{Machine learning for computational physics by ChatGPT}

\subsection{Physics-informed neural networks (PINNs)}\label{SectML1}


Regular neural networks learn patterns and relationships from data without any knowledge of the underlying physics processes. 
This might lead to predictions that are not consistent with the known laws of physics. On the other hand, physics-informed neural networks (PINNs) \cite{raissi2019physics,wang2022and,kashefi2022physics,kashefi2022prediction} are a type of artificial neural network that incorporates known physics principles or laws into the learning process. In fact, PINNs overcome this limitation by integrating the governing equations of the physical system into the network's loss function. In simple words, PINNs are neural networks that learn from the boundary and initial conditions as well as the underlying physics to solve a forward problem. Alternatively, PINNs can be used to solve an inverse problem by learning from sparse data as well as the underlying physics. 


In this subsection, for example, we ask ChatGPT to solve a forward problem using the PINN methodology. Particularly, we consider the one-dimensional diffusion equation for the variable $\theta(x,t)$ with the source term as follows

\begin{equation}
    \frac{\partial \theta}{\partial t} = \frac{\partial ^2 \theta}{\partial x^2} + \cos(x)\bigl(\cos(t)-\sin(t)\bigl),
    \label{EqPINN1}
\end{equation}
which has an exact analytical solution of $\theta(x,t)=\cos(x)\cos(t)$. Boundary and initial conditions of Eq. \ref{EqPINN1} obey the exact solution. According to the PINN methodology, the loss function ($\mathcal{L}$) is defined as

\begin{equation}
\mathcal{L} = \frac{1}{M_1} \sum_{i=1}^{M_1} \bigl(\hat{\theta}_i - \theta_{i}^{\text{bc}}\bigl)^2 + \frac{1}{M_2} \sum_{i=1}^{M_2} \bigl(\hat{\theta_i} - \theta_{i}^{\text{ic}}\bigl)^2 + \frac{1}{N} \sum_{i=1}^{N} \Bigl(\frac{\delta \hat{\theta}_i}{\delta t_i} - \frac{\delta}{\delta x_i} \bigl(\frac{\delta \hat{\theta}_i}{\delta x_i}\bigl) - \cos(x_i)\bigl(\cos(t_i)-\sin(t_i)\bigl)\Bigl)^2,
    \label{EqPINN2}
\end{equation}
where $\delta$ indicates the automatic differentiation operator in Tensorflow \cite{tensorflow2015-whitepaper}. $\hat{\theta}$ is the value predicted by PINN. $\theta^{\text{bc}}$ and $\theta^{\text{ic}}$ show the value of $\theta(x,t)$ at the boundary and initial points, respectively. The number of points located at the boundary and initial conditions are respectively indicated by $M_1$ and $M_2$. $N$ is the number of interior points of the domain. We ask ChatGPT to find the solution to this partial differential equation (Eq. \ref{EqPINN1}) using PINN.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a Python code for finding the solution of the partial differential equation of u\_t = u\_xx + cos(x)*(cos(t)-sin(t)) using the PINN methodology. The neural network is only aware of the boundary and initial conditions, which obey the exact solution of u(x,t) = cos(x)*cos(t). Plot the exact solution and the predicted solution.}
\end{tcolorbox}



\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} To solve the given partial differential equation (PDE) using the Physics-Informed Neural Networks (PINN) methodology, we'll follow these steps:

\begin{enumerate}
 
   \item  Import the necessary libraries.
   \item Define the neural network architecture.
   \item Set up the boundary and initial conditions.
   \item Train the neural network.
   \item Evaluate and plot the results.

\end{enumerate}

Here's a Python code implementing the PINN methodology for the given PDE:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{PINN.txt}
\end{tcolorbox}

\begin{figure}[h]
\centering
\includegraphics[width=6.2cm]{1.pdf}
\includegraphics[width=7cm]{Loss.pdf}
\caption{Location of training points (left) and loss ($\mathcal{L}$) history (right) for solving the partial differential equation (Eq. \ref{EqPINN1}) by ChatGPT using the PINN methodology}
\label{FigPINN1}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{3.pdf}
\includegraphics[width=7cm]{2.pdf}
\caption{A comparison between the exact solution and the predicted solution to the partial differential equation (Eq. \ref{EqPINN1}) generated by ChatGPT}
\label{FigPINN2}
\end{figure}


\subsection{Convolutional neural networks (CNNs) for computational physics}\label{SectML2}


%\subsection{Convolutional neural networks (CNNs) for predicting flow fields around airfoils}\label{SectML1}


Convolutional neural networks (CNNs) are specific types of artificial neural networks designed for processing and analyzing images. CNNs are automated pattern detectors that can recognize and extract features (e.g., edges, shapes, textures) from images. In this sense, CNNs can be used for supervised learning of computational mechanics, when the problem solution is a function of geometric parameters \cite{bhatnagar2019prediction,thuerey2020deep}. In this approach, the data must be represented on Cartesian grids (i.e., image-like data). For example, we can design a deep learning framework, where the CNN input is the images of airfoils with different shapes and the CNN output is the velocity and pressure fields. We ask ChatGPT to develop a Python code for designing a CNN-based deep learning framework to predict the flow fields around airfoils.


\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Develop a Python code for the prediction of the velocity and pressure fields around airfoils with different geometries in two dimensions. Specifically, use convolutional neural networks to encode geometric features and then use deconvolutional neural networks to decode the outputs. Input is 128 by 128 images, and the output has the same size.}
\end{tcolorbox}



\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} To predict the velocity and pressure fields around two-dimensional airfoils with different geometries using a combination of convolutional neural networks (CNNs) and deconvolutional neural networks (also known as transposed convolutions), you can follow these steps:

\begin{enumerate}
    \item Data preparation: Obtain a dataset with airfoil shapes and corresponding velocity and pressure fields. You can use computational fluid dynamics (CFD) simulations or experimental data for this purpose.

    \item Data preprocessing: Normalize and resize the airfoil images and velocity and pressure fields to a suitable size for the CNN. Split the dataset into training, validation, and test sets.

    \item Model creation: Design a CNN architecture for encoding geometric features and a deconvolutional neural network for decoding the outputs.

    \item Training: Train the combined model using the training and validation datasets.

    \item Testing: Evaluate the model's performance on the test dataset.

\end{enumerate}
Here's a sample code using TensorFlow and Keras:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{CNNs.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} This sample code provides a starting point for your project. You'll need to implement the functions to load and preprocess the data, as well as modify the CNN architecture and parameters according to your specific dataset and requirements.}
\end{tcolorbox}

There are two notable observations. First, ChatGPT implements the ``mean squared error'' as the loss function in line 40 of the above code. This is interesting because although this is an image-based prediction problem, ChatGPT realizes that this is, indeed, a regression task. Line 40 of the above code is listed below as well.


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{CNNs_1.txt}
\end{tcolorbox}
Second, ChatGPT implements the last layer of the network with three outputs for the velocity in the $x$ and $y$ directions and the pressure, as can be seen in line 34 of the above code, showing that GPT understands that the velocity field in two dimensions is a vector with two components and the pressure is simply a scalar variable. Line 34 of the above code is listed below as well.


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{CNNs_2.txt}
\end{tcolorbox}


\section{Debugging and improving codes using ChatGPT}\label{Sect3}

In this subsection, we investigate if ChatGPT can help us debug and improve our codes. As a practical example, we consider the Gauss-Seidel method \cite{wendland2017numerical}. The Gauss-Seidel method is an iterative method for solving a system of linear equations $A\vec{x} = \vec{b}$, where $A$ is a square matrix of coefficients, $\vec{x}$ is the unknown vector of variables, and $\vec{b}$ is a known vector of constants. The Gauss-Seidel method works by iteratively improving an initial guess of the solution vector $\vec{x}^{(0)}$ using the following update formula:

\begin{equation}
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - \sum_{j=i+1}^n a_{ij} x_j^{(k)}\right),
\label{EqGS}
\end{equation}
where $x_i^{(k)}$ is the $i$-th component of the solution vector at the $k$-th iteration, $a_{ij}$ are the coefficients of the matrix $A$, and $b_i$ are the constants in the vector $\vec{b}$. We test ChatGPT with a C\texttt{++} code written by the first author (A. Kashefi) that solves the system of $A\vec{x} = \vec{b}$. We provide ChatGPT with the code and ask if the code produces the correct results.

\begin{tcolorbox}

{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have written a C++ code for solving a system of equations using the Gauss-Seidel method. The code is as follows. Please let me know if the output of the code is correct.}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GS_Correct.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
\includegraphics[width=5mm]{gpt.png} The code for solving a system of equations using the Gauss-Seidel method looks fine. However, to check whether the output of the code is correct, we need to compare it with the actual solution.

For the given system of equations:
}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GS_Analysis_1.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont The actual solution is x1 = 1, x2 = 2, x3 = 1, x4 = -1, and x5 = 3.

Running the provided code, we get the following output:}
\end{tcolorbox}



\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GS_Analysis_2.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont The 
We can see that the output of the code is very close to the actual solution. The small differences may be due to numerical error, and can be reduced by increasing the number of iterations or using double precision arithmetic.

Therefore, the output of the code is correct.}
\end{tcolorbox}


ChatGPT could surprisingly successfully recognize the embedded system of equations ($A\vec x = \vec b$) inside our C\texttt{++} code (see lines 64 to 76 of the above code). Additionally, it seems that ChatGPT ran our code (using perhaps an inner compiler) as it said in the chat box: ``Running the provided code, we get the following output''.


For the next step, we intentionally put a bug in our C\texttt{++} code. In the loop written in line 18 of the following code, we start indexing from ``10'' instead of ``0'', and we ask the same question from ChatGPT.

%%%%%%%%%%%
\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have written a C++ code for solving a system of equations using the Gauss-Seidel method. The code is as follows. Please let me know if the code works correctly or not!}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GS_Wrong.txt}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} The code appears to be working correctly for solving a system of linear equations using the Gauss-Seidel method. However, there are a few points that can be improved:

\begin{enumerate}

\item Indexing of the loop: The loop indexing for \textbf{i} starts at 10, which does not make sense since \textbf{n} is 5. It should start from 0.

\item Memory allocation: Memory for the matrix a should be deallocated using the \textbf{`delete'} keyword after the program has finished using it. Also, \textbf{x} and \textbf{b} are not being deallocated in the code, which can lead to memory leaks.


\item Printing output: The output of the solution \textbf{x} is being printed in a for loop in the \textbf{`main'} function. This can be improved by creating a separate function for printing the solution vector.

\item Magic number: The value \textbf{`10\^-6'} is used as a threshold for convergence, which is a magic number. It should be declared as a constant variable at the beginning of the program to make the code more readable.

\end{enumerate}

Here is a modified version of the code with these improvements:
}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GS_Improved.txt}
\end{tcolorbox}


Interestingly, ChatGPT could recognize the minor bug in our code and fix it with some additional improvements.


\section{Completing incomplete codes by ChatGPT}\label{Sect4}

In this subsection, we investigate 
if ChatGPT is able to complete incomplete codes for numerical algorithms. For example, we consider the Thomas algorithm \cite{darve2021numerical}, which is an algorithm for solving a system of linear equations in the form of $A\vec{x} = \vec{d}$, in which the matrix $A$ is tridiagonal. It means that the non-zero elements are only on the main diagonal, the upper diagonal, and the lower diagonal. Let us say that $a_i$ (lower diagonal components), $b_i$ (main diagonal components), and $c_i$ (upper diagonal components) are the coefficients of the tridiagonal matrix, $d_i$ are the constants in the right-hand side vector, and $x_i$ are the unknown variables. The Thomas algorithm involves three steps. In the first step, we modify the coefficients to obtain a lower triangular matrix. We define the coefficients $\beta_i$ and $\gamma_i$ as follows

\begin{equation}
\beta_1 = b_1, \qquad \gamma_1 = c_1/\beta_1,
\label{EqThomas1}
\end{equation}

\begin{equation}
   \beta_i = b_i - a_i \gamma_{i-1}, \qquad \gamma_i = c_i/\beta_i, \quad i=2,\ldots,n-1,
\label{EqThomas2}
\end{equation}
In the second step (forward substitution), we solve the following system of equations for $y_1, y_2, \ldots, y_n$

\begin{equation}
   \beta_1 y_1 = d_1,
\label{EqThomas3}
\end{equation}

\begin{equation}
    \beta_i y_i = d_i - a_i y_{i-1}, \quad i=2,\ldots,n.
\label{EqThomas4}
\end{equation}
In the third step (backward substitution), we solve the original system of equations using the values of $y_1, y_2, \ldots, y_n$ obtained from the second step

\begin{equation}
   x_n = y_n,
\label{EqThomas5}
\end{equation}

\begin{equation}
    x_i = y_i - \gamma_i x_{i+1}, \quad i=n-1,\ldots,1.
\label{EqThomas6}
\end{equation}

The code of the Thomas algorithm is programmed in C\texttt{++} by the first author (A. Kashefi). We intentionally delete the content inside the ``for'' loop in lines 20 and 21, as can be seen in the following code. Afterward, we ask ChatGPT to write the loop such that the whole code works properly and produces correct outputs.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have written a C++ code for solving a tridiagonal system of equations. However, there is a specific part of the code that I do not know how to write it. It is in fact inside the loop of \textbf{`
for(int i = n - 2; i > -1 ; i - -)\{\}'}. Can you help me and write inside the loop for me? Here is my code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{Tri_me_incomplete.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} 
Sure, I can help you with that. Inside the loop \textbf{`for(int i = n - 2; i > -1 ; i - -)'}, you need to first calculate \textbf{`x[i]'} using the formula:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{Tri_gpt_1.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont 
Then you can output \textbf{`x[i]'} using \textbf{`cout'}. Here is the updated code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{Tri_gpt_2.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont This should solve your problem. Let me know if you have any further questions or issues!
}
\end{tcolorbox}

ChatGPT amazingly accomplished this task, as can be seen from the above example.



\section{Who wrote this code, humans or machines? ChatGPT answers!}\label{Sect5}

In this section, we try to answer this question: if ChatGPT can understand if a provided code is programmed by humans or by itself (i.e., ChatGPT)?! To answer this question, we consider two practical examples. The first one is the compressed sparse row (CSR) methodology \cite{darve2021numerical}, and the second one is the method of power iteration \cite{darve2021numerical,wendland2017numerical}.



The CSR algorithm is a strategy to store sparse matrices in a memory-efficient way, and it provides fast access to the non-zero elements of the matrix \cite{darve2021numerical}. The CSR algorithm works as follows

\begin{enumerate}

    \item Count the number of non-zero elements in each row of the matrix.
    \item Calculate the total number of non-zero elements in the matrix.
    \item Allocate three arrays: the value array, the column index array, and the row pointer array.
    \item Traverse the matrix row by row, storing the non-zero elements in the value array, and their column indices in the column index array.
    \item Store the row pointer array with the starting index of each row in the value and column index arrays.
\end{enumerate}
The resulting data structure contains three arrays:

\begin{itemize}   
\item  The value array contains all the non-zero values of the matrix, stored in row-major order.

\item  The column index array contains the column indices of each non-zero element in the value array.

\item  The row pointer array contains the starting index in the value and column index arrays for each row of the matrix.
\end{itemize}
This data structure allows for efficient matrix-vector multiplication, as well as other linear algebra operations.

A C\texttt{++} code for implementing the CSR algorithm is written by the first author (A. Kashefi). Hence, we know that the code has been generated by a human. Now, we provide the code for ChatGPT in the chat box and ask ChatGPT to identify if the code has been written by a human or by ChatGPT.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have a C++ code, please let me know if the code has been written by a human or by ChatGPT. The code is as follows.}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{CSR_me.txt}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} This code appears to have been written by a human. It is a C++ implementation of the Compressed Sparse Row (CSR) matrix format. The code declares a function \textbf{`CSR'} that takes in a 2D array of doubles and its dimensions and outputs the corresponding CSR format arrays. The main function initializes an example matrix and calls the CSR function on it. The code also prints the resulting arrays for visual verification.


The code is written in a consistent style, with indentation and spacing used appropriately. The variable names are meaningful and descriptive, and the comments are helpful in understanding the code's functionality. Overall, the code appears to be well-written and easy to read.}
\end{tcolorbox}

Apparently, ChatGPT successfully recognize that the given code had been written by humans. 


Let us exemplify another test case. For instance, the algorithm for finding the maximum eigenvalue of a matrix $A$ using the power iteration method \cite{darve2021numerical,wendland2017numerical}, which is described as follows

\begin{enumerate}
    
\item Choose an initial guess for the eigenvector $x_0$.
\item Repeat until convergence:
\begin{enumerate}
\item Calculate the new vector $y = A x_k$.
\item Calculate the norm of the new vector $y$ (i.e., $|y|$).
\item Normalize the new vector, $x_{k+1} = \frac{y}{|y|}$.
\item Calculate the corresponding eigenvalue: $\lambda_{k+1} = \frac{x_{k+1}^{tr} A x_{k+1}}{x_{k+1}^{tr} x_{k+1}}$.
\end{enumerate}
\item Return the final eigenvector $\mathbf{x}$ and eigenvalue $\lambda$.

\end{enumerate}
Now, we first ask ChatGPT to generate a C code for finding the maximum eigenvalue of a matrix using the method of power iteration. Afterward, we provide that code for ChatGPT and ask if the code has been generated by humans or ChatGPT.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have a C code, I was wondering if the code has been written by a human or by ChatGPT. Here is the code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{Max_EigenValue.txt}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png}
It seems that the code has been written by a human. The code performs power iteration method to find the maximum eigenvalue of a given matrix. It defines the matrix A and an initial guess for the eigenvector x. Then, it initializes some variables and performs iterations to find the maximum eigenvalue. Finally, it prints the maximum eigenvalue. The code is well-commented and organized, indicating that it has been written by a human.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Are you sure?}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png}
Yes, I am sure that the code you provided was written by a human.}
\end{tcolorbox}

As can be observed, ChatGPT is not able to recognize that the provided code has been indeed generated by itself!

\section{Rewriting a given code in a different language by ChatGPT}\label{Sect6}



In some cases, users might need to rewrite a code in another language, for example, due to compatibility with some software, to increase computing performance, etc. The following code is written by the first author (A. Kashefi) in C\texttt{++} for the purpose of computing the maximum eigenvalue of a matrix using the method of power iteration \cite{darve2021numerical,wendland2017numerical}. The relevant algorithm was presented in Sect. \ref{Sect5}. 


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} I have a C++ code. Please rewrite the code in Python. My code is as follows:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{my_self_eigen_max.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Here is the Python code equivalent to the provided C++ code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{python_eigen_max.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont 
Note that in Python, you don't need to include libraries like \textbf{`math'} and \textbf{`random'} using preprocessor directives like in C++. Also, the function \textbf{`rand()'} used in C++ has been replaced with \textbf{`random.random()'} in Python. Finally, the \textbf{`using namespace std'} directive is not used in Python.}
\end{tcolorbox}


Through this example, we observe that ChatGPT has the capability of rewriting a given code in a different language for numerical algorithms.

\section{Code parallelization using ChatGPT}\label{Sect7}


Code parallelization is crucial for achieving high-performance computing and handling the growing demand for faster and more efficient computing \cite{karniadakis2003parallel}. With code parallelization, multiple tasks can be executed simultaneously and the time required to complete a task can significantly reduce. In this subsection, we assess the ability of ChatGPT for making serial codes parallel. To this end, a simple serial C\texttt{++} code written by the first author (A. Kashefi) is given to ChatGPT. This code computes the maximum eigenvalue of a matrix using the method of power iteration as explained in Sect. \ref{Sect5}. 


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
\includegraphics[width=5mm]{aliGPT_red.png} Make my code parallel. The code is as follows:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{my_self_eigen_max.txt}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
\includegraphics[width=5mm]{gpt.png} To parallelize your code, you can use OpenMP, which is an API for parallel programming in C++. Here's a parallel version of your code using OpenMP:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{parallel.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
In the parallel version of your code, we use the \textbf{`\#pragma omp'} directives to specify which loops to parallelize.}
\end{tcolorbox}


This task is accomplished by ChatGPT; however, complicated and longer serial codes are necessary for testing the code parallelization capability of ChatGPT. 

\section{Failures and challenges of ChatGPT for programming}\label{Sect8}

\subsection{Singular matrices}\label{Sect81}


Let us reconsider the two-dimensional diffusion equation (see Eq. \ref{EqDif1}). We used the FTCS method \cite{hoffmann2000computational} to numerically solve it in Sect. \ref{Sect24}. Another numerical algorithm to solve this partial differential equation (Eq. \ref{EqDif1}) is the alternating direction implicit (ADI) method \cite{hoffmann2000computational}. The ADI method involves splitting the two-dimensional diffusion equation (Eq. \ref{EqDif1}) into two one-dimensional equations, one for each direction. The resulting equations are as follows


\begin{equation}
\frac{T_{i,j}^{n+\frac{1}{2}} - T_{i,j}^n}{\Delta t} = \frac{D}{2} \left( \frac{T_{i+1,j}^{n+\frac{1}{2}} - 2T_{i,j}^{n+\frac{1}{2}} + T_{i-1,j}^{n+\frac{1}{2}}}{\Delta x^2} + \frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\Delta y^2} \right) + s_{i,j}^{n},
\label{EqADI1}
\end{equation}


\begin{equation}
\frac{T_{i,j}^{n+1} - T_{i,j}^{n+\frac{1}{2}}}{\Delta t} = \frac{D}{2} \left( \frac{T_{i+1,j}^{n+\frac{1}{2}} - 2T_{i,j}^{n+\frac{1}{2}} + T_{i-1,j}^{n+\frac{1}{2}}}{\Delta x^2} + \frac{T_{i,j+1}^{n+1} - 2T_{i,j}^{n+1} + T_{i,j-1}^{n+1}}{\Delta y^2} \right)+ s_{i,j}^{n+\frac{1}{2}}.
\label{EqADI2}
\end{equation}
 At each time step, we first numerically solve Eq. \ref{EqADI1} for $T^{n+\frac{1}{2}}_{i,j}$, and in the second step, we solve Eq. \ref{EqADI2} for $T^{n+1}_{i,j}$. Now we ask ChatGPT to develop a Python code for solving the two-dimensional diffusion equation using the ADI method.

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Please write a Python code for solving the 2D diffusion equation using the Alternating-direction implicit (ADI) method.}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} 
Sure, here's a Python code for solving the 2D diffusion equation using the Alternating-direction implicit (ADI) method:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{ADI.txt}
\end{tcolorbox}

When we run the above code (generated by ChatGPT), we receive the error of ``LinAlgError: Singular matrix'' associated with line 36. In this case, we observe that the ADI algorithm is incorrectly implemented by ChatGPT, leading to a singular matrix (i.e., non-invertible). Line 36 of the above code is listed below as well.


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=Python]{ADI_1.txt}
\end{tcolorbox}

%\subsection{Broadcasting matrices with different shapes}\label{Sect82}

\subsection{Arrays with incompatible sizes}\label{Sect92}

%1D Euler, Python

As another important problem of computational physics, let us consider the two-dimensional incompressible viscous fluid flow \cite{brooks1982streamline,majda2002vorticity,panton2013incompressible,sussman1994level,hirsch2007numerical,stam1999stable,kashefi2020coarseA,kashefi2022coarseB} governed by the equations of conservation of mass and momentum written as follows

\begin{equation}
    \frac{\partial u}{\partial x} + \frac{\partial v}{\partial y} = 0,
    \label{NS1}
\end{equation}

\begin{equation}
   \rho \left(\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} + v\frac{\partial u}{\partial y}\right) = -\frac{\partial p}{\partial x} + \mu\left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right) + f_x,
   \label{NS2}
\end{equation}

\begin{equation}
    \rho \left(\frac{\partial v}{\partial t} + u\frac{\partial v}{\partial x} + v\frac{\partial v}{\partial y}\right) = -\frac{\partial p}{\partial y} + \mu\left(\frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2}\right) + f_y,
\label{NS3}
\end{equation}
where $u$ and $v$ are the velocity components in the $x$ and $y$ directions, respectively. The fluid density is shown by $\rho$. $p$ stands for the pressure and $\mu$ is the dynamic viscosity. $f_x$ and $f_y$ denote the external body forces acting in the $x$ and $y$ directions, respectively. The Reynolds number ($Re$), identifying flow characteristics, is defined as
\begin{equation}
    Re = \frac{\rho UL}{\mu},
    \label{Eq4}
\end{equation}
where $U$ and $L$ are respectively the characteristic velocity and length.


We ask ChatGPT to numerically solve the governing equations of the incompressible flow (Eqs. \ref{NS1}--\ref{NS3}) for the two-dimensional lid-driven cavity problem \cite{kim1985application} for the Reynolds number of $Re=100$.



\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a MATLAB code for solving the two-dimensional incompressible viscous flow. As a test case, use the lid-driven cavity problem for the Reynolds number of 100. Use a pressure correction scheme.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Here is a MATLAB code for solving the two-dimensional incompressible viscous flow using a pressure correction scheme, applied to the lid-driven cavity problem with Reynolds number 100 as a test case:}
\end{tcolorbox}

%We ask ChatGPT to write a numerical program for obtaining the solution to the Taylor-Green vortex problem, which is an exact analytic solution of the transient two-dimensional incompressible Navier-Stokes equations.  


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=MATLAB]{Ns_dimension.txt}
\end{tcolorbox}

When we run this MATLAB code, we receive the error ``Arrays have incompatible sizes for this operation'' in line 27 (div\_uv = U\_x + V\_y). In the case of requesting the code in Python (along with the Numpy library), We face the broadcasting issue, which is similar to the experience discussed above. Line 27 of the above code is listed below as well.


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=MATLAB]{Ns_dimension_1.txt}
\end{tcolorbox}

    
\subsection{Including unknown or unwanted libraries}\label{Sect83}


Based on our experiences, ChatGPT generates codes for executing numerical algorithms by including unknown or unwanted libraries in some cases. To demonstrate this fact to our audiences, we provide two examples in this subsection.



For the first example, we discuss the generalized minimal residual (GMRES) algorithm \cite{darve2021numerical,wendland2017numerical}. The GMRES algorithm is an iterative method for solving large, non-symmetric linear systems of $A \vec x = \vec b$. The GMRES methodology is based on the Krylov subspace methods. The GMRES algorithm might suffer from high computational and storage costs, specifically for large problems, since it requires storing all the basis vectors of the Krylov subspace. This issue is potentially alleviated by using restarted GMRES, called the GMRES(m) algorithm, which restarts the process after a fixed number of iterations, limiting the size of the Krylov subspace. We ask ChatGPT to write a C\texttt{++} code performing the GMRES methodology.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} 
Please write a C++ code for solving Ax=b, while A is a general sparse matrix, using the GMRES algorithm.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} 
Sure! Here's an example C++ code for solving Ax=b using the GMRES algorithm, where A is a general sparse matrix:}
\end{tcolorbox}

%%%%%%%%%%%

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{GMRES.txt}
\end{tcolorbox}

%%%%%%%%%%%

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont 
This code defines a sparse matrix \textbf{`A'}, a right-hand side vector \textbf{`b'}, and an initial guess for the solution vector \textbf{x}. It then uses the GMRES algorithm to solve the linear system \textbf{`Ax=b'}. The inner linear solver is set to BiCGSTAB with a tolerance of 1e-6. The outer linear solver is set to GMRES with a maximum of 1000 iterations and a tolerance of 1e-6. The preconditioner is set to the identity matrix. Finally, the solution vector \textbf{`x'} is printed to the console.}
\end{tcolorbox}

As can be seen in lines 2 and 3 of the above code, ChatGPT includes the ``Eigen'' library (i.e., <Eigen/Sparse> and <Eigen/IterativeLinearSolvers>) for coding the GMRES algorithm. In fact instead of writing the GMRES algorithm from scratch (as we expect), ChatGPT loads the GMRES solver from the Eigen library. This forces users to install the Eigen library and also reform the previously written matrices into an acceptable format for the Eigen library.



For the next example, we consider generating meshes for the finite-element method \cite{hughes2012finite,reddy2019introduction,kashefi2018finite,kashefi2020coarseC,geuzaine2009gmsh}. Finite-element mesh generation is a crucial step in the finite-element method. The process involves discretizing the domain of interest into smaller, simpler geometric elements (e.g., triangles). A well-designed mesh is essential for achieving convergence in the solution process. Poorly generated meshes might lead to incorrect solutions. The quality of the mesh directly affects the computational efficiency of the finite element analysis. A well-constructed mesh balances the need for accuracy with the demand for computational resources. Too few elements may result in low accuracy, while too many elements may result in excessive computation times and memory requirements. We request ChatGPT to develop a C\texttt{++} code for the finite element mesh generation.



\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a C++ code for generating triangular meshes that can be used for a finite element solver.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} 
Generating triangular meshes for a finite element solver in C++ involves the use of an external library. Here is an example code that uses the Triangle library to generate a triangular mesh for a square domain:}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{Mesh.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont
This code defines the domain as a square with corners \textbf{`(xmin, ymin)'} and \textbf{`(xmax, ymax)'}, and the mesh size as \textbf{`h'}. It then defines the input for the Triangle library using the \textbf{`triangulateio'} struct, which contains the coordinates of the points and segments. The points and segments are defined manually as an array of doubles and an array of integers, respectively.}
\end{tcolorbox}

As can be seen in line 5 of the above code, ChatGPT includes the ``triangle'' library (i.e., <triangle.h>). However, this library is unknown to us. Even by an online search, we cannot find this library and ChatGPT does not hint where we might find this library. Hence, in practice, the above code is useless.


\subsection{Refusing to write codes}\label{Sect84}

We discussed the two-dimensional unsteady Navier-Stokes and continuity equations (Eqs. \ref{NS1}--\ref{NS3}) for incompressible flow in Sect. \ref{Sect92}. Let us reconsider this problem. We ask ChatGPT to develop a code for solving the continuity and Navier-Stokes equations (Eqs. \ref{NS1}--\ref{NS3}).


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Write a MATLAB code for solving the 2D Navier-Stokes equations. Specifically, use a pressure projection scheme. For the intermediate velocity, use an implicit time integration. As a test case, solve the Taylor-Green vortex problem with the Dirichlet boundary conditions that read the exact solution.}
\end{tcolorbox}


\begin{tcolorbox}[breakable, enhanced]
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} As an AI language model, I cannot generate executable code. However, I can provide the basic structure of the code that can be used as a starting point for implementing the pressure projection scheme in MATLAB for solving the 2D Navier-Stokes equations.

The code would involve the following steps:

\begin{enumerate}
   
 \item Define the domain and discretization grid.
 \item  Initialize the velocity and pressure fields.
 \item  Define the time step and simulation time.
 \item  Loop over the time steps.
 \item  Solve for the intermediate velocity using an implicit time integration method (e.g. backward Euler).
 \item Solve for the pressure using the pressure projection scheme.
 \item Correct the velocity field with the pressure.
 \item Apply boundary conditions.
 \item Output the results.
\end{enumerate}

The following is an outline of the MATLAB code:

}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=MATLAB]{Matlab_outLine.txt}
\end{tcolorbox}

As can be seen from this example, ChatGPT refuses to write the requested code. However, our experiments show that this is not the case always. If we retype the same question in the chat box or reword our request, ChatGPT will eventually start writing a complete code for the requested numerical algorithm.

\subsection{Server disconnection for programming long codes}\label{Sect85}

According to our experiments, when we ask ChatGPT to produce codes for more realistic and more challenging numerical problems, where the size of required codes is usually large (i.e., many lines), a server disconnection or server interruption happens. We show this reality by an example. Let us reconsider the continuity and Navier-Stokes equations (see Eqs. \ref{NS1}--\ref{NS3}) we discussed in Sect. \ref{Sect92}.


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Please develop a C++ code for numerically solving the 2D incompressible flow. Use a pressure projection scheme. Consider the 2D Taylor-Green vortex with periodic boundary conditions as a test case.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Sure, here's an example code for numerically solving the 2D incompressible flow using a pressure projection scheme in C++. The code uses a finite difference method with a staggered grid and solves for the velocity and pressure fields in each time step. The test case is the 2D Taylor-Green vortex with periodic boundary conditions.}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{NS_CPlus1.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Please continue coding, you stopped.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Apologies for that. Here's the rest of the code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{NS_CPlus2.txt}
\end{tcolorbox}

\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Again you stopped. Please write the rest of the code.}
\end{tcolorbox}


\begin{tcolorbox}
{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Apologies again for the inconvenience. Here's the rest of the code:}
\end{tcolorbox}

\begin{tcolorbox}[breakable, enhanced]
\lstinputlisting[language=C++]{NS_CPlus3.txt}
\end{tcolorbox}


%\begin{tcolorbox}
%{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{aliGPT_red.png} Please write the rest of the code in the main function}
%\end{tcolorbox}


%\begin{tcolorbox}
%{\fontfamily{lmss}\selectfont \includegraphics[width=5mm]{gpt.png} Apologies for the mistake earlier. Here's the complete code with the main function:}
%\end{tcolorbox}

As can be seen through this example, ChatGPT stops responding for producing relatively long codes. After each interruption, we ask ChatGPT to continue coding; however, this process is frustrating. Moreover, although it seems that ChatGPT tries to complete the rest of the code generated from the previous part, ChatGPT misses some intermediate codes in practice. For example, in the above example, ChatGPT stopped coding the section associated with ``Set boundary conditions for u\_star''. After we asked it to continue coding, ChatGPT started coding the new section of ``Solve tridiagonal system for u\_star''. At least for this case, we could not eventually get a full C\texttt{++} code from ChatGPT for solving the two-dimensional incompressible flow and the mission failed.


%\subsection{Other issues}\label{Sect86}

%Poisson example, variable 'b'! a function is not defined ... 

\subsection{Default version versus plus version of ChatGPT}\label{Sect86}

There is a possibility for users to upgrade ChatGPT to its ``plus'' version with the cost of \$20 per month subscription. However, we observe all the above-mentioned issues and failures even with the plus version of ChatGPT. 

\section{Summary}\label{Sect9}

The most important messages of this technical report are summarized as follows. We demonstrate that using ChatGPT (provided by OpenAI), one can:


\begin{itemize}
\item Generate codes for implementing numerical algorithms in different programming languages such as C, C\texttt{++}, Python, MATLAB, Julia, etc; with specifying details such as boundary and initial conditions for partial differential equations

\item Debug codes, improve code efficiency and complete incomplete codes of numerical methods

\item Making C\texttt{++} codes parallel using OpenMP

\item Rewriting a given code in a different programming language

\item
\end{itemize}



Additionally, the most important limitations and challenges of using ChatGPT for programming numerical algorithms discussed in this technical report are be listed as follows:

\begin{itemize}
    \item Generating singular matrices (non-invertible) 
    
    \item Producing arrays with incompatible sizes and shapes
    
    \item Irregular interruption for generating long codes, which are usually required for important and serious scientific simulations 
    
    \item Including unknown libraries
    
    \item The lack of ability to recognize if a code is generated by humans or by itself (i.e., ChatGPT)
    
\end{itemize}


We plan to update this technical report on new findings. Additionally, we investigate the ChatGPT capacity for implementing other important numerical algorithms such as level set methods \cite{osher2004level,sethian1999level,osher2001level}, spectral methods \cite{canuto2007spectral}, the smoothed particle hydrodynamics (SPH) method \cite{violeau2012fluid}, point-cloud deep learning methodologies for computational mechanics \cite{kashefi2021point,kashefi2021pointPorous,qi2017pointnet++,qi2017pointnet}, the discontinuous Galerkin method \cite{cockburn2012discontinuous,farhat2001discontinuous}, etc.



\section{Code availability}\label{Sect10}


All the codes (including correct, incomplete, and buggy ones) are available on the following GitHub repository: \url{https://github.com/Ali-Stanford/ChatGPT_Programming_Numerical_Methods} 



%\bibliographystyle{johd}
\bibliographystyle{plain}
%\bibliographystyle{siam}
\bibliography{bib}


\end{document}