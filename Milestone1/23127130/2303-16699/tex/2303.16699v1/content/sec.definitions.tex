Fix a finite set~$\ap$ of atomic propositions. A \emph{trace} over $\ap$ is a map $t \colon \nats \rightarrow \pow{\ap}$, denoted by $t(0)t(1)t(2) \cdots$. 
It is \emph{ultimately periodic}, if $t = x \cdot y^\omega$ for some $x,y \in (\pow{\ap})^+$, i.e.\ there are $s,p>0$ with $t(n) = t(n+p)$ for all $n \ge s$.
The set of all traces over $\ap$ is  $(\pow{\ap})^\omega$. 

A transition system~$\tsys = (V,E,v_\initmark, \lambda)$ consists of a set~$V$ of vertices, a set~$E \subseteq V \times V$ of (directed) edges, an initial vertex~$v_\initmark \in V$, and a labelling~$\lambda\colon V \rightarrow \pow{\ap}$ of the vertices by sets of atomic propositions. A path~$\rho$ through~$\tsys$ is an infinite sequence~$\rho(0)\rho(1)\rho(2)\cdots$ of vertices with $(\rho(n),\rho(n+1))\in E$ for every $n \ge 0$.
The trace of $\rho$ is defined as $\lambda(\rho(0))\lambda(\rho(1))\lambda(\rho(2))\cdots$.

\subsection{\hyltl}

The formulas of \hyltl are given by the grammar
\[
\phi  {} \cceq {}  \exists \pi.\ \phi \mid \forall \pi.\ \phi \mid \psi \qquad\qquad
\psi {}  \cceq {}  a_\pi \mid \neg \psi \mid \psi \vee \psi \mid \X \psi \mid \psi \U \psi
\]
where $a$ ranges over atomic propositions in $\ap$ and where $\pi$ ranges over a fixed countable set~$\var$ of \emph{(trace) variables}. Conjunction, implication, and equivalence are defined as usual, and the temporal operators eventually~$\F$ and always~$\G$ are derived as $\F\psi = \neg \psi\U \psi$ and $\G \psi = \neg \F \neg \psi$. A \emph{sentence} is a  formula without free variables.

The semantics of \hyltl is defined with respect to a \emph{trace assignment}, a partial mapping~$\Pi \colon \var \rightarrow (\pow{\ap})^\omega$. The assignment with empty domain is denoted by $\Pi_\emptyset$. Given a trace assignment~$\Pi$, a variable~$\pi$, and a trace~$t$ we denote by $\Pi[\pi \rightarrow t]$ the assignment that coincides with $\Pi$ everywhere but at $\pi$, which is mapped to $t$. 
Furthermore, $\suffix{\Pi}{j}$ denotes the trace assignment mapping every $\pi$ in $\Pi$'s domain to $\Pi(\pi)(j)\Pi(\pi)(j+1)\Pi(\pi)(j+2) \cdots $, its suffix from position $j$ onwards.

For sets~$T$ of traces and trace assignments~$\Pi$ we define 
\begin{itemize}
	\item $(T, \Pi) \models a_\pi$ if $a \in \Pi(\pi)(0)$,
	\item $(T, \Pi) \models \neg \psi$ if $(T, \Pi) \not\models \psi$,
	\item $(T, \Pi) \models \psi_1 \vee \psi_2 $ if $(T, \Pi) \models \psi_1$ or $(T, \Pi) \models \psi_2$,
	\item $(T, \Pi) \models \X \psi$ if $(T,\suffix{\Pi}{1}) \models \psi$,
	\item $(T, \Pi) \models \psi_1 \U \psi_2$ if there is a $j \ge 0$ such that $(T,\suffix{\Pi}{j}) \models \psi_2$ and for all $0 \le j' < j$: $(T,\suffix{\Pi}{j'}) \models \psi_1$, 
	\item $(T, \Pi) \models \exists \pi.\ \phi$ if there exists a trace~$t \in T$ such that $(T,\Pi[\pi \rightarrow t]) \models \phi$, and 
	\item $(T, \Pi) \models \forall \pi.\ \phi$ if for all traces~$t \in T$: $(T,\Pi[\pi \rightarrow t]) \models \phi$. 
\end{itemize}
We say that $T$ \emph{satisfies} a sentence~$\phi$ if $(T, \Pi_\emptyset) \models \phi$. In this case, we write $T \models \phi$ and say that $T$ is a \emph{model} of $\phi$. 
Two \hyltl sentences~$\varphi$ and $\varphi'$ are equivalent if $T \models \varphi$ if and only if $T \models \varphi'$ for every set~$T$ of traces.
Although \hyltl sentences are required to be in prenex normal form, they are closed under Boolean combinations, which can easily be seen by transforming such a formula into an equivalent formula in prenex normal form. 

\subsection{\hyctlstar.}

The formulas of \hyctlstar are given by the grammar
\begin{align*}
\phi & {} \cceq {} a_\pi \mid \neg \phi \mid \phi \vee \phi \mid \X \phi \mid \phi \U \phi \mid \exists \pi.\ \phi \mid \forall \pi.\ \phi
\end{align*}
where $a$ ranges over atomic propositions in $\ap$ and where $\pi$ ranges over a fixed countable set~$\var$ of \emph{(path) variables}, and where we require that each temporal operator appears in the scope of a path quantifier. Again, other Boolean connectives and temporal operators are derived as usual.
Sentences are formulas without free variables.

Let $\tsys$ be a transition system. The semantics of \hyctlstar is defined with respect to a \emph{path assignment}, a partial mapping~$\Pi$ from variables in $\var$ to paths of $\tsys$. The assignment with empty domain is denoted by $\Pi_\emptyset$. Given a path assignment~$\Pi$, a variable~$\pi$, and a path~$\rho$ we denote by $\Pi[\pi \rightarrow \rho]$ the assignment that coincides with $\Pi$ everywhere but at $\pi$, which is mapped to $\rho$. 
Furthermore, $\suffix{\Pi}{j}$ denotes the path assignment mapping every $\pi$ in $\Pi$'s domain to $\Pi(\pi)(j)\Pi(\pi)(j+1)\Pi(\pi)(j+2) \cdots $, its suffix from position $j$ onwards.

 For transition systems~$\tsys$ and path assignments~$\Pi$ we define 
\begin{itemize}
	\item $(\tsys, \Pi) \models a_\pi$ if $a \in \lambda(\Pi(\pi)(0))$, where $\lambda$ is the labelling function of $\tsys$,
	\item $(\tsys, \Pi) \models \neg \psi$ if $(\tsys, \Pi) \not\models \psi$,
	\item $(\tsys, \Pi) \models \psi_1 \vee \psi_2 $ if $(\tsys, \Pi) \models \psi_1$ or $(\tsys, \Pi) \models \psi_2$,
	\item $(\tsys, \Pi) \models \X \psi$ if $(\tsys,\suffix{\Pi}{1}) \models \psi$,
	\item $(\tsys, \Pi) \models \psi_1 \U \psi_2$ if there exists a $j \ge 0$ such that $(\tsys,\suffix{\Pi}{j}) \models \psi_2$ and for all $0 \le j' < j$: $(\tsys,\suffix{\Pi}{j'}) \models \psi_1$, 
	\item $(\tsys, \Pi) \models \exists \pi.\ \phi$ if there exists a path~$\rho$ of $\tsys$, starting in $\last(\Pi)$, such that $(\tsys,\Pi[\pi \rightarrow \rho]) \models \phi$, and 
	\item $(\tsys, \Pi) \models \forall \pi.\ \phi$ if for all paths~$\rho$ of $\tsys$ starting in $\last(\Pi)$: $(\tsys,\Pi[\pi \rightarrow \rho]) \models \phi$. 
\end{itemize}
Here, $\last(\Pi)$ is the initial vertex of $\Pi(\pi)$, where $\pi$ is the path variable most recently added to or changed in $\Pi$, and the initial vertex of $\tsys$ if $\Pi$ is empty.\footnote{For the sake of simplicity, we refrain from formalising this notion properly, which would require to keep track of the order in which variables are added to or changed in $\Pi$.}
We say that $\tsys$ \emph{satisfies} a sentence~$\phi$ if $(\tsys, \Pi_\emptyset) \models \phi$. In this case, we write $\tsys \models \phi$ and say that $\tsys$ is a \emph{model} of $\phi$. 

\subsection{Complexity Classes for Undecidable Problems.}
A type~$0$ object is a natural number~$n \in \nats$, a type~$1$ object is a function $f \colon \nats \rightarrow \nats$, and a type~$2$ object is a function~$f\colon (\nats \rightarrow \nats) \rightarrow \nats$.
As usual, predicate logic with quantification over type~$0$ objects (first-order quantifiers) is called first-order logic.
Second- and third-order logic are defined similarly.

We consider formulas of arithmetic, i.e.\ predicate logic with signature~$(0,1, +, \cdot, <)$ evaluated over the natural numbers. With a single free variable of type~$0$, such formulas define sets of natural numbers (see, e.g.\ Rogers~\cite{Rogers87} for more details):
\begin{itemize}
	\item $\Sigma_1^0$ contains the sets of the form $\set{x \in \nats \mid \exists x_0.\  \cdots \exists x_k.\ \psi(x, x_0, \ldots, x_k)}$ where $\psi$ is a quantifier-free arithmetic formula and the $x_i$ are variables of type~$0$. 
	\item $\Sigma_1^1$ contains the sets of the form $\set{x \in \nats \mid \exists x_0.\  \cdots \exists x_k.\ \psi(x, x_0, \ldots, x_k)}$ where $\psi$ is an arithmetic formula with arbitrary (existential and universal) quantification over type~$0$ objects and the $x_i$ are variables of type~$1$. 
	\item $\Sigma_1^2$ contains the sets of the form $\set{x \in \nats \mid \exists x_0.\  \cdots \exists x_k.\ \psi(x, x_0, \ldots, x_k)}$ where $\psi$ is an arithmetic formula with arbitrary (existential and universal) quantification over type~$0$ and type~$1$ objects and the $x_i$ are variables of type~$2$.
\end{itemize}
Note that there is a bijection between functions of the form~$f\colon \nats\rightarrow \nats$ and subsets of $\nats$, which is implementable in  arithmetic. 
Similarly, there is a bijection between functions of the form~$f \colon (\nats \rightarrow \nats)\rightarrow\nats$ and subsets of $\pow{\nats}$, which is again implementable in arithmetic.
Thus, whenever convenient, we use quantification over sets of natural numbers and over sets of sets of natural numbers, instead of quantification over type~$1$ and type~$2$ objects; in particular when proving lower bounds. We then include $\in$ in the signature. 

Also, note that $0$ and $1$ are definable in first-order arithmetic. 
Thus, whenever convenient, we drop $0$ and $1$ from the signature of arithmetic.
In the same vein, every fixed natural number is definable in first-order arithmetic.





