% !TeX spellcheck = en_GB
% encoding: utf8
% !TEX encoding = utf8
% !TEX program = pdflatex

\documentclass{ieeetran}

\usepackage[cmex10]{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{bm}
%\usepackage{plotstable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage[linesnumbered,ruled,vlined,onelanguage]{algorithm2e}
\usepackage{algorithmic}
\usepackage{mathtools}
%\usepackage[]{algorithmic}
\usepackage{array}

\usepackage{array}
\usepackage{makecell}
\usepackage{csvsimple}
\usepackage{booktabs}
\usepackage{xargs}
%\usepackage{color, colortbl}
\usepackage{footmisc}

\usepackage{ifthen}

% % %
% BibTeX styles
\bibliographystyle{IEEEtran}


%%%%%
%%  Comments 
%%%%%
\usepackage{xargs}



\newcommand{\fig}[1]{fig.~\ref{#1}}
\newcommand{\Fig}[1]{Fig.~\ref{#1}}

\usepackage{fourier} 
\usepackage{array}
\usepackage{makecell}
\usepackage{csvsimple}
\usepackage{booktabs}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\usepackage{tabularx}
% compiler error without following two lines
\usepackage{caption,setspace}
%\captionsetup{font={sf,small,stretch=0.80},labelfont={bf,color=accessblue}}
%\usepackage{soul}
\usepackage{xargs}


\usepackage{hyperref} %<--- Load after everything else

%%%%%
%%   Definicja wymagań
%%%%
\newcommand{\req}[1]{\textbf{\texttt{R#1}}}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{//#1\\}}
\begin{document}
	
	\title{MeROS: SysML-based Metamodel for ROS-based Systems}
	%\title{Harmonizing complex tasks for robots with the TaskER framework}
	
	\author{Tomasz Winiarski$^{1}$, Member, IEEE
	\thanks{$^{1}$Warsaw University of Technology, Institute of Control and Computation Engineering, Poland
			{\tt\small tomasz.winiarski@pw.edu.pl}
	}}
	
		\maketitle
	
	\begin{abstract}
		The complexity of today's robot control systems implies difficulty in developing them efficiently and reliably. Systems engineering (SE) and frameworks come to help. The framework metamodels are needed to support the standardisation and correctness of the created application models. Although the use of frameworks is widespread nowadays, for the most popular of them, Robot Operating System (ROS) version 1, a contemporary metamodel, has been missing so far. This article proposes a new metamodel for ROS (MeROS), which addresses both the running system and developer workspace. For compatibility with the latest versions of ROS 1, the metamodel includes the latest ROS 1 concepts such as nodelet, action, and metapackage. An essential addition to the original ROS concepts is the grouping concepts, which provide an opportunity to illustrate the decomposition of the system, as well as varying degrees of detail in its presentation. The metamodel is derived from the requirements and then verified on the practical example of the Rico assistive robot. The matter is described in the SysML language, supported by standard development tools to conduct projects in the spirit of SE.
	\end{abstract}
	


\section{Introduction}
\label{sec:intro}	


The development of civilisation leads to an increase in the importance of robotics. In particular, it is determined by demographic changes, but also by the race for technological supremacy. Many modern robotic systems are complex. To create them as effectively and reliably as possible, it is necessary to follow systems engineering (SE), where metamodels play an essential role~\cite{bezivin2004search,schmidt2006model,kent2002model}.

Robots, especially complex ones, are mostly software-controlled. Hence, in robotics SE is inextricably linked with software engineering, where the use of frameworks has been crucial for many years \cite{mnkandla2009software,shehory2014agent}.
Many robotics frameworks have been developed so far \cite{inigo2012robotics,tsardoulias2017robotic,hentout2016survey}. Some steps towards standardisation have been made in the recent years, and ROS (Robot Operating System) has come to the fore. Stand-alone ROS~1 (ROS version~1)~\cite{quigley2009ros} is unsuitable for hard RT (Real Time) systems, so one of the solutions in practical applications (e.g., \cite{lages2014architecture,buys2011haptic,pages2016tiago,Seredynski-fabric-romoco-2019,kornuta-bpan-2020,cholewinski2015software}), is to integrate ROS~1 with Orocos \cite{bruyninckx2001open,bruyninckx2002orocos}. Over time, ROS~1 has evolved to, among other things, improve its performance. Known and crucial problems in the face of some contemporary applications (e.g. cybersecurity, RT performance) led to the development of a~new version of the framework, ROS~2 \cite{maruyama2016exploring,park2020real}.   


According to~analyses of ROS metrics from~July 2022\footnote{\url{https://discourse.ros.org/t/2022-ros-metrics-report/29594}}, interest in ROS was growing, and~though the ROS~2 version was gaining popularity, ROS~1 was still more popular than ROS~2, even in terms of new package downloads, not to mention~existing applications.
ROS~1 has evolved considerably from the initial distributions. Its metamodels that were created so far are now incomplete and outdated (sec.~\ref{sec:related-work}). According to ROS metrics, new ROS~1 distributions have practically replaced older one's, which lacked elements such as actions or nodelets. These indications point to the need to formulate an up-to-date, recent ROS~1 metamodel, which this article undertakes by presenting the new metamodel for ROS -- MeROS.

ROS 2 has significant advantages over ROS 1. Nevertheless, choosing the right version of the framework to conduct the works is not obvious. The problem is complex, nevertheless some important aspects can be identified. These aspects are inseparable. In the following, control systems development use cases are distinguished, were usage of ROS~1 is still justified. 

[UC1] Existing ROS~1 systems.
\begin{itemize}
	\item $[$UC1.1] The system works correctly and there is no need to migrate. The advantages of ROS~2 have no material significance. No hardware changes are planned that would hinder the continued use of ROS~1.
	\item $[$UC1.2] Some components closely associated with or created in ROS~1 may be created by the manufacturer of the equipment and migration may be difficult or impossible at some stage. Despite this, the equipment continues to be operated and its control system is expanded.
	\item $[$UC1.3] The system is very complex and its migration requires a significant investment in time and money.
\end{itemize}

[UC2] Newly developed control systems.
\begin{itemize}
	\item $[$UC2.1] Existing ROS~1 packages that are missing or underdeveloped in ROS~2 are used. The advantages of ROS~2 do not determine the need for migration.
	\item $[$UC2.2] The competences of the development team and the infrastructure (operating systems, etc.) prompt the usage of ROS~1.
\end{itemize}


Naturally, a number of other aspects come into play, including among the important ones.
\begin{itemize}
	\item ROS~2 comes only with versions with multi-year support from 2020 onwards\footnote{\url{https://docs.ros.org/en/rolling/Releases.html}}. In particular, there are still a number of known bugs that may call its use into question.
	\item On the other hand, support for ROS~1 expires (May 2025 for ROS~1 Noetic \footnote{\url{http://wiki.ros.org/Distributions}}) and as time goes on, more and more problematic use is to be expected.
	\item Hybrid systems can be created (e.g., \cite{ginting2021chord}).
\end{itemize}

MeROS is a metamodel that standardises the way of modelling for systems based on ROS~1. It is founded on SysML, a profile of UML. Modelling in languages from the UML family addresses a number of important aspects of systems engineering\cite{chaudron2012effective}. These include:
\begin{itemize}
	\item $[$UC3.1] Systems documentation,
	\item $[$UC3.2] Systems presentation,
	\item $[$UC3.3] Analysis in interdisciplinary teams (graphical language is more understandable for non-specialists in the field), 
	\item $[$UC3.4] Defects detection,
	\item $[$UC3.5] Integration of new collaborators into the development team,
	\item $[$UC3.6] Resuming to work after the break,
	\item $[$UC3.7] Extension and modification of existing systems,
	\item $[$UC3.8] Creation of a project for the implementation of new systems,
	\item $[$UC3.9] migration of systems, in the case of MeROS -- from ROS~1 to ROS~2.   
\end{itemize}

In practice, documentation is created both prior to implementation and in many cases through a process of backward invention \cite{canfora2007new} for existing systems. Agile-type strategies involve modifying the documentation as the project develops\cite{habib2021systematic}.

The robotic models can be subdivided~\cite{de2021survey} into Platform Independent Models (PIM), e.g., \cite{zielinski2017variable,zielinski2010motion,tasker2020,earl2020}, and Platform Specific Models (PSM). The metamodels of ROS, including MeROS, belong to PSM and should answer to the component nature of ROS \cite{Figat:2022:RAS,wenger2016model}. It is convenient to use a~standardized language to describe the model. Hence, in this work, the Systems Modelling Language (SysML) \cite{omg-sysml16,Friedenthal:2015} is chosen as it is a~standard in SE.

The following presentation starts from formulating of the requirements (sec.~\ref{sec:requirements}) for the MeROS metamodel. These requirements are allocated to the metamodel that is described in sec.~\ref{sec:metamodel}. The way to present a~model of a~specific application based on MeROS is presented on practical example in sec.~\ref{sec:application}.
A comparison of the MeROS with similar metamodels is presented in sec.~\ref{sec:related-work}. The paper is finalized with conclusions (sec.~\ref{sec:conslusions}).


\section{Metamodel requirements}
\label{sec:requirements}

The requirements formulation process for MeROS metamodel is multi-stage and iterative. In the beginning, the initial requirements were formulated based on: (i) literature review (both scientific and ROS wiki/community sources), (ii) author experience from supervising and supporting ROS-based projects, and finally, (iii) author experience from EARL \cite{earl2020} PIM development and its applications (e.g. \cite{tasker2020,karwowski2021hubero,en14206693-grav-comp}). Verification of draft versions of MeROS by its practical applications led to an iterative reformulation of requirements and MeROS itself. The article presents the final version of both MeROS metamodel and the requirements it originates from.

MeROS requirements are depicted on a~number of dedicated SysML diagrams. The requirements are organised in a~tree-like nesting structure, with additional internal relations, and labelled following this structure. The general requirements are presented in Fig.~\ref{fig:general_req}.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/general_req.png}}
	\end{center}
	\caption{General requirements.} 
	\label{fig:general_req}
\end{figure}


The SysML models have two main parts: behavioural [R1] and structural [R2]. The goal of MeROS is to cover ROS concepts [R3] and not change theirs labels as long as possible, to maintain conformity and intuitiveness. The ROS system is two-faced. While it is executed [R4], it has a~specific structure and behaviour, but from the developers' point of view, the workspace [R5] is the exposed aspect. The model should be compact and simple [R6] rather than unnecessarily elaborate and complicated. One of the assumptions that stands out MeROS from other ROS metamodels is conformity with the latest ROS~1 versions [R7]. Although the SysML-based MeROS is classified into PSM [R8], i.e., Platform Specific Models, it should be compatible with Non-ROS elements [R9].

The structural aspects requirements are presented in Fig.~\ref{fig:structural_aspects_req}.
A~vital addition to the original ROS concepts is the grouping of communicating methods [R2.1] and communicating components [R2.2]. The motivation is presented further on.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/structural_aspects_req.png}}
	\end{center}
	\caption{Structural aspects requirements.} 
	\label{fig:structural_aspects_req}
\end{figure}



The ROS concepts that MeROS models are grouped into four major classes (Fig.~\ref{fig:ros_concepts_req}): Communicating components [R3.1], Communication methods [R3.2], Workspace [R3.3], and Other [R3.4].

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.95\columnwidth]{img/requirement_pkg/original_ros_concepts_req.png}}
	\end{center}
	\caption{ROS concepts requirements.} 
	\label{fig:ros_concepts_req}
\end{figure}

Communicating components (Fig.~\ref{fig:communicating_components_req}) are: ROS Node [R3.1.1], ROS Nodelet [R3.1.2], ROS plugin [R3.1.3], and ROS library [R3.1.4]. Both plugin and library let to share the same code between various Nodes or Nodelets. The system demands two particular Nodes: ROS Master [R3.1.1.1] and rosout [R3.1.1.2].

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.95\columnwidth]{img/requirement_pkg/communicating_components_req.png}}
	\end{center}
	\caption{Communicating components requirements.} 
	\label{fig:communicating_components_req}
\end{figure}

Communication methods (Fig.~\ref{fig:communication_concepts_req}) cover three methods of  communication and relate two inter-component connections and data structures: ROS Topic [R3.2.1] with its Message [R3.2.1.1] and connection [R3.2.1.2], ROS Service [R3.2.2] comprising data structure [R3.2.2.1] and connection [R3.2.2.2], and finally ROS Action [R3.2.3] including data structure [R3.2.3.1] and connection [R3.2.3.2].

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/communication_concepts_req.png}}
	\end{center}
	\caption{Communication concepts requirements.} 
	\label{fig:communication_concepts_req}
\end{figure}


Workspace concepts (Fig.~\ref{fig:workspace_concepts_req}) comprises ROS Package [R3.3.1] and Metapackage [R3.3.2] introduced in latest version of ROS~1.


\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/workspace_concepts_req.png}}
	\end{center}
	\caption{Workspace concepts requirements.} 
	\label{fig:workspace_concepts_req}
\end{figure}

Other concepts [R3.4] depicted in Fig.~\ref{fig:other_concepts_req} include four elements. ROS Parameter Server [R3.4.1] manages ROS Parameters [3.4.2], roscore [R3.4.3] forms a collection of programs and nodes that are pre-requisites of a ROS~1-based system. Finally, ROS Namespace [R3.4.4] reflects the ROS concepts to organize namespaces.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/other_concepts_req.png}}
	\end{center}
	\caption{ROS other concepts requirements.} 
	\label{fig:other_concepts_req}
\end{figure}

Fig.~\ref{fig:roscore_req} presents additional, roscore related relations. Both ROS Master and rosout are executed with roscore [R3.4.3]. ROS Parameter Server is a part of ROS Master.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/roscore_mm_req.png}}
	\end{center}
	\caption{roscore related requirements dependences.} 
	\label{fig:roscore_req}
\end{figure}


To achieve intuitiveness MeROS presents Running system structure (Fig.~\ref{fig:running_system_req}) following rqt\_graph pattern [R4.1]. In particular, there are two ways to present communication, including [R4.1.1]
%	\footnote{exemplary graph \url{https://github.com/siemens/ros-sharp/issues/174}}
and without [R4.1.2]
% \footnote{exemplary graph \url{https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html}}
dedicated communication components. The dedicated components are especially useful in the presentation when many communication components use the same topic both on the publisher and the subscribe side. In opposition, the expression of topics names on arrows connecting communicating components, i.e., without dedicated communication components, let to reduce the number of components needed to depict communication for many topics and a~low number of communicating components. The other advantage of usage of dedicated communication components is that the particular connection can be split into several diagrams (e.g. ibd or sd), where the same object represents this connection in every associated diagram. Services [R4.2] and actions [R4.3] should be depicted as an addition to the presentation of the particular topics. It should be noted that rqt\_graph represents actions as a~number of topics. In MeROS the topics executing an action are aggregated, that reduces the number of depicted connections.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/requirement_pkg/running_system_req.png}}
	\end{center}
	\caption{Running system requirements.} 
	\label{fig:running_system_req}
\end{figure}

The compactness and simplicity [R6] and its nesting requirements are presented in Fig.~\ref{fig:compactness_and_simplicity_req}. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.9\columnwidth]{img/requirement_pkg/compactness_and_simplicity_req.png}}
	\end{center}
	\caption{Compactness and simplicity requirements.} 
	\label{fig:compactness_and_simplicity_req}
\end{figure}

A SysML project to develop and represent MeROS metamodel should consist of a~small number of packages [R6.1], but still, the packages should distinguish the major aspects of development: (i) metamodel requirements formulation, (ii) metamodel itself, and (iii) metamodel realizations/applications.
Dedicated SysML stereotypes [R6.2] are introduced to MeROS to replace the direct block specialization representation on diagrams and improve the legibility and compactness of diagrams.
The grouping of concepts [R6.3] has diverse aims. It enables presentation of a~system part in a~general, PIM like abstract way, on the logical level rather than a~detailed, PSM like implementation one. The aggregation reduces the number of objects represented on the diagram, to highlight the essential aspects, and stay compact and consisten t in presentation.
The number of SysML blocks should be reduced to the reasonable level [R6.4]. Both [R6.1] and [R6.4] help to in Avoidance of unnecessary mapping of SysML blocks [R6.5].

There are three elements in the requirements set that satisfy the specifics of latest ROS~1 versions (Fig.~\ref{fig:recent_ros_version_req}): ROS Nodelet [R3.1.2] (introduced primarily to increase efficiency of ROS components switching), ROS Action [R3.2.3], and ROS Metapackage [R3.3.2].

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.9\columnwidth]{img/requirement_pkg/recent_ros_version_req.png}}
	\end{center}
	\caption{Latest ROS 1 version requirements.} 
	\label{fig:recent_ros_version_req}
\end{figure}



\section{MeROS metamodel}
\label{sec:metamodel}

MeROS metamodel is formulated according to the requirements [RX] discussed in the previous section. Sec.~\ref{sec:metamodel-composition} presents MeROS blocks structural composition, sec.~\ref{sec:metamodel-communication} describes inter-component communication. From the metamodel perspective, the structural aspects [R2] are formulated in both sections, while behavioural [R1] in the latter.
The diagrams comprise selected requirements being allocated to expose the MeROS metamodel development process. 

The MeROS diagrams were created in the Enterprise Architect development tool within the SysML project [R8] organised in three packages [R6.1] (Fig.~\ref{fig:meros_project_packages_pkg}): (i) Requirement Model related to requirements formulation and analysis, (ii) MeROS -- the metamodel itself, (iii) Rico Controller -- the exemplary application of MeROS. The stereotypes are introduced in MeROS metamodel with the dedicated MeROS profile [R6.2].

\begin{figure}[H]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_project_packages_pkg.png}}
	\end{center}
	\caption{MeROS project packages, where Rico Controller is an exemplary realisation of MeROS metamodel.} 
	\label{fig:meros_project_packages_pkg}
\end{figure}

\subsection{Metamodel composition}
\label{sec:metamodel-composition}

The degree of specificity of a metamodel is a compromise between its universality (and therefore more general formulation) and a more accurate representation of a certain subclass of specific implementations. The metamodel contains compositions of elements and major other relationships. Attributes and operations can range widely, hence their inclusion would lead to overgrowth and complication of the metamodel [R6]. Naturally, models derived from the metamodel can define their operations as well as new relations specific to a particular system. 

The SysML blocks reflect ROS concepts [R3], and their composition is depicted in bdd (block definition) diagrams. The metamodel is formulated in a~single package. Hence, Workspaces and Running Systems are composed into ROS System (Fig.~\ref{fig:ros_system_bdd}). Consequently, some concepts (e.g., Node) occur both in Workspaces and Running Systems. It reduces the number of SysML blocks in the metamodel [R6.4] and eliminates the need of unnecessary mapping 
of SysML blocks [R6.5].

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.85\columnwidth]{img/meros_pkg/ros_system_bdd.png}}
	\end{center}
	\caption{ROS system general composition -- bdd.} 
	\label{fig:ros_system_bdd}
\end{figure}

In MeROS, a~Communicating Component (Fig.~\ref{fig:communicating_components_bdd}) is a~crucial abstraction of a~number of ROS concepts to represent their standardized role regarding communication. It should be noted that behavioural aspects of a~particular model specified in MeROS can be formulated by operation specification as an act (activity), sd (sequence), or stm (state machine) diagrams. The Intrasystem is one of the aggregates added to the base ROS concepts in MeROS. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.85\columnwidth]{img/meros_pkg/communicating_components_inherit_bdd.png}}
	\end{center}
	\caption{Communicating Component and specialised blocks -- bdd.} 
	\label{fig:communicating_components_bdd}
\end{figure}

Relations of Communicating Components are depicted in Fig.~\ref{fig:communication_blocks_bdd} and Fig.~\ref{fig:communication_blocks2_bdd}. 


\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.9\columnwidth]{img/meros_pkg/communicating_component_bdd.png}}
	\end{center}
	\caption{Communicating Component relations -- topics and actions -- bdd.} 
	\label{fig:communication_blocks_bdd}
\end{figure}

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/communicating_component2_bdd.png}}
	\end{center}
	\caption{Communicating Component relations -- services, aggregates, Non-ROS elements -- bdd.} 
	\label{fig:communication_blocks2_bdd}
\end{figure}

Besides standard ROS communication methods, the Non-ROS are also included to achieve interfaces with Non-ROS parts of the general system. An Action Data Structure comprises data used by three of five Topics composed in Action, i.e., goal, feedback and result.

The Communication Channel \cite{palka2022communication} concept depicted in Fig.~\ref{fig:communication_channel_bdd} is introduced to aggregate specializations of ROS connection (Topic connections, Service connections, and Action connections) as well as Non-ROS Connections. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/communication_channel_bdd.png}}
	\end{center}
	\caption{Communication Channel -- bdd.} 
	\label{fig:communication_channel_bdd}
\end{figure}


The Node (Fig.~\ref{fig:node_bdd}) composes Parameters and Nodelets. There are two specific Nodes considered in the metamodel: ROS Master and rosout.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/node_bdd.png}}
	\end{center}
	\caption{Node -- bdd.} 
	\label{fig:node_bdd}
\end{figure}


The Running System (Fig.~\ref{fig:running_system_bdd}) composes ROS and Non-ROS Communicating Component specializations as well as Connections between them. Two specific Nodes are highlighted: rosout and ROS master.	Additionally Parameter block is introduced.
It should be noted that although MeROS could be classified as PSM, the initial, general system description with Communications Channels and Intrasystems corresponds to PIM specification. Then, the detailing of these aggregates corresponds to the transition from PIM to PSM. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/running_system_bdd.png}}
	\end{center}
	\caption{Running System compositions -- bdd.} 
	\label{fig:running_system_bdd}
\end{figure}

The way Communicating Components use various type of connections is presented in Fig.~\ref{fig:running_system_communication_bdd}. Both ROS and Non-ROS Communicating Components can communicate via Non-ROS Connection but only ROS Communicating Components use ROS Connections.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/running_system_communication_bdd.png}}
	\end{center}
	\caption{Running System communication -- bdd.} 
	\label{fig:running_system_communication_bdd}
\end{figure}

The Intrasystem (Fig.~\ref{fig:intrasystem_bdd}) comprises a fragment of the Running System. Hence, instead of composing the parts it aggregates them. The only exception is the optional composition of the other Intrasystem.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/intrasystem_bdd.png}}
	\end{center}
	\caption{Intrasystem compositions -- bdd.} 
	\label{fig:intrasystem_bdd}
\end{figure}

The Namespace (Fig.~\ref{fig:namespace_bdd}), like the Intrasystem, aggregates elements of the Running System, but only ROS related. In opposition to the Intrasystem, the Namespace does not specialize Communicating Component, hence it can not act as Communicating Component.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/namespace_bdd.png}}
	\end{center}
	\caption{Namespace -- bdd.} 
	\label{fig:namespace_bdd}
\end{figure}

The Workspace (Fig.~\ref{fig:ros_workspace_bdd}) contains Packages that compose the files related to general ROS concepts as Node source codes, communication data structures, etc. It should be noted that data structures of Topics composed into Actions are stored in Action Data Structures instead of Msg Data Structures. The Misc <<block>> relates to other ROS and Non-ROS files, e.g., roslaunch configuration, obligatory package.xml, obligatory CMakeLists, graphics. The Metapackage is introduce to allocate [R3.3.2]. 


\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/ros_workspace_bdd.png}}
	\end{center}
	\caption{ROS Workspace composition -- bdd.} 
	\label{fig:ros_workspace_bdd}
\end{figure}



\subsection{Communication}
\label{sec:metamodel-communication}

This section depicts the behavioural and structural aspects of communication in the system. The previous section considers block definition diagrams (bdd). In the following part, the internal block diagrams (ibd) as well as behavioural diagrams are discussed. The goal is to present three modes of communication: Topic [R4.1] (sec.~\ref{sec:metamodel-topic}), Service [R4.2] (sec.~\ref{sec:metamodel-service}) and Action [R4.3] (sec.~\ref{sec:metamodel-action}). It should be noted that the concept of presentation of communication with and without dedicated communication component is illustrated on communication with Topics, but can be also applied to both Services and Actions.

\subsubsection{Topic}
\label{sec:metamodel-topic}

Fig.~\ref{fig:topic_communication_1_ibd} presents the ibd fiagram of publishers and subscribers communication via topics. In this diagram dedicated communication block is used for each Topic [R4.1.1]. In general, there are no limits to the number of publishers, subscribers and topic they communicate with. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/topic_communication_1_ibd.png}}
	\end{center}
	\caption{Topics with dedicated communication components -- ibd.} 
	\label{fig:topic_communication_1_ibd}
\end{figure}

Thanks to dedicated component to represent communication, the diagram in Fig.~\ref{fig:topic_communication_1_ibd} can be split into two considering publisher (Fig.~\ref{fig:topic_split_publisher_ibd}) and subscriber (Fig.~\ref{fig:topic_split_subscriber_ibd}) separately, without losing information. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.8\columnwidth]{img/meros_pkg/topic_split_publisher_ibd.png}}
	\end{center}
	\caption{Topics with dedicated communication components -- ibd.} 
	\label{fig:topic_split_publisher_ibd}
\end{figure}

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.8\columnwidth]{img/meros_pkg/topic_split_subscriber_ibd.png}}
	\end{center}
	\caption{Topics with dedicated communication components -- ibd.} 
	\label{fig:topic_split_subscriber_ibd}
\end{figure}

The corresponding sequence diagram is depicted in Fig. \ref{fig:topic_communication_1_sd}. Publishers send a message throw a topic to the subscribers. The incoming message cause the subscriber to execute callback function.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/topic_communication_1_sd.png}}
	\end{center}
	\caption{Topics with dedicated communication blocks -- sd.} 
	\label{fig:topic_communication_1_sd}
\end{figure}

Fig.~\ref{fig:topic_communication_2_ibd} and Fig.~\ref{fig:topic_communication_2_sd} present an alternative approach to depict the system communicating via topics. In this case, no  dedicated communication blocks are used. [R4.1.2]. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/topic_communication_2_ibd.png}}
	\end{center}
	\caption{Topics without dedicated communication blocks -- ibd.} 
	\label{fig:topic_communication_2_ibd}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/topic_communication_2_sd.png}}
	\end{center}
	\caption{Topics without dedicated communication components -- sd.} 
	\label{fig:topic_communication_2_sd}
\end{figure}

\subsubsection{Service}
\label{sec:metamodel-service}

For each ROS Service there is at most one server and a~number of clients (Fig.~\ref{fig:service_communication_ibd} and Fig.~\ref{fig:service_communication_sd}). Service type communication is bidirectional and realizes RPC (remote procedure call).

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/service_communication_ibd.png}}
	\end{center}
	\caption{Service-based communication -- ibd.} 
	\label{fig:service_communication_ibd}
\end{figure}

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/service_communication_sd.png}}
	\end{center}
	\caption{Service-based communication -- sd.} 
	\label{fig:service_communication_sd}
\end{figure}


\subsubsection{Action}
\label{sec:metamodel-action}

The general, simplified structure of ROS Action communication (Fig~.\ref{fig:action_communication_compact_ibd}) is analogous to ROS Service.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/action_communication_compact_ibd.png}}
	\end{center}
	\caption{Action-based communication -- compact representation -- ibd.} 
	\label{fig:action_communication_compact_ibd}
\end{figure}

In ROS 1, an Action is based on several Topics (Fig.~\ref{fig:action_communication_topics_ibd}).

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/action_communication_topics_ibd.png}}
	\end{center}
	\caption{Action-based communication -- Topics -- ibd.} 
	\label{fig:action_communication_topics_ibd}
\end{figure}

In practice, to present an action-related communication compactly on sd diagram (Fig.~\ref{fig:action_communication_compact_sd}) particular Topics can be generalized as a~request (for /goal and /cancel Topics) and a~response (for /status, /feedback and /result Topics). It should be noted that this diagram presents the Action communication sequence in simplified way.


\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/action_communication_compact_sd.png}}
	\end{center}
	\caption{Action-based communication sequence -- compact presentation -- sd.} 
	\label{fig:action_communication_compact_sd}
\end{figure}

The detailed behaviour of Action server and Action client is specified by state machines \footnote{\url{http://wiki.ros.org/actionlib/DetailedDescription}}. Here, these two state machines are depicted in stm diagrams. In the description, in addition to the original ROS wiki presentation, the Topics are directly mentioned both in transitions and states actions.

Fig.~\ref{fig:action_server_stm} depicts Action server state machine.
Its transitions depend on the new messages sent by the Action client or internal predicates. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/action_server_stm.png}}
	\end{center}
	\caption{Action server -- stm.} 
	\label{fig:action_server_stm}
\end{figure}

The Action client state machine (Fig.~\ref{fig:action_client_stm}) depends on server state provided by the Action server in /status Topic and internal predicates. 

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/meros_pkg/action_client_stm.png}}
	\end{center}
	\caption{Action client -- stm.} 
	\label{fig:action_client_stm}
\end{figure}


\section{MeROS application}
\label{sec:application}


\subsection{Application hints}
\label{sec:application-hints}

MeROS is a metamodel with different ways of utilising it in the broader context of systems engineering. It is therefore difficult to speak of an indication of the best procedure for its application. Nevertheless, it is possible to formulate some practical guidelines for building a particular system model based on MeROS. 

\begin{itemize}
	\item Before defining an Object, one must define the Block of which it is an instance. It is best to place Block definitions on the bdd diagrams as well. Afterwards, the definition of Objects and the formulation of the other diagrams can follow.
	\item The Object is an instance of the Block, the Object's classifier corresponds to the Block's name and the Object's name specifies the name of the Block instance. The stereotypes for Block and Object are the same.
	\item The same Blocks and the same Objects should not be duplicated. A Block or Object is defined once and used in different diagrams (in particular the same Blocks in both the Running System and Workspace diagrams, or Objects in the ibd and sd diagrams).
	\item In practice, as long as automatic validation of models formulated in MeROS is not planned, there is no need to formulate it completely in a SysML project. Stereotypes, preferably from a UML profile, will suffice. 
\end{itemize}

To help the development of user projects, the MeROS UML profile and other materials are accessible from MeROS project page\footnote{\url{https://www.robotyka.ia.pw.edu.pl/projects/meros/}}. 


\subsection{Exemplary system}
\label{sec:application-example}

This section presents key aspects of an exemplary system development process incorporating MeROS. The exemplary system was created within AAL INCARE project to control the Rico assistive robot (modified TIAGo platform) to execute transportation attendance tasks (Fig.~\ref{fig:herbatka_u_winiara}). The purpose of the following description is not to document the entire system, but to illustrate by example representative aspects of the MeROS application.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/herbatka_u_winiara.jpg}}
	\end{center}
	\caption{Transportation attendance by Rico robot \url{https://vimeo.com/670252925}} 
	\label{fig:herbatka_u_winiara}
\end{figure}

The part of the application scenario is conceptually presented in Fig.~\ref{fig:general_sd}.

\begin{figure}[htb] 
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/rico_pkg/general_sd.png}}
	\end{center}
	\caption{Concept scenario -- sd.} 
	\label{fig:general_sd}
\end{figure}

Here, the system (<<RunningSystem>> \texttt{:Rico}) and its behaviour are formulated in a~general way. An actor ask the robot to move. Then, the system recognizes voice command and confirms with voice its acceptance. In the second stage the robot executes motion and informs about motion finish also with voice.

In the following part of the description, the <<RunningSystem>> \texttt{:Rico} and sequence diagram frame \texttt{motion execution} are presented in detailed way.
The block definition diagram in Fig.~\ref{fig:rico_running_system_bdd} depicts the composition of <<RunningSystem>> \texttt{:Rico}.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/rico_pkg/rico_running_system_bdd.png}}
	\end{center}
	\caption{Rico <<RunningSystem>> composition -- bdd.}
	\label{fig:rico_running_system_bdd}
\end{figure}

The <<RunningSystem>> \texttt{:Rico} structure is depicted in Fig.~\ref{fig:rico_running_system_ibd}. Here, and in the following diagrams the \texttt{rosout} and \texttt{ROS master} <<Node>>s were omitted to make the diagrams more compact. The specific label is needed for <<CommChannel>>, e.g., <<CommChannel>> \texttt{:Move To to Robot Core}, because this <<CommChannel>> is described later on.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.85\columnwidth]{img/rico_pkg/rico_running_system_ibd.png}}
	\end{center}
	\caption{Structure of <<RunningSystem>> :Rico -- ibd.} 
	\label{fig:rico_running_system_ibd}
\end{figure}


The system bases on TaskER framework \cite{tasker2020} developed from RAPP approach to construct systems with variable structure \cite{zielinski2017variable}. The role of the TaskER is to schedule a robot’s tasks. It consists of Task Requesters <<Node>>s to submit new tasks, Task Harmoniser <<Node>> to schedule tasks execution, dynamic <<Node>>s (here, <<Node>> :Move To) to execute particular task on the robot hardware and cloud part, here <<NonRosCompon>> :Voice Recognition and Synthesis Platform. The common part of controller is located in <<Intrasystem>> :Rico.

Fig.~\ref{fig:robot_core_ibd} illustrates how various instances of the same block are depicted in the model. Two <<Parameter>> Objects of the same classifier :Double are composed into <<Node>> :MoveBase.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.85\columnwidth]{img/rico_pkg/robot_core_ibd.png}}
	\end{center}
	\caption{Selected elements of <<Intrasystem>> :Robot Core -- ibd.} 
	\label{fig:robot_core_ibd}
\end{figure}



<<CommChannel>> \texttt{:Move To to Robot Core} is depicted in Fig.~\ref{fig:move_to_2_core_cm_ibd}. It comprises three actions.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.85\columnwidth]{img/rico_pkg/move_to_2_core_cm_ibd.png}}
	\end{center}
	\caption{Example of <<CommChannel>> -- ibd.} 
	\label{fig:move_to_2_core_cm_ibd}
\end{figure}

The part of the scenario generally described in Fig.~\ref{fig:general_sd} is depicted in detail in Fig.~\ref{fig:motion_execution_sd}. The presentation remains conceptual from the behavioural point of view, but it considers the particular parts of the <<RunningSystem>> \texttt{:Rico}.

%	\begin{figure}[htb]
	%		\centering
	%		\begin{center}
		%			{\includegraphics[width=\columnwidth]{img/rico_pkg/motion_command_recognition_sd.png}}
		%		\end{center}
	%		\caption{Motion command recognition -- sd.} 
	%		\label{fig:motion_command_recognition_sd}
	%	\end{figure}

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/rico_pkg/motion_execution_sd.png}}
	\end{center}
	\caption{Motion execution -- sd.} 
	\label{fig:motion_execution_sd}
\end{figure}

Finally, on the most detailed, ROS specific level, the particular communication methods are specified (Fig.~\ref{fig:command_motion_sd}).

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=\columnwidth]{img/rico_pkg/command_motion_sd.png}}
	\end{center}
	\caption{Command motion with detailed Communication Mediums presentation -- sd.} 
	\label{fig:command_motion_sd}
\end{figure}

The part of the <<Workspace>> \texttt{Rico} that includes previously mentioned elements is presented in Fig.~\ref{fig:rico_workspace_nodes_bdd} and Fig.~\ref{fig:rico_workspace_msgs_bdd}.

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.9\columnwidth]{img/rico_pkg/rico_workspace_nodes_bdd.png}}
	\end{center}
	\caption{Rico <<Workspace>> composition -- Packages with Nodes -- bdd.}
	\label{fig:rico_workspace_nodes_bdd}
\end{figure}

\begin{figure}[htb]
	\centering
	\begin{center}
		{\includegraphics[width=.9\columnwidth]{img/rico_pkg/rico_workspace_msgs_bdd.png}}
	\end{center}
	\caption{Rico <<Workspace>> composition -- Packages with Msgs -- bdd.}
	\label{fig:rico_workspace_msgs_bdd}
\end{figure}


\section{Related work}
\label{sec:related-work}

Papers in the scope of the literature review are chosen based on an intensive study of the previous scientific work in robotic systems modelling. In particular, the survey \cite{de2021survey} is deeply analysed. As the qualification criterion, the occurrence of ROS 1 metamodel is chosen as well as UML (Unified Modelling Language), or SysML language, to describe it. Six papers describing five metamodels met this criterion, all of which used UML. The metamodels are contrasted with the representative requirements to which MeROS is subjected (Tab.~\ref{tab:ros-spec-req-sota}).
For clarification, the table refers to aspects of the metamodels, which are visualised in the analysed papers' diagrams.


\begin{table}[htb]
	\centering
	\caption{MeROS requirements satisfaction in ROS specific metamodels.}
	\setlength{\tabcolsep}{3.5pt} % Default value: 6pt
	\renewcommand{\arraystretch}{1.0} % Default value: 1
	\begin{tabular}{c c c c c c c c c c c c}
		\toprule
		Metamodel/req. & \rotatebox{90}{R3.1.1 Node}  & \rotatebox{90}{R3.1.2 Nodelet}  & \rotatebox{90}{R3.1.3 ROS plugin} & \rotatebox{90}{R3.1.4 ROS library} & \rotatebox{90}{R3.2.1 Topic} & \rotatebox{90}{R3.2.2 Service} & \rotatebox{90}{R3.2.3 Action}&
		\rotatebox{90}{R3.3.1 Package} & \rotatebox{90}{R3.3.2 Metapackage}&
		\rotatebox{90}{R3.4.2 ROS Parameter} &  \rotatebox{90}{R6.3 Grouping of concepts}\\
		\midrule
		Ecore     & $+$ & $-$ & $-$ & $-$ & $+$ & $+$ & $+$ & $-$ & $-$ & $+$ & $+$\\
		RosSystem & $-$ & $-$ & $-$ & $-$ & $+$ & $+$ & $+$ & $-$ & $-$ & $-$ & $-$\\
		HyperFlex & $+$ & $-$ & $-$ & $-$ & $+$ & $+$ & $+$ & $+$ & $-$ & $+$ & $-$\\
		RoBMEX    & $+$ & $-$ & $-$ & $-$ & $+$ & $+$ & $-$ & $+$ & $+$ & $-$ & $+$\\
		ROSMOD    & $+$ & $-$ & $-$ & $+$ & $-$ & $+$ & $-$ & $+$ & $-$ & $-$ & $+$\\
		MeROS     & $+$ & $+$ & $+$ & $+$ & $+$ & $+$ & $+$ & $+$ & $+$ & $+$ & $+$\\
		\bottomrule
	\end{tabular}
	\label{tab:ros-spec-req-sota}
\end{table}	

The authors of \cite{wenger2016model} present Ecore -- the ROS 1 metamodel as the central part of the ReApp workbench created to support the efficiency of software creation for robotic systems. The metamodel is specified in a~single, extensive structural diagram, with the ROS node being its central part. The diagram describes the aspects of running system and comprises all ROS communication methods. The nodes are composed into an AppNetwork concept [R6.3]. 

In the paper \cite{garcia2019bootstrapping}, the authors propose two methods based on the created RosSystem metamodel. It aims at the automated generation of models from manually written artefacts through static code analysis and monitoring the execution of the running system. A~large part of the work is concentrated on the toolchain. This ROS metamodel is structurally specified in a~UML class diagram that emphasises communication methods.

HyperFlex toolchain \cite{brugali2016hyperflex,gherardi2013variability} includes extensive and comprehensive metamodel addressing both ROS 1 and complementary Orocos. Formerly, these two frameworks were used together to take from RT properties of Orocos and elasticity of ROS. The presentation of HyperFlex is complex \cite{brugali2016hyperflex,gherardi2013variability}, both the running system and workspace are considered. Concepts such as nodelet or metapackage are missing due to the HyperFlex period of its foundation.

RoBMEX \cite{ladeira2021robmex} was created as a~top-down methodology based on a~set of domain-specific languages that enhance the autonomy of ROS-based systems by allowing the creation of missions graphically and then generating automatically executable source codes conforming to the designed missions. Hence, the ROS metamodel was extended by the upper layer with mission/task specification. The metamodel is complex and inspiring and consists of the running and workspace parts. In the workspace aspect, the grouping concepts are introduced together with subpackages, classified as metapackage for the sake of generality.

ROSMOD \cite{kumar2016rosmod} is the Robot Operating System Model-driven development tool suite,
an integrated development environment for rapid prototyping component-based
software for ROS. Its internal metamodel is complex and comprises a~number of standard ROS concepts and additional grouping concepts. Although the description is extensive, the ROSMOD was created in 2016, hence some current concepts are missing, like ROS actions or nodelets.


\section{Conclusions and discussion}
\label{sec:conslusions}

Diagrams are an integral part of the description of component-based robot control systems. ROS comprises rqt\_graph tool that generates diagrams with the structure of the running system. This capability is readily used by software developers (e.g., \cite{thale2020ros,bisi2018development,gupta2020design}) due to its ease of use. Unfortunately, despite its numerous advantages and configurability, this tool has many limitations. Hence, in parallel to automatically generated diagrams, others are needed, some of which are based on UML/SysML. The most comprehensive modelling solutions include explicitly defined metamodels. As a~novelty regarding previous works, this paper proposes an up-to-date metamodel for current versions of ROS~1 supported by profile to support the metamodel application in ROS applications models. In MeROS, the metamodel of original ROS concepts is extended by grouping concepts. It lets to present part of the system in a~PIM-like style instead of a~platform specific -- PSM.

Although the adoption of UML/SySML-based domain metamodels has a number of positive implications it also has its problems and limitations. Without doubt, the use of modelling software such as Enterprise Architect or Visual Paradigm is highly recommended when creating them. Although the diagrams as such can be drawn in a general-purpose graphics program, in practice for complex systems this is not advisable if only because it is not possible to create a UML project and take advantage of all the benefits of this solution. In particular, creating a set of diagrams without a project is more time-consuming and it is easier to introduce errors. In practice, the cost of this type of software is not a major obstacle and its popularity makes it easier to implement in use. A problem with SysML development environments is that in many aspects they are not standardised and vary considerably in functionality. This makes it difficult to use advanced features such as automatic model analysis, e.g. to check for metamodel compatibility.

There are many methodologies for conducting and documenting projects and not all of them assume the use of languages from the UML family. In some simplification, one could say that some project teams make extensive use of UML while others do not at all\footnote{\url{https://creately.com/guides/advantages-and-disadvantages-of-uml/}}. In the case of robotics projects, the lack of widespread use in earlier years may have been due in part to their relatively small scope and academic nature. When projects are extensive, multi-asset and the consequences of failure are high, the use of UML allows for greater efficiency of operation and reduced risk of project failure. Hence, as has been the case for many large-scale projects, for instance from the space industry (e.g., \cite{friedenthal2017architecting}) or the medical industry (e.g., \cite{BiomedicalHealthcare}), contemporary complex robotics projects should benefit from appropriate tools to support their guidance and documentation. 

Many skilful and experienced programmers have not used UML\footnote{\url{	https://www.techwalla.com/articles/the-disadvantages-of-uml}}. This is due to the lack of absolute necessity to use such tools both for programming itself and for the development of small projects. Hence, the first use of UML in a developers team can consume a disproportionate amount of time. Another problem is the synchronisation of diagrams with source code. Here, the answer is, among other things, the appropriate level of generality of the diagrams, so that unnecessary details are not mapped there. The automatic generation of code from the diagrams, or the automatic generation of selected diagrams on the basis of code can also be helpful. Finally, it is worth mentioning that UML diagrams do not constitute a complete description of the system. In particular, the description by diagrams is complemented by mathematical expressions. A way of combining these two ways of description is presented in e.g. \cite{earl2020}. SysML parametric diagrams also respond to this problem.

System development involves the use of a~number of tools organised in toolchains. The degree of tools interaction varies. In software engineering, the aim is to create clear procedures for system development, with an indication of the dependencies between the successive stages of the development process. In robotics, there have been many works dedicated to toolchains (SmartMDSD \cite{dennis2016smartmdsd}, RobotML \cite{robotml2}, \cite{dal2022formal}), nowadays the ROS is common middleware (e.g. \cite{wienke2012meta}, BRIDE \cite{bubeck2014bride}, HyperFlex \cite{brugali2016hyperflex}). MeROS is part of the toolchain used in the Robot Programming and Machine Perception Team at Warsaw University of Technology (WUT). At the forefront of the toolchain stays the modelling of the system with PIM using the SPSysML \cite{dudek2023spsysml} based on EARL language \cite{earl2020}. EARL is derived from agent theory \cite{kornuta-bpan-2020, zielinski2010motion,zielinski2017variable}. In the intermediate stage, MeROS plays the major role of a~PSM. Finally, FABRIC  \cite{Seredynski-fabric-romoco-2019}, as well as alternative approaches \cite{winiarskimmar2015,figat2020robotic} are used to support code generation. Current work concerns deepening the integration of MeROS with the rest of the toolchain. The works are centred around two robotic platforms: the Velma service robot \cite{en14206693-grav-comp,Figat:2022:RAS} \footnote{\url{https://www.robotyka.ia.pw.edu.pl/robots/velma}} (Fig. \Ref{fig:velma}) and the assistive robot Rico \cite{tasker2020,karwowski2021hubero} \footnote{\url{https://www.robotyka.ia.pw.edu.pl/robots/rico}} (Fig.\ref{fig:rico}).

% The height can be increased to 5.5cm
\begin{figure}[htb]
	\centering
	\begin{subfigure}[b]{.43\columnwidth}
		\includegraphics[height=4.8cm]{img/velma.jpg}
		\caption{Velma.}
		\label{fig:velma}
	\end{subfigure}
	\begin{subfigure}[b]{.47\columnwidth}
		\includegraphics[height=4.8cm]{img/rico.jpg}
		\caption{Rico.}\label{fig:rico}
	\end{subfigure}
	\caption{Robotic platforms.}
	\label{fig:robots}
\end{figure}

Although ROS~1 still dominates among component-based robotic frameworks, one should expect many robotic platforms to migrate to ROS~2 in the future, not to mention the use of ROS 2 in newly developed systems. The ROS version change will entail a~corresponding adaptation of MeROS, which should not cause significant difficulties.


	
	
	\section*{Acknowledgment}
	The research was funded by the Centre for Priority Research Area Artificial Intelligence and Robotics of Warsaw University of Technology within the Excellence Initiative: Research University (IDUB) programme. 
	
	\bibliography{meros}
	
	
	
%	\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{img/autorzy/twiniarski.jpg}}]{Tomasz Winiarski} IEEE, INCOSE Member, M.Sc./Eng. (2002), PhD (2009) in control and robotics, from Warsaw University of Technology (WUT), assistant professor of WUT. He is a~member of Robotics Group as the head of Robotics Laboratory in Institute of Control and Computation Engineering (ICCE), Faculty of Electronics and Information Technology (FEIT). He is working on modelling and design of robots, and programming methods of robot control systems. The research targets service and social robots as well as didactic robotic platforms. His personal experience concerns development and modelling of robotic frameworks, manipulator position--force and impedance control, safety in robotic research. Recently, he was the head of the WUT group in AAL -- INCARE project "Integrated Solution for Innovative Elderly Care".
%	\end{IEEEbiography}
	
	
	
\end{document}
