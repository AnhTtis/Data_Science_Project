\section{Background}
\label{section:background}

\subsection{Fault Definitions \& Fault Propagation}
\label{section:background:subsection:fault_defitions_propagation}

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/vector/exported-pdf/background_fault.pdf}
    \caption{Fault classification based on detectability and recoverability from the resulting modifications: in this work we focus on \glsentrytitlecase{sdc}{longpl}, as they are undetectable unrecoverable errors, leading to huge drops in \glsentryshort{dnn} accuracy.}
    \label{figure:fault_background}
\end{figure}

Faults propagate in different ways depending on the software and hardware conditions in which they occur: if the outcome leads to a change of the processed data only, we refer to them as soft errors. Depending on the outcome on the system, as normal execution or soft errors, faults can be distinguished in 4 categories, as described in Figure \ref{figure:fault_background}: faults can be detectable or undetectable, and the resulting outcome can be recoverable or unrecoverable. Therefore, we can define 4 types of errors: \titlecaseabbreviationpl{dre}, \titlecaseabbreviationpl{due}, \titlecaseabbreviationpl{sdc}, which corresponds to \titlecaseabbreviationpl{uue}, \titlecaseabbreviationpl{ure}. \titlecaseabbreviationpl{dre} and \titlecaseabbreviationpl{ure} are recoverable, hence, they are not analyzed in detail in this work. Regarding \titlecaseabbreviationpl{due}, these errors can be detected through many efficient algorithms, and while they might require complete system reboots, they are detectable, and a possible mitigation can be employed. Therefore, the main focus of this work is for \titlecaseabbreviationpl{sdc} regarding soft errors, as these errors can lead to great drops in accuracy for \titlecaseabbreviation{dnn} systems, and they are not easily predictable. \titlecaseabbreviationpl{sdc} can also affect directly the system execution, and not only its data, however we do not consider them here, hence, we focus only on soft errors, affecting data and the result of the \titlecaseabbreviation{dnn} system. This is mainly because most \titlecaseabbreviationpl{cps} have strict safety requirements, which might be invalidated by possible errors.

Another classification system for faults is transient and permanent: the former refers to faults generated by temporary variations in the running hardware and software system, such as charged particles interacting with the silicon substrate, while the latter refers to permanent defects of the system. We focus on transient faults, as scaling technologies has increased the effects of faults on the running systems. In the case of transient faults caused by charged particles, the resulting effect is a bit flip in the corresponding registers and memory cells. Therefore, we use these transient faults causing bit-flips as our study target.

\subsection{Fault Injection for \glsentrytitlecase{dnn}{longpl}}
\label{section:background:subsection:fault_injection_for_neural_networks}

Fault injection is a tool for testing the response of a system when an unreachable or undesired state is erroneously reached.
For \titlecaseabbreviationpl{dnn}, fault injection can be implemented in many different ways: a common way of injecting faults is by modifying weight and/or output tensors during execution. This approach is the most reliable and the easiest to implement for simulating bit-flips due to charged particle interactions, for more complex faults it might be required to cover control logic crashes or modifications, which are out of the scope of this work. Therefore, we focus only on modifying the weight and the output tensors.
% This behaviour can be caused by transient or permanent faults: the former disappear after a concise time interval, while the latter are non-repairable and last for the rest of the system life.
% Our focus will be on transient faults, which are caused by the silicon substrate of the hardware interacting with accelerated particles which are omni-present in the environment. More specifically, our experiments will target transient bit-flips leading to \titlecaseabbreviationpl{sdc}. \titlecaseabbreviationpl{sdc} decrease the accuracy of the network, without affecting its operational capability, which is critical for safety-dependent systems such as cyber-physical systems.

% Fault injection is used to test the behaviour of a system when an unexpected state is erroneously reached.
% Faults are classified mainly into two types, transient, which disappear after a concise time interval, and permanent, which are not repairable. Also, depending on the outcome of the affected signals, they are categorized as bit-flip if the signal value is inverted or stuck-at if the signal value is stuck at a 0 or 1 in bit value.
% Our focus will be on transient faults, which are caused by particles interacting with the hardware and flipping the signal values.
% In the case of neural networks, these can happen in different locations. However, when using software-level injection methodologies, only a limited set of faults can be covered without prior knowledge of the inner workings of the software and hardware platforms. This means the only directly addressable elements are the tensor values and their indices for layer weights and outputs, representing faults happening in memory locations for the weights and the temporary layer outputs.

\subsection{Importance Sampling}
\label{section:background:subsection:importance_sampling}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{images/vector/exported-pdf/importance_background.pdf}
    \caption{Qualitative visualization of differences between random uniform sampling and importance sampling for integral computation. Importance sampling uses a sampling distribution focused where the integrand function is bigger in absolute value, hence providing more accurate result with fewer samples than random uniform sampling.}
    \label{figure:importance_sampling_background}
\end{figure}

Importance Sampling is a Monte Carlo sampling technique used in integral computations \cite{kloekBayesianEstimatesEquation1978}.
We show an example for integral computation in Figure \ref{figure:importance_sampling_background}. For computing $\int_{-\infty}^{\infty} f\left(x\right)~dx$, we can sample either a uniform distribution which is completely random, or use importance sampling, employing a modified distribution. The latter increases the sampling rate around the areas where $f\left(x\right)$ is larger in absolute value, hence providing a more accurate computation with fewer samples compared to a random uniform distribution.
% It refers to using different sampling distribution than a uniform one, so that we can use more samples from the intervals where the integral value is bigger, hence reducing variance and number of required samples to reach a pre-determined accuracy.
The application to fault injection is similar, focusing the fault samples where the effects would be more noticeable, compared to random sampling which covers all the possible faults in the same way.

