
\section{Clifford Ansatz}
\label{sec:clifford}

Having laid out the scaling-inspired architecture in the previous section and shown that it can capture some expected features of mean-field models, especially the SYK model, we now consider a concrete version of the network built from Clifford gates. We would also like to use the network as a variational ansatz to study physical mean-field models, but for the reasons outlined in the introduction, in this paper we focus on the Clifford model as an example where we can also classically simulate the network properties. A review of the Clifford group and how it can be implemented is provided in appendix \ref{sec:phase_space}. 

If the circuits in Figure~\ref{fig:arch} are composed of Clifford gates, then the network can be interpreted as an encoding circuit for a stabilizer quantum error correcting code~\cite{gottesman_stabilizer_codes_quantum_1997}. The ground state qudits then correspond to the logical qudits of the code. We focus in particular on the distance of the code and the weight of the stabilizers, as they provide a good heuristic for probing the entanglement structure and give us a glimpse at the network's potential as an error-correcting code. The purpose of this section is to review this error correction interpretation and setup the subsequent calculations in Sections~\ref{sec:numerical} and \ref{sec:code_structure}.

\subsection{The Clifford Group}


Let us briefly recall the motivation for Clifford circuits. In general, simulating quantum circuits on a classical computer architecture becomes difficult with increasing number of qudits due to the exponential scaling of the Hilbert space dimension with the number of qudits. However, we can still compute certain quantities efficiently on classical computers by restricting ourselves to a subgroup of the full unitary group that only scales linearly in the number of qudits ~\cite{gottesman_heisenberg_representation_quantum_1998, aaronson_improved_simulation_stabilizer_2004}. This group is called the \emph{Clifford group} and is defined as the subgroup of unitary operators that map Pauli strings to Pauli strings~\cite{gottesman_heisenberg_representation_quantum_1998}. Elements of the Clifford group can then be represented as \emph{Clifford circuits}, which are circuits composed of successive (elementary) Clifford gates acting on a bounded number of qudits at a time. An example of such a Clifford circuit is depicted in Figure \ref{fig:layer_circuit} in the context of random scrambling.

The Clifford group has a variety of applications in quantum information. For example, in the context of generating random states, the Clifford group is useful because it forms a $k$-design of the Haar measure of random unitaries. This means that quantities averaged over random choices of gates/states only start to differ between Clifford and Haar in probability moments higher than $k$, where we have $k=1$ for all possible qudit dimensions $d$, $k=2$ for all $d$ that are powers of primes, and $k=3$ when said base prime is 2. \cite{zhu_multiqubit_clifford_groups_2017, graydon_clifford_groups_are_2021}.

The reason the Clifford group for $N$ qudits with local dimension $d$ can be efficiently simulated resides in the fact that it is a projective representation of the symplectic group $\text{Sp}(2N, \mathbb{F}_d)$, where $2N$ is the vector space dimension the group acts on and $\mathbb{F}_d$ is the (unique) finite field with $d$\footnote{In this case $d$ must be the power of a prime.} elements. As mentioned before, the space of Pauli strings therefore scales linearly, with operators mapping between them being represented (up to a phase) by $2N \times 2N$ symplectic matrices over $\mathbb{F}_d$. Sampling Cliffords therefore can be achieved by sampling symplectic matrices, for which efficient algorithms exist \cite{koenig_how_efficiently_select_2014}.  A more detailed description of this framework is provided in Appendix \ref{sec:phase_space}.

\subsection{Random Layer Circuits}

To define a precise model based on our architecture, we have to make an explicit choice for the depth $D$ circuits $D_{\ell}$ that are applied at each layer $\ell$. Inspired by SYK, our approach is to apply $n_{\ell} / q$ randomly sampled Clifford gates\footnote{In general $q$ does not have to divide $n_{\ell}$ without remainder, in which case one can simply leave $n_{\ell} \mod{q}$ qudits unchanged at each sub-layer. In our computations we always chose our parameters such that this is not necessary. } to randomly chosen non-intersecting sets of $q$ qudits for each sub-layer $1 \leq m \leq D$ of the total layer circuit. Such a Clifford circuit is depicted in figure \ref{fig:layer_circuit} for $q=2$. Heuristically, this ansatz can be interpreted as a Trotterization of the SYK Hamiltonian, although with qudits instead of Majorana fermions \footnote{In an actual variational calculation with the SYK model, we might expect that the layer circuits are unitarites generated by SYK-Hamiltonian-like operators (although not necessarily the SYK Hamiltonian itself). The choice of random Clifford layers is thus loosely inspired by our expectations for the SYK model.} .

\begin{figure}[hbt]
    \centering
    \tikzfig{figures/wall_circuit}
    \caption{An example of a layer circuit acting on 10 qudits with $q=2$ and depth $D=3$. Each unmarked gate represents a randomly sampled Clifford element acting on two qudits, while the gates $\pi_m$ for $m=1,2,3$ are random permutations of the qudits. While such a circuit does not exhibit a causal cone, this non-locality of interactions is expected from mean-field models.}
    \label{fig:layer_circuit}
\end{figure}

With that we can then view the resulting network as an encoding circuit for a quantum stabilizer code. The $k$ ground state qudits are the logical qudits and the $N$ UV qudits are the physical qudits. We now briefly review stabilizer codes and the important notion of distance, which captures aspects of the entanglement structure discussed above in Section~\ref{sec:arch}.

\subsection{Stabilizer Codes}
\label{sec:stab}

A $[[N, k, \delta]]$ \emph{stabilizer code} that encodes $k$ logical qudits into $N$ physical qudits with distance $\delta$ is defined in terms of a \emph{stabilizer group} $S$, which is an abelian subgroup of the (generalized) Pauli group $P_d(N)$ i.e.\ the group generated by all possible $N$-element tensor products of ordinary Pauli operators ($d = 2$)
\begin{equation}
    X = \begin{pmatrix}
        0 & 1 \\ 1 & 0
    \end{pmatrix}, \,
    Y = \begin{pmatrix}
        0 & -i \\ i & 0
    \end{pmatrix}, \,
    Z = \begin{pmatrix}
        1 & 0 \\ 0 & -1
    \end{pmatrix},
\end{equation}
or their higher-dimensional counterparts ($d > 2$), which are defined in appendix \ref{sec:weyl_rep} \cite{gottesman_stabilizer_codes_quantum_1997}. The stabilizer group must therefore be generated by $N - k$ independent and commuting elements of $P_d(N)$. A \emph{code word} then is a state vector $\ket{\psi} \in \mathbb{C}^{d^N}$ that satisfies $s \ket{\psi} = \ket{\psi}$ for all $s \in S$. The space spanned by all possible code words is called the \emph{code space} and has dimension $d^k$ due to the rank of the group being $N-k$. The operators mapping logical states to other logical states are called \emph{logical operators} and must therefore commute with all elements of the stabilizer group and hence form the centralizer of the stabilizer group in in $P_d(N)$.

%\subsubsection{Error Correction}

%The purpose of stabilizer codes is to facilitate the detection and correction of errors that might occur in a quantum state without destroying its entanglement structure. One cannot use simple redundancy, as this is impossible in general due to the no-cloning theorem. In principle, this can be accomplished by performing projective measurements according to the basis elements of the stabilizer group, to check if the state still has unit eigenvalue as initially required. Repeating this with all stabilizer basis elements produces a $N-k$ dimensional vector called the \emph{syndrome} associated to the given error that occurred. If the syndrome does show an error for a certain stabilizer, one can apply a so-called \emph{destabilizer} to correct that error. Each destabilizer anti-commutes with a single stabilizer and commutes with all others, allowing us to flip a single localized error without affecting the other stabilizers or the code word. \bgs{destabilizers are only defined up to local operators, right?}

%However there are limits to this approach: Once the number of singular errors crosses the threshold given by the distance $\delta$, it is by definition impossible to reconstruct the original logical state since it has been affected by too many errors. It is therefore essential to find codes that maximize the scaling of $\delta$ with the total system size $N$ because the probability of errors will increase as well. Additionally, it can occur that an error exactly mimics one of the logical operators (up to an additional error that doesn't), meaning it can't be detected. However (for codes with a \enquote{good} distance) the probability of this happening quickly approaches zero with increasing $N$ due to the spreading of the encoded information implying that the logical operators must act non-trivially on almost all physical qudits, decreasing the chance of them randomly occurring.

\subsubsection{Decoupling \& Code Distance}

The code distance is a measure of how robust the code is to errors on the physical qubits. Determining the distance for a stabilizer code is in general a computationally intensive problem due to the potential for complex patterns of entanglement. We use an \emph{adversarial approach}, which is based on analyzing the mutual information
\begin{equation}
\label{eq:mut_inf}
    I(A, R) = S(A) + S(R) - S(AR)
\end{equation}
between all possible subsystems $A$ of the physical qudits and some external reference $R$ which is maximally entangled with the code space. A depiction of the setup can be found in figure \ref{fig:decoupling}.
\begin{figure}[htb]
    \centering
    \tikzfig{figures/decoupling}
    \caption{Circuit representation of state in which the code space is maximally entangled with a reference $R$. Here $U_{MN}$ is a unitary that takes states of the form $\ket{\psi_{\text{anc}}}_M \otimes \ket{\psi_{\text{code}}}_N$ and maps $\ket{\psi_{\text{code}}}$ to the code space of the chosen stabilizer code. $\ket{\psi_{\text{anc}}}$ is the all $0$ state of the ancillary qubits. If a region $A$ has zero mutual information with $R$, then it has no access to the encoded information. The code distance $\delta$ is the biggest integer such that all regions $A$ of size $|A| < \delta$ have $I(A,R)=0$.}
    \label{fig:decoupling}
\end{figure}

Because $R$ is maximally entangled with the code space, it is effectively tracking the encoded information. Therefore the question is how much of the system does an adversary need access to in order to be correlated with $R$ and thus have (at least partial) access to the encoded information. This correlation can be detected using the aforementioned mutual information \eqref{eq:mut_inf}, which becomes non-zero in such a case.
%In that case one says that $A$ is \emph{decoupled} from the rest of the physical qudit space, meaning that the state can be written as a tensor product on $A$ and its complement $MN / A$. 
The code distance $\delta$ is the biggest integer such that all regions $A$ with $|A|<\delta$ have $I(A,R)=0$. %is therefore
%\begin{equation}
%    \delta = |A^*|,
%\end{equation}
%where $A^*$ is one of the largest subsets of physical qudits which still satisfy $I(A^*, R) = 0$. 
%Since the code word is assumed to be maximally entangled with $R$, this statement is true for all possible choices of $\ket{\psi_{\text{code}}}$.

Implementing this approach as an algorithm is time-consuming though, since iterating through all possible choices for $A$ is combinatorically intensive. A way to simplify the procedure at the cost of only getting an upper bound approximation for the code distance is by randomly sampling choices for $A$ and determining the largest one which has vanishing mutual information. This Monte Carlo approach is the method we use.

\subsubsection{Stabilizer Weights}

It is also interesting to ask about the weights of the stabilizers. The weight of a Pauli string is defined as the number of elements of $P_d(1)$ in the tensor product representation of the operator that are not proportional to the identity operator $I$. Since $P_d(1)$ contains $d^2$ elements, there are $d^2 - 1$ such nontrivial operators.  If the stabilizer group has a generating set containing only Pauli strings of bounded weight, then we say the code has constant weight. The code space can always be obtained as the ground space of a Hamiltonian built from a generating set of the stabilizer group, and if the code has constant weight then there is such a Hamiltonian which contains only terms acting on a bounded number of qudits at a time.



\subsection{Summary}

Here we reviewed the notion of a stabilizer code and defined the random Clifford gate version of our architecture. In the following two sections, \ref{sec:numerical} and \ref{sec:code_structure}, we consider random stabilizer codes built from random Clifford layers inserted in the RG-inspired architecture (Figure~\ref{fig:arch} and Section~\ref{sec:arch}). We investigate the distance and stabilizer weights both numerically and via analytic arguments. We verify that these codes can be highly entangled, for example, with a distance proportional to $N$. We also study the distribution of stabilizer weights and show that some stabilizers do have high weight proportional to $N$. As such, they are not constant weight codes in general.
