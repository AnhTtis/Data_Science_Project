\section{Results}

\subsection{Technical Details}
The stabilizer simulation used to generate the following data was written in Python 3.9.7 using Numpy 1.21 (linear algebra) \cite{harris2020array} and Galois 0.0.24 (finite field arithmetic) \cite{Hostetter_Galois_2020}, and is based on the projective symplectic representation discussed in section \ref{sec:phase_space}. The algorithm used to randomly sample symplectic matrices for Clifford operators is based on \cite{Koenig_2014}, but was generalized to work for any choice of prime qudit dimension $d$. The complete code can be found at
\\~\\
\centerline{\url{https://github.com/Slartibartfass42/ldpc_syk}.}
\\~\\
All data in this paper was generated using a 2021 MacBook Pro with M1 Pro processor and 16 GB RAM. If the computation involved random sampling, an average over 1000 iterations is displayed together with the error on the mean\footnote{Some errors are so small that they are not visible in the figures.}.

\subsection{Simple Scrambling}

We first considered the simple case of the two-site wall scrambling circuit as depicted in figure \ref{fig:wall_circuit}, except that we randomly chose the Weyl pairs that the random Cliffords act on at each step in the process. The system therefore does no exhibit a causal cone. Analysing the weight evolution of such a circuit provides a good heuristic for how quickly such a system becomes highly entangled and thus chaotic.

Starting with unit weight $d=3$ Weyl operators acting on $n = 2^1, 2^2, \ldots, 2^7$ sites, we recorded their new weight after each scrambling layer until the system equilibrated around some value. We call the average step number when this happens the \emph{scrambling time} $T^*$. The resuling weight evolution over time $T$ (i.e.\ the number of steps) is depicted in figure \ref{fig:simple_weights}.
\begin{figure}[hbt]
    \centering
    \includegraphics[width=.9\linewidth]{figures/simple_weights.png}
    \caption{The average weight evolution of $n$ Weyl operators ($d=3$) with initial unit weight overall when subjugated to repeated random two-site scrambling Clifford gates as seen in figure \ref{fig:wall_circuit}. The dashed lines indicate the expected values the weights approach over time, namely $8n/9$. This is because a single randomly sampled $d=3$ Weyl operator has a chance of $8/9$ to have a non-zero weight i.e.\ not being the identity operator.}
    \label{fig:simple_weights}
\end{figure}

We can infer two facts about the scrambling behavior from this graph:
\begin{enumerate}
    \item The initial weight growth $W(T)$ up until the scrambling time is roughly exponential, since it is linear in the logarithmic plot. We can therefore write
    \begin{equation}
        W(T) \sim r^T, \quad T < T^*
    \end{equation}
    for some (numerically determined) constant $r$. We expect $r$ to be slightly less than 2, as that is the number of sites involved in a single scrambling. 

    \item The average weight in equilibrium is not exactly $n$, but $8/9 \cdot n$. This is because a randomly sampled single Weyl operator with $d = 3$ only has a chance of 1 in $9 = d^2$ to have zero weight, namely when it is the identity. This can be seen from \eqref{eq:weyl_single}. In general, the average equilibrium weight of $n$ Weyl operators with qudit dimension $d$ is
    \begin{equation}
        W(T) \sim \frac{d^2 - 1}{d^2} \cdot n, \quad T > T^*.
    \end{equation}
    We also refer to (Weyl) operators in general as being \emph{f-scrambled} if their weight satisfies $W(T) \sim f \cdot n$ after the scrambling time.
\end{enumerate}

Combining these two results we deduce that $r^{T^*} \sim f \cdot n$ for some constants $r$ and $f$, which allows us to approximate the scrambling time as
\begin{equation}
\label{eq:scrm_time}
    T^* \sim \frac{\log(f \cdot n)}{\log(r)}.
\end{equation}
To confirm this statement, we extracted the scrambling times from figure \ref{fig:simple_weights} by manually pinpointing the step when the system seems to reach equilibrium and assuming a human error of $\pm 1$ steps. Plotting those values against the system size and making a fit by using \eqref{eq:scrm_time} resulted in \ref{fig:simple_scrm_time}.
\begin{figure}[hbt]
    \centering
    \includegraphics[width=.9\linewidth]{figures/simple_times.png}
    \caption{The scrambling time $T^*$ with regard to the systems size i.e.\ the number of Weyl operators being scrambled. As expected, the growth follows a logarithmic trend determined by $T^* \sim \log(f n) / \log(r)$ with $r = 1.83 \pm 0.08$ being close to 2. Unlike expected however, the determined value for $f$ differs from the expected value of $8/9$ by $2.09 \sigma$ with $\sigma = 10.72$ being a large error. This is attributed to a systematic error that occurred when determining the scrambling times by hand.}
    \label{fig:simple_scrm_time}
\end{figure}

While the data does indeed seem to follow the trend dictated by our approximation of the scrambling time and with a reasonable result for $r$, the fit for $f$ on the other hand is not quite compatible with the expected value. This is very likely due to how the data points and their errors were determined. Follow-up work on this subject will require a more systematic way of extracting the scrambling time from data such that human bias does not interfere significantly.

\subsection{SYK-Like Scrambling}

Building on top of the previous results, an analogous weight analysis for the SYK circuit seen in figure \ref{fig:syk_circuit} with $d=3$ was performed. Setting $n_{\text{code}} = 2$ and $\ell = 10$, we prepared a Weyl operator with unit weight in the code subsystem and simulated its evolution for varying scrambling circuit depths $D = 1, 2, \ldots 7$. The weight of the operator at each step of the simulation is shown in figure \ref{fig:syk_weights_l10}.
\begin{figure}[hbt]
    \centering
    \includegraphics[width=.9\linewidth]{figures/syk_weights_l10.png}
    \caption{The weight evolution of the SYK circuit as depicted in figure \ref{fig:syk_circuit} for $n_{\text{code}} = 2$, $\ell = 10$ and circuit depth $D = 1, 2, \ldots, 7$. Even for small choices of $D$ the operator weight quickly converges towards the exponentially increasing maximal threshold determined by \eqref{eq:syk_weight_max} (the blue line).}
    \label{fig:syk_weights_l10}
\end{figure}

As can be easily seen, for increasing $D$ the weights at each step $T$ seem to quickly converge towards the predicted average maximum, which is in general given by
\begin{equation}
\label{eq:syk_weight_max}
    W_{\text{max}}(T) = \frac{(d^2 - 1)}{d^2} (n_{\text{code}}+ 2^T), \quad T = 1, 2, \ldots, \ell.
\end{equation}
Note that $D$ is roughly the equivalent of $T$ for the circuit in the previous section section. We therefore denote $D^*(T)$ as the smallest circuit depth for which the system reaches (almost) maximal weight \eqref{eq:syk_weight_max} for each $T$. By looking at figure \ref{fig:syk_weight_diff_l10} this seems universially to be the case for $D^* = 5$, independent of $T$, but $D^* = 4$ seems to give the same result for $T > 1$. For determining the optimal code distance, we therefore suggest to choose $D=4$ for all steps and increase if necessary. Since this behavior should stay roughly the same for larger $\ell$ due to the self-similar nature of the code, $D=4$ might prove to be a good choice for larger system sizes, although that remains to be shown explicitly

\begin{figure}[hbt]
    \centering
    \includegraphics[width=.9\linewidth]{figures/syk_weight_diff_l10.png}
    \caption{The relative weight difference between the simulated and expected values using the same data as in figure \ref{fig:syk_weights_l10}. While  the discrapancy for smaller scrambling depths seems to get larger over time, starting with $D=3$ the difference seems to stay constantly small. Note theat the irregular behaviour for $T < 2$ is likely due to the choice of giving the initial state unit weight.}
    \label{fig:syk_weight_diff_l10}
\end{figure}

Unfortunately, due to time constraints no data regarding the (adversarial) distance of the SYK code has been generated as of writing. We can therefore not say yet if our construction has good error-correcting properties or if it even has the properties of a quantum ldpc code. This will be explored in future work.

\subsection{Tripartite Entanglement}

Last but not least, we considered the GHZ content of tripartite states with $n_{\text{party}} = 1, 2, \ldots, 5$ and $d = 3, 5, 7, 11, 13$. The ration between the average number of GHZ states and $n_{\text{party}}$ is displayed in figure \ref{fig:tripartite_g}.
\begin{figure}[hbt]
    \centering
    \includegraphics[width=.9\linewidth]{figures/tripartite_g.png}
    \caption{Rate of occurrence of tripartite entanglement in form of GHZ states for different systems sizes per party and qudit dimensions. While a general downward trend is visible and expected, the dependence of the ratio on $d$ and $n_{\text{party}}$ is still for the most part unexplained and requires a more extensive analsysis of all quantities involved and the correctness of the simulation.} 
    \label{fig:tripartite_g}
\end{figure}

While the case of $n_{\text{party}} = 1$ does have a significant amount of tripartite entanglement for all $d$, this ratio drops rapidly for $n_{\text{party}} > 1$ and seems to indicate the beginning of a general downward trend that continues even beyond the available data. How exactly this trend behaves requires a more thorough analysis using larger values of $n_{\text{party}}$.

What's interesting is the difference in $d$-dependent behavior for different choices of $n_{\text{party}}$. While for $n_{\text{party}} = 3, 5$ the GHZ content seems to be the same for all qudit dimensions and with vanishing error on the mean, the content for $n_{\text{party}} = 1, 3, 5$ either increases or decreases with larger $d$ while also exhibiting a larger error. So far it reamins unclear if this behavior can be somehow explained, or if it is due to some numerical anomaly or faulty behavior in the stabilizer simulation. More work is therefore necessary.

What might have an explanation though is the oscillating maximum GHZ ratio between even and odd $n_{\text{party}}$. Reminding ourselves that $S(A) + S(B) + S(C) = 2(a + b + c) + 3g$, it is easy to see that if the left-hand side is overall odd, then we must have $g > 0$. This might be more likely to be the case for $n_{\text{party}}$ odd since in the even case the qubits for a single party are on average either pairwise (maximally) entangled with each other or entangled with qubits from other parties. Since that entanglement always comes in pairs the local entropies must be even on average, therfore allowing $g = 0$. This is only specualation though, and an analysis of the local entropies is required to bring certainty.

