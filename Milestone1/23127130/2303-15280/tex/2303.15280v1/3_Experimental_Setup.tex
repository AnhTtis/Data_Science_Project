\section{Experimental Setup} \label{sec:experimental_setup}

This section elaborates on the evaluation setup of the
proposed methodologies.  Since performance bug localization in cores
is the focus of this work, sections~\ref{subsec:probe_setup}
to~\ref{subsec:impl_bugs} cover in detail its experimental setup
characteristics, while section~\ref{subsec:setup_memory} covers the
changes implemented to apply the proposed methodologies to a memory
system performance bug localization setup.

\input{3a_Probe_Setup}

\begin{scriptsize}
  \begin{table*}[!htb]
  \footnotesize
    \centering
    \caption{Performance bug types injected in gem5 and their
      corresponding locations. Multiple variations of each type were
      implemented for this evaluation.}
    \label{tab:bugs_gem5}
    \resizebox{0.99\textwidth}{!}{
\begin{tabular}{p{0.1\textwidth}|p{0.9\textwidth}}
  \hline
  \textbf{Bug location} & \textbf{Bug type description} \\ \hline
  \multicolumn{1}{l|}{\multirow{2}{*}{Fetch}} & Fetching instructions from the instruction cache takes \textit{T} cycles longer than expected. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} &  Every \textit{T} cycles, the maximum number of instructions that the processor is able to fetch is reduced by \textit{N} entries during one cycle. \\ \hline
  \multicolumn{1}{l|}{Decode} & Instructions that require no source operands are delayed by \textit{T} cycles on the decode stage. \\ \hline
  \multicolumn{1}{l|}{\multirow{5}{*}{Issue}} & If an instruction with opcode \textit{X} reaches the front of the instruction queue, meaning that it has become the oldest instruction there, then the issue process is stalled until the instruction can be issued (all the dependencies have been met, and computational resources are available). Once this occurs, only that instruction leaves the queue during that cycle. Normal behavior is resumed afterward. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & Every instruction whose opcode is \textit{X} can be retired from the instruction queue only when it becomes the oldest instruction there. A similar bug was found in the Intel Xeon Processors errata~\cite{intel_xeon_errata}. Its description can be found under ``POPCNT instruction may take longer to execute than expected''. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & If the operands of instructions with opcode \textit{X} depend on the result of an instruction with opcode \textit{Y}, the issuing of the former is stalled by \textit{T} cycles after its operands are ready. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & If less than \textit{N} slots are available in the instruction queue, delay the next instruction by \textit{T} cycles. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & The pointer signaling the front of the instruction queue is randomly shifted by \textit{N} positions. This event occurs with a frequency of \textit{T} times per 1000 cycles. \\ \hline
  \multicolumn{1}{l|}{Rename} & All instructions whose opcode is \textit{X} are marked as serializing instructions. This causes all subsequent instructions to be stalled until that instruction has been issued. \\ \hline
  \multicolumn{1}{l|}{\multirow{3}{*}{Execute}} & The latency of functional units handling integer operation \textit{X} is increased by \textit{T} cycles. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & The latency of functional units handling floating-point operation \textit{X} is increased by  \textit{T} cycles. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & The latency of functional units handling  ``Single-Instruction Multiple-Data'' operations  \textit{X} is increased by \textit{T} cycles. \\ \hline
  \multicolumn{1}{l|}{Branch} & Branch prediction index table malfunction, effectively reducing the size of the tables by \textit{N} entries. \\ \hline
  \multicolumn{1}{l|}{\multirow{3}{*}{Registers}} & If an instruction with opcode \textit{X} uses physical register \textit{R}, then this instruction is delayed by \textit{T} cycles.  A bug similar to this can be found on Intel 386 DX errata~\cite{intel_386_errata} labeled as ``POPA/POPAD instruction malfunction''. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & After every \textit{N} times a register has been written, delay the following write by \textit{T} cycles. The inspiration for this bug is the one labeled as ``GPMC may stall after 256 write accesses in NAND\_DATA, NAND\_COMMAND, or NAND\_ADDRESS'' found on the TI AM3517 and TI AM3505 ARM processors errata~\cite{TI_am3517_errate}. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & The number of physical registers is reduced by \textit{N}. \\ \hline
  \multicolumn{1}{l|}{\multirow{2}{*}{Load/Store Queue}} & For every \textit{N} requests, the load-queue incorrectly rejects entries stating that it is full. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & For every \textit{N} requests, the store-queue incorrectly rejects entries stating that it is full. \\ \hline
  \multicolumn{1}{l|}{\multirow{2}{*}{Memory}} & After every \textit{N} stores to the same cache line, delay the following write by \textit{T} cycles. \\ \cline{2-2} 
  \multicolumn{1}{l|}{} & The latency of L2 cache is \textit{T} cycles higher than expected. This issue is similar to the documented for NXP MPC7448 RISC processor in its errata~\cite{nxp_7448_errata} labeled as ``L2 latency perfomance issue''. \\ \hline
  \multicolumn{1}{l|}{Re-Order Buffer} & If less than \textit{N} slots are available in the re-order buffer, delay the next instruction by \textit{T} cycles. \\ \hline
  \multicolumn{1}{l|}{Commit} & Every \textit{T} cycles, the maximum number of instructions that the processor is able to commit is reduced by \textit{N} entries during one cycle. \\ \hline

\end{tabular}
}
\end{table*}
\end{scriptsize}

\input{3b_Archs}
\input{3c_Bugs}
\input{3d_Memory_Setup}






