\documentclass[review]{elsarticle}

%\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%\input{Qcircuit}
\usepackage{qcircuit}
\bibliographystyle{plainurl}
%\usepackage{tikz}
%\usepackage{float}
%\usepackage{graphicx}
\usepackage{float}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{hyperref} 
\usepackage{mathrsfs}
\usepackage{graphicx}
\usepackage{float}
\usepackage{color}
\usepackage{braket}
\usepackage{xcolor}
\usepackage{tablefootnote}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{cleveref}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tcolorbox}
 \tcbuselibrary{skins, breakable, listings, theorems}
\usepackage{colortbl}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{Fact}{Fact}
\newtheorem{Remark}{Remark}
\newtheorem{Example}{Example}
\usepackage[margin=1.16in]{geometry}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\renewcommand{\KwData}{ \textbf{Input:}} 
\renewcommand{\KwResult}{ \textbf{Output:}} 
%\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{bm}
%\usepackage{algorithmicx}
%\usepackage{algpseudocode}
%\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%
%\usepackage[margin=1.0in]{geometry}
%\usepackage{setspace}
%\renewcommand{\algorithmicrequire}{ \textbf{Input:}} %Use Input in the format of Algorithm
%\renewcommand{\algorithmicensure}{ \textbf{Output:}} %UseOutput in the format of Algorithm]

\newcommand{\eqdef}{\ensuremath{:=}}
\newcommand{\inbrace}[1]{\left \{ #1 \right \}}
\newcommand{\inparen}[1]{\left ( #1 \right )}
\newcommand{\insquare}[1]{\left [ #1 \right ]}
%\newcommand{\ket}[1]{\ket{\bm{#1}}}
\newcommand{\oracle}[1]{O_{x,#1}}
%\newcommand{\theta}{\theta} 

\newcommand{\MAJ}{\textsc{MAJ}}
\newcommand{\OR}{\textsc{OR}}
\newcommand{\AND}{\textsc{AND}}
%\newcommand{\GAND}{\textsc{and}}
\newcommand{\Parity}{\textsc{PARITY}}
\newcommand{\Th}{\textsc{TH}}
\newcommand{\EXACT}{\textsc{EXACT}}
%\newcommand{\EXACT}{\text{EXACT}}
\newcommand{\Mod}{\textsc{MOD}}
\newcommand{\SUM}{\textsc{SUM}}
\newcommand{\Rp}{\mathcal{R}_p} % p-random restriction
\newcommand{\sgn}{{\mathrm{sgn}}}
%\newcommand{\one}{{\mathbf{1}}}
\newcommand{\one}[1]{{\mathbf{1}_{\{#1\}}}}

\newcommand{\spar}{\mathrm{sparsity}}
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\spn}{\mathrm{span}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\qpoly}{\mathrm{quasipoly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\Bias}{\mathsf{Bias}}
\newcommand{\qmod}{\lceil n(1-\frac{1}{m}) \rceil}

\renewcommand{\star}{*} % nicer-looking than star
\renewcommand{\l}{\ell} % nicer-looking than l
\newcommand{\eps}{\epsilon}
\newcommand{\tildeO}{{\widetilde O}}
\newcommand{\transpose}{{\mathsf{T}}}


\renewcommand{\hat}{\widehat}
\renewcommand{\tilde}{\widetilde}
%\newcommand{\ket}[1]{{\left\vert #1 \right\rangle}}
\newcommand{\inner}[1]{\langle{#1}\rangle}

\newcommand{\B}{\{0,1\}}

\let\OldLambda\lambda
\let\lambda\relax
\DeclareMathOperator{\lambda}{\OldLambda}
\DeclareMathOperator{\FC}{\mathsf{FC}}
\DeclareMathOperator{\D}{\mathsf{D}}
\DeclareMathOperator{\C}{\mathsf{C}}
\DeclareMathOperator{\R}{\mathsf{R}}
\DeclareMathOperator{\Q}{\mathsf{Q}}
\DeclareMathOperator{\UC}{\mathsf{UC}}
\DeclareMathOperator{\RC}{\mathsf{RC}}
\DeclareMathOperator{\QC}{\mathsf{QC}}
\DeclareMathOperator{\s}{\mathsf{s}}
\DeclareMathOperator{\bs}{\mathsf{bs}}
\DeclareMathOperator{\fbs}{\mathsf{fbs}}
\DeclareMathOperator{\adeg}{\mathsf{\widetilde{deg}}}
\let\deg\relax
\DeclareMathOperator{\deg}{\mathsf{deg}}
\DeclareMathOperator{\Adv}{\mathsf{Adv}}
\DeclareMathOperator{\SA}{\mathsf{SA}}
\DeclareMathOperator{\MM}{\mathsf{MM}}
\DeclareMathOperator{\SWA}{\mathsf{SWA}}
\DeclareMathOperator{\GSA}{\mathsf{GSA}}
\DeclareMathOperator{\K}{\mathsf{K}}
\DeclareMathOperator{\Dom}{Dom}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\diag}{diag}

\newcommand{\tR}{\tilde{R}}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the mandatory bibstyle

%\newcommand{\authnote}[2]{\textsuperscript{#1}\footnote{\textsuperscript{#1}#2}}
%\makeatletter
%\newcommand{\nocorauthnote}[1]{\ifx@corref@empty\else\unskip\textsuperscript{#1}\fi@footnotemark@footnotetext}
%\makeatother
\begin{document}
\begin{frontmatter}
\title{On the exact quantum query complexity of $\Mod_m^n$ and $\EXACT_{k,l}^n$}

%\author[1]{Zekun Ye\authnote{1}{\indent {\it E-mail address:} yezekun@smail.nju.edu.cn}}
\author{Zekun Ye\corref{one}}
\cortext[one]{ \indent {\it E-mail address:} yezekun@smail.nju.edu.cn}

\address{State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing 210023, China}


%\address[a2]{Center for Quantum Computing, Peng Cheng Laboratory, Shenzhen, China}
%\address[a2]{Ministry of Education Key Laboratory of Machine Intelligence and Advanced Computing (Sun Yat-sen University), Guangzhou 510006, China}

%\title{On the exact quantum query complexity of $\Mod_m^n$ and $\EXACT_{k,l}^n$}%Two new result about the exact quantum query complexity of symmetric functions} %TODO Please add

%\titlerunning{On the exact quantum query complexity of $\Mod_m^n$ and $\EXACT_{k,l}^n$} %TODO optional, please use if title is longer than one line

%\author{***}{***}{}{}{}
%\authorrunning{***}
%\Copyright{***}
%\author{Zekun Ye}{Nanjing University, Nanjing 210023, China\\yezekun@smail.nju.edu.cn}{}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

%\author{Lvzhou Li}{Institute of Quantum Computing and Computer Science Theory, School of Computer Science and Engineering, Sun Yat-sen University, Guangzhou 510006, China \and Ministry of Education Key Laboratory of Machine Intelligence and Advanced Computing (Sun Yat-sen University), Guangzhou 510006, China \\lilvzh@mail.sysu.edu.cn}{lilvzh@mail.sysu.edu.cn}{}{}



%\category{Track A: Algorithms, Complexity and Games} %optional, e.g. invited paper

%\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{CVIT 2016}
%\EventAcronym{CVIT}
%\EventYear{2016}
%\EventDate{December 24--27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{42}
%\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{document}

%\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
The query model has generated considerable interest in both classical and quantum computing communities. Typically, quantum advantages are demonstrated by showcasing a quantum algorithm with a better query complexity compared to its classical counterpart. Exact quantum query algorithms play a pivotal role in developing quantum algorithms. For example, the Deutsch-Jozsa algorithm demonstrated exponential quantum advantages over classical deterministic algorithms. As an important complexity measure, exact quantum query complexity describes the minimum number of queries required to solve a specific problem exactly using a quantum algorithm. 

In this paper, we consider the exact quantum query complexity of the following two $n$-bit symmetric functions: $\Mod_m^n(x) = |x| \bmod m$ and
$$
\EXACT_{k,l}^n(x) = 
\begin{cases}
1, &\text{if }|x| \in \{k,l\}, \\
0, &\text{otherwise},
\end{cases}
$$
where $|x|$ is the number of $1$'s in $x$. Our results are as follows:
\begin{itemize}
\item 
We present an optimal quantum algorithm for computing $\Mod_m^n$, achieving a query complexity of $\lceil n(1-\frac{1}{m}) \rceil$ for $1 < m \le n$. This settles a conjecture proposed by Cornelissen, Mande, Ozols and de Wolf (2021). Based on this algorithm, we show the exact quantum query complexity of a broad class of symmetric functions that map $\B^n$ to a finite set $X$ is less than $n$.
\item 
When $l-k \ge 2$, we give an optimal exact quantum query algorithm to compute $\EXACT_{k,l}^n$ for the case $k=0$ or $k=1,l=n-1$. This resolves the conjecture proposed by Ambainis, Iraids and Nagaj (2017) partially. 
\end{itemize}

\end{abstract}
\begin{keyword}
query complexity, exact algorithms, quantum computing
\end{keyword}
\end{frontmatter}


\section{Introduction}
The quantum query model is a computational model that describes the power and limitations of quantum algorithms in solving problems in a query-based setting. It has demonstrated the powerful ability of a quantum computer to perform certain computational tasks more efficiently than a classical computer, such as Simon's algorithm \cite{simon1994power} and Shor's integer factorization algorithm \cite{shor1994algorithms}. Moreover, the quantum query model has found applications in a variety of areas, including cryptography \cite{LZ19, YZ21}, optimization \cite{GAW19, CCLW20}, and learning theory \cite{LW19, ACL+21}.

The quantum query model can be discussed in two main settings: the exact setting and the bounded-error setting. A quantum query algorithm computes a function $f$ exactly if its output equals $f(x)$ with probability 1 for any input $x$. In this case, the algorithm is called an exact quantum algorithm. If the algorithm's output equals $f(x)$ with a probability at least $\epsilon$ (where $\epsilon$ is a constant greater than 1/2) for any input $x$, it is said to compute $f$ with bounded error. The quantum query complexity of $f$ is the minimal number of queries required by a quantum algorithm to compute $f$ on the worst input. The quantum query complexities of $f$ in the exact and bounded error settings are denoted by $Q_E(f)$ and $Q_{\epsilon}(f)$, respectively. Similarly, in the classical query model, we can define the deterministic query complexity and the randomized query complexity. The deterministic query complexity of $f$, denoted by $D(f)$, is the minimum number of queries required by a classical deterministic algorithm to compute $f$ on the worst input.
The randomized query complexity of $f$, denoted by $R_{\epsilon}(f)$, is the minimum number of queries required by a classical randomized algorithm to compute $f$ with bounded error $\epsilon$ on the worst input. A comprehensive survey of the query model can be found in \cite{buhrman2002complexity}. In this paper, we focus primarily on the quantum query model of the exact setting. 


Symmetric functions are an important class of functions that arise in a wide range of applications, from coding theory to cryptography. Formally, a function is \emph{symmetric} if $f(x_0,...,x_{n-1}) = f(x_{\pi(0)},...,x_{\pi(n-1)})$ for any permutation $\pi \in S_n$, where $S_n$ is the symmetric group. For example, the parity function is a symmetric function, since it returns 1 if and only if the number of 1's in the input is odd. Other examples of symmetric functions include the majority function and the threshold function.
In this paper, we focus on the symmetric functions that map $\B^n$ to a finite set $X$.

If a function is only defined for a restricted range of inputs, then we say the function is
\emph{partial}. Otherwise, the function is \emph{total}. The study of the exact quantum query complexity of partial symmetric functions has a long history. In 1992, Deutsch and Jozsa \cite{DJ92} gave a partially symmetric Boolean function for the first time. The goal of the function is to distinguish $|x| = n/2$ or $|x| = \{0,n\}$. There exists a quantum algorithm, called the Deutsch-Jozsa algorithm, to compute this function with one query exactly, while the optimal deterministic algorithm requires at least $\frac{n}{2}+1$ queries \cite{CEMM98}. Moreover, there is a decision version of the famous Grover's search problem \cite{Grover96}: distinguish $|x| = 0$ or $1$. An exact quantum algorithm for this problem exists using $O(\sqrt{n})$ queries, whereas the optimal deterministic algorithm requires $n$ queries \cite{Hoy00,Lon01,BHMT02}. In 2018, Qiu and Zheng \cite{QZ18} proved that when $n$ is an even number, distinguishing $|x| = \frac{n}{2}$ or $|x| = \{0,1,..,k,n-k,n-k+1,...,n\}$ is $k+1$, while the deterministic query complexity is $\frac{n}{2}+ k+1$. In 2020, Qiu and Zheng \cite{QZ20} studied the exact quantum query complexity for the symmetric partial Boolean functions with degree 1 or 2, and presented the exact quantum query complexity of a symmetric partial Boolean function $f$ is 1 if and only if $f$ can be computed by the Deutsch-Jozsa algorithm. He, Sun, Yang, and Yuan \cite{HSY+18} established the asymptotically optimal bound for the exact quantum query complexity of distinguishing whether $|x|=k$ or $l$ $(k < l)$. Furthermore, in most cases, the gap between the upper and lower bounds provided by them is no more than 1.  %while the deterministic query complexity is $n-l+k+1$. 
With respect to the symmetric functions with large alphabet inputs, Li and Li \cite{LL22} studied the promised element distinctness problem and gave an optimal exact quantum algorithm.

% symmetric Boolean functions are a subclass of symmetric Boolean functions that are 


%In the discussion of total symmetric Boolean functions, since the deterministic query complexity of any $n$ outlier fully symmetric Boolean function is $n$, in order to analyze the quantum advantage, we only need to discuss the quantum query complexity. 
%On the one hand, the best-known quantum algorithms so far require at least $\frac{n}{2}$ lookups for any non-nominal completely symmetric Boolean function. On the other hand, combining the work of von zur Gathen and Roche\cite{vzGR97} with the polynomial approach yields a quantum lower bound \cite{BBC+01}, the following conclusions can be drawn: the exact quantum algorithm to calculate any $n$ non-value complete symmetric Boolean function needs at least $\frac{n}{2}-O(n^{0.548}) $ queries. Furthermore, Ambainis et al. \cite{AGZ15} demonstrated that, Except for $\text{AND}_n$ and its isomorphic functions, the exact quantum query complexity of all other $n$-bit complete Boolean symmetric functions is less than $n$. The above results are an overall description of the exact quantum query complexity of complete Boolean symmetric functions, while 



The exact quantum query complexity of total symmetric functions has also been studied extensively. On the one hand, the best known exact quantum algorithm for any $n$-bit non-constant  symmetric Boolean function requires at least $\frac{n}{2}$ queries. On the other hand, combining the lower bound on the degree of symmetric Boolean functions \cite{vzGR97}, the best known result about the difference between consecutive primes \cite{BHP01}
with polynomial methods \cite{BBC+01}, it leads to the following conclusion: any exact quantum algorithm for computing any $n$-bit non-constant symmetric Boolean function requires at least $\frac{n}{2}-O(n^{0.525})$ queries. Moreover, Montanaro, Jozsa and Mitchison \cite{MJM15} indicated the exact quantum query complexity of all symmetric Boolean functions on up to 6 bits by numerical results. Chen, Ye and Li \cite{CYL20} proved $\Parity_1$ and $\Parity_2$ are the only two total Boolean functions, up to isomorphism, that can be computed by one-query quantum algorithm exactly. Ambainis, Gruska and Zheng \cite{AGZ15} showed $\AND_n$ is the only $n$-bit Boolean function, up to isomorphism, that requires $n$ quantum queries to compute exactly. 
Totally, while the deterministic query complexity of all non-constant total symmetric functions is $n$ \cite{Aaronson03,MJM15,AGZ15},
there are only a few total symmetric functions whose exact quantum query complexity is fully characterized, which are summarized as Table \ref{table_exact} (up to isomorphic). Note that the functions $\neg\OR_n$ and $\AND_n$  are special cases of $\EXACT_k^n$ when $k = 0$ and $n$.

\begin{table}
\caption{The exact quantum query complexity of several symmetric functions}
\label{table_exact}
\begin{center}

\begin{tabular}{|l|p{7cm}|l|}
\hline
Functions & Definition & Exact Quantum Query Complexity \\
\hline
$\Parity_n$ & $\Parity(x) = |x| \bmod 2$ & $\lceil n/2 \rceil$ \cite{CEMM98,FGGS1998,BBC+01}\\
\hline
$\EXACT_k^n$ & $
\EXACT_k^n(x) = 
\begin{cases}
1, &\text{if }|x| = k, \\
0, &\text{otherwise}.
\end{cases}
$ & $\max\inbrace{k,n-k}$ \cite{AIS13}\\
\hline
$\Th_k^n$ & $
\Th_k^n(x) = 
\begin{cases}
1, &\text{if }|x| \ge k, \\
0, &\text{otherwise}.
\end{cases}
$ & $\max\inbrace{k,n-k+1}$ \cite{AIS13}\\
\hline
\end{tabular}
\end{center}
\end{table}








There are some total symmetric functions that have been studied, but the exact quantum query complexity is not fully characterized, including $\Mod_m^n$ and $\EXACT_{k,l}^n$. 
Specifically, $\Mod_m^n:\B^n\rightarrow \{0,1,...,m-1\}$, defined as $\Mod_m^n(x) = |x| \bmod m$, where $1 < m \le n$, is a generalization of $\Parity_n$. Recently, Cornelissen, Mande, Ozols and de Wolf \cite{CMO+21} showed that when the prime factor of $m$ is only 2 or 3, $Q_E(\Mod_m^n) = \lceil n(1-1/m)\rceil$. Moreover, for any $m$, they proved $Q_E(\Mod_m^n) \ge \lceil n(1-1/m)\rceil$. Then they proposed the following conjecture:
\begin{conjecture}[\cite{CMO+21}]\label{con:mod}
Let $1 < m \le n$ be integers. The exact quantum query complexity of computing the Hamming weight of an $n$-bit string modulo $m$ is $\qmod$.
\end{conjecture}
Afterward, using variational learning algorithms, Wu, Hou, Zhang, Li and Zeng \cite{WHZ+22} suggested that when $m = n = 5$, there exists a quantum algorithm using 4 queries to compute $\Mod_m^n$, which is consistent with Conjecture \ref{con:mod} in the case of $m = n = 5$.

For the function $\EXACT_{k,l}^n$, which aims to determine whether $|x| \in \inbrace{k,l} (k < l)$, Ambainis, Iraids and Nagaj \cite{AIN17} gave the best known result:
$\max\{n-k,l\}-1 \le Q_E(\EXACT_{k,l}^n) \le \max\{n-k,l\}+1$. Moreover, they also showed the following special cases are tight: $Q_E(\EXACT_{k,k+1}^{2k+1}) = k+1$; if $l-k \in \{2,3\}$, then $Q_E(\EXACT_{k,l}^n) = \max\{n-k,l\}-1$. Finally, they proposed the following conjecture:
\begin{conjecture}[\cite{AIN17}]\label{con:kl}
If $l-k \ge 2$, then $Q_E(\EXACT_{k,l}^n) = \max\{n-k,l\}-1$.
\end{conjecture}
For $\EXACT_{k,l}^n$, Wu et al. \cite{WHZ+22} also gave the numerical result about some instances of small sizes. For the case $l-k = 2$, $n$ is even and $k,l$ is symmetrically distributed around n/2, the numerical result is consistent with Conjecture \ref{con:kl}. 

In this paper, we consider the above two conjectures and study the exact quantum query complexity of $\Mod_m^n$ and $\EXACT_{k,l}^n$. Our motivation is as follows:
\begin{itemize}
\item The exact quantum query complexity of $\Mod_m^n$ and $\EXACT_{k,l}^n$ are not fully characterized. Thus, we aim to improve the best-known result of these two functions.
\item In the quantum model, we say a function is \emph{evasive} if its exact quantum query complexity equals its input size. $\Mod_m^n$ is a key function to analyze the quantum evasiveness of the symmetric functions with large alphabet output. By studying the exact quantum query complexity of $\Mod_m^n$, we can better understand the quantum evasiveness of a broad class of symmetric functions.
\item At present, there are quite a few exact quantum algorithm design techniques. It is interesting to obtain more exact quantum algorithm design paradigms.
\end{itemize}
Our results are the following theorems and corollary:
\begin{theorem}\label{th:mod}
For $1 < m \le n$, there exists an exact quantum query algorithm to compute $\Mod_m^n$ with $\qmod$.
\end{theorem}
\begin{corollary}\label{th:lessn}
For any symmetric functions $f:\B^n \rightarrow X$, where $X$ is a finite set, let $F(|x|) = f(x)$ for any $x \in \B^n$. If there exists $k \in [n]$ such that $F(0) = F(k)$ and $F(n-k) = F(n)$, then the exact quantum query complexity of $f$ is less than $n$. Moreover, the upper bound is tight, i.e., there exists a symmetric function $f$ satisfying the above conditions whose exact quantum query complexity is $n-1$.
\end{corollary}
\begin{theorem}\label{th:kl}
If $l-k \ge 2$, then the exact quantum query complexity of $\EXACT_{k,l}^n$ is $\max\inbrace{n-k,l}-1$ for the case $k=0$ and the case $k=1,l=n-1$. 
\end{theorem}
Theorem \ref{th:mod} shows that there exists a quantum query algorithm to compute $\Mod_m^n$ with $\lceil n(1-1/m) \rceil$ exactly. Thus, we show that the lower bound given by \cite{CMO+21} is tight, proving Conjecture \ref{con:mod}.
Compared to the algorithm proposed in \cite{CMO+21}, our algorithm is more natural and suitable for any $1 < m \le n$. Furthermore, Corollary \ref{th:lessn} proves a wide range of symmetric functions is not evasive in the quantum model based on the above algorithm.
Theorem \ref{th:kl} shows when $l-k \ge 2$, the exact quantum query complexity of $\EXACT_{k,l}^n$ is $\max\inbrace{n-k,l}-1$ for the case $k=0$ or $k=1,l=n-1$. Thus, we partially prove Conjecture $\ref{con:kl}$ and give a tighter characterization to the exact quantum query complexity of $\EXACT_{k,l}^n$.

The remainder of the paper is organized as follows. In Section \ref{sec:pre}, we review some definitions and notations used in this paper. In Section \ref{sec:mod}, we give an optimal exact quantum algorithm to compute $\Mod_m^n$ and analyze the quantum evasiveness of a broad class of symmetric functions. In Section \ref{sec:kl}, we discuss the exact quantum query complexity of $\EXACT_{k,l}^n$. Finally, a conclusion is made in Section \ref{sec:con}.

\section{Preliminary}\label{sec:pre}
This section first gives some formal definitions of the quantum query model. For convenience, for an $n$-bit Boolean string $x \in \B^n$, we let $x= x_0\cdots x_{n-1}$.
\begin{definition}[POVM \cite{NC15}]
A set of operators $\inbrace{E_j}$ is a POVM (Positive Operator-Valued Measure) if each operator $E_j$ is positive and $\sum_j E_j = I$. If a measurement  described by $\inbrace{E_j}$ is performed upon a quantum state $\ket{\psi}$, then the probability of obtaining outcome $j$ is given by $p(j) = \langle \psi | E_j | \psi \rangle$.
\end{definition}
\begin{definition}[Quantum query algorithms]
\label{def:qqa}
A quantum query algorithm $\mathcal{A}$ consists of an initial  state $\ket{\psi_0}$, a unitary operator sequence $U_TO_xU_{T-1}O_x\cdots O_xU_0$ and a POVM $\{E_j\}$, where $U_i$'s are fixed unitary operators, and $O_x$ is a quantum query oracle dependent on $x$, which is defined as $O_x \ket{i}\ket{b} = \ket {i}\ket{b \oplus x_i}$, where $i \in \{0,...,n-1\}$, $b \in \{0,1\}$. The algorithm process is as follows:
\begin{itemize}
    \item Prepare the initial state $\ket{\psi_0}$;
    \item Perform unitary operations $U_0,O_x,...,O_x,U_T$ sequentially on $\ket{\Psi_0}$ to obtain the quantum state $\ket{\Psi_x} = U_TO_xU_{T-1}O_x\cdots O_xU_0 \ket{\Psi_0}$;
\item Perform the measurement described by $\{E_j\}$ upon the quantum state $\ket{\Psi_x}$, %. Then the probability of outcome $m$ is given by $p(m) = \langle \Psi_x | E_j | \Psi_x \rangle$. We 
and use the measurement result as the output $\mathcal{A}(x)$ of the algorithm.
\end{itemize}
The query complexity of the algorithm is defined as the number of query oracle $O_x$ used in the algorithm.
\end{definition}

As mentioned in \cite{AIS13}, a quantum algorithm can also be described as a recursive algorithm with the following structure:
First, perform unitary operation $U_1O_xU_0$ and measure; second, depending on the measurement result, call a smaller instance of the algorithm. Such a recursive algorithm can be transformed into a quantum query algorithm described as Definition \ref{def:qqa} with the same query complexity.
\begin{definition}[Exact quantum algorithms]
Given function $f:\B^n \rightarrow X$, where $X$ is a finite set, if a quantum algorithm $\mathcal{A}$ satisfies $\mathcal{A}(x) = f(x)$ for any $x \in \B^n$, then $\mathcal{A}$ is an exact quantum algorithm to compute $f$.
\end{definition}

\begin{definition}[Exact quantum query complexity]
For function $f:\B^n \rightarrow X$, where $X$ is a finite set. The exact quantum query complexity of $f$, $Q_E(f)$, is the minimal number of queries an exact quantum algorithm requires to compute $f$. 
%on the worst input.
%the query complexity of the optimal exact quantum algorithm to compute $f$.
\end{definition}

\begin{definition}[Univariate version of symmetric functions]
For a symmetric function $f: \B^n \rightarrow X$, where $X$ is a finite set, we define $F: \inbrace{0,1,...,n} \rightarrow X$ as $F(x) = f(|x|)$ for any $x \in \B^n$, where $|x|$ is the Hamming weight of $x$, i.e., the number of $1$'s in $x$. 
\end{definition}

\begin{definition}[Majority index]
Suppose $x \in \B^n$ and $|x| \neq \frac{n}{2}$, we say $i$ is a majority index of $x$ if i) $|x| >  \frac{n}{2}$ and $x_i = 1$, or ii) $|x| < \frac{n}{2}$ and $x_i = 0$.
\end{definition}
Next, we give some notations used in this paper. %For any positive integer $t$, let $[t] = \inbrace{1,\dots,t}$. 
Let $\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ and $\ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$.
\begin{comment}
$$
\begin{aligned}
&\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, & &\ket{1} = \begin{pmatrix} 0 \\ 1  \end{pmatrix}, \\
&\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}), & & \ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1}).\\
\end{aligned}
$$
\end{comment}
Then $O_x \ket{i}\ket{+} = \ket{i}\ket{+}$ and $O_x \ket{i}\ket{-} = (-1)^{x_i}\ket{i}\ket{-}$.
For any angle $\theta$, let 
$$
\begin{aligned}
\ket{\theta}^{\circ} &=  \cos \theta \ket{+} +\sin \theta \ket{-}.\\
%\ket{\theta^{\circ}} &= -\sin\theta\ket{+}+\cos\theta \ket{-}.
\end{aligned}
$$
If $x_i =0$, then $O_x \ket{i}
\ket{\theta}^{\circ} = \ket{i}
\ket{\theta}^{\circ} $; if $x_i = 1$, then $O_x \ket{i}
\ket{\theta}^{\circ} = \ket{i}
\ket{-\theta}^{\circ}$.
The rotation operation $R_{\theta}$ is defined as
$$R_{\theta} \ket{\eta}^{\circ} =
%\cos (\eta+\theta) \ket{+} +\sin (\eta+\theta) \ket{-}.
\ket{\theta+\eta}^{\circ}
$$
for any angle $\eta$. For positive integer $n$, let $[n] = \inbrace{1,\dots,n}$ and $\mathbb{Z}_n = \inbrace{0,1,...,n-1}$.
For any $a\in \mathbb{Z}_n$, the permutation operation $U_a$ is defined as 
$$
U_a\ket{i} = \ket{i+a \bmod n}.
$$
Let 
\begin{equation}\label{eq:oracle}
O_{x,a,\theta} = (U_{a} \otimes R_{a\theta/2})O_x (U_{-a} \otimes R_{-a\theta/2}). 
\end{equation}
For $i \in \mathbb{Z}_n$, we have
$$
O_{x,a,\theta}\ket{i}\ket{0}^{\circ} = \ket{i}\ket{a\theta x_{i-a}}^{\circ},
$$
where
%$$
%\theta_{i-a} =
%\begin{cases} 
%0 &\text{ if }x_{i-a} = 0, \\
%\theta & \text{ if }x_{i-a} = 1, \\
%\end{cases}
%$$
%and 
the subtraction operator is with modulo $n$.
%$$
%\SUM\ket{0}\ket{\eta_1}\ket{\eta_2}\cdots\ket{\eta_n} = \ket{\sum_{i=1}^n\eta_i}\ket{\eta_1}\ket{\eta_2}\cdots\ket{\eta_n}.
%$$
We select the unitary operation $\SUM$ such that
\begin{equation}
\label{eq:sum}
\SUM\ket{0}^{\circ}\ket{\eta_1}^{\circ}\ket{\eta_2}^{\circ}\cdots\ket{\eta_{n-1}}^{\circ} = |\sum_{i=1}^{n-1}{{\eta_i}\rangle}^{\circ}\ket{\eta_1}^{\circ}\ket{\eta_2}^{\circ}\cdots\ket{\eta_{n-1}}^{\circ}
\end{equation}
for any angle $\eta_1,...,\eta_{n-1}$.
For $j \in \{0,...,n-1\}$, let 
$$
\begin{aligned}
\ket{\phi_{j}} &= \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1} \ket{i}\ket{ij\theta}^{\circ}, \\
\ket{\phi_{j}^*} &= \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1} \ket{i}\ket{ij\theta+\pi/2}^{\circ},\\
\end{aligned}
$$
where $\theta = \frac{2\pi}{n}$. Then $\langle \phi_j | \phi_j^* \rangle = 0$.
%, 
For any $j,k \in \{0,...,n-1\}$ and $j\neq k$, we have $\sin \frac{n(j-k)\theta}{2} = 0$. Thus, by Fact \ref{fact:sum_tri}, we have
$$
\begin{aligned}
\langle \phi_j | \phi_k \rangle = \langle \phi_j^* | \phi_k^* \rangle  &= \frac{1}{n}\sum_{i=0}^{n-1}\cos{i(j-k)\theta}& & = 0. \\
\langle \phi_j | \phi_k^* \rangle &= -\frac{1}{n}\sum_{i=0}^{n-1}\sin{i(j-k)\theta}& & = 0. \\
\end{aligned} 
$$
As a result, $\inbrace{\ket{\phi_0},...,\ket{\phi_{n-1}},\ket{\phi_0^*},...,\ket{\phi_{n-1}^*}}$ is an orthonormal basis. 
\begin{Fact}[\cite{jeffrey2008handbook}]\label{fact:sum_tri}
If $\sin \frac{x}{2} \neq 0$, we have
$$
\begin{aligned}
\sum_{k=0}^{n-1}\sin{kx} &= \frac{\sin{\frac{nx}{2}}\sin{\frac{(n-1)x}{2}}}{\sin\frac{x}{2}}, \\
\sum_{k=0}^{n-1}\cos{kx} &= 
\frac{\sin{\frac{nx}{2}}\cos{\frac{(n-1)x}{2}}}{\sin\frac{x}{2}}.
\end{aligned}
$$
\end{Fact}
Let $I_{d}$ be the identity operator in a $d$-dimension Hilbert space. Let 
$
P'_j =
\ket{\phi_j}\bra{\phi_j}+\ket{\phi_j^*}\bra{\phi_j^*}
$
for $j \in \inbrace{0,...,m-1}$. Then for any $j \in \inbrace{0,...,m-1}$, $P'_j$ is a projection operator and $\sum_{j=0}^{m-1} P'_j = I_{2n}$. Thus, $\inbrace{P'_j}$ is a POVM. For any $j \in \inbrace{0,...,m-1}$, let 
\begin{equation}\label{eq:P_j}
P_j = P'_j \otimes I_{2^{n-1}}.
\end{equation}
Then
$\inbrace{P_j}$ is also a POVM.





\section{Computing the Hamming weight modulo $m$}\label{sec:mod}
First, we give Algorithm \ref{algorithm1} to compute $\Mod_n^n$, where $\theta = \frac{2\pi}{n}$. We verify the correctness of Algorithm \ref{algorithm1} as follows. For any $x\in \{0,1\}^n$, let $S_x = \{i:x_i = 1\}$. 
If $i-a = j$ for some $j \in S_x$, then $a\theta x_{i-a} = (i-j)\theta$; otherwise, $a\theta x_{i-a} = 0$. Thus, $\sum_{a=0}^{n-1}a\theta x_{i-a} = \sum_{j \in S_x}(i-j)\theta$. If $|x| \bmod m = k$, then 
$$
\sum_{j \in S_x}(i-j)\theta = ik\theta+\eta_x
$$
for some angle $\eta_x$.
Thus, 
$$
\begin{aligned}
\ket{\psi_n} &= \frac{1}{\sqrt{n}}\sum_{i=0}^{n-1}\ket{i}\ket{ik\theta+\eta_x}^{\circ}\ket{1\theta x_i}^{\circ}\ket{2\theta x_{i-1}}^{\circ}\cdots \ket{(n-1)\theta x_{i-(n-1)}}^{\circ}          \\
&=\frac{1}{\sqrt{n}}\sum_{i=0}^{n-1}\cos{\eta_x}\ket{i}\ket{ik\theta}^{\circ}\ket{1\theta x_i}^{\circ}\ket{2\theta x_{i-1}}^{\circ}\cdots \ket{(n-1)\theta x_{i-(n-1)}}^{\circ} \\
&+ \frac{1}{\sqrt{n}}\sum_{i=0}^{n-1}\sin{\eta_x}\ket{i}\ket{ik\theta+\pi/2}^{\circ}\ket{1\theta x_i}^{\circ}\ket{2\theta x_{i-1}}^{\circ}\cdots \ket{(n-1)\theta x_{i-(n-1)}}^{\circ}. 
\end{aligned}
$$
Finally, the probability of obtaining the measurement result $k$ is
$$
\langle \psi_n | P_k | \psi_n \rangle = 
\frac{1}{n}\sum_{i=0}^{n-1} (\cos^2\eta_x+\sin^2\eta_x) =1. 
$$
Thus, the algorithm will output $k$ with the probability 1, i.e., Algorithm \ref{algorithm1} always outputs the correct result.

\begin{algorithm}
			\caption{Compute $\Mod_n^n$.}
			\label{algorithm1}
			\KwIn{$x\in\B^n$;}
			\KwOut{$|x| \bmod n$.}
			\begin{enumerate}
				\item Prepare initial state $\ket{\psi_0} = \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1} \ket{i}\ket{0}^{\otimes n}$, which consists of an $n$-dimensional qudit and $n$ ancillary qubits.
				\item For $a =1$ to $n-1$, 
				perform unitary operation $O_{x,a,\theta}$ given by Equation (\ref{eq:oracle})
				in the qudit and the $a+1$-th ancillary qubit sequentially to obtain the state
				$$
				\frac{1}{\sqrt{n}}\sum_{i=0}^{n-1} \ket{i}\ket{0}^{\circ}\ket{1\theta x_{i-1}}^{\circ}\ket{2\theta x_{i-1}}^{\circ}\cdots \ket{(n-1)\theta x_{i-(n-1)}}^{\circ}.
				$$
				\item Perform $\SUM$ operations given by Equation (\ref{eq:sum}) in all the ancillary qubits and obtain the final state $$
				\ket{\psi_n} = 
				\frac{1}{\sqrt{n}}\sum_{i=0}^{n-1} \ket{i}
			|\sum_{a=0}^{n-1}{a\theta x_{i-a}\rangle}^{\circ}
			\ket{1\theta x_i}^{\circ}\ket{2\theta x_{i-1}}^{\circ}\cdots \ket{(n-1)\theta x_{i-(n-1)}}^{\circ}.
				$$
				\item Perform the measurement described by $\inbrace{P_j}$ defined in Equation (\ref{eq:P_j}) upon the quantum state $\ket{\psi_n}$, and then output the measurement result. 
			\end{enumerate}
	\end{algorithm}

%We analyze the number of queries used in Algorithm \ref{algorithm1} as follows. Note that if $a = 0$, then $O_{x,a,\theta} = I$; if $a \neq 0$, then we use unitary gates $U_{-a},R_{-a\theta/2},O_x,R_{a\theta/2},U_a$ to construct
%$O_{x,a,\theta}$ as Eq. (\ref{eq:oracle}).
Since we have $O_{x,a,\theta} = (U_{a} \otimes R_{a\theta/2})O_x (U_{-a} \otimes R_{-a\theta/2})$ as Equation (\ref{eq:oracle}), the number of query oracle $O_x$ used in Algorithm \ref{algorithm1} is $n-1$. 

Next, for $1 < m < n$, let $c = \lfloor\frac{n}{m}\rfloor$ and $n = cm+q$. Then $0 \le q < m$. 
We give Algorithm \ref{algorithm2} to compute $|x| \bmod m$. The algorithm procedure is as follows. i) If $q = 0$, we partition $x$ into $m$-bit substrings $x^{(0)},...,x^{(c-1)}$. For any $0 \le i \le c-1$, we compute $b_i = |x^{(i)}| \bmod m$ by Algorithm \ref{algorithm1}. Finally, we output $(\sum_{i=0}^{c-1} b_i) \bmod m$. ii) If $q \neq 0$, we partition $x$ into $c$ $m$-bit substrings $\inbrace{x^{(0)},...,x^{(c-1)}}$ and one $q$-bit substring $x^{(c)}$. For $0 \le i \le c-1$, we compute $b_i = |x^{(i)}| \bmod m$ by Algorithm \ref{algorithm1}. Then we query all the elements in $x^{(c)}$ and compute $b_c = |x^{(c)}| \bmod m$. Finally, we output $\inparen{\sum_{i=0}^c b_i} \bmod m$. We verify the correctness of Algorithm \ref{algorithm2}. If $q = 0$, then 
$$
\begin{aligned}
|x| \bmod m &= \inparen{\sum_{i=0}^{c-1} |x^{(i)}|} \bmod m \\
&= \inparen{\sum_{i=0}^{c-1} \inparen{|x^{(i)}| \bmod m}} \bmod m \\
&= \inparen{\sum_{i=0}^{c-1} b_i} \bmod m.
\end{aligned}
$$
If $q > 0$, then we have $|x| \bmod m = \inparen{\sum_{i=0}^{c} b_i} \bmod m$ similarly. Thus, Algorithm \ref{algorithm2} always gives the correct output. Moreover, the number of queries in Algorithm is $c(m-1)+q = n-c = \lceil n(1-\frac{1}{m})\rceil$.
	
\begin{algorithm}
\caption{Compute $\Mod_m^n$.}
\label{algorithm2}

			\KwIn{$x\in\B^n$, integers $m,c,q$ such that $1 < m < n$, $c = \lceil \frac{n}{m} \rceil$ and $n = cm+q$;}
			\KwOut{$|x| \bmod m$.}
%\begin{algorithmic}[1]
\For{$i = 0 \to c-1$}{
 Let $x^{(i)} = x_{im}\cdots x_{(i+1)m-1}$\;
 Compute $b_i = |x^{(i)}| \bmod m$ by Algorithm \ref{algorithm1}\;
}
\eIf{$q=0$}{\Return $(\sum_{i=0}^{c-1} b_i) \bmod m$;}{
Let $x^{(c)} = x_{cm}\cdots x_{n-1}$\;
 Query all the elements in $x^{(c)}$ and let $b_c = |x^{(c)}|$\;
 \Return $\inparen{\sum_{i=0}^c b_i} \bmod m$;
}
%\end{algorithmic}
\end{algorithm}

The above results show that for any $1 < m \le n$, there exists an exact quantum query algorithm to compute $\Mod_m^n$ with $\qmod$ queries, which implies Theorem \ref{th:mod}.
Since Cornelissen et al. \cite{CMO+21} showed that any quantum algorithm needs $\lceil n(1-\frac{1}{m})\rceil$ queries to compute $|x| \bmod m$ exactly, our algorithm is optimal and Conjecture \ref{con:mod} is proved.
 

As a corollary, %we can compute $|x| \bmod n$ using $n-1$ queries for $x\in\B^n$. Furthermore, 
we can use less than $n$ quantum queries to compute any symmetric function $f:\B^n \rightarrow X$ such that $F(0) = F(k)$ and $F(n-k) = F(n)$ for some $k \in [n]$, where $F$ is the univariate version of $f$. 
\begin{proof}[Proof of Corollary \ref{th:lessn}]
If $k = n$, we compute $a = |x| \bmod n$ using $n-1$ quantum queries by Algorithm \ref{algorithm1} and then $f(x) = F(a)$. If $k \in \inbrace{1,...,n-1}$, we give Algorithm \ref{al:lessn} to compute $f$. The algorithm procedure is as follows. First, we partition $x$ into two substrings $x' \in \B^{n-k}$ and $x'' \in \B^k$. Then we compute $a = |x'| \bmod (n-k)$ and $b = |x''| \bmod k$ by Algorithm \ref{algorithm1}. Then we discuss the following cases:
\begin{itemize}
    \item If $a\neq 0, b \neq 0$, then $|x| = a+b$.
    \item If $a \neq 0,b=0$, then we query $x_{n-k}$ to determine $|x''| = 0$ or $k$, and thus determine $|x|$.
    \item If $a=0,b \neq 0$, the case is similar to the above case.
    \item  if $a=0,b=0$, then we query $x_{0}$. If $x_0 = 0$, then $|x| = 0$ or $k$; if $x_0 = 1$, then $|x| = n-k$ or $n$.
\end{itemize}







\begin{algorithm}
\caption{Compute $f$} % such that $F(0) = F(k)$ and $F(n-k) = F(n)$ for some $1 \leq k \leq n-1$}
\label{al:lessn}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

%\Input{$x \in \B^n$;}
\KwIn{$x \in \B^n$, a symmetric function $f:\B^n \rightarrow \B$ such that $F(0) = F(k)$ and $F(n-k) = F(n)$ for some $k \in [n]$, where $F$ is the univariate version of $f$;}
\Output{$f(x)$.}

Let $x' = x_0\cdots x_{n-k-1},x'' = x_{n-k}\cdots x_{n-1}$;

Compute $a = |x'| \bmod (n-k)$ and $b = |x''| \bmod k$ using Algorithm \ref{algorithm1};

\Switch{$(a, b)$}{
\Case{$(a \neq 0, b \neq 0)$}{
$f(x) = F(a+b)$;
}
\Case{$(a \neq 0, b = 0)$} {
Query $x_{n-k}$\;
\lIf{$x_{n-k} = 0$}{$f(x) = F(a)$}\lElse{$f(x) = F(a + k)$}
}
\Case{$(a = 0, b \neq 0)$} {
Query $x_0$\;
\lIf{$x_{0} = 0$}{$f(x) = F(b)$}\lElse{$f(x) = F(n-k+b)$}
}
\Case{$(a = b = 0)$} {
Query $x_0$\;
\lIf{$x_{0} = 0$}{$f(x) = F(0)$}\lElse{$f(x) = F(n-k)$}
}
}
\end{algorithm}
The correctness of Algorithm \ref{al:lessn} is not hard to verify. Moreover, the number of queries of the algorithm is at most $(n-k-1)+(k-1)+1 = n-1$, i.e., $Q_E(f) \le n-1$. Since $Q_E(\Mod_n^n) = n-1$, the above bound is tight. %sThus we prove Corollary \ref{th:lessn}.
\end{proof}

Furthermore, Ambainis et al. \cite{AGZ15} proved that the exact quantum query complexity of a total symmetric Boolean function $f:\{0,1\}^n \rightarrow \{0,1\}$ is $n$ if and only if $f$ is isomorphic to $\AND_{n}$ function. Correspondingly, we conjecture there exists a generalized characterization to all total symmetric functions $f:\{0,1\}^n \rightarrow X$. %Let $F : \inbrace{0,...,n} \rightarrow X$ be defined as $F(|x|) = f(x)$ for any $x \in \B^n$ which is the univariate function with respect to $F$. 
Thus we give the following conjecture:

\begin{conjecture}\label{con1}
Given a total symmetric function $f:\{0,1\}^n \rightarrow X$, where $X$ is a finite set. Let $F$ be the univariate version of $f$, the exact quantum query complexity of $f$ is $n$ if and only if one of the following conditions satisfies:
\begin{itemize}
    \item [i)] $F(0) \neq F(i)$ for any $i \in [n]$; %\label{condition1}
     \item [ii)] $F(n) \neq F(i)$ for any $i \in \inbrace{0,..,n-1}$. %\label{condition2}.
\end{itemize}
\end{conjecture}

Suppose a function $f$ satisfies item i). Then for any $x$, if there exists an algorithm to compute $f(x)$, then the algorithm also can compute $\AND_n(x)$, and thus  $Q_E(f) \ge Q_E(\AND_n)$. Similarly, if $f$ satisfies item ii), then $Q_E(f) \ge Q_E(\OR_n)$.
Thus, $Q_E(f) = n$. As a result, to solve the above conjecture, we only need to solve the following question: if there exist $i \in [n],j\in\inbrace{0,...,n-1}$ such that $F(0) = F(i)$ and $F(n) = F(j)$, whether the exact quantum query complexity of $f$ is less than $n$? By Corollary \ref{th:lessn}, we have already proven that if $i+j = n$, then the exact quantum query complexity of $f$ is less than $n$. Thus, we propose the following conjecture:
\begin{conjecture}\label{con2}
If a total symmetric function $f:\B^n \rightarrow X$ satisfies $F(0) = F(i)$, $F(j) = F(n)$ for some $i \in [n],j \in \inbrace {0,...,n-1}$ such that $i+j \neq n$, then $Q_E(f) < n$, where $F$ is the univariate version of $f$.
\end{conjecture}
If Conjecture \ref{con2} is proved, then Conjecture \ref{con1} is also correct.
 

\section{Exact Quantum Query Complexity of $\EXACT_{k,l}^n$}\label{sec:kl}
In this section, we consider the exact quantum query complexity of $\EXACT_{k,l}^n$ for $l-k \ge 2$. The $n$-bit Boolean function $\EXACT_{k,l}^n$ is defined as follows:
$$
\EXACT_{k,l}^n(x) = 
\begin{cases}
1, &\text{if }|x| \in \{k,l\}, \\
0, &\text{otherwise}.
\end{cases}
$$
In the following context, we need to use the $n$-bit Boolean function $\EXACT_k^n$, defined as
$$
\EXACT_{k}^n(x) = 
\begin{cases}
1, &\text{if }|x| = k, \\
0, &\text{otherwise}.
\end{cases}
$$
First, we consider the case $k = 0$. We give the following lemma:
\begin{lemma}\label{lemma:klzero}
For $x \in \B^n$ and $2 \le l \le n$, there exists a quantum algorithm to compute $\EXACT_{0,l}^n(x)$ with $n-1$ queries.
\end{lemma}

\begin{proof}
If $l < n$, we provide the algorithm as follows. For $i=0$ to $n-l-1$, we query $x_i$ until $x_i = 1$ for some $i$. Then we consider the following two cases:
i) If we find the smallest integer $i \in [0,n-l-1]$ such that $x_i = 1$, let 
$x' = x_{i+1}\cdots x_{n-1}$. Then $\EXACT_{0,l}^n(x) = \EXACT_{l-1}^{n-i-1}(x')$. Since $\EXACT_{l-1}^{n-i-1}(x')$ can be computed by $\max\inbrace{n-i-l,l-1}$ quantum queries \cite{AIS13}, the total number of queries is
$$
\begin{aligned}
(i+1)+ \max\inbrace{n-i-l,l-1} &\le  \max\inbrace{n-l,i+l} \\
&\le \max\inbrace{n-l,n-1} \\
&= n-1.
\end{aligned}
$$
ii) If we find $x_i = 0$ for any $0 \le i \le n-l-1$, let $x' = x_{n-l} \cdots x_{n-1}$ and compute $|x'| \mod l$ using Algorithm \ref{algorithm1}. If $|x'| \mod l =0$, then $|x| = 0$ or $l$, and thus $\EXACT_{0,l}^n(x) = 1$; otherwise, $\EXACT_{0,l}^n(x) = 0$. The total number of queries is $n-l+l-1 = n-1$.

If $l = n$, we compute $|x| \bmod n$ using $n-1$ quantum queries by Algorithm \ref{algorithm1}, and then $|x|\in \inbrace{0,l}$ if and only if $|x|\bmod n = 0$. 
\end{proof}
Second, we consider the case $k=1$ and $l =n-1$. We give the following lemma. \begin{lemma}\label{lemma:klone}
For $x\in\B^n$ and $n \ge 4$, there exists a quantum algorithm to compute $\EXACT_{1,n-1}^n(x)$ with $n-2$ queries.
\end{lemma}


%\begin{algorithm}[H]
%\label{al:exact_one_n}
%\caption{Compute $\EXACT_{1,n-1}^n(x)$.}
    %If $n$ is even, then we compute $x_0 \oplus x_1, x_2 \oplus x_3, ..., x_{n-2}\oplus x_{n-1}$ by $\frac{n}{2}$ quantum queries. If exactly one pair $(x_{2i},x_{2i+1})$ are equal, we let $x' = x_0x_2\cdots x_{2i-2}x_{2i+2}\cdotsx_{n-2}$. Then $|x'| \in \inbrace{0,\frac{n}{2}-1}$ if and only if $|x| \in \inbrace{1,n-1}$. Then we determine whether $|x'| \in \inbrace{0,\frac{n}{2}-1}$ by Algorithm \ref{algorithm1} using $\frac{n}{2}-2$ queries. Thus, the number of queries is $\frac{n}{2}+\frac{n}{2}-2 = n-2$ queries.
    \begin{proof}
    We give a recursive algorithm as follows. The goal of the algorithm is to determine whether $|x| \in \inbrace{1,n-1}$. If $|x| \in \inbrace{1,n-1}$, the algorithm finds at least a majority index of $x$. %In the algorithm, an subroutine is to compute $x_i \oplus x_j$ by 1 quantum query, which can be implemented by Deutsch's Algorithm or our Algorithm \ref{algorithm1}.
    \begin{itemize}
        \item If $n = 4$, we compute $x_0 \oplus x_1$ and $x_2 \oplus x_3$ using 2 quantum queries by Algorithm \ref{algorithm1}. i) If $x_0 \oplus x_1 = 0, x_2 \oplus x_3 = 1$, then $|x| \in \inbrace{1,3}$ and $\inbrace{0,1}$ are majority indices of $x$; ii) if $x_0 \oplus x_1 = 1, x_2 \oplus x_3 = 0$, then $|x| \in \inbrace{1,3}$ and $\inbrace{2,3}$ are majority indices of $x$ similarly; iii) if $x_0 \oplus x_1 =  x_2 \oplus x_3$, then $|x| \in \inbrace{0,2,4}$.
    
    \item If $n= 5$, then there exists an algorithm to determine whether $|x| \in \inbrace{1,4}$ using 3 quantum queries \cite{AIN17}. It is worth noting if $|x| \in \inbrace{1,4}$, the algorithm will find some $i,j$ such that $x_i \neq x_j$. Thus, all the indices except $i,j$ are  majority indices of $x$.
    
    \item If $n > 5$, let $x' = x_2\cdots x_{n-1}$. We compute $x_0 \oplus x_1$ using 1 quantum query first. i) If $x_0 \neq x_1$, 
    %then $\EXACT_{1,n-1}^n(x) = \EXACT_{0,n-2}^{n-2}(x')$. Thus, 
    we compute $|x'| \bmod n-2$ using Algorithm \ref{algorithm1} to determine whether $|x'| \in \inbrace{0,n-2}$. If $|x'| \notin \inbrace{0,n-2}$, then $|x| \notin \inbrace{1,n-1}$; if $|x'| \in \inbrace{0,n-2}$, then $|x| \in \inbrace{1,n-1}$ and $\inbrace{2,...,n-1}$ are majority indices of $x$.
    ii) If $x_0  = x_1$, we call the algorithm recursively to determine whether $|x'| \in \inbrace{1,n-3}$ and find a majority index $i$ in $x'$ if $|x'| \in \inbrace{1,n-3}$. Then we discuss the following two cases:
    \begin{enumerate}
        \item  If $|x'| \notin \inbrace{1,n-3}$, we have
        $|x'| \in \inbrace{0,2,...,n-4,n-2}$. Since $x_0 = x_1$ and $|x| = x_0+x_1+|x'|$, we have $|x| \in \inbrace{0,2,...,n-2,n}$. Thus, $|x| \notin \inbrace{1,n-1}$;
        \item  If $|x'| \in \inbrace{1,n-3}$, we compute $x_0 \oplus x'_i$ using 1 quantum query. If $x_0 \neq  x'_i$, then $|x| \in \inbrace{3,n-3}$ and thus $|x| \notin \inbrace{1,n-1}$; if $x_0 = x'_i$, then $|x| \in \inbrace{1,n-1}$.
    \end{enumerate}
 
    \end{itemize}
    Next, we prove the number of queries in the above algorithm to compute $\EXACT_{1,n-1}^n(x)$ is at most $n-2$
    by the induction method. i) For $n=4$ and $5$, the correctness of the proposition is easy to check; ii) We suppose the proposition is correct for any $n$ such that $4 \le n < m$ for some integer $m \ge 6$. Then we aim to prove the correctness of the proposition in the case $n = m$. If $x_0 \neq x_1$, the number of queries in the algorithm is $1+(m-2-1)= m-2$; if $x_0 = x_1$, then by the induction assumption, the number of queries in the algorithm is at most $1+(m-2-2)+1 = m-2$. Thus, the proposition is also correct for $n = m$. %As a result, the query complexity of the above algorithm to compute $\EXACT_{1,n-1}^k(n)$ is $n-2$.
    
    
    
    \end{proof}
Combining Lemma \ref{lemma:klzero}, \ref{lemma:klone} and the known lower bound from \cite{AIN17}, we prove Theorem \ref{th:kl}, which implies the correctness of Conjecture \ref{con:kl} for the above two cases.






\section{Conclusion}\label{sec:con}




In this paper, we have characterized the exact quantum query complexity of $\Mod_m^n$ for any $1 < m \le n$. As a corollary, we have shown a broad class of symmetric functions is not evasive in the quantum model. Additionally, we have given the tight exact quantum query complexity of $\EXACT_{k,l}^n$ for some cases. Furthermore, there are some open questions worth exploring.

\begin{itemize}
\item For total symmetric Boolean functions, there are still some basic function classes whose quantum exact query complexity has not been fully characterized.  It would be interesting to investigate whether the techniques used in this article can be extended to these functions.


\item How to give a fully characterization to the class of symmetric functions that map from $\B^n$ to a finite set $X$, whose quantum query complexity is less than $n$?


\end{itemize}

The study of the exact quantum query complexity of symmetric functions is an important area of research in quantum computing. While the exact quantum query complexities of a few symmetric functions are well-established, there remain many challenges in this domain. Further research is necessary to enhance our understanding of the exact quantum query complexity of symmetric functions and to explore new quantum algorithms in this field.

\section*{Declaration of competing interest}
The authors declare that they have no known competing financial interests or personal relationships that could have
appeared to influence the work reported in this paper.

\section*{Acknowledgment}
We would like to thank Penghui Yao for helpful comments. This research was supported by National Natural Science Foundation of China (Grant No. 61972191)
and the Program for Innovative Talents and Entrepreneur in Jiangsu.

\bibliography{references}

\end{document}