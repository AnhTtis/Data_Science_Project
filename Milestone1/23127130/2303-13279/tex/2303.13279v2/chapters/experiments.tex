\section{Implementation and Experimental Results}{\label{sec:Experiments}}
\label{sec:stats_molecules}
\label{sec:performance_algo}
\label{sec:implementation}
% \subsection{Statistical analysis of molecules}

\begin{wrapfigure}{r}{5cm}
	\centering
	\vspace{-3em}
	\includegraphics[width =\textwidth]{./chapters/Plots/tw-histogram.pdf}
	% \subfloat[]{\includegraphics[width=0.5
		% \textwidth]{./chapters/Plots/tw-histogram.pdf}}
	\vspace{-2em}
	\caption{Treewidths of PubChem Molecules.}
	\label{fig:tw_distribution}
\end{wrapfigure}

\paragraph{Benchmarks}
We conducted experiments on the entire PubChem database of chemical compunds \cite{pubchem}, containing over 113 million molecules. \ref{app:imp} has more details. %It includes information on chemical structures, identifiers, chemical and physical properties, biological activities and toxicity data.%, and many others. Below, we report results on thWe have also conducted experiments on some of the widely used datasets PubChem, including Common Chemistry CAS, Nature Catalysis, Wikipedia, Nature Communications, Wiley, Springer Nature, Nature Chemistry, Nature Portfolio Journals,
%Springer Materials, Drug and Medication, Nature Synthesis, Nature Chemical Biology, KEGG, DrugBank. 



%We began by downloading the SMILES representations \cite{weininger1988smiles} for all PubChem compounds using the FTP bulk download option. To parse these SMILES into Networkx graphs \cite{hagberg2008exploring} in Python3, we utilized open-source libraries such as RDKit \cite{RDKit} and pysmiles \cite{pysmiles}. Next, we employed the tree decomposition solver FlowCutter \cite{strasser2017computing} to obtain the tree decompositions for these graphs. Our dynamic programming algorithms were then implemented in C++ using these tree decompositions. All statistical analyses for the experiments were conducted in Python3, with a detailed notebook to be made available in the respective Zenodo repository.

\paragraph{Treewidth Statistics}
Figure~\ref{fig:tw_distribution} shows the treewidth distribution in the entire PubChem dataset. The $y$ axis in this figure is in logarithmic scale. Notably, more than $99.9\%$ of the compounds have a treewidth of less than 5. This holds not only for the whole database, but also for individual molecule families. See~\ref{app:fig} for more detailed tables and figures.


\begin{figure}[H]
	\resizebox{.9\linewidth}{!}{
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/num-of-vertices-vs-t-num-of-perfect-matchings_scatter.pdf}} 
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/num-of-vertices-vs-t-num-of-matchings_scatter.pdf}} 
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/num-of-vertices-vs-t-num-of-independent-sets_scatter.pdf}}}
	\vspace{-1em}
	\caption{Runtime Comparison of our Algorithms versus WTZL~\cite{wan2018computing} and the Naive Non-parameterized Approaches.}
	\label{fig:baseline_cmp}
	

\end{figure}

\vspace{-1.5em}
\begin{figure}[H]
	\resizebox{.9\linewidth}{!}{
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/runtime_comparison_Kekule.png}} 
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/runtime_comparison_Hosoya.png}} 
		{\includegraphics[width=0.4\textwidth]{./chapters/Plots/runtime_comparison_Merrifield-Simmons.png}}}
	\vspace{-1em}
	\caption{Runtime Comparison of Our Approach versus WTZL \cite{wan2018computing}. %The x-axis represents the time taken by the WTZL algorithm, and the y-axis represents the time taken by our algorithm. The greeen points represent the data points where our algorithm outperforms the WTZL algorithm, and the red points represent the data points where the WTZL algorithm outperform our algorithm.
	}
	\label{fig:wtzl_vs_our}
\end{figure}




\sloppy{
\paragraph{Runtimes}  Figure~\ref{fig:baseline_cmp} compares the runtimes of our algorithms, the WTZL algorithms~\cite{wan2018computing}, and the naive non-parameterized algorithms (\ref{app:brute}) over our benchmark set. To enable the experiment to conclude within a manageable timeframe of a few days, we enforced a time limit of 100 milliseconds per instance and report results for counting Kekul\'e structures and computing the Hosoya and Merrifield-Simmons indices. The runtimes for our approach and WTZL include the time required for computing tree decompositions. In practice, we observe that our runtime is dominated by the tree decomposition computation, rather than our own dynamic programming, whereas this is not the case for WTZL.  Note that Figure~\ref{fig:baseline_cmp} contains scatter plots, but the dots resemble lines due to the large number of benchmarks. For Kekul\'e structures, WTZL is able to conclude early over roughly half of the molecules and its runtime in these cases is close to the time required for computing tree decompositions and hence closely tracks our runtime, too. This is why Figure~\ref{fig:baseline_cmp}(a) appears to have two blue lines. We also remark that the $y$ axis in these plots is in logarithmic scale. Figure~\ref{fig:wtzl_vs_our} presents a runtime comparison between our approach and the algorithms presented in WTZL \cite{wan2018computing}. In these plots, the $x$ axis represents the time taken by the WTZL algorithms, and the $y$ axis is our time. The green points correspond to instances where our algorithm outperforms the WTZL algorithm. This accounts for {$49.3$}, {$99.04$} and {$99.20$} percent of benchmarks for Kekul\'e, Hosoya and Merrifield-Simmons, respectively. We also note that both axes in these plots are in logarithmic scale, showing that our approach is often several orders of magnitude faster in practice.
}

% \begin{figure}[h]
% 	\centering
% 	\subfloat[]{\includegraphics[width=0.4\textwidth]{./chapters/Plots/treewidth-vs-t-num-of-perfect-matchings.pdf}}
% 	\subfloat[]{\includegraphics[width=0.4\textwidth]{./chapters/Plots/treewidth-vs-t-num-of-perfect-matchings.pdf}} 
% 	\\ 
% 	\subfloat[]{\includegraphics[width=0.4\textwidth]{./chapters/Plots/treewidth-vs-t-num-of-independent-sets.pdf}} 
% 	\caption{Time vs Treewidth characteristics for algortihms}
% 	\label{fig:charact_time_tw}
% \end{figure}
% \todo{remove this figure}
% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/treewidth_time_independent_set.pdf}
% 	\caption{Time vs Treewidth for computing Independent Sets}
% 	\label{fig:time_treewidth}
% \end{figure}
% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/treewidth_time_matchings.pdf}
% 	\caption{Time vs Treewidth for computing Matchings}
% 	\label{fig:time_matchings}
% \end{figure}
% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/treewidth_time__perfect_matchings.pdf}
% 	\caption{Time vs Treewidth for computing Perfect Matchings }
% 	\label{fig:time_perfect_matchings}
% \end{figure}
% \paragraph*{Comparision with baseline algorithms}
% In this sectiom, we present a comparision of our parameterized algorithms with naive baseline algorithms (See Figure \ref{fig:baseline_cmp}). We present time vs edges characteristics for graphs selected uniformly at random from selected PubChem datasources. For conducting this comparision, we limited ourselves to graphs with at most $40$ edges, and for each edge size we sampled $50$ graphs from the datasources, and reported the average time for each edge size. 
% \todo{make this look nice}
% \todo{all figures and tables should be over the entire PubChem database}
% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/perfect_matchings_comparision.pdf}
% 	\caption{Comparision of algorithms for perfect matchings}
% 	\label{fig:perfect_matchings_comparision}
% \end{figure}
% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/matchings_comparision.pdf}
% 	\caption{Comparision of algorithms for matchings}
% 	\label{fig:matchings_comparision}
% \end{figure}

% \begin{figure}[h!]
% 	\captionsetup{justification=centering}
% 	\centering
% 	\includegraphics[scale = 0.6]{./chapters/images/independent_set_comparision.pdf}
% 	\caption{Comparision of algorithms for independet set}
% 	\label{fig:independent_set_comparision}
% \end{figure}
% \subsection{Implementation Details}

% \begin{itemize}
% 	\item g++ 9.4.0
% 	\item System Ubuntu 20.04.5 LTS
% 	\item CPU AMD Ryzen 5 4600H with Radeon Graphics \url{https://www.amd.com/en/products/apu/amd-ryzen-5-4600h}
% 	\item Tree decomposition solver \url{https://github.com/kit-algo/flow-cutter} at commit ebb2427fdb69839c149f3e4ff184fb7112e324ba
% \end{itemize}

%\section{Conclusion}\label{sec:Conclusion}
%
%In this work, we presented simple combinatorial fixed-parameter tractable (FPT) algorithms, based on treewidth and pathwidth as parameters, for several classical $\#P$-complete problems in computational chemistry. Additionally, we provided experimental results showing that real-world molecules from the massive PubChem database all have small treewidth.  Thus, we argue that parameterization by treewidth should be adopted as the default approach to solving any graph problem in computational chemistry.

% \newpage