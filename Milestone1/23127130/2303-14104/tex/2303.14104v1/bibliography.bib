@misc{
    curl, 
    title = {{cURL}},
    howpublished={\url{https://curl.se/}},
    note = {Accessed in June 2021},
    year = {1998}
}

@misc{
    reqbin, 
    title = {Reqbin: Online REST \& SOAP API Testing Tool},
    hpwpublished={\url{https://reqbin.com/}},
    note = {Accessed in June 2021}, 
    year = {2018}
}

@misc{
    dredd, 
    title = {Dredd},
    howpublished={\url{https://dredd.org/en/latest/index.html}},
    note = {Accessed in June 2021},
    year = {2020}
}

@misc{
    swagger-schemas, 
    title = {{Swagger -- Data Models}},
    howpublished={\url{https://swagger.io/docs/specification/data-models}},
    note = {Accessed in May 2021},
    year = {2020}
}

@misc{
    postman, 
    title = {Postman},
    howpublished={\url{https://learning.getpostman.com/}},
    note = {Accessed in June 2021},
    year = {2020}
}

@misc{
    postman-auto, 
    title = {{Postman -- Scripts}},
    howpublished={\url{https://learning.getpostman.com/docs/postman/scripts/test-scripts/}},
    note = {Accessed in May 2021},
    year = {2021}
}

@misc{
    soapui, 
    title = {{SoapUI}},
    howpublished={\url{https://www.soapui.org/}},
    note = {Accessed in June 2021},
    year = {2006}
}

@misc{
    jepsenwebsite, 
    title = {{Jepsen}},
    howpublished={\url{https://jepsen.io/}},
    note = {Accessed in June 2021}
}

@misc{
    jepsenKnossosGitHub, 
    title = {{Knossos}},
    howpublished={\url{https://github.com/jepsen-io/knossos}},
    note = {Accessed in June 2021}
}

@misc{
    consistency, 
    title = {{Consistency Models}},
    howpublished={\url{https://jepsen.io/consistency}},
    note = {Accessed in February 2021}
}

@article{kingsbury2020elle,
  title={Elle: Inferring Isolation Anomalies from Experimental Observations},
  author={Kingsbury, K. and Alvaro, P-},
  journal={arXiv preprint arXiv:2003.10554},
  year={2020}
}

@misc{
    nebula_jepsen, 
    title = {{Practice Jepsen Test Framework in Nebula Graph}},
    howpublished={\url{https://nebula-graph.io/posts/practice-jepsen-test-framework-in-nebula-graph/}},
    note = {Accessed in February 2021}
}

@article{nidhra2012black,
  title={Black box and white box testing techniques-a literature review},
  author={Nidhra, S. and Dondeti, J.},
  journal={International Journal of Embedded Systems and Applications},
  volume={2},
  number={2},
  pages={29--50},
  year={2012}
}

@inproceedings{jiang2008automatic,
  title={Automatic identification of load testing problems},
  author={Jiang, Z. and Hassan, A. and Hamann, G. and Flora, P.},
  booktitle={ICSME 2008},
  pages={307--316},
  xyear={2008},
  xorganization={IEEE}
}

@misc{
    non_func, 
    title = {{Chapter 12. Designing for Non-Functional Properties}},
    howpublished={\url{https://www.oreilly.com/library/view/software-architecture-foundations/9780470167748/ch12.html}},
    note = {Accessed in February 2021}
}

@misc{
    why_non_func, 
    title = {{Why is the difference between functional and Non-functional requirements important?}},
    howpublished={\url{https://reqtest.com/requirements-blog/functional-vs-non-functional-requirements}},
    note = {Accessed in February 2021}
}

@misc{
    tla_homepage, 
    title = {{The TLA+ Home Page}},
    howpublished={\url{https://lamport.azurewebsites.net/tla/tla.html}},
    note = {Accessed in February 2021}
}

@misc{
    tla, 
    title = {{Specification of a partial replication protocol with TLA+}},
    howpublished={\url{http://hdl.handle.net/10362/16273}},
    note = {Accessed in February 2021}
}

@misc{
    faker, 
    title = {{Faker’s documentation!}},
    howpublished={\url{https://faker.readthedocs.io/}},
    note = {Accessed in July 2021}
}

@misc{
    JMeter, 
    title = {{Apache JMeter}},
    howpublished={\url{https://jmeter.apache.org/}},
    note = {Accessed in July 2021}
}

@misc{
    load_testing_tools, 
    title = {{15 Top Load Testing Tools for 2021 (Open Source Guide)}},
    howpublished={\url{https://testguild.com/load-testing-tools}},
    note = {Accessed in July 2021}
}

@misc{
    taurus, 
    title = {{Codename Taurus}},
    howpublished={\url{https://gettaurus.org/}},
    note = {Accessed in July 2021}
}

@misc{
    locust, 
    title = {{An open source load testing tool.}},
    howpublished={\url{https://locust.io/}},
    note = {Accessed in July 2021}
}

@misc{
    locust-docs, 
    title = {{What is Locust?}},
    howpublished={\url{https://docs.locust.io/en/stable/what-is-locust.html}},
    note = {Accessed in July 2021}
}

@misc{
    artillery, 
    title = {{Modern testing for SRE and DevOps}},
    howpublished={\url{https://artillery.io/}},
    note = {Accessed in July 2021}
}

@misc{
    artillery-docs, 
    title = {{Artillery?}},
    howpublished={\url{https://artillery.io/}},
    note = {Accessed in July 2021}
}

@misc{
    openAPI, 
    title = {{OpenAPI Specification}},
    howpublished={\url{https://swagger.io/specification/}},
    note = {Accessed in July 2021}
}

@misc{
    openAPI-annotations, 
    title = {{Generating REST API documentation with OpenAPI}},
    howpublished={\url{https://www.ibm.com/docs/en/was-liberty/core?topic=liberty-generating-rest-api-documentation-openapi}},
    note = {Accessed in July 2021}
}

@MastersThesis{
tese,
author={A. Ribeiro},
title={{Invariant-Driven Automated Testing}},
school={Universidade Nova de Lisboa},
xaddress={Lisboa},
year={2021},
}

@article{linearizability,
author = {Herlihy, M. and Wing, J.},
title = {Linearizability: A Correctness Condition for Concurrent Objects},
year = {1990},
xissue_date = {July 1990},
xpublisher = {Association for Computing Machinery},
xaddress = {New York, NY, USA},
volume = {12},
number = {3},
xissn = {0164-0925},
xurl = {https://doi.org/10.1145/78969.78972},
xdoi = {10.1145/78969.78972},
xabstract = {A concurrent object is a data object shared by concurrent processes. Linearizability
is a correctness condition for concurrent objects that exploits the semantics of abstract
data types. It permits a high degree of concurrency, yet it permits programmers to
specify and reason about concurrent objects using known techniques from the sequential
domain. Linearizability provides the illusion that each operation applied by concurrent
processes takes effect instantaneously at some point between its invocation and its
response, implying that the meaning of a concurrent object's operations can be given
by pre- and post-conditions. This paper defines linearizability, compares it to other
correctness conditions, presents and demonstrates a method for proving the correctness
of implementations, and shows how to reason about concurrent objects, given they are
linearizable.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jul,
pages = {463–492},
xnumpages = {30}
}

@inproceedings{Madeira00Emulation,
author = {Madeira, H. and Costa, D. and Vieira, M.},
title = {On the Emulation of Software Faults by Software Fault Injection},
xyear = {2000},
xisbn = {0769507077},
xpublisher = {IEEE Computer Society},
xaddress = {USA},
xabstract = {This paper presents an experimental study on the emulation of software faults by fault
injection. In a first experiment, a set of real software faults has been compared
with faults injected by a SWIFI tool (Xception) to evaluate the accuracy of the injected
faults. Results revealed the limitations of Xception (and any other SWIFI tools) in
the emulation of the different classes of software faults (about 44% of the software
faults cannot be emulated). The use of field data about real faults was discussed
and software metrics were suggested as an alternative to guide the injection process
when field data is not available. In a second experiment, a set of rules for the injection
of errors meant to emulate classes of software faults was evaluated. The fault triggers
used seem to be the cause for the observed strong impact of the faults in the target
system and in the program results. The results also show the influence in the fault
emulation of aspects such as code size, complexity of data structures, and recursive
versus sequential execution.},
booktitle = {DSN 2000},
pages = {417–426},
xnumpages = {10},
xkeywords = {Fault injection, fault classification, software faults},
xseries = {DSN '00}
}

@article{Natella16Assessing,
author = {Natella, R. and Cotroneo, D. and Madeira, H.},
title = {Assessing Dependability with Software Fault Injection: A Survey},
year = {2016},
xissue_date = {February 2016},
xpublisher = {Association for Computing Machinery},
xaddress = {New York, NY, USA},
volume = {48},
number = {3},
xissn = {0360-0300},
xurl = {https://doi.org/10.1145/2841425},
xdoi = {10.1145/2841425},
xabstract = {With the rise of software complexity, software-related accidents represent a significant
threat for computer-based systems. Software Fault Injection is a method to anticipate
worst-case scenarios caused by faulty software through the deliberate injection of
software faults. This survey provides a comprehensive overview of the state of the
art on Software Fault Injection to support researchers and practitioners in the selection
of the approach that best fits their dependability assessment goals, and it discusses
how these approaches have evolved to achieve fault representativeness, efficiency,
and usability. The survey includes a description of relevant applications of Software
Fault Injection in the context of fault-tolerant systems.},
journal = {ACM Comput. Surv.},
xmonth = feb,
articleno = {44},
xnumpages = {55},
xkeywords = {dependability assessment, Software faults, software fault tolerance}
}

@Inproceedings{faultsee,
   author = "M. Matos and M. Pardal and M. Amaral and H. Mercier",
   title = "FaultSee: Reproducible Fault Injection in Distributed Systems",
   booktitle = "EDCC 2020",
   xyear = 2020,
   xmonth = sep,
   xBibTexOrigem = "15709 www.Inesc-ID.pt 2021-07-07"
}

@INPROCEEDINGS{nftape,  
author={Stott, D.T. and Floering, B. and Burke, D. and Kalbarczpk, Z. and Iyer, R.K.},  
booktitle={IPDS 2000},   
title={NFTAPE: a framework for assessing dependability in distributed systems with lightweight fault injectors},   
xyear={2000},  
xvolume={},  
xnumber={},  
xpages={91-100},  
xdoi={10.1109/IPDS.2000.839467}}


@article{netflix,
author = {Tseitlin, Ariel},
title = {The Antifragile Organization},
year = {2013},
xissue_date = {August 2013},
xpublisher = {Association for Computing Machinery},
xaddress = {New York, NY, USA},
volume = {56},
number = {8},
xissn = {0001-0782},
xurl = {https://doi.org/10.1145/2492007.2492022},
xdoi = {10.1145/2492007.2492022},
xabstract = {Embracing failure to improve resilience and maximize availability.},
journal = {Commun. ACM},
xmonth = aug,
pages = {40–44},
xnumpages = {5}
}

@article{Alvaro17Abstracting,
author = {Alvaro, P. and Tymon, S.},
title = {Abstracting the Geniuses Away from Failure Testing: Ordinary Users Need Tools That Automate the Selection of Custom-Tailored Faults to Inject.},
year = {2017},
xissue_date = {September-October 2017},
xpublisher = {Association for Computing Machinery},
xaddress = {New York, NY, USA},
volume = {15},
number = {5},
xissn = {1542-7730},
xurl = {https://doi.org/10.1145/3155112.3155114},
xdoi = {10.1145/3155112.3155114},
xabstract = {This article presents a call to arms for the distributed systems research community
to improve the state of the art in fault tolerance testing. Ordinary users need tools
that automate the selection of custom-tailored faults to inject. We conjecture that
the process by which superusers select experiments can be effectively modeled in software.
The article describes a prototype validating this conjecture, presents early results
from the lab and the field, and identifies new research directions that can make this
vision a reality.},
journal = {Queue},
xmonth = oct,
pages = {29–53},
xnumpages = {25}
}

@article{jepsenElleGitHub,
author = {Kingsbury, K. and Alvaro, P.},
title = {Elle: Inferring Isolation Anomalies from Experimental Observations},
year = {2020},
xissue_date = {November 2020},
publisher = {VLDB Endowment},
volume = {14},
number = {3},
xissn = {2150-8097},
xabstract = {Users who care about their data store it in databases, which (at least in principle)
guarantee some form of transactional isolation. However, experience shows that many
databases do not provide the isolation guarantees they claim. With the recent proliferation
of new distributed databases, demand has grown for checkers that can, by generating
client workloads and injecting faults, produce anomalies that witness a violation
of a stated guarantee. An ideal checker would be sound (no false positives), efficient
(polynomial in history length and concurrency), effective (finding violations in real
databases), general (analyzing many patterns of transactions), and informative (justifying
the presence of an anomaly with understandable counterexamples). Sadly, we are aware
of no checkers that satisfy these goals.We present Elle: a novel checker which infers
an Adya-style dependency graph between client-observed transactions. It does so by
carefully selecting database objects and operations when generating histories, so
as to ensure that the results of database reads reveal information about their version
history. Elle can detect every anomaly in Adya et al's formalism (except for predicates),
discriminate between them, and provide concise explanations of each. This paper makes
the following contributions: we present Elle, demonstrate its soundness over specific
datatypes, measure its efficiency against the current state of the art, and give evidence
of its effectiveness via a case study of four real databases.},
journal = {Proc. VLDB Endow.},
xmonth = nov,
pages = {268–280},
xnumpages = {13}
}

@INPROCEEDINGS{Freitas16Characterizing, 
author={F. Freitas and J. Leitao and N. Preguiça and R. Rodrigues}, 
booktitle={DSN 2016}, 
title={Characterizing the Consistency of Online Services (Practical Experience Report)}, 
xyear={2016}, 
xpages={638-645}, 
xkeywords={application program interfaces;social networking (online);APIs;Blogger;Facebook Feed;Facebook Groups;Google+;Internet services;online service consistency model;Blogs;Clocks;Facebook;Feeds;Probes;Synchronization;Web and internet services;Internet online services;Session guarantees;consistency;measurement study}, 
xdoi={10.1109/DSN.2016.64}, 
xmonth={June}
}

@inproceedings {cobra,
author = {Cheng Tan and Changgeng Zhao and Shuai Mu and Michael Walfish},
title = {Cobra: Making Transactional Key-Value Stores Verifiably Serializable},
booktitle = {OSDI} 2020},
xyear = {2020},
xisbn = {978-1-939133-19-9},
xpages = {63--80},
xurl = {https://www.usenix.org/conference/osdi20/presentation/tan},
xpublisher = {{USENIX} Association},
xmonth = nov,
}