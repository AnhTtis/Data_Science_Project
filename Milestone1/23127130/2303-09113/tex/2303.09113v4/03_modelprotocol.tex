\section{Protocol \& Model}
\label{sec:modelprotocol}

%



%
We briefly recap Nakamoto consensus (NC)
%
and the bounded-ca\-pa\-ci\-ty model of~\cite{bwlimitedposlc}.
Detailed pseudocode of the protocol is provided in \appendixRef{\cref{sec:algos-reference-pseudocode}}.
Technical details about the model are provided in \appendixRef{\cref{sec:algos-reference-environment}}.
%
%
%
%
%
%
%
%
%
%
For ease of exposition, the execution features a \emph{static} set of $N$ \emph{equipotent} \emph{nodes}, each of which runs an independent instance of the protocol.
%
Temporary crash faults (`sleepiness') of nodes, heterogeneous distribution of hash power,
or difficulty adjustment
are left to be addressed with techniques from~\cite{backbone,sleepy,garay2017bitcoin}.
%
We are interested in the large system regime $N\to\infty$.
Nodes interact with each other and with the adversary $\Adv$ through an environment $\Env$ that models the network.
$\Adv$ and $\Env$ are summarized below.

%

\myparagraph{Nakamoto's Longest Chain Consensus Protocol}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
For ease of analysis, we consider the protocol 
(pseudocode in \appendixRef{\cref{alg:generic-lc-protocol}})
to proceed in discrete \emph{\timeslots} of duration $\slotduration$.
%
Consider $\slotduration$ to be a small quantum of time where $\slotduration \to 0$.
At each \timeslot $t$, the protocol 
queries the PoW block production (`mining') oracle
(idealized functionality in \appendixRef{\cref{alg:hdrtree-pow}})
%
%
in an attempt to extend the \emph{longest processed chain} $\dC$ in the node's view with a new block 
of
%
pending transactions $\txs$.
Each block production attempt is committed to a parent block and block content,
%
and only a single block is produced when the attempt is successful.
Per \timeslot, each node can make one block production attempt that will be successful with probability $\blkrateslot/N$ where $\blkrateslot = \Theta(\slotduration)$, independently of other nodes and \timeslots.
%
If successful, the node disseminates both the resulting \emph{(block) header} $\Chain'$ and the associated \emph{(block) content} $\txs$ via the environment $\Env$ to all nodes.
%
%
Finally, the protocol identifies the $\confDepth$-deep prefix $\dC\trunc{\confDepth}$ containing all but the last $\confDepth$ blocks of $\dC$.
The transactions along $\dC\trunc{\confDepth}$ are concatenated to produce the \emph{output ledger} $\LOG{}{t}$.
%
%
%


When a node $p$ receives a new valid block header $\Chain$ from $\Env$ (push-based header broadcasting), 
%
then $p$ adds $\Chain$ to its \emph{header tree} $\hT$ 
%
and relays $\Chain$ to all other nodes via $\Env$.
Throughout the execution, the protocol requests from $\Env$
(pull-based content downloading)
the content 
for
%
block headers 
%
decided by a \emph{scheduling policy}.
%
As a concrete example, we use the \rulelc rule
(pseudocode in \appendixRef{\cref{alg:longest-header-chain-rule}})
in which
a node downloads content for the first block header with unknown content on the longest header chain it sees.
%
%
Once a block's content is received and verified by executing its transactions, 
%
the node makes it available to other nodes via $\Env$, and updates its 
%
$\dC$.


%
%
%
%
%
%
%
%
%
%
%
%
%
%
%


%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%



\myparagraph{Bounded-Capacity Network}
%
%
%
%
We borrow the bounded-capacity network model of~\cite{bwlimitedposlc} (see \appendixRef{\cref{fig:model}} for an illustration).
In this model, $\Env$ abstracts \emph{push-based flooding of `small' block headers} and \emph{pull-based downloading of `large' block contents} from peers.
%
Broadcasted block header chains 
%
are delivered by $\Env$ to every node,
%
%
%
with a per-node per-header delay determined by $\Adv$, up to a commonly known delay upper bound $\DeltaHeader$.
%
Block content made available for download
%
is kept by $\Env$ in what can be thought of as a `cloud'.
Nodes can request the content associated with a particular header.
If content matching the header is available, then it is delivered by $\Env$ to the node.
%
%
Content download and verification is subject to a per-node capacity constraint of~$\bwtime$.
%
Blocks have a fixed maximum size, hence $C$ is measured in blocks per second.
See \appendixRef{\cref{sec:algos-reference-environment}} for a more formal description of $\Env$.

The `cloud' captures key properties of pull-based
peer-to-peer 
%
downloading. At first, content matching a particular header might not be available (\eg, $\Adv$ produced a block and disseminated its header, but withheld its content). Later, such content can become available (\eg, $\Adv$ releases the content to one node). Thus, the `cloud' ensures neither data availability nor strong consistency of query outcomes, unlike stronger primitives such as
verifiable information dispersal
%
\cite{avid,avidfp,dispersedledger,semiavidpr}. However, once content for a header does become available, it is unique and remains available. This captures the header's binding commitment to the content, and the fact that honest nodes share content 
%
with peers. Requests for unavailable content do not count towards the processing budget.

Also note that the adversary can push additional headers and contents to nodes at will.
%
This models non-uniform capacity (higher than the lower bound $C$)
and non-uniform delay (lower than the upper bound $\DeltaHeader$)
across nodes (analogous to adversary delay up to maximum $\Delta$ in the bounded-delay model).


\myparagraph{The Adversary}
%
The \emph{static} adversary $\Adv$ chooses a set of nodes (up to a fraction $\beta$ of all $N$ nodes, where $\beta$ is common knowledge) to corrupt before the randomness of the execution is drawn and the execution commences. Uncorrupted \emph{honest} nodes follow the protocol at all times. Corrupted \emph{adversary} nodes have arbitrary computationally-bounded \emph{Byzantine} behavior, coordinated by $\Adv$ in an attempt to break consensus.
%
Among other things, the adversary can:
withhold block headers and contents, or release them late or selectively to honest nodes;
push headers and contents to nodes while bypassing the delay and capacity constraints;
break ties in the chain selection and schdeuling policy.
%
%
%
%
Note that all miners that deviate from the honest protocol (including crash faults and SPV miners) are modeled as adversary.



\myparagraph{Security}
%
%
For an execution of 
PoW NC
%
where every honest node $p$ at every \timeslot $t$ outputs a ledger $\LOG{p}{t}$, we recall the security desiderata.

\begin{itemize}
    \item \emph{Safety:}
          For all adversary strategies,
          %
          all \timeslots $t,t'$, and 
          %
          all honest nodes $p, q$ (same or different): $\LOG{p}{t}\preceq\LOG{q}{t'}$ or $\LOG{q}{t'}\preceq\LOG{p}{t}$.
    \item \emph{$\Tlive$-Liveness:}
          For all adversary strategies, if a transaction $\tx$ is received by all honest nodes by \timeslot $t$,
          then for every honest node $p$ and for all \timeslots $t' \geq t+\Tlive$, $\tx \in \LOG{p}{t'}$.
    %
    %
    %
\end{itemize}

Note that since blocks have a fixed maximum size, liveness is expected only if transactions are received at a bounded rate. The following definition captures this.

\begin{definition}
\label{def:env-bounded-tx}
    The environment $\Env$ is \emph{$(\tput,\Ttput)$-tx-limited}, if the cumulative size of all transactions received by honest nodes during any interval of $\Ttput$ \timeslots is at most $\tput\cdot\Ttput$ times the maximum block size.
\end{definition}

Liveness will be proved under transaction-limited environments. The parameter $\tput$ is thus the worst-case throughput ($\blkratetime$ being the best-case throughput).
The burstiness of transaction arrival is measured by $\Ttput$; large $\Ttput$ may increase confirmation latency $\Tlive$.

%
A consensus protocol is \emph{secure over time horizon $\Thorizon$ \timeslots with transaction rate $\tput$} iff for some finite $\Ttput,\Tlive$, for all $(\tput,\Ttput)$-tx-limited environments, it satisfies safety, and $\Tlive$-liveness 
with overwhelming probability\footnote{As is customary, we denote by $\kappa$ the security parameter. 
Event $\Event_{\kappa}$ occurs \emph{with overwhelming probability} if $\Prob{\Event_{\kappa}} \geq 1 - \negl(\kappa)$.
Here, a function $f(\kappa)$ is \emph{negligible} $\negl(\kappa)$, if for all $n>0$, there exists $\kappa_n^*$ such that for all $\kappa > \kappa_n^*$, $f(\kappa) < \frac{1}{\kappa^n}$.} over executions of time horizon $\Thorizon$ \timeslots.
The properties 
%
can also be redefined in terms of real-time units instead of \timeslots.

%
%
%
%
%
%
%
%
%



%
%

%

%
%
%
%
%
%
%
%
%

%
%
%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

