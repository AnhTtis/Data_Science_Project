\subsubsection{Many Probabilistic Pivots Imply One Combinatorial Pivot}
\label{sec:proof-analysis-many-pps-one-cps}

The \rulelc rule $\dlrulelong$
(\appendixRef{\cref{alg:longest-header-chain-rule}})
has a few useful properties.
Nodes using this rule 
\begin{enumerate}[(P1),leftmargin=3em]
    \item \label{item:good-download-rule-no-repeat}
    process a \BPO's block's content at most once,
    \item \label{item:good-download-rule-honest-block} either process the most recent honest block, or fully utilize their capacity to process other blocks (\ie, do not stay idle), and
    \item \label{item:good-download-rule-cutoff} prioritize blocks that were produced `recently'.
\end{enumerate}
%
%
\ref{item:good-download-rule-no-repeat} holds by construction.
\ref{item:good-download-rule-honest-block} holds because 
this rule
is never idle, and 
will always process towards an honest block
when it has processed all longer chains
and there is capacity remaining.
Moreover, we expect that in a secure execution,
\ref{item:good-download-rule-cutoff} holds because
a node's longest header chain cannot fork off too much from its longest processed chain.
%
More precisely, due to \cref{lem:cps-stabilize-informal},
any longest header chain in any honest node's view must extend the block produced in the most recent \sltcp, and therefore blocks with the highest process priority must have been produced after the most recent \sltcp.
Thus, if the adversary wants to prevent honest nodes from processing the block produced at a \sltgood \iindex $k$,
so that $G_k = 1$ but $D_k = 0$, 
then it can only ``distract'' them by providing $\goodsepbw$ blocks
produced after the most recent \sltcp
(\cref{prop:download-or-spend-budget}).

While we subsequently use 
$\dlrulelong$
%
as a concrete example,
%
%
the proofs only use \ref{item:good-download-rule-no-repeat}, \ref{item:good-download-rule-honest-block}, \ref{item:good-download-rule-cutoff},
and thus apply to several other simple scheduling policies, including the freshest-block rule 
of~\cite{bwlimitedposlc}.

\begin{restatable}{proposition}{RestatePropDownloadOrSpendBudget}
%
    \label{prop:download-or-spend-budget}
    If $G_k = 1$ and $D_k = 0$, then during \timeslots $[t_k, t_k + \goodsep]$, all honest nodes 
    using the \rulelc scheduling policy
    %
    process content of at least $\goodsepbw$ blocks that are produced in $\intvl{i}{k}$, where $i<k$ is the largest index such that $\predCP{i}$ (if such an $i$ does not exist, $i=0$).
%
\end{restatable}

\begin{proof}
In \timeslot $t_k$, there is exactly one block $b$ produced by an honest node, 
the block header is made public at the beginning of the \timeslot,
and is seen by all honest nodes within $\DeltaHeader$ time.
Thereafter, each node has enough time to process $\goodsepbw$ blocks during \timeslots $[t_k, t_k + \goodsep]$.

Under the \rulelc scheduling policy,
if $\Dat{k} = 0$,
\ie an honest node did not process content for the block $b$ before the end of \timeslot $t_k + \goodsep$,
then
that honest node must process the content for at least $\goodsepbw$ blocks on chains longer than the height of the block $b$ or in the prefix of the block $b$.
Since honest nodes produce blocks extending their longest chain, $b$ extends the longest processed chain of some honest node at \timeslot $t_k - 1$.
Let $b^*$ be the block produced in \timeslot $t_i$ where $\predCP{i}$ (suppose $i$ exists).
$\predCP{i} \implies \Yat{i} = 1$, therefore this block is unique, and also $t_k > t_i + \goodsep$.
Due to \cref{lem:cps-stabilize-informal}, any valid header chain longer than $b$ (which is some node's longest processed chain) at time slot $t_k$ must contain $b^*$.
Therefore, the only blocks
that are processed by an honest node during \timeslots $[t_k, t_k + \goodsep]$
\begin{enumerate}
    \item must be produced after $t_i$ because they extend $b^*$, and
    \item must be produced no later than $t_k$ because there are no blocks produced in $\intvl{t_k}{t_k+\goodsep}$.
\end{enumerate}
In case a \sltcp $i<k$ does not exist, the claim is trivial.
\end{proof}


\import{./figures/}{fig-ppivot-cpivot-intuitive.tex}


Given the above properties of the scheduling policy, we now want to show that \sltcps occur once in a while.
\Cref{fig:ppivot-cpivot-intuitive} illustrates the key argument for this.
To start, let us show that there is at least one \sltcp in $\intvl{0}{\Kcp}$.
From \cref{lem:many-pps-informal}, there are many \sltpps in $\intvl{0}{\Kcp}$.
If there were no \sltcps in $\intvl{0}{\Kcp}$, then the adversary must prevent each \sltpp from turning into a \sltcp.
We know that in any interval around a \sltpp, 
%
\sltgood \iindices outnumber \sltbad \iindices by a margin 
%
proportional to the interval size
(\appendixRef{\cref{prop:lower-tailbound-X}}, see top row in \cref{fig:ppivot-cpivot-intuitive}).
Therefore, for a \sltpp to not be a \sltcp, the adversary must prevent an honest node from processing the most recent honest block in several of these \sltgood \iindices (so that the corresponding $\Gat{k}=1$ \iindices have $\Dat{k}=0$).
\Cref{fig:ppivot-cpivot-intuitive} shows an example where the adversary prevented processing of the honest block in one \sltgood \iindex, and as a result, two of the \sltpps fail to become a \sltcp.
%
From \cref{prop:download-or-spend-budget}, for each such \iindex, the adversary must `spend' at least $\goodsepbw$ blocks that the honest node processes.
These blocks come from a `limited budget'. 
%
In \appendixRef{\cref{lem:one-cp-induction-base}}, through a combinatorial argument, we show that
this `budget' falls short of the number of blocks required to overthrow all \sltcps. Thus, there must be at least one \sltcp in $\intvl{0}{\Kcp}$.
%
%
Next, we would like to show that there is at least one \sltcp in $\intvl{m\Kcp}{(m+1)\Kcp}$ for all $m \geq 0$ (by induction, where 
we just saw the base case $m=0$).
Here,
one may be concerned that
the adversary could save up many blocks from the past and attempt to make honest nodes process these blocks at a particular target \timeslot $t_k$.
But, given that one \sltcp occurred in $\intvl{(m-1)\Kcp}{m\Kcp}$ (by induction hypothesis), \cref{prop:download-or-spend-budget} ensures that honest nodes will only process blocks that are produced after $(m-1)\Kcp$.
%
This allows us to bound the `budget' of blocks that the adversary can use to prevent \sltpps from becoming \sltcps, and 
we can complete the induction and conclude:
%
%
%
%
\begin{lemma}[\FormalVersion{\appendixRef{\cref{lem:many-pps-one-cps}}}]
\label{lem:many-pps-one-cps-informal}
    If honest nodes use the \rulelc scheduling policy,
    and in every interval of size at least $\Kcp$,
    at least a certain fraction of \BPOs are \sltpps
    %
    (which holds for 
    %
    $\blkrateslot, \blkratetime$ chosen as a function of the
    model and analysis parameters, as per \eqref{pow-max-tp}),
    %
    then for all $m \geq 0$,
    the interval $\intvl{m\Kcp}{(m+1)\Kcp}$ has at least one \sltcp.
    It follows that any arbitrary interval of length $2\Kcp$ contains at least one \sltcp.
\end{lemma}



%



%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%



%



%

%
%
%
%
%
%
%
%
%
%
%

%
%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

%

%
%
%
%
%
%
%
%
%
%


%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%



%
%
%
%
%
%
%
%
%
%
%
%
%


%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%



%

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
    
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
    
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
    
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
    
%
%
%
%
%
%
%
%
%
%
%



%
%
%
%
%
%
%

