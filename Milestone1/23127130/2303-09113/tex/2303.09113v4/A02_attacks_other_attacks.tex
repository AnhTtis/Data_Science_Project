\section{Other Congestion-Based Attacks}
\label{sec:general-attacks}


%
%


%
%
%
%
%
%
%
%


%
%
%
%
%
%

%




\subsection{\GreedyAttack}
%
\label{sec:greedy-attack}
%
The \teaserattack relied on the fact that the adversary could entice nodes with a long header chain that is later discovered to be unavailable for processing. It is natural in this case to consider adjusting the scheduling policy to one that prefers the proverbial `bird in the hand over two birds in the bush', \ie, to extend the blocks we already processed over the illusive promise of a longer chain that the adversary may withhold from us. 

%
\emph{\ruleGreedy policy.}\;\;
This policy prioritizes processing blocks that extend the chain a node has already processed. If a header of a block at height $h$ is announced, and we already have $h_i$ blocks from that chain,
%
we set the priority of the block to be $(h_i,h)$ and compare between the two priorities lexicographically.

While the \rulegreedy policy performs well at high processing rates, we unfortunately find that it performs poorly in the low processing rate regime. Specifically, if a fork in the chain occurs, and nodes are split evenly between the two alternatives, the fork may never resolve. This is because nodes extend their own chain, and prioritize processing on their side of the split while having insufficient processing power to catch up with the other alternative chain. A fork in the chain can result from a deliberate attack by an adversary that releases blocks selectively to different nodes, by a network split, or worse, by an unlucky timing of honest node mining events. In this case, the blockchain fails even for small adversaries. 
Importantly, a fork that never resolves is either a safety or a liveness failure, as no transaction on either side of the split can be safely accepted.

\import{./figures/}{fig-experiment-greedy.tex}

To demonstrate this scheduling policy in action, we simulate a network of 100 nodes that are split evenly between two partitions for only 15 seconds, \ie, for an expected time required to produce 15 blocks.%
\footnote{Such short splits are relatively easy to induce in reality (transient problems with Internet routing, denial-of-service on the network, etc.) and thus a practical scheduling rule must recover from such splits.}
Once the network split ends, the simulation continues for another 4000 seconds, allowing nodes the opportunity to 
converge on a chain.
%
We 
%
measure the height of the latest block all nodes agree upon. If nodes do not recover from the partition, 
this block will be the genesis and the liveness of the protocol has failed. Otherwise, nodes quickly agree on the main chain and the height of the latest agreed block is 
just a little behind the longest tip of the chain.

We simulate the evolution after a brief partition for both the \rulelc policy as well as for the \rulegreedy policy. Our results (\cref{fig:experiment-greedy}) show that in settings where capacity is greater than $1/2$, nodes manage to catch up with the chain and the rate of growth matches for both scheduling policies. In lower capacity settings, however, nodes never catch up.
Note that this attack requires no adversary mining,
yet the protocol is insecure (\cf \cref{fig:comparison-bddelay-bdbandwidth}(c)).
This is in stark contrast to the bounded-delay analysis
which suggests that the protocol retains security
against a non-mining adversary
%
at any capacity (\cf \cref{fig:comparison-bddelay-bdbandwidth}(a)),
and highlights again the need to study the security of blockchains at capacity.











\subsection{The \PoSTeaserAttack (PoS)}
\label{sec:pos-teaser-attack}

\import{./figures/}{fig-experiment-teaserequiv.tex}

\import{./figures/}{fig-attack-pos-teaser.tex}

In PoS, 
%
the adversary can greatly increase the network's processing load using equivocations. The \PoSteaserattack, described in \cref{fig:attack-pos-teaser}, uses equivocations to announce a whole new chain at every instance when the \teaserattack would have announced a single new block.
As the attack goes on, the length of the new announced chain increases. This increases the time honest nodes spend processing this chain, and \emph{decelerates} the honest chain growth until it comes to a halt. As a result,
in \cref{fig:experiment-teaser-pos}, 
the chain growth rate under the \PoSteaserattack is nearly zero.
%

As in the \teaserattack, the adversary starts by producing a private chain. Assuming the adversary's block production rate $\blkratetimeAdv$ is less than the honest chain growth rate before the attack ($\blkratetimeGrowthSilent$), the probability that the adversary produces a chain of length $k$ before the honest chain reaches length $k$ is $e^{-O(k)}$ \cite{nakamoto_paper,dem20}. This means that with probability $\epsilon$, the adversary eventually produces a private chain of length $k = O(\log(1/\epsilon))$, of which it can announce equivocations during the attack.
Since this chain is longer than the honest chain, it has higher scheduling priority.
It takes honest nodes $k/\bwtime$ time to process such a chain, during which time, honest nodes do not process blocks on the honest chain. So, any honest blocks produced within $k/\bwtime$ time after the first honest block at height $h$ do not grow the honest chain (\cref{fig:attack-teaser}(e)). If $\blkratetimeHon k/\bwtime$ is large, then there are many honest blocks that do not lead to chain growth, causing the chain growth rate $\blkratetimeGrowth$ to drop
(\cref{fig:experiment-teaser-pos}). 
As in the \teaserattack, if the adversary's block production rate $\blkratetimeAdv$ exceeds $\blkratetimeGrowth$, then the adversary succeeds in maintaining the number of block productions required for the attack to go on forever. This eventually slows honest chain growth to a halt. Thus, if $\blkratetimeHon k/\bwtime$ is large, \ie, $\blkratetimeHon = \Omega(1/k) = \Omega\left(\frac{1}{\log(1/\epsilon)}\right)$, then the attack succeeds with probability $\epsilon$.
%
%
%