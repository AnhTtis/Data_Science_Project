\begin{algorithm}[tb]%
    \caption{%
        Idealized functionality $\FtreePoSEquivBlank$:
        block production lottery and header chain structure
        for PoS
        (helper functions: \fullVersionRef{\cref{sec:algos-reference-helperfunctions}})%
    }%
    \label{alg:posequivblank-hdrtree}%
    \begin{algorithmic}[1]%
        \scriptsize%
        %
        
        %
        %
        %
        %
        %
        \LineComment{$\Call{init}{\genesisHeaderChain, \mathsf{numNodes}}$ and $\Call{verify}{\Chain}$ same as in \cref{alg:hdrtree-pow}}
        
        \LineComment{$\Call{isLeader}{P,t}$ same as in \cref{alg:hdrtree-pos}}
        %
        %
        %
        %
        %
        %
        %
        %
        %

        \On{$\Call{extend}{t', \Chain, \txs \textcolor{jnSUDigitalGreen}{, \eqProofs}}$ \textbf{from} $\mathcal A$ (adversary node $P$) or $\FtreePoS$}
                \label{loc:posequivblank-hdrtree-binding}
            \LineComment{New header chain is valid if parent chain $\Chain$ is valid, $P$ is leader for slot $t'$, and $t'$ is later than the tip of $\Chain$ and is not in the future}
            \If{$(\Chain\in\Tree) \land \FtreePoS.\Call{isLeader}{P,t'} \land (\Chain.\mathsf{time} < t' \leq t)$} 
                \LineComment{\textcolor{jnSUDigitalGreen}{Check
                equiv.\ pfs.\ 
                %
                are valid, point to `recent' headers,
                %
                and do not repeat}}
                %
                \label{loc:posequivblank-hdrtree-valid-eq-proof}
                \If{\textcolor{jnSUDigitalGreen}{$\forall (\Chain_1,\Chain_2) \in \eqProofs \colon (\Chain_1 \preceq \Chain) \land (\Chain_2 \in \Tree) \land (\Chain_1 \eqEquivocation \Chain_2)$ $\land (\len{\Chain_1} > \len{\Chain} - \keqproof) \land ((\Chain_1, \Chain_2) \not\in \bigcup_{\Chain' \preceq \Chain} \Chain'.\eqProofs) \}$
                %
                }}
                    \LineComment{Produce a new block header extending $\Chain$}
                    \State $\Chain' \gets \Chain\|\operatorname{newBlock}(\mathsf{time}\colon t', \mathsf{node}\colon P, \mathsf{txsHash}\colon \operatorname{Hash}(\txs))$ 
                    \State $\Tree \gets \Tree \cup \{\Chain'\}$
                        \Comment{Register new header chain in header tree}
                    \State \Return{$\Chain'$}
                \EndIf
            \EndIf
            \State \Return{$\bot$}
        \EndOn

        \On{$\Call{extend}{\Chain, \txs \textcolor{jnSUDigitalGreen}{, \eqProofs}}$ \textbf{from} node $P$ (possibly adversarial) \textbf{at} time slot $t$}
            \State \Return{$\FtreePoS.\Call{extend}{t, \Chain, \txs \textcolor{jnSUDigitalGreen}{, \eqProofs}}$}
        \EndOn
        

        
        %
        %
        %
        %
        %
    \end{algorithmic}%
\end{algorithm}%