%
\section{Predictable Validity}
\label{sec:throughputloss}


%
%

\subsection{Predictable Transaction Validity}
\label{sec:throughputloss:predictranvad}

\begin{definition}
    A transaction has \emph{predictable validity} if it is valid\footnote{In UTXO-based systems (e.g., Bitcoin), \textit{valid} means the inputs of the transaction have not been spent. In account-based systems (e.g., Ethereum), \textit{valid} means the transaction execution succeeds and fees are paid.} both at the time an honest node adds it to a block and when that block is executed.
\end{definition}

The sanitization in \sapos leads to a loss of \emph{predictable transaction validity}. An honest block $B$ may include a transaction that depends on the contents of a previous block $A$ whose equivocations were not known at the time. 
After block $B$ is produced, the adversary could release an equivocation for the block $A$, forcing honest nodes to sanitize block $A$'s contents, which may invalidate the transaction in block $B$. Such invalidated transactions take up free space in honest blocks and lower the effective throughput (valid confirmed transactions) of the ledger.

Traditional NC protocols, require a node to download and validate blocks before building on them, satisfying predictable validity. On the other hand, protocols which lack state determinism, such as DAG-based \cite{spiegelman2022bullshark,danezis2022narwhal} and LazyLedger \cite{al2019lazyledger} blockchain protocols, choose to forego predictable validity and accept that not all transactions will ultimately be executed.

We propose a simple solution to recover predictable validity for \sapos:
If nodes limit transactions included in a block to those that don't depend on any \emph{recent} state, then they can be sure that all equivocations that could affect the validity state of a transaction have a corresponding equivocation proof included in the chain. This is because at the time of creating a block, honest nodes \emph{have seen all transactions which will be executed}, however, \emph{not all transactions nodes have seen will be executed}. The following lemma follows naturally. See \fullVersionRef{\cref{sec:proof-details}} for proof details.

\begin{lemma}
    \label{lem:pred-valid-1}
    If a node produces a block whose transactions do not share state with any transaction included in the last $\keqproof$ blocks, then the block satisfies predictable transaction validity.
\end{lemma}


\subsection{Predictable Fee Validity}
\label{sec:throughputloss:predicfeevad}

In practice, for instance in popular Defi-ecosystems which consist of very interdependent transactions (e.g., transactions interacting with major token exchanges and other prominent smart contracts) \cite{guo2019graph,chen2020understanding}, it may not always be practical to limit the interaction between transactions. As an alternative to predictable transaction validity, we would like to preserve the minimum requirement that each transaction pays its fee, regardless of the outcome of its execution. This guarantees that miners are compensated for space used in their blocks, and also makes it costly for the adversary to take up space with invalid transactions.

\begin{definition}
    A transaction has predictable \emph{fee validity} if its fee can be paid both when an honest node adds it to a block and when that block is executed.
\end{definition}

In systems like Ethereum, transactions have a \emph{max gas} value set by the sender, which limits the computation allowed by the transaction and ultimately its fee. We consider a protocol with this gas mechanism, as well as a base transaction cost that covers the block space taken up by the transaction. 
We introduce a notion of \emph{gas deposit accounts} to \sapos that can only be used for transaction fees (transactions internally do not have access to these accounts).
When a miner includes a transaction, it checks that the account funding the transaction has enough funds to cover the maximum gas, even if all transactions in its recent ancestor blocks make it to the sanitized ledger and consume their maximum gas. Users thus need to maintain a balance proportional to the complexity and frequency of the transactions they make. Thus, users who primarily make simple transactions (direct transfers having low max gas) or transact infrequently (few transactions in recent ancestor blocks) need to maintain smaller balances than those who are spending more on fees. We also require that any deposit to the account is not considered in the balance until $\keqproof$ blocks after the deposit transaction. Withdraws however can take place immediately, as direct transactions.

\begin{lemma}
    \label{lem:pred-valid-2}
    If a node produces a block whose transactions are funded by gas deposit accounts with sufficient balance (balance before $\keqproof$ blocks minus any fees since),
    then all transactions in the block satisfy predictable fee validity.
\end{lemma}
See \fullVersionRef{\cref{sec:proof-details}} for proof details.
Thus, by sanitizing the contents of equivocating blocks and using our gas deposit scheme, we ensure that nodes download a maximum of one block per \timeslot and that honest block creators only include transactions that pay for their spot in the block.

The solutions in \cref{sec:throughputloss:predictranvad} and \cref{sec:throughputloss:predicfeevad} are complementary and could each be adopted as per-miner heuristics (i.e., not a consensus rule), or by the system based on the use-case (e.g., expected inter-dependency of transactions). Note that there are user-side complexities both schemes do not directly address. Since transactions can be sanitized, we can no longer rely on transaction nonce schemes that are strictly incremental but instead must relax them to strictly increasing. In lieu of stronger validity guarantees, it is the onus of the user to make sure their transactions behave correctly in the event some get sanitized. Sanitizing block content also opens up the potential for the adversary to perform free options (for a limited amount of time) by including transactions in a block that they can later decide to cancel (by revealing an equivocation at no cost within the allowed window).


