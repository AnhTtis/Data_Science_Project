\section{Scheduling Policies \& Attacks}
\label{sec:experiments}
Since download and processing resources are constrained, it becomes increasingly important to correctly prioritize the blocks that are downloaded and validated.  In this section we describe two possible scheduling policies for nodes running Nakamoto consensus. We show attacks tailored to each such policy and thus show that the choice of policy has a high impact on security. The attacks in this section apply to both PoW and PoS Nakamoto consensus, as the attacks only exploit the block production process that is common to both. The precise setup of the attacks is described in \secref{attacks-details}.

In the PoW setting, since headers contain all information needed to verify that enough work has been spent to mine the block, invalid block headers can be ignored, and the attacker is unable to produce blocks without spending computation. Similarly in the PoS setting, the attacker cannot produce blocks for a \timeslot where it is not elected a leader as per the PoS lottery. We restrict ourselves to process only blocks whose parent block is already fully validated. Thus, when we describe the priority of some header block as high, we actually start to process its first unprocessed ancestor.



\smallskip\noindent\textbf{The \ruleLC policy.}\;\;
This policy aims to match Nakamoto consensus' confirmation rule. It prioritizes the processing of blocks that are on the longest announced header chain, regardless of which blocks we already have. We assign each unprocessed header a priority $h$ if it is on a header chain of height $h$.


\smallskip\noindent\textbf{The \ruleGreedy policy.}\;\;
This policy prioritizes downloading blocks that extend the chain a node has already processed. If a header of a block at height $h$ is announced, and we already have $h_i$ blocks from that chain, then we set the priority of the block to be $(h_i,h)$ and compare between the two priorities lexicographically.

%
%

%

\subsection{Attacking the \ruleLC Policy: The \TeaserAttack}
\label{sec:teaser-attack}

\import{./figures/}{fig-attack-teaser.tex}
The \ruleLC policy seems to be a natural policy when considering the longest-chain protocol. We would like to consider attacks that break the safety or liveness of the chain using as little mining power as possible. The naive attack strategy, 
%
that bounded-delay analysis suggests to be worst-case~\cite{dem20},
is to have the attacker mine a secret chain of blocks without releasing any blocks to the network. If the attacker is able to outpace the rate of growth of the honest chain, it can publish its blocks at will, and undo all transactions in the blockchain.
Since honest nodes take time to process each block, the rate of growth of the chain is slower than the honest nodes' block creation rate and the attacker can more easily succeed in this naive attack if bandwidth is low.
%
This effect is detailed in \secref{experiment-growth}.
But can we do better than this attack?

\smallskip\noindent\textbf{The \TeaserAttack.}\;\;
We show that in fact, an adversary can strategically announce headers and release blocks in a way that will exploit the \rulelc policy to waste some processing done by the honest nodes. In \figref{attack-teaser}, we describe the \teaserattack that achieves this. We see that this attack utilizes the chain that the attacker constructs not only to later overtake the public chain, but also to induce processing of one extra block for every block that grows the length of the honest chain. It therefore effectively doubles the processing invested per growth event of the public main chain. To entice nodes to process blocks needlessly, the attacker reveals a long header chain from its secret chain, teasing the nodes to download a block from that chain, but makes the rest of the blocks unavailable for download.
%

\import{./figures/}{fig-experiment-teaser.tex}

To demonstrate the attack, we simulate a network with 100 nodes that together create 1 block per second.
The simulations were written as event-driven simulations using Python's simpy package.\footnote{Source code: \gitSourceUrl}
See \secref{attacks-details} for details on the implementation and setup.
To start the attack, the attacker must pre-mine a short private chain longer than the honest chain. Even if the attacker's mining rate is lower than the honest mining rate, the attacker still succeeds in doing this with some probability. Thereafter, it starts the \teaserattack and the subsequent increased processing delays slow down the honest chain growth rate, which allows the adversary to maintain its lead.

We compare the rate of growth of the honest chain when the attacker mines silently and does not publish blocks (private attack) to the scenario in which a \teaserattack (\figref{attack-teaser}) is being carried out. The chain's rate of growth then sets the bound on the system's security: if the attacker manages to mine faster than the honest network is growing (\ie $\blkratetimeAdv > \blkratetimeGrowth$), then it is able to continue the attack indefinitely.

\Figref{experiment-teaser} depicts the result of our simulation. It shows
%
that with the \teaserattack, the network's processing power is slowed roughly by a factor of $2$. As a result, the effective delay of block propagation increases, and the attacker succeeds with greater ease compared to the naive attack. 
Since the silent attack is the worst-case attack 
for Nakamoto consensus according to bounded-delay analysis~\cite{dem20},
%
%
the \teaserattack demonstrates that scheduling policies must be taken into account when considering the security of the protocol, and sufficient capacity needs to be provisioned to ensure security.


\subsection{The \ruleGreedy Policy and the \GreedyAttack}
\label{sec:greedy-attack}

The \teaserattack relied strongly on the fact that the attacker could entice nodes with a long header chain that is later discovered to be unavailable for download. It is natural in this case to consider adjusting the download rule to one that prefers the proverbial `bird in the hand over two birds in the bush', \ie, to extend the blocks we already downloaded over the illusive promise of a longer chain that the attacker may withhold from us. 

While the \rulegreedy policy performs well at high processing rates, we unfortunately find that it preforms poorly in the low processing rate regime. Specifically, if a fork in the chain occurs, and nodes are split evenly between the two alternatives, the fork may never resolve. This is because nodes extend their own chain, and prioritize download on their side of the split, while having insufficient processing power to catch up with the other alternative chain. A fork in the chain can result from a deliberate attack by an attacker that releases blocks selectively to different nodes, by a network split, or worse, by an unlucky timing of honest node mining events. In this case, the blockchain fails even for small attackers. 
Importantly, a fork that never resolves is either a safety or a liveness failure, as no transaction on either side of the split can be safely accepted.

\import{./figures/}{fig-experiment-greedy.tex}

To demonstrate this download rule in action, we simulate a network of 100 nodes that are split evenly between two partitions for only 15 seconds, \ie, for an expected time required to produce 15 blocks.%
\footnote{Such short splits are relatively easy to induce in reality (transient problems with Internet routing, denial-of-service on the network, etc.) and thus a practical scheduling rule must recover from such splits.}%
Once the network split ends, the simulation continues for another 4000 seconds, allowing nodes the opportunity to 
converge on a chain.
%
We 
%
measure the height of the latest block all nodes agree upon. If nodes do not recover from the partition, 
this block will be the genesis and the liveness of the protocol has failed. Otherwise, nodes quickly agree on the main chain and the height of the latest agreed block is 
just a little behind the longest tip of the chain. 

%

We simulate the evolution after a brief partition for both the \rulelc policy as well as for the \rulegreedy policy. Our results (\figref{experiment-greedy}) show that in settings where bandwidth is greater than $1/2$, nodes manage to catch up with the chain and the rate of growth matches for both scheduling policies. In lower bandwidth settings, however, nodes never catch up.
Note that this attack requires no adversarial mining,
yet the protocol is insecure (\cf \figref{comparison-bddelay-bdbandwidth}(c)).
This is in stark contrast to the bounded-delay analysis
which suggests that the protocol retains security
against a non-mining adversary
%
at any bandwidth (\cf \figref{comparison-bddelay-bdbandwidth}(a)),
and highlights again the need to study the security of blockchains at capacity.



%
%


