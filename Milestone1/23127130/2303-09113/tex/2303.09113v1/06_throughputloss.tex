%
\section{Predictable Transaction Validity}
\label{sec:throughputloss}

As discussed in \secref{pos-equivocations}, our PoS protocol variant \sapos requires that honest nodes build on top of a header chain whose full block contents they
cannot download (due to having already downloaded other blocks from the same  equivocating \BPO).
In Bitcoin's history, such mining without validating block contents (termed SPV mining) has led to forks where some miners were extending blocks which later turned out to be invalid \cite{kaushal2017evolution}.
Thus, reaching consensus on the header chain is not enough,
we need to consider how nodes catch up to and handle missing block contents.

One option to consider is using excess bandwidth to \emph{catch-up} to the longest chain's contents. Here we hit the crux of what is termed the \emph{data availability (DA) problem}~\cite{DBLP:conf/fc/Al-BassamSBK21}. We must guarantee that the contents of the blocks
is available. DA would be satisfied if nodes only extended blocks that at least one honest node had downloaded the contents of. %
%
\emph{The problem is that we don't know who is honest.} %

In lieu of a DA scheme, in \sapos(\secref{pos-equivocations}) we choose instead to \emph{sanitize}, or exclude, the contents of equivocations from the ledger so no additional block downloads are needed and chain quality (more honest than dishonest blocks in the ledger) holds. \emph{We still have the problem of predictable transaction validity---honest blocks may include transactions that depend on content from blocks whose equivocations were not known at the time}. %
Additionally, the adversary could use equivocations to invalidate transactions, taking up free space in honest blocks and lowering the effective throughput (valid confirmed transactions) of the ledger.
%
We thus decouple the validity of transactions at the time they are added to a block, from when they are executed post-consensus.

%


%

%
%

%

%
%


\begin{definition}
    A transaction has \emph{predictable validity} if it is valid both at the time an honest node adds it to a block and when that block is executed.
\end{definition}

Traditional LC protocols, which require a node to download and validate blocks before building on them, satisfy this definition as the state before the block is executed is deterministic. With our equivocation scheme, an honest node cannot know if a \emph{recent} block will be equivocated. What we can guarantee is that at the time of creating a block, honest nodes \emph{have seen all transactions which will be executed}. Unfortunately, the converse is not correct: \emph{not all transactions nodes have seen will be executed}. If nodes limit transactions included in a block to those that don't depend on any \emph{recent} state, then they can be sure all equivocations that could affect the validity state of a transaction have been included. The following lemma follows naturally.

%

%
%

\begin{lemma}
    \label{lem:pred-valid-1}
    If a node produces a block whose transactions do not share state with any transaction included in the last $\keqproof$ blocks, then the block satisfies predictable transaction validity.
\end{lemma}
See \secref{proof-details} for proof details.

%

%

Block creators thus choose which transactions to include in a block so they remain valid and pay for their block space, note this is not a consensus rule.
%
In practice, the Defi-ecosystem consists of very interdependent transactions (e.g., transactions interacting with major token exchanges and other prominent smart contracts) \cite{guo2019graph,chen2020understanding}, so it may not be practical to limit the interaction between transactions. The key property we want to guarantee is that any transaction included in an honest block that is part of the canonical chain will be paid for, i.e., the adversary cannot take up free honest block space, so we relax the definition of predictable validity.

\begin{definition}
    A transaction has predictable  \emph{fee validity} if its fee can be paid both when an honest node adds it to a block and when that block is executed.
\end{definition}

The block creator only needs to ensure that the transaction will be paid for, regardless of the outcome of its execution, so \emph{we decouple the fee mechanism from the transaction validity.}  %
Since the cost of transacting in smart contract platforms depends on the length of execution which, in turn, depends on state, we must also be sure to include a cost for the transaction size in \sapos that is paid independently of execution gas costs.
This is to ensure that attackers won't be able to spam the blockchain with transactions that are later sanitized, but still take up space in blocks.
%
%

Then for the miner to get paid, we require that the account funding the transaction has enough funds to cover the maximum gas, even if all transactions in its recent ancestor blocks are make it to the sanitized ledger and consume the maximum gas they could possibly need. To do this, we introduce a notion of \emph{gas deposit accounts} to \sapos that can only be used for transaction fees (transactions internally do not have access to these accounts).
The maximum gas for a transaction can be bounded using the maximum gas value set be the sender in Ethereum-style transactions.
Therefore, users who primarily make simple transactions (direct transfers having low maximum gas) or transact infrequently (few transactions in recent ancestor blocks) only need to maintain little balance.
We also require that any deposit to the account is not considered in the balance until $\keqproof$ blocks after the deposit transaction. Withdraws however can take place immediately, as direct transactions.


%
%

\begin{lemma}
    \label{lem:pred-valid-2}
    If a node produces a block whose transactions are funded by gas deposit accounts with sufficient balance (balance before $\keqproof$ blocks minus any fees since),
    then all transactions in the block satisfy predictable fee validity.
\end{lemma}
See \secref{proof-details} for proof details.

Thus, by sanitizing the contents of equivocating blocks and using our gas deposit scheme, we ensure that nodes download a maximum of one block per \timeslot and that honest block creators only include transactions that pay for their spot in the block.

Note that in our scheme, we are primarily concerned with effective throughput as honest block space taken up by transactions that pay their place in the blockchain. There are user-side complexities that our scheme does not directly address. Since transactions can be sanitized, we can no longer rely on transaction nonce schemes that are strictly incremental but instead must relax them to strictly increasing. In lieu of stronger validity guarantees, it is the onus of the user to make sure their transactions behave correctly in the event some get sanitized. Sanitizing block content also opens up the potential for the adversary to perform free options (for a limitted amount of time) by including transactions in a block that they can later decide to cancel (by revealing an equivocation at no cost within the allowed window).


