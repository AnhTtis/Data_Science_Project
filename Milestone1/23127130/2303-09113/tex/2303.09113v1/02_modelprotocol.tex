\section{Protocol \& Model}
\label{sec:modelprotocol}

%
Pseudocode of an idealized LC protocol $\protocol$ is provided in \algref{generic-lc-protocol}.
Details of the protocol's resource-based block production lottery, \ie, of production and verification of blocks, are abstracted through an idealized functionality $\Ftree$ (\cf~\cite[Fig.~2]{sleepy}, \cite[Alg.~3]{bwlimitedposlc}).
Pseudocode for instantiations $\FtreePoW$ and $\FtreePoS$ modeling proof-of-work (PoW) and proof-of-stake (PoS) are provided in \algref{hdrtree-pow} and \algref{hdrtree-pos}, respectively.
Helper functions used in the pseudocode are detailed in \secref{algos-reference-helperfunctions}.
We study these protocols in a unified model for a network $\Env$ with finite bandwidth (\figref{model}), and for the powers and limits of an adversary $\Adv$.



\subsection{Longest Chain Protocols}
\label{sec:modelprotocol-protocolfeatures}

\import{./figures/}{alg-generic-lc-protocol.tex}
\import{./figures/}{alg-hdrtree-pow.tex}
\import{./figures/}{alg-hdrtree-pos.tex}
\import{./figures/}{alg-longest-header-chain-rule.tex}

%
%
%
%

For ease of exposition, the execution features a \emph{static} set of $N$ \emph{equipotent} \emph{nodes}, each of which runs an independent instance of $\protocol$.
Temporary crash faults (`sleepiness') of nodes (in PoW and PoS), heterogeneous distribution of hash power (in PoW) or stake (in PoS), and stake shift (in PoS)
or difficulty adjustment (in PoW),
are left to be addressed with techniques from~\cite{david2018ouroboros,snowwhite,sleepy,DBLP:conf/crypto/GarayKL17}.
%
We are interested in the large system regime $N\to\infty$.
Nodes interact with each other and with the adversary $\Adv$ through an environment $\Env$ that models the network and is detailed in \secref{modelprotocol-modelfeatures,algos-reference-environment}.
The protocol proceeds in \emph{\timeslots} of duration $\slotduration$ (\myalgref{generic-lc-protocol}{generic-lc-protocol-mainloop}).
At each \timeslot $t$, the protocol queries the block production lottery $\Ftree$ in an attempt to extend the longest downloaded chain $\dC$ in the node's view with a new block 
of
%
pending transactions $\txs$.
If successful, the node disseminates both the resulting \emph{block header} $\Chain'$ and the associated \emph{block content} $\txs$ via the environment $\Env$ to all nodes.
%
%
Finally, the protocol identifies the $\confDepth$-deep prefix $\dC\trunc{\confDepth}$ containing all but the last $\confDepth$ blocks of $\dC$.
The transactions along $\dC\trunc{\confDepth}$ are concatenated to produce the output ledger $\LOG{}{t}$.
%
%
%

When a node $p$ receives a new valid block header $\Chain$ (\myalgref{generic-lc-protocol}{generic-lc-protocol-receiveheader}), $p$ adds $\Chain$ to its header tree $\hT$, records $\Chain$ as first seen at the current \timeslot, and relays $\Chain$ to all other nodes via $\Env$.
Throughout the execution, the protocol requests from $\Env$ the content 
for
%
block headers 
%
decided by a download priority rule (\myalgref{generic-lc-protocol}{generic-lc-protocol-downloadrule}).
As a concrete example, we use the `download longest header chain' rule (\algref{longest-header-chain-rule})
in which
a node downloads content for the first block header with unknown content on the longest header chain it has seen.
%
%
Once a valid block's content is received (\myalgref{generic-lc-protocol}{generic-lc-protocol-receivecontent}), the node makes it available to other nodes via $\Env$, and updates its 
%
$\dC$.


\paragraph{Proof-of-Work}
%
The characteristics of PoW-based block production, \eg, in Bitcoin~\cite{nakamoto_paper,backbone}, are captured by the idealized functionality $\FtreePoW$ (\algref{hdrtree-pow}).
Each block production attempt is committed to a parent block and block content (\myalgref{hdrtree-pow}{hdrtree-pow-binding}), and only a single block is produced when the attempt is successful.
Per \timeslot, each node can make one block production attempt that will be successful with probability $\blkrateslot/N$, independently of other nodes and \timeslots (\myalgref{hdrtree-pow}{hdrtree-pow-blockproductionlottery}).
This model, for ease of exposition, assumes uniform hash power across all nodes.
Since each \timeslot represents a single PoW evaluation, we study PoW in the regime $\blkrateslot = \Theta(\slotduration)$, $\slotduration \to 0$.
In turn as $\blkrateslot \to 0$, with probability $1$, each \timeslot produces at most one block across all nodes.
%
%
The PoW model thus implies that every block must be produced in a \timeslot \emph{strictly after} its parent block.


\paragraph{Proof-of-Stake}
%
PoS LC protocols such as from the Ouroboros~\cite{kiayias2017ouroboros,david2018ouroboros,badertscher2018ouroboros} or Sleepy Consensus~\cite{sleepy,snowwhite} families can be modeled using $\FtreePoS$ (\algref{hdrtree-pos}).
As in PoW, each node can make one block production attempt per \timeslot that will be successful with probability $\blkrateslot/N$, independently of other nodes and \timeslots (\myalgref{hdrtree-pos}{hdrtree-pos-blockproductionlottery})%
\footnote{There may be multiple blocks in one \timeslot, as in
%
%
the Ouroboros~\cite{kiayias2017ouroboros,david2018ouroboros,badertscher2018ouroboros} and Sleepy Consensus~\cite{sleepy,snowwhite} protocols.}%
, modeling uniform stake.
In PoS, however, (even past) block production opportunities can be `reused' to produce multiple blocks with different parents and/or content, \ie, to equivocate (\myalgref{hdrtree-pos}{hdrtree-pos-leader,hdrtree-pos-binding}).
The regime of interest is $\slotduration = \Theta(1)$.
%
%
%
%
%



\subsection{Bandwidth Constrained Network}
\label{sec:modelprotocol-modelfeatures}

\import{./figures/}{fig-model.tex}

We borrow the bandwidth constrained network model of~\cite{bwlimitedposlc} (\figref{model}).
In this model, $\Env$ abstracts push-based flooding of `small' block headers and pull-based downloading of `large' block contents from peers.
%
Block header chains sent via $\Env.\Call{broadcastHeaderChain}{}$ are eventually delivered by $\Env$ to every node,
%
\cf~\myalgref{generic-lc-protocol}{generic-lc-protocol-receiveheader}.
Headers are delivered with a per-node per-header delay determined by $\Adv$, up to a commonly known delay upper bound $\DeltaHeader$.
%
Block content made available via $\Env.\Call{uploadContent}{}$ is kept by $\Env$ in what can be thought of as a `cloud'.
Nodes can request the content associated with a particular header.
If content matching the header is available, then it is delivered by $\Env$ to the node,
%
\cf~\myalgref{generic-lc-protocol}{generic-lc-protocol-receivecontent}.
Content download is subject to a per-node bandwidth constraint of~$\bwtime$.
%
See \secref{algos-reference-environment} for a more formal description of $\Env$.

The `cloud' captures key properties of pull-based
peer-to-peer 
%
downloading. At first, content matching a particular header might not be available (\eg, $\Adv$ produced a block and disseminated its header, but withheld its content). Later, such content can become available (\eg, $\Adv$ releases the content to one honest node). Thus, the `cloud' ensures neither data availability nor strong consistency of query outcomes, unlike stronger primitives such as
verifiable information dispersal
%
\cite{avid,avidfp,dispersedledger,semiavidpr}. However, once content for a header does become available, it is unique and remains available. This captures the header's binding commitment to the content, and the fact that honest nodes share content 
%
with peers. Requests for unavailable content do not count towards the download budget.
Also note that the adversary can push headers and content bypassing bandwidth and delay constraints, and this models non-uniform bandwidth across nodes, and additional effects (analogous to adversarially controlled delay up to maximum $\Delta$ in the bounded delay model).


\paragraph{Powers and Limits of the Adversary}
%
The \emph{static} adversary $\Adv$ chooses a set of nodes (up to a fraction $\beta$ of all $N$ nodes, where $\beta$ is common knowledge) to corrupt before the randomness of the execution is drawn and the execution commences. Uncorrupted \emph{honest} nodes follow $\protocol$ at all times. Corrupted \emph{adversarial} nodes follow arbitrary computationally bounded \emph{Byzantine} behavior, coordinated by $\Adv$ in an attempt to break consensus.
%
Among other things, the adversary can:
withhold block headers and content, or release them late or selectively to honest nodes;
push headers and content to nodes while bypassing the delay and bandwidth constraints;
break ties in $\protocol$'s chain selection and content download policy;
in PoS, reuse block production opportunities to produce multiple blocks (\emph{equivocations}, \cf~$\FtreePoS.\Call{extend}{}$), and extend chains using past opportunities as long as the purported block production \timeslots along every chain remain strictly increasing.



\subsection{Security of Ledger Protocols}
\label{sec:modelprotocol-ledgersecurity}

For an execution of $\protocol$ where every honest node $p$ at every \timeslot $t$ outputs a ledger $\LOG{p}{t}$, we recall the security desiderata:
\begin{itemize}
    \item \emph{Safety:}
          For all adversarial strategies, for all \timeslots $t,t'$, and for all honest nodes $p, q$: $\LOG{p}{t}\preceq\LOG{q}{t'}$ or $\LOG{q}{t'}\preceq\LOG{p}{t}$.
    \item \emph{Liveness with parameter $\Tlive$:}
          For all adversarial strategies, if a transaction $\tx$ is received by all honest nodes by \timeslot $t$,
          then for every honest node $p$ and for all \timeslots $t' \geq t+\Tlive$, $\tx \in \LOG{p}{t'}$.
\end{itemize}
A consensus protocol is \emph{secure over \timeslot horizon $\Thorizon$ with parameter $\Tlive$} iff it satisfies safety, and liveness with parameter $\Tlive$, with overwhelming probability over executions of \timeslot horizon $\Thorizon$.

%
%
%
%
%
%
%
%
%



\subsection{Notation}
\label{sec:modelprotocol-notation}

Nodes are identified using $p, q$.
%
%
Our notation distinguishes between three notions of `time':
\emph{\Timeslots} of $\protocol$ are indicated by $r, s, t$.
\Timeslots in which one or more blocks are produced form a sub-sequence $\{t_k\}$, defined in \secref{analysis-definitions}.
\emph{\Iindices} into this sub-sequence are denoted by $i, j, k$.
%
Physical parameters of our model,
%
%
%
header propagation delay $\DeltaHeader$ and bandwidth $\bwtime$, are specified in units of \emph{real time}.
%

We denote intervals of \iindices (or \timeslots) as $\intvl{i}{j} \triangleq \{i+1,...,j\}$, with the convention that $\intvl{i}{j} \triangleq \emptyset$ for $j \leq i$.
We study executions over a finite horizon of $\Thorizon$ \timeslots (or $\Khorizon$ \iindices), and any interval $\intvl{i}{j}$ with $i < 0$ or $j > \Khorizon$ considered truncated accordingly.
The notation $\intvl{i}{j} \intvlg K$ (resp.\ $\intvlgeq, \intvll, \intvlleq, \intvleq$) is short for $j-i > K$ (resp.\ $\geq, <, \leq, =$).
In the analysis, we denote with upper-case Latin letters several random processes over \iindices (\eg, $\Xat{k}$) or \timeslots (\eg, $\Hat{t}$).
For any set $I$ of \iindices (analogously for \timeslots), we define $\Xat{I} \triangleq \sum_{k \in I} X_k$.

%
We denote by $\kappa$ the security parameter. An event $\Event_{\kappa}$ occurs \emph{with overwhelming probability} (\emph{\wop}) if $\Prob{\Event_{\kappa}} \geq 1 - \negl(\kappa)$.
Here, a function $f(\kappa)$ is \emph{negligible} $\negl(\kappa)$, if for all $n>0$, there exists $\kappa_n^*$ such that for all $\kappa > \kappa_n^*$, $f(\kappa) < \frac{1}{\kappa^n}$.

