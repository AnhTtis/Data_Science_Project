\section{Protocol Algorithms Reference}
\label{sec:algos-reference}

\subsection{Helper Functions for Pseudocode}
\label{sec:algos-reference-helperfunctions}

\begin{itemize}
      \item $\operatorname{Hash}(\txs)$:\;\;
%
            %
            Cryptographic hash function to produce
            a binding commitment to $\txs$
            (modelled as a random oracle)

      \item $\Chain' \preceq \Chain$, $\Chain \succeq \Chain'$:\;\;
%
            %
            Relation describing that $\Chain'$ is a prefix of $\Chain$

      \item $\Chain \| \Chain'$:\;\;
%
            %
            Concatenation of $\Chain$ and $\Chain'$

      \item $\len{\Chain}$:\;\;
%
            %
            Length of $\Chain$

      \item $(\TRUE \text{ with probability $x$, else } \FALSE)$:\;\;
%
            %
            Bernoulli random variable with success probability $x$

      \item $\operatorname{prefixChainsOf}(\Chain)$:\;\;
%
            %
            Set of prefixes of $\Chain$, \ie, all $\Chain'$ with $\Chain' \preceq \Chain$

      \item $\operatorname{newBlock}(\mathsf{txsHash}\colon \operatorname{Hash}(\txs))$ and
      \\
      $\operatorname{newBlock}(\mathsf{time}\colon t, \mathsf{node}\colon P, \mathsf{txsHash}\colon \operatorname{Hash}(\txs))$:\;\;
%
            %
            Produce a new PoW and PoS block header with
            given parameters, respectively

      \item $\operatorname{txsLedger}(\TxsMap, \Chain)$:\;\;
%
            %
            Concatenates the block contents stored in $\TxsMap$ for the blocks along the chain $\Chain$, to obtain the corresponding transaction ledger
        
        \item $(\Chain \eqEquivocation \Chain') \triangleq (\Chain \neq \Chain') \land (\Chain.\mathsf{node} = \Chain'.\mathsf{node}) \land (\Chain.\mathsf{time} = \Chain'.\mathsf{time})$:\;\;
        Relation for distinct headers from the same \BPO
\end{itemize}

%


\subsection{Environment $\Env$}
\label{sec:algos-reference-environment}

%
%
The environment $\Env$ initializes $N$ nodes and lets $\Adv$ corrupt up to $\beta N$ nodes at the beginning of the execution. Corrupted nodes are controlled by the adversary. Honest nodes run $\protocol$.
The environment maintains a mapping $\Env.\TxsMap$ from block headers to the block content (transactions). This mapping is referred to as the `cloud' in \secref{modelprotocol} and \figref{model}.
%
$\Env$ also maintains for each node a queue of pending block headers
to be delivered after a delay determined by the adversary.
If $\Adv$ has not instructed $\Env$ to deliver a header $\DeltaHeader$ real time after it was added to the queue of pending block headers,
then $\Env$ delivers it to the node.
%

Honest nodes and $\Adv$ interact with $\Env$ via the following functions:
\begin{itemize}
      \item $\Env.\Call{broadcastHeaderChain}{\Chain}$:

            \noindent If called by an honest node, $\Env$
            enqueues $\Chain$ in the queue of pending block headers for each node, and notifies $\Adv$.
            %
            Then, for each node $P$, on receiving $\Call{deliver}{\Chain,P}$ from $\Adv$,
            or when $\DeltaHeader$ time has passed since $\Chain$
            was added to the queue of pending headers, $\Env$ triggers $P.\Call{receivedHeaderChain}{\Chain}$.

      \item $\Env.\Call{uploadContent}{\Chain, \txs}$:

            \noindent $\Env$ stores a mapping from the header chain $\Chain$ to the content $\txs$ of its last block by setting $\Env.\TxsMap[\Chain] = \txs$.
            $\Env$ only stores the content $\txs$
            if $\mathrm{Hash}(\txs) = \Chain.\mathsf{txsHash}$.

      \item $\Env.\Call{receivePendingTxs}{\null}$:

            \noindent $\Env$ generates a set of pending
            transactions and returns them.
    
    \item
        If node $P$ at \timeslot $t$ requests the content associated with a block header $\Chain$, $\Env$ acts as follows.
        %
        %
If $\Env.\TxsMap[\Chain]$ is set, then let $\txs = \Env.\TxsMap[\Chain]$ (if not, $\Env$ ignores the request).
%
If the request was received from an honest node $P$,
if $\Env$ has recently triggered $P.\Call{receivedContent}{.}$ at a rate below $\bwtime$,
%
then $\Env$ triggers  $P.\Call{receivedContent}{\Chain, \txs}$ (else, $\Env$ ignores the request).
If the request was received from $\Adv$, $\Env$ sends $(\Chain, \txs)$ to $\Adv$.
\end{itemize}

At all times, $\Adv$ can trigger $P.\Call{receivedHeaderChain}{\Chain}$
and $P.\Call{receivedContent}{\Chain, \txs}$
for honest nodes $P$ (bypassing header delay and bandwidth constraint in an adversarially chosen way).

%
%
%
%
%
%
