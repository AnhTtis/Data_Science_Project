\subsubsection{Many Probabilistic Pivots Imply One Combinatorial Pivot}
\label{sec:fullproof-analysis-many-pps-one-cps}

The \rulelc rule $\dlrulelong$
(\cref{alg:longest-header-chain-rule})
has a few useful properties.
Intuitively, nodes using this rule 
\begin{enumerate}[(P1),leftmargin=3em]
    \item \label{item:good-download-rule-no-repeat}
    download a \BPO's block's content at most once,
    \item \label{item:good-download-rule-honest-block} either download the most recent honest block, or fully utilize their bandwidth to download other blocks (\ie, do not stay idle), and
    \item \label{item:good-download-rule-cutoff} prioritize blocks that were produced `recently'.
\end{enumerate}


\ref{item:good-download-rule-no-repeat} holds by construction.
\ref{item:good-download-rule-honest-block} holds because the download rule $\dlrulelong$
is never idle, and 
will always download towards an honest block
when it has downloaded all longer chains
and there is bandwidth remaining.
Moreover, we expect that in a secure execution,
\ref{item:good-download-rule-cutoff} holds because the longest header chain cannot fork off too much from the longest downloaded chain of an honest node, otherwise it would imply a safety violation.
More precisely, due to \cref{lem:cps-stabilize},
any longest header chain in any honest node's view must extend the block produced in the most recent \sltcp, and therefore blocks with the highest download priority must have been produced after the most recent \sltcp.
If the adversary wants to prevent honest nodes from downloading the block produced at a \sltgood \iindex $k$,
so that $G_k = 1$ but $D_k = 0$, then it can only ``distract'' them by providing $\goodsepbw$ blocks
produced after the most recent \sltcp
(\cref{prop:download-or-spend-budget}).

%
%
%
%
%
%
\RestatePropDownloadOrSpendBudget*

\begin{proof}
In \timeslot $t_k$, there is exactly one block $b$ produced by an honest node, 
the block header is made public at the beginning of the \timeslot,
and is seen by all honest nodes within $\DeltaHeader$ time.
Thereafter, each node has enough time to download $\goodsepbw$ blocks during \timeslots $[t_k, t_k + \goodsep]$.

Under the download rule $\dlrulelong$,
if $\Dat{k} = 0$,
\ie an honest node did not download content for the block $b$ before the end of \timeslot $t_k + \goodsep$,
then
that honest node must download the content for at least $\goodsepbw$ blocks on chains longer than the height of the block $b$ or in the prefix of the block $b$.
Since honest nodes produce blocks extending their longest chain, $b$ extends $\dC_p(t_k-1)$ for some $p$.
Let $b^*$ be the block produced in \timeslot $t_i$ where $\predCP{i}$ (suppose $i$ exists).
$\predCP{i} \implies \Yat{i} = 1$, therefore this block is unique, and also $t_k > t_i + \goodsep$.
Due to \cref{lem:cps-stabilize}, any valid header chain longer than $b$ at time slot $t_k$ must contain $b^*$.
Therefore, the only blocks
that are downloaded by an honest node during \timeslots $[t_k, t_k + \goodsep]$
\begin{enumerate}
    \item must be produced after $t_i$ because they extend $b^*$, and
    \item must be produced no later than $t_k$ because there are no blocks produced in $\intvl{t_k}{t_k+\goodsep}$.
\end{enumerate}
In case a \sltcp $i<k$ does not exist, the claim is trivial.
\end{proof}


%


Given the above properties of the download rule, we now want to show that \sltcps occur once in a while.
\Cref{fig:ppivot-cpivot-intuitive} illustrates the key argument for this.
To start, let us show that there is at least one \sltcp in $\intvl{0}{\Kcp}$.
From \cref{lem:many-pps}, there are many \sltpps in $\intvl{0}{\Kcp}$.
If there were no \sltcps in $\intvl{0}{\Kcp}$, then the adversary must prevent each \sltpp from turning into a \sltcp.
We know that in any interval around a \sltpp, there are more \sltgood \iindices than \sltbad \iindices (see top row in \cref{fig:ppivot-cpivot-intuitive}). In fact, \sltgood \iindices outnumber \sltbad \iindices by a margin that increases linearly with the size of the interval (\cref{prop:lower-tailbound-X}).
Therefore, for a \sltpp to not be a \sltcp, the adversary must prevent an honest node from downloading the most recent honest block in several of these \sltgood \iindices (so that the corresponding $\Gat{k}=1$ \iindices have $\Dat{k}=0$).
\Cref{fig:ppivot-cpivot-intuitive} shows an example where the adversary prevented download of the honest block in one \sltgood \iindex, and as a result, two of the \sltpps fail to become a \sltcp.
In \cref{lem:one-cp-induction-base}, through a combinatorial argument, we show that to prevent all of $n$ \sltpps in $\intvl{0}{\Kcp}$ from becoming \sltcps, the adversary must prevent download of the honest block in at least $n/4$ \sltgood \iindices in $\intvl{0}{2\Kcp}$.
From \cref{prop:download-or-spend-budget}, for each such \iindex, the adversary must `spend' at least $\goodsepbw$ blocks that the honest node downloads.
These blocks must come from a `budget' that can contain at most all blocks mined during $\intvl{0}{2\Kcp}$.
If this `budget' falls short of the number of blocks required to overthrow all \sltcps, then there must be at least one \sltcp in $\intvl{0}{\Kcp}$.


Next, we would like to show that there is at least one \sltcp in $\intvl{m\Kcp}{(m+1)\Kcp}$ for all $m \geq 0$ (where 
we just saw the base case $m=0$).
Here,
one may be concerned that
the adversary could save up many blocks from the past and attempt to make honest nodes download these blocks at a particular target \timeslot $t_k$.
But given that one \sltcp occurred in $\intvl{(m-1)\Kcp}{m\Kcp}$, \cref{prop:download-or-spend-budget} ensures that honest nodes will only download blocks that are produced after $(m-1)\Kcp$.
This allows us to bound the `budget' of blocks that the adversary can use to overthrow \sltcps, and therefore show that there is at least one \sltcp in $\intvl{m\Kcp}{(m+1)\Kcp}$.
This argument is formalized in \cref{lem:one-cp-induction-full}.


Below, we first show the proof for the base case (\ie for the interval $\intvl{0}{\Kcp}$) to highlight the key techniques.
Here, $\Qin{.}{.}$ is the total number of blocks mined in an interval (bounds the adversary's block budget), and the expressions on the left in \eqref{cp-induction-full-margin-condition,cp-induction-full-ppivots-condition} are the minimum number of blocks the adversary needs to produce to ensure that there are no \sltcps, in terms of the number of \sltpps $\Pin{.}{.}$ and number of \sltgood \iindices $\Gin{.}{.}$.

\begin{lemma}
    \label{lem:one-cp-induction-base}
    If honest nodes use the download rule $\dlrulelong$
    and
    \begin{IEEEeqnarray}{C}
        \label{eq:cp-induction-base-margin-condition}
        \forall \intvl{i}{j} \intvlgeq \Kcp, i < \Kcp \colon\quad
        \frac{\goodsepbw}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right) > \Qin{0}{j}, \IEEEeqnarraynumspace\\
        %
        \label{eq:cp-induction-base-ppivots-condition}
        \frac{\goodsepbw}{4} \Pin{0}{\Kcp} > \Qin{0}{2\Kcp},
        %
    \end{IEEEeqnarray}
    then $\exists k_1^* \in \intvl{0}{\Kcp} \colon \predCP{k_1^*}$.
\end{lemma}

Towards proving \cref{lem:one-cp-induction-base}, we show two simple corollaries of the \sltcp conditions (\cref{prop:not-cp-exists-interval,prop:not-cp-interval-properties}) and show that in any interval, \sltgood \iindices outnumber \sltbad \iindices by at least the number of \sltpps in that interval.

\begin{proposition}
\label{prop:not-cp-exists-interval}
\begin{IEEEeqnarray}{C}
    \lnot \predCP{k} \qquad\implies\qquad \exists \intvl{i}{j} \ni k \colon\quad \Yin{i}{j} \leq 0.
\end{IEEEeqnarray}
\end{proposition}
%
\begin{proof}
From \cref{def:cp}.
\end{proof}


\begin{proposition}
\label{prop:not-cp-interval-properties}
If $\Yin{i}{j} \leq 0$, then
\begin{IEEEeqnarray}{C}
    \label{eq:not-cp-interval-property1}
    \Nin{i}{j} \geq \Din{i}{j}, 
    %
    \qquad
    \label{eq:not-cp-interval-property2}
    \Gin{i}{j} - \Din{i}{j} \geq \frac{1}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right).
    \IEEEeqnarraynumspace
\end{IEEEeqnarray}
\end{proposition}
%
\begin{proof}
We obtain \eqref{not-cp-interval-property1} from the definition $\Yat{i} = \Dat{i} - \Nat{i}$.
%
Then,
\begin{IEEEeqnarray}{rCl}
    \Gin{i}{j} + \Bin{i}{j} &=& \Din{i}{j} + \Nin{i}{j} \\
    \Gin{i}{j} + \Bin{i}{j} &\geq& 2 \Din{i}{j} \\
    2 \Gin{i}{j} - 2 \Din{i}{j} &\geq& \Gin{i}{j} - \Bin{i}{j}.
\end{IEEEeqnarray}
\end{proof}



\begin{proposition}
\label{prop:ppivots-imply-honest-margin}
If $\Pin{i}{j} > 0$, then $\Gin{i}{j} - \Bin{i}{j} \geq \Pin{i}{j}$.
\end{proposition}
%
\begin{proof}
Let $n = \Pin{i}{j}$.
First, consider $n=1$.
There is exactly one \sltpp $k \in \intvl{i}{j}$.
From \cref{def:pp}, $\Xin{0}{i} < \Xin{0}{j}$. Therefore, $\Xin{i}{j} > 0$, hence $\Gin{i}{j} - \Bin{i}{j} \geq 1$.
%
For the general case, let $k_1,...,k_n$ be the \sltpps in $\intvl{i}{j}$. Then, we apply the $n=1$ case on the disjoint intervals $\intvl{i}{k_1}$, $\intvl{k_1}{k_2}, ...$, $\intvl{k_{n-1}}{j}$ and then sum up.
\end{proof}


\import{./figures/}{fig-one-cp-proof-figures.tex}

\begin{proof}[Proof of \cref{lem:one-cp-induction-base}]
Due to \eqref{cp-induction-base-ppivots-condition}, there is at least one \sltpp in $\intvl{0}{\Kcp}$ (otherwise $\Pin{0}{\Kcp}=0$).
Suppose for contradiction that there is no \sltcp in $\intvl{0}{\Kcp}$.
Since \sltcps are also \sltpps, it is enough to consider that
none of the \sltpps is a \sltcp.
Then around each \sltpp, there must be at least one interval which violates the combinatorial pivot condition.
Formally, there is a set of intervals $\intvlset$ such that:
\begin{IEEEeqnarray}{C}
    \label{eq:intervals-cover-ppivots}
    \bigcup_{I \in \intvlset} I \supseteq \left\{ k \in \intvl{0}{\Kcp} \colon \predPP{k} \right\} \IEEEeqnarraynumspace\\
    \label{eq:intervals-y-condition}
    \forall I \in \intvlset \colon\quad \Yat{I} \leq 0 \quad \text{(by \cref{prop:not-cp-exists-interval})}. \IEEEeqnarraynumspace
\end{IEEEeqnarray}
Without loss of generality, each interval $I \in \intvlset$ contains at least one \sltpp (removing all intervals that do not contain a \sltpp maintains \eqref{intervals-cover-ppivots,intervals-y-condition}).
Then if $\intvl{i}{j} \in \intvlset$, $i < \Kcp$.

First, consider the large intervals with $|I| \geq \Kcp$.
Consider \iindices $k \in I$ for which $\Gat{k}=1$ (\sltgood) but $\Dat{k}=0$ (block not downloaded).
From \cref{prop:download-or-spend-budget}, for each such \iindex, all honest nodes download $\goodsepbw$ blocks that are produced no later than $t_k$.
%
The number of \iindices $k \in I$ with  $\Gat{k} = 1$ and $\Dat{k} = 0$ is $\Gat{I} - \Dat{I}$.
For each such index, there must exist $\goodsepbw$ distinct blocks produced in or before the interval $I$. Therefore, if $I = \intvl{i}{j}$,
\begin{IEEEeqnarray}{rClr}
    \Qin{0}{j} &\geq& \goodsepbw \left( \Gin{i}{j} - \Din{i}{j} \right) & \\
    &\geq& \frac{\goodsepbw}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right) & \quad \text{(by \cref{prop:not-cp-interval-properties}).}
\end{IEEEeqnarray}
This contradicts \eqref{cp-induction-base-margin-condition}.
Therefore, all intervals $I \in \intvlset$ are small ($|I| < \Kcp$).
%
Then for each $I \in \intvlset$, $I \subset \intvl{0}{2\Kcp}$.
Also, 
\begin{IEEEeqnarray}{Cl}
    \Gat{I} - \Dat{I} \geq \frac{1}{2} \left( \Gat{I} - \Bat{I} \right) \geq \frac{1}{2} \Pat{I}
    &\quad\text{(by \cref{prop:not-cp-interval-properties,prop:ppivots-imply-honest-margin})}. \IEEEeqnarraynumspace
    \label{eq:failed-more-than-ppivots}
\end{IEEEeqnarray}

Consider the \iindices $k \in \intvl{0}{2\Kcp}$ with $\Gat{k} = 1$ and $\Dat{k} = 0$.
Let $\intvlset_k = \{ I \in \intvlset \colon k \in I\}$ be the set of intervals that contain \index $k$.
Let $I^L_k$ be an interval in $\intvlset_k$ that stretches farthest to the left, and let $I^R_k$ be an interval that stretches farthest to the right (these may also be the same).
Note that all other intervals in $\intvlset_k$ are contained in $I^L_k \cup I^R_k$.
Therefore, all intervals in $\intvlset_k$ except $I^L_k$ and $I^R_k$ can be removed from $\intvlset$ while maintaining \eqref{intervals-cover-ppivots,intervals-y-condition} (see \cref{fig:one-cp-proof-figures}(a)).
This process is repeated for all $k \in \intvl{0}{2\Kcp}$ with $\Gat{k} = 1$ and $\Dat{k} = 0$, so that in the resulting set $\intvlset$, each such \iindex $k$ is contained in at most two intervals.
Then,
\begin{IEEEeqnarray}{rCl}
    \sum_{k \in \intvl{0}{2\Kcp} \colon \Gat{k} = 1, \Dat{k} = 0} |\intvlset_k|  &\leq& \sum_{k \in \intvl{0}{2\Kcp} \colon \Gat{k} = 1, \Dat{k} = 0} 2 \IEEEeqnarraynumspace\\
    &=& 2\left( \Gin{0}{2\Kcp} - \Din{0}{2\Kcp} \right). \IEEEeqnarraynumspace \label{eq:cp-sum-rewrite-1}
\end{IEEEeqnarray}
This sum can be rewritten as
\begin{IEEEeqnarray}{rCl}
    \IEEEeqnarraymulticol{3}{l}{\sum_{k \in \intvl{0}{2\Kcp} \colon \Gat{k} = 1, \Dat{k} = 0} |\intvlset_k| = \sum_{I \in \intvlset} \left( \Gat{I} - \Dat{I} \right)} \IEEEeqnarraynumspace\\
    \qquad\qquad&\geq& \sum_{I \in \intvlset} \frac{1}{2} \Pat{I} 
    %
    %
    \geq \frac{1}{2} \Pin{0}{\Kcp} \quad \text{(by \eqref{intervals-cover-ppivots})}.
    \IEEEeqnarraynumspace \label{eq:cp-sum-rewrite-2}
\end{IEEEeqnarray}
From \eqref{cp-sum-rewrite-1,cp-sum-rewrite-2},
\begin{IEEEeqnarray}{rCl}
    \Gin{0}{2\Kcp} - \Din{0}{2\Kcp} &\geq& \frac{1}{4} \Pin{0}{\Kcp}.
\end{IEEEeqnarray}
This can also be seen from \cref{fig:one-cp-proof-figures}(b).
Finally, as shown before, for each \index $k$ with $\Gat{k}=1$ and $\Dat{k}=0$, all honest nodes download at least $\goodsepbw$ distinct blocks produced in or before \iindex $k$ (\cref{prop:download-or-spend-budget}). This gives
\begin{IEEEeqnarray}{rCl}
    \Qin{0}{2\Kcp} &\geq& \goodsepbw \left( \Gin{0}{2\Kcp} - \Din{0}{2\Kcp} \right) 
    %
    %
    \geq \frac{\goodsepbw}{4} \Pin{0}{\Kcp}
    \IEEEeqnarraynumspace
\end{IEEEeqnarray}
which is a contradiction to \eqref{cp-induction-base-ppivots-condition}.
\end{proof}



\Cref{lem:one-cp-induction-full} proves that at least one \sltcp exists in successive intervals of $\Kcp$ length. \Cref{lem:one-cp-induction-full} is proved by induction, where the base case is \cref{lem:one-cp-induction-base}. 

\begin{lemma}
    \label{lem:one-cp-induction-full}
    \label{lem:many-pps-one-cps}
    %
    If honest nodes use the download rule $\dlrulelong$
    and
    \begin{IEEEeqnarray}{C}
        \label{eq:cp-induction-full-margin-condition}
        \forall \intvl{i}{j} \intvlgeq \Kcp
        %
        \colon\quad 
        %
        \frac{\goodsepbw}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right) > \Qin{i-2\Kcp}{j}, \IEEEeqnarraynumspace\\
        \label{eq:cp-induction-full-ppivots-condition}
        \forall m \geq 0 \colon\quad 
        \frac{\goodsepbw}{4} \Pin{m\Kcp}{(m+1)\Kcp} > \Qin{(m-2)\Kcp}{(m+2)\Kcp}, \IEEEeqnarraynumspace
    \end{IEEEeqnarray}
    then 
    $\forall m \geq 0 \colon
    \exists k_m^* \in \intvl{m\Kcp}{(m+1)\Kcp} \colon
    \predCP{k_m^*}$.
\end{lemma}
%
\begin{proof}
    This will be proved through induction.
    For the base case ($m=0$), \cref{lem:one-cp-induction-base} shows 
    that $\exists k_1^* \in \intvl{0}{\Kcp} \colon \predCP{k_1^*}$.
    
    For $m \geq 1$, assume that $\exists k_{m-1}^* \in \intvl{(m-1)\Kcp}{m\Kcp}$ such that  $\predCP{k_{m-1}^*}$.
    Now we want to show that $\exists k_{m}^* \in \intvl{m\Kcp}{(m+1)\Kcp}$ such that  $\predCP{k_{m}^*}$.
    Suppose for contradiction that there is no \sltcp in $\intvl{m\Kcp}{(m+1)\Kcp}$.
    %
    As in the proof of \cref{lem:one-cp-induction-base}, 
    there is a set of intervals $\intvlset$ such that:
    \begin{IEEEeqnarray}{Cr}
        \label{eq:induction-full-intervals-cover-ppivots}
        \bigcup_{I \in \intvlset} I \supseteq \left\{ k \in \intvl{m\Kcp}{(m+1)\Kcp} \colon \predPP{k} \right\} & \\
        \label{eq:induction-full-intervals-y-condition}
        \forall I \in \intvlset \colon\quad \Yat{I} \leq 0. &
        %
    \end{IEEEeqnarray}
    Without loss of generality, each interval $I \in \intvlset$ contains at least one \sltpp.
    Then if $\intvl{i}{j} \in \intvlset$, $i < (m+1)\Kcp$ and $j > m\Kcp$.
    
    First, consider the large intervals with $|I| \geq \Kcp$.
    Consider \iindices $k \in I$ for which $\Gat{k}=1$ (\sltgood) but $\Dat{k}=0$ (block not downloaded).
    From \cref{prop:download-or-spend-budget},
    for each such \iindex $k$, all honest nodes download $\goodsepbw$ blocks that are produced
    %
    in the interval $\intvl{k_{m-1}^*}{k}$.
    %
    The number of \iindices $k \in I$ with  $\Gat{k} = 1$ and $\Dat{k} = 0$ is exactly $\Gat{I} - \Dat{I}$.
    For each such index, there must exist $\goodsepbw$ distinct blocks from distinct \BPOs
    %
    that are downloaded by honest nodes.
    Therefore if $I = \intvl{i}{j}$,
    \begin{IEEEeqnarray}{rClr}
        \Qin{k_{m-1}^*}{j} &\geq& \goodsepbw \left( \Gin{i}{j} - \Din{i}{j} \right) & \IEEEeqnarraynumspace \\
        &\geq& \frac{\goodsepbw}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right) & \quad \text{(from \cref{prop:not-cp-interval-properties}).} \IEEEeqnarraynumspace
    \end{IEEEeqnarray}
    But $k_{m-1}^* > (m-1)\Kcp$ and $i < (m+1)\Kcp$. Therefore $\Qin{k_{m-1}^*}{j} \leq \Qin{i-2\Kcp}{j}$.
    Then we have a contradiction to \eqref{cp-induction-full-margin-condition}.
    Therefore all intervals $I \in \intvlset$ are small ($|I| < \Kcp$).
    %
    Then for each $I \in \intvlset$, $I \subset \intvl{(m-1)\Kcp}{(m+1)\Kcp}$.
    Also, 
    \begin{IEEEeqnarray}{Cr}
        \label{eq:failed-more-than-ppivots-induction}
        \Gat{I} - \Dat{I} \geq \frac{1}{2} \left( \Gat{I} - \Bat{I} \right) \geq \frac{1}{2} \Pat{I} & \quad \text{(\cref{prop:not-cp-interval-properties,prop:ppivots-imply-honest-margin})} \IEEEeqnarraynumspace
    \end{IEEEeqnarray}
    
    Consider the \iindices $k \in \intvl{(m-1)\Kcp}{(m+1)\Kcp}$ with $\Gat{k} = 1$ and $\Dat{k} = 0$.
    %
    Following the arguments in the proof of \cref{lem:one-cp-induction-base},
    we can reduce the set $\intvlset$
    so that in the resulting set $\intvlset$, each such \iindex $k$ is contained in at most two intervals.
    Then,
    \begin{IEEEeqnarray}{rCl}
        \IEEEeqnarraymulticol{3}{l}{ \sum_{k \in \intvl{(m-1)\Kcp}{(m+1)\Kcp} \colon \Gat{k} = 1, \Dat{k} = 0} |\intvlset_k| } \nonumber \\
        \quad&\leq& 
        %
        %
        2\left( \Gin{(m-1)\Kcp}{(m+1)\Kcp} - \Din{(m-1)\Kcp}{(m+1)\Kcp} \right). \IEEEeqnarraynumspace
    \end{IEEEeqnarray}
    This sum can be rewritten as
    \begin{IEEEeqnarray}{rCl}
        \IEEEeqnarraymulticol{3}{l}{ \sum_{k \in \intvl{(m-1)\Kcp}{(m+1)\Kcp} \colon \Gat{k} = 1, \Dat{k} = 0} |\intvlset_k| } \\
        \quad&=& \sum_{I \in \intvlset} \left( \Gat{I} - \Dat{I} \right) \\
        &\geq& \sum_{I \in \intvlset} \frac{1}{2} \Pat{I} \\
        &\geq& \frac{1}{2} \Pin{m\Kcp}{(m+1)\Kcp}.
        \IEEEeqnarraynumspace
        %
    \end{IEEEeqnarray}
    Therefore,
    \begin{IEEEeqnarray}{rCl}
        \IEEEeqnarraymulticol{3}{l}{ \Gin{(m-1)\Kcp}{(m+1)\Kcp} - \Din{(m-1)\Kcp}{(m+1)\Kcp} } \nonumber \\
        \quad&\geq& \frac{1}{4} \Pin{m\Kcp}{(m+1)\Kcp}.
    \end{IEEEeqnarray}
    
    Finally, for each \index $k$ with $\Gat{k}=1$ and $\Dat{k}=0$, all honest nodes download at least $\goodsepbw$ distinct blocks produced in or before 
    the most recent \sltcp before $(m-1)\Kcp$.
    By induction assumption, we have a \sltcp $k_{m-2}^* \in \intvl{(m-2)\Kcp}{(m-1)\Kcp}$.
    This gives
    \begin{IEEEeqnarray}{rCl}
        \IEEEeqnarraymulticol{3}{l}{ \Qin{(m-2)\Kcp}{(m+1)\Kcp} } \nonumber \\
        \quad&\geq& \goodsepbw \left( \Gin{(m-1)\Kcp}{(m+1)\Kcp} - \Din{(m-1)\Kcp}{(m+1)\Kcp} \right) \IEEEeqnarraynumspace \\
        &\geq& \frac{\goodsepbw}{4} \Pin{m\Kcp}{(m+1)\Kcp}
    \end{IEEEeqnarray}
    which is a contradiction.
\end{proof}



Finally,
using the fact that, with overwhelming probability, a constant fraction of \iindices are \sltpps,
we calculate the condition on the parameters $\blkrateslot, \slotduration$ in terms of $\goodsep,\goodsepbw$ for which the conditions \eqref{cp-induction-full-margin-condition,cp-induction-full-ppivots-condition} in \cref{lem:many-pps-one-cps} hold with overwhelming probability.
Precisely, we show that, with overwhelming probability, for any \iindex $k$ throughout the time horizon, there is at least one \sltcp in the interval $\intvl{k}{k+2\Kcp}$.

\begin{lemma}
\label{lem:pow-security-condition}
If $\frac{\goodsepbw}{16} \frac{(2\probGood-1)^2}{\probGood} > 1$,
then for $\Kcp = \Theta(\kappa^2)$,
$\Khorizon = \poly(\kappa)$,
with overwhelming probability,
for all $k < \Khorizon - 2\Kcp$,
$\exists k^* \in \intvl{k}{k+2\Kcp} \colon \predCP{k^*}$.
\end{lemma}
%
\begin{proof}
    \sloppy Define the event $\Event_1 = \left\{\forall \intvl{i}{j} \intvlgeq \Kcp \colon \Pin{i}{j} > (1-\delta)\probPP(j-i) \right\}$.
    Suppose that $\Event_1$ occurs, and $\frac{\goodsepbw}{16}\probPP (1-\delta) > 1$ for some $\delta \in (0,1)$.
    Then,
    \begin{IEEEeqnarray}{rCl}
        \forall \intvl{i}{j} \intvlgeq \Kcp \colon\quad
        \frac{\goodsepbw}{4} \Pin{i}{j} &>& \frac{\goodsepbw}{4} (1-\delta)\probPP(j-i) \IEEEeqnarraynumspace \\
        &>& 4(j-i) \\
        &\eqA& \Qin{i-2\Kcp}{j+\Kcp}
    \end{IEEEeqnarray}
    where (a) is because as $\slotduration \to 0$, each non-\sltempty \timeslot has exactly one \BPO. This satisfies \eqref{cp-induction-full-ppivots-condition} in \cref{lem:one-cp-induction-full}. Further,
    \begin{IEEEeqnarray}{C}
        \frac{\goodsepbw}{2} \left( \Gin{i}{j} - \Bin{i}{j} \right)
        \geq \frac{\goodsepbw}{2} \Pin{i}{j} > 3 (j-i) > \Qin{i-2\Kcp}{j}\IEEEeqnarraynumspace
    \end{IEEEeqnarray}
    which satisfies condition \eqref{cp-induction-full-margin-condition} in \cref{lem:one-cp-induction-full}.
    Therefore there is at least one \sltcp in every interval of the form $\intvl{m\Kcp}{(m+1)\Kcp}$.
    It also follows that for all $k$, there is at least one \sltcp in the interval $\intvl{k}{k+2\Kcp}$.
    By choosing $\Kcp = \Omega(\kappa^2)$, $\Khorizon = \poly(\kappa)$, and using \cref{lem:many-pps} and a union bound,
    the probability of failure of $\Event_1$ is $\negl(\kappa)$.
\end{proof}






While the analysis above is for the download rule $\dlrulelong$, the proofs only use properties \ref{item:good-download-rule-no-repeat}, \ref{item:good-download-rule-honest-block}, \ref{item:good-download-rule-cutoff}
and thus apply to several other simple download rules.
%
Another such download rule is
``download only blocks that are consistent with the node's confirmed chain''.
In this work, we did not adopt this rule
because it would fail to recover from a network split, as demonstrated in the \greedyattack mentioned in \cref{sec:greedy-attack}.

