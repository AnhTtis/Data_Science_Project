\section{Protocol \& Model Details}
\label{sec:algos-reference}

\subsection{Nakamoto Consensus Pseudocode}
\label{sec:algos-reference-pseudocode}

\import{./figures/}{alg-generic-lc-protocol.tex}
\import{./figures/}{alg-hdrtree-pow.tex}
%
\import{./figures/}{alg-longest-header-chain-rule.tex}

Pseudocode of an idealized NC protocol $\protocol$ is provided in \cref{alg:generic-lc-protocol}.
Details of the PoW-based block production lottery, \ie, of production and verification of blocks, are abstracted through an idealized functionality $\FtreePoW$ whose pseudocode is provided in \cref{alg:hdrtree-pow} (\cf~\cite[Fig.~2]{sleepy}, \cite[Alg.~3]{bwlimitedposlc}).
Pseudocode for the \rulelc block download/processing rule $\dlrulelong$ is provided in \cref{alg:longest-header-chain-rule}.
%
%
Helper functions used in the pseudocode are detailed in \cref{sec:algos-reference-helperfunctions}.



\subsection{Helper Functions for Nakamoto Consensus Pseudocode}
\label{sec:algos-reference-helperfunctions}

\begin{itemize}
      \item $\operatorname{Hash}(\txs)$:\;\;
%
            %
            Cryptographic hash function to produce
            a binding commitment to $\txs$
            (modelled as a random oracle)

      \item $\Chain' \preceq \Chain$, $\Chain \succeq \Chain'$:\;\;
%
            %
            Relation that $\Chain'$ is a prefix of $\Chain$

      \item $\Chain \| \Chain'$:\;\;
%
            %
            Concatenation of $\Chain$ and $\Chain'$

      \item $\len{\Chain}$:\;\;
%
            %
            Length of $\Chain$

      \item $(\TRUE \text{ with probability $x$, else } \FALSE)$:\;\;
%
            %
            Bernoulli random variable with success probability $x$

      \item $\operatorname{prefixChainsOf}(\Chain)$:\;\;
%
            %
            Set of prefixes of $\Chain$, \ie, all $\Chain'$ with $\Chain' \preceq \Chain$

      \item $\operatorname{newBlock}(\mathsf{txsHash}\colon \operatorname{Hash}(\txs))$ and
      \\
      $\operatorname{newBlock}(\mathsf{time}\colon t, \mathsf{node}\colon P, \mathsf{txsHash}\colon \operatorname{Hash}(\txs))$:\;\;
%
            %
            Produce a new PoW and PoS block header with
            given parameters, respectively

      \item $\operatorname{txsLedger}(\TxsMap, \Chain)$:\;\;
%
            %
            Concatenates the block contents stored in $\TxsMap$ for the blocks along the chain $\Chain$, to obtain the corresponding transaction ledger
\end{itemize}

%




\subsection{Bounded-Bandwidth Model Environment $\Env$}
\label{sec:algos-reference-environment}

\import{./figures/}{fig-model.tex}

We study PoW NC (\cref{sec:algos-reference-pseudocode})
%
using the following model
%
for a network $\Env$ with finite bandwidth (\cref{fig:model}), and for the powers and limits of an adversary $\Adv$.

%
%
The environment $\Env$ initializes $N$ nodes and lets $\Adv$ corrupt up to $\beta N$ nodes at the beginning of the execution. Corrupted nodes are controlled by the adversary. Honest nodes run $\protocol$.
The environment maintains a mapping $\Env.\TxsMap$ from block headers to the block content (transactions). This mapping is referred to as the `cloud' in 
%
\cref{fig:model}.
%
$\Env$ also maintains for each node a queue of pending block headers
to be delivered after a delay determined by the adversary.
If $\Adv$ has not instructed $\Env$ to deliver a header $\DeltaHeader$ real time after it was added to the queue of pending block headers,
then $\Env$ delivers it to the node.
%

Honest nodes and $\Adv$ interact with $\Env$ via the following functions:
\begin{itemize}
      \item $\Env.\Call{broadcastHeaderChain}{\Chain}$:

            \noindent If called by an honest node, $\Env$
            enqueues $\Chain$ in the queue of pending block headers for each node, and notifies $\Adv$.
            %
            Then, for each node $P$, on receiving $\Call{deliver}{\Chain,P}$ from $\Adv$,
            or when $\DeltaHeader$ time has passed since $\Chain$
            was added to the queue of pending headers, $\Env$ triggers $P.\Call{receivedHeaderChain}{\Chain}$.

      \item $\Env.\Call{uploadContent}{\Chain, \txs}$:

            \noindent $\Env$ stores a mapping from the header chain $\Chain$ to the content $\txs$ of its last block by setting $\Env.\TxsMap[\Chain] = \txs$.
            $\Env$ only stores the content $\txs$
            if $\mathrm{Hash}(\txs) = \Chain.\mathsf{txsHash}$.

      \item $\Env.\Call{receivePendingTxs}{\null}$:

            \noindent $\Env$ generates a set of pending
            transactions and returns them.
    
    \item
        If node $P$ at \timeslot $t$ requests the content associated with a block header $\Chain$, $\Env$ acts as follows.
        %
        %
If $\Env.\TxsMap[\Chain]$ is set, then let $\txs = \Env.\TxsMap[\Chain]$ (if not, $\Env$ ignores the request).
%
If the request was received from an honest node $P$,
if $\Env$ has recently triggered $P.\Call{receivedContent}{.}$ at a rate below $\bwtime$,
%
then $\Env$ triggers  $P.\Call{receivedContent}{\Chain, \txs}$ (else, $\Env$ ignores the request).
If the request was received from $\Adv$, $\Env$ sends $(\Chain, \txs)$ to $\Adv$.
\end{itemize}

At all times, $\Adv$ can trigger $P.\Call{receivedHeaderChain}{\Chain}$
and $P.\Call{receivedContent}{\Chain, \txs}$
for honest nodes $P$ (bypassing header delay and bandwidth constraint in an adversarially chosen way).

%
%
%
%
%
%

