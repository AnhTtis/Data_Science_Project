\section{Overview of the \DF System}
\label{sec:systemoverview}

% path plot
\begin{figure}[t]
\centering
\includegraphics[width=0.8\textwidth]{figures/system}
\caption{Overview of the \DF system.}
\label{fig:system}
\end{figure}
% END: path plot

Figure~\ref{fig:system} overviews the main components of \DF, annotated with the numbers of sections where they are discussed. Applications, e.g., database analytics,  training linear regression model and Chow-Liu trees, and linear algebra computation, rely on queries with natural joins and group-by aggregates, where each aggregate is expressed using the sum and product operations in a ring. In particular, Section~\ref{sec:applications} introduces the covariance ring over continuous and categorical features. Queries and rings serve as input to \DF, together with a stream of updates (tuple inserts and deletes) to the underlying database. Section~\ref{sec:preliminaries} details the data model, the query language supported by \DF, and the ring algebraic structure.

The logical optimizer creates a {\em variable order} for the input query (Section~\ref{sec:factorized_ring_computation}). This is akin to a query plan, albeit expressed as a partial order on the query variables as opposed to a partial order on the relations to join. Classical query evaluation uses query plans that dictate the order in which the relations are joined. \DF uses variable orders that dictate the  order in which the variables are marginalized.
For each join variable, all relations with that variable are joined. This choice is motivated by the observation that relation-at-a-time query plans is suboptimal in general, whereas the evaluation by variable orders is worst-case optimal~\cite{Ngo:SIGREC:2013}. 

Finding a good variable order for a given query is a computationally hard problem. For {\em q-hierarchical} queries~\cite{Nicole:PODS:2017}, we can efficiently find variable orders  that allow for maintenance with best guarantees in terms of update time and time to present the updated query result to the user (Section~\ref{sec:query_classes}). 
This also applies to queries, which become  q-hierarchical on databases that satisfy functional dependencies.

Given a variable order for a query, the physical optimizer creates a {\em view tree} (Section~\ref{sec:factorized_ring_computation}), which is a tree of views to support the maintenance and output enumeration of the query. Updates to base relations are propagated bottom-up in the tree, while output enumeration requires top-down access in the view tree. Depending on which base relations are updatable (dynamic) or non-updatable (static), \DF decides to materialize and maintain views in the view tree to support efficient propagation of the updates and avoid recomputation. Section~\ref{sec:factorized_IVM} discusses the view materialization problem, whereas Section~\ref{sec:factorizable_updates} discusses efficient update propagation. 


Each view is accessed via indices with key-payload entries. Its primary index is a hash map over all its keys (Section~\ref{sec:preliminaries}). \DF may also need secondary and even tertiary indices, which are hash maps over different subsets of its keys. 
% Secondary and tertiary indices are updated lazily: updates to views are buffered, and these indices are updated only when they are needed.
Such indices are updated lazily: the index updates are buffered and only executed when index access is required. 
The views for q-hierarchical queries require the primary indices to support updates that are propagated bottom-up in the view tree, and secondary indices to support output enumeration that proceeds top-down in the view tree (Section~\ref{sec:query_classes}).
\DF implements equality-based joins using in-memory hash-based join operators.
Aggregation is performed using variable marginalization. To marginalize a variable, 
\DF enumerates the entries with the same key, except for the marginalized variable, and applies the aggregation on these entries on the fly.

For a view tree and ring specification for each variable to be marginalized, the compiler outputs code in  DBToaster's intermediate representation language {\em M3}. DBToaster has its own optimizer and compiler that turns M3 code into highly optimized C++ code. This code takes the stream of input data updates, maintains the views, and enumerates the query output, relying on DBToaster's runtime library for data ingestion.



