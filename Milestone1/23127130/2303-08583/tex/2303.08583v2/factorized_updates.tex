%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Factorizable Updates}
\label{sec:factorizable_updates}

Our focus so far has been on supporting updates represented by delta relations. We next consider an alternative approach that decomposes a delta relation into a union of factorizable relations. The cumulative size of the decomposed relations can be much less than the size of the original delta relation. Also, the complexity of propagating a factorized update can be much lower than that of its unfactorized (listing) representation, since the factorization makes explicit the independence between query variables and enables optimizations of delta propagation such as pushing marginalization past joins. Besides the factorized view computation, this is the second instance where \DF exploits factorization.

Factorizable updates arise in many domains such as linear algebra and machine learning. Section~\ref{sec:applications} demonstrates how our framework can be used for the incremental evaluation of matrix chain multiplication, recovering prior work on this~\cite{NEK:SIGMOD:2014}.  Matrix chain computation can be phrased in our language of joins and aggregates, where matrices are binary relations. Changes to one row/column in an input matrix may be expressed as a product of two vectors. In general, an arbitrary update matrix can be decomposed into a sum of rank-$1$ matrices, each of them  expressible as products of vectors, using low-rank tensor decomposition methods~\cite{TensorDecomp:2009,TensorDecomposition:2017}.

\begin{example}
Arbitrary relations can be decomposed in\-to a union of factorizable relations. The relation $\VIEW[A,B]{R}$ $= \{(a_i,b_j) \to 1\mid i\in[n],j\in[m]\}$ can be decomposed as $\VIEW[A]{R_1}\VPROD\VIEW[B]{R_2}$, where $\VIEW[A]{R_1}=\{(a_i) \to 1\mid i\in[n]\}$ and $\VIEW[B]{R_2}=\{(b_j) \to 1\mid j\in[m]\}$. We thus reduced a relation of size $nm$ to two relations of cumulative size $n+m$. If $\VIEW{R}$ were a delta relation, the delta views on top of it would now be expressed over $\VIEW[A]{R_1}\VPROD\VIEW[B]{R_2}$ and their computation can be factorized as done for queries in Section~\ref{sec:factorized_ring_computation}. Product decomposition of relations can be done in linearithmic time in both the number of variables and the size of the relation~\cite{WSD:2008}. 

Consider now $\VIEW[A,B]{R'}$ $=$ $\VIEW[A,B]{R}$ $\VPLUS$ $\{(a_{n+1},b_j) \to 1\mid j\in[m-1]\}$ with $\VIEW{R}$ as above. We can decompose each of the two terms in $\VIEW{R'}$ similarly to $\VIEW{R}$, yielding overall $n+2m$ values instead of $nm+m-1$. A different decomposition with $n+m+3$ values is given by a factorizable over-approximation of $\VIEW{R'}$ compensated by a small product with negative payload: $\{(a_i)\to 1\mid i\in[n+1]\}\VPROD\{(b_j)\to 1\mid j\in[m]\}\VPLUS\{(a_{n+1})\to 1\}\VPROD\{(b_m)\to -1\}$.\punto
\end{example}

The {\sc Optimize} method used in the delta view tree algorithm in Figure~\ref{fig:dynamic_view_tree_algo} exploits the distributivity of join $\VPROD$ over marginalization $\VSUM_{X}$ to push the latter past the former and down to the views with variable $X$. This optimization is reminiscent of pushing aggregates past joins in databases and variable elimination in probabilistic graphical models~\cite{FAQ:PODS:2016}. In case the delta views express Cartesian products, then they are not materialized but instead kept factorized.

\begin{example}
\label{ex:factorized-update}
Consider the query $\VIEW{Q}$ from Example~\ref{ex:delta_view_tree} 
and its view tree in Figure~\ref{fig:example_payloads}.
In the delta view tree derived for updates to $\VIEW{S}$, the top-level delta is computed as:
\begin{align*}
\VIEW[~]{\delta{V^{@A}_{RST}}} = \VSUM_{A} \VIEW[A]{V^{@B}_{R}} \VPROD 
\big(&  \VSUM_{C} \VIEW[C]{V^{@D}_{T}} \VPROD \\
& \underbrace{\hspace{3em}\underbrace{\VSUM_{E} \VIEW[A,C,E]{\delta{S}}}_{\VIEW[A,C]{\delta{V^{@E}_{S}}}}\big)}_{\VIEW[A]{\delta{V^{@C}_{ST}}}}
\end{align*}
A single-tuple update $\VIEW{\delta{S}}$ binds variables $A$, $C$, and $E$, and computing $\VIEW{\delta{V^{@A}_{RST}}}$ requires $\bigO{1}$ lookups in $\VIEW{V^{@D}_{T}}$ and $\VIEW{V^{@B}_{R}}$. An arbitrary-sized update $\VIEW{\delta{S}}$ can then be processed in $\bigO{|\VIEW{\delta{S}}|}$ time.

Assume now that $\VIEW{\delta{S}}$ is factorizable as $\VIEW[A,C,E]{\delta{S}} = \VIEW[A]{\delta{S_{A}}} \VPROD \VIEW[C]{\delta{S_{C}}} \VPROD \VIEW[E]{\delta{S_{E}}}$. In the construction of the delta view tree, the {\sc Optimize} method exploits this factorization to push the marginalization past joins at each variable; for example, the delta at $E$ becomes:
\begin{align*}
\VIEW[A,C]{\delta{V^{@E}_{S}}} &= \VSUM_{E} \VIEW[A]{\delta{S_{A}}} \VPROD \VIEW[C]{\delta{S_{C}}} \VPROD \VIEW[E]{\delta{S_{E}}} \\
&= \VIEW[A]{\delta{S_{A}}} \VPROD \VIEW[C]{\delta{S_{C}}} \VPROD \VSUM_{E} \VIEW[E]{\delta{S_{E}}}
\end{align*}
We also transform the top-level delta into a product of three views:
\begin{align*}
\VIEW[~]{\delta{V^{@A}_{RST}}} = 
&\big( \VSUM_{A} \VIEW[A]{V^{@B}_{R}} \VPROD \VIEW[A]{\delta{S_{A}}} \big) \VPROD
\big( \VSUM_{C} \VIEW[C]{V^{@D}_{T}} \VPROD \VIEW[C]{\delta{S_{C}}} \big) \VPROD 
 \big( \VSUM_{E} \VIEW[E]{\delta{S_{E}}} \big)
\end{align*}
The computation time for this delta is proportional to the sizes of the three views representing the update:
$\bigO{\min(|\VIEW{V^{@B}_{R}}|, {|\VIEW{\delta{S_{A}}}|}) + \min(|\VIEW{V^{@D}_{T}}|, |\VIEW{\delta{S_{C}}}|) + |\VIEW{\delta{S_{E}}}|}$.
\punto
\end{example}


