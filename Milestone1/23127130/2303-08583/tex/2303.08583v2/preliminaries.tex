%!TEX root = main.tex
\section{Data Model and Query Language}
\label{sec:preliminaries}

  The data model of \DF is based on relations over rings and its query language allows for natural joins and group-by aggregates over such relations.

% 
\begin{definition}
A ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$ is a set $\RING$ with two closed binary operations $\RINGPLUS$ and $\RINGPROD$, the additive identity $\RINGZERO$, and the multiplicative identity $\RINGONE$ such that for all $a,b,c\in\RING$, the following 
axioms are satisfied:
\begin{enumerate}
    \item $a \RINGPLUS b = b\RINGPLUS a$.
    \item $(a \RINGPLUS b)\RINGPLUS c = a \RINGPLUS (b \RINGPLUS c)$.
    \item $\RINGZERO \RINGPLUS a = a \RINGPLUS \RINGZERO = a$.
    \item $\exists -a \in \RING: a \RINGPLUS (-a) = (-a) \RINGPLUS a = \RINGZERO$.
    \item $(a \RINGPROD b) \RINGPROD c = a \RINGPROD (b \RINGPROD c)$.
    \item $a \RINGPROD \RINGONE = \RINGONE * a = a$.
    \item $a \RINGPROD (b \RINGPLUS c) = a \RINGPROD b \RINGPLUS a \RINGPROD c$ and $(a \RINGPLUS b) \RINGPROD c = a \RINGPROD c \RINGPLUS b \RINGPROD c$.
\end{enumerate}
A semiring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$ satisfies all of the above properties 
except the additive inverse property (Property 4) and adds the axiom 
$\RINGZERO \RINGPROD a = a \RINGPROD \RINGZERO = \RINGZERO$.
A (semi)ring for which $a \RINGPROD b = b \RINGPROD a$ is commutative. 
\punto
\end{definition}

\begin{example}
The number sets $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{R}$, and $\mathbb{C}$ with arithmetic operations $+$ and $\cdot$ and numbers $0$ and $1$ form commutative rings. The set $\mathcal{M}$ of $(n \times n)$ matrices  forms a non-commutative ring $(\mathcal{M}, \cdot, +, 0_{n,n}, I_{n})$, where $0_{n,n}$ and $I_{n}$ are the zero matrix and the identity matrix of size $(n \times n)$. The set $\mathbb{N}$ of natural numbers  is a commutative semiring but not a ring because it has no additive inverse. Further examples are the max-product semiring $(\mathbb{R}_{+}, \max, \times, 0, 1)$, the Boolean semiring $(\{ \text{true}, \text{false} \}, \lor, \land, \text{false}, \text{true})$,  and the set semiring $(2^{U}, \cup, \cap, \emptyset, U)$ of all possible subsets of a given set $U$.\punto
\end{example}


%\medskip

\paragraph{\textbf{Data.}}

%{\bf Data Model.}
A schema $\mathcal{S}$ is a set of variables. Let $\Dom(X)$ denote the domain of a variable $X$. A tuple $\vecnormal{t}$ over schema $\mathcal{S}$ has the domain $\Dom(\mathcal{S}) = \prod_{X \in \mathcal{S}}{\Dom(X)}$. The empty tuple $\tuple{}$ is the tuple over the empty schema.
%We denote by $\sch(\vecnormal{t})$ the schema of the tuple $\vecnormal{t}$.

Let $(\RING,\hspace{-0.05em} \RINGPLUS,\hspace{-0.05em} \RINGPROD,\hspace{-0.05em} \RINGZERO,\hspace{-0.05em} \RINGONE)$ be a ring. A {\em relation} $\VIEW{R}$ over schema $\mathcal{S}$ and the ring $\RING$ is a function $\VIEW{R}: \Dom(\mathcal{S}) \to \Codom$ mapping tuples over schema $\mathcal{S}$ to values in $\Codom$ such that $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$ for finitely many tuples $\vecnormal{t}$. The tuple $\vecnormal{t}$ is called a {\em key}, while its mapping $\VIEW{R}[\vecnormal{t}]$ is the {\em payload} of $\vecnormal{t}$ in $\VIEW{R}$. We use $\sch(\VIEW{R})$ to denote the schema of $\VIEW{R}$. 
The statement $\vecnormal{t} \in \VIEW{R}$ tests if $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$. The size $|\VIEW{R}|$ of $\VIEW{R}$ is the size of the set $\{ \vecnormal{t} \mid \vecnormal{t} \in \VIEW{R} \}$, which consists of all keys with non-$\RINGZERO$ payloads. 
A database $\db$ is a collection of relations over the same ring. Its size $|\db|$ is the sum of the sizes of its relations. 
This data model is in line with prior work on $K$-relations over provenance semirings~\cite{Green:2007:ProvenanceSemirings}, generalized multiset relations~\cite{Koch:Ring:2010:PODS}, and factors over semirings~\cite{FAQ:PODS:2016}.

Each relation  or materialized view $\VIEW{R}$  over schema $\mathcal{S}$ is implemented 
as a hash map or a multidimensional array that stores 
key-payload entries $(\vecnormal{t},\VIEW{R}[\vecnormal{t}])$ for each tuple 
$\vecnormal{t}$ with $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$.
% and needs $O(|R|)$ space.
The data structure can:
(1) look up, insert, and delete entries in amortized constant time, and
(2) enumerate all stored entries in $\VIEW{R}$ 
with constant \emph{delay}, i.e., the following times are constant: 
(i) the time between the start of the enumeration and outputting the first tuple, (ii) the time between outputting any two consecutive tuples, and (iii) the time between outputting the last tuple and the end of the enumeration~\cite{DurandFO07}.
For a schema $\mathcal{X} \subset \mathcal{S}$,
we use an index data structure that for any $\vecnormal{t} \in \Dom(\mathcal{X})$ can:
(4) enumerate all tuples in $\sigma_{\mathcal{X}=\vecnormal{t}} \VIEW{R}$ with constant delay,
(5) check $\vecnormal{t} \in \pi_{\mathcal{X}}\VIEW{R}$ in amortized constant time; and
(7) insert and delete index entries in amortized constant time.

We give a hash-based example data structure that supports the above operations with the stated complexities.
Consider a relation $R$ over schema $\mathcal{S}$. 
A hash table with chaining stores key-value entries of the form $(\vecnormal{t},R(\vecnormal{t}))$ for each tuple $\vecnormal{t}$ over $\mathcal{S}$ with  
$R(\vecnormal{t}) \neq \RINGZERO$. 
The entries are doubly linked to support enumeration with constant delay. 
The hash table can report the number of its entries in constant time and supports lookups, inserts, and deletes in {amortized} constant time.
% on average, under the assumption of simple uniform hashing.
%
To support index operations on a schema $\mathcal{X} \subset \mathcal{S}$, 
we create another hash table with chaining where each table entry stores an $\calX$-value 
$\vecnormal{t}$ as key and a doubly-linked list of pointers to the entries in $R$ having 
$\vecnormal{t}$ as $\mathcal{X}$-value.
Looking up an index entry given $\vecnormal{t}$ takes {amortized} constant time,
% on average under simple uniform hashing, 
and its doubly-linked list enables enumeration of the matching entries in $R$ with constant delay. 
Inserting an index entry into the hash table additionally prepends a new pointer to the doubly-linked list for a given $\vecnormal{t}$; overall, this operation takes {amortized} constant time.
For efficient deletion of index entries, each entry in $R$ also stores back-pointers to its index entries (one back-pointer per index for $R$). 
When an entry is deleted from $R$, locating and deleting its index entries in doubly-linked lists takes constant time per index.
%An alternative data structure that can meet our requirements is a tree-structured index
%such as a B$^+$-tree. This would, however, require {\em worst-case} logarithmic time and imply an additional logarithmic factor in our complexity results. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\paragraph{\textbf{Query Language.}}
We consider queries with natural joins and group-by aggregates:
\begin{lstlisting}[language=SQL,mathescape]
  SELECT$\;X_1,\ldots,X_f$,$\;$SUM$(g_{f+1}(X_{f+1}) * ... * g_{m}(X_{m}))$
  FROM $R_1$ NATURAL$\;$JOIN $\ldots$ NATURAL$\;$JOIN $R_n$
  GROUP$\;$BY $X_1,\ldots,X_f$
\end{lstlisting}
The group-by variables $X_1,\ldots,X_f$ are {\em free}, while the other variables $X_{f+1},\ldots,X_m$ are {\em bound}. The {\tt SUM} aggregate values are from a ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$. The \texttt{SUM} operator uses the addition 
$\RINGPLUS$ from $\RING$. Further aggregates can be expressed using the sum and product operations from the ring. 
A {\em lifting} function $g_{k}: \Dom(X_k) \to \RING$, for $f < k \leq m$, maps $X_k$-values to elements in $\RING$:
when marginalizing $X_k$,  we aggregate the values $g_{k}(x)$ from $\RING$ and not the values $x$ from $\Dom(X_k)$.

Instead of the verbose SQL notation, we use the following more compact encoding:
\begin{align*}
\qquad  \VIEW[X_1,\ldots,X_f]{Q} = \VSUM_{X_{f+1}} \cdots \VSUM_{X_{m}} \VPRODBIG_{i \in [n]} \VIEW[\mathcal{S}_i]{R_i}
\end{align*}
where $\VPRODBIG$ is the join operator, $\VSUM_{X_{f+1}}$ is the aggregation operator that  marginalizes over the variable $X_{f+1}$, and each relation $\VIEW{R_i}$ is a function mapping keys over schema $\mathcal{S}_i$ to payloads in $\RING$. We also need a union operator $\VPLUS$ to express updates (insert/delete) to relations.

\begin{example}
\label{ex:sql_count}
The SQL query
\begin{lstlisting}[language=SQL,mathescape,columns=flexible]
  SELECT SUM(1) FROM R NATURAL JOIN S NATURAL JOIN T 
\end{lstlisting}
over tables $R(A,B)$, $S(A,C,E)$, and $T(C,D)$ can be encoded as follows in our formalism.
The table $R$ is encoded as a relation $\VIEW{R}: \Dom(A) \times \Dom(B) \to \mathbb{Z}$ that maps tuples $(a,b)$ to their multiplicity in $R$; similarly, we encode the tables $S$ and $T$ as relations $\VIEW{S}$ and $\VIEW{T}$. We translate the SQL query into: 
  % 
  $$
    \VIEW[~]{Q} = \underset{A,B,C,D,E}{\VSUM} \VIEW[A,B]{R}  \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
  %  \VIEW[~]{Q} = \VSUM_{A}\VSUM_{B}\VSUM_{C}\VSUM_{D}\VSUM_{E} \VIEW[A,B]{R} \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
  $$
  where $\underset{A,B,C,D,E}{\VSUM}$ abbreviates $\VSUM_A \cdots \VSUM_E$. The lifting functions used for marginalization map all values to $1$.
  Recall that by definition $\VIEW{R}$, $\VIEW{S}$, and $\VIEW{T}$ are finite.
  The relation $\VIEW{Q}$ maps the empty tuple $()$ to the count. 
  \punto
  \end{example}


Given a ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$, relations $\VIEW{R}$ and $\VIEW{S}$ over schema $\mathcal{S}_1$ and relation $\VIEW{T}$ over schema $\mathcal{S}_2$, a variable $X \in \mathcal{S}_1$, and a lifting function $g_{X}:\Dom(X) \to \RING$, we define the three operators as follows: 

\hspace{-1.9em} 
\begin{tabular}{@{~}l@{~~~~~}r@{~}r@{\;}l@{}}
\multicolumn{4}{@{~}l}{\em union:}\\
& $\forall\vecnormal{t} \in \mathsf{D}_1{:}$ & 
  $(\VIEW{R} \VPLUS \VIEW{S})[\vecnormal{t}]$ & 
  $= \VIEW{R}[\vecnormal{t}] + \VIEW{S}[\vecnormal{t}]$ \\[4pt]

\multicolumn{4}{@{~}l}{\em join:}\\
& $\forall\vecnormal{t} \in \mathsf{D}_2{:}$ & 
  $(\VIEW{S} \VPROD \VIEW{T})[\vecnormal{t}]$ & 
  $= \VIEW{S}[\pi_{\mathcal{S}_1}(\vecnormal{t})] * \VIEW{T}[\pi_{\mathcal{S}_2}(\vecnormal{t})]$\\[4pt]

\multicolumn{4}{@{~}l}{\em aggregation by marginalization:}\\[4pt]
& $\forall\vecnormal{t} \in \mathsf{D}_3{:}$ & 
  $(\VSUM_{X} \VIEW{R})[\vecnormal{t}]$ & 
  $= \textstyle\sum \,\{\, \VIEW{R}[\vecnormal{t}_1] \,\RINGPROD\, g_{X}(\pi_{\{X\}}(\vecnormal{t}_1)) \mid$
  $\vecnormal{t}_1 \,{\in}\, \mathsf{D}_1, \vecnormal{t} = \pi_{\mathcal{S}_1 \setminus \{X\}}(\vecnormal{t}_1) \}$  
\end{tabular}
\\[6pt]
where $\mathsf{D}_1 = \Dom(\mathcal{S}_1)$, $\mathsf{D}_2 = \Dom(\mathcal{S}_1 \cup \mathcal{S}_2)$, and $\mathsf{D}_3 = \Dom(\mathcal{S}_1 \setminus \{X\})$, and $\pi_{\mathcal{S}}(\vecnormal{t})$ is a tuple representing the projection of tuple $\vecnormal{t}$ on the schema $\mathcal{S}$.


\begin{example}
Consider relations over a ring $(\RING,\hspace{-0.05em} \RINGPLUS,\hspace{-0.05em} \RINGPROD,\hspace{-0.05em} \RINGZERO,\hspace{-0.05em} \RINGONE)$:
\begin{center}
  \small
  \begin{tabular}{lll}
    \begin{tabular}[t]{@{\,}l@{~}l@{~$\to$~}l@{\,}}
      $A$ & $B$ & $\VIEW{R}[A,B]$ \\\toprule
      $a_1$ & $b_1$ & $r_1$ \\
      $a_2$ & $b_1$ & $r_2$ \\
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      A & B & $\to$ & $\VIEW[A,B]{S}$ \\\toprule
      $a_2$ & $b_1$ & $\to$ & $s_1$ \\
      $a_3$ & $b_2$ & $\to$ & $s_2$ 
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      B & C & $\to$ & $\VIEW[B,C]{T}$\\\toprule
      $b_1$ & $c_1$ & $\to$ & $t_1$ \\
      $b_2$ & $c_2$ & $\to$ & $t_2$ 
    \end{tabular}
  \end{tabular}
\end{center}
The values $r_1$, $r_2$, $s_1$, $s_2$, $t_1$, $t_2$ are non-$\RINGZERO$ values from $\RING$. 
The operators $\VPLUS$, $\VPROD$, and $\oplus$ are akin to union, join, and aggregation ($g_A:\hspace{-0.1em} \Dom(A) \hspace{-0.1em}\to\hspace{-0.1em} \RING$ is the lifting for $A$):

\vspace{-6pt}
\begin{center}
  \small  \hspace*{-1em}
  \begin{tabular}{l@{\hskip 0.5em}l}
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      $A$ & $B$ & $\to$ & $(\VIEW{R} \VPLUS \VIEW{S})[A,B]$ \\\toprule
      $a_1$ & $b_1$ & $\to$ & $r_1$ \\
      $a_2$ & $b_1$ & $\to$ & $r_2+s_1$ \\
      $a_3$ & $b_2$ & $\to$ & $s_2$
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{~}l@{\,}}
      $A$ & $B$ & $C$ & $\to$ & $\big((\VIEW{R} \VPLUS \VIEW{S}) \VPROD \VIEW{T}\big)[A,B,C]$ \\\toprule
      $a_1$ & $b_1$ & $c_1$ & $\to$ & $r_1*t_1$ \\
      $a_2$ & $b_1$ & $c_1$ & $\to$ & $(r_2 + s_1)*t_1$ \\
      $a_3$ & $b_2$ & $c_2$ & $\to$ & $s_2*t_2$
    \end{tabular}
  \end{tabular}\\[4ex]
  \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      $B$ & $C$ & $\to$ & $\big(\VSUM_{A}(\VIEW{R} \VPLUS \VIEW{S}) \VPROD \VIEW{T} \big)[B,C]$ \\\toprule
      $b_1$ & $c_1$ & $\to$ & $r_1 * t_1  \,*\, g_{A}(a_1) + (r_2 + s_1) * t_1  \,*\, g_{A}(a_2)$ \\
      $b_2$ & $c_2$ & $\to$ & $s_2 * t_2 \,*\, g_{A}(a_3)$
    \end{tabular}
  \end{center}
\end{example}




\begin{example}\label{ex:sql_sum_aggregate}
Let us consider the SQL query from Section~\ref{ex:sql_sum_aggregate_intro}, which computes \texttt{SUM(R.B$\,$*$\,$T.D$\,$*$\,$S.E)} grouped by $A$, $C$. Assume that $B$, $D$, and $E$ take values from $\mathbb{Z}$.
We model the tables $R$, $S$, and $T$ as relations mapping tuples to their multiplicity, as in 
Example~\ref{ex:sql_count}. 
The variables $A$ and $C$ are free, while  $B$, $D$, and $E$ are bound. 

When marginalizing over the bound variables, we apply the same lifting function to these variables: $\forall x \in \mathbb{Z}: g_{B}(x) = g_{D}(x) = g_{E}(x) = x$. The SQL query can be expressed in our formalism as follows:
$$
  \VIEW[A,C]{Q} = \underset{B,D,E}{\VSUM}\VIEW[A,B]{R} \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
$$
The computation of the aggregate \texttt{SUM(R.B$\,$*$\,$T.D$\,$*$\,$S.E)} now happens over payloads. 
% We can exploit the associativity of $\VPROD$ and the distributivity of $\VPROD$ over $\oplus$ to push the marginalization past joins wherever possible:
% \begin{align*}
%   \VIEW[A,C]{Q} = \big(\VSUM_{B} \VIEW[A,B]{R} \big) \VPROD  
%     \big(\VSUM_{E} \VIEW[A,C,E]{S} \big) \VPROD 
%     \big(\VSUM_{D} \VIEW[C,D]{T} \big)
% \end{align*}
\punto
\end{example}

By using relations over rings, we avoid the intricacies of incremental computation under multiset semantics caused by the non-commutativi\-ty of inserts and deletes. We simplify delta processing by representing both inserts and deletes as tuples, with the distinction that they map to positive and respectively negative ring values. This uniform treat\-ment allows for simple delta rules for the three operators of our query language.

\bigskip
