%!TEX root = main.tex
\section{Data Model and Query Language}
\label{sec:preliminaries}
We recall the definition of rings. 
% 
\begin{definition}
A ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$ is a set $\RING$ with two closed binary operations $\RINGPLUS$ and $\RINGPROD$, the additive identity $\RINGZERO$, and the multiplicative identity $\RINGONE$ such that for all $a,b,c\in\RING$, the following 
axioms are satisfied:
\begin{enumerate}
    \item $a \RINGPLUS b = b\RINGPLUS a$.
    \item $(a \RINGPLUS b)\RINGPLUS c = a \RINGPLUS (b \RINGPLUS c)$.
    \item $\RINGZERO \RINGPLUS a = a \RINGPLUS \RINGZERO = a$.
    \item $\exists -a \in \RING: a \RINGPLUS (-a) = (-a) \RINGPLUS a = \RINGZERO$.
    \item $(a \RINGPROD b) \RINGPROD c = a \RINGPROD (b \RINGPROD c)$.
    \item $a \RINGPROD \RINGONE = \RINGONE * a = a$.
    \item $a \RINGPROD (b \RINGPLUS c) = a \RINGPROD b \RINGPLUS a \RINGPROD c$ and $(a \RINGPLUS b) \RINGPROD c = a \RINGPROD c \RINGPLUS b \RINGPROD c$.
\end{enumerate}
A semiring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$ satisfies all of the above properties 
except the additive inverse property (Property 4) and adds the axiom 
$\RINGZERO \RINGPROD a = a \RINGPROD \RINGZERO = \RINGZERO$.
A (semi)ring for which $a \RINGPROD b = b \RINGPROD a$ is commutative. 
\punto
\end{definition}

\begin{example}
The number sets $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{R}$, and $\mathbb{C}$ with arithmetic operations $+$ and $\cdot$ and numbers $0$ and $1$ form commutative rings. The set $\mathcal{M}$ of $(n \times n)$ matrices  forms a non-commutative ring $(\mathcal{M}, \cdot, +, 0_{n,n}, I_{n})$, where $0_{n,n}$ and $I_{n}$ are the zero matrix and the identity matrix of size $(n \times n)$. The set $\mathbb{N}$ of natural numbers  is a commutative semiring but not a ring because it has no additive inverse. Further examples are the max-product semiring $(\mathbb{R}_{+}, \max, \times, 0, 1)$, the Boolean semiring $(\{ \text{true}, \text{false} \}, \lor, \land, \text{false}, \text{true})$,  and the set semiring $(2^{U}, \cup, \cap, \emptyset, U)$ of all possible subsets of a given set $U$.\punto
\end{example}


%\medskip

\paragraph{\textbf{Data.}}

%{\bf Data Model.}
A schema $\mathcal{S}$ is a set of variables. Let $\Dom(X)$ denote the domain of a variable $X$. A tuple $\vecnormal{t}$ over schema $\mathcal{S}$ has the domain $\Dom(\mathcal{S}) = \prod_{X \in \mathcal{S}}{\Dom(X)}$. The empty tuple $\tuple{}$ is the tuple over the empty schema.
%We denote by $\sch(\vecnormal{t})$ the schema of the tuple $\vecnormal{t}$.

\nop{
A ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$ is a set with two binary operations, $+$ and $*$, which generalize the arithmetic operations of addition and multiplication, the additive identity $\RINGZERO$, the multiplicative identity $\RINGONE$, and an additive inverse for each element of $\RING$ .
Examples of rings are $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{R}$, $\mathbb{R}^2$, $\mathbb{R}^3$, and matrix ring.
}

Let $(\RING,\hspace{-0.05em} \RINGPLUS,\hspace{-0.05em} \RINGPROD,\hspace{-0.05em} \RINGZERO,\hspace{-0.05em} \RINGONE)$ be a ring. A {\em relation} $\VIEW{R}$ over schema $\mathcal{S}$ and the ring $\RING$ is a function $\VIEW{R}: \Dom(\mathcal{S}) \to \Codom$ mapping tuples over schema $\mathcal{S}$ to values in $\Codom$ such that $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$ for finitely many tuples $\vecnormal{t}$. The tuple $\vecnormal{t}$ is called a {\em key}, while its mapping $\VIEW{R}[\vecnormal{t}]$ is the {\em payload} of $\vecnormal{t}$ in $\VIEW{R}$. We use $\sch(\VIEW{R})$ to denote the schema of $\VIEW{R}$. 
The statement $\vecnormal{t} \in \VIEW{R}$ tests if $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$. The size $|\VIEW{R}|$ of $\VIEW{R}$ is the size of the set $\{ \vecnormal{t} \mid \vecnormal{t} \in \VIEW{R} \}$, which consists of all keys with non-$\RINGZERO$ payloads. 
A database $\db$ is a collection of relations over the same ring. Its size $|\db|$ is the sum of the sizes of its relations. 
This data model is in line with prior work on $K$-relations over provenance semirings~\cite{Green:2007:ProvenanceSemirings}, generalized multiset relations~\cite{Koch:Ring:2010:PODS}, and factors over semirings~\cite{FAQ:PODS:2016}.

Each relation  or materialized view $\VIEW{R}$  over schema $\mathcal{S}$ is implemented 
as a hash map or a multidimensional array that stores 
key-payload entries $(\vecnormal{t},\VIEW{R}[\vecnormal{t}])$ for each tuple 
$\vecnormal{t}$ with $\VIEW{R}[\vecnormal{t}] \neq \RINGZERO$.
% and needs $O(|R|)$ space.
The data structure can:
(1) look up, insert, and delete entries in (amortized) constant time, and
(2) enumerate all stored entries in $\VIEW{R}$ 
with constant (amortized) \emph{delay}, i.e., the following times are constant: 
(i) the time between the start of the enumeration and outputting the first tuple, (ii) the time between outputting any two consecutive tuples, and (iii) the time between outputting the last tuple and the end of the enumeration~\cite{DurandFO07}.
For a schema $\mathcal{X} \subset \mathcal{S}$,
we use an index data structure that for any $\vecnormal{t} \in \Dom(\mathcal{X})$ can:
(4) enumerate all tuples in $\sigma_{\mathcal{X}=\vecnormal{t}} \VIEW{R}$ with constant delay,
(5) check $\vecnormal{t} \in \pi_{\mathcal{X}}\VIEW{R}$ in constant time; and
(7) insert and delete index entries in (amortized) constant time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\paragraph{\textbf{Query Language.}}
We consider queries with natural joins and group-by aggregates:
\begin{lstlisting}[language=SQL,mathescape]
  SELECT$\;X_1,\ldots,X_f$,$\;$SUM$(g_{f+1}(X_{f+1}) * ... * g_{m}(X_{m}))$
  FROM $R_1$ NATURAL$\;$JOIN $\ldots$ NATURAL$\;$JOIN $R_n$
  GROUP$\;$BY $X_1,\ldots,X_f$
\end{lstlisting}
The group-by variables $X_1,\ldots,X_f$ are also called {\em free}, while the other variables $X_{f+1},\ldots,X_m$ are {\em bound}. The {\tt SUM} aggregate values are from a ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$. The lifting functions $g_{k}: \Dom(X_k) \to \RING$, for $f < k \leq m$, map (lift) variable values to elements in $\RING$. The \texttt{SUM} operator uses the addition $\RINGPLUS$ from $\RING$. More complex aggregates can be expressed using the sum and product operations from the ring. 
Instead of the verbose SQL notation, we use the following more compact encoding:
\begin{align*}
\qquad  \VIEW[X_1,\ldots,X_f]{Q} = \VSUM_{X_{f+1}} \cdots \VSUM_{X_{m}} \VPRODBIG_{i \in [n]} \VIEW[\mathcal{S}_i]{R_i}
\end{align*}
where $\VPROD$ is the join operator, $\VSUM_{X_{f+1}}$ is the aggregation operator that  marginalizes over the variable $X_{f+1}$, and each relation $\VIEW{R_i}$ is a function mapping keys over schema $\mathcal{S}_i$ to payloads in $\RING$. We also need a union operator $\VPLUS$ to express updates (insert/delete) to relations.

\begin{example}
  \label{ex:sql_count}
  We show how to encode the following SQL query over tables $R(A,B)$, $S(A,C,E)$, and $T(C,D)$ in our formalism:
  \begin{lstlisting}[language=SQL,mathescape,columns=flexible]
    SELECT SUM(1) FROM R NATURAL JOIN S NATURAL JOIN T  
  \end{lstlisting}
  % Assuming the ring $\mathbb{Z}$, 
  We encode the table $R$ as a relation $\VIEW{R}: \Dom(A) \times \Dom(B) \to \mathbb{Z}$ that maps tuples $(a,b)$ to their multiplicity in $R$; similarly, we encode the tables $S$ and $T$ as relations $\VIEW{S}$ and $\VIEW{T}$. We translate the SQL query into: 
  % 
  $$
    \VIEW[~]{Q} = \underset{A,B,C,D,E}{\VSUM} \VIEW[A,B]{R}  \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
  %  \VIEW[~]{Q} = \VSUM_{A}\VSUM_{B}\VSUM_{C}\VSUM_{D}\VSUM_{E} \VIEW[A,B]{R} \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
  $$
  where the lifting functions used in marginalization map all values to $1$.
  Remember that by definition $\VIEW{R}$, $\VIEW{S}$, and $\VIEW{T}$ are finite relations.
  The relation $\VIEW{Q}$ maps the empty tuple $()$ to the count. 
  \punto
  \end{example}


Given a ring $(\RING, \RINGPLUS, \RINGPROD, \RINGZERO, \RINGONE)$, relations $\VIEW{R}$ and $\VIEW{S}$ over schema $\mathcal{S}_1$ and relation $\VIEW{T}$ over schema $\mathcal{S}_2$, a variable $X \in \mathcal{S}_1$, and a lifting function $g_{X}:\Dom(X) \to \RING$, we define the three operators as follows: 

\hspace{-1.9em} 
\begin{tabular}{@{~}l@{~~~~~}r@{~}r@{\;}l@{}}
\multicolumn{4}{@{~}l}{\em union:}\\
& $\forall\vecnormal{t} \in \mathsf{D}_1{:}$ & 
  $(\VIEW{R} \VPLUS \VIEW{S})[\vecnormal{t}]$ & 
  $= \VIEW{R}[\vecnormal{t}] + \VIEW{S}[\vecnormal{t}]$ \\[4pt]

\multicolumn{4}{@{~}l}{\em join:}\\
& $\forall\vecnormal{t} \in \mathsf{D}_2{:}$ & 
  $(\VIEW{S} \VPROD \VIEW{T})[\vecnormal{t}]$ & 
  $= \VIEW{S}[\pi_{\mathcal{S}_1}(\vecnormal{t})] * \VIEW{T}[\pi_{\mathcal{S}_2}(\vecnormal{t})]$\\[4pt]

\multicolumn{4}{@{~}l}{\em aggregation by marginalization:}\\[4pt]
& $\forall\vecnormal{t} \in \mathsf{D}_3{:}$ & 
  $(\VSUM_{X} \VIEW{R})[\vecnormal{t}]$ & 
  $= \textstyle\sum \,\{\, \VIEW{R}[\vecnormal{t}_1] \,\RINGPROD\, g_{X}(\pi_{\{X\}}(\vecnormal{t}_1)) \mid$\\
& & &
  \hspace{2.05em}
  $\vecnormal{t}_1 \,{\in}\, \mathsf{D}_1, \vecnormal{t} = \pi_{\mathcal{S}_1 \setminus \{X\}}(\vecnormal{t}_1) \}$  
\end{tabular}
\\[6pt]
where $\mathsf{D}_1 = \Dom(\mathcal{S}_1)$, $\mathsf{D}_2 = \Dom(\mathcal{S}_1 \cup \mathcal{S}_2)$, and $\mathsf{D}_3 = \Dom(\mathcal{S}_1 \setminus \{X\})$, and $\pi_{\mathcal{S}}(\vecnormal{t})$ is a tuple representing the projection of tuple $\vecnormal{t}$ on the schema $\mathcal{S}$.


\begin{example}
Consider relations over a ring $(\RING,\hspace{-0.05em} \RINGPLUS,\hspace{-0.05em} \RINGPROD,\hspace{-0.05em} \RINGZERO,\hspace{-0.05em} \RINGONE)$:
\begin{center}
  \small
  \begin{tabular}{lll}
    \begin{tabular}[t]{@{\,}l@{~}l@{~$\to$~}l@{\,}}
      $A$ & $B$ & $\VIEW{R}[A,B]$ \\\toprule
      $a_1$ & $b_1$ & $r_1$ \\
      $a_2$ & $b_1$ & $r_2$ \\
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      A & B & $\to$ & $\VIEW[A,B]{S}$ \\\toprule
      $a_2$ & $b_1$ & $\to$ & $s_1$ \\
      $a_3$ & $b_2$ & $\to$ & $s_2$ 
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      B & C & $\to$ & $\VIEW[B,C]{T}$\\\toprule
      $b_1$ & $c_1$ & $\to$ & $t_1$ \\
      $b_2$ & $c_2$ & $\to$ & $t_2$ 
    \end{tabular}
  \end{tabular}
\end{center}
The values $r_1$, $r_2$, $s_1$, $s_2$, $t_1$, $t_2$ are non-$\RINGZERO$ values from $\RING$. 
The operators $\VPLUS$, $\VPROD$, and $\oplus$ are akin to classical union, join, and aggregation:

\vspace{-6pt}
\begin{center}
  \small  \hspace*{-1em}
  \begin{tabular}{l@{\hskip 0.5em}l}
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      $A$ & $B$ & $\to$ & $(\VIEW{R} \VPLUS \VIEW{S})[A,B]$ \\\toprule
      $a_1$ & $b_1$ & $\to$ & $r_1$ \\
      $a_2$ & $b_1$ & $\to$ & $r_2+s_1$ \\
      $a_3$ & $b_2$ & $\to$ & $s_2$
    \end{tabular}
    &
    \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{~}l@{\,}}
      $A$ & $B$ & $C$ & $\to$ & $\big((\VIEW{R} \VPLUS \VIEW{S}) \VPROD \VIEW{T}\big)[A,B,C]$ \\\toprule
      $a_1$ & $b_1$ & $c_1$ & $\to$ & $r_1*t_1$ \\
      $a_2$ & $b_1$ & $c_1$ & $\to$ & $(r_2 + s_1)*t_1$ \\
      $a_3$ & $b_2$ & $c_2$ & $\to$ & $s_2*t_2$
    \end{tabular}
  \end{tabular}\\[4ex]
  \begin{tabular}[t]{@{\,}l@{~}l@{~}l@{~}l@{\,}}
      $B$ & $C$ & $\to$ & $\big(\VSUM_{A}(\VIEW{R} \VPLUS \VIEW{S}) \VPROD \VIEW{T} \big)[B,C]$ \\\toprule
      $b_1$ & $c_1$ & $\to$ & $r_1 * t_1  \,*\, g_{A}(a_1) + (r_2 + s_1) * t_1  \,*\, g_{A}(a_2)$ \\
      $b_2$ & $c_2$ & $\to$ & $s_2 * t_2 \,*\, g_{A}(a_3)$
    \end{tabular}
  \end{center}
 where $g_A:\hspace{-0.05em} \Dom(A) \hspace{-0.05em}\to\hspace{-0.05em} \RING$ is the lifting function for $A$.
  \punto
\end{example}




\begin{example}\label{ex:sql_sum_aggregate}
Let us consider the SQL query from Section~\ref{ex:sql_sum_aggregate_intro}, which computes \texttt{SUM(R.B$\,$*$\,$T.D$\,$*$\,$S.E)} grouped by $A$, $C$. Assume that $B$, $D$, and $E$ take values from $\mathbb{Z}$.
We model the tables $R$, $S$, and $T$ as relations mapping tuples to their multiplicity, as in Example~\ref{ex:sql_count}. 
The variables $A$ and $C$ are free, while  $B$, $D$, and $E$ are bound. 

When marginalizing over the bound variables, we apply the same lifting function to these variables: $\forall x \in \mathbb{Z}: g_{B}(x) = g_{D}(x) = g_{E}(x) = x$. The SQL query can be expressed in our formalism as follows:
$$
  \VIEW[A,C]{Q} = \underset{B,D,E}{\VSUM}\VIEW[A,B]{R} \VPROD \VIEW[A,C,E]{S} \VPROD \VIEW[C,D]{T}
$$
The computation of the aggregate \texttt{SUM(R.B$\,$*$\,$T.D$\,$*$\,$S.E)} now happens over payloads. 
% We can exploit the associativity of $\VPROD$ and the distributivity of $\VPROD$ over $\oplus$ to push the marginalization past joins wherever possible:
% \begin{align*}
%   \VIEW[A,C]{Q} = \big(\VSUM_{B} \VIEW[A,B]{R} \big) \VPROD  
%     \big(\VSUM_{E} \VIEW[A,C,E]{S} \big) \VPROD 
%     \big(\VSUM_{D} \VIEW[C,D]{T} \big)
% \end{align*}
\punto
\end{example}

One key benefit of using relations over rings is avoiding the intricacies of incremental computation under classical multiset semantics caused by 
non-commutativi\-ty of inserts and deletes. Our data model simplifies delta processing by representing both inserts and deletes as tuples, with the distinction that they map to positive and respectively negative ring values. This uniform trea\-tment allows for simple delta rules for the three operators of our query language.

\bigskip

\nop{
This sum-product formulation covers many computational problems such as conjunctive query evaluation, inference in probabilistic graphical models, and matrix chain multiplication~\cite{FAQ:PODS:2016}. 
}
