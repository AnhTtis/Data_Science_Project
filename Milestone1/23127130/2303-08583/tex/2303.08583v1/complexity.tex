\section{Complexity Analysis}
\label{sec:complexity_analysis}

{\bf Size bounds.} For a join query $Q$, its hypergraph $H(Q)$ has one node per variable in $Q$ and one hyperedge per relation in $Q$.  Figures~\ref{fig:example_intro_varorder} depicts a query hypergraph.

An edge cover is a subset of (hyper)edges of $H(Q)$ such that each node appears in at least one edge. Edge cover can be formulated as an integer programming problem by assigning to each edge $R_i$ a weight $w_{R_i}$ that can be $1$ if $R_i$ is part of the cover and $0$ otherwise. The size of an edge cover upper bounds the size of the query result, since the Cartesian product of the relations in the cover includes the
query result: $|Q(\db)| \leq |R_1|^{w_{R_1}}\cdot\ldots\cdot|R_n|^{w_{R_n}}$, where the database $\db$ is $(R_1,\ldots,R_n)$. By minimizing the size of the edge cover, we can obtain a lower upper bound on the size of the query result. This bound becomes tight for fractional weights~\cite{AGM:2013}.  Minimizing the sum of the weights thus becomes the objective of a linear program.

\begin{definition}[\cite{AGM:2013}]\label{def:agm}
Given a join query $Q$ over a database $(R_1,\ldots,R_n)$, the {\em fractional edge cover number} $\rho^*(Q)$ is the cost of an optimal solution to the linear program with variables $(w_{R_i})_{i\in[n]}$ representing weights of $(R_i)_{i\in[n]}$:
\begin{flalign*}
\textrm{minimize} &\prod_{i\in[n]} |R_i|^{w_{R_i}}\\
\textrm{subject to} &\sum_{R\textrm{ is relation of } X} w_R \geq 1~~\textrm{for each variable } X \\
&~~~\forall i\in[n]: \omega_{R_i}\geq 0.
\end{flalign*}
\end{definition}

\begin{example}
\em
Consider the triangle query:
\begin{align*}
Q_{\vartriangle} = R(A,B), S(B,C), T(C,A)
\end{align*}
Figure~\ref{fig:triangle_hypergraph_viewtree} gives the hypergraph of $Q_{\vartriangle}$. The linear program is: 
\begin{flalign*}
\textrm{\em minimize} & \quad |R|^{w_{R}} \cdot |S|^{w_{S}} \cdot |T|^{w_{T}} \\ 
\textrm{\em subject to} & \quad
\begin{tabular}[t]{@{}c@{\hspace*{.5em}}c@{\hspace*{.25em}}c@{\hspace*{.25em}}c@{\hspace*{.25em}}c@{\hspace*{.25em}}c@{\hspace*{.25em}}c}
$A:$ & $w_{R}$ & & & $+$& ${w_{T}}$& $\geq 1$ \\
$B:$ & $w_{R}$ & $+$ & ${w_{S}}$ & & & $\geq 1$ \\
$C:$ & & & $w_{S}$ & $+$ & ${w_{T}}$ & $\geq 1$
\end{tabular}
\end{flalign*}
% 
For $|R|=|S|=|T|=N$, setting $w_{R}=w_{S}=w_{T}=1/2$ gives the optimal solution $\rho^*(Q_{\vartriangle}) = N^{3/2}$. Consequently, the query result has $\bigO{N^{3/2}}$ tuples. This bound is tight in the sense that there exist classes of databases for which the result size is at least $\Omega(N^{3/2})$. For the acyclic query $Q$ in Section~\ref{sec:introduction}, setting the weights $1$ to each of the three relations gives $\rho^*(Q)=N^3$ if all relations have size $N$.
\punto
\end{example}

\nop{
Cardinality constraints can be used to lower the size bounds of query results. For instance, if the number of distinct $A$-values in $R(A,B)$ is $k \ll N$, then we can refine  $Q_\vartriangle$ as $R(A,B),S(B,C),T(C,A),U(A)$ with the new size bound $\rho^*(Q_\vartriangle) = N \cdot k$, where $w_{S}=1$ and $w_{U}=1$.

Join selectivities can also be incorporated to obtain a size {\em estimate} (in contrast to an upper bound). For instance, assume the selectivity of the join on $A$ between $R$ and $T$ is very low: $sel(A) = \frac{|R(A,B),T(C,A)|}{|R|\cdot|T|} = \frac{k}{N}$. Then, we consider a relation $U(A,B,C)=R(A,B),T(C,A)$ whose size estimate is $k \cdot N$ and use this as a cardinality constraint to obtain an estimate of $k \cdot N$ for $Q_\vartriangle$'s size since the size of the join of $S$ and $U$ cannot exceed the size of $U$.
}

Similarly to $\rho^*(Q)$, the {\em factorization width} $\fw(Q)$ governs the sizes of the factorized results of a join query $Q$~\cite{Olteanu:FactBounds:2015:TODS}. In a factorized join over a variable order $\omega$, the values of a variable $X$  depend on the tuples of values of its $\mathit{key}(X)$ variables and are independent of the values for other variables. A tight bound on this number is then given by the size of a join query that covers the variables in $\mathit{key}(X)\cup\{X\}$. We denote this restriction of $Q$ by $Q_{\mathit{key}(X)\cup\{X\}}$. An upper bound on the size of the factorization is then given by the maximum over all variables in $\omega$ of their number of values. This can be improved by going over all possible variable orders of $Q$ and taking the minimum upper bound. This is the factorization width of the query.

\begin{definition}\label{def:fw}
Given a join query $Q$, the {\em factorization width} of $Q$ is  $\fw(Q) = \min_{\omega\in\Omega(Q)} \max_{v\in\mathit{vars}(Q)} \rho^*(Q_{\mathit{key}(X)\cup\{X\}})$.
\end{definition}

\begin{example}\em
For acyclic queries $Q$ over relations $R_1,\ldots,R_n$, $\fw(Q)=\max_{i\in[n]}(|R_i|)$, while $\rho^*(Q)$ can be as much as $\prod_{i\in[n]}|R_i|$ as in our running example. Here are examples of restrictions of our natural join $Q$ in Section~\ref{sec:intro_example}: $\mathit{key}(D)\cup\{D\}=\{C,D\}$ is covered by the query restriction $Q_{\{C,D\}}$ that is the relation $T$; $\mathit{key}(C)\cup\{C\}=\{A,C\}$ is covered by the query restriction $Q_{\{A,C\}}$ that is the relation $S$. For the triangle query $Q_\vartriangle$ and variable order $A-B-C$: $\mathit{key}(C)\cup\{C\}=\{A,B,C\}$ is covered by $Q_\vartriangle$, while $\mathit{key}(B)\cup\{B\}=\{A,B\}$ is covered by relation $R$.
\punto
\end{example}

For any join query $Q$, its factorization width is the fractional hypertree width~\cite{Olteanu:FactBounds:2015:TODS}, a parameter that captures tracta\-bility for a host of computational problems~\cite{FAQ:PODS:2016}.

\begin{proposition}
\label{prop:factorization}
Given a join query $Q$, for every database $\db$, the result $Q(\db)$ admits:
\begin{itemize}
\item a flat representation of size $\bigO{\rho^*(Q)}$~{\em\cite{AGM:2013}};
\item a factorized representation of size $\bigO{\fw(Q)}$~{\em\cite{Olteanu:FactBounds:2015:TODS}}.
\end{itemize}

There are classes of databases $\db$ for which the above size bounds are tight. The flat and factorized representations of $Q(\db)$ can be computed worst-case optimally{\em~\cite{Ngo:SIGREC:2013,Olteanu:FactBounds:2015:TODS}}.
\end{proposition}


\subsection{Dynamic Factorization Width}
\label{sec:dynamic_width}

\milos{Doesn't consider other rings (only LR), indicator projections, and factorizable updates}

As in the non-incremental case, different variable orders may lead to wildly different performance of our IVM approach. In this section, we settle the question of which variable orders can best support IVM under updates to a given set of relations and thereby pinpoint the complexity of maintaining query results under updates. This is captured by a novel notion called {\em dynamic factorization width}, which is a refinement of the factorization width.

We first recall the complexities in the non-incremental case. There, we only materialize the root view of a view tree over a variable order with the smallest factorization width, and we thus have the time data complexity $\bigO{\fw(Q)}$ for computing factorized joins~\cite{Olteanu:FactBounds:2015:TODS} and aggregates over them~\cite{BKOZ:PVLDB:2013,FAQ:PODS:2016}; for cofactor matrices over factorized joins, there is an additional $\bigO{m^2}$ factor, since the sizes of these matrices can be quadratic in the number $m$ of variables (features)~\cite{SOC:SIGMOD:2016}. The space complexity is $\bigO{1}$ or $\bigO{m^2}$ to store the aggregate or cofactor matrix in addition to the database (modulo logarithmic factors in the data size for data iterators).

We next discuss the IVM case. Let $Q$ be any join query. For any variable order $\omega \in \Omega(Q)$, let $\tau(\omega)$ be the view tree inferred from $\omega$. This view tree has exactly one leaf for each relation symbol in $Q$.

We consider updates to relations whose relation symbols in $Q$ form a set ${\mathcal{U}}$; a relation may have several relation symbols  if it is involved in self-joins in $Q$, in which case all of them are in ${\mathcal{U}}$. For a relation symbol $R\in{\mathcal{U}}$, let $\Upsilon_{\tau(\omega)}(R)$ be the set of views that are ancestors of the leaf $R$ in $\tau(\omega)$, i.e., it consists of all the views (recursively) defined using $R$. 

The time needed to compute the delta for a view $\VIEW[keys]{V^{@X}_{rels}}$ is upper bounded by that of a join query $Q^{\sf rels}_{\sf keys \cup \{X\}-\sigma(R)}$ over relations in {\sf rels} that cover $X$ and the variables in {\sf keys} but excluding the variables in $R$. The reason for the exclusion is that a single-tuple update to $R$ binds the variables in $R$ to constants. The overall time to compute the deltas of all views in $\Upsilon_{\tau(\omega)}(R)$ is then
\begin{align*}
T(\omega,R) = \sum_{\VIEW[keys]{V^{@X}_{rels}}\in\Upsilon_{\tau(\omega)}(R)} \rho^*(Q^{\sf rels}_{{\sf keys\cup\{x\}}-\sigma(R)}).
\end{align*}

We are now ready to define the dynamic factorization width that captures the time complexity of incremental maintenance of $Q$ under updates to relations in ${\mathcal{U}}$.

\begin{definition}
Given a join query $Q$ and a set of relation symbols ${\mathcal{U}}$ in $Q$. Then, the {\em dynamic factorization width} of $Q$ and ${\mathcal{U}}$ is $\dfw(Q,{\mathcal{U}}) = \min_{\omega\in\Omega(Q)}\max_{R\in\mathcal{U}} T(\omega,R).$
\end{definition}

\begin{theorem}
Given a query $Q$ with $m$ variables, database $\db$, a payload ring $\RING$, and a set of relations ${\mathcal{U}}$ in $\db$. The time complexity of incrementally maintaining the result of $Q$ over the ring $\RING$ under single-tuple updates to relations in ${\mathcal{U}}$ is $\bigO{\dfw(Q,{\mathcal{U}})\cdot T_\RING}$, where $T_\RING$ is $\bigO{1}$ for rings of numbers and $\bigO{m^2}$ for the degree-$1$ matrix ring.
\end{theorem}

\begin{example}\label{ex:time-complexity}
\em
For our query $Q$ in Section~\ref{sec:intro_example} and database $\db$, the (static) factorization width is $\fw(Q)=O(|R|+|S|+|T|)$. Under single-tuple updates to relations in a set ${\mathcal{U}}_1\subseteq\{R,S\}$, the dynamic factorization width is $\dfw(Q,{\mathcal{U}}_1)=1$ since there are no free variables of the views over $R$ or $S$ in the variable order in Figure~\ref{fig:example_intro_varorder}. This means that we can maintain the result of a sum aggregate over $Q$ in $\bigO{1}$ time under ${\mathcal{U}}_1$ updates. The same holds for ${\mathcal{U}}_2\subseteq\{S,T\}$, i.e., $\dfw(Q,{\mathcal{U}}_2)=1$, as supported by the variable order $C-\{ D, A - \{ B, E \}\}$. However, $\dfw(Q,{\mathcal{U}}_3)=\bigO{|\db|}$ for ${\mathcal{U}}_3=\{R,S,T\}$ since there is no variable order without free variables above all three relations and some variable orders have one free variable above at least one of the three relations. Under the variable order in Figure~\ref{fig:example_intro_varorder}, $\dfw(Q,{\mathcal{U}}_3)=\min(|R|,|S|)$.

The triangle query $Q_\vartriangle$ has the (static) factorization width $\fw(Q_\vartriangle)= \rho^*(Q_\vartriangle)$. For any relation $U \in \{ R, S, T \}$, the dynamic factorization width is $\dfw(Q,\{ U \})=1$ as supported by a path variable order that has the variables in $U$ as prefix. We can thus maintain an aggregate over the triangle query in $\bigO{1}$ under single-tuple updates to exactly one of its three relations. For updates to at least two relations ${\mathcal{U}}_4$, $\dfw(Q,{\mathcal{U}}_4)=O(|\db|)$. For instance, assume a variable order $A-B-C$. We need to cover: no variable under updates to $R$; one of the variables $A$ or $B$ under updates to $S$ or $T$ respectively (the case for other permutations of this variable order is analog). Maintenance has thus lower time cost than recomputation.
\punto
\end{example}

We next analyze the space complexity $S(Q)$ of our approach. This is the sum of the sizes of the views in a view tree. The space needed by the keys of a view $\VIEW[keys]{V^{@X}_{rels}}$ is given by the fractional edge cover of a join query built using relation symbols {\sf rels} to cover the variables in {\sf keys}. To obtain the minimum size, we go over all variable orders of $Q$:
\begin{align*}
 S(Q) = \min_{\omega\in\Omega(Q)}\sum_{\VIEW[keys]{V^{@X}_{rels}}\in\tau(\omega)} \rho^*(Q^{\sf rels}_{\sf keys}).
\end{align*}

\begin{theorem}
Given a query $Q$ with $m$ variables, database $\db$, a payload ring $\RING$. The space complexity required by the materialization of a view tree for $Q$ over the ring $\RING$ is $\bigO{S(Q)\cdot T_\RING}$, where $T_\RING$ is $\bigO{1}$ for the sum ring and $\bigO{m^2}$ for the degree-$m$ matrix ring.
\end{theorem}

There are three differences between the formula $S(Q)$ and Definition~\ref{def:fw} of the factorization width $\fw(Q)$: (1) the use of summation vs. maximum, though the gap between them is linear in $m$ and thus independent of the database size; (2) the cover for $S(Q)$ can only use relation symbols of the view; (3) for $S(Q)$, we only need to cover $\sf keys$ and not also the variable at the view as in the case of $\fw(Q)$. The interplay of (2) and (3) can in fact make $S(Q)$ larger than $\fw(Q)$.
For acyclic queries, both complexities are linear if all relations have the same size and $S(Q)$ can be smaller than $\fw(Q)$ in case some relations are asymptotically smaller than others. 
For cyclic queries, however, $S(Q)$ can be larger than $\fw(Q)$. We show this for the triangle query $Q_\vartriangle$ and relations of the same size $N$. Under any variable order, there is a view of size $\bigO{N^2}$, whereas $\fw(Q_\vartriangle)=N^{3/2}$. For instance, for the variable order $A-B-C$, we materialize the view $\VIEW[A,B]{V^{@C}_{ST}} = \VSUM_{C} \VIEW[B,C]{S} \VPROD \VIEW[C,A]{T} \VPROD \VIEW[C]{\VLIFT_{C}}$, which may create $\bigO{N^2}$ pairs $(A,B)$ as we need both $S$ and $T$ to cover the variables $A$ and $B$. To avoid the large intermediate result, we join all three relations at the same time~\cite{Ngo:SIGREC:2013}, so as to cover $(A,B)$ using $R$. That would, however, require recomputation of this 3-way join for each update. This takes $\bigO{N}$ time since only two of the three variables are bound to constants. In contrast, our IVM approach trades off space for time: We need $\bigO{N^2}$ space but then support $\bigO{1}$ updates to one of the three relations (Example~\ref{ex:time-complexity}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
