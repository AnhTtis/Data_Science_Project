\section{Note on Complexity of \DF}
\label{appendix:complexity}

Due to lack of space, we only mention the complexity of \DF without proof. Let $Q$ be the conjunctive query, $\omega$ its variable order, $\tau$ the view tree modeled on $\omega$, and $\mathcal{D}$ the database of input {\color{blue}relations}. Let $N$ be the maximum size of a {\color{blue}relation} in $\mathcal{D}$. We next assume view trees with indicator projections as introduced in Appendix~\ref{sec:cyclic_queries}.

{\bf Computation.} The time to compute the keys of any view in the view tree $\tau$ is $O(N^{{\it fhtw}(\omega)})$, where $\mathit{fhtw}(\omega)$ is the fractional hypertree width of the variable order $\omega$~\cite{Olteanu:FactBounds:2015:TODS,FAQ:PODS:2016}. By taking the variable order that minimizes ${\it fhtw}(\omega)$, we obtain the fractional hypertree width ${\it fhtw}(Q)$ of $Q$~\cite{Marx:2010}.

The above analysis ignores payload computation! For the standard sum-product ring (e.g., $\mathbb{R}$), the additional complexity brought by payload computation is subsumed by the above upper bound. For the degree-$m$ matrix ring, the additional complexity factor is $O(m^2)$, totalling $O(N^{{\it fhtw}(\omega)}\cdot m^2)$. However, for the relational data ring, the payload size may become larger than the key size. Assuming a worst-case optimal join algorithm for computing the cyclic joins, e.g., LeapFrog TrieJoin~\cite{Veldhuizen14:LFTJ}, the time to compute the payloads is $O(N^{\rho^*(Q)})$, where $\rho^*(Q)$ is the fractional edge cover number of $Q$~\cite{AGM:2013}. For payloads encoding the factorized representation of the result of $Q$, the overall complexity remains $O(N^{{\it fhtw}(\omega)})$ since the cumulative size of all payloads of the views in the view tree is  $O(N^{{\it fhtw}(\omega)})$.

{\bf Maintenance.} The previous complexity results are for computation from scratch. We next discuss the complexity for maintenance under single-tuple update to some of the input {\color{blue}relations}. The complexity may become lower since the variables that appear in the updated {\color{blue}relations} are fixed to the constants in the update. Let $Q_u$ be the query $Q$ where all variables fixed to constants by the updates are removed; if a {\color{blue}relation} has no variable left, then it is removed from $Q_u$. Then, we define the {\em dynamic fractional hypertree width} of $Q$ as the fractional hypertree width of $Q_u$: $\mathit{dfhtw}(Q) = \mathit{fhtw}(Q_u)$. Similarly, the {\em dynamic fractional edge cover number} of $Q$ is the fractional edge cover number of $Q_u$: $\mathit{d\rho^*}(Q) = \mathit{\rho^*}(Q_u)$. Then, all complexity results from the previous computation case hold for maintenance where we replace the widths by their dynamic counterparts.




