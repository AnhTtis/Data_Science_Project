\documentclass[%
 %reprint,
 superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 %aps,
 prx,
 twocolumn,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math

\usepackage[table,svgnames]{xcolor} % provides the \rowcolors command 
%\rowcolors{2}{white}{lightgray} 
\setlength{\arrayrulewidth}{0.3mm}
\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.2}


\usepackage{color}
\usepackage[normalem]{ulem}
\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

\newcommand{\ms}[1]{{\color{blue}{#1}}} 


\definecolor{eggplant}{RGB}{180,33,147}
\newcommand{\xw}[1]{{\color{red}{#1}}} 
\definecolor{grey}{rgb}{.6,.6,.6}
\newcommand{\scrap}[1]{{\color{grey}{\sout{#1}}}}

\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle #1|}
\newcommand{\bracket}[2]{\langle #1| #2 \rangle}

\newcommand{\QIGA}{QiGA }  % change here if you find a better name, QiGA is somewhat ugly.



\begin{document}


%\title{Grover's Algorithm Offers No Practical Quantum Advantage}
\title{Grover's Algorithm Offers No Quantum Advantage}

\author{E.M.\ Stoudenmire}
%\email{mstoudenmire@flatironinstitute.org}
\affiliation{Center for Computational Quantum Physics, Flatiron Institute, 162 5th Avenue, New York, NY 10010, USA}
\author{Xavier Waintal}
\affiliation{PHELIQS, Universit√© Grenoble Alpes, CEA, Grenoble INP, IRIG, Grenoble 38000, France}


\date{\today} 

\begin{abstract}
Grover's algorithm is one of the primary algorithms offered as evidence that quantum computers can provide an advantage over classical computers. 
It involves an ``oracle'' (external quantum subroutine) which must be specified for a given application
and whose internal structure is not part of the formal scaling of the quantum speedup guaranteed by the algorithm. 
Grover's algorithm also requires exponentially
many steps to succeed, raising the question of its implementation on near-term, non-error-corrected hardware and indeed
even on error-corrected quantum computers. 
In this work, we construct a quantum inspired algorithm, executable on a classical computer, that performs
Grovers' task in a {\it linear} number of call to the oracle --- an exponentially smaller number than Grover's algorithm --- and
demonstrate this algorithm explicitly for boolean satisfiability problems (3-SAT).
Our finding implies that there is no {\it a priori} theoretical quantum speed-up associated with Grover's algorithm.
We critically examine the possibility of a practical speed-up, a possibility that depends on the nature of the quantum circuit 
associated with the oracle. We argue that the unfavorable scaling of the success probability of Grover's algorithm, which in the presence of noise decays as the exponential of the exponential of the number of qubits, makes a practical speedup unrealistic even under extremely optimistic assumptions on both hardware quality and availability.
\end{abstract}


\maketitle

\section{\label{sec:intro} Introduction}

Two classes of algorithms dominate the landscape of possible applications for quantum computing. 
The first class computes a non-trivial result then extracts this result using the quantum Fourier transform. 
This class includes the seminal Shor's algorithm for integer factorization \cite{Shor:1994,Beauregard,Kitaev} 
as well as the quantum phase estimation algorithm \cite{Kitaev} 
proposed for solving quantum chemistry problems and several other algorithms \cite{HHL}.  
Some of these algorithms, in particular Shor's, offer an exponential speedup over any known classical methods,
though only for a handful of rather specific applications.


The second class includes Grover's algorithm (GA) and its generalizations, such as amplitude amplification \cite{Grover,GroverReview,Brassard}. 
Grover's algorithm promises a less spectacular quadratic speedup, but in return enjoys 
wide popularity due to its many possible use cases.
Theoretically, quite a large number of problems could be accelerated by simply replacing the critical part of the classical
algorithm by a call to a Grover's routine implemented on a quantum computer. 
It is also appealing that the quadratic speedup
of Grover's algorithm can be put on firm mathematical grounds and is provably optimal under certain assumptions \cite{Bennett}, in contrast to Shor's where the speedup is only conjectured.
This quadratic speedup is very convenient theoretically as it does not require any knowledge of the oracle which encodes the problem
into the quantum algorithm. 
The class of problems for which Grover's algorithm can be applied include instances of 
NP-complete problems which are extremely challenging computationally. 
Applications where Grover's algorithm is the main subroutine range from optimizing functions \cite{Baritompa} for e.g. analyzing high energy physics data \cite{Wei} to solving various graph 
problems \cite{Durr} to option pricing \cite{Stamatopoulos2020} to pattern recognition (finding a string in a text) \cite{Ramesh} to
various form of machine learning (including supervised learning \cite{Aimeur}, perceptrons \cite{Kapoor}, active learning agents \cite{Kapoor} and reinforcement learning \cite{Dong}).   Specific versions have been implemented on small quantum processors with up to $n \leq 5$ qubits \cite{Dewes,Figgatt,Mandviwalla,Pokharel} but the success probability is still low for the largest systems.

Grover's algorithm solves the problem of inverting an unknown function.
Given a function \mbox{$y=f(b)$} where $b$ can take $N=2^n$ values, Grover's algorithm finds the value $b=f^{-1}(y)$ for a given $y$ in only $\sqrt{N}$ calls to the quantum ``oracle'' function which implements $f(b)$ while a naive exhaustive search would require about $N$ calls to the corresponding classical function. 
 Grover's theoretical speedup is of a peculiar nature: it is an abstract speedup that considers the oracle as a black box function and counts the computational cost solely in terms of the number of calls to the oracle. In any actual implementation, however, the oracle must be realized as a specific quantum circuit, hence the internal structure of $f(b)$ must be exposed. In particular the computational cost of one call to the $f(b)$ oracle may (almost always will) depend on $N$ in some way. 

In this work, we argue that there is no generic theoretical speed-up in Grover's algorithm. To this end, we
construct a quantum inspired Grover algorithm (QiGA) that solves Grover's problem on a classical computer. In contrast to the usual assumptions made to discuss quantum advantage in this context, the input of \QIGA is not the classical oracle $f(b)$ but the quantum oracle, which is the same quantum circuit that would be given to the quantum computer. The comparison with a quantum computer is fairer: both computers are given the same input. 
We find that \QIGA solves the problem in at most $O(\log N)$ calls and in many cases a single call to the {\it quantum} oracle. 
In other words, if one is capable of simulating the quantum circuit of the oracle once, then one can
obtain the same result that would require a quantum computer to make exponentially many calls to the oracle. 
Our findings provide a new comparison point for the discussion of any possible advantage.

In the second half of this work we discuss the implications of our work for the
possibility of a practical quantum advantage using Grover. We argue that if the oracle is too hard to simulate classically, so that
a quantum computer becomes necessary, then generic, practical problems arise. 
We show Grover's algorithm to be very sensitive to noise with the success probability decaying as the exponential of an exponential.
Beyond ruling out near-term implementations for more than a few qubits, such a rapid accumulation of noise would 
overwhelm any known quantum error correction protocol.
 
This is why we say Grover's algorithm offers no quantum advantage. By \emph{quantum advantage}
we mean for a specific problem of a fixed size, that a quantum algorithm running on actual hardware would 
reach the solution faster than the best classical strategy. 
For a given problem, if the oracle is easy to simulate then a quantum computer
is not needed, while if it is hard to simulate the quantum implementation will be, as we shall see, beyond the reach of foreseeable hardware.

This article starts with a summary of the main results (Section~\ref{sec:summary}) for readers mostly interested in the implications of our work. The rest of the article is split into two parts. In the first (Sections \ref{sec:review} and \ref{sec:classical}), we construct the quantum inspired algorithm that mimics Grover's algorithm in a classical computer but takes advantage of its internal structure to require exponentially fewer calls to the oracle. We explicitly demonstrate and test this algorithm using both random and quasi-one-dimensional instances of NP-complete random boolean satisfiability problems (3-SAT). 
In the second part of the article, we examine the implication of our findings on the possibility of a quantum speed-up (Sections \ref{sec:scaling}
and \ref{sec:advantage}). 
In particular, Section~\ref{sec:scaling} establishes the lack of resilience of Grover's algorithm to noise, an important aspect needed for the discussion of a possible quantum advantage.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:summary} Summary of the main results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{QiGA.pdf}
    \caption{ 
    \label{fig:QiGA} Schematic showing the main implications of our quantum-inspired Grover's algorithm (QiGA) for the possibility of Grover's algorithm offering a genuine quantum advantage.
    }
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{grover_entropy.pdf}
    \includegraphics[width=\columnwidth]{zoomed_grover_entropy.pdf}
    \caption{Entanglement entropy, in units of $\log(2)$, of the quantum state during a simulation of Grover's algorithm for $n=10$ qubits for the optimal number $r=25$ of iterations.
    Substeps between each complete iteration show the properties of the state after each layer of the quantum circuits described in Appendix~\ref{appendix:circuit} which implement the oracle and diffusion operators. The entropy is dominated by the oracle step for the first half of the algorithm, then becomes dominated by the diffusion step for the second half of the algorithm.
    During the simulation the matrix product state (MPS) rank (not shown) goes up and down in a sawtooth shape with maxima of $\chi=11$ during an iteration and minima of $\chi=2$ between each iteration. The dashed line along the lower envelope is the theoretical prediction for the entanglement between iterations of the algorithm (the oscillations are a small $1/N$ effect). The lower panel shows a zoom of the region in the box in the upper panel, labeling substeps where the oracle and diffuser circuits act.
    \label{fig:entropy}
    }
\end{figure}

The logic behind our main claim is summarized in Fig.~\ref{fig:QiGA}. The same ``oracle'' circuit that defines an implementation of GA on a quantum computer is given to a classical simulator which is limited only by entanglement (a tensor network). If this simulator can calculate a {\it single} oracle circuit with a  complexity better than $2^{n/2}$, our \QIGA algorithm solves the GA problem parametrically faster than a quantum computer would. Even when the simulator scales as a less favourable exponential, we explicitly demonstrate cases where simulating the oracle can be done in just hours on a desktop computer for $n \lesssim 40$ qubits and likely on a supercomputer for $n \lesssim 80$ qubits. For larger numbers of qubits there must be some instances of NP-complete problems where simulating the  oracle circuit remains infeasible. Yet for such problems, GA would require at least $2^{80/2}=2^{40} \approx 10^{12}$ application of the oracle circuit on a quantum computer which translates into an astronomically large time-to-solution even under favourable hardware assumptions.

At the root of this work is the observation that, {\it in between} the calls to the oracle, the level
of entanglement present in the internal state of a quantum computer running GA is extremely low. 
In between each iteration of GA, the entanglement 
entropy between any two subgroups of qubits is at most $\log(2)$. In other words, GA strongly leverages the ability of quantum mechanics to create superpositions (quantum parallelism) but it barely uses the possibility to entangle states. 

Before describing our ``quantum inspired" GA (where we use the resources available in 
a classical computer in the most efficient way), we start with a ``simulation" of GA (where we only use operations implementable on a quantum computer).
Figure~\ref{fig:entropy} shows the entanglement entropy of the quantum state during a simulation of Grover's algorithm for $n=10$ qubits, using the quantum circuit described in Appendix~\ref{appendix:circuit} to implement the oracle and diffusion steps. As claimed, the entanglement in between iterations never exceeds $\log(2)$, a value which is reached when the algorithm is halfway done. The entanglement entropy does become higher during the partial application of the oracle and diffusion operator circuits. The value of this intra-oracle entanglement barrier is strongly problem dependent and will determine the performance of the quantum inspired GA.

As we shall see, the low-entanglement states occurring in GA at integer and half integer iteration number have a simple classical representation in terms of a rank-2 ``matrix product state" \cite{Ostlund,Vidal,Perez-Garcia} (MPS) which can easily be kept on a classical computer at a linear cost in the number $n$ of qubits just by storing $2n$ matrices of size $2\times 2$. 
Similarly, the oracle itself is a rank-2 ``matrix product operator" \cite{McCulloch,Verstraete:2004} (MPO), another standard object of tensor network theory. 






A second, very important observation of this work is that being 
able to compute the action of the oracle circuit on the initial product state (the post-oracle state) is always sufficient to complete GA in a \emph{single} call to the oracle. 
In fact, it is sufficient to even just compute $\sim \log(N)$ {\it amplitudes} of this state in the $\ket{\pm}$ basis.
In this way the quantum inspired algorithm differs from a mere \emph{simulation} of GA that
would still require an exponentially large number $\sqrt{N} = 2^{n/2}$ of applications of the oracle circuit.
Hence, the initial problem is mapped onto the following question: given a quantum circuit that implements
a given oracle, how can one compute its action on an MPS? 
There exist standard techniques for computing the outputs of quantum circuits as tensor networks \cite{Crosswhite,McCulloch,Pirvu:2010,Zaletel}.
We illustrate them in two cases: in the first we take an explicit problem (known as 3-SAT) and show that the explicit knowledge of the oracle's quantum circuit can be exploited to enact the oracle efficiently in many cases. 
In the second, we consider the generic case of an arbitrary quantum circuit and show that the full post-oracle state can be constructed from $O(n)$ amplitudes of this state using the so-called tensor cross interpolation algorithm. 

It remains to discuss the implications of our findings on the possibility of quantum advantage using GA. On a theoretical level our quantum inspired GA requires exponentially fewer number of calls to the oracle. In turn, a classical calculation of the quantum oracle may be exponentially harder than the corresponding task on a quantum computer, depending on the quantum circuit structure and depth. Hence, which of the two approaches (classical or quantum) is faster depends on the actual problem and can not be decided a priori. In particular oracles whose quantum circuits have small depths (and therefore more of chance to be eventually implemented in quantum hardware)
can be solved trivially using our quantum inspired approach.

An interesting corollary of the quantum inspired GA algorithms relates to classical complexity theory. It is widely believed that $P \ne NP$, meaning the so-called NP-complete problems are exponentially difficult in the hardest cases. 
Since NP-complete problems, such as the random 3-SAT examples we consider below, can be simulated with GA, it follows that 
$P \ne NP$ implies that in at least one instance the entanglement barrier of the 3-SAT oracle must be exponentially high. 
Otherwise, because the cost of MPS simulations are determined by the entanglement, a single call to the oracle could be simulated in polynomial time and hence the full problem as well, which would imply $P=NP$. 
Thus there must be a direct connection between the complexity of a classical problem and the entanglement level of the associated quantum circuit.

On a practical level our quantum inspired GA puts very stringent conditions on putative quantum hardware that could be used to implement the GA. In presence of noise or imperfections, the probability of success of GA decreases exponentially with the number of applied gates in the circuit. Since the number of oracle calls, hence the number of gates, also scales exponentially with $n$ in GA, it follows that the overall success rate decays as an ``exponential of an exponential'', i.e.\ very quickly.  We estimate the associated constraints on the hardware in terms of qubit number $n$,
noise level, and quantum computer clock frequency and conclude that none of the requirements are realistic, even if fault-tolerant quantum technologies were available.


\section{\label{sec:review} Problem formulation}

Grover's algorithm \cite{Grover,GroverReview} aims to harness the potential of quantum parallelism by gradually extracting the result of a parallel function evaluation through a series of \emph{Grover iterations}. For a problem involving
classical states of length $N$, for which $n$ qubits are needed such that $N=2^n$, the number of 
Grover iterations needed to extract the result of the problem scales as $\sqrt{N}$, which is to be compared to worst-case classical
strategies such as guessing solutions at random or performing an exhaustive search which have a cost scaling as $N$.
 
\subsection{\label{sec:notations} Notation and Problem Setting}
Let $b\in\{0,1,\cdots,N-1\}$ be an integer whose binary representation is
$b_{n-1}\cdots b_1 b_0$, that is $b = \sum_{i=0}^{n-1} b_i 2^i$ with $b_i\in\{0,1\}$. We denote by $\ket{b} = 
\ket{b_{n-1} \cdots b_1 b_0}$ the corresponding $n$-qubit state in the computational basis.

Let $f(b)$, be a function that takes a bitstring as an input $b$
and returns 
\begin{align}
    f(b) = \begin{cases} 1, & \text{if}\ b = w \\ 0, & \text{if}\ b \neq w \end{cases} \ \ .
\end{align}
Here $w$ is a (unknown) specific bitstring. 
GA aims to solve the problem of finding the value of $w$ in as few calls to the function $f$ as possible.
This problem can be viewed as  inverting $f$, that is, computing $w = f^{-1}(1)$.

GA also assumes one can implement an \emph{oracle operator} $U_w$ such that for states $\ket{b}$
in the computational basis
\begin{align}
    U_w \ket{b} = (-1)^{f(b)} \ket{b}.
    \label{eq:oracle_action_basic}
\end{align}
Since quantum computer can perform classical logic (at the price of adding ancilla qubits to ensure reversibility), a classical algorithm that computes $f(b)$ can be turned into a quantum circuit
that implements Eq.~\eqref{eq:oracle_action_basic}. The explicit form of $U_w$ reads,
\begin{align}
    U_w \ket{b} = \begin{cases} -\ket{b}, & \text{if}\ b = w \\ +\ket{b}, & \text{if}\ b \neq w \end{cases}
    \label{eq:oracle_action}
\end{align}
therefore  $U_w$ is equivalent to the operator
\begin{align}
    U_w = 1 - 2 \ket{w} \bra{w} \ . \label{eq:oracle_operator}
\end{align}
However, for any real application of practical interest, one does not know the value of $w$ ahead of time and only knows how to implement 
$U_w$ as a quantum circuit based on the function $f$.

GA straightforwardly generalizes to the case of multiple solutions $\{w^\alpha\}_{\alpha=1}^{S}$ such that $f(w^\alpha)\equiv 1$. 
One defines the oracle as 
\begin{align}
    U_w = 1 - 2 \sum_{\alpha=1}^S \ket{w^\alpha} \bra{w^\alpha}.
    \label{eq:multi_oracle}
\end{align}
Each solution $w^\alpha$ has a binary representation $w^\alpha_{n-1} \cdot w^\alpha_2 w^\alpha_1 w^\alpha_0$.
In this article, we focus on the case where the problem has a fixed number of solutions $S$ (or more generically where $S$ grows at most polynomially with $n$). For problems that have an exponential number of solutions, our algorithm would have to be revisited, but we conjecture that easy classical solutions exist in that case. For each qubit, we define the two states $\ket{+}$ and $\ket{-}$ as,
\begin{align}
\ket{\pm} = \frac{\ket{0}\pm\ket{1}}{\sqrt{2}}
\end{align}
and the equal weight superposition state $\ket{s}$ as,
\begin{align}
    \ket{s} &= \ket{+++\cdots+} \\
            &=\frac{1}{\sqrt{2^n}} \sum_{x_{n-1} \cdots x_0 \in \{0,1\}^n} \ket{x_{n-1}\cdots x_0} \ .
\end{align}
Last, GA requires a second operator, the diffusion operator $U_s$ that has a structure
similar to the oracle but with respect to the known state $\ket{s}$:
\begin{align}
    U_s= 1 - 2 \ket{s} \bra{s} \ . \label{eq:diffusion_operator}
\end{align}

\subsection{\label{sec:grover_def} Definition of the Grover Algorithm}
Given an oracle $U_w$, GA proceeds as follows
\begin{enumerate}
    \item initiate the qubits in state $\ket{000\cdots0}$
    \item apply a Hadamard gate on each qubit to obtain $\ket{s}$
    \item apply the oracle operator $U_w$
    \item apply the diffusion operator $U_s$
    \item repeat steps 3 and 4 each $q$ times
    \item measure the qubits in the computational basis and find $\ket{w}$ with a probability very close to one
\end{enumerate}
The optimal number of steps of GA can be estimated to be about $q\approx r$ with 
$r \equiv \frac{\pi}{4} \sqrt{N} = \frac{\pi}{4} 2^{n/2}$. In the case where there are multiple solutions, the measurement at the end produces one of the $w^\alpha$ with uniform probability. GA has an appealing geometrical interpretation \cite{Nielsen}: $U_w$ and $U_s$ are mirror operators with respect to the hyper-planes perpendicular to $w$ and $s$. It follows that the product $U_sU_w$ is a rotation inside the ($\ket{s},\ket{w}$) plane that gradually rotates the state from $\ket{s}$ to $\ket{w}$.

\subsection{\label{sec:mps} On the level of entanglement inside Grover's algorithm}
The type of classical calculation we will consider involves representing the quantum state as a tensor network, specifically a matrix product state (MPS). 
An MPS compresses a quantum state by factoring it into a network of smaller
tensors contracted in a one-dimensional chain like structure. For states having low to moderate entanglement, the MPS rank or dimension $\chi$ of the ``bond'' indices connecting the MPS tensors can be chosen relatively small while representing the state to very high or even perfect accuracy.
Quantum states such as GHZ or W states are exactly MPS of rank $\chi=2$ and product states such as the initial state $\ket{s}$ of Grover's algorithm are $\chi=1$ MPS. An important fact we will use below is that any state which is a sum of $P$ product states can be explicitly written as an MPS of rank $\chi=P$ \cite{McCulloch}.

In the context of GA, one finds that after any application of
$U_w$ or $U_s$, the internal state $\ket{\Psi}$ of the quantum computer lies in a superposition of $\ket{s}$ and $\ket{w}$ \cite{Nielsen},
\begin{align}
\ket{\Psi} = \alpha \ket{s} + \beta \ket{w}
\end{align}
with $|\alpha|^2+|\beta|^2=1$, i.e. in the superposition of two unentangled states ($1+S$ states in the general case).   
It follows that $\ket{\Psi}$ can be cast into the form,
\begin{align}
\ket{\Psi} &=& 
\begin{bmatrix} \alpha  & \beta  \end{bmatrix}
\begin{bmatrix} \ket{w_1} & 0 \\ 0 & \ket{+} \end{bmatrix}
\begin{bmatrix} \ket{w_2} & 0 \\ 0 & \ket{+} \end{bmatrix} \ \ \ \nonumber\\
\ \ \ \ & ... & \begin{bmatrix} \ket{w_{n-1}} & 0 \\ 0 & \ket{+} \end{bmatrix}
\begin{bmatrix} \ket{w_n} & 0 \\ 0 & \ket{+} \end{bmatrix}
\begin{bmatrix} 1 \\ 1 \end{bmatrix}
\end{align} 
which is manifestly a rank $\chi=2$  MPS or $\chi=1+S$ in the general case. Such a state is minimally entangled and can easily be kept inside the memory of a classical computer at a linear cost in the number of qubits. In other words, while Grover's algorithm takes advantage of quantum parallelism (i.e. superposition), it uses very little entanglement for most of the algorithm. The only possible exception is while the oracle circuit has only been partially applied.





\section{\label{sec:classical} A quantum inspired algorithm for simulating Grover's algorithm in a single call to the oracle}

We now detail the different steps of our quantum inspired Grover's algorithm (\QIGA). Although we use MPS and MPO technology for both \QIGA and mere simulations of GA, we emphasize that the goals are very different. In the first, we aim at solving the Grover problem with as few computations as possible while in the latter we want to mimic what would happen in a (possibly noisy) actual quantum computer.

\subsection{\label{sec:grover_mpo} A low rank Matrix Product Operator (MPO) for Grover's oracle}

A crucial observation that makes \QIGA possible is that the oracle
 $U_w$ can be cast into the form of  a rank-$2$ MPO (rank $1+S$ in the case of multiple solutions).   
 The explicit form of this MPO is
\begin{align}
U_w = 
\begin{bmatrix} 1 & 1 \end{bmatrix}
 \left( \prod_{i=1}^n M_i \right)
\begin{bmatrix} 1 \\ -2 \end{bmatrix}
\label{eq:Uw_is_mpo1}
\end{align} 
with
\begin{align}
M_i = 
\begin{bmatrix} I_i & 0                        & 0 &...\\ 
                0         & \ket{w^1_i}\bra{w^1_i} & 0 & ... \\
                0         & 0                        & \ket{w^2_i}\bra{w^2_i} & ... \\
                ...       & ...     & ... & ... \\
                ...      & 0 & 0 & \ket{w^S_i}\bra{w^S_i}
\end{bmatrix} 
\label{eq:Uw_is_mpo2}
\end{align} 
where ${\rm I}_{i}$ is the $2\times 2$ identity matrix acting on qubit $i$ and
$\ket{w^\alpha_i}\bra{w^\alpha_i}$ the projector on the bitstring $i$ of solution $\alpha$.
We emphasize that this MPO {\it exists} but its construction is not necessarily easy since, by definition, one does not have access to the solutions $w^\alpha$.
A similar MPO can be written for the diffusion operator $U_s$ with the replacement of $M_i$ by
\begin{align}
    M'_i = 
    \begin{bmatrix} I_i & 0                   \\ 
                0         & \ket{+}\bra{+} 
\end{bmatrix} 
\end{align}
 in Eq.\eqref{eq:Uw_is_mpo1}. 
 

\subsection{Solving the problem in a single call to the oracle}

Assuming one has access to an explicit form of $U_w$, such as the MPO form above, a product of a small number of MPOs, or an efficiently simulable quantum circuit, one can construct the MPS state
$\ket{\Psi_w} = U_w \ket{s}$. Using the definition  of the oracle Eq.~(\ref{eq:multi_oracle}) and the fact that
$\bracket{w^\alpha}{s}=\frac{1}{\sqrt{2^n}}$, we obtain
\begin{align}
\ket{\Psi_w} = \ket{s} - \frac{2}{\sqrt{2^n}} \sum_{i=1}^{S} \ket{w_i} \label{eq:sum_of_products} \ .
\end{align}
This expression is explicitly the sum of $1+S$ product states, thus the state $\ket{\Psi_w} = U_w \ket{s}$ is exactly an MPS of bond dimension $\chi=1+S$.

The form of $\ket{\Psi_w}$ as a sum of product states in Eq.~(\ref{eq:sum_of_products}) immediately presents a classical strategy to extract the solution states $\{\ket{w_i}\}$ in a single step: one simply subtracts the state $\ket{s}$. Subtracting a product state such as $\ket{s}$ from an MPS is a straightforward operation with a cost scaling as $n \chi^3 \propto \log{N}$.
For example, in the case of $n=100$ qubits and $\chi=50$ the subtraction takes about 0.2 seconds.

It is important to note that this subtraction operation has no quantum equivalent. This can be seen easily with an
argument analogous to the no-cloning theorem: if there existed a unitary matrix that maps $\ket{\Psi}\otimes \ket{s}$
to $(\ket{\Psi}-\ket{s}) \otimes \ket{\Phi}$ for all $\ket{\Psi}$, then this matrix would map  $\ket{s}\otimes \ket{s}$
to the null vector which contradicts the assumption that the matrix is unitary. It follows that our algorithm
cannot be used as a ``classical preconditioner" for amplitude amplification \cite{Brassard}. See the associated discussion in
section~\ref{sec:advantage_theo}.

In summary the different steps of \QIGA are:
\begin{enumerate}
    \item Use classical simulation techniques to compute $\ket{\Psi_w} = U_w \ket{s}$ as an MPS of rank $\chi=1+S$
    \item Compute $\ket{\tilde{W}} = \ket{\Psi_w}-\ket{s}$ and normalize it to obtain $\ket{W}$, an MPS of rank $\chi=S$
    \item Sample from $\ket{W}$ to obtain the states $\ket{w^\alpha}$ with uniform probability, using the fact that perfect sampling of MPS can be performed with a cost $n \chi^2$ \cite{Ferris:2012,METTS}
\end{enumerate}
If $S$ is small enough, the states $\ket{w^\alpha}$ can also be fully enumerated.

One can modify the classical approach described above not only to sample individual solutions $w^\alpha$ but even to
count the number of solutions. To do so, one acts with $U_w$ on the \emph{unnormalized} state $\sum_b \ket{b}$. Then
the squared norm of the resulting state gives the number of solutions.

\subsection{Obtaining the MPS using tensor cross interpolation}

The problem is therefore reduced to the construction of the explicit MPS form of $\ket{\Psi_w} = U_w \ket{s}$ 
which is known to have a finite rank $\chi=1+S$.

Suppose for a specific bitstring $\ket{b}$ one is capable of classically calculating
the amplitude $\bracket{b}{\Psi_w}$. Such a simulation is known as a closed simulation and is much
easier \cite{Ayral} than a so-called open simulation which provides the full state $\ket{\Psi_w}$. We will comment in
section \ref{sec:advantage} on the practical limitations to these kind of simulations.

There has been recent progress in algorithms able to 
construct a MPS representation of the state $\ket{\Psi_w}$ in $O(\chi^2 n)$ calls to a 
routine that calculates $\bracket{b}{\Psi_w}$.
Here, we make use of tensor cross interpolation \cite{Oseledets:2010,Savostyanov:2011,Savostyanov:2014,Dolgov:2020,Nunez-Fernandez} 
following the implementation described in \cite{Nunez-Fernandez}. The advantage of tensor cross interpolation is that it is
agnostic to the details of the quantum circuit $U_w$ and only requires an external  classical subroutine that computes
$\bracket{b}{\Psi_w}$. The algorithm requests the value of $\bracket{b}{\Psi_w}$
for certain values of $b$ using an active learning algorithm. It follows that it is directly compatible with the most advanced methods that have been
developed to calculate amplitudes of quantum circuits (including those that leverage on the high level of 
parallelism available in supercomputers).

Before we can use tensor cross interpolation effectively, a small adjustment must be performed. A direct calculation
of $\bracket{b}{\Psi_w}$ provides
\begin{align}
\label{eq:amplitude1}
\bracket{b}{\Psi_w} = \frac{1}{2^{n/2}} \left[ 1 - 2 \sum_{\alpha=1}^S \delta_{b,w^\alpha} \right] \ \ .
\end{align}
For a random bitstring $b$, one has $\bracket{b}{\Psi_w} = 1/\sqrt{2^{n}}$ since it is exponentially unlikely that
$b$ matches one of the solutions $w^\alpha$. It follows that the tensor cross interpolation algorithm would fail
to reconstruct the MPS as its exploration of the $\bracket{b}{\Psi_w}$ function would have an exponentially low probability of finding the relevant 
part (second half of the right hand side of Eq.\eqref{eq:amplitude1}).  Another way to see the same problem is to write $\bracket{b}{\Psi_w}$ in terms of the calls to the function $f(b)$. It reads
\begin{align}
\label{eq:amplitude2}
\bracket{b}{\Psi_w} = \frac{1}{2^{n/2}} (-1)^{f(b)}
\end{align}
i.e. the amplitudes can be calculated in a single call to $f(b)$. Hence, if $\ket{\Psi_w}$ MPS could be reconstructed
from $O(n)=O(\log N)$ calls to $\bracket{b}{\Psi_w}$, it would mean that the original problem could be solved in 
$O(n)$ calls to the function $f(b)$ hence that NP-complete problems could be solved in polynomial time,
an unlikely situation.

To solve this issue, we turn to the $\ket{\pm}$ basis and calculate $\bracket{\beta}{\Psi_w}$ instead of
$\bracket{b}{\Psi_w}$ where $\ket{\beta}$ is a product of $\ket{\pm}$ states (e.g. $\ket{+-+-...-+}$). 
Denoting the binary representation of $\beta$ as
$\beta_0,\beta_1...\beta_n$ with $\beta_i=0$ for a state $\ket{+}$
and $\beta_i=1$ for a state $\ket{-}$, we find
\begin{align}
\label{eq:amplitude3}
\bracket{\beta}{\Psi_w} =  \delta_{\beta,0} - 
\frac{2}{2^{n}} \sum_{\alpha=1}^S (-1)^{\sum_{i=0}^{n-1} \beta_i w_i^\alpha}
\end{align}
This form is directly suitable for tensor cross interpolation since information about the solutions $w^\alpha$
is now present for any bitstring $\beta$. We emphasize that \QIGA itself knows nothing about the solution $w^\alpha$
and only uses the amplitudes $\bracket{\beta}{\Psi_w}$. 
Calculating these amplitudes
$\bracket{\beta}{\Psi_w}$ has the same complexity as calculating $\bracket{b}{\Psi_w}$ since the two quantum circuits only differ by a layer of Hadamard gates at the end. Similarly, when the MPS is known in the $\ket{\beta}$ basis,
it is simply a matter of applying local Hadamard gates to get it back in the $\ket{b}$ basis. We have checked in explicit numerical calculations that our implementation of tensor cross interpolation can reconstruct the MPS in
$O(n)$ calls to the $\bracket{\beta}{\Psi_w}$ subroutine up to at least $n=1000$.

In terms of call the the function $f(b)$, the amplitudes $\bracket{\beta}{\Psi_w}$ take the form,
\begin{align}
\label{eq:amplitude4}
\bracket{\beta}{\Psi_w} =  
\frac{1}{2^{n}}\sum_{b=0}^{2^n-1} (-1)^{f(b) +\sum_{i=0}^{n-1} b_i \beta_i} 
\end{align}
which takes $O(2^n)$ calls to the classical function, if one does not take advantage of its quantum circuit form. 
Hence we recover the expected $O(N)$ classical scaling to solve the search problem if one does not use insights about the function $f$. 
When using the quantum circuit to compute the oracle amplitudes, the \QIGA complexity will depend on the entanglement barrier present in a single application of the quantum oracle as illustrated in Fig.\ref{fig:entropy}.

We  emphasize  that the approach outlined above is only feasible for a closed, classical simulation of the oracle circuit; it cannot be attempted on a quantum computer. 
Indeed, a quantum computer only provides bitstrings $\beta$ distributed according to the probability 
$|\bracket{\beta}{\Psi_w}|^2$ but it does not provide the actual value $\bracket{\beta}{\Psi_w}$ (nor can one choose the value of $\beta$).

\section{Illustration with an explicit construction for the 3-SAT problem \label{sec:3SAT}}

To illustrate our quantum inspired GA with a practical application, we have implemented a simulation of the
oracle for the 3-SAT boolean satisfiability problem. 3-SAT is an NP-complete problem and finding fast, possibly heuristic, algorithms for solving it is the subject of active research, with applications including cryptanalysis \cite{Massacci:2000,Mironov:2006}, industrial operations research  \cite{ortools},  and computational biology \cite{corblin2007sat}. 

In a SAT problem, the function $f(b)$ is given by a set of $p$ clauses that must all be satisfied for $b$
to be a solution. In 3-SAT, each clause $\delta$ is constructed out of 3 variables 
$b_{i_\delta}$, $b_{j_\delta}$ and $b_{k_\delta}$ from the binary representation of $b$. $f(b)$ takes the form,
\begin{align}
f(b) = (\tilde b_{i_1} \lor \tilde b_{j_1} \lor \tilde  b_{k_1}) \land (\tilde b_{i_2} \lor \tilde b_{j_2} \lor \tilde b_{k_2})
\land \ldots \nonumber \\
 \ldots \land (\tilde b_{i_p} \lor \tilde b_{j_p} \lor  \tilde b_{k_p})
\end{align}
where  $\lor$ means logical ``or'',  $\land$ logical ``and'', and $\tilde b_a = b_a$ or $\tilde b_a = \lnot b_a$ (not $b_a$) depending on the clause. 

The problems we consider are defined by choosing the ratio $\alpha=p/n$ of clauses to variables (or qubits) to be fixed, usually between $4 < \alpha < 5$ since in this range the number of satisfying solutions $S$ becomes small. 
Otherwise the choice of which variables 
enter into each clause and whether a variable is negated is made with uniform probability.  
Below we will consider totally random SAT clauses in section \ref{sec:randomSAT} then clauses with quasi-one-dimensional 
structure in section \ref{sec:1dSAT}.

\subsection{Tensor Network SAT Approach \label{sec:sat_approach}}

To explicitly implement the Grover's oracle operator for 3-SAT and construct the post-oracle state $\ket{\Psi_w}$, first prepare the state of
the system to be
\begin{align}
\ket{+}_1 \ket{+}_2 \ket{+}_3 \cdots \ket{+}_n \ket{1}_A  = \ket{s} \ket{1}_A
\end{align}
where the extra qubit in the $\ket{1}_A$ state acts as an ancilla whose role is to record which states of the previous $n$ qubits
either satisfy ($\ket{1}_A$) or do not satisfy ($\ket{0}_A$) all of the SAT clauses applied so far.

Next, each SAT clause $C$ such as $C=(b_3 \lor \lnot b_{7} \lor b_{8})$ is mapped to an operator by noting
that there is only one bitstring which \emph{fails to satisfy} the clause. In the example above, this bitstring is $0_3, 1_7, 0_8$. 
Using this bitstring, one defines an operator
\begin{align}
O_C & = P^0_{3} \otimes P^1_{7} \otimes P^0_{8} \otimes P^0_{A} + (1 - P^0_{3} \otimes P^1_{7} \otimes P^0_{8}) \otimes 1_A \ .
\end{align}
which projects the ancilla qubit into the $\ket{0}_A$ state for any state containing the unsatisfying bitstring. 
Otherwise it leaves the ancilla unchanged.
Here $P^0_i = \ket{0}\bra{0}$ and $P^1_i = \ket{1}\bra{1}$ are projectors onto the $\ket{0}$ or $\ket{1}$ states for qubit $i$.

In our classical implementation, the operator $O_C$ can be applied in its above form using straightforward tensor network methods.
We used the approach of implementing each $O_C$ as an MPO and applying these MPOs to the quantum state represented as an MPS. 
As an MPO, $O_C$ has a rank $\chi=3$, which can be understood from the fact that when one expands all the terms it is the sum of three product operators \cite{McCulloch}.

After applying the $O_C$ operators for every SAT clause, the state of the system becomes 
\begin{align}
\frac{1}{\sqrt{2^{n}}} \sum_{i=1}^S \ket{w_i} \ket{1}_A + \frac{1}{\sqrt{2^{n}}}  \sum_{j=1}^{2^n-S} \ket{\tilde{w}_j} \ket{0}_A
\label{eq:sat_mps}
\end{align}
where the $\{w_i\}$ are the satisfying bitstrings and the $\{\tilde{w}_j\}$ are the unsatisfying ones. To convert this state
to a conventional Grover's post-oracle state Eq.~(\ref{eq:sum_of_products}), one can perform a post-selected, or forced, measurement of 
the ancilla qubit to be in the $\ket{-} = H\ket{1}$ state.  (Note that for a tensor network such a forced measurement always succeeds on the first try
and can be done by just acting with a single-qubit projection operator.) 
After dropping the now unentangled ancilla qubit, the
state will take the form of Eq.~(\ref{eq:sum_of_products}). If one is only interested in solving the Grover problem rather than constructing the post-oracle state, one simply projects the ancilla of Eq.\eqref{eq:sat_mps} onto the state $\ket{1}_A$. 

\subsection{Random SAT Experiments \label{sec:randomSAT}}

We have tested this classical oracle implementation on fully random SAT clauses (variables $b_{i_p}$ chosen by drawing $i_p$ randomly from $1,2,..,n$ and with each variable negated with probability $1/2$) for up to $n=40$ variables or qubits, using the
ITensor software \cite{itensor,itensor-r0.3} running on a single workstation with four Xeon 3.6 GHz processors and 256 Gb of RAM.
For all experiments we used a ratio of clauses to variables of $p/n = 4.2$.
The results shown in Table~\ref{sat_results} are for various experiments over a range of $n$ and different random instances for the same $n$ with different
numbers $S$ of satisfying bitstrings. We report both the maximum MPS rank $\chi_\text{max}$, which was the largest rank 
encountered during application of the $O_C$ operators, and the total time required to apply all of the operators and construct the post-oracle state.

\begin{table}
\begin{tabular}{| c c l l |}
\hline
n & S & $\chi_\text{max}$ & time  \\
\hline
30  &  4  &  467   & 21 s   \\
32   &  2  &  954  &  1.8 minutes  \\
34   &  48 &  1162 &  3.2 minutes \\
36   & 16  & 1994 &  8.3 minutes  \\
38   &  8  &  5867 &  1.6 hours \\
40   &  0  &  1402 &  4.2 minutes\\
40   &  28 &  2926  & 21 minutes  \\
40   &  161 & 5690 &  1.65 hours \\
40   &  174  & 10374  & 6.5 hours \\
\hline
\end{tabular}
\caption{Maximum MPS ranks $\chi_\text{max}$ and execution times to compute the post-oracle state corresponding to random 3-SAT problem
instances involving $n$ variables ($n$ qubits). The table also shows the number of satisfying assignments or bitstrings $S$ for each problem instance.
\label{sat_results}
}
\end{table}

After each post-oracle state was prepared, its quality was checked by projecting (post-selecting) the ancilla qubit into the state $\ket{1}_A$ then sampling 5000 bitstrings from the other $n$ qubits to verify that all samples satisfied the SAT clauses.
To count the number $S$ of satisfying bitstrings (\#SAT problem) we applied the MPOs $O_C$ to an \emph{unnormalized} state with each qubit (except the ancilla) initialized to $(\ket{0}+\ket{1})$. Afterward, we projected the ancilla into the $\ket{1}_A$ state and computed the norm of the resulting state which is equal to $S$. For smaller systems these counts were verified to be correct by checking with exact enumeration. The resulting counts $S$ are shown in the second column of Table~\ref{sat_results}, 

These results indicate the post-Grover's-oracle state can be prepared classically for typical 3-SAT instances for at least $n=40$ qubits 
on a single workstation. For problems of this size, the optimal number of iterations of Grover's algorithm 
would be \mbox{$r=823,500$} in contrast to the single application of the oracle used here.
The largest MPS rank encountered across the experiments we performed was $\chi=10,374$ which is a small fraction ($1\%$) of the 
maximum possible rank $2^{40/2}\approx 10^6$. The entanglement barrier in the random 3-SAT problem is not only relatively modest for finite problem sizes, but was typically observed to be lower for the case of fewer satisfying solutions $S$. 
Hence \QIGA appears to perform better on problems with few solutions. 

It is important to note that the approach above can be straightforwardly parallelized through a ``slicing'' approach, similar to other recent high-performance quantum circuit simulations \cite{chen2018classical, Gray2021hyper, Pan:2022}. Instead of initializing all the $n$ input qubits to the $\ket{+}$ state, a subset of $p$ of these qubits can be initialized to either the $\ket{0}$ or $\ket{1}$ states. By running $2^p$ separate calculations for each setting of these computational-basis qubits one can obtain the same final result by combining the solutions obtained from $2^p$ computers working with no communication overhead. When trying this in practice, we found that the total computational effort (sum of running times of each of the parallel computers) was comparable to the original (serial) running time, while the maximum time for any one computer was significantly less than the original time.
Because the oracle acts classically on the computational basis qubits, the maximum entanglement during the oracle application is generally much lower for each sliced input so that the parallel approach  results in a faster time to solution.

Note that our implementation of a SAT solver as a Grover oracle operator is nevertheless far slower than the most efficient classical SAT solving 
algorithms, some of which also happen to use tensor networks \cite{Kourtis2019} and can solve
typical $n=40$ instances of 3-SAT in under one second.


\subsection{Quasi-One-Dimensional SAT Experiments \label{sec:1dSAT}}

In this section, we design instances of the 3-SAT problem where the QiGA approach has \emph{provably linear scaling} in the number of 
qubits $n$, that is a logarithmic scaling with problem size $\log(N)$. This is in sharp contrast to the $2^n$ scaling of an unstructured classical problem. 
The goal of the construction
and associated experiments we perform below is to illustrate two points. First, it shows that there {\it are} classes of problems for which QiGA is always exponentially faster than GA. Second, the underlying structure that makes the problem easier for QiGA {\it need not} be known a priori: QiGA discovers this structure and takes advantage of it automatically.

We consider a quasi-1D case that involves grouping variables into blocks of size $B$ along a 1D path, with the first block $(1,2,\ldots,B)$, second block $(B+1,\ldots, 2B)$, etc. The SAT problem is then defined by two sets of SAT clauses required to be satisfied altogether:
\begin{enumerate}
\item $N_\text{intra}$ fully random SAT clauses where variables in each clause only act within each block
\item $L_\text{inter}$ layers of random SAT clauses where variables span across two neighboring blocks
\end{enumerate}
The cases we consider will allow $N_\text{intra}$ to be any size while $L_\text{inter}$ is fixed to a small value such as $L_\text{inter}= 1,2,3$.

The proof of linear scaling consists of bounding the cost of applying the constraints of clauses in sets (1) and (2) above separately. 
We will use a similar approach as in Section~\ref{sec:sat_approach} above, with the slight modification that we will 
project out any unsatisfying bitstrings for a clause $C_p =(b_{i_p} \lor b_{j_p} \lor b_{k_p})$ by acting with an operator
\begin{align}
O_{C_p} = (1- P^{b_{i_p}}_{i_p} P^{b_{j_p}}_{j_p} P^{b_{k_p}}_{k_p})
\end{align}
that sets the state containing the single bitstring not satisfying $C_p$ to zero. There is no ancilla qubit in this approach.
The process of applying the MPOs $O_{C_p}$ is depicted in Fig.~\ref{fig:1dSAT} and explained in detail below.


\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{1dSAT.pdf}
    \caption{Schematic of the process of applying the operators (MPOs) $O_{C_p}$ enforcing the SAT clauses defining the quasi-1D SAT problem.
     The qubits are organized into blocks of size $B$ and a number of random, intra-block SAT clauses are enforced which act only inside each block. 
     Then a fixed number of layers of inter-block clauses are enforced which act between neighboring blocks.}  \label{fig:1dSAT}
\end{figure}

Starting from the product superposition state
\begin{align}
\ket{s} = \ket{+}_1 \ket{+}_2 \ket{+}_3 \cdots \ket{+}_n 
\end{align}
and applying the operators for the set (1) of intra-block clauses, the cost scales as $(N_\text{intra}\ n \ 2^{ 3 B/2})$ in the worst case.
To see why, note that the state after applying the operators will be a product of MPS for each block, and the maximum bond dimension 
of an MPS with $B$ sites is $\chi = 2^{B/2}$..
Algorithms for applying operators to MPS of this size scale as $B \chi^{3} = B\, 2^{ 3 B/2}$. One has to apply each of the operators $O_{C_p}$ and there are $N_\text{intra}$ of these. Finally there are $n/B$ blocks. Multiplying each of these costs gives the above scaling. Thus the cost of enforcing the set (1) clauses scales only linearly with number of qubits $n$.

Next one enforces the $L_\text{inter}$ layers inter-block clauses in set (2). For each layer of such clauses, one can group the clauses into two sets, one acting across blocks 1 and 2, then 3 and 4, then 5 and 6, etc. and the next set acting across blocks 2 and 3, 4 and 5, 6 and 7, etc. The cost of applying the first layer scales at most as $n\ 2^{3 B/2}$ and doubles the bond dimension between blocks in the worst case, since the bond dimension of the $O_{C_p}$ MPOs is $2$. The cost of applying the next layer will then scale at most as $(n\ 8\ 2^{3 B/2})$, the extra factor of $8=2^3$ coming from the doubling of bond dimension due to the first layer. In general the cost of enforcing the $(2 L_\text{inter})$ layers of inter-block clauses will be 
$(n\ 2^{2 L_\text{inter}-1}\ 2^{3 B/2})$. 

Therefore the overall cost of enforcing all of the 1D 3-SAT clauses scales as
\begin{align}
(n\ N_\text{intra}\ \ 2^{ 3 B/2}) + (n\ 2^{2 L_\text{inter}-1} 2^{3 B/2})
\end{align}
which is manifestly linear in $n$, assuming $B$ and $L_\text{inter}$ are held constant, and that $N_\text{intra}$ depends only on $B$ (is chosen proportional to $B$).

\begin{table}
\begin{tabular}{| c c l l |}
\hline
n & S & $\chi_\text{max}$ & time  \\
\hline
40   &  99  &  21 &  0.973s\\
40   &  50  &  22 &  0.973s\\
40   &  108  &  16 &  0.989s\\
40   &  0 &  19 &  0.985s\\
60   &  4530 & 22 & 2.00s \\
60   &  0 & 19 & 1.98s \\
60   &  17920 & 19 & 1.96s \\
\hline
\end{tabular}
\caption{Maximum MPS ranks $\chi_\text{max}$ and execution times to compute the post-oracle state corresponding to blocked 1D 3-SAT problem
instances involving $n$ variables ($n$ qubits). In all cases the block size was chosen as $B=10$ and $N_\text{intra}=37$ random clauses were applied within each block while $N_\text{inter}=2$ layers of clauses were applied between neighboring blocks.
The table also shows the number of satisfying assignments or bitstrings $S$ for each problem instance.
\label{1d_sat_results}
}
\end{table}

In practice, when implementing the above method on test systems of $n=40$ qubits, using a fixed block size of $B=10$, taking $L_\text{inter}=2$ and choosing \mbox{$N_\text{intra} = 3.7 \cdot B$}, we find that all the clauses can be enforced in a running time of under 1 second. The maximum MPS bond dimension  observed is $\chi=22$. Systems with $n=60$ qubits are just as easy for the same block size and number of clauses per block, with similar maximum bond dimension and running times just under 2 seconds. See Table~\ref{1d_sat_results} for detailed results.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{noise_n_30.pdf}
    \includegraphics[width=0.95\columnwidth]{pr_Lambda.pdf}
    \caption{(a) Probability of success versus number of iterations of Grover's algorithm for $n=30$ qubits and different levels of noise $\lambda$.
    Also shown are theoretical fits to the cases $\lambda=10^{-5}, 10^{-4}$.
    For $n=30$ the theoretically optimal number of iterations is $r=25,736$. The final success probability 
    reaches a reasonable value for noise $\lambda < 5\times 10^{-5}$, but once the noise becomes as large as $\lambda = 10^{4}$,
    the success probability reaches a maximum of only 0.04 at the 10,000th iteration then falls to about 0.006 by the 
    final iteration.
    (b) Final probability of success after the optimal number of iterations $r$ as a function of total noise $\Lambda=\lambda r$ where $\lambda$
    is the amount of depolarizing noise per iteration. }  \label{fig:noise_plot}
\end{figure}


\section{\label{sec:scaling} Scaling of Errors in Grover's Algorithm}

We now turn to the second part of this work where we discuss the possibility of quantum advantage for GA.
Before we can do that, we need to study the sensitivity of GA to the presence of imperfections such as gate errors
or decoherence. There has been some previous literature on this subject \cite{Koch}.
The advantage of our tensor network approach is the capability to study relatively large system from which we can extract the actual scaling of the errors in GA.

At the end of GA, the quantum computer is supposed to be  in the state $\ket{w}$ so that upon measuring the qubits one finds the solution $w$ almost certainly (up to negligible exponentially small $1/N$ corrections). However, due to imperfection in the gates or environmental coupling and decoherence 
the system will be in some other state
 instead, described by the density matrix $\rho$. The probability to get the correct  output $w$ when one performs the measurement of the qubits is $F = \bra{w}\rho\ket{w}$. $F$ is known as the {\it fidelity} of the calculation which 
 matches the success probability of the algorithm for GA. 
Generically, the fidelity decays exponentially with the number of gates applied in the calculation as well as with any idle time (decoherence). This exponential behavior has been observed ubiquitously in experiments and was established on a large scale in the seminal ``quantum supremacy'' experiment of Google \cite{Arute2019}. 
Denoting by $\epsilon$ the typical error per gate and $N_g$ the total number of gates used,
we therefore expect the decay rate to be $F \approx e^{-\epsilon N_g}$ with $N_g = r (N_o + N_d)$
where $N_o$ (resp. $N_d$) is the number of gates in the quantum circuit of the oracle (resp. diffusion operator).
In other words, the success probability of GA is expected to follow a
rather unfavorable {\it double exponential} decay with $n$,
\begin{align}
\label{eq:doubleexponential}
F \approx \exp\big[-\frac{\pi\epsilon}{4} (\sqrt{2})^n\, (N_o + N_d)\big].
\end{align}
  


To substantiate the scaling of GA with noise and number of qubits, we have performed classical simulations 
using an MPO state representation capable of representing mixed states. 
For these simulations we also implement the oracle and diffusion operators as MPO tensor
networks as described in Section~\ref{sec:grover_mpo}. As discussed earlier, without noise the MPS bond dimension $\chi$ of the state in between
the oracle and diffusion steps (so at every step of these simulations) is $\chi=2$, leading to an MPO-mixed-state representation of only $\chi=4$ 
so that each step can be performed rather quickly and it is possible to run the whole algorithm up to about $n=30$ qubits in under an hour. 
Adding noise to the simulations only modifies the bond dimension of the state very slightly and observed bond dimensions always remain less
than $\chi \lesssim 10$. 

To model the effects of noise, we apply a depolarizing noise channel $\Delta_\lambda(\rho) = (1-\lambda) \rho + \frac{\lambda}{2^n} I$ 
in between Grover iterations, that is once per iteration. 
By not including any noise during the application of the oracle or the diffuser our simulations 
are being very generous in favor of the success of GA. The noise per iteration $\lambda$ relates simply to the noise per gate $\lambda = \epsilon (N_o + N_d)$.

The results of our simulations for $n=30$ qubits and various levels of noise $\lambda$ are shown in Fig.~\ref{fig:noise_plot}(a). 
As long as the noise $\lambda \lesssim 5\times 10^{-5}$ the final probability of success reaches a reasonable value after
the optimal number of iterations, which for $n=30$ is $r = 25,736$. 
However, the probability of success after $r$ iterations falls below $1\%$ once the noise becomes larger than about $10^{-4}$. 
Note that non-zero noise leads to a maximum in the success probability at an earlier iteration $q^* < r$. We analyze the height and location 
of this maximum further below. 

Due to the transparent nature of GA and the depolarizing noise model, one can actually work out an exact result for the state 
after $q$ steps of the algorithm. By a recursive procedure, one finds:
\begin{align}
\rho_q = (1-\lambda)^{q} \ket{\Psi_q} \bra{\Psi_q} +  (1-(1-\lambda)^{q}) I \frac{1}{2^n}
\end{align}
where $\ket{\Psi_q}$ is the ideal pure state after $q$ noiseless Grover iterations. 
Using a well-known result for the probability of success of the noiseless GA after $q$ iterations \cite{Zhang}
\begin{align}
|\bracket{w}{\Psi_q}|^2 & = \sin^2((2q+1) \theta) \\
\theta & = \arcsin\Big(\frac{1}{\sqrt{2^n}}\Big)
\end{align}
it follows that the probability of success after iteration $q$ is given by
\begin{align}
p_q =  \bra{w} \rho_q \ket{w} = (1-\lambda)^{q} \sin^2((2q+1) \theta) \ \ .
\end{align}
Since $q\gg 1$, ignoring exponentially small corrections, we have:
\begin{align}
\label{eq:opt_prob}
p_q =  e^{-\lambda q} \sin^2(2q \theta) \ \ .
\end{align}
We show in Fig.~\ref{fig:noise_plot} that this fit works well, though there is a slight disagreement which 
we attribute not to the fit, but to a loss of precision in the early iterations of the numerical simulations
due to the use of double-precision floating point numbers and the very small signal of GA through the early 
iterations \cite{SaiToh}.

Interestingly, the form of $p_q$ Eq.~(\ref{eq:opt_prob}) means that if one defines the noise level in terms of
a parameter $\Lambda$ such that $\lambda = \Lambda/r$ then the final success probability is
\begin{align}
p_r = e^{-\Lambda}
\end{align}
regardless of the number of qubits, using the fact that $\sin^2(2r\theta)\approx 1$ up to exponentially small corrections. 
One can interpret $\Lambda=\lambda \cdot r$ as the total accumulated noise throughout a complete run of GA.
In Fig.~\ref{fig:noise_plot} we show how the 
final success probability $p_r$ observed  in noisy simulations fits very well to $e^{-\Lambda}$.



In the presence of large noise, due to a maximum that develops in the fidelity curve, it is advantageous for GA to stop the iteration
at a certain smaller value of $q=q^*$. An explicit calculation of the optimum of Eq.\eqref{eq:opt_prob}
provides
\begin{align}
\tan[2(r-q^*)\theta] = \frac{\Lambda}{\pi}
\end{align}
from which we arrive at the optimum success probability,
\begin{align}
\label{eq:opt_prob2}
p_{\rm success} =  \frac{e^{\frac{2\Lambda}{\pi}\arctan(\frac{\Lambda}{\pi})}}{1+(\Lambda/\pi)^2} 
e^{-\Lambda}. 
\end{align}
This formula behaves as $p_{\rm success} \approx e^{-\Lambda}$ for small $\Lambda$ (approaching 1.0 as $\Lambda \rightarrow 0$) 
and behaves as $p_{\rm success} \approx e^{-2}\cdot(\pi/\Lambda)^2$ for large $\Lambda$. 

Because $p_{\rm success}$ depends only on $\Lambda$,
an important conclusion is that for the GA success probability to scale successfully to large values of $n$, the total noise
$\Lambda$ must be held independent of $n$. The noise per iteration $\lambda$ must therefore scale as 
\begin{align}
\lambda = \frac{\Lambda}{r} \propto \frac{\Lambda}{(\sqrt{2})^n}
\end{align}
showing the noise per iteration must be reduced exponentially with $n$. 

\section{\label{sec:advantage} On the possibility of quantum advantage in Grover's algorithm}

There are two kinds of quantum advantages. The theoretical one, i.e. the possibility that in an idealized world
a perfect quantum computer could perform parametrically better than a classical one for a given task. And the practical one, i.e. the possibillty that an actual device does something useful faster than a classical machine.

With respect to the first question our \QIGA merely reverses the charge of the proof: we show that there is no theoretical
quantum advantage unless proven otherwise and quantum advantage has to be decided in a case-by-case manner. 

With respect to the second kind of quantum advantage involving an actual machine, 
the existence of \QIGA and the demands for implementing GA 
place drastic bounds on the hardware needed which we will argue are simply out of reach.
When discussing hardware, there is long list of specifications that we could consider including heat management, control electronics, classical data bandwidth for e.g. syndrom analysis,
device variability, power consumption...Here we limit ourselves to discussing three aspects: the total qubit count, the error budget per gate and the time to solution.



\subsection{Absence of generic theoretical quantum advantage}
\label{sec:advantage_theo}

\QIGA implies that if the quantum circuit for the oracle can be simulated classically, then 
$O(n)$ such calculations are sufficient to solve the problem while a quantum computer 
needs $O(2^{n/2})$ calls to the oracle. An immediate consequence is that no theoretical quantum advantage can be
claimed generically, i.e. irrespectively of the nature of the underlying quantum circuit for the oracle. 
 This is an important point to make with respect to the large literature which assumes, implicitly or explicitly, the existence of a quantum speed-up every time a GA replaces its classical counterpart \cite{Montanaro:2016}.

If the complexity for calculating one amplitude of the oracle is smaller than $(\sqrt{2})^n$, then \QIGA is parametrically faster than its quantum counterpart. Constructing an oracle whose classical simulation is provably harder than $(\sqrt{2})^n$ can most likely be done. Indeed, in the large depth limit classical simulations of quantum circuits have a generic complexity of $2^n$. Yet, we are not aware of such a construction for an actual oracle (i.e. a circuit whose output amplitudes are only $\pm 1$). Conversely, there are clear cases where classical algorithms win. For instance, if the oracle can be simulated with a fixed depth, then the problem can be solved in linear time using MPS technology while GA would require an exponential time. The Quasi-1D SAT is another example.

We emphasize that our work does not contradict previous work that formally proves that the quantum speed-up of GA is optimal \cite{Bennett}. While the proof is certainly valid technically, its usefulness for a given problem requires the best known classical strategy to scale as $2^n$ (i.e.~worst-case classical scaling) for that problem. But for any specific problem, if Grover's can be applied there must exist an explicit circuit for the oracle. So there is always at least some structure to the problem: the structure of the oracle circuit. One can always try to simulate this oracle circuit by applying it to a tensor network. Until such a ``simulability check'' has been done, the applicability of the proof remains in doubt because the problem might not satisfy the proof's assumptions. In other words, one must be very careful with using the concept of  an ``oracle'' which, however appealing theoretically, might not be relevant to practical applications.

A corollary of the existence of \QIGA is that the quantum circuit associated to the oracle of an NP complete problem 
must be exponentially difficult to simulate in the general case, i.e. presents an exponentially high entanglement barrier. Indeed, otherwise, one could simulate it in polynomial time which would prove $P=NP$ a statement widely believed to be untrue. 
Hence \QIGA provides a direct connection between classical complexity theory and the entanglement level of a quantum circuit.


Lastly, we would like to discuss the relation of this work to amplitude amplification \cite{Brassard}, a direct generalisation of GA. In some cases, there exist fast classical heuristic algorithms that can solve NP-hard problems faster than GA, though still scaling exponentially.
For instance, there exist very fast classical algorithms for the 3-SAT problem which we considered earlier in our  \QIGA  demonstrations
(incidentally, among the best are tensor network approaches \cite{Kourtis2019}). 
Amplitude amplification is claimed to recover the quadratic Grover speedup over such fast classical algorithms 
by combining these algorithms with a slight modification of GA. 
Below, we show that \QIGA applies in this context as well.
We again argue that the question of whether the oracle can be simulated classically is 
a crucial one.

A classical heuristic algorithm takes the form of a function $b=G(r)$ that proposes
a bitstring $b$ as a possible solution. Here the variable $r$ captures the probabilistic nature of the heuristic, e.g. it can be the seed of the pseudo random number generator used in the heuristic. In a good heuristic, $r$ need to span a much smaller number of values than $b$. For instance, in the context of 3-SAT, the Schoning algorithm \cite{Schoning} solves 3-SAT (with a complexity $(4/3)^n$) by an iterative process over bitstrings where at each stage an unsatisfied clause is chosen randomly and then a bit of the clause is flipped in order for the clause to become satisfied. 
To transform this heuristic into a quantum algorithm, amplitude amplification does not search for the  bitstring $b$ that satisfies $f(b)=1$ but instead uses GA to search for the value of $r$ that satisfies
$f(G(r))=1$ (see the discussion around Theorem 6 of  \cite{Brassard}), i.e. one needs to use GA with the oracle $U_w \ket{r} = (-1)^{f(G(r))} \ket{r}$. It follows that our \QIGA approach applies directly to the amplitude amplification of these heuristics: one only needs to modify the oracle in the same way it would be modified for the quantum computer. Hence, the question of the existence of a theoretical quantum advantage translates again into the one of an entanglement barrier, here of the new oracle $f(G(r))$. Anticipating on the discussion of the next section, these heuristics make classical problems computable up to very large values of $n$. For instance for 3-SAT, problems with $n\sim 10,000$ are well within range. It follows that the entrance level for GA for these problems would be much higher than for the problems for which no heuristic is available. As we shall see in the estimates below, this would translate into inaccessible number of required qubits and astronomically large times to solution.




\subsection{Absence of practical quantum advantage on a noisy quantum computer}

We now turn to the question of a practical advantage and provide some estimates about the specifications
a quantum hardware must fullfill to solve a task better than what one can do classically. We start by estimating the total gate count $N_g$. The diffusion operator typically requires $2n$ Toffoli gates and the oracle at least the same
(a simpler oracle would likely be rather easy to solve classically). Each Toffoli gate must be decomposed into 15 gates (including $6$ Control-NOT and $7$ T gates). We arrive at a total gate count for GA of $N_g \ge 60\, n\, 2^{n/2}$ assuming perfect connectivity (i.e. that the two-qubit gates can be applied between any pairs of qubits). In order for the final success probability to be of order unity (here we choose $p_{\rm success}=1/2$) we need $\Lambda \approx 0.8$
which translates into $\epsilon \le 1/(60\, n\, 2^{n/2})$.

It follows that in order to apply GA on just $5$ qubits, one needs $\epsilon \le 5.10^{-4}$ which is much better than any existing hardware. Indeed, the experimental value of the error per gate $\epsilon$ has been mostly stable in the last ten years, typically around $\epsilon\approx 0.01$ for the state of the art \cite{Arute2019} and slightly better for some systems with few  ($<10$) qubits. Previous applications of GA for a few qubits used a much smaller gate count in order to retain a large enough fidelity. This is possible for contrived examples where one uses Eq.~\eqref{eq:oracle_action} instead
of Eq.~\eqref{eq:oracle_action_basic} i.e. one explicitly uses information about the solution $w$ instead of performing the classical logic of computing $f(b)$. While this is perfectly acceptable for proof of principle experiments, this does not correspond to the full application of GA to actually solve a problem.
Going to $n=40$ which we can easily solve on a desktop computer using \QIGA leads to $\epsilon \le 4.10^{-10}$. Manipulating tens of qubits with precisions better than one part in a billion for a total of billions of gates is in our view completely unrealistic. Using the best available 
algorithms available on supercomputers (see \cite{Ayral} for a recent review) to perform \QIGA  we estimate that $n=80$ problems are
accessible on supercomputers (most probably $n\ge 100$). Solving such a problem would require $\epsilon \le 2.10^{-16}$
as well as a time to solution (assuming very fast $10$ ns gates) of more than one year of uninterrupted running time. 

\subsection{Absence of practical quantum advantage on a fault tolerant quantum computer}
 
The problem of limited qubit fidelity can in principle be solved by quantum error correction which should allow
to lower the effective error level per gate $\epsilon_L$ by constructing robust logical qubits out of several physical qubits.
However, quantum error correction trades a better effective $\epsilon_L$ with a much higher qubit count $n_L$
as well as a much higher time to solution since logical qubits require many physical qubit operations in order to 
make a single logical one. Hence, we can already anticipate that quantum error correction is unlikely to help given the above already high estimate of the time to solution.

To make quantitative estimates, we focus on the example of the surface code, one of the most robust QEC code with a clear path to implementation \cite{Fowler}. We ignore non-correctable errors \cite{Waintal2019} for simplicity.
We also ignore the so-called syndrome analysis although this would be quite problematic in practice. In the surface code, the error $\epsilon_{\rm L}$ per logical gate on a logical qubit  scales as
\begin{align}
\epsilon_{\rm L} \propto \epsilon_{\rm ph}
\left(
\frac{\epsilon_{\rm ph}}{\epsilon_{\rm th}}
\right)^{\sqrt{N_c}/2}
\end{align}
where $N_c$ is the number of physical qubit per logical qubit,
$\epsilon_{\rm ph}$ is the error per gate on the physical qubits and
$\epsilon_{\rm th}$ is the threshold of the code, around $\epsilon_{\rm th}\approx 0.01$ for the surface code \cite{Fowler}. Ignoring logarithmic corrections, we immediately observe that the exponentially large running time which implies that one must have $\epsilon_{\rm L} (\sqrt{2})^n \le 1$ translates into 
\begin{align}
N_c \propto n^2.
\end{align}
i.e. the number of physical qubits per logical one increases quadratically with $n$
in sharp contrast to e.g. Shor's algorithm where $N_c \propto (\log n)^2$ has a weak logarithmic increase. 
We can already surmise that, since the estimates for algorithms with exponential speed-up already involve millions, or more realistically billions, of very high quality physical qubits to address $n=100$, the added complexity in Grover would move these estimates far beyond anything reasonable \cite{Reiher}.

To continue, we need to modify our gate count estimate and consider separately the Control-NOT gates and the T gates. 
In the surface code, Control-NOT are performed through ``braiding'', a process that requires making a loop of one qubit around the other which costs an extra $\sqrt{n}\sqrt{N_c}$ factor. Also, the time scale is no longer limited by the time it takes to execute one gate but by the time to make a projective measurement of the so-called stabilizers. For instance in superconducting transmon qubit, the former can be as low as $10$ ns while the later takes around $1 \mu$s. 
Systems based on atomic physics such as cold ions are typically much slower. Also, 
the error per gate $\epsilon$ is likely to be limited by the measurement errors that are typically much worst than the error per gate. Considering only  Control-NOT operations we arrive at a time to solution of $10^5$ years for $n=80$.
Applying T gates on a surface code requires the availability of special states that can be obtained through ``magic state distillation", a lengthy process that involve several logical qubits for each T gate that one wants to apply. In order for the already rather large time to solution not to be slowed down by the T gates, one would need to incorporate a large number of ``T gate factories" on the quantum chip thereby raising the total qubit count dramatically. We need not to elaborate further, it should be clear at this stage that the fate of quantum error correction for the implementation of GA is extremely doubtful.

\section{Conclusion}

Grover's algorithm is an elegant intellectual construction. Unfortunately our analysis indicates that it will remain so for the foreseeable future.

We have constructed a quantum inspired version of Grover's algorithm that can solve quantum problem in a single call to the oracle, requiring exponentially fewer steps than Grover's algorithm, provided one is able to compute individual amplitudes of the oracle. We have also
provided specific cases where this ``classical advantage'' can be realized.

Since our classical algorithm is fully general, it provides a clear benchmark against which one can evaluate the potential speed-up of Grover algorithm both theoretically and practically. While we cannot exclude a \emph{theoretical} quantum scaling advantage for every problem, assuming an idealized quantum implementation, we estimate that practical quantum implementations will be associated with astronomically large computing times. On the other hand, problems for which a quantum implementation may seem necessary could have hidden structure revealed by our classical algorithm in the form of low entanglement barriers on the way to a solution. And even if the entanglement barrier does grow with problem size and produces an exponential scaling, it remains possible this scaling could be better than $2^{n/2}$ for specific classes of problems.

A work which has some overlap with ours is the proposal of Chamon and Mucciolo \cite{Chamon} to use MPS tensor networks as a classical computing platform for solving Grover's algorithm problems. An important technical difference, however, is that their algorithm depends on computing and comparing exponentially small numbers, which could become challenging when working with fixed precision floating-point. Also, while their work discusses the growth of entanglement in Grover oracles, only worst-case bounds are stated.

A separate line of work based on the problem size needed for a quantum/classical scaling crossover 
has also cast doubt on the usefulness of Grover's algorithm since it only offers at best a quadratic speedup, while 
the estimated speeds of error-corrected quantum operations are expected to remain much slower than classical operations
 \cite{Babbush:2021,TroyerDisentangling}. This is an entirely distinct argument from ours which further casts doubt on the usefulness of Grover's 
 algorithm as a practical tool.

Beyond the above rather negative results, our quantum inspired algorithm 
may also lead to more positive results.
For instance, while we have focused on exact calculations of the the quantum circuit amplitudes, 
an interesting possibility would be to construct the MPS from {\it approximate} calculations of 
the amplitudes $\bracket{\beta}{\Psi_w}$ using standard MPS compression techniques. It is unclear if the resulting MPS would provide an efficient heuristic for solving the Grover problem.

\begin{acknowledgments}
EMS acknowledges insightful discussions with Jielun Chris Chen, Matthew Fishman, Roger Mong, Vadim Oganesyan, Nicola Pancotti, Olivier Parcollet, Dries Sels, Simon Trebst, and Steve White. The Flatiron Institute is a division of the Simons Foundation. XW acknowledges funding from the French ANR QPEG and the Plan France 2030 ANR-22-PETQ-0007 ``EPIQ''. 
\end{acknowledgments}

% The \nocite command causes all entries in a bibliography to be printed out
% whether or not they are actually referenced in the text. This is appropriate
% for the sample file to show the different styles of references, but authors
% most likely will not want to use it.
\nocite{*}

\bibliography{main}


\appendix

\section{Quantum Circuits for Oracle and Diffusion Operators \label{appendix:circuit}}
We discuss here some details of the quantum circuit used in the \emph{simulations} of GA,
not to be confused with the \QIGA calculations.

For obtaining the entanglement entropy plot Fig.~\ref{fig:entropy}, which shows the entanglement not only between Grover iterations but also 
inside of the  substeps of the oracle and diffusion circuits, we used the circuits shown in the figure below. These circuits are for the case where
the target bitstring $w$ is known. (The target for the diffusion operator is always known, since it can be implemented as the oracle which targets
$|000...0\rangle$ pre- and post-processed by a Hadamard gate on each qubit.) The circuit pattern below uses at most three-qubit gates. 
This is in contrast to the implementation sometimes seen where the oracle is implemented
by a ``multi-controlled'' gate, which is equivalent to our observation in the main text that the oracle can always in principle be implemented
by a rank $\chi=2$ MPO (for the case of a single targeted bitstring $w$).

For the specific case of four qubits and a target bitstring $w=1011$, the oracle circuit pattern used for the Fig.~\ref{fig:entropy} simulation was:
\begin{center}
\includegraphics[width=0.7\columnwidth]{oracle_circuit.pdf}
\end{center}

For Grover's algorithm on $n$ qubits, the operator above is initialized by preparing $n+1$ additional ancilla qubits, $n$ in the $\ket{0}$ state and the $n+1$ qubit in the $\ket{-} = H\ket{1}$ state. By using Toffoli gates acting on the upper and lower registers, the ancillas are flipped to indicate that each qubit of the target bitstring has been found (upper control) and that all previous bits have been found (lower control). If so, the next ancilla qubit is flipped to 1. 

The notation of the white circle for the upper control of the second Toffoli gate stands for an ``anti-control'' meaning the gate acts only if that qubit is $\ket{0}$. This kind of control can be viewed as shorthand for:
\begin{center}
\includegraphics[width=0.5\columnwidth]{controls.pdf}
\end{center}
that is, NOT gates on either side of a regular control.

At the center of the circuit, if the $n^\text{th}$ ancilla qubit is 1, then the $n+1$ ancilla is acted on by a NOT gate which results in a minus sign (``phase kickback mechanism'')
for the amplitude of the state with the target bitstring in the upper register. Lastly, the Toffoli gates are acted in reverse order to ``uncompute'' the ancilla register, restoring all of the ancillas to their initial product state. It is easy to check by inspection that applying the above circuit
to $\ket{b}\ket{0000-}_A$ leads to $\pm \ket{b}\ket{0000-}_A$ depending on wither $b=w$ or not.
\end{document}
%
% ****** End of file apssamp.tex ******
