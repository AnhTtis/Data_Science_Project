@misc{mueller2018newlisp,
  title={NewLisp},
  author={Mueller, Lutz},
  year={2018}
}

@article{10.1145/3547646,
author = {Westrick, Sam and Arora, Jatin and Acar, Umut A.},
title = {Entanglement Detection with Near-Zero Cost},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547646},
doi = {10.1145/3547646},
abstract = {Recent research on parallel functional programming has culminated in a provably efficient (in work and space) parallel memory manager, which has been incorporated into the MPL (MaPLe) compiler for Parallel ML and shown to deliver practical efficiency and scalability. The memory manager exploits a property of parallel programs called disentanglement, which restricts computations from accessing concurrently allocated objects. Disentanglement is closely related to race-freedom, but subtly differs from it. Unlike race-freedom, however, no known techniques exists for ensuring disentanglement, leaving the task entirely to the programmer. This is a challenging task, because it requires reasoning about low-level memory operations (e.g., allocations and accesses), which is especially difficult in functional languages. In this paper, we present techniques for detecting entanglement dynamically, while the program is running. We first present a dynamic semantics for a functional language with references that checks for entanglement by consulting parallel and sequential dependency relations in the program. Notably, the semantics requires checks for mutable objects only. We prove the soundness of the dynamic semantics and present several techniques for realizing it efficiently, in particular by pruning away a large number of entanglement checks. We also provide bounds on the work and space of our techniques. We show that the entanglement detection techniques are practical by implementing them in the MPL compiler for Parallel ML. Considering a variety of benchmarks, we present an evaluation and measure time and space overheads of less than 5% on average with up to 72 cores. These results show that entanglement detection has negligible cost and can therefore remain deployed with little or no impact on efficiency, scalability, and space.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {115},
numpages = {32},
keywords = {disentanglement, parallelism, functional, memory management}
}

  

@inproceedings{elphick2003partial,
  title={Partial evaluation of MATLAB},
  author={Elphick, Daniel and Leuschel, Michael and Cox, Simon},
  booktitle={International Conference on Generative Programming and Component Engineering},
  pages={344--363},
  year={2003},
  organization={Springer}
}

@inproceedings{10.1145/3062341.3062381,
author = {W\"{u}rthinger, Thomas and Wimmer, Christian and Humer, Christian and W\"{o}\ss{}, Andreas and Stadler, Lukas and Seaton, Chris and Duboscq, Gilles and Simon, Doug and Grimmer, Matthias},
title = {Practical Partial Evaluation for High-Performance Dynamic Language Runtimes},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062381},
doi = {10.1145/3062341.3062381},
abstract = {Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system. This violates the principle to not repeat yourself. In contrast, we define languages solely by writing an interpreter. The interpreter performs specializations, e.g., augments the interpreted program with type information and profiling information. Compiled code is derived automatically using partial evaluation while incorporating these specializations. This makes partial evaluation practical in the context of dynamic languages: It reduces the size of the compiled code while still compiling all parts of an operation that are relevant for a particular program. When a speculation fails, execution transfers back to the interpreter, the program re-specializes in the interpreter, and later partial evaluation again transforms the new state of the interpreter to compiled code. We evaluate our approach by comparing our implementations of JavaScript, Ruby, and R with best-in-class specialized production implementations. Our general-purpose compilation system is competitive with production systems even when they have been heavily optimized for the one language they support. For our set of benchmarks, our speedup relative to the V8 JavaScript VM is 0.83x, relative to JRuby is 3.8x, and relative to GNU R is 5x.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {662–676},
numpages = {15},
keywords = {virtual machine, partial evaluation, optimization, language implementation, dynamic languages},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{berlin1990compiling,
  title={Compiling scientific code using partial evaluation},
  author={Berlin, Andrew and Weise, Daniel},
  journal={Computer},
  volume={23},
  number={12},
  pages={25--37},
  year={1990},
  publisher={IEEE}
}


@inproceedings{berlin1990partial,
  title={Partial evaluation applied to numerical computation},
  author={Berlin, Andrew},
  booktitle={Proceedings of the 1990 ACM Conference on LISP and Functional Programming},
  pages={139--150},
  year={1990}
}


@article{futamura1971partial,
  title={Partial evaluation of computation process-an approach to a compiler-compiler},
  author={Futamura, Yoshihiko},
  journal={Systems, computers, controls},
  volume={25},
  pages={45--50},
  year={1971}
}


@inproceedings{10.1145/158511.158707,
author = {Consel, Charles and Danvy, Olivier},
title = {Tutorial Notes on Partial Evaluation},
year = {1993},
isbn = {0897915607},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/158511.158707},
doi = {10.1145/158511.158707},
abstract = {The last years have witnessed a flurry of new results in the area of partial evaluation. These tutorial notes survey the field and present a critical assessment of the state of the art.},
booktitle = {Proceedings of the 20th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {493–501},
numpages = {9},
location = {Charleston, South Carolina, USA},
series = {POPL '93}
}

  



  @article{10.1145/243439.243447,
author = {Jones, Neil D.},
title = {An Introduction to Partial Evaluation},
year = {1996},
issue_date = {Sept. 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/243439.243447},
doi = {10.1145/243439.243447},
abstract = {Partial evaluation provides a unifying paradigm for a broad spectrum of work in program optimization compiling interpretation and the generation of automatic program generators [Bj\o{}rner et al. 1987; Ershov 1992; and Jones et al. 1993]. It is a program optimization technique, perhaps better called program specialization, closely related to but different from J\o{}rring and Scherlis' staging transformations [1986]. It emphasizes, in comparison with Burstall and Darlington [1977] and J\o{}rring and Scherlis [1986] and other program transformation work, full automation and the generation of program generators as well as transforming single programs. Much partial evaluation work to date has concerned automatic compiler generation from an interpretive definition of programming language, but it also has important applications to scientific computing, logic programming, metaprogramming, and expert systems; some pointers are given later.},
journal = {ACM Comput. Surv.},
month = {sep},
pages = {480–503},
numpages = {24},
keywords = {partial evaluation, program specialization, compiler generators, compilers, interpreters}
}

  



@article{10.1145/3140587.3062381,
author = {W\"{u}rthinger, Thomas and Wimmer, Christian and Humer, Christian and W\"{o}\ss{}, Andreas and Stadler, Lukas and Seaton, Chris and Duboscq, Gilles and Simon, Doug and Grimmer, Matthias},
title = {Practical Partial Evaluation for High-Performance Dynamic Language Runtimes},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062381},
doi = {10.1145/3140587.3062381},
abstract = {Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system. This violates the principle to not repeat yourself. In contrast, we define languages solely by writing an interpreter. The interpreter performs specializations, e.g., augments the interpreted program with type information and profiling information. Compiled code is derived automatically using partial evaluation while incorporating these specializations. This makes partial evaluation practical in the context of dynamic languages: It reduces the size of the compiled code while still compiling all parts of an operation that are relevant for a particular program. When a speculation fails, execution transfers back to the interpreter, the program re-specializes in the interpreter, and later partial evaluation again transforms the new state of the interpreter to compiled code. We evaluate our approach by comparing our implementations of JavaScript, Ruby, and R with best-in-class specialized production implementations. Our general-purpose compilation system is competitive with production systems even when they have been heavily optimized for the one language they support. For our set of benchmarks, our speedup relative to the V8 JavaScript VM is 0.83x, relative to JRuby is 3.8x, and relative to GNU R is 5x.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {662–676},
numpages = {15},
keywords = {virtual machine, dynamic languages, optimization, partial evaluation, language implementation}
}

  



@inproceedings{10.1145/582153.582181,
author = {Komorowski, H. Jan},
title = {Partial Evaluation as a Means for Inferencing Data Structures in an Applicative Language: A Theory and Implementation in the Case of Prolog},
year = {1982},
isbn = {0897910656},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/582153.582181},
doi = {10.1145/582153.582181},
abstract = {An operational semantics of the Prolog programming language is introduced. Meta-IV is used to specify the semantics. One purpose of the work is to provide a specification of an implementation of a Prolog interpreter. Another one is an application of this specification to a formal description of program optimization techniques based on the principle of partial evaluation.Transformations which account for pruning, forward data structure propagation and opening (which also provides backward data structure propagation) are formally introduced and proved to preserve meaning of programs. The so defined transformations provide means to inference data structures in an applicative language. The theoretical investigation is then shortly related to research in rule-based systems and logic.An efficient well-integrated partial evaluation system is available in Qlog --- a Lisp programming environment for Prolog.},
booktitle = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {255–267},
numpages = {13},
location = {Albuquerque, New Mexico},
series = {POPL '82}
}

  



@article{alpuente1998partial,
  title={Partial evaluation of functional logic programs},
  author={Alpuente, Mar{\'\i}a and Falaschi, Moreno and Vidal, Germ{\'a}n},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={20},
  number={4},
  pages={768--844},
  year={1998},
  publisher={ACM New York, NY, USA}
}


@inproceedings{meyer1991techniques,
  title={Techniques for partial evaluation of imperative languages},
  author={Meyer, Uwe},
  booktitle={Proceedings of the 1991 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
  pages={94--105},
  year={1991}
}

@article{andersen1992self,
  title={Self-applicable C Program Specialization.},
  author={Andersen, Lars Ole},
  journal={PEPM},
  volume={92},
  number={28},
  pages={54--61},
  year={1992},
  publisher={Citeseer}
}


@article{LLOYD1991217,
	author = {J.W. Lloyd and J.C. Shepherdson},
	journal = {The Journal of Logic Programming},
	number = {3},
	pages = {217-242},
	title = {Partial evaluation in logic programming},
	volume = {11},
	year = {1991}}


@misc{burger2013picolisp,
  title={The PicoLisp Reference},
  author={Burger, Alexander},
  year={2013},
  publisher={Preuzeto}
}

@inproceedings{clinger1991macros,
  title={Macros that work},
  author={Clinger, William and Rees, Jonathan},
  booktitle={Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages},
  pages={155--162},
  year={1991}
}


@techreport{plt-tr1,
  title       = {Reference: Racket},
  author      = {Matthew Flatt and PLT},
  number      = {PLT-TR-2010-1},
  institution = {PLT Design Inc.},
  year        = {2010},
  note        = {\url{https://racket-lang.org/tr1/}}
}

@inproceedings{hickey2008clojure,
  title={The Clojure programming language},
  author={Hickey, Rich},
  booktitle={Proceedings of the 2008 symposium on Dynamic languages},
  pages={1--1},
  year={2008}
}


@article{winston1986lisp,
  title={Lisp},
  author={Winston, Patrick Henry and Horn, Berthold K},
  year={1986},
  publisher={Addison Wesley Pub., Reading, MA}
}


@phdthesis{shutt2010fexprs,
      title={Fexprs as the basis of Lisp function application or \$vau: the ultimate abstraction},
        author={Shutt, John N},
          year={2010}
}

@article{kearsleyimplementing,
    title={Implementing a Vau-based Language With Multiple Evaluation Strategies},
      author={Kearsley, Logan},
      
}
@inproceedings{reinking2021perceus,
    title={Perceus: Garbage free reference counting with reuse},
    author={Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
    booktitle={Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
    pages={96--111},
    year={2021}
}

@article{lorenzenreference,
    title={Reference Counting with Frame Limited Reuse},
    author={Lorenzen, Anton and Leijen, Daan}
}

@article{xie2021generalized,
  title={Generalized evidence passing for effect handlers: efficient compilation of effect handlers to C},
  author={Xie, Ningning and Leijen, Daan},
  journal={Proceedings of the ACM on Programming Languages},
  volume={5},
  number={ICFP},
  pages={1--30},
  year={2021},
  publisher={ACM New York, NY, USA}
}

@inproceedings{chang2017type,
  title={Type systems as macros},
  author={Chang, Stephen and Knauth, Alex and Greenman, Ben},
  booktitle={Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  pages={694--705},
  year={2017}
}

@article{chang2019dependent,
  title={Dependent type systems as macros},
  author={Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J},
  journal={Proceedings of the ACM on Programming Languages},
  volume={4},
  number={POPL},
  pages={1--29},
  year={2019},
  publisher={ACM New York, NY, USA}
}

@inproceedings{10.1145/1411204.1411255,
author = {Dolstra, Eelco and L\"{o}h, Andres},
title = {NixOS: A Purely Functional Linux Distribution},
year = {2008},
isbn = {9781595939197},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411204.1411255},
doi = {10.1145/1411204.1411255},
abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
pages = {367–378},
numpages = {12},
keywords = {software deployment, system configuration management, package management, NixOS, purely functional deployment model, purely functional language, nix},
location = {Victoria, BC, Canada},
series = {ICFP '08}
}



@article{10.1145/1411203.1411255,
author = {Dolstra, Eelco and L\"{o}h, Andres},
title = {NixOS: A Purely Functional Linux Distribution},
year = {2008},
issue_date = {September 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1411203.1411255},
doi = {10.1145/1411203.1411255},
abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {367–378},
numpages = {12},
keywords = {purely functional language, purely functional deployment model, system configuration management, NixOS, package management, software deployment, nix}
}

      
@article{lombardi1964lisp,
  title={Lisp as the language for an incremental computer},
  author={Lombardi, Lionello A},
  year={1964},
  publisher={[Cambridge, MIT]}
}

      

    @article{10.1145/249069.231419,
    author = {Sperber, Michael and Thiemann, Peter},
title = {Realistic Compilation by Partial Evaluation},
year = {1996},
issue_date = {May 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {31},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/249069.231419},
doi = {10.1145/249069.231419},
abstract = {Two key steps in the compilation of strict functional languages are the conversion of higher-order functions to data structures (closures) and the transformation to tail-recursive style. We show how to perform both steps at once by applying first-order offline partial evaluation to a suitable interpreter. The resulting code is easy to transliterate to low-level C or native code. We have implemented the compilation to C; it yields a performance comparable to that of other modern Scheme-to-C compilers. In addition, we have integrated various optimizations such as constant propagation, higher-order removal, and arity raising simply by modifying the underlying interpreter. Purely first-order methods suffice to achieve the transformations. Our approach is an instance of semantics-directed compiler generation.},
journal = {SIGPLAN Not.},
month = {may},
pages = {206–214},
numpages = {9},
keywords = {semantics-directed compiler generation, compilation of higher-order functional languages, partial evaluation}
}

  

@inproceedings{10.1145/231379.231419,
author = {Sperber, Michael and Thiemann, Peter},
title = {Realistic Compilation by Partial Evaluation},
year = {1996},
isbn = {0897917952},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/231379.231419},
doi = {10.1145/231379.231419},
abstract = {Two key steps in the compilation of strict functional languages are the conversion of higher-order functions to data structures (closures) and the transformation to tail-recursive style. We show how to perform both steps at once by applying first-order offline partial evaluation to a suitable interpreter. The resulting code is easy to transliterate to low-level C or native code. We have implemented the compilation to C; it yields a performance comparable to that of other modern Scheme-to-C compilers. In addition, we have integrated various optimizations such as constant propagation, higher-order removal, and arity raising simply by modifying the underlying interpreter. Purely first-order methods suffice to achieve the transformations. Our approach is an instance of semantics-directed compiler generation.},
booktitle = {Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation},
pages = {206–214},
numpages = {9},
keywords = {semantics-directed compiler generation, partial evaluation, compilation of higher-order functional languages},
location = {Philadelphia, Pennsylvania, USA},
series = {PLDI '96}
}
@book{ruf1993topics,
  title={Topics in online partial evaluation},
  author={Ruf, Erik Steven},
  year={1993},
  publisher={Stanford University}
}

  @article{danvy1996eta,
  title={Eta-expansion does the trick},
  author={Danvy, Olivier and Malmkj{\ae}r, Karoline and Palsberg, Jens},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={18},
  number={6},
  pages={730--751},
  year={1996},
  publisher={ACM New York, NY, USA}
}

@inproceedings{rompf2013optimizing,
  title={Optimizing data structures in high-level programs: New directions for extensible compilers based on staging},
  author={Rompf, Tiark and Sujeeth, Arvind K and Amin, Nada and Brown, Kevin J and Jovanovic, Vojin and Lee, HyoukJoong and Jonnalagedda, Manohar and Olukotun, Kunle and Odersky, Martin},
  booktitle={Proceedings of the 40th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={497--510},
  year={2013}
}

@article{sperber2000generation,
  title={Generation of LR parsers by partial evaluation},
  author={Sperber, Michael and Thiemann, Peter},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={22},
  number={2},
  pages={224--264},
  year={2000},
  publisher={ACM New York, NY, USA}
}
@inproceedings{sestoft1996ml,
  title={ML pattern match compilation and partial evaluation},
  author={Sestoft, Peter},
  booktitle={Dagstuhl Seminar on Partial Evaluation},
  volume={1110},
  pages={446--464},
  year={1996}
}