\section{Partial Evaluation}
\label{sec:partial}

Partial Evaluation dates back at least to Lombardi's partial evaluator for Lisp \cite{lombardi1964lisp}.
In this work, we devise a partial evaluator specifically focused on partially evaluating away fexprs that behave like macros that we call \textbf{macro-like operatives}. By partially evaluating and inlining calls to these fexprs in a way analogous to macro expansion, we show a language based on fexprs instead of macros can be approximately as efficient and at least as powerful.
Our partial evaluation algorithm can eliminate all uses of macro-like operatives, where macro-like means the uses are static, and the combiner definition looks something like Listing \ref{code:macrolike}.
\begin{lstlisting}[language=Lisp,caption={A Macro-like Combiner Definition},label=code:macrolike]
(let (helper (lambda (...) <generate code like macro>))
     (vau dynamic_env (parameters) (eval (helper parameters) dynamic_env)))
\end{lstlisting}

In these cases, the combiner takes in its arguments unevaluated (as it is an operative), passes them to a helper function that generates new code based on the passed code parameters, and then immediately evaluates the code generated by the macro-like function.
Any combiner written following this template will be partially evaluated away by our algorithm.
Our partial evaluator and compiler can handle more cases than just this exact "macro-like" template, but we focus on this case.
By showing that it is possible to port anything written as a macro (which will be expanded away) to an analogous operative combiner (that will be partially evaluated away), we establish the practicality of using fexprs instead of macros as the fundamental building blocks of a purely functional Lisp-like language. When creating a new language, one loses neither expressivity nor significant performance by choosing fexprs as the base construct over the combination of functions and macros.
Any use of fexprs that is not partially evaluated away is something that \textit{could not be expressed via macros}, and thus paying a performance penalty in these cases is not onerous.


We implemented an online partial evaluation strategy for \kraken. Based on \cite{10.1145/243439.243447}'s description, offline partial evaluation relies on a Binding Time Analysis to have been done so it can determine which pieces of code are dependent upon dynamic runtime values of the system and which can be computed statically.
On the other hand, online partial evaluation actually executes the program using real values if they are statically known, and symbolic values otherwise.
Computations that use only static values result in more statically known values, whereas the computations involving dynamic values generate residual code to be included in the final program.

In our case, it is impossible to even determine what symbols will be used as variables without performing at least some execution, much less determining if those variables will contain static or dynamic values, so online partial evaluation is the solution for us.
By being an online partial evaluation algorithm, we do not mean it is happening at program run-time rather it runs at compile-time. In other words,
"online" only refers to when the binding analysis is done relative to partial evaluation, not when the partial evaluation itself is done. 

Sophisticated partial evaluation algorithms can handle partially-static data structures, in which only some of the data and structure is known \cite{10.1145/249069.231419}.
A classic example of partially-static data is a Lisp cons cell, one side of which contains a static integer and the other residual code.
Some advanced partial evaluators maintain additional information about values and residual code, such as its type \cite{ruf1993topics}.

The following is the key difficulty in compiling away macro-esque operatives - the call site environment must be reified and passed to the operative, and that reified environment will be a partially-static data structure.
That is, each frame in the environment is either static data, mapping symbols to static values, or it is a static description of dynamic data, containing symbols and the ID of the combiner that created it (by being called).
Either of these types of frames may then chain upwards to a parent frame, which may be of either type as well.
Correctly handling these partially-static-data environments while ensuring that all macro-esque operatives are partially evaluated away while preventing both non-termination and exponential runtime was the key challenge in this work.
A thorny complication is that that a combiner definition may have to be partially evaluated multiple times in environments with different amounts of static data before it has enough information to reduce as far as it should according to our criteria of eliminating all statically known operative calls.
This means if partial evaluation for a form fails, we can't turn it into residual code right away, as it might be evaluated again later.
If this is done naively, it is very easy to incur exponential runtime as at every call first the combiner is evaluated, then the parameters, followed by the combiner again.
Since this compounds at every call inside a combiner (and compounds via environments containing combiners containing environments without memorization or similar), a mitigating technique is needed.
Our solution to this issue is the needed-for-progress-IDs system, which will be explained below.

As bits of the partial evaluation, especially as relating to calls, get complex, we broke down the algorithm into sections to make it easier to understand. In each section, we provide examples along the way, and at the end provide some final examples to show the process. Our partial evaluation roadmap:
\begin{itemize}
    \item \textbf{Section 4.1}: Partial Evaluation Contexts, Marking Syntax, and Unval Relation
    \item \textbf{Section 4.2}: Small Step Semantics
    \item \textbf{Section 4.3}: Helper Relations
    \item \textbf{Section 4.4}: Partial-Eval Versions of Primitives
    \item \textbf{Section 4.5}: Total Effect of Partial Evaluation
    \item \textbf{Section 4.6}: Examples
\end{itemize}

\subsection{Evaluation Contexts, Marking Syntax, and Unval Relation}
For partial evaluation, we added a new active term, \textit{under}, replace \textit{eval} with \textit{peval} (partial eval), and add new values to \textit{combine}, as shown in Fig. \ref{fig:extendedtermsyntax}.
\begin{figure}[h]
\[
  \begin{array}{rccll}
    AT &:=&& \kpval{T}{\kmkd{i_x}{E}}{ES}{FS}\\
       && \alt & \kunder{T}{(T\dots)}{\kmkd{i_x}{E}}{ES}{FS}\\
       && \alt & \kcombine{T}{(T\dots)}{E} & \text{(Active terms)}
  \end{array}
  \]
  \caption{New Terms for Partial Evaluation}
  \label{fig:extendedtermsyntax}
\end{figure}


We track two critical types of information throughout the partial evaluation process: IDs of environments that contain values needed for progress, and a set of the currently evaluating terms.
This allows us to massively prune the execution space and guide the path of partial evaluation.

This bookkeeping information is added via a "mark" pass.
Partial evaluation will operate on this "mark"'d representation, as will the compiler.
The extra information that bookkeeping adds for each type of form is as follows:
\begin{itemize}
    \item \textbf{Combiner}: A unique ID ($i$) that indicates environments created by calling this combiner\\
    Example: $\kmkd{i}{\kcomb{n}{s'}{\kmkd{i'_{f'}}{E'}}{(s\dots)}{Tb}}$
    \item \textbf{Env}: A unique ID ($i_r$ or $i_f$) matching this environment to the combiner whose call created it. The $r$ or $f$ subscript indicating whether the environment is "fake", a static description of the dynamic environment which maps symbols to placeholder values, or "real", a fully static map from symbols to (almost entirely) static values. "Almost entirely" because a "real" environment can map a symbol to a "fake" environment, as happens when partially evaluating a call to an operative that takes in its call site environment. \\
    Example: $\kmkd{i_r}{\kenv{(s \leftarrow V)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}}$\\
    Example: $\kmkd{i_f}{\kenv{(s \leftarrow V)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}}$
    \item \textbf{Symbol}: ID of environment that the symbol will be resolved in, if applicable. True means the symbol has yet to be partially evaluated, so the ID of the environment will resolve to unknown. $\emptyset$ means the symbol is a value instead of a suspended lookup.\\
    Example: $\kmkd{\truev}{s}$\\
    Example: $\kmkd{7}{s}$\\
    Example: $\kmkd{\emptyset}{s}$
    \item \textbf{Array}: Arrays can be marked by one of three options: \textit{val}, \textit{freshCall}, or \textit{attemptedCall}. \textit{val} indicates the array is a value. \textit{freshCall} indicates the array is a call that hasn't been partially evaluated yet.  \textit{attemptedCall} indicates the suspended call was partially evaluated, but couldn't proceed. \textit{attemptedCall} contains two values - the ID of the dynamic calling environment if the called combiner needs it (otherwise $\emptyset$) and/or the (form, environment) pair that caught and prevented infinite recursion.\\
    Example: $\kmkd{\kval}{(V_1~V_2)}$\\
    Example: $\kmkd{\kfresh}{(V_1~V_2)}$\\
    Example: $\kmkd{\katt{\emptyset}{\emptyset}}{(V_1~V_2)}$
\end{itemize}

In our implementation, we store additional data for efficiency, such as all for-progress-IDs found inside an array, but we will define them in Appendix A as stand-alone functions for ease of presentation.
Our implementation essentially pre-computes and stores the results of these functions as additional bookmarking data, reducing exponential lookups to constant factors.
This could also be achieved via memoization.

The mark relation in Fig. \ref{fig:markrelation} only needs to add bookkeeping to the surface syntax, so it is quite simple.
\begin{figure}[h]
\[
  \begin{array}{rcll}
    \kmark{n} &=& n\\
    \kmark{s} &=& \kmkd{\emptyset}{s}\\
    \kmark{(T\dots)} &=& \kmkd{\kval}{(\kmark{T}\dots)}\\
  \end{array}
  \]
  \caption{Mark Relation}
  \label{fig:markrelation}
\end{figure}

We must also split evaluation into two pieces: "unval"-ing and "partial-eval"-ing.
Unvaling takes a value and turns it into a suspended computation. Partial-evaling takes a suspended computation (or a value containing one) and tries to perform at least some evaluation in order to reduce work at runtime.
Now, evaluation is just unvaling composed with partial evaluation.

\begin{figure}[h]
\[
  \begin{array}{rcll}
    \kunval{n} &=& n\\
    \kunval{\kprim{n}{o}} &=& \kprim{n}{o}\\
    \kunval{\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_{f'}}{E'}}{(s\dots)}{Tb}}} &=& \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_{f'}}{E'}}{(s\dots)}{Tb}}\\
    \kunval{\kmkd{i}{E}} &=& \kmkd{i}{E}\\
    \kunval{\kmkd{\emptyset}{s}} &=& \kmkd{\truev}{s}\\
    \kunval{\kmkd{\kval}{(T_1~T_2\dots~T_n)}} &=& \kmkd{\kfresh}{(\kunval{T_1}~T_2\dots~T_n)}\\
  \end{array}
  \]
  \caption{Unval Relation}
  \label{fig:unvalrelation}
\end{figure}
Unvaling (Fig. \ref{fig:unvalrelation}) a self-evaluating value is just the value itself, as there is no computation to suspend.
The two forms that change when unvaling are symbols (which go from values to suspended lookups of that symbol in an environment) and arrays (which turn into suspended calls).


Contexts in Fig. \ref{fig:pecontexts} are defined like before, but augmented with our new "peval" (partial evaluate), combiner bodies, and multiple positions in the new "under" form.
\begin{figure}[h]
\[
  \begin{array}{rcl}
    \Ctxt &:=& \square \alt \kpval{\Ctxt}{\kmkd{i_x}{E}}{ES}{FS} \alt \kcomb{n}{s'}{\kmkd{i_x}{E}}{(s\dots)}{\Ctxt}\\
    && \alt \kunder{\Ctxt}{(T\dots)}{\kmkd{i_x}{E}}{ES}{FS} \alt \kunder{T}{(\Ctxt~T\dots)}{\kmkd{i_x}{E}}{ES}{FS}\\
    && \alt \kunder{T}{(T~\Ctxt~T\dots)}{\kmkd{i_x}{E}}{ES}{FS} \alt \kunder{T}{(T\dots~\Ctxt)}{\kmkd{i_x}{E}}{ES}{FS}\\
    && \alt \kcombine{\Ctxt}{(T\dots)}{E} \alt \kcombine{T}{(\Ctxt,T\dots)}{E}\\
    && \alt \kcombine{T}{(T\dots,\Ctxt,T\dots)}{E} \alt \kcombine{T}{(T\dots,\Ctxt)}{E}\\
  \end{array}
\]
  \caption{Contexts for Partial Evaluation}
  \label{fig:pecontexts}
\end{figure}

\subsection{Partial-Eval Small-Step Semantics}
In Appendix B we present some simplified pseudocode to give an additional reference and roadmap for the relations presented here.

For simplicity, we split the semantics into two subsections. The first one will talk about partial evaluation of everything but calls. The second one will just be the calls due to their complexity. 

\subsubsection{Partial Evaluation of Non-Calls}: The partial evaluation of non-calls is easier to understand, and it helps to get a feel for the basic semantics of partial evaluation.

\begin{figure}[h]
\[
  \begin{array}{rcl}
    \InCtxt{E}    &\rightarrow& \InCtxt{E'} ~ (\text{if } E \rightarrow E')\\
    \\
    \kpval{x}{\kmkd{i_x}{E}}{ES}{FS}  &\rightarrow& x~~\text{if}~\truev~\notin~\kprog{x}~\land\\
                                                  &&~\kprog{x}~\cap~ES~=~\emptyset~\land\\
                                                  &&~\kiprog{x}~\cap~ES~=~\kiprog{x}\\
                                                  && \textbf{else:}\text{ continue below}\\
                                                  \\
    \kpval{\kmkd{x}{s}}{\kmkd{i_x}{E}}{ES}{FS}  &\rightarrow& lookup(s,E)\\
    \kpval{\kmkd{i'_{x'}}{E'}}{\kmkd{i_{x}}{E}}{ES}{FS}  &\rightarrow& \kmkd{i'_{x'}}{E''}~\textbf{if}~\kmkd{i'_{x''}}{E''} \in ES ~\textbf{else}~\kmkd{i'_{x'}}{E'}\\
    \\

    \kpval{&&\\ \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}}{&&\\\kmkd{i_x}{E}}{ES}{FS}  &\rightarrow& \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}\\
    \\
    \kpval{&&\\ \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_{f'}}{E'}}{(s\dots)}{Tb}}}{&&\\\kmkd{i_x}{E}}{ES}{FS}  &\rightarrow& \text{let}~E''=\kenv{(s \leftarrow \kmkd{i''}{s})\dots}{s' \leftarrow \kmkd{i''}{s'}}{\kmkd{i_x}{E}}~\text{in}\\
    && \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i_x}{E}}{(s\dots)}{\\&&\qquad \kpval{Tb}{\kmkd{i''_f}{E''}}{\{\kmkd{i''_f}{E''}\}\cup ES}{FS}}}\\
  \end{array}
\]
  \caption{Non-Call Partial-Eval Semantics}
  \label{fig:ncpesemantics}
\end{figure}
In Fig. \ref{fig:ncpesemantics}, we see the formal relations for partial evaluation of all forms except calls. 
The components of an actively partially evaluating form $\kpval{x}{\kmkd{i_x}{E}}{ES}{FS}$ is as follows:
\begin{itemize}
    \item The form that needs to be partially evaluated ($x$ in the figure).
    \item The environment to partially evaluate it in ($\kmkd{i_x}{E}$ in the figure)
    \item The "call stack" (a set in this case) of environments for evaluating the forms above this one ($ES$ in the figure)
    \item A set of currently evaluating forms ($FS$ in the figure) used to check for and prevent infinite recursion
\end{itemize}

%We begin with the step-inside-context rule before getting to our first interesting rule, the will-make-progress condition.
%If we cannot make progress, we return the form unchanged.  Otherwise, we fall through the other rules to determine how to proceed. 

Our first relation is the same as from the small-step semantics of the base language - that a larger expression can step if a sub-component of it as indicated by the Context form can step.

The next relation checks to see if partially evaluating the form will make any progress.
There are three conditions which, if true, mean that the form cannot make progress:
\begin{itemize}
    \item the form has already been partially evaluated ($\truev~\notin~\kprog{x}$)
    \item none of the environments the form needs to progress are currently real or in our environment stack ($\kprog{x}~\cap~ES~=~\emptyset$)
    \item the form hadn't previously stopped evaluating to prevent infinite recursion or we are no longer under the form that began the loop ($\kiprog{x}~\cap~ES~=~\kiprog{x}$)
\end{itemize}
If all three of these are true, partially evaluating the form won't have any affect and instead the form can be returned immediately.

On the other hand, if any of these are false the form might be able to make progress and it falls through to the remaining relations.
Note that integers, symbol values, and array values will all already have been returned by the progress-check condition.
We are only left with suspended symbol lookup, environment value, or derived combiner.
For suspended symbol lookup, we just lookup the symbol in the current environment. If this environment is fake, it will return the same symbol marked with the ID of the environment that it would be found in if it were real.
When partially evaluating an environment value we check the current environment\_stack to see if the environment has a newer, real version (identified by ID) - if so we return it, else we return the environment unchanged.


A derived combiner is the most complicated case in this section.
First, we check to see if its static environment is real or not.
If it is, the fifth rule of Fig. \ref{fig:ncpesemantics} (as noted by the r subscript in the static environment $\kmkd{i'_r}{E'}$ in the combiner value), we return it immediately, since this combiner has already been evaluated in a real environment.
As a closure, it captured the environment from its original evaluation during its creation, and since it might have since moved this environment should not be replaced.
On the other hand, a fake static environment (as noted by the f subscript in the static environment $\kmkd{i'_f}{E'}$ in the combiner value) means the closure's initial evaluation has not yet happened and the closure is still at its original defining place.
In this case, we replace the old static environment with the current one, and then create a new fake environment that maps the function's parameters to placeholder symbols marked with the ID of the combiner/fake environment. We further partially evaluate the combiner's body in this fake environment.
The final result is a new derived combiner form that wraps up the new static environment and the partially evaluated body form.

\subsubsection{Partial Evaluation of Calls}
The partial evaluation of calls is more complex due to the high amount of bookkeeping that needs to be maintained. This complexity can be seen in Fig. ~\ref{fig:cpesemantics}.

\begin{figure}[h]
\[
  \begin{array}{rcl}
    \kpval{\kmkd{\kfresh}{(T_1~T_2\dots)}}{\kmkd{i_x}{E}}{ES}{FS}   &\rightarrow& \kpcombine{\\&&\qquad\kpval{T_1}{\kmkd{i_x}{E}}{ES}{FS}}{\\&&\quad(T_2\dots)}{\kmkd{i_x}{E}}{ES}{FS}\\
    \kpval{\kmkd{\katt{x}{y}}{(T_1~T_2\dots)}}{\kmkd{i_x}{E}}{ES}{FS}   &\rightarrow& \kpcombine{\\&&\qquad\kpval{T_1}{\kmkd{i_x}{E}}{ES}{FS}}{\\&&\quad(T_2\dots)}{\kmkd{i_x}{E}}{ES}{FS}\\
    \\
    \kpcombine{\kmkd{x}{s}}{(T_2\dots)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kmkd{\katt{\emptyset}{\emptyset}}{(\kmkd{x}{s}~T_2\dots)}\\
    \kpcombine{\kmkd{\katt{x}{y}}{(T_1\dots)}}{&&\\(T_2\dots)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kmkd{\katt{\emptyset}{\emptyset}}{\\&&\qquad(\kmkd{\katt{x}{y}}{(T_1\dots)}~T_2\dots)}\\
    \\
    \kpcombine{\kprim{(S~n)}{o}}{(V\dots)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpcombine{\kprim{n}{o}}{\\&&\qquad\kpval{\kunval{\kpval{V}{\kmkd{i_x}{E}}{ES}{FS}}}{\\&&\qquad\qquad\kmkd{i_x}{E}}{ES}{FS}\dots}{\kmkd{i_x}{E}}{ES}{FS}\\
    \\
    \kpcombine{&&\\ \kmkd{i''}{\kcomb{(S~n)}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}}}{&&\\ (V\dots)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpcombine{\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_{x'}}{E'}}{s}{Tb}}}{\\&&\qquad\kpval{\kunval{\kpval{V}{\kmkd{i_x}{E}}{ES}{FS}}}{\\&&\qquad\qquad\kmkd{i_x}{E}}{ES}{FS}\dots}{\kmkd{i_x}{E}}{ES}{FS}\\
    \\
    \kpcombine{&&\\ \kmkd{i''}{\kcomb{0}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}}}{&&\\(V\dots)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow&  \textbf{let}~E''=\kenv{(s \leftarrow V)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}~\textbf{in}\\
    &&\textbf{let}~C = \kmkd{i''}{\kcomb{0}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}}~\textbf{in}\\
    &&\textbf{let}~F = (C,E'')~\textbf{in}\\
    &&\kmkd{\katt{\emptyset}{F}}{(C~V\dots)}~\textbf{if}~F \in FS\\
    &&\textbf{else}~\kunder{\\
    &&\kpval{Tb}{\kmkd{i''_r}{E''}}{(\kmkd{i''_r}{E''}\cup ES)}{\{F\}\cup FS}}{\\&&(\kmkd{i''}{\kcomb{0}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}}~V\dots)}{\\&&\kmkd{i_x}{E}}{ES}{FS}\\
    \\
    \kunder{z}{&&\\(\kmkd{i''}{\kcomb{0}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}~V\dots)}}{&&\\\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \textbf{let}~o = returnOk(z,i')~\textbf{in}\\
    &&dropRV(z,\kmkd{i_x}{E},ES,FS)~\textbf{if}~o=\truev~\textbf{else}\\
    &&\textbf{let}~i_?= i_x~\textbf{if}~s' \neq \emptyset~\textbf{else}~\emptyset~\textbf{in}\\
    &&\kmkd{\katt{i_?}{\emptyset}}{(\kmkd{i''}{\\&&\qquad\kcomb{0}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}}V\dots)}\\
  \end{array}
\]
  \caption{Call Partial-Eval Semantics}
  \label{fig:cpesemantics}
\end{figure}
First, we partially evaluate the first item in the array, which will be the combiner, transitioning to a \textit{combine} form to indicate we are in the process of evaluating a call, as seen before in the base language semantics in Section 3.
The next rule handles the case where the thing to be called isn't a combiner but instead a suspended symbol lookup ($\kmkd{x}{s}$). In this case, we simply return the call as-is, marked as attempted, because we can't make progress.
We do the same if the thing to be called is another suspended call ($\kmkd{\katt{x}{y}}{(T_1\dots)}$).
Otherwise, we have a combiner, either primitive or derived, and we extract the wrap\_level from it. We then partial eval, unval, and partial eval again the arguments wrap\_level number of times.
If the combiner is a normal applicative, this would mean 1 time, like function calls in most other languages. The other common option is 0 times when the combiner is an operative, in order to take the code for the parameters in unevaluated. This might be so the operative can behave like a macro, or implement special control flow.
Numbers greater than 1 for wrap\_level are also possible, but rarely useful.
We retain the ability for wrap\_levels greater than 1 for uniformity, but have not used them in practice.

Now, we are ready to execute the actual call due to the parameters being evaluated the proper number of times according to the wrap\_level in the combiner.
The semantics for executing calls to primitive combiners are given as relations in Fig. 9 in Appendix A.
For derived combiners, we create a new inner environment ($E''$) that maps the parameter symbols to the argument values, the special dynamic environment parameter symbol ($s'$) to the current dynamic environment ($\kmkd{i_x}{E}$), and chains up to the indicated static environment ($\kmkd{i'_{x'}}{E'}$) from the combiner value.
We first check to see if this (form, environment) pair is currently executing ($(C,E'') \in FS$), and return early if so to prevent infinite recursion.
If it does return early, the returned call notes the (form, environment) pair that caused it to stop executing in its \textit{atmdCall} form: $\kmkd{\katt{\emptyset}{F}}{(C~V\dots)}$.
Otherwise, the combiner body is evaluated in this new environment, with the call site marked by the \textit{under} marker form.
The \textit{under} form delineates where a currently executing call is. This allows us to check whether the value/code resulting from partially evaluating a call site is legal to return whenever the form stops evaluating.
To do this, it contains both the partial evaluation of the combiner body to execute the call as well as a fallback term.
The fallback term, which is an updated suspended call in this case, is to be used if the call fails.
The fallback term additionally carries the current dynamic environment, environment stack, and executing form set to be used in the next rule.
The result is checked by the \textit{returnOk} auxiliary function to see if this value is safe to return (defined in Appendix A, overview given in Section 4.3). If it is safe, it passes through \textit{dropRV} before being returned (Fig. 8 in Appendix A).

The case where it is not legal to return a value is if there is, or could be, a reference that must be resolved in the inner environment created by this call.
If the result is legal to return, the dropRedundentVeval (or \textit{dropRV}) ensures no useless call to \textit{veval} (a modified \textit{eval} used in the primitive semantics (Fig. 9 in Appendix A)) to wrap any part of the result.
This is important because these unnecessary wrapper calls to \textit{veval} can block partial evaluation progress in some cases.


When the result form is not legal to return, we return a call form with the partially evaluated combiner (with updated wrap\_level) and partially evaluated arguments based on the fallback value in the \textit{under} form.
If the combiner does take in a dynamic environment, we note the current dynamic environment's ID on the suspended call form ($i_?$).



\subsection{Helper Relations}
Next we quickly describe the various helper relations (fully defined in Appendix A) used in our definition of the partial evaluation relations.
\begin{itemize}
    \item \textbf{Needed-For-Progress}: The needed-for-progress relation shows the set of IDs for which at least one needs to correspond to a real environment (static data) with values in order for the form to make progress. $\truev$ means that it can make progress no matter what.
    \item \textbf{Needed-For-Progress-Upper}: An "upper" version of the needed-for-progress relation (in Appendix A) that tracks IDs of environments that are real themselves, but chain upwards to fake environment IDs.
    \item \textbf{Needed-For-Progress-Infinite}: This relation extracts the forms that have previously stopped executing to prevent infinite recursion. This is important when we are not currently executing in the call stack of one of these forms. If we are not, we should keep executing this form, as it has more evaluation to go before it hits another opportunity for infinite recursion. This is part of the mechanism that allows us to use the Y-combinator to implement recursion without either having infinite recursion or un-evaluated recursive calls with finite inputs.
    \item \textbf{Lookup}: As its names signifies, it finds the value associated with a symbol in an environment.
    \item \textbf{returnOk}: It determines if it is legal to return a particular result out of a particular environment. For example, a term can be returned out of a call if the ID of the inner environment/combiner is not present in the term either explicitly or implicitly through a suspended call to a combiner that takes in its dynamic environment.
    \item \textbf{IDin}: It determines if this ID appears in this value without being under a combiner that introduces this ID.
    \item \textbf{takesDE}: It determines if this combiner takes in the dynamic environment.
    \item \textbf{dropRV} / dropRedundentVeval: Our final helper function removes extraneous calls to \textit{veval} that can get in the way of further partial evaluation.
    \textit{veval} is a version of the applicative \textit{eval}, but with both parameters (the term to evaluate and the environment to evaluate it in) already unvaled and partially evaluated.
    It requires special handling (which it receives via the -1 wrap\_level), because its term argument should not be partially evaluated via the normal machinery, which would use the wrong environment (the current dynamic environment, instead of the explicit environment passed to \textit{veval}/\textit{eval}).
Calls to \textit{eval} are common in macro-like operatives, where the normal final call of a macro-like operative is to \textit{eval} the code constructed during the body of the combiner.
This call to \textit{eval} will partially evaluate to a call to \textit{veval}, which will then return successfully to the call site.
In a normal macro-like operative call, this call site's dynamic environment is the explicit environment passed to \textit{veval}, and thus the call to \textit{veval} is extraneous and the term will be inlined directly, completing the partial evaluation dance that fully expands macro-like operative calls.
This removal is the responsibility of \textit{dropRV}.
A "macro-like operative combiner call" example that demonstrates this happening is located below in section 4.6.
\end{itemize}

\subsection{Partial Eval Primitives Small-Step Semantics}
Finally, we come to the (selected) semantics of the primitive combiners.
For space, their formal definition is relegated to Appendix A. In general, they perform the same function as the simpler base primitives, but operate on the marked terms.
The main combiners of interest are \textit{if0} and \textit{vau} which perform additional partial evaluation on their branches and body, respectively.
We have already heard about \textit{eval}'s half-life as \textit{veval} and function in carrying along the proper environment to evaluate a suspended piece of code in until it can be unwrapped by \textit{dropRV} and spliced into its final location.
The formal definition of \textit{eval}, \textit{veval}, and \textit{dropRV} are in Appendix A.
The primitive implementations omitted are the trivial ones - they only evaluate if their parameters are fully evaluated values and they evaluate to the same value that they would under the base semantics.


\subsection{Combined Effect of Partial Evaluation}
The end result of all of this interconnected machinery is the removal of all statically called operatives where the operative was written in a macro-esque style.
%Note that due to the invariants maintained by partial evaluation exactly the calls to derived combiners for which all arguments are values are executed.
Note that the invariants maintained by partial evaluation ensure that derived combiners are only executed whose arguments are all values.
Additionally, the result of a call to a combiner is either a value, a suspended computation where all calls either don't take in the dynamic environment (which would be the combiner's environment that it's being returned from), or an explicit call to veval providing its own environment.
These are the cases that can be returned by a macro-like combiner!
In addition, the partial evaluation process strips redundant calls to veval.
Once the suspended code is returned from the call to the macro-like combiner, its call to veval will become redundant and the inner suspended computation will be inlined into the parent, just like how a macro would be expanded to code spliced into its calling location.

\subsection{Examples}
To illustrate the algorithm, we have some examples of marking, unvaling, and then partial-evaling in stages. The full step-by-step examples are too long for any paper, so these have been somewhat abbreviated.
\subsubsection{Addition Example}
We'll walk through the full partial evaluation steps for $(+~1~2)$ which is 3.
\begin{longtable}{cc}
      $(+~1~2)$ & The initial code\\
      $\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2)}$ & Marked\\
      $\kmkd{\kfresh}{(\kmkd{\truev}{+}~1~2)}$ & Then unvaled\\
      \\
      $\kpval{\kmkd{\kfresh}{(\kmkd{\truev}{+}~1~2)}}{\kmkd{i_r}{E}}{ES}{FS}$ & We can't show the entire env,\\
      &but for illustration say that E\\
      &maps "+" to the primitive + combiner\\
      \\
      $\kpcombine{\kpeval{\kmkd{\truev}{+}}{\kmkd{i_r}{E}}{ES}{FS}}{(1~2)}{\kmkd{i_r}{E}}{ES}{FS}$ & Begin call, PV combiner\\
      $\kpcombine{\kprim{1}{+}}{(1~2)}{\kmkd{i_r}{E}}{ES}{FS}$ & Lookup replaces the symbol +\\
      & with the primitive \\&combiner\\
      \\
      $\kpcombine{\kprim{0}{+}}{(\kpval{\kunval{1}}{\kmkd{i_r}{E}}{ES}{FS}$ & Unval+PartialEval to evaluate\\
      $\kpval{\kunval{2}}{\kmkd{i_r}{E}}{ES}{FS})}{\kmkd{i_r}{E}}{ES}{FS}$ & parameters, but integers stay the \\&same\\
      \\
      $\kpcombine{\kprim{0}{+}}{(1~2)}{\kmkd{i_r}{E}}{ES}{FS}$ & And then the call\\
      +(1~2) & Primitive does the calculation\\
      3 & result is 3, as expected,\\
        & which is legal to return\\
\end{longtable}
\subsubsection{Constant Combiner Example}
Now that we've done addition, we'll get slightly more complex by introducing the creation of a combiner with a body that can be partially evaluated. We take larger steps because we've gone over the details with the simple addition. In this case, we have $(vau~(x)~(+~1~2~x))$ meaning "1+2+x" for some input x.
We use just a pinch of syntactic sugar to have a 2-argument vau that is equivalent to the 3-argument vau that ignores its special dynamic environment parameter.
\begin{longtable}{cc}
      $(vau~(x)~(+~1~2~x))$ & The initial code\\
      $\kmkd{\kval}{(\kmkd{\emptyset}{vau}~\kmkd{\kval}{(x)}~\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~x)})}$ & \text{Parsed and marked syntax}\\
    $\kmkd{\kfresh}{(\kmkd{\truev}{vau}~\kmkd{\kval}{(x)}~\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~x)})}$ & \text{Unvaled}\\
      &\\
      $\kpval{\kmkd{\kfresh}{$&\text{We can't show the entire env.}\\$(\kmkd{\truev}{vau}~\kmkd{\kval}{(x)}~\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~x)})$&\text{For illustration, E maps "vau"}\\$}}{\kmkd{i_r}{E}}{ES}{FS}$ &\text{to the primitive vau combiner}\\
    \\
      $\kpcombine{\kpeval{\kmkd{\truev}{vau}}{\kmkd{i_r}{E}}{ES}{FS}}{$&\\$(\kmkd{\kval}{(x)}~\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~x)}))}{\kmkd{i_r}{E}}{ES}{FS}$ & \text{Begin call, PV combiner}\\
      &\\
      $\kpval{$&\text{The symbol Vau maps to its}\\
      $\kmkd{7}{\kcomb{0}{s'}{\kmkd{i_f}{E}}{(x)}{\kmkd{\kfresh}{(\kmkd{\truev}{+}~1~2~\kmkd{\emptyset}{x})}}}}{$ &\text{combiner value that will now}\\
      $\kmkd{i_r}{E}}{ES}{FS}$ &\text{be partially evaluated}\\
      \\
      $\kmkd{7}{\kcomb{0}{s'}{\kmkd{i_f}{E}}{(x)}{$&\text{Partial evaluating the body}\\$\kpval{\kmkd{\kfresh}{(\kmkd{\truev}{+}~1~2~\kmkd{\emptyset}{x})}}{$& \text{with fake environment. Notice, we}\\$\kmkd{7_f}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}}}{ES}{FS}}}$ & \text{are almost back to our first example}\\
      &\\
      $\kmkd{7}{\kcomb{0}{s'}{\kmkd{i_r}{E}}{(x)}{\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~3~\kmkd{7}{x})}}}$ & \text{We'll fast forward through the}\\
      & \text{process from our first example}\\
\end{longtable}
We moved quickly through the part mostly shared with the previous example. The only difference being the addition of the parameter reference $x$ to the addition.
The only thing to note is that $\kmkd{\emptyset}{x}$ is unvaled to $\kmkd{\truev}{x}$ (not shown) and then was partially evaluated to $\kmkd{7}{x}$ (7 being the ID of the combiner/fake environment). Furthermore, the partial evaluation version of addition had to return a new partially evaluated call, since it could not yet evaluate $x$.
We are left with a partially-evaluated combiner, but haven't yet seen this new technique do anything that previous partial evaluation techniques couldn't.
For that, let's see a high-level view of how a macro-like operative call would be partially evaluated away.
\subsubsection{Macro-like Operative Call Example}
Due to the length of a step-by-step evaluation of this code, we will take larger jumps than before, omitting that which could be inferred from our two previous examples.
\begin{lstlisting}[language=Lisp,caption={},label=code:additionexample]
(let ( (double_parameter (vau de (x) (eval (array + x x) de))) )
     (vau (x) (double_parameter (+ 1 2 x))))
\end{lstlisting}
We'll skip over how "let" works for now (it's an operative combiner too) and focus on the partial evaluation of a macro-like operative part.
This piece of code defines a macro-like operative called "double\_parameter" that takes in a piece of code "x" unevaluated along with the dynamic calling environment "de" and then constructs the code "(+ x x)" as an array and evaluates it in de, the calling environment.
This code is intentionally simplistic and will evaluate its argument twice (though the downsides of doing so are considerably reduced in a purely functional language where evaluating x cannot have side effects).
This should bring to mind the classic macro example from C, "\#define double(x) (x+x)", and indeed we chose it for its familiarity.
Let's start by seeing what the macro-like f-expression itself looks like partially evaluated, and then we'll jump right into its application. This code:
\begin{lstlisting}[language=Lisp,caption={},label=code:additionexample]
(vau de (x) (eval (array + x x) de))
\end{lstlisting}
becomes
\[
      \kmkd{6}{\kcomb{0}{de}{\kmkd{i_r}{E}}{(x)}{\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{eval}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{array}~\kprim{1}{+}~\kmkd{6}{x}~\kmkd{6}{x})}~\kmkd{6}{de})}}}
\]
in a way very similar to our earlier examples of partially evaluated combiners.
We have a combiner with two suspended calls, nested, with some suspended symbol lookups.\\
Now let's look at its use, when partially evaluating the body:
\begin{lstlisting}[language=Lisp,caption={},label=code:additionexample]
(vau (x) (double_parameter (+ 1 2 x)))
\end{lstlisting}
becomes, skipping forwards to evaluating the body
\begin{longtable}{cc}
      $\kmkd{7}{\kcomb{0}{\emptyset}{\kmkd{i_f}{E}}{(x)}{\kpval{$&\\
      $\kmkd{\kfresh}{(\kmkd{\truev}{double\_parameter}~\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})})}}{$&\\
      $\kmkd{i_r}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}}}{ES}{FS}}}$ & \text{forwards to call}\\
      \\
      $\kmkd{7}{\kcomb{0}{\emptyset}{\kmkd{i_f}{E}}{(x)}{\kpval{\kmkd{\kfresh}{($
      &\\
      $\kmkd{6}{\kcomb{0}{de}{\kmkd{i_r}{E}}{(x)}{\kmkd{\katt{\emptyset}{\emptyset}}{$
      &\\
      $(\kprim{0}{eval}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{array}~\kprim{1}{+}~\kmkd{6}{x}~\kmkd{6}{x})}~\kmkd{6}{de})}}}$
      &\\
      $\kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})})}}{$&\\
      $\kmkd{7_r}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}}}{ES}{FS}}}$ & \text{substituting in definition}\\
      \\
\end{longtable}
We'll use a symbol for this nested environment, as it is quite unwieldy.
\[
    E'' = \kmkd{6_r}{\kenv{(x \leftarrow \kmkd{\kval}{(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})})}{\kmkd{7_r}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}}}{\kmkd{i_r}{E}}}
\]
Let's continue along with the example.
\begin{longtable}{cc}
      \\
      $\kpval{\kmkd{\katt{\emptyset}{\emptyset}}{$&\text{evaluating body}\\
      $(\kprim{0}{eval}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{array}~\kprim{1}{+}~\kmkd{6}{x}~\kmkd{6}{x})}~\kmkd{6}{de})}}{E''}{$
      &\\
      $ES}{FS}$ &\text{with generated env}\\
      \\
      $\kpval{\kmkd{\katt{\emptyset}{\emptyset}}{$&\text{evaluating array call}\\
      $(\kprim{0}{eval}~\kmkd{\kval}{(\kprim{1}{+}~(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x}))}$&\\
      $\kmkd{7_f}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}})}}{E''}{$
      &\\
      $ES}{FS}$ & \text{and its symbol parameters}\\
      \\
      $\kpcombine{\kmkd{i''}{\kprim{-1}{veval}}}{$
      &\\
      $(\kunval{\kmkd{\kval}{(\kprim{1}{+}~(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x}))}}$
      &\\
      $\kmkd{7_f}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}})}{$
      &\\
      $E''}{ES}{FS}$ & \text{evaluating eval}\\
 \\
      $\kpcombine{\kmkd{i''}{\kprim{-1}{veval}}}{$
      &\\
      $(\kmkd{\kfresh}{(\kprim{1}{+}~(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x}))}$
      &\\
      $\kmkd{7_f}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}})}{$
      &\\
      $E''}{ES}{FS}$ & \text{unval}\\
      \\
      $\text{let}~\kmkd{7_f}{E'}~=~\kmkd{7_f}{\kenv{(x \leftarrow \kmkd{7}{x})}{}{\kmkd{i_r}{E}}}~\text{in}$ & \text{we also abbriviate E'}\\
      $\text{let}~V'~=~\kpval{$
      &\\
      $\kmkd{\kfresh}{(\kprim{1}{+}~(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x})(\kmkd{\emptyset}{+}~1~2~\kmkd{\emptyset}{x}))}}{$
      &\\
      $\kmkd{7_f}{E'}}{\{\kmkd{7_f}{E'}\}\cup ES}{FS}~\text{in}$ &\\
      $\kunder{V'}{(\kprim{-1}{veval}~V'~\kmkd{7_f}{E'})}{\kmkd{i_x}{E}}{ES}{FS}$ & \text{stepping veval}\\
\end{longtable}
V' will step to:
\[
    \text{let}~V'~=~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~3~\kmkd{7}{x})}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~3~\kmkd{7}{x})})}~\text{in}\\
\]
Now, the under call will fail to complete, as $returnOk$ will return false, finding $7$ in the result.
Thus, the fallback will be returned and will be the final result of the call to $double\_parameter$.
This time, $returnOk$ will be true, as $6$, $double\_parameter$'s ID, is nowhere to be found in the result.
Thus, we will transition to a call to $dropRV$ with the ID $7$.
\[
    dropRV(\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{-1}{veval}~V'~\kmkd{7_f}{E'})},~\kmkd{7_f}{E'},~ES,~ FS)
\]
Of course, this is a redundant veval, so the final result of partially evaluating the call to \\ $double\_parameter$ is:
\[
    V'
\]
that is,
\[
    \kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~3~\kmkd{7}{x})}~\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{0}{+}~3~\kmkd{7}{x})})}
\]

Note that this suspended computation is returned and replaces the call to the macro-like operative call.
This code is the equivalent of:
\begin{lstlisting}[language=Lisp,caption={},label=code:additionexample]
(vau (x) (+ (+ 3 x) (+ 3 x)))
\end{lstlisting}
This is what we would have gotten if we had used a macro and basic constant propagation.

Note that this evaluation of the example did not depend on the exact values, the code generated by the macro-like operative, or the parameters to the call.
In just this way, static calls to macro-like operatives will be partially evaluated away by our algorithm in a way congruent to macro-expansion and then constant propagation in a more standard optimizing Scheme implementation.


