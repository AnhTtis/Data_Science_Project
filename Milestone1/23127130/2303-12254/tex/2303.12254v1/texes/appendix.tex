%% Appendix
\appendix

\section{Auxiliary Helper Relations}
\begin{figure}[H]
\[
  \begin{array}{rcll}
    \kprog{n}      &=& \emptyset\\
    \kprog{\kmkd{\emptyset}{s}}  &=& \emptyset\\
    \kprog{\kmkd{i}{s}} &=& \{i\}\\
    \kprog{\kmkd{\kval}{(T_1~\dots~T_n)}} &=& \kprog{T_1} \cup \dots \cup \kprog{T_n}\\
    \kprog{\kmkd{\kfresh}{(T_1~\dots~T_n)}} &=& \{\truev\}\\
    \kprog{\kmkd{\katt{x}{y}}{(T_1~\dots~T_n)}} &=& \{x\} \cup \kprog{T_1} \cup \dots \cup \kprog{T_n}\\
    %comb
    \kprog{\kmkd{x}{\kcomb{n}{s'}{\kmkd{i}{E}}{(s\dots)}{T}}} &=& (\kprog{\kmkd{i}{E}} \cup \kprog{T}) - \{x\}\\
    %prim-comb
    \kprog{\kprim{n}{o}} &=& \emptyset\\
    %env - huh, can only have on upper-env and s'<-de, won't be anywhere else
    % due to our call restrictions
    \kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{s' \leftarrow \kmkd{i'}{E'}}{\kmkd{i}{E}}}} &=& \kprog{\kmkd{i}{E}} \cup \kprog{\kmkd{i'}{E'}}\\
    \kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} &=& \kprog{\kmkd{i}{E}}\\
  \end{array}
  \]
  \caption{Needed-For-Progress Relation}
  \label{fig:neededforprogressrelation}
\end{figure}
\begin{figure}[H]
\[
  \begin{array}{rcll}
    \kuprog{n}      &=& \emptyset\\
    \kuprog{\kmkd{x}{s}} &=& \emptyset\\
    \kuprog{\kmkd{\kval}{(T_1~\dots~T_n)}} &=& \kuprog{T_1} \cup \dots \cup \kuprog{T_n}\\
    \kuprog{\kmkd{\kfresh}{(T_1~\dots~T_n)}} &=& \kuprog{T_1} \cup \dots \cup \kuprog{T_n}\\
    \kuprog{\kmkd{\katt{x}{y}}{(T_1~\dots~T_n)}} &=& \kuprog{T_1} \cup \dots \cup \kuprog{T_n}\\
    %comb
    \kuprog{\kmkd{x}{\kcomb{n}{s'}{\kmkd{i}{E}}{(s\dots)}{T}}} &=& \emptyset\\
    %prim-comb
    \kuprog{\kprim{n}{o}} &=& \emptyset\\
    %env - huh, can only have on upper-env and s'<-de, won't be anywhere else
    % due to our call restrictions
    \kuprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{s' \leftarrow \kmkd{i'}{E'}}{\kmkd{i}{E}}}} &=& \kuprog{\kmkd{i}{E}} \cup \kuprog{\kmkd{i'}{E'}}\\
    && \text{if}~\kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{\kmkd{i'}{E'}}{\kmkd{i}{E}}}} = \emptyset\\
    \kuprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} &=& \kuprog{\kmkd{i}{E}}\\
    && \text{if}~\kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} = \emptyset\\

    \kuprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{s' \leftarrow \kmkd{i'}{E'}}{\kmkd{i}{E}}}} &=& \{x\} \cup \kuprog{\kmkd{i}{E}} \cup \kuprog{\kmkd{i'}{E'}}\\
    && \text{if}~\kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{\kmkd{i'}{E'}}{\kmkd{i}{E}}}} \neq \emptyset\\
    \kuprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} &=& \{x\} \cup \kuprog{\kmkd{i}{E}}\\
    && \text{if}~\kprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} \neq \emptyset\\
  \end{array}
  \]
  \caption{Needed-For-Progress-Upper Relation}
  \label{fig:neededforprogressupperrelation}
\end{figure}

\begin{figure}[H]
\[
  \begin{array}{rcll}
    \kiprog{n}      &=& \emptyset\\
    \kiprog{\kmkd{x}{s}} &=& \emptyset\\
    \kiprog{\kmkd{\kval}{(T_1~\dots~T_n)}} &=& \kiprog{T_1} \cup \dots \cup \kiprog{T_n}\\
    \kiprog{\kmkd{\kfresh}{(T_1~\dots~T_n)}} &=& \kiprog{T_1} \cup \dots \cup \kiprog{T_n}\\
    \kiprog{\kmkd{\katt{x}{y}}{(T_1~\dots~T_n)}} &=& \{y\} \cup \kiprog{T_1} \cup \dots \\
    && \cup~\kiprog{T_n}\\
    %comb
    \kiprog{\kmkd{x}{\kcomb{n}{s'}{\kmkd{i}{E}}{(s\dots)}{T}}} &=& \emptyset\\
    %prim-comb
    \kiprog{\kprim{n}{o}} &=& \emptyset\\
    %env
    \kiprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{s' \leftarrow \kmkd{i'}{E'}}{\kmkd{i}{E}}}} &=& \emptyset\\
    \kiprog{\kmkd{x}{\kenv{(s \leftarrow T)\dots}{}{\kmkd{i}{E}}}} &=& \emptyset\\
  \end{array}
  \]
  \caption{Needed-For-Progress-Resume-Infinite Relation}
  \label{fig:neededforprogressresumeinfiniterelation}
\end{figure}

\begin{figure}[H]
\[
  \begin{array}{rcll}
    lookup(s,&&\\\kenv{(s_1 \leftarrow V_1)(s_2 \leftarrow V_2)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}) &=& lookup(s,\kenv{(s_2 \leftarrow V_2)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}})\\
    lookup(s,\kenv{(s \leftarrow V)\dots}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}) &=& V\\
    lookup(s,\kenv{}{s \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}) &=& \kmkd{i_x}{E}\\
    lookup(s,\kenv{}{s' \leftarrow \kmkd{i_x}{E}}{\kmkd{i'_{x'}}{E'}}) &=& lookup(s,E')\\
  \end{array}
  \]
  \caption{lookup}
  \label{fig:lookup}
\end{figure}

\begin{figure}[H]
\[
  \begin{array}{rcll}
        %(cond   ((not (later_head? func_result)) (not (check_for_env_id_in_result env_id func_result)))
    returnOk(n,i) &=& \truev\\
    returnOk(o,i) &=& \truev\\
    returnOk(\kmkd{\emptyset}{s},i) &=& \truev\\
    returnOk(\kmkd{\kval}{(V\dots)},i) &=& \truev\\
    returnOk(\kmkd{i'}{C},i) &=& \lnot IDin(i,\kmkd{i'}{C})\\
    returnOk(E,i) &=& \lnot IDin(i,E)\\
    \\
        % special cases now
        %   *(veval body {env}) => (combiner_return_ok {env})
        %       The reason we don't have to check body is that this form is only creatable in ways that body was origionally a value and only need {env}
        %           Either it's created by eval, in which case it's fine, or it's created by something like (eval (array veval x de) de2) and the array has checked it,
        %           or it's created via literal vau invocation, in which case the body is a value.
        %       ((and (marked_array? func_result)
        %             (prim_comb? (idx (.marked_array_values func_result) 0))
        %             (= 'veval (.prim_comb_sym (idx (.marked_array_values func_result) 0)))
        %             (= 3 (len (.marked_array_values func_result)))
        %             (combiner_return_ok (idx (.marked_array_values func_result) 2) env_id))                                       true)

    returnOk(\kmkd{y}{(\kprim{-1}{veval}~z~\kmkd{i'_{x'}}{E})},i) &=& returnOk(\kmkd{i'_{x'}}{E},i)\\


        %   (func ...params) => (and (doesn't take de func) (foldl combiner_return_ok (cons func params)))
        %
        %       ((and (marked_array? func_result)
        %             (not (comb_takes_de? (idx (.marked_array_values func_result) 0) (len (.marked_array_values func_result))))
        %             (foldl (lambda (a x) (and a (combiner_return_ok x env_id))) true (.marked_array_values func_result)))         true)
    returnOk(\kmkd{y}{(f~V\dots)},i) &=& \lnot takesDE(f) \land \bigwedge returnOk(V,i)\dots\\
  \end{array}
  \]
  \caption{returnOk}
  \label{fig:returnok}
\end{figure}
IDin (fg. \ref{fig:idin}) is quite simple, but pulled out to make returnOk more readable:
\begin{figure}[H]
\[
  \begin{array}{rcll}
    IDin(x,i) &=& i \in \kprog{x} \lor i \in \kuprog{x}\\
  \end{array}
  \]
  \caption{IDin}
  \label{fig:idin}
\end{figure}
"takesDE" (fg. \ref{fig:takesDE}) is similarly simple, returning if the primitive or derived combiner takes in its dynamic environment.
\begin{figure}[H]
\[
  \begin{array}{rcll}
    takesDE(\kprim{0}{vau}) &=& \truev\\
    takesDE(\kprim{0}{if0}) &=& \truev\\
    takesDE(\kprim{-1}{vif0}) &=& \truev\\
      takesDE(\kprim{x}{y}) &=& \falsev & \text{(Other primitives don't)}\\
    takesDE(\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}) &=& s' \neq \emptyset\\
      takesDE(x) &=& \truev \quad& \text{(any other term, including suspended terms,}\\
               &&&\text{we count as true to be safe)}\\
  \end{array}
  \]
  \caption{takesDE}
  \label{fig:takesDE}
\end{figure}


dropRV handles two main cases - the first is a call to veval, which is removed if it is redundant (if the ID of the explicit environment matches the ID of the current dynamic environment).
The second is a suspended function call, which calls dropRV recursively on all parameters.
If this does change the call, then we re-partially evaluate it, as perhaps with simpler parameters it can now be evaluated further.

\begin{figure}[H]
\[
  \begin{array}{rcll}
    % if (veval x E) and E is not real, and E is current env, then
    % dropRedundentVeval(x, ...)
    dropRV(\kmkd{y}{(\kprim{-1}{veval}~z~\kmkd{i_f}{E})},\kmkd{i_x}{E},ES,FS) &=& dropRV(z,\kmkd{i_x}{E},ES,FS)\\
    &&(\text{only if}~y \neq \kval)\\
    \\

    % if (x y...) where x.level != -1, then z = map(dropRedundentVeval(x y...))
    % if z != (x y...) then [peval z] else z
    dropRV(\kmkd{y}{(\kprim{n}{o}~V\dots)}, \kmkd{i_x}{E},ES,FS) &=&\textbf{let}~g~=~(\kprim{n}{o}~V\dots)\\
                                                               &&\textbf{let}~z~=~(\kprim{n}{o}~dropRV(V,\kmkd{i_x}{E},ES,FS)\dots)~\textbf{in}\\
                                                               &&\kpval{\kmkd{\kfresh}{z},\kmkd{i_x}{E}}{\kmkd{i_x}{E}}{ES}{FS}~\textbf{if}~z~\neq g\\
                                                               &&\textbf{else}~\kmkd{y}{z}\\
    &&(\text{only if}~y \neq \kval, n \neq -1)\\

    dropRV(&&\\
         \kmkd{y}{(\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}~V\dots)},&&\\\kmkd{i_x}{E},ES,FS) &=& \textbf{let}~g~=~(\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}~V\dots)~\textbf{in}\\
                                                               &&\textbf{let}~z~=~(\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'_r}{E'}}{(s\dots)}{Tb}}\\&&\qquad\qquad\qquad dropRV(V,\kmkd{i_x}{E},ES,FS)\dots)~\textbf{in}\\
                                                               &&\kpval{\kmkd{\kfresh}{z},\kmkd{i_x}{E}}{\kmkd{i_x}{E}}{ES}{FS}~\textbf{if}~z~\neq g\\
                                                               &&\textbf{else}~\kmkd{y}{z}\\

    \\
    dropRV(z,\kmkd{i_x}{E},ES,FS) &=& z\quad\text{Otherwise, return unchanged}\\
  \end{array}
  \]
  \caption{dropRV}
  \label{fig:droprv}
\end{figure}

\begin{figure}[H]
\[
  \begin{array}{rcl}
    \kpcombine{\kprim{0}{eval}}{(V_1~V_2)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpcombine{\kmkd{i''}{\kprim{-1}{veval}}}{\\&&\qquad(\kunval{V_1}~V_2)}{\\&&\kmkd{i_x}{E}}{ES}{FS}\\
    \kpcombine{\kprim{-1}{veval}}{(V~\kmkd{i'_{x'}}{E'})}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow&\textbf{let}~V'~=\kpval{V}{\kmkd{i'_{x'}}{E'}}{(\kmkd{i'_{x'}}{E'} \cup ES)}{FS}~\textbf{in}\\&&\kunder{V'}{(\kprim{-1}{veval}~V'~\kmkd{i'_{x'}}{E'})}{\kmkd{i_x}{E}}{ES}{FS}\\
    \kunder{z}{(\kprim{-1}{veval}~V'~\kmkd{i'_{x'}}{E'})}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \textbf{let}~o = returnOk(z,i')~\textbf{in}\\
    &&dropRV(z,\kmkd{i_x}{E},ES)~\textbf{if}~o=\truev~\textbf{else}\\
    &&\kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{-1}{veval}~V'~\kmkd{i'_{x'}}{E'})}\\
    \\
      \kpcombine{\kprim{0}{vau}}{(s'~(s\dots)~V)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpval{\\&&\kmkd{genID()}{\kcomb{0}{s'}{\kmkd{i_f}{E}}{(s\dots)}{unval(V)}}\\&&}{\kmkd{i_{x}}{E}}{ES}{FS}\\
    \\
    \kpcombine{\kprim{0}{wrap}}{&&\\(\kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'}{E'}}{(s\dots)}{V}})}{\kmkd{i}{E}}{ES}{FS} &\rightarrow& \kmkd{i''}{\kcomb{(S~n)}{s'}{\kmkd{i'}{E'}}{(s\dots)}{V}}\\
    \kpcombine{\kprim{0}{unwrap}}{&&\\(\kmkd{i''}{\kcomb{(S~n)}{s'}{\kmkd{i'}{E'}}{(s\dots)}{V}})}{\kmkd{i}{E}}{ES}{FS} &\rightarrow& \kmkd{i''}{\kcomb{n}{s'}{\kmkd{i'}{E'}}{(s\dots)}{V}}\\
    \\
    \kpcombine{\kprim{0}{if0}}{(V_c~V_t~V_e)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow&
        \textbf{let}~F~=(\kprim{0}{if0}~V_c~V_t~V_e)\textbf{in}\\
      &&\textbf{let}~FS'~=\{F\} \cup FS~\textbf{in}\\
      &&\textbf{let}~V_c'~=\kpval{\kunval{V_c}}{\kmkd{i_x}{E}}{ES}{FS}~\textbf{in}\\
      &&\textbf{let}~V_t'~=\kunval{V_t}~\textbf{if}~F \in FS\\
      &&\qquad\quad\textbf{else}~\kpval{\kunval{V_t}}{\kmkd{i_x}{E}}{ES}{FS'}~\textbf{in}\\
      &&\textbf{let}~V_e'~=\kunval{V_e}~\textbf{if}~F \in FS\\
      &&\qquad\quad\textbf{else}~\kpval{\kunval{V_e}}{\kmkd{i_x}{E}}{ES}{FS'}~\textbf{in}\\
      &&\kunder{V_c'}{(\kprim{-1}{vif0}~V_c'~V_t'~V_e')}{\kmkd{i_x}{E}}{ES}{FS}\\
    \kunder{0}{(\kprim{-1}{vif0}~V'~V_t~V_e)}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpval{V_t'}{\kmkd{i_x}{E}}{ES}{FS}\\
    \kunder{(S~n)}{(\kprim{-1}{vif0}~V_c'~V_t'~V_e')}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kpval{V_e'}{\kmkd{i_x}{E}}{ES}{FS}\\
    \kunder{z}{(\kprim{-1}{vif0}~V_c'~V_t'~V_e')}{\kmkd{i_x}{E}}{ES}{FS} &\rightarrow& \kmkd{\katt{\emptyset}{\emptyset}}{(\kprim{-1}{vif0}~z~V_t'~V_e')}\\
    &&\quad\text{(otherwise for if)}\\
    \\
    \kpcombine{\kprim{0}{int-to-symbol}}{(n)}{E}{ES}{FS} &\rightarrow& \kmkd{\emptyset}{'sn} ~\text{(a symbol made out of the number n)}\\
    \kpcombine{\kprim{0}{array}}{(V\dots)}{E}{ES}{FS} &\rightarrow& \kmkd{\kval}{(V\dots)}\\
  \end{array}
\]
  \caption{Semantics of Partial Eval Primitives}
  \label{fig:partialevalrimitives}
\end{figure}
\pagebreak






\section{Partial Evaluation Pseudocode}

\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKwFunction{FRecurs}{PartialEval}%
\SetKwFunction{FRecursCall}{PartialEvalCall}%
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{fintq}%
\renewcommand{\forcond}{$i$ \KwTo\Range{$n$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%


\begin{algorithm}[H]
\footnotesize
\SetAlgoLined
\Fn(\tcc*[h]{}){\FRecurs{form, env, env\_stack, evaluating\_forms\_set}}{
\KwData{Our inputs are the current form to partially evaluate,\\
the env to evaluate it in,\\
the full call stack of currently active envs,\\
and the set of evaluations currently taking place.}
\KwResult{The partially evaluated form}
\tcc{First we check to see if we will make any progress by partially evaluating this form}
$not\_yet\_evaled \leftarrow \truev~\in?~\kprog{x}$\;
  $newly\_real\_env\_ids \leftarrow \exists~i~\in \kprog{x}~\text{s.t.}~\kmkd{i_x}{E}~\in~env\_stack $\;
$newly\_unblocked \leftarrow evaluating\_forms\_set ~\cap~\kiprog{x}\neq~\kiprog{x}$\;

\uIf(){$not\_yet\_evaled \lor newly\_real\_env\_ids \lor newly\_unblocked$}{
    \uIf{form is an env value, $\kmkd{i_x}{E}$}{
        \tcc{grab the newer real version of this env, if it exists}
        \uIf{$\kmkd{i_r}{E'} \in env\_stack$}{
            return $\kmkd{i_r}{E'}$
        }
        \uElse{
            return $\kmkd{i_x}{E}$\;
        }
    }
    \uElseIf{form is an derived-combiner value, $\kmkd{i}{\kcomb{n}{s}{\kmkd{i'_x}{E}}{(s\dots)}{Tb}}$}{
        \tcc{recurse on the combiner's static env and body}
        \uIf{$x~=?~r$}{
          return $\kmkd{i}{\kcomb{n}{s}{\kmkd{i'_x}{E}}{(s\dots)}{Tb}}$\;
        }
        \uElse{
            $new\_env \leftarrow \kenv{(s \leftarrow \kmkd{i}{s})\dots}{s' \leftarrow \kmkd{i}{s'}}{env}$\;
            $new\_body \leftarrow \FRecurs{$Tb, new\_env, new\_env~\cup~env\_stack, evaluating\_forms\_set$}$\;
            return $\kcomb{n}{s}{env}{(s\dots)}{new\_body}$\;
        }
    }
    \Else{
        \tcc{this is a call - broken out into Algorithm 2}
        return \FRecursCall{form, env, env\_stack, evaluating\_forms\_set}\;
    }
}
\uElse {
    \tcc{partial evaluation won't make any progress, just return form unchanged}
    return form\;
}
}
  \caption{Partial Evaluation Algorithm Pseudocode (except calls)}\label{algo:partialeval}
\end{algorithm}

\pagebreak

\begin{algorithm}[H]
\footnotesize
\SetAlgoLined
\Fn(\tcc*[h]{}){\FRecursCall{form, environment, environment\_stack, evaluating\_forms\_set}}{
\KwData{Our inputs are the current form to partially evaluate,\\
the environment to evaluate it in,\\
the full call stack of currently active environments,\\
and the set of evaluations currently taking place.}
\KwResult{The partially evaluated form}

\tcc{first partially evaluate the combiner}
$\kmkd{x}{(T_1~T_2\dots)} \leftarrow form$\;
$c \leftarrow \FRecurs{$T_1, env, env\_stack, evaluating\_forms\_set$}$\;
\tcc{If the result is a suspended symbol lookup or a suspended call, return since we can't make progress}
\If{$c = \kmkd{x}{s}\lor c = \kmkd{\katt{x}{y}}{(T'\dots)}$}{
  return $\kmkd{\katt{\emptyset}{\emptyset}}{(c~T_2\dots)}$\;
}
\tcc{Otherwise, c is a combiner, either primitive or derived. Get its wrap level}

\uIf{$c = \kprim{n}{o}$}{
    $wrap\_level \leftarrow n$
}
\Else{
  $\kmkd{i}{\kcomb{n}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}} \leftarrow c$\\
  $wrap\_level \leftarrow n$
}
    
\tcc{evaluate the the parameters until wrap\_level is 0 (or not at all if it is -1)}
$args \leftarrow (T_2\dots)$\\
\If{$wrap\_level > 0$}{
    $args \leftarrow ( \FRecurs{$T, env, env\_stack, evaluating\_forms\_set$}~\text{for}~T~\in args)$\;
    \If{any entry in args is not a value}{
        return $\kmkd{\katt{\emptyset}{\emptyset}}{(c~args\dots)}$\;
    }
    \Repeat{$wrap\_level = 0$}{
        $args \leftarrow ( unval(T)~\text{for}~T~\in args)$\;
        $args \leftarrow ( \FRecurs{$T, env, env\_stack, evaluating\_forms\_set$}~\text{for}~T~\in args)$\;
        \If{any entry in args is not a value}{
            $new\_c = replacewraplevel(c, wrap\_level)$\\
            return $\kmkd{\katt{\emptyset}{\emptyset}}{(new\_c~args\dots)}$\;
        }
    }
}
\uIf{$c = \kprim{n}{o}$}{
    return $drop\_redundant\_eval(o(env, env\_stack, args), env, env\_stack)$\;
}
\Else{
    \tcc{make our inner environment}
    $\kmkd{i}{\kcomb{n}{s'}{\kmkd{i'_{x'}}{E'}}{(s\dots)}{Tb}} \leftarrow c$\\
    $inner\_env \leftarrow \kmkd{i}{\kenv{(s \leftarrow V~\textbf{for}~(s,V) \in zip((s\dots), args)}{s' \leftarrow env}{\kmkd{i'_{x'}}{E'}}}$\;
    \tcc{Check if we're already evaluating this form, to prevent infinite recursion}
    $new\_c = replaceWrapLevel(c, wrap\_level)$\\
    \If{$(Tb,inner\_env) \in evaluating\_forms\_set$}{
        return $\kmkd{\katt{\emptyset}{(Tb,inner\_env)}}{(new\_c~args\dots)}$\;
    }
    $result \leftarrow \FRecurs{$Tb, inner\_env, \{inner\_env\}\cup env\_stack, \{(Tb,inner\_env)\} \cup evaluating\_forms\_set$}$\;
    \uIf{combiner\_return\_ok(result, env.id)} {
        return drop\_redundant\_eval(result, env, env\_stack)\;
    }
    \uElseIf{$s' \neq \emptyset$}{
        \tcc{If this combiner takes in the dynamic environment, track the current dynamic environment ID as needed for this call to progress}
        return $\kmkd{\katt{env.id}{\emptyset}}{(new\_c~args\dots)}$\;
    }
    \Else{
        return $\kmkd{\katt{\emptyset}{\emptyset}}{(new\_c~args\dots)}$\;
    }
}
}    
 \caption{Partial Evaluation Algorithm Pseudocode (for calls)}\label{algo:partialevalcall}
\end{algorithm}
