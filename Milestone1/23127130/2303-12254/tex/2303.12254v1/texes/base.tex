\section{\krakenSpace Language}
\label{sec:base}

As mentioned before, the proposed \krakenSpace language follows quite closely to John Shutt's definition of the pure Vau calculus (\cite{shutt2010fexprs}) augmented with explicit primitive data types and operations to create a more practical language.
Basing our language on the pure Vau calculus instead of the more complex calculi that form the basis of John Shutt's Kernel language makes the partial evaluation and optimization simpler and more feasible.
The main missing features from his complex calculi are mutation and continuations.
In order to keep our formalization understandable, we present a calculus simplified further from our real language that eliminates boolean values, varaidac parameters, and prunes down the builtin primitive combiners.
%The Functional-But-In-Place (FBIP) technique made possible by Perceus reference counting algorithms (\cite{reinking2021perceus}, \cite{lorenzenreference}) makes mutation-free programming efficient enough to be fully practical.

We start defining the \krakenSpace language by presenting its syntax, contexts, and small-step semantics before expounding upon the difference between its surface and internal syntax and semantics.

\subsection{Syntax}

\begin{figure}[h]
\[
  \begin{array}{rcll}
    n &\in& \mathbb{N}&\text{(Integers)}\\
    s &\in& Symbols&\\
    o &\in& \{\kprim{1}{eval}, \kprim{0}{vau},\kprim{1}{wrap}, \kprim{1}{unwrap},&\\
    &&\kprim{0}{if0}, \kprim{0}{vif0}, \kprim{1}{int-to-symbol},&\\
    &&\kprim{1}{symbol?}, \kprim{1}{int?}, \kprim{1}{combiner?},\kprim{1}{env?},&\\
    &&\kprim{1}{array?}, \kprim{1}{len}, \kprim{1}{idx}, \kprim{1}{concat},&\\
    &&\kprim{1}{+}, \kprim{1}{<=} \}&\text{(Primitive Operations)}\\
    E &:=& \kenv{(s \leftarrow T)\dots}{}{E} \alt \kenv{(s \leftarrow T)\dots}{s' \leftarrow E}{E} & \text{(Environments)}\\
    A &:=& (T \dots)& \text{(Arrays)}\\
    C &:=& \kcomb{n}{s'}{E}{(s\dots)}{T} & \text{(Combiners)}\\
    S &:=& n \alt o \alt E \alt C & \text{(Self evaluating terms)}\\
    V &:=& S \alt s \alt A & \text{(Values)}\\
    T &:=& V \alt AT & \text{(Terms)}\\
    AT &:=& \keval{T}{E} \alt \kcombine{T}{(T\dots)}{E} & \text{(Active terms)}\\
  \end{array}
  \]
  \caption{Syntax of the Base Language}
  \label{fig:basesyntax}
\end{figure}

The surface syntax of the language (Fig. \ref{fig:basesyntax}) consists of arrays of symbols and integers.
The internal syntax includes both primitive and derived combiners, environments, and actively-executing terms.
It is this split between surface syntax and internal syntax that permits a non-trivial theory \cite{shutt2010fexprs}.

\subsection{Contexts}
\begin{figure}[h]
\[
  \begin{array}{rcl}
    \Ctxt &:=& \square \alt \kcombine{\Ctxt}{(T\dots)}{E} \alt \kcombine{T}{(\Ctxt,T\dots)}{E}\\
    && \alt \kcombine{T}{(T\dots,\Ctxt,T\dots)}{E} \alt \kcombine{T}{(T\dots,\Ctxt)}{E}\\
  \end{array}
\]
  \caption{Contexts of the Base Language}
  \label{fig:basecontexts}
\end{figure}

The contexts for evaluation in our base calculus (Fig. \ref{fig:basecontexts}) define the holes where current evaluation must take place - namely, either evaluating the head of an array to find the combiner to call, or evaluating parameters before calling combiner.

\subsection{Small-Step Semantics}
\begin{figure}[h]
\[
  \begin{array}{rcl}
    \InCtxt{E}    &\rightarrow& \InCtxt{E'} ~ (\text{if } E \rightarrow E')\\
    \keval{S}{E}  &\rightarrow& S\\
    \keval{s}{E}  &\rightarrow& lookup(s,E)\\
    \keval{(T_1~T_2\dots)}{E}  &\rightarrow& \kcombine{\keval{T_1}{E}}{(T_2\dots)}{E}\\
    \\
    \kcombine{\kcomb{(S~n)}{s'}{E'}{(s\dots)}{Tb}}{(V\dots)}{E} &\rightarrow& \kcombine{\kcomb{n}{s'}{E'}{s}{Tb}}{\\&&\keval{V}{E}\dots}{E}\\
    \kcombine{\kcomb{0}{s'}{E'}{(s\dots)}{Tb}}{(V\dots)}{E} &\rightarrow& \keval{Tb}{\kenv{(s \leftarrow V)\dots}{s' \leftarrow E}{E'}}\\
    \\
    \kcombine{\kprim{(S~n)}{o}}{(V\dots)}{E} &\rightarrow& \kcombine{\kprim{n}{o}}{(\keval{V}{E}\dots)}{E}\\
  \end{array}
\]
  \caption{Semantics of the Base Language}
  \label{fig:basesemantics}
\end{figure}

Our small-step semantics (Fig. \ref{fig:basesemantics}) provides the evaluation steps for calls, symbols, and values. \krakenSpace evaluates self-evaluating values to themselves and symbols to the lookup of the symbol within the current environment.
The most interesting case is calls because it requires the first element of the array to be evaluated first resulting in a combiner. 

How the call proceeds after obtaining the combiner to be called depends on the "wrap level" and type of combiner.
This "wrap level" designates how many times the arguments to the combiner should be evaluated, and the semantics encodes evaluating the arguments that many times, enforcing that a combiner will have a "wrap level" of 0 (decremented every time the parameters are evaluated) before being called.
As we mentioned earlier, a combiner with a wrap level of 1 is an applicative, equivalent to functions in other languages.
The combiner can be either primitive (built into the language) or derived (created by the user with a call to \textit{vau}).
A derived combiner's body is evaluated in a new environment that maps the parameter symbols to the actual arguments, including mapping a special symbol to the current dynamic call environment, and chains up to the existing static environment stored within the derived combiner. The primitive combiners are explained more in the next section.

\subsection{Small-Step Semantics (selected primitives)}
\begin{figure}[h]
\[
  \begin{array}{rcl}
    \kcombine{\kprim{0}{eval}}{(V~E')}{E} &\rightarrow& \keval{V}{E'}\\
    \kcombine{\kprim{0}{vau}}{(s'~(s\dots)~V)}{E} &\rightarrow& \kcomb{0}{s'}{E}{(s\dots)}{V}\\
    \kcombine{\kprim{0}{wrap}}{\kcomb{0}{s'}{E'}{(s\dots)}{V}}{E} &\rightarrow& \kcomb{1}{s'}{E'}{(s\dots)}{V}\\
    \kcombine{\kprim{1}{unwrap}}{\kcomb{1}{s'}{E'}{(s\dots)}{V}}{E} &\rightarrow& \kcomb{0}{s'}{E'}{(s\dots)}{V}\\
    \kcombine{\kprim{0}{if0}}{(V_c~V_t~V_e)}{E} &\rightarrow& \kcombine{\kprim{0}{vif0}}{\\&&(\keval{V_c}{E}~V_t~V_e)}{E}\\
    \kcombine{\kprim{0}{vif0}}{(0~V_t~V_e)}{E} &\rightarrow& \keval{V_t}{E}\\
    \kcombine{\kprim{0}{vif0}}{(n~V_t~V_e)}{E} &\rightarrow& \keval{V_e}{E} ~\text{(n != 0)}\\
    \kcombine{\kprim{0}{int-to-symbol}}{(n)}{E} &\rightarrow& 'sn ~\text{(symbol made out of the number n)}\\
    \kcombine{\kprim{0}{array}}{(V\dots)}{E} &\rightarrow& (V\dots)\\
  \end{array}
\]
  \caption{Semantics of Base Language Primitives}
  \label{fig:baseprimitives}
\end{figure}
%The primitive combiners have particular small-step semantics within our language.  The main primitives with fixed semantics are eval, vau, wrap, unwrap, if, vif, int-to-symbol, and array:  
The semantics of the most important primitive combiners are given in Fg. \ref{fig:baseprimitives}, but are additionally described here in English for clarity:
\begin{itemize}
    \item $\kprim{0}{eval}$: evaluates its argument in the given environment.
    \item $\kprim{0}{vau}$: creates a new combiner and is analogous to lambda in other languages, but with a "wrap level" of 0, meaning the created combiner does not evaluate its arguments.
    \item $\kprim{0}{wrap}$: increments the wrap level of its argument. Specifically, we are "wrapping" a "wrap level" n combiner (possibly "wrap level" 0, created by \textit{vau}) to create a "wrap level" n+1 combiner. A wrap level 1 combiner is analogous to regular functions in other languages.
    \item $\kprim{0}{unwrap}$: decrements the "wrap level" of the passed combiner, the inverse of \textit{wrap}.
    \item $\kprim{0}{if}$: evaluates only its condition and converts to the $\kprim{0}{vif}$ primitive for the next step. It cannot evaluate both branches due to the risk of non-termination.
    \item $\kprim{0}{vif}$: evaluates and returns one of the two branches based on if the condition is non-zero. 
    \item $\kprim{0}{int-to-symbol}$: creates a symbol out of an integer.
    \item $\kprim{0}{array}$: returns an array made out of its parameter list.
\end{itemize}
% The $\kprim{0}{eval}$ primitive evaluates it's argument in the given environment.
% The $\kprim{0}{vau}$ primitive creates a new combiner and is analogus to lambda in other languages, but with wrap level 0 - that is, the created combiner does not evaluate its arguments.
% $\kprim{0}{wrap}$ primitive increments the wrap level of its argument - in this way, by "wrapping" a wrap level 0 combiner created by vau a wrap level 1 combiner, anlogous to regular functions in other languages, is created.
% $\kprim{0}{unwrap}$ inverts this, decrementing the wrap level of a combiner.
% $\kprim{0}{if}$ mostly works as one would expect, but as it cannot evaluate all of its arguments for fear of non-termination, it first evaluates its condition and indirects through $\kprim{0}{vif}$ which represents an if with the condition already evaluating.
% $\kprim{0}{vif}$ then finishes the job by evaluating one of its two branches based on if its condition is non-zero.
% Finally, $\kprim{0}{int-to-symbol}$ creates a symbol out of an integer, and $\kprim{0}{array}$ returns an array made out of its parameter list.


The less interesting primitives we just describe here:
%We have other primitives that could have been defined as derived combiners but decided to push them into the language to make them faster. Most of these primitives are used on the array. These are tests, len, idx, concat, +, <=:
\begin{itemize}
  \item $\kcombine{\kprim{0}{type-test?}}{(A)}{E}$: \textit{array?}, \textit{comb?}, \textit{int?}, and \textit{symbol?}, each return 0 if the single argument is of that type, otherwise they return 1.
    \item $\kcombine{\kprim{0}{len}}{(A)}{E}$: returns the length of the single array argument.
    \item $\kcombine{\kprim{0}{idx}}{(A~n)}{E}$: returns the nth item array A.
    \item $\kcombine{\kprim{0}{concat}}{(A~B)}{E}$: combines both array arguments into a single concatenated array.
    \item $\kcombine{\kprim{0}{+}}{(A~A)}{E}$: adds its arguments
    \item $\kcombine{\kprim{0}{<=}}{(A~A)}{E}$: returns 0 if its arguments are in increasing order, and 1 otherwise.
\end{itemize}
% The remaining primitive functions not listed are pretty simple - the predicate tests return 0 if the single argument is of that type, otherwise they return 1.
% $\kcombine{\kprim{0}{len}}{(A)}{E}$ returns the length of it's single array argument.
% $\kcombine{\kprim{0}{idx}}{(A~n)}{E}$ returns the nth item in array A.
% Concat combines its array arguments into a single concatenated array.
% $\kprim{0}{+}$ sums its arguments, $\kprim{0}{<=}$ returns 0 if its arguments are in increasing order, and 1 otherwise.

\subsection{Base Language Summary}
This base calculus defined above is not only capable of normal lambda-calculus computations with primitives and derived user applicatives, but also supports a superset of macro-like behaviors via its support for operatives.
All of the advantages listed in the introduction apply to this calculus, as do the performance drawbacks, at least if implemented naively. Our partial evaluation and compilation framework will demonstrate how to compile this base language into reasonably performant binaries (WebAssembly bytecode, for our prototype).
