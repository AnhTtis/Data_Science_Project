\section{Related Work}
\label{sec:relatedwork}

The focus of this paper has been on efficient fexpr language implementation using partial evaluation.


\textbf{Other Fexpr Implementations:}

Aside from NewLisp~\cite{mueller2018newlisp}, picoLisp~\cite{burger2013picolisp} also includes fexprs as a language feature.
Similar to NewLisp, picoLisp is a dynamic and interpreted language and does no special optimization of fexprs. Like NewLisp, most forms in picoLisp are implemented in the interpreter itself instead of being built up from smaller components, as is common to do with macros in other Lisps that use macros.
While both of these languages originally lacked a macro implementation, NewLisp eventually added one due to the confusing evaluation rules and performance problems caused by its fexprs.

However, John Shutt demonstrated in his 2010 thesis \cite{shutt2010fexprs} that if fexprs are re-formulated divorced from their historical context and co-existence with other now-extinct language features, like dynamic scoping, they can be an elegant and well-behaved alternative to macros. It is important, however, that the language be designed with this in mind from the start. We have additionally shown that the performance problems that have plagued fexprs are solvable, fixing the other main issue that has kept fexprs from common usage.

\textbf{Partial Evaluation:}

Our work's main contribution is the partial evaluation scheme that provides the basis for the performance improvement of our fexpr implementation.
Partial evaluation has been around for many years, including during the early years of Lisp \cite{lombardi1964lisp}, and is utilized in many languages.
Jones~\cite{10.1145/243439.243447} and Charles \& Olivier~\cite{10.1145/158511.158707} provide a high-level look at partial evaluation and its history in the community and explain well the differences between online and offline techniques.
Ruf provides details of interesting online partial evaluation techniques in his thesis~\cite{ruf1993topics}, and Sperber \& Thiemann~\cite{10.1145/249069.231419}~give a description of the technique of using static data descriptions as a stand in for dynamic data in their paper on compilation using partial evaluation, which is similar to our handling of partially-static-data environments.
Danvy, Malmkj{\ae}r, and Palsberg use eta-expansion as a part of partial evaluation in their implementation of "The Trick" in \cite{danvy1996eta}, whereas we use it during compilation to optimize the remnents of the Y-Combiner.
Partial evaluation's application is broad, having been utilized for many imperative languages like C~\cite{andersen1992self}, Matlab~\cite{elphick2003partial} and Pascal~\cite{meyer1991techniques}, as well as for other programming paradigms, such as logic programming, where Lloyd \& Sheperdson~\cite{LLOYD1991217} provided a theoretical foundation that got expanded by Alpuente et al~\cite{alpuente1998partial}.
Romph et al. use partial evaluation/staging to optimize data structures in Scala in \cite{rompf2013optimizing}, Sperber \& Thiemann further use partial evaluation in the generation of LR parsers in \cite{sperber2000generation}, and Sestoft uses partial evaluation to compile efficient ML pattern matching \cite{sestoft1996ml}.

% Here we list all references to making a Kernel/Vau calculus/f-expr based language efficient that we found:
% \begin{itemize}
%     \item{} Axis of Eval list of 22 attempted implementations - \url{https://axisofeval.blogspot.com/2011/09/kernel-underground.html} \\ 
%       None doing partial evaluation, to my knowledge. I believe all abandoned or link-rotted with the seeming exception of \url{https://github.com/rocketnia/fexpress},
%       which is taking a very different approach (Lisp-2, explicit apply form, etc) in Racket.
%     \item{} Lambda The Ultimate small discussion of partial eval for Vau/Kernel - \url{http://lambda-the-ultimate.org/node/4346}
%     \item{} Implementing a Vau-based Language With Multiple Evaluation Strategies - \cite{kearsleyimplementing} \\
%       Talks about how partial evaluation could make efficient, doesn't do it.
%     \item{} Google Groups email thread by Andres Navarro - \url{https://groups.google.com/g/klisp/c/Dva-Le8Hr-g/m/pyl1Ufu-vksJ} \\
%       Andres Navarro talks about his experimental fklisp which is a "very simple functional dialect of Kernel" with no mutation or first class continuations.
%       It doesn't compile anything, but prints out the partially evaluated expression. Was a work in progress, ran into performance problems, seems abandoned.
% \end{itemize}

% We were unable to find any active or successfully attempts at making a language based on f-exprs practical.
