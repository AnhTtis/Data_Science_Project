\section{Compilation Strategies}

\subsection{Using Three-Qubit Gates}
In our qubits-on-ququarts compilation strategy, we expand the physical connectivity graph between the ququarts on a given architecture and treat each ququart as two connected qubits.  Each qubit in the expanded ququart is fully connected to the qubits in the neighboring ququarts as shown in Figure \ref{fig:mixed-radix-and-full-encoded}.  We call this new graph the interaction graph; it maintains a mapping of where circuit qubits are mapped to on this graph. When one or fewer of the qubits in the expanded ququart is mapped to, the entire ququart is in a qubit state. Otherwise, it is considered to be in the ququart state.

To execute three-qubit gates, circuit qubits must be routed into a connected subgraph of the interaction graph, e.g. for CCZ$(q_0, q_1, q_2)$ requires $q_0\sim q_1$ and $q_1\sim q_2$ but it is not guaranteed that $q_0\sim q_2$, where $\sim$ defines adjacency. We develop a compiler optimization which appropriately performs routing and gate selection based on this adjacency and use of higher dimension. While we are able to perform any configuration of three qubit gates directly in mixed-radix or full-ququarts scenarios, we take care to use best configurations to minimize time in the less stable $\ket{2}$ or $\ket{3}$ states.

\subsubsection{Qubit-Only}
In a qubit-only regime we can use a decomposition into eight CX operations \cite{shende_cnot-cost_2008}.  This decomposition has the flexibility of being target-independent from a compilation standpoint.
%We simply surround the target qubit with Hadamard gates, similar to a CCZ gate. 
This is an expensive compilation, requiring eight two-qubit gates and 14 one-qubit gates.  But, it does not use the less stable $\ket{2}$ and $\ket{3}$ state.  Alternatively, we can use a directly-optimized three-qubit pulse sequence. QOC software failed to find a solution for a direct CCZ operation, so we synthesize a pulse implementing the $i$Toffoli gate using a three-qubit version of our quantum optimal control software that only uses the first two levels of the qubits and use the decomposition shown in Figure \ref{fig:toffoli_decomp}d inspired by \cite{kim_high-fidelity_2022} to execute a complete Toffoli gate.

\begin{figure}
    \centering
    \scalebox{0.9}{
        \input{figures/toffoli-decomp.qcircuit}
     }
     \caption{Different decompositions for the Toffoli Gate. a) is the base Toffoli circuit. b) is Toffoli circuit with a swapped second control and target from the original.  By surrounding the control and the target with Hadamards, we perform the same operation. c) The Toffoli gate constructed from a CCZ gate which can be used as a Toffoli by surrounding the target with Hadamard gates. (d) The Toffoli gate constructed from an iToffoli gate, which requires an controlled $S^\dagger$ gate in addition to Hadamard gates.}
    \label{fig:toffoli_decomp}
    \vspace{-0.5em}
\end{figure}

\subsubsection{Intermediate Mixed-Radix}
We also permit \textit{temporary} use of the higher energy levels to perform an operation.  By performing an encoding gate (ENC) followed by the three-qubit gate and a final decode (ENC$^\dagger$) operation, we get temporary access to full connectivity to perform fast three-qubit gates.

The compiler should opt to encode qubits of similar \textit{type}, i.e. both controls together or both targets together. Let $U(q_0, q_1, q_2)$ be the operation with $q_0, q_1$ the same (either both controls or both targets). In some cases, encoding is simple because the routing strategy (prior work) results in $q_0\sim q_1$ as in  \ref{fig:three-qubit-configs}(a). However, it may fail to do this by default and we may have $q_0\sim q_2$ and $q_1\sim q_2$ as in \ref{fig:three-qubit-configs}(b). 

We have three options to compile to a favorable configuration.  First, we could enforce the ideal relationship through additional gates by adding an additional SWAP($q_0$, $q_2$). Second, in the special case where $U = X$ Toffoli we can change which pair is the same type with Hadamard gates as in Figure \ref{fig:toffoli_decomp}b to use the most efficient implementation; we call this \textit{re-targeting}. Third, if $U$ permits, we transform $U$ into $U'$ so that $q_0, q_1, q_2$ are all the same type; for example we transform CCX to CCZ so each operand is a ``control,'' Figure \ref{fig:toffoli_decomp}c. While the additional re-targeting or transformation gates add both error and duration, they enable the shortest duration version of $U$ to be used for an overall net increase in fidelity. We consider the special cases of $U \in \{CCV | V \in SU(2)\}$, i.e the set of locally equivalent gates to $CCX$. We leave the generalized case to future work in circuit synthesis.


\subsubsection{Full Ququart}
Mixed-radix three-qubit gate strategies apply for full-ququart compilation as well. However, the router by default, described below, does not distinguish control or target. When executing three-qubit gates, we ensure only qubits of the same type are encoded if it does not require an extra swap operation.

\subsection{Mapping and Routing}
Our compilation for encoded qubits on ququart architectures is similar to previous compilation strategies for qubits as seen in many previous works \cite{cowtan_qubit_2019, murali_noise-adaptive_2019, duckering_orchestrated_2021} and adapts them to three-qubit gates on ququart architectures.  However, unlike these prior works, we take into account the varying fidelities and durations of internal ququart versus mixed-radix versus full-ququart inter-ququart gates, similar to \cite{litteken_communication_2022}.

The first step is to decompose the operations in the circuit to native gates supported by the device. Our compiler handles the native execution of three-qubit gates, we decompose to the CX, CCX, CCZ or CSWAP along with a parameterized single-qubit rotation gate.

Qubits are mapped onto the interaction graph with the goal of maximizing locality.  We assign a weight between each pair of qubits in the original circuit according to: $w(i, j) = \sum_{t \in C} o(i, j, t)/{t}$, where the sum is over each time step $t$ in the circuit $C$ and $o(i, j, t) = 1$ if qubits $i, j$ interact in time step $t$ and $0$ otherwise. This weight includes lookahead functionality by weighting future interactions (larger $t$) smaller. 
%This adds a weighted value that decreases as the time step $t$ in the circuit increases if the qubits interact during time step $t$ as determined by $o(i, j, t)$. 
The first qubit is mapped according to which has greatest total weight to all other qubits: \\ $\underset{i}{\text{argmax}} W(i) = \sum_{j \in Q_c / \{i\}} w(i, j)$.  This qubit is placed in the first encoded location of the center-most qudit on the connection graph.  For each other qubit, we choose the circuit qubit that has the greatest $W$ with respect to the placed qubits.  For each adjacent qubit, $n$, to the placed qubits, we compute $\sum_{j \in Q_P} w(i, j) d(n, \varphi(j))$ where $\varphi$ is the mapping of circuit qubits to physical qubits, and $d$ is a specialized fidelity function between the qubits estimating the possibility of error along the communication path.  We then map the qubit to the minimizing location.

When routing, we track the circuit qubits on the interaction graph and use SWAP gates until the interacting qubits are adjacent. We attempt to disrupt advantageous qubit layouts as little as possible by using adaptive weights that change as operations are scheduled based on \cite{baker_time-sliced_2020}.  This strategy attempts to keep qubits interacting in the near future close to one another where the disruption of each potential SWAP between circuit qubits $i, j$ is calculated by $D(i, j) = \sum_{k \in Q_c} w(i, k) (d(\varphi(i), \varphi(k)) - d(\varphi(j), \varphi(k))) +  w(j, k) (d(\varphi(j), \varphi(k)) - d(\varphi(i), \varphi(k)))$. However, rather than using simple distances, we use the same specialized distance metric incorporating the previous function $d$.  We choose the SWAP candidate that minimizes this value while always moving the qubit closer to the other qubits it needs to interact with.  To generalize to three-qubit based routing we modify the cost function to $C(i) = \sum_{j \in Q_o / i}D(i, \varphi^{-1}(n)) (d(\varphi(i), \varphi(j)) - d(n, \varphi(j))$  where $Q_o$ is now a set of all operands.

It would be reasonably simple to extend this compiler design to accomodate k-qubits on n-d-level-qudits, where we pack each qudit with $log_2(d)$ qubits, and ensure that there is no way to move any one qubit closer to another in a fully connected set of qubits. However, we only explore three-qubit gates on a maximum of two, four-level devices, or three, two-level devices in this work.  This is for design and practical reasons.  From a design point of view, our gate set and compiler are intended to be used after a circuit has been translated into qubit-based gates. Compiling natively to higher-radix qudit operations would require a much larger set of basis gates than the qubit-based set we use here.  Additionally, there is not a standard set of four-or-more qubit gates that are typically used in circuits, meaning there would have to be some arbitrary decomposition to four-qubit gates, rather than three qubits.  Choosing a basis gate set is a time intensive process and has to be done selectively \cite{gokhale_optimized_2020}. We therefore expand the normal one and two-qubit framework used in many compilers to include the most commonly used three-qubit gates as it is the most common multi-qubit gate.

It should be noted that all translation to higher-radix devices occurs during this compilation step.  The general programmer still writes a program in terms of qubits.  The compiler translates the program into the correct sequence of qubit-on-ququart operations to perform the same computation.  In the case of full-ququart operation, the measured state would be decoded according to the compression strategy.