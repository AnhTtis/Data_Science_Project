\begin{figure*}[htb]
\centering
\begin{minipage}{0.64\linewidth}
\includegraphics[width=\linewidth]{Figure/evaluation_circuit.pdf}
\end{minipage}
~
\begin{minipage}{0.32\linewidth}
\includegraphics[width=\linewidth]{Figure/evaluation_sim_result.pdf}
\end{minipage} \\[1mm]
\begin{minipage}{0.62\linewidth}
\centering
(a)
\end{minipage}
~
\begin{minipage}{0.32\linewidth}
\centering
(b)
\end{minipage}
\caption{The quantum circuit of solving formula $\mathcal{F}$ and the simulation result}
\label{fig:evaluation_circuit}
\end{figure*}

\section{Evaluation} \label{sec:Evaluation}

In this section, we demonstrate our quantum circuit design for solving a $\mathcal{BV}$ SMT formula $\mathcal{F}$, whose Boolean abstract formula is
\[
\mathcal{F}_B: (x \vee y \vee z) \wedge (x \vee \neg y \vee z)
\]
with atom $x: (a + b < a \oplus b)$, $y: (a + b > a \oplus b)$, and $z: (a + b = 1)$, where variables $a$, $b$, $c$ are all $2$-bit long; `$+$' is the modulo-sum operation and `$\oplus$' is the exclusive-or operation.

% $F_{SMT} = ((a + b < a \oplus b) \vee (a + b > a \oplus b) \vee (a + b = 1)) \wedge ((a + b < a \oplus b) \vee \neg (a + b > a \oplus b) \vee (a + b = 1))$

% \begin{figure}[tb]
%     \centering
%     \includegraphics[width=\linewidth]{Figure/evaluation_circuit.pdf}
%     \caption{The quantum circuit of solving formula $\mathcal{F}$.}
%     \label{fig:evaluation_circuit}
% \end{figure}



Fig.~\ref{fig:evaluation_circuit}~{(a)} shows the block diagram of the quantum SMT solver for formula $\mathcal{F}$, in which only important qubits are shown. Internal qubits of each module are omitted. Although the SAT and theory (arithmetic + comparator) circuit are drawn sequentially in the diagram, they can operate in parallel in the realistic implementation since there are no dependency between them.
The main inputs are the three Boolean abstract variables $x, y, z$ and SMT variables $a$, $b$. They are placed in superposition by the Hadamard gate initially. To solve formula $\mathcal{F}$, two comparators are required. Comparator one is responsible for the relation between $(a + b)$ and $(a \oplus b)$, while comparator two is for $(a + b)$ and the constant $1$.

\begin{table}[tb]
\footnotesize
	\begin{center}
		\caption{List of qubits contain in circuit for solving $\mathcal{F}$}
		\label{tb:qubit_list}
		\begin{tabular}{ | c | c | c |}\hline
			Module & Qubit name & Amount \\ \hline
			\multirow{5}{*}{SMT} & Boolean abstract variable & 3 \\ \cline{2-3}
			& SMT variables & 2*2 \\ \cline{2-3}
		    & ancilla qubits & 5 \\ \cline{2-3}
		    & SMT output & 1 \\ \cline{2-3}
		    & addition qubit & 1 \\ \hline
		    \multirow{2}{*}{SAT} & SAT output & 1 \\ \cline{2-3}
		    & extra qubits & 2 \\ \hline
		    Adder & adder output & 3 \\ \hline
		    Bitwise XOR & bitwise XOR output & 2 \\ \hline
		    \multirow{3}{*}{Comparator 1 \& 2} & comparator output & 2*2 \\ \cline{2-3}
		    & comparator internal output & (2-1)*2*2 \\ \cline{2-3}
		    & comparator ancilla & 1*2 \\ \hline
		\end{tabular}
	\end{center}
\end{table}

% Since there are unused ancilla qubits at this point and it is easy to reverse back to the original condition, we use two ancilla qubits with two $NOT$ gates to implement the constant $1^{[2]}$ and restore them after the computation of Comparator 2. 
% The circuit of comparator 1 is shown in Figure \ref{fig:evaluation_cmp1} and the bottom two qubits are the so-called internal output of comparator.

% \begin{figure}[tb]
%     \centering
%     \includegraphics[width=\linewidth]{Figure/evaluation_cmp1.pdf}
%     \caption{The comparator 1 circuit of $F_{SMT}$ solving circuit.}
%     \label{fig:evaluation_cmp1}
% \end{figure}


% For the next module, the consistent extract circuit will link those two parts together to find the theory consistent assignments. 
% In order to reduce the qubits usage, instead of placing specific qubits $| atom \rangle$ as mentioned in section \ref{subsec:extract&inverse}, we connect the target qubit of the $CCNOT$ gate to the Boolean abstract variable directly and it outputs the same result as connecting $| atom \rangle$ and Boolean abstract variable through an extra $CNOT$ gate. 
% The proof of equality and disequality cases are shown below, where $B$ represents the Boolean abstract variable.\\
% For $a = b$, when $atom = B$, output $= (|\neg O_1 \wedge \neg O_2\rangle) \oplus B$ \\
% For $a \neq b$, when $atom = B$, output $= (|\neg O_1 \wedge \neg O_2\rangle) \oplus \neg B = (|\neg O_1 \wedge \neg O_2\rangle) \oplus 1 \oplus B = (|O_1 \vee O_2\rangle) \oplus B$ \\
% For the other four cases, the extraction result can be provided by one $CNOT$ gate with the corresponding qubit pair as its input. 
% The consistent extract circuit of this example circuit is shown in Figure \ref{fig:evaluation_consistent_extract}

% \begin{figure}[tb]
%     \centering
%     \includegraphics[width=0.8\linewidth]{Figure/evaluation_consistent_extract.pdf}
%     \caption{The consistent extract circuit of $F_{SMT}$ solving circuit.}
%     \label{fig:evaluation_consistent_extract}
% \end{figure}


% Finally, one $(n+1)-CNOT$ gate will provide the evaluation result for the SMT formula, where $n=3$ in this demo case, and then the $control-Z$ gate will apply phase inversion to the satisfiable assignments. 
% By adding the reverse circuit after that, the oracle circuit is accomplished.
% The last part of Grover’s algorithm is the diffusion function. 
% According to our purpose, the search database is constructed by Boolean abstract variables (i.e. $x,y,z$), SMT variables (i.e. $a^{[2]}, b^{[2]}$) and additional qubit (i.e. $q_{addition}$), so those three parts of qubits will be the inputs of diffusion circuit.


% \subsection {Simulation result}

The circuit was implemented and simulated in Qiskit~\cite{GT19}. The whole circuit requires $32$ qubits, which already reaches the maximum number of qubits that Qiskit supports. The breakdown of the qubits required is listed in Table~\ref{tb:qubit_list}.
The simulation result, as shown in Fig.~\ref{fig:evaluation_circuit}~{(b)}, was obtained by performing five Grover iterations as one shot, repeated for $1,024$ shots to get $1,024$ measurements. 
One may wonder how we get the required number of iterations (i.e., $\frac{\pi}{4}\sqrt{N/M}$, c.f.~Section~\ref{sec:Preliminary}) for performing Grover's algorithm. Actually, this number could be obtained by quantum counting~\cite{BH98}. However, the avaliable $32$ qubits supported by Qiskit are not sufficient to perform quantum counting for this circuit. Thus, we started from one iteration and increased the number until the probability distribution of the measurements started to get worse. The turning point that we got is five, for this experiment. Actually, we have manually calculated the value of $\frac{\pi}{4}\sqrt{N/M}$ by enumerating the search space and the solutions. We found that it is consistent with the number, five.

As shown in Fig.~\ref{fig:evaluation_circuit}~{(b)}, we can observe six bit-strings with a higher probability compared to others. Table~\ref{tb:evaluation_solutions} interprets the six bit-strings back to the assignments of five main variables $x$, $y$, $z$, $a$, $b$. They are exactly the solutions to formula $\mathcal{F}$. 
The “Counts” column represents how many times the assignment was measured among the $1,024$ shots. According to the simulation result, our circuit provides a $99.32\%$ (the summation of ``Counts'' divided by $1024$) of probability of measuring the solutions. In addition, it is possible to obtain all the solutions within a reasonable number of measurement shots. 
% The detailed implementation in Qiskit can be found in [XXX]. \lsw{Create an anonymous to host our detailed figures.}

% \begin{figure}[tb]
%     \centering
%     \includegraphics[width=0.65\linewidth]{Figure/evaluation_sim_result.pdf}
%     \caption{The simulation result (probability distribution) for $\mathcal{F}$}
%     \label{fig:evaluation_sim_result}
% \end{figure}

\begin{table}[tb]
\scriptsize
% \footnotesize{}
	\begin{center}
		\caption{Solutions of $\mathcal{F}$ obtained by quantum circuit}
		\label{tb:evaluation_solutions}
		\begin{tabular}{ | c | c | c | c | c |}\hline
			Output & \multirow{2}{*}{Counts} & \multicolumn{3}{c|}{Assignments} \\ \cline{3-5}
			bit-string & & $(x,y,z)$ & $a$ & $b$ \\ \hline
			$0010100$   &   $174$  & $(0,0,1)$     & $01$  & $00$ \\ \hline
			$0011110$   &   $158$  & $(0,0,1)$	    & $11$ 	& $10$ \\ \hline
			$0010001$   &   $183$  & $(0,0,1)$		& $00$ 	& $01$ \\ \hline
			$1001101$   &   $156$  & $(1,0,0)$		& $11$ 	& $01$ \\ \hline
			$0011011$   &   $164$  & $(0,0,1)$		& $10$ 	& $11$ \\ \hline
			$1000111$   &   $182$  & $(1,0,0)$		& $01$ 	& $11$ \\ \hline
		\end{tabular}
	\end{center}
\end{table}
