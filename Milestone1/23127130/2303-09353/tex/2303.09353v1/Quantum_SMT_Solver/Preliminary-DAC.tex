\section{Preliminary} \label{sec:Preliminary}

We assume that our readers have basic concepts in quantum computing, e.g., the {\em tensor product} operation, {\em inner product} operation, {\em outer product} operation, and primitive quantum gates such as $\mathtt{X}$, $\mathtt{Z}$, $\mathtt{H}$, $\mathtt{CCNOT}$, etc. We use the {\em ket} notation $|\cdot \rangle$ to denote the (column) vector representing the state of a quantum system, and the {\em bra} notation $\langle \cdot |$ to denote its conjugate transpose. Given two vectors $|v_1\rangle$ and $|v_2\rangle$, we use $\langle v_1 | v_2 \rangle$ to denote their inner product, $|v_1\rangle \langle v_2|$ for their outer product, and $|v_1\rangle \otimes |v_2\rangle$ for their tensor product. For simplicity, we may write $|v_1\rangle \otimes |v_2\rangle$ as $|v_1,v_2\rangle$, or even $|v_1 v_2\rangle$.


\subsection{Grover’s algorithm}
Grover’s algorithm~\cite{G96} is one of the most famous quantum algorithms. It is used to solve the searching problem for finding one target element in a disordered database with $N$ elements. 
Due to the characteristic of parallel computation in quantum systems, Grover's algorithm takes $O(\sqrt{N})$ operations to find the target element, which is a quadratic speed up compared with classical methods requiring $O(N)$ operations.
Grover’s algorithm is widely used in many applications, such as cryptography \cite{GL16}, pattern matching \cite{TN22}, etc.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.92\linewidth]{Figure/grover_implement.pdf}
    \caption{Grover's algorithm}
    \label{fig:grover_implement}
\end{figure}

The overall structure of Grover’s algorithm is shown in Fig.~\ref{fig:grover_implement}. The two main operations of it are {\em phase inversion} and {\em inversion about the average}, which are handled by the oracle and diffuser, respectively. 
Initially, the input will be placed in superposition ($|x\rangle$) to evaluate all elements in the database at once. 
Next, the oracle function $U_f$ considers all the possible inputs and marks the target element by applying phase inversion, i.e., $U_f |x\rangle = (-1)^{f(x)} |x\rangle$, in which $f(x) = 1$ for the target element and $f(x) = 0$ for the others.
The oracle is problem-dependent, while the diffuser is not. Thus, designing the correct oracle is the key to apply Grover’s algorithm. 
After the target element being marked, the diffuser applies the {\em inversion about the mean} operation, to amplify the probability of the target element, so that one can obtain the result by measurement.
In order to achieve the optimal probability for the target element to be measured, the two operations (called a Grover iteration) need to repeat $(\pi / 4) \sqrt{N}$ iterations .

Grover’s algorithm can also be deployed for problems with multiple target elements. 
In such a case, the number of required iterations becomes $(\pi / 4) \sqrt{N/M}$, where $M$ is the number of target elements. 
In addition, one can measure the correct result only when the number of the target elements is less than that of the nontarget elements (i.e. $M/N < 50\%$) due to the natural property of the algorithm~\cite{Y08}.
Since the number of target elements is usually unknown before the searching, there are several ways to solve this issue.
The most common one is to apply quantum counting~\cite{BH98} to obtain the (approximate) number of target elements before using Grover’s algorithm. After knowing the ratio of $M/N$, if it is more than $50\%$, one can double the search space by adding $N$ nontarget elements, so the target elements will always be less than $50\%$ of the search space. Another way is to apply the advanced algorithm proposed by Boyer et al.~\cite{BB98}.

\subsection{SAT, SMT, and Theory of Fixed-Width Bit Vector}

A Boolean formula is constructed by logical operators such as negation ($\neg$), conjunction ($\wedge$) and disjunction ($\vee$) among Boolean variables. Given a Boolean formula, the Boolean satisfiability (SAT) problem asks if there exists an assignment of the Boolean variables that satisfies the formula. 

Satisfiability modulo theory (SMT), an extension of SAT, is the problem of determining whether a mathematical formula is satisfiable. A mathematical formula is composed of atoms (predicates) connected by Boolean logical operators (e.g., formula $F$ in Section~\ref{sec:Introduction}). The type of atoms depends on the theory used in the mathematical formula. 

\begin{figure}[tb]
\centering
\[
\begin{matrix}
    E & \simeq & \Tilde{a} \mid \mathcal{C} \mid \; E_1 \odot E_2 & \mbox{where} & \odot \mbox{ is an arithmetic operator} \\
    atom & \simeq & E_1 \; \rhd \; E_2 & \mbox{where} & \rhd \in \{<, >, =, \geq, \leq, \neq \}
\end{matrix}
\]
\caption{Syntax of $\mathcal{BV}$ atoms}
\label{fig:BV-Syntax}
\end{figure}

In this work, we focus on the theory of quantifier free fixed-width bit-vectors (c.f.~Section~4.2.5 in \cite{S07}), denoted by $\mathcal{BV}$ for short. The syntax of $\mathcal{BV}$ atoms is given in Fig.~\ref{fig:BV-Syntax}. An expression $E$ could be a variable $\Tilde{a}$ with $n$ bits, a constant $\mathcal{C}$, or the result of an arithmetic operation between two expressions $E_1$ and $E_2$. Notice that once the data width ($n$ bits) is determined, it is fixed for all expressions. An atom is composed of two expressions and one comparison operator $\rhd$ in between, where $\rhd \in \{<, >, =, \geq, \leq, \neq \}$. The arithmetic operator includes word-concatenation, modulo-sum, modulo-multiplication, bitwise operation, shift operation, etc.


% $\mathcal{BV}$ theory is useful for representing Register Transfer Level (RTL) hardware circuits, such as data paths. 
% The format of $\mathcal{BV}$ atoms can be written as $(\mathbf{a} @ \mathbf{b})$. $\mathbf{a}$ and $\mathbf{b}$ are $\mathcal{BV}$ terms, those terms can be built from fixed bit width variables ($x^{[16]}$) or constants ($0^{[32]}$) or the operation of terms. 
% The operator contains: word-concatenation (e.g. $x^{[8]} \circ y^{[8]}$), sub-word selection (e.g. $(x^{[16]}[7:0])^{[8]}$), modulo-sum (e.g. $x^{[8]} +_8 y^{[8]}$), modulo-multiplication (e.g. $x^{[8]} \times_8 y^{[8]}$), bitwise operation AND, OR, NOT, XOR (e.g. $x^{[8]}\ OR_8\ y^{[8]}$), shift operation (e.g. $x^{[8]} <<_2$). 
% $@$ is the predicate symbol, such as $<$, $\geq$, $=$ (e.g. $x^{[8]} \geq_8 y^{[8]}$). 

% Additionally, the SMT theory which is quantifier free ($QF$) means the formula does not contain quantifiers, such as universal ($\forall$) and existential ($\exists$) quantifiers. 
% One of the traditional approaches to solving $\mathcal{BV}$ SMT problem is bit blasting, which applies preprocessing algorithm and then encodes the result into a pure SAT problem. 
% The other approaches are adopting the layered theory solver that contains solvers explicitly for (sub-theories of) $\mathcal{BV}$ or using the linear integer arithmetic ($\mathcal{LIA}$) theory solver by encoding the problem into $\mathcal{LIA}$ theory.
