\section{Related Works} \label{sec:RelatedWorks}

\subsection{SAT circuit} \label{subsec:SAT-Circuit}
SAT is useful in a wide range of applications, but it is also a famous NP-Complete problem. There are many works, such as hardware implementation of SAT solvers, trying to improve the performance of solving SAT problems.
With the advantage of superposition in the quantum system, there exists a chance to speed up the process of SAT solving by using the quantum circuit. Alberto et al. \cite{AS07} proposed three algorithms, including the quantum Fredkin circuit, quantum register machine and quantum P system, to solve the SAT problem. By adopting the superposition nature of the quantum system to the input, the system can obtain all the results of all possible inputs in one evaluation. But the common problem of those methods is that it is difficult to measure the SAT result since the probability of SAT results will be very low if the number of satisfiable assignments is way less than the number of unsatisfiable assignments. Although the author proposed a non-unitary operator or there are other methods like the chaotic dynamic system \cite{MI03} to extract the SAT result, they are difficult to implement for now.

Another approach to solving the measurement problem is to adopt Grover’s search algorithm. Since the algorithm is used to find the target elements in a database by amplifying the measurement probability of those elements, it is suitable for searching the satisfiable assignments if those assignments can be marked properly in the oracle function. Fernandes et al.~\cite{FS19} provide the concept of constructing the oracle circuit of 3-SAT solving based on Grover’s algorithm.

\subsection{Quantum arithmetic and comparator circuit}

Chakrabarti et al.~\cite{CS08} proposed a quantum ripple carry adder that is based on the famous VBE adder~\cite{VB96} with the improvement of gate level reduction. Their proposed adder reorganizes the carry gates that generate carry bits to let some parts of the gates operate in parallel. On the other hand, they discard the series of sum and carry gates in the second part of the VBE adder, and replace those gates with $\mathtt{CNOT}$ gates to generate the summation result. The author also proposed the design of a quantum carry look ahead adder, but there are no benefits of qubit usage or gate level compared to the ripple carry adder. We adopt the ripple carry adder for modulo-sum operation in our circuit.

Kotiyal et al.~\cite{KT14} proposed a design of quantum multiplier focusing on reducing the ancilla inputs and garbage outputs since the usage of qubits is the main consideration of quantum circuit design. The advantage of their proposed multiplier is that they use the binary tree based design to handle partial product summation in parallel. Besides, they employ the adder without ancilla and garbage qubits proposed by Takahashi et al.~\cite{TT10} to reduce the caused by adders. The implementation result also showed that their multiplier has up to $60.34\%$ and $52.27\%$ improvement of ancilla and garbage qubits usage compared to other previous works.

Kotiyal et al. \cite{KT11} proposed a quantum bidirectional barrel shifter that can perform four shift operations, including logical right shift, logical left shift, arithmetic right shift and arithmetic left shift. In order to implement the 2to1 MUX, which is the major component of the barrel shifter, they adopt the Fredkin gate (i.e. $\mathtt{CSWAP}$ gate) for implementation by setting the control qubit as the select signal and one of the target qubits as the output. They also use the $\mathtt{CNOT}$ gate to handle signal fan out. Compared to previous works, their shifter has the reversal control unit to achieve the bidirectional shift even though the core module of the shifter only operates right shift operation.

Finally, the quantum comparator will be used to identify the atom’s status once the two $\mathcal{BV}$ terms are ready. The quantum comparator proposed by Oliveira et al. \cite{OR07} can indicate the relation between two input quantum bit strings $\mathbf{a}$ and $\mathbf{b}$. Their circuit, compared to another subtraction based comparator NKO, requires less resources and has higher computation parallelism.

% \begin{comment}
%     Proof. A $m-CNOT$ gate can be implemented by cascading $m$-1 $CCNOT$ gates and setting the target input of first $m-2$ $CCNOT$ gates to $|0\rangle$.
%     \par
%     The operation of $CCNOT$ gate can be represented as $CCNOT (|i_1 i_2 \rangle \otimes |o \rangle) = | i_1 i_2 \rangle \otimes |(i_1 \wedge i_2) \oplus o \rangle$.
%     \par
%     The cascading structure of $CCNOT$ gates is constructed by connecting the output of one $CCNOT$ gate to one of the succeeding $CCNOT$ gate's control input :
%     \begin{center}
%         $CCNOT_1 (|i_1 i_2 \rangle \otimes |o_1 \rangle)$ 
%         $= | i_1 i_2 \rangle \otimes |(i_1 \wedge i_2) \oplus o_1 \rangle$ 
%         $= | i_1 i_2 \rangle \otimes |i_1 \wedge i_2 \rangle$, where $o_1 = | 0 \rangle$
%         \par
%         $CCNOT_2 (|(i_1 \wedge i_2) i_3 \rangle \otimes |o_2 \rangle)$ 
%         $= | (i_1 \wedge i_2) i_3 \rangle \otimes |(i_1 \wedge i_2 \wedge i_3) \oplus o_2 \rangle$ 
%         $= | (i_1 \wedge i_2) i_3 \rangle \otimes |i_1 \wedge i_2 \wedge i_3 \rangle$, where $o_2 = | 0 \rangle$
%         \par
%         $...$
%         \par
%         $CCNOT_{m-1} (|(i_1 \wedge i_2 \wedge ... \wedge i_{m-1}) i_m \rangle \otimes |o_{m-1} \rangle)$ 
%         $= |(i_1 \wedge i_2 \wedge ... \wedge i_{m-1}) i_m \rangle \otimes |(i_1 \wedge i_2 \wedge ... \wedge i_{m}) \oplus o_{m-1} \rangle$
%     \end{center}
    
%     Finally, the output of target qubit of $CCNOT_{m-1}$ is equal to the output of target qubit of a $m-CNOT$ gate.
%     \\
%     \\
%     Proof. The SAT operation $U_{SAT}$ for 3-SAT problem in CNF behaves as :
%     \begin{center}
%         $U_{SAT} (|v_1 v_2 ... v_n \rangle \otimes {|1 \rangle}^{\otimes m} \otimes |0 \rangle)$ $= |v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 ... c_m \rangle \otimes |F(v_1,v_2,...,v_n) \rangle$
%     \end{center}
%     and can be implemented by existing Quantum gates,
%     where $n$ and $m$ are the number of variables and clauses of SAT formula $F$ respectively, $v$ are the variables of $F$, and $c_i$ is the assignment status of clause $i$ ($|c_i \rangle = |1 \rangle$ if clause $i$ is satisfiable and $|c_i \rangle = |0 \rangle$ if it is unsatisfiable).
    
%     First of all, the three basic operations of SAT formula $F$, negation, conjunction, and disjunction can be implemented by $NOT$ and $CCNOT$ gates.
%     \begin{center}
%         $NOT (|a\rangle) = |\neg a \rangle$
%     \end{center}
%     \begin{center}
%         $CCNOT (|ab\rangle \otimes |0 \rangle) = |ab\rangle \otimes |(a \wedge b) \otimes 0 \rangle = |ab\rangle \otimes |a \wedge b \rangle$
%     \end{center}
%     \begin{center}
%         $CCNOT (|\neg a \neg b\rangle \otimes |1 \rangle) = |ab\rangle \otimes |(\neg a \wedge \neg b) \otimes 1 \rangle = |\neg a \neg b\rangle \otimes |a \vee b \rangle$
%     \end{center}
    
%     Next, the literal operation of the $j$th literal in clause $i$ can be represented by $U_{l\_ij}$, where $|l_{ij} \rangle = U_{l\_ij}(|v_{ij} \rangle)$
%     \begin{center}
%         $|l_{ij} \rangle = U_{l\_ij}(|v_{ij} \rangle) = NOT (|v_{ij} \rangle) = |\neg v_{ij} \rangle$, if $l_{ij} = \neg v_{ij}$
%         \par
%         $|l_{ij} \rangle = U_{l\_ij}(|v_{ij} \rangle) = I (|v_{ij} \rangle) = |v_{ij} \rangle$, if $l_{ij} = v_{ij}$
%     \end{center}
    
%     Since the problem format is 3-SAT, the literal operation for clause $i$ can be represented as 
%     \begin{center}
%         $U_{l\_i} = I^{\otimes (i_1 - 1)} \otimes U_{l\_i1} \otimes I^{\otimes (i_2 - i_1 - 1)} \otimes U_{l\_i2} \otimes I^{\otimes (i_3 - i_2 - 1)} \otimes U_{l\_i3} \otimes I^{\otimes (n - i_3 - 1)}$
%     \end{center}
    
%     And then the 3-SAT clause operation of clause $i$ can be represented as 
%     \begin{center}
%         $U_{c\_i} = (NOT^{\otimes 3} \otimes I) CCCNOT (NOT^{\otimes 3} \otimes I)$
%         \par
%         , where 
%         $U_{c\_i}(|l_{i1} l_{i2} l_{i3} \rangle \otimes |1 \rangle)$
%         $= |l_{i1} l_{i2} l_{i3} \rangle \otimes |l_{i1} \vee l_{i2} \vee l_{i3} \rangle$
%         $= |l_{i1} l_{i2} l_{i3} \rangle \otimes |c_i \rangle$
%     \end{center}
    
%     \begin{center}
%         $U_{c\_i}(|l_{i1} l_{i2} l_{i3} \rangle \otimes |1 \rangle)$ 
%         $= (NOT^{\otimes 3} \otimes I) CCCNOT (NOT^{\otimes 3} \otimes I)(|l_{i1} l_{i2} l_{i3} \rangle \otimes |1 \rangle)$
%         $= (NOT^{\otimes 3} \otimes I) CCCNOT (|\neg l_{i1} \neg l_{i2} \neg l_{i3} \rangle \otimes |1 \rangle)$ 
%         $= (NOT^{\otimes 3} \otimes I)(|\neg l_{i1} \neg l_{i2} \neg l_{i3} \rangle \otimes |l_{i1} \vee l_{i2} \vee l_{i3} \rangle)$
%         $= |l_{i1} l_{i2} l_{i3} \rangle \otimes |l_{i1} \vee l_{i2} \vee l_{i3} \rangle$
%     \end{center}
    
%     When combining the literal and clause operation, the operator $U_{lc\_i}$ can be written as $U_{lc\_i} = (U_{l\_i} \otimes I^{\otimes m}) (U_{c\_i}') (U_{l\_i} \otimes I^{\otimes m})$, where $U_{c\_i}'$ represents the clause operation $U_{c\_i}$ only applies to the three variables which are included in clause $i$ and the corresponding $|c_i \rangle$, while left other qubits remain unchanged at the same time, like the operation of $U_{l\_i}$.
    
%     After that, the conjunction operation of all clauses can be represented as $U_{conj} = m-CONT$, where $U_{conj}(|c_1 c_2 ... c_m \rangle \otimes |0 \rangle) = |c_1 c_2 ... c_m \rangle \otimes |c_1 \wedge c_2 \wedge ... \wedge c_m \rangle$
    
%     Finally, the overall SAT operation can be represented as 
%     \begin{center}
%         $U_{SAT} = (I^{\otimes n} \otimes U_{conj}) (U_{lc\_m} \otimes I)...(U_{lc\_1} \otimes I)$
%         \par
%         , where $U_{SAT} (|v_1 v_2 ... v_n \rangle \otimes {|1 \rangle}^{\otimes m} \otimes |0 \rangle) = |v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 ... c_m \rangle \otimes |F(v_1,v_2,...,v_n) \rangle$
%     \end{center}
    
%     \begin{center}
%         $U_{SAT} (|v_1 v_2 ... v_n \rangle \otimes {|1 \rangle}^{\otimes m} \otimes |0 \rangle)$
%         $= (I^{\otimes n} \otimes U_{conj}) (U_{lc\_m} \otimes I)...(U_{lc\_1} \otimes I) (|v_1 v_2 ... v_n \rangle \otimes {|1 \rangle}^{\otimes m} \otimes |0 \rangle)$
%         $= (I^{\otimes n} \otimes U_{conj}) (U_{lc\_m} \otimes I)...(U_{lc\_2} \otimes I) (|v_1 v_2 ... v_n \rangle \otimes |c_1 \rangle \otimes {|1 \rangle}^{\otimes (m-1)} \otimes |0 \rangle)$
%         $= (I^{\otimes n} \otimes U_{conj}) (U_{lc\_m} \otimes I)...(U_{lc\_3} \otimes I) (|v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 \rangle \otimes {|1 \rangle}^{\otimes (m-2)} \otimes |0 \rangle)$
%         $= ... = (I^{\otimes n} \otimes U_{conj}) (|v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 ... c_m \rangle \otimes |0 \rangle)$
%         $= |v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 ... c_m \rangle \otimes |c_1 \wedge c_2 \wedge ... \wedge c_m \rangle$
%         $= |v_1 v_2 ... v_n \rangle \otimes |c_1 c_2 ... c_m \rangle \otimes |F(v_1,v_2,...,v_n) \rangle$
%     \end{center}
% \end{comment}