\section{Introduction} \label{sec:Introduction}

Satisfiability modulo theory (SMT) is the problem of determining the satisfiability of a first-order formula with respect to a decidable first-order theory. Compared to Boolean satisfiability problem (SAT), the atoms in SMT can be in different forms depending on the theories they base on. With this richer expressiveness, SMT is widely used in plenty of applications, particularly in formal verification, ranging from recent topics like neural networks \cite{KB17} \cite{AW21} and smart contracts \cite{AR18} \cite{AG20} to hardware circuit designs \cite{FS17} \cite{AF18}. Consider the following formula $F$, based on the theory of fixed-width bit-vector, consisting of three integer variables $a$, $b$ and $c$, each of which is $2$-bit long.
\[
F: [(a > b) \vee (a < b) \vee (a = b)] \wedge [\neg(a > b) \vee \neg(a < b) \vee \neg(a = b)]
\]

Formula $F$ is {\em satisfiable} as there exists an assignment $a = 2$ and $b = 2$, with binary representation $10$ and $10$, respectively, making $F$ evaluate to True. Such an assignment is called a {\em solution}. If there does not exist any solution, the formula is called {\em unsatisfiable}.

To solve a SMT problem, most of state-of-the-art SMT solvers adopt the classical {\em lazy approach}~\cite{S07}, which consists of three steps: (1) abstract the original formula as a Boolean formula, i.e., make an abstraction from the original theory domain to the Boolean domain, (2) find a solution to the abstract Boolean formula, and (3) check the consistency between Boolean and the original theory domains. If the solution found in step~{($2$)} is not consistent in both domains, it will be abandoned, and step~{(2)} continues until a consistent solution is found, or the formula is concluded unsatisfiable.

% Let a $\mathcal{BV}$ SMT formula
% $F = ((a^{[2]} >_2 b^{[2]}) \vee (a^{[2]} <_2 b^{[2]}) \vee (a^{[2]} =_2 b^{[2]})) \wedge (\neg(a^{[2]} >_2 b^{[2]}) \vee \neg(a^{[2]} <_2 b^{[2]}) \vee \neg(a^{[2]} =_2 b^{[2]}))$ and $\mathcal{T}2\mathcal{B}(F) = (x \vee y \vee z) \wedge (\neg x \vee \neg y \vee \neg z)$, where $\mathcal{T}2\mathcal{B}$ is the Boolean abstract function that mapping atoms to Boolean variables (i.e. $\mathcal{T}2\mathcal{B}(a^{[2]} >_2 b^{[2]}) = x$, $\mathcal{T}2\mathcal{B}(a^{[2]} <_2 b^{[2]}) = y$, $\mathcal{T}2\mathcal{B}(a^{[2]} =_2 b^{[2]}) = z$).


For instance, if we use Boolean variables $x$, $y$, and $z$ to denote the predicate $(a > b)$, $(a < b)$, and $(a = b)$, respectively, formula $F$ can be abstracted as the following Boolean formula $F_B$:
% \vspace{-1mm}
\[
F_B: (x \vee y \vee z) \wedge (\neg x \vee \neg y \vee \neg z)
\]
% \vspace{-1mm}
An SAT solver can be used to find a solution to the Boolean formula $F_B$, and a bit-vector theory solver can help to check the consistency. Fig.~\ref{fig:SMT_lazy_example} illustrates how the lazy approach solves formula $F$. In the first three iterations, SAT solver finds an assignment but immediately rejected by the theory solver. For example, in iteration~$1$, SAT solver finds a solution $x=0 \wedge y=1 \wedge z=1$ to formula $F_B$, which is rejected by the theory solver because $(a < b)$ and $(a = b)$ cannot hold simultaneously. This back and forth process continues two more iterations, and a consistent solution is found in iteration~$4$.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.98\linewidth]{Figure/SMT_lazy_example.pdf}
    \caption{SMT solving by the classical lazy approach}
    \label{fig:SMT_lazy_example}
\end{figure}


    % $\mathbf{Iteration 1}$ : $SAT\ solver : $ $xyz = 011 \rightarrow$ $Theory\ solver : $ theory inconsistent \\
    % ($a_2$ cannot be less than and equal to $b_2$ at the same time) \\
    % $\Rightarrow$ $\mathbf{Iteration 2}$ : $SAT\ solver : $ $xyz = 101 \rightarrow$ $Theory\ solver : $ theory inconsistent \\
    % $\Rightarrow$ $\mathbf{Iteration 3}$ : $SAT\ solver : $ $xyz = 110 \rightarrow$ $Theory\ solver : $ theory inconsistent \\
    % $\Rightarrow$ $\mathbf{Iteration 4}$ : $SAT\ solver : $ $xyz = 001 \rightarrow$ $Theory\ solver : $ theory consistent : $a=00$, $b=00$ \\
    % $\Rightarrow$ SMT result : SAT, SAT solution : $\{xyz=001, a=00, b=00\}$


One can observe that each iteration of this back and forth process only checks the consistency of one Boolean solution (against the theory) at a time. If the search space is huge, this approach becomes unscalable. Indeed, there is an {\em online} version of the lazy approach, which adopts heuristics, making it more efficient. However, the online version does not reduce the theoretical time complexity.

% the main shortcoming of the lazy approach is that it needs to find and check the assignments one by one between the SAT solver and theory solver. The situation will become more critical for larger SMT problems. Although there is the online version of the lazy approach which adopts heuristic methods to narrow down the search space during the procedure to make the approach more efficient, the benefits gained from those methods highly depend on the input SMT problem and the necessity of operating the two processes back and forth between two solvers still exists.

In recent years, quantum technology is widely used in many applications to solve traditionally difficult problems by taking advantage of the nature of superposition and entanglement in quantum systems. Grover’s algorithm~\cite{G96}, one of the famous quantum algorithms, helps to search target objects among a huge search space. There are two essential components in Grover's algorithm: (1) an {\em oracle}, and (2) the {\em diffuser}. In a nutshell, the oracle answers the ``yes/no'' question about whether an object in the search space is our target, while the diffuser tries to increase or maximize the probability of the target's being measured. The details of Grover's algorithm is briefed in Section~\ref{sec:Preliminary}.

To use Grover's algorithm for a search problem, the key is to provide the oracle. As long as the oracle can correctly identify the targets among the search space, the diffuser, which is standard and independent from the search problem, can help to ``extract'' the targets. In this work, we develop a quantum SMT solver based on Grover's algorithm. More specifically, given a SMT formula, we develop a methodology to generate the oracle required by Grover's algorithm to search the solutions to the SMT formula.

Let us take formula $F$ as an example again. Assume the two variables $a$ and $b$, each of which is $2$-bit long, are represented by binary strings $a_1 a_2$ and $b_1 b_2$, respectively. Together with the abstract Boolean formula $F_B$, we can use seven bits to represent each element $|v\rangle$ in the search space, as a column vector $|x,y,z,a_1,a_2,b_1,b_2\rangle$. There are requirements for $|v\rangle$ to be a solution of formula $F$. Firstly, in the Boolean domain, $x$, $y$, $z$  have to satisfy the following condition:
\vspace{-1mm}
\begin{equation} \label{eq:Boolean}
F_B(x,y,z) = (x \vee y \vee z) \wedge (\neg x \vee \neg y \vee \neg z) = 1
\end{equation}

Secondly, in the bit-vector theory domain, $a_1$, $a_2$, $b_1$, $b_2$ need to be consistent with their Boolean abstraction $x$, $y$, $z$. Thus, they have to satisfy the following three conditions:
\vspace{-1mm}
\begin{eqnarray}
(x = 1 \iff a_1 a_2 > b_1 b_2) \vee  (x = 0 \iff a_1 a_2 \not> b_1 b_2) \\
(y = 1 \iff a_1 a_2 < b_1 b_2) \vee  (y = 0 \iff a_1 a_2 \not< b_1 b_2) \\
(z = 1 \iff a_1 a_2 = b_1 b_2) \vee  (z = 0 \iff a_1 a_2 \neq b_1 b_2)
\end{eqnarray}

Here comes the interesting and critical part. If we can construct an oracle $\Psi$, which can help us to take care of the four conditions simultaneously, then the diffuser can proceed to extract the solution for us. That is, our oracle $\Psi$ does the following:

\begin{displaymath}
\Psi(|v\rangle) = \left\{ 
\begin{matrix}
 -1 \cdot |v\rangle & \mbox{if} & (1) \wedge (2) \wedge (3) \wedge (4) \\
 |v\rangle & \mbox{otherwise} &
\end{matrix}
\right.
\end{displaymath}

If an input $|v\rangle$ is a solution to $F$, our oracle adds a ``$-1$'' phase to it; otherwise, $|v\rangle$ is not changed. Since the input $|v\rangle$ can be placed in superposition, representing every possible input, our oracle is able to identify all the solutions to $F$ in one shot. Then, the diffuser recognizes those inputs with a ``$-1$'' phase and tries to increase/maximize their probability to be measured.
Fig.~\ref{fig:Oracle_High-level}~{(b)} shows all the $16$ solutions to formula $F$, and our oracle is able to identify all of them among the $128$ inputs in one shot.

% \begin{figure}[tb]
%     \centering
%     \includegraphics[width=\linewidth]{Figure/SMT_quantum_example.pdf}
%     \caption{The example of solving the SMT formula $F$ with quantum approach.}
%     \label{fig:SMT_quantum_example}
% \end{figure}

Fig.~\ref{fig:Oracle_High-level}~{(a)} shows the structure of our oracle design and summarizes our contributions. There are four components in our oracle:
\begin{enumerate}
\item {\bf SAT Circuit} (c.f.~Section~\ref{subsec:SAT-Circuit-Degisn}) determines the solutions for the Boolean domain, i.e., Equation~(\ref{eq:Boolean}) in our example.

\item {\bf Theory Circuit} (c.f.~Section~\ref{subsec:Theory-Circuit}) determines the truth value of predicates (e.g., $a < b$, $a > b$, $a = b$ in our example) in the theory domain with respect to different inputs.

\item {\bf Consistency Extractor} (c.f.~Section~\ref{subsec:Consistency_Extractor}) identifies those solutions that are consistent in both Boolean and the theory domains, i.e., $(1) \wedge (2) \wedge (3) \wedge (4)$ in our example.

\item {\bf Solution Inverser} (c.f.~Section~\ref{subsec:solution_inverter}) inverses the solutions to the SMT formula by adding a ``-1'' phase to them for the diffuser's further processing.
\end{enumerate}

\begin{figure}[tb]
\begin{minipage}{0.6\linewidth}
\centering
\includegraphics[width=0.9\linewidth]{Figure/Oracle_high-level_figure.pdf}
\end{minipage}
~
\begin{minipage}{0.35\linewidth}
\centering
\includegraphics[width=0.95\linewidth]{Figure/Output_Table.pdf}
\end{minipage} \\[1mm]
\begin{minipage}{0.6\linewidth}
\centering
\footnotesize
(a) Our oracle $\Psi$
\end{minipage}
~
\begin{minipage}{0.35\linewidth}
\centering
\footnotesize
(b) Solutions
\end{minipage}
\caption{Structure of our oracle $\Psi$}
\label{fig:Oracle_High-level}
\end{figure}

% In this paper, we proposed a quantum circuit that is based on Grover’s searching algorithm to solve the quantifier-free bit-vector ($QF$-$\mathcal{BV}$) theory SMT problem. With the advantage of the superposition nature of the quantum system, the circuit can evaluate all possible inputs at one time which can provide significant improvement in solving efficiency. Compare to the traditional lazy approach, our proposed quantum circuit considers all possible inputs at one time, so it does not need to operate back and forth between the two processes for searching the solution one by one, which is the main weakness of the traditional method. Besides, the traditional approach only outputs one of the satisfiable solutions while the SMT problem is satisfiable. But for our quantum circuit, it can provide much more information by discovering all satisfiable solutions. Please see.


We have also proved the correctness of each component design. The rest of this paper is organized as follows. 
Section~\ref{sec:Preliminary} reviews preliminary concepts about quantum computing.
The proposed quantum SMT solver based on Grover's algorithm for formulas of the bit-vector theory is introduced in Section~\ref{sec:Methodology}. 
Evaluations of our approach are given in Section~\ref{sec:Evaluation}. Related works are discussed in Section~\ref{sec:RelatedWorks}.
The conclusion and our future works are discussed in Section~\ref{sec:Conclusion}.