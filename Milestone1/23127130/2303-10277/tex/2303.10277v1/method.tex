


% 1. introduce a feasibility-consistent abstraction, however conservative
% 2. reduce conservativeness by extension
% 3. feasibility condition on the extended abstraction and 


% We first propose a feasibility-consistent abstraction under control limits. However, this abstraction is difficult to construct and can be very conservative. Therefore, we propose an extended abstraction, which greatly eases the construction and improves conservativeness. Then, we show how to design a persistently feasible safety index on this extended abstraction. 



% The persistent feasibility verification is transformed into a $\Sigma_1$ property verification. The safety index can be transplanted to all systems with the same abstraction and qualified properties.

\subsection{Consistent abstraction under control limits}

In order to construct a consistent abstraction under control limits, we first show how to choose $\Phi$, the corresponding abstract space $Z$ and $\phi_z$. Then we pose a condition on the abstract control limits to make the abstraction consistent.

Suppose $\phi_0$ is composed of some inner functions. That is, $\exists \varphi_1(x),\cdots,\varphi_k(x)$, $\st \phi_0(x) = \phi_0(\varphi_1(x), \cdots, \varphi_k(x))$. For example, $\varphi_i(x)$ can be the distance to obstacles, the center of mass, etc. Inspired by \cite{liu2014control}, we can define $\Phi$ and correspondingly $Z$ by
\begin{align}
    \Phi = \varphi_1 \times \dot \varphi_1 \times \cdots \times \varphi_1^{(n_1)} \times \cdots \times \varphi_k \times \cdots \times \varphi_k^{(n_k)}
\end{align}
where the relative degree in the sense of Lie derivative from $\varphi_i^{(n_i)}$ to the concrete control $u$ is one. This choice of $\Phi$ ensures the appearance of $u$ in $\dot z$, which is a necessary condition of persistent feasibility. $z_i$ are all features of $x$. 
Therefore, we can restrict the safety index $\phi(x)$ to be composite functions of $\Phi$ and let $\phi_z(z) := \phi(z)$.
\begin{defn}[Composition]
    $\phi(x)$ is a composite function of $\Phi$, that is, $\phi(x) = \phi(\Phi(x)) = \phi(z)$.
    % $\forall x_1, x_2, \Phi(x_1) = \Phi(x_2) \implies \phi(x_1) = \phi(x_2)$. Then we can have $\phi(z) = \phi(\varphi_1(x),\dot \varphi_1(x),\cdots)$.
\end{defn}

% Then $\Phi$ satisfies that
% \begin{align}
%     \forall x_1, x_2, \Phi(x_1) = \Phi(x_2) \implies \phi(x_1) = \phi(x_2) 
% \end{align}
% Then we can abuse the notation a little and let

For example, as shown in \cref{fig:idea}, we can define $\varphi(x) := d$, then $\phi_0(x) := 1-d = 1 - \varphi(x)$. We can let $z = [\varphi(x), \dot \varphi(x)] = [d, \dot d]$ and $\phi(z) = \phi(d, \dot d)$. 
% where $\phi$ can be defined both on $X$ and $Z$ and is to be designed. 

Next, we present the condition of consistent abstraction. We start by proving that the abstract control $v$ is an affine transformation of the concrete control $u$.

\begin{lem}[Affine transformation of control]\label{lem:affine_control}
    Consider a control affine concrete system and a smooth map $\Phi$. The abstract control can be represented as an affine transformation of the concrete control, specifically, we can let $v = C(x) u + d(x)$, where $C(x) = g_z(\Phi(x))^{-1} \nabla \Phi(x) g(x)$, and $d(x) = g_z(\Phi(x))^{-1}[\nabla \Phi(x) f(x) - f_z(\Phi(x))]$. The proof is in \cref{apd:affine_control_proof}.
\end{lem}

\begin{defn}[Implementable abstract control limits]\label{defn:affine_limits}
    Given a polytope concrete control limits $U$ and a state $x$, based on \cref{lem:affine_control}, the implementable abstract control limits at $x$ is also a polytope set, defined as $\Phi_U(x):= \{C(x) u + d(x) \mid \forall u \in U\}$.
\end{defn}

% \begin{thm}[Equivalent vector field]
%     Given a state $x$ and control limits $U$. $\forall v \in \Phi_U(x)$
%     \begin{align}
%         \dot z(z, v) = \nabla \Phi \dot x(x, u)
%     \end{align}
% \end{thm}

\begin{thm}[Feasibility consistency condition]\label{thm:feasibility-propagation}
    Let $\Sigma_1$ and $\Sigma_2$ be two control systems and $\Phi:X \to Z$ be a surjective smooth map. Suppose the abstract control limits $V$ is a state-dependent set, then 
    \cref{eq:z_feasibility} $\implies$ \cref{eq:x_feasibility}
    % the persistent feasibility of $\phi$ can be propagated from $\Sigma_2$ to $\Sigma_1$ 
    if
    \begin{align}
        \forall z,\ V(z) \subseteq \cap_{x\in \Phi^{-1}(z)} \Phi_U(x)\label{eq:feasibility-propagation}
    \end{align}
    % And \cref{eq:z_feasibility} $\impliedby$ \cref{eq:x_feasibility} if 
    % \begin{align}
    %     \forall x,\ V(\Phi(x)) \supseteq \Phi_U(x)\label{eq:feasibility-inherit}
    % \end{align}
    \begin{proof}
    For arbitrary $x \in \{\phi(x)\}_{=0}$, we can let $z = \Phi(x)$ and have $\phi(z) = 0$. Then based on \cref{eq:z_feasibility}, there exists a $v \in V(z)$ such that $\dot \phi(z,v) < 0$. From \cref{eq:feasibility-propagation}, we know this $v \in V(z) \subseteq \Phi_U(x)$. Therefore, based on \cref{defn:affine_limits}, $\exists u \in U$ such that $v = C(x) u + d(x)$. And this $u$ satisfies that $\dot \phi(x,u) = \pd[\phi]{x}\dot x = \pd[\phi]{z} \pd[z]{x} \dot x = \pd[\phi]{z}\dot z = \dot \phi(z,v) < 0$. 
    % $\dot z(z,v) = \nabla\Phi(x)\dot x(x,u)$.
    
    % \textit{\cref{eq:z_feasibility} $\impliedby$ \cref{eq:x_feasibility}}: For arbitrary $z \in \{\phi(z)\}_{=0}$, we can find arbitrary $x \in \Phi^{-1}(z)$ and have $\phi(x) = 0$. When $\Sigma_1$ is persistently feasible, there always exists a $u \in U$ such that $\dot \phi(x,u) < 0$. Let $v = C(x)u + d(x)$. From \cref{eq:feasibility-inherit} and \cref{defn:affine_limits}, we know $v \in \Phi_U(x) \subseteq V(z)$. Therefore, $\dot z(z,v) = \nabla\Phi(x)\dot x(x,u)$, and $\dot \phi(z,v) = \pd[\phi]{z}\dot z =  \pd[\phi]{x}\dot x = \dot \phi(x,u) < 0$.
    \end{proof}
\end{thm}

% We first propose a sufficient condition of $\Sigma_2$ such that \cref{eq:z_feasibility} $\implies$ \cref{eq:x_feasibility}.
% \begin{thm}[Feasibility propagation condition]\label{thm:feasibility-propagation}
%     Let $\Sigma_1$ and $\Sigma_2$ be two control systems and $\Phi:X \to Z$ be a surjective smooth map. Then the persistent feasibility of $\phi$ on $\Sigma_2$ can be propagated to $\Sigma_1$ if given arbitrary $z, v \in \Sigma_2$
%     \begin{align}
%         \forall x \in \Phi^{-1}(z), \exists u \in U, \st \dot z = \nabla\Phi(x) \dot x = \pd[z]{x} \dot x\label{eq:feasibility-propagation}.
%     \end{align}
%     % where $\Phi_*$ is the induced push forward map of $\Phi$. Intuitively speaking, given a $\dot x$, $\Phi_*$ decomposes it into $x$ and $u$ then maps them to $z$ and $v$, then produces a $\dot z$.
%     \begin{proof}
%     $\forall \phi(x) = 0$, there exists a $z = \Phi(x)$ and $\phi(z) = 0$. When $\Sigma_2$ is persistently feasible, for this $z$, there always exists a $v$ such that $\dot \phi(z,v) < 0$. And based on \cref{eq:feasibility-propagation}, we know that for this $x$, $\exists u$ such that $\nabla\Phi(x)\dot x = \dot z$. Therefore, $\dot \phi(z,v) = \pd[\phi]{z}\dot z = \pd[\phi]{z} \pd[z]{x} \dot x = \pd[\phi]{x}\dot x$
%     \end{proof}
% \end{thm}

\Cref{thm:feasibility-propagation} states that the feasibility can be propagated from $\Sigma_2$ to $\Sigma_1$ if all abstract control $v\in V(z)$ at a given $z$ is always implementable on the concrete system at arbitrary $x \in \Phi^{-1}(z)$. 
% And the feasibility can be propagated from $\Sigma_1$ to $\Sigma_2$ if all control $u$ at a given $x$ has corresponding abstract control $v \in V(z)$.
% As shown in \cref{fig:idea}, in order to make sure the abstract control $v$ is always feasible for the concrete system, the abstract control limits $V$ has to be a varying set that depends on $x$, which can be denoted by $\Phi_U(x) :X \to \PP(\real^{n_v})$ where $\PP(\real^{n_v})$ is the power set of $\real^{n_v}$. However, system abstraction requires $V$ to be independent of $x$, otherwise, the dimension of the $\Sigma_2$ can not be reduced.
% A natural way to get rid of the dependency of $x$ for $V$ is to define a $V(z): Z \to \PP(\real^{n_v})$. The subjective map $\Phi$ partitions the state space $X$ into equivalence classes. We can denote the preimage of a $z$ by $\Phi^{-1}(z)$. A feasible control limits $V$ for all $x\in \Phi^{-1}(z)$ can be define as $V(z) = \cap_{x\in \Phi^{-1}(z)} \Phi_U(x)$. $\Sigma_2$ with an $z$-dependent $V$ is a valid consistent abstraction because it ensures every abstract control $v$ found given a $z$ is implementable by the concrete system $\Sigma_1$ for all $x \in \Phi^{-1}(z)$. 
However, $V(z)$ is difficult to construct because $\Phi^{-1}(z)$ is difficult to compute. For example, $\Phi^{-1}(z)$ may correspond to all possible poses of a robot arm given an end-effector status $z$. Besides, $z = \Phi(x)$ may aggregate $x$ with vastly different abstract control limits $\Phi_U(x)$ into the same class, making $V(z)$ very tight and even empty. As shown in \cref{fig:idea}, if we design control using $V(z) = \Phi_U(x_1) \cap \Phi_U(x_2)$, we will lose horizontal acceleration for both cases. Therefore, we need a better method that is easy to construct and improves conservativeness.


\subsection{Non-conservative abstraction under control limits}

% To get rid of the dependency on $x$ for $V$ while maintaining non-conservativeness, our key idea is to extend the abstract state $z$ with the space of possible control limits. 
% The reason $V(z)$ is difficult to construct and conservative is that $z = \Phi(x)$ aggregates $x$ with vastly different abstract control limits $\Phi_U(x)$ into the same class, making it necessary to compute the preimage of $z$ and a small intersection of $\Phi_U(x)$. 

To address this issue, we propose an extended abstraction that only aggregates $x$ with similar abstract control limits $\Phi_U(x)$. 
% If we define an extended abstraction as $\hat z = \hat \Phi(x) := \Phi(x) \oplus \Phi_U(x)$, which aggregates $x$ with the same $\Phi(x)$ and the same $\Phi_U(x)$ into a $\hat z$. Then the extended abstract control limits $\hat V(\hat z) = \cap_{x\in\hat \Phi^{-1}(\hat z)} \Phi_U(x) = \Phi_U(x)$ is no longer conservative and does not require computing the preimage of $\hat z$, because all $x\in\hat \Phi^{-1}(\hat z)$ share the same abstract control limits. And by designing the abstract controller on $\hat Z$, we provide implementable abstract control under all different abstract control limits. That is, we can provide different control for $x_1$ and $x_2$ in \cref{fig:idea} even they share the same $z$. However, the space for this extended system is $\hat Z := Z \times \PP(\real^{n_v})$ because $\Phi_U: X \mapsto \PP(\real^{n_v})$, where $\PP(\real^{n_v})$ is the power set of $\real^{n_v}$, which has very high dimensions\wth{better to be more specific} and contradicts the purpose of system abstraction. 
In the following, we first define a one-dimensional under-approximation of $\Phi_U(x)$, then define such an extended abstraction.

% Therefore, we propose an extension that aggregates $x$ with similar control limits with only one extra dimension, such that the abstracted space is $\hat Z = Z \times \real$.


\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{img/extension.pdf}
    \caption{Left: Abstract control limit $V(x)$ and its under-approximation $M$. Right: Extended abstraction and extended abstract safe set. The abstract space $Z$ is extended with the scalar $M$, representing the maximal inner $Lp$-norm ball of $\Phi_U(x)$. In this way, the abstract safe set is lifted from $Z$ to $\hat Z = Z \times \real$. Designing the safety index $\phi$ on $\hat Z$ enables different safe control under different control limits. Persistent feasibility requires that there always exists a control that leads to a system flow $\dot{\hat z}$ toward the interior of the invariance set. }
    \label{fig:extended-abstraction}
\end{figure}


\begin{defn}[state-dependent radius of control constraints]
The radius of the largest zero-centered inner $Lp$-norm ball of $\Phi_U(x)$ is defined as: 
\begin{align}
    M(x) = \max_{r} r \quad \st B_p(r) \subseteq \Phi_U(x),
\end{align}
where $B_p(r) = \{v \mid \|v\|_p \leq r\}$. 
\end{defn}
\begin{defn} [Extended abstraction]
    With $M(x)$, we define an extended abstraction for $\Sigma_1$ as $\hat \Phi(x) := \Phi(x) \times M(x)$, and $\hat z := z \oplus M$. The abstract control is defined as $\hat v = v \times m$. The abstract control limit is defined by $\hat V(\hat z) := B_p(M) \times \real$. The corresponding extended abstraction space is $\hat Z := Z \times \real$, which has only one more dimension than $Z$.    
\end{defn}
% \begin{thm}[Feasibility propagation of $\hat \Phi$]
    % The extended abstraction $\hat \Phi$ is feasibility consistent.
    % \begin{proof}
    % Based on the abstraction, we know that $B_p(M) \subseteq \Phi_U(x), \forall x\in\hat\Phi^{-1}(\hat z)$. Therefore, $B_p(M) \subseteq \cap_{x\in\hat\Phi^{-1}(\hat z)}\Phi_U(x)$. And based on \cref{thm:feasibility-propagation}, $\forall \hat z$, $\hat V(\hat z) = B_p(M) \subseteq \cap_{x\in\hat\Phi^{-1}(\hat z)} (M) \implies$ $\hat \Phi$ is feasibility consistent.
    % \end{proof}
% \end{thm}

In this way, we keep the extended abstraction in low dimension and gain flexibility in designing abstract control under different control limits.

One prerequisite of this under-approximation is that $\Phi_U(x)$ must contain $0$. Because $M(x) = 0$ when $0 \notin \Phi_U(x)$. In this case, $\hat V(\hat z)$ is an empty set which makes $\Sigma_2$ ill-defined. Therefore, we provide sufficient conditions of $0\in \Phi_U(x)$. 
% Using a zero-centered inner $Lp$-norm ball to under-approximate $\Phi_U(x)$ requires that

\begin{asp}[$0 \in \Phi_U(x)$]
    We assume
    \begin{align}
        \forall x, \exists u,\ \st C(x)u + d(x) = 0.
    \end{align}{}
\end{asp}

To understand when the assumption holds, we present the following three case studies:
\begin{case}
    If $0\in U$ and systems are driftless~\cite{lavalle2006planning}, that is $f(x)=0$ and $f_z(z)=0$. Then $0 \in \Phi_U(x)$ always holds. 
    % Because based on \cref{lem:affine_control}, when $f(x) = 0$ and $f_z(z) = 0$, $v = C(x) u$. And because $0\in U$, we have $0 \in \Phi_U(x)$.
    % \begin{proof}
    % \end{proof}
\end{case}

\begin{case}
    When $v$ is a scalar, a sufficient condition of $\Phi_U(x)$ contains $0$ is $\min_{u\in \partial U} \|u\| > \max_{x \in X} \|d(x)\| / \|C(x)\|$.
    % \begin{align}
    %     \min_{u\in \partial U} \|u\| > \max_{x \in X} \|d(x)\| / \|C(x)\| \label{eq: scalar_u}
    % \end{align}{}
    % \begin{proof}
    % \cref{eq: scalar_u} holds implies that $\exists u_0 \in U$ such that $u_0 = - C(x)^T d(x) /\|C(x)\|^2 $. Then we can define $v_0 := C(x) u_0 + d(x) = 0$. Therefore $0 \in \Phi_U(x)$.
    % \end{proof}        
\end{case}

\begin{case}
    When $v$ is a vector, a sufficient condition that $0 \in \Phi_U(x)$ is that $\min_{u\in \partial U} \|u\| > \max_{x \in X} \|C(x)^T w(x)\| \label{eq: vector_u}$,
    % \begin{align}
    %     \min_{u\in \partial U} \|u\| > \max_{x \in X} \|C(x)^T w(x)\| \label{eq: vector_u}
    % \end{align}{}
    where $w(x)$ is a solution of $C(x) C(x)^T w(x) + d(x) = 0$.
    % \begin{align}
    %     C(x) C(x)^T w(x) + d(x) = 0.
    % \end{align}{}
    % \begin{proof}
    %     \cref{eq: vector_u} holds implies that $\exists u_0 \in U$ such that $u_0 = C(x)^T w(x)$. Then we can define $v^* := C(x) u^* + d(x) = 0$. Therefore $0 \in \Phi_U(x)$.
    % \end{proof}    
\end{case}


The extended abstraction enables the design of abstract controllers under varying control limits. Without the extension, an abstract controller will give us the same control under different abstract control limits. But after the extension, we can define the safety index on $\hat Z$, which is abstract control limits aware. For example, as in \cref{fig:idea}, if the only considering $d,\dot d$, an abstract controller will suggest the same control for $x_1$ and $x_2$, but after the extension, it will suggest different actions for $x_1$ and $x_2$.