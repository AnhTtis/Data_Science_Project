
The consistent abstraction theory shows that a persistent feasible safety index defined on the extended abstraction guarantees persistent feasibility for the concrete system. Next, we show how to design a persistent feasible safety index on the extended abstract space $\hat Z$.


\subsection{Persistent feasibility on extended abstraction}

As shown in \cref{fig:extended-abstraction}, a safety index defined on $Z$ corresponds to a disk invariance set on the $Z$ plane. But a safety index defined on $\hat Z = Z \times \real$ corresponds to a bucket shape invariance set in $\hat Z$. $M$ can be viewed as an additional inner function. Persistent feasibility requires that we can always find a control on the boundary of the invariance set that leads to a system flow towards the inside of the invariant set. Formally, persistent feasibility requires the following inequality holds for all $x \in \{x\mid\phi(x)=0\}$:
\begin{align}
    & \min_{\|v\| < M} \dot \phi(x,u) = \dot \phi(z(x),v(u)) = \pd[\phi]{z} \dot z + \pd[\phi]{M} \dot M  \\
    & = \pd[\phi]{z(x)} [f_z(z(x)) + g_z(z(x)) v] + \pd[\phi]{M} \dot M(x) < 0 \label{eq:safe_X}
\end{align}

The numerical method to verify persistent feasibility for general nonlinear systems has an exponential growth time complexity $\OO(2^n)$~\cite{wei2022safe}, where $n$ is the dimension of the state. Therefore we wish to verify the feasibility on the abstracted system and propagate the feasibility back to concrete system. However, notice that $\dot M(x)$ does not depend on $z$ but on $x$. 
To guarantee the abstract control is consistent for all $x \in \Phi^{-1}(\hat z)$. We propose the following method. 

Suppose $M(x) \in [M_{min}, M_{max}] := R_v$, we instead verify the following stricter inequality: $\forall z\in\{z\mid\phi(z)=0\}, \forall M, \exists v$, such that
\begin{align}
    \min_{\|v\|<M} \pd[\phi]{z} \left[f_z(z) + g_z(z) v\right] + \left|\pd[\phi]{M} \dot M_{*}\right| < 0,\label{eq:stricter_feasibility}
\end{align}
where $\dot M_{*}$ is a chosen upper bound of $\dot M(x)$, which equals to or larger than the maximum value of $\dot M(x)$. It is easy to see that \cref{eq:stricter_feasibility} $\implies$ \cref{eq:safe_X}. Intuitively, \cref{eq:stricter_feasibility} says that we can always find a control $u$ that corresponds to a $\dot z$, whose combination with the largest possible $\dot M$ (which is $\dot{\hat z}$) still points towards the interior of the invariant set. And because \cref{eq:stricter_feasibility} is $x$-independent, we can verify it on the space $\hat Z$, which is a much smaller space than $X$, therefore can be verified by numerical methods. We can derive the following lemma from \cref{eq:stricter_feasibility}:\begin{lem}[Persistent feasibility]\label{lem:abstract_feasibility_M_max}
A safety index is persistently feasible if $\dot M_{*}$ satisfies the following condition for all $x\in X$ such that $\phi(x)=0$:
\begin{align}
    \inf_{z, M \in Z \times R_v} -\frac{\min_{\|v\|<M} \pd[\phi]{z} \left[f_z(z) + g_z(z) v\right]}{\left|\pd[\phi]{M}\right|} > \dot M_{*}. \nonumber
\end{align}
\end{lem}

In addition, \cref{eq:stricter_feasibility} can be relaxed when $M=M_{min}$. Because $\pd[\phi]{M}$ is expected to be always negative (the system is safer when the control limit is larger), and $\dot M \geq 0$ when $M=M_{min}$. Therefore $\pd[\phi]{M}|_{M_{min}} \dot M|_{M_{min}} \leq 0$. Therefore, we only need to verify that $\min_{\|v\|<M} \pd[\phi]{z} \left[f_z(z) + g_z(z) v\right]  < 0$ when $M = M_{min}$. We can estimate $M_{min}$ and $M_{max}$ by sampling the state space and computing $M$ with \cref{lem:M}.

% One flaw of the method is that it is doomed to fail when $M = M_{min}$  . Because, as shown in \cref{fig:extended-abstraction}, no matter what $\dot z$ is, $\dot{\hat z}$ always points outside of the invariance set if $\dot M_{*}$ exists. 

% To address this issue, note that we can design $\pd[\phi]{M}$ to be always negative (to encourage the system to remain in states with larger control limit). Then 


% In the next, we discuss how to compute $M(x)$ and $\dot M(x)$.

% \subsection{Online computation of $M$ and $\dot M$}

\begin{lem}[Sampling guarantee]\label{lem:sampling}
    Suppose 1. we uniformly sample $N$ times from $X$ and denote the maximum and minimum of $M(x)$ by $\hat M_{max}$ and $\hat M_{min}$, and the maximum of $\dot M(x)$ by $\hat{\dot M}_{*}$; 2. a $\phi$ is designed to guarantee persistent feasibility with $\hat M_{max}$, $\hat M_{min}$ and $\hat{\dot M}_{*}$. Then we can guarantee that more than $100\cdot p\%$ states are feasible with the probability $[1-p^N]^3$, where $0<p<1$. The proof is in \cref{apd:sampling_proof}
\end{lem}

\subsection{Safety Index Synthesis and Execution}

% \subsubsection{}

With dynamics abstraction, we can synthesize $\phi$ on a low dimensional space. Therefore, we can use analytical or numerical methods~\cite{wei2022safe} to compute $\left|B^*_\theta\right|$ in \cref{eq:B*}.
During online execution, we can find a safe control in the original space when $\phi(x)=0$ by:
\begin{align}
    & \dot \phi(x, u) = \pd[\phi]{z} \pd[z]{x} \dot x + \pd[\phi]{M} \pd[M]{x} \dot x\\
    & = (\pd[\phi]{z} \pd[z]{x} + \pd[\phi]{M} \pd[M]{x}) [f(x) + g(x) u] < 0.
\end{align}
% \begin{align*}
%     \pd[M]{x} = \lim_{\delta \to 0} \frac{M(x+\delta)-M(x)}{\delta}
% \end{align*}
$\pd[M]{x}$ is sometimes difficult to derive analytically, but it can always be computed numerically by taking the limit: $\lim_{\delta \to 0} [M(x+\delta)-M(x)]/\delta.$ The numerical error can be compensated by using a larger ${\dot M}_*$.
% Because $\dot M$ is bounded and the persistent feasibility guarantees a safe control exists even for $\hat{\dot M}_{*}$, therefore safety always can be guaranteed by choosing the most conservative safe control. 
With this safety constraint, we can choose a control $u$ that is close to a given safety-ignorant reference control $u_0$ with a QP objective function as in most energy function based method~\cite{wei2019safe}: $\min_{u} \|u-u_0\|\ \st \dot \phi(x,u) < 0.$
% \begin{align}
%     \min_{u} \|u-u_0\|\ \st \dot \phi(x,u) < 0.
% \end{align}

