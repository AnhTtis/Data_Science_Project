\subsection{Graph Enumeration and Optimization}
\label{enumeration}

Designers and system architects still often rely on engineering intuition and trial-and-error methods when exploring graph-centric problems.
However, these approaches can lead to a lack of novel and satisfactory solutions within time restrictions.

A potential systematic strategy is \textit{graph enumeration}, which are techniques for generating (or sometimes simply counting) nonisomorphic graphs with particular properties \cite{b89}.
The properties can be quite diverse and are sometimes termed network structure constraints \cite{b31}.
Some examples include bounding the potential degrees of the vertices in the graph or a maximum cost associated with the graph \cite{b59}.
It is important to note that the number of valid graphs is usually combinatorial in nature; thus, the computational costs for just generating an enumeration can become quite expensive.
However, two different graph enumeration algorithms might produce the desired enumeration, but one might do it more efficiently \cite{b59}.

In any case, there are several important engineering applications where the enumeration of graphs, often with thousands to millions of entries, is practical. %  \cite{}.
Even if graph enumeration is not possible, generating a partial listing (either algorithmically or manually) may still be desirable to explore potential solutions.
In this work, it is assumed that there is a generated set of graphs, denoted $\mathcal{G}$, that contains the graphs of interest.
For the purposes of the case study, this is an enumeration of $RLC$ circuit graphs with certain properties based on \cite{b5}.


While having a list of novel graphs can be useful on its own, in many engineering domains, the graph is only an intermediary representation used to compute one or more value metrics of interest.
For example, the graph might correspond to a physics-based system model that is used to determine the comfort and handling of an automotive suspension \cite{b94}.
For this work, we will consider a single performance metric, denoted $J(G_i)$, that is a function of the graph, and the natural goal is seeking graphs that minimize this ``performance'' metric:
\begin{align}
\underset{G_i}{\textrm{minimize:}} \quad & J(G_i)
\label{archopt}
\end{align}

One of the challenges in engineering design with graphs is sometimes the computational cost of $J(G_i)$ is quite expensive, perhaps many orders of magnitude larger than generating the graph $G_i$ itself.
The source of this cost can be quite diverse, including high-fidelity simulations, optimization, human-centric evaluation, and physical experiments.
The focus of this work is when this cost is prohibitive. 

Based on the classification put forth by \cite{b93}, we define the following three types of graph-centric design problems:
\begin{enumerate}[nolistsep,label=$\bullet$]
   
\item \textit{Type 0} --- All desired graphs can be generated and so can their performance metric $J(G_i)$ within time $T$

\item \textit{Type 1} --- All desired graphs can be generated, but only some of the performance metrics $J(G_i)$ can be evaluated within time $T$; the performance assessment is too expensive

\item \textit{Type 2} --- All desired graphs cannot be generated within time $T$
    
\end{enumerate}

\noindent where $T$ is the amount of time allocated to complete the graph design study. 
This work focuses on methods for Type 1 problems (using data from a large Type 0 study).

