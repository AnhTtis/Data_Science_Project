\subsection{Graph Enumeration and Optimization}
\label{enumeration}

Designers and system architects still often rely on engineering intuition and trial-and-error methods when exploring graph-centric problems.
However, these approaches can lead to a lack of novel and satisfactory solutions within time restrictions.

A potential systematic strategy is \textit{graph enumeration}, which are techniques for generating (or sometimes simply counting) nonisomorphic graphs with particular properties \cite{b89}.
The properties can be quite diverse and are sometimes termed network structure constraints \cite{b31}.
Some examples include bounding the potential degrees of the vertices in the graph or a maximum cost associated with the graph \cite{b59}.
It is important to note that the number of valid graphs is usually combinatorial in nature; thus, the computational costs for just generating an enumeration can become quite expensive.
However, two different graph enumeration algorithms might produce the desired enumeration, but one might do it more efficiently \cite{b59}.

In any case, there are several important engineering applications where the enumeration of graphs, often with thousands to millions of entries, is practical. %  \cite{}.
Even if graph enumeration is not possible, generating a partial listing (either algorithmically or manually) may still be desirable to explore potential solutions.
In this work, it is assumed that there is a generated set of graphs, denoted $\mathcal{G}$, that contains the graphs of interest.
For the purposes of the case study, this is an enumeration of $RLC$ circuit graphs with certain properties based on \cite{b5}.

% In this section, we discuss what \textit{enumeration} is and why it is used by engineers.
% Engineers typically rely on trial-and-error methods when it comes to solving design problems, but this can lead to a lack of novel solutions.
% A way to help prevent this is by coming up with a list of all architectures that can satisfy specific constraints.
% \textit{Graph Enumeration} is a study in graph theory that deals with generating (or simply counting) non-isomorphic graphs with a particular property \cite{b89}.

While having a list of novel graphs can be useful on its own, in many engineering domains, the graph is only an intermediary representation used to compute one or more value metrics of interest.
For example, the graph might correspond to a physics-based system model that is used to determine the comfort and handling of an automotive suspension \cite{b94}.
For this work, we will consider a single performance metric, denoted $J(G_i)$, that is a function of the graph, and the natural goal is seeking graphs that minimize this ``performance'' metric:
\begin{align}
\underset{G_i}{\textrm{minimize:}} \quad & J(G_i)
\label{archopt}
\end{align}

One of the challenges in engineering design with graphs is sometimes the computational cost of $J(G_i)$ is quite expensive, perhaps many orders of magnitude larger than generating the graph $G_i$ itself.
The source of this cost can be quite diverse, including high-fidelity simulations, optimization, human-centric evaluation, and physical experiments.
The focus of this work is when this cost is prohibitive. 

Based on the classification put forth by \cite{b93}, we define the following three types of graph-centric design problems:
\begin{enumerate}[nolistsep,label=$\bullet$]
   
\item \textit{Type 0} --- All desired graphs can be generated and so can their performance metric $J(G_i)$ within time $T$

\item \textit{Type 1} --- All desired graphs can be generated, but only some of the performance metrics $J(G_i)$ can be evaluated within time $T$; the performance assessment is too expensive

\item \textit{Type 2} --- All desired graphs cannot be generated within time $T$
    
\end{enumerate}

\noindent where $T$ is the amount of time allocated to complete the graph design study. 
This work focuses on methods for Type 1 problems (using data from a large Type 0 study).


% For example, let us say we have an architecture design problem described by \eref{archopt}:
% \begin{align}
% \underset{i}{\textrm{minimize:}} \quad & J(G_i) \\
% \textrm{subject to:} \quad & G_i \in \mathcal{F} \subset \mathcal{G}
% \label{archopt}
% \end{align}
%
% where $x_a$ is the architecture design variable, $f_a(x_a)$ is a mapping between the architecture design variable and the architecture $a$, $\Psi$ is a performance index, and $\mathcal{F}_a$ is the set of feasible architectures \cite{b5}.
% The method used in the two case studies generates candidate architectures that are used to determine a performance index concerning an architecture problem.

% When it comes to these architecture-based design problems, the goal is a set of all architectures that satisfy a specific set of constraints\cite{b31}, but as we discussed in \sref{gt}, the candidate architectures in the list have to be \textit{unique}\cite{b30}. One of the approaches used is called the \textit{perfect matching} approach (PM)\cite{b3,b59}.

% \subsection{The Perfect Matching Approach}
% \label{pma}
% We have already discussed what a graph is and what a labeled graph is in \sref{gt}.
% Here, we need to touch on one other graph type that is essential for this topic, and that is a \textit{ports graph}.
% A port graph, $G^P$ is a three-tuple $(C,R,P)$, where $C$ is the set component labels, $R$ is a column vector that represents the number of replicates for each component type, and $P$ is the column vector for the number of ports for each component.
% Using these variables, we can then create the three-tuple $(V,E,L)$ that defines our labeled graph.
% Using this information, the perfect matching (PM) approach states that all ports of every vertex are connected to exactly one other port \cite{b3}.
% Enumeration with this PM approach can be effective certain graph enumeration problems, but still suffers the combinatorial growth issue\cite{b59}.

% \xdrh{(still needs to be placed}
% In some cases, such as the design problems discussed later, it is necessary to designate a limit on the number of degrees for a vertex.
% This can be described by $\delta(G) \coloneqq \min\{d(v) | v \in V\}$ or \textit{minimum degree} and $\Delta(G) \coloneqq \max\{d(v) | v \in V\}$ or \textit{maximum degree}.