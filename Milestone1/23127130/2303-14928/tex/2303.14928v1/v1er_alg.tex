\section{Description of \Vp}
\label{sec:ver_alg}
\input{v2er_alg.fig}
In this section, we describe the algorithm for verification of PQE
called \Vp.
%
%  Subsection: description of VerPQE
%
\subsection{High-level view of \Vp}
A high-level view of \Vp is given in Fig.~\ref{fig:ver_pqe}. \Vp
accepts formula \prob{X}{F}, a subset $G \in F$ of clauses to take out
of the scope of quantifiers and a solution $H$ to this PQE
problem. That is \prob{X}{F} is supposed to be logically equivalent to
$H \wedge \prob{X}{F \setminus G}$. \Vp returns \ti{true} if this
equivalence holds and so, $H$ is a correct solution. Otherwise, \Vp
returns \ti{false}.



\Vp consists of two parts separated by a solid line. In the first part
(lines 1-4), \Vp just checks if $H$ is implied by $F$. This is done by
checking for every clause $C \in H$ if $F \wedge \overline{C}$ is
satisfiable. If so, $C$ is not implied by $F$ and the solution $H$ is
incorrect. Hence, \Vp returns \ti{false} (line 4). In the second part
(lines 5-9), for every clause $C \in G$, the algorithm checks if $C$
is redundant in \prob{X}{F \wedge H} by calling the function \Cr (line
6). Namely, \Cr checks if $\prob{X}{F \wedge H} \equiv \prob{X}{(F
  \setminus \s{C}) \wedge H}$. If so, $C$ is removed from $F$ (line
8). Otherwise, $C$ is not redundant in \prob{X}{F \wedge H} and \Vp
returns \ti{false} (line 7). If all clauses of $G$ can be removed from
\prob{X}{F \wedge H}, then $H$ is a correct solution and \Vp returns
\ti{true}.
%
%  Subsection: description of ChkRed
%
\subsection{Description of \Cr}
\input{c1heck_red.fig} The pseudocode of \Cr is shown in
Fig.~\ref{fig:chk_red}. \Cr accepts the formula \prob{X}{F(X,Y) \wedge
  H(Y)} and a quantified clause $C$ to be checked for redundancy. \Cr
returns \ti{true} if $C$ is redundant in \prob{X}{F \wedge
  H}. Otherwise, it returns false. To verify redundancy of $C$, \Cr
checks if $F \wedge H$ has a $Y$-removable $C$-boundary point. If not,
$C$ is redundant. Otherwise, $C$ is not redundant.

\Cr starts with computing the set $Y$ of unquantified variables (line
1). Then it initializes the set of ``plugging'' clauses (see below).
The main work is done in the while loop (lines 3-12). \Cr starts with
checking if formula $F \wedge H$ has a $C$-boundary point (lines 4-5)
i.e.  checking if there is an assignment (\pnt{x},\pnt{y}) satisfying
$\mi{Plg} \wedge (F \setminus \s{C}) \wedge H \wedge
\overline{C}$. The formula \ti{Plg} is used here to exclude the
$C$-boundary points examined in the previous iterations of the
loop. If no (\pnt{x},\pnt{y}) exists, the clause $C$ is redundant and
\Cr returns \ti{true} (line 7).

If the assignment (\pnt{x},\pnt{y}) above exists, \Cr checks if
formula $\cof{F}{y} \wedge \cof{H}{y}$ is satisfiable i.e. whether $F
\wedge H$ is satisfiable in subspace \pnt{y} (lines 8-10). If not, the
$C$-boundary point (\pnt{x},\pnt{y}) is $Y$-removable. This means that
$C$ is not redundant in \prob{X}{F \wedge H} and \Cr returns
\ti{false} (line 10). Otherwise, (\pnt{x},\pnt{y}) is a
$Y$-unremovable boundary point and \Cr calls the function \ti{PlugCls}
to build a plugging clause $D(Y)$. The latter is falsified by \pnt{y}
and so excludes re-examining $C$-boundary points in the subspace
\pnt{y}. After that, \Cr adds $D$ to the formula \ti{Plg} and starts a
new iteration of the loop.


The simplest way to build $D$ is to form the longest clause falsified
by \pnt{y}. One can try to make $D$ shorter to exclude a greater
subspace from future considerations. Suppose there is $\pnt{y}^*
\subset \pnt{y}$ such that the assignment $\pnt{x}^*$ satisfying
$\cof{F}{y} \wedge \cof{H}{y}$ (found in line 8) still satisfies
$F_{\vec{y}^*} \wedge H_{\vec{y}^*} $. This means that every
$C$-boundary point of the larger subspace $\pnt{y}^*$ is
$Y$-unremovable too. So, one can add to \ti{Plg} a shorter plugging
clause $D$ falsified by $\pnt{y}^*$ rather than \pnt{y}.

%
% Subsection: Scalability of VerPQE
%

\subsection{Scalability issues}
\label{ssec:perf}
As we mentioned earlier, \Vp consists of two parts. The first part of
\Vp checks if every clause of the solution $H$ is implied by $F$. In
the second part, for every clause $C \in G$, the function \Cr checks
if $C$ is redundant in \prob{X}{F \wedge H}. (Recall that $G$ is the
subset of clauses that one must take out of \prob{X}{F}.) The first
part reduces to $|H|$ calls to a SAT-solver. So, it is as scalable as
SAT-solving (unless $H$ blows up as the size of the PQE problem
grows).  The second part of \Vp scales much poorer. The reason is that
this part requires enumeration of $Y$-unremovable $C$-boundary points
and the number of such points is typically grows exponentially. Besides,
the plugging clauses produced by \Cr are long.  So, adding a plugging
clause cannot exclude a big chunk of $C$-boundary points at once. So,
the size of formulas that can be efficiently handled by \Vp is limited
by 70-80 variables.

There is however \tb{an important case} where \Vp can efficiently
verify large formulas. This is the case where $F \wedge H$ does not
have any $Y$-unremovable $G$-boundary points. (Since $F$ and $F \wedge
H$ have the same $Y$-unremovable $G$-boundary points, this means that
$F$ has no such boundary points either.)  Then for every clause $C \in
G$, the \smallskip function \Cr immediately finds out that the formula
$(F \setminus \s{C}) \wedge H \wedge \overline{C}$ is unsatisfiable.
So, the verification of solution $H$ reduces to $|H| + |G|$
SAT-checks.

