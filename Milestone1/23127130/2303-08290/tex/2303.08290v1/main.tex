\documentclass{article}

% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2020

% ready for submission
% \usepackage{neurips_2020}

% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
\usepackage[square,numbers]{natbib}
    \usepackage[preprint]{neurips_2020}

% to compile a camera-ready version, add the [final] option, e.g.:
%     \usepackage[final]{neurips_2020}

% to avoid loading the natbib package, add option nonatbib:
     % \usepackage[nonatbib]{neurips_2020}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{graphicx, wrapfig}
\usepackage{algpseudocode}
% \usepackage{algorithm}
% \usepackage{algorithm2e}
\usepackage{amsmath}
\usepackage[linesnumbered,ruled]{algorithm2e}


% mathematical notation
\newcommand{\hi}{hi}
\newcommand{\fl}{fl}
\newcommand{\Enct}{\mathtt{Enc}^{t}}
\newcommand{\Ence}{\mathtt{Enc}^{e}}
\newcommand{\Encstruc}{\mathtt{Enc}_{struc}}
\newcommand{\Decstruc}{\mathtt{Dec}_{struc}}
\newcommand{\Embhi}{\textbf{E}_{\hi}}
\newcommand{\Embfl}{\textbf{E}_{\fl}}
\newcommand{\Enchi}{\mathtt{Enc}_{\hi}}
\newcommand{\Encfl}{\mathtt{Enc}_{\fl}}

\title{Rediscovery of CNN's Versatility for Text-based Encoding of Raw Electronic Health Records}


\author{%
Eunbyeol Cho$^{1*}$ \quad Min Jae Lee$^{1*}$ \quad Kyunghoon Hur$^1$ \\
\textbf{Jiyoun Kim}$^1$ \quad \textbf{Jinsung Yoon}$^2$ \quad \textbf{Edward Choi}$^1$ \quad \\
$^1$KAIST \quad $^2$Google Cloud AI Research \\
\texttt{\{eunbyeol.cho,mjbooo,pacesun,jiyoon.kim,edwardchoi\}@kaist.ac.kr}\\
\texttt{jinsungyoon@google.com}
}



\begin{document}

\maketitle
\def\thefootnote{*}\footnotetext{These authors contributed equally}\def\thefootnote{\arabic{footnote}}


\begin{abstract}
Making the most use of abundant information in electronic health records (EHR) is rapidly becoming an important topic in the medical domain.
Recent work presented a promising framework that embeds entire features in raw EHR data regardless of its form and medical code standards.
The framework, however, only focuses on encoding EHR with minimal preprocessing and fails to consider how to learn efficient EHR representation in terms of computation and memory usage.
In this paper, we search for a versatile encoder not only reducing the large data into a manageable size but also well preserving the core information of patients to perform diverse clinical tasks. 
We found that hierarchically structured Convolutional Neural Network (CNN) often outperforms the state-of-the-art model on diverse tasks such as reconstruction, prediction, and generation, even with fewer parameters and less training time.
Moreover, it turns out that making use of the inherent hierarchy of EHR data can boost the performance of any kind of backbone models and clinical tasks performed.
Through extensive experiments, we present concrete evidence to generalize our research findings into real-world practice.
We give a clear guideline on building the encoder based on the research findings captured while exploring numerous settings.
\end{abstract}

\section{Introduction}
\label{sec:intro}
The widespread introduction of electronic health record (EHR) systems brings tremendous opportunities to apply a data-driven approach to the healthcare domain.
Through EHR systems, millions of patients' data are now collected in a systematic manner across diverse healthcare institutions.
Using this rapidly growing EHR dataset, many researchers have found applications such as predicting clinical outcomes, learning representations of cohorts to get medical insights, and synthesizing clinical data.

To perform EHR-related tasks, conventional frameworks employed various encoding architectures such as recurrent neural networks~\citet{lipton2015lstm, edward2015doctorai, rajkomar2018scalable}, convolutional neural networks~\cite{miotto2016deep, nguyen2016deepr, landi2020}, and transformer-based models~\cite{yoon2022ehr, edward2019gct, shang2020gbert, rasmy2020medbert, li2020behrt, song2018sand}.
% Despite the diversity of proposed works, all these attempts have clear limitations that they are applicable exclusively for their own EHR system.
Despite the diversity of proposed works, all these attempts have clear limitations in that they are applicable exclusively to their own EHR system.
For example, they cannot use both MIMIC-III~\cite{johnson2016mimic} and eICU~\cite{pollard2018eicu} datasets together for training, unless involving manual harmonization of incompatible features.
% Technically, they employ incompatible feature selections with medical knowledge to suit their individual needs.
In addition, inherent disparities in the standards of medical codes and database schemas prevent data from being sourced from multiple healthcare institutions.
None of previous works thus can fully utilize information in multiple diverse EHR systems.


A recent work~\cite{hur2020descemb, hur2022unihpf} presented a text-based encoding approach to address this conventional limitation.
Specifically, \cite{hur2022unihpf} proposed a universal framework that can embed entire features in raw EHR data regardless of its schema and medical code standards.
Moreover, the framework showed comparable, if not better, performance on various tasks, even without relying on domain knowledge-based preprocessing.
However, it comes at a steep price of the embedded data having tens to hundreds of times larger in size than existing methods, even if it covers only a few hours of medical trajectory of a patient in hospital.
Therefore, a structure that efficiently extracts the core information from the large input is needed. 

In this study, we search for a versatile model architecture to encode the raw EHR input into a low-dimensional space under the universal text-based encoding framework for diverse tasks such as reconstruction (\textit{i.e.} autoencoding), prediction, and generation.
Throughout the paper, we make the following contributions:
\begin{itemize}
  \item
  To the best of our knowledge, this is the first work to search for a versatile encoder not only reduces the large raw EHR into a manageable size but also preserves patients' core information to perform diverse clinical tasks.
  \item
  We conduct extensive experiments with multiple variables to tune model architectures and various clinical tasks (\textit{i.e., reconstruction, prediction, generation}).
  Furthermore, by experimenting with two representative datasets in the EHR domain (\textit{i.e., MIMIC-III, eICU}), we present concrete evidence for generalizing our research findings to a wide variety of EHR systems.
  We capture the core tendencies while exploring these numerous settings and systematically summarize the findings to give a clear guideline on building the encoder.
  \item
  The encoder that we found is widely applicable in real-world practice.  
  Even with fewer parameters and less training time, a hierarchically structured CNN often outperforms the state-of-the-art model on widely accepted tasks in the field.
\end{itemize}

\section{Related work}
\label{gen_inst}

\paragraph{Feature-selection-based encoder for EHR}
Many researchers have applied a data-driven approach to the healthcare domain.
By making use of EHR datasets, they predict medical outcomes, learn the representation of patients for various downstream tasks, and synthesize medical data.
To perform the clinical tasks, they employed various encoding backbones such as recurrent neural network~\cite{lipton2015lstm, edward2015doctorai, rajkomar2018scalable}, convolutional neural network~\cite{miotto2016deep, nguyen2016deepr, landi2020}, and Transformer~\cite{yoon2022ehr, edward2019gct, shang2020gbert, rasmy2020medbert, li2020behrt, song2018sand}.
However, all such works have invested a lot in preprocessing the raw EHR for standardizing the EHR schema, or feature engineering specifically for the given task.
This is a clear limitation in that extensive human labor and clinical domain knowledge are required to produce satisfactory model performance.

\paragraph{Universal Healthcare Predictive Framework}
Recently,~\cite{hur2022unihpf} presented UniHPF, a universal framework that can embed entire features of raw EHR regardless of schema and medical code standard used in the database.
Specifically, UniHPF views EHR data as pure text and flattened the EHR tables (\textit{e.g.} prescriptions, lab results) to feed them to Transformer-based text encoders.
This text-based approach showed comparable if not better performance compared to conventional approaches on various predictive tasks, even without relying on medical domain knowledge.
Ironically, because it can handle raw EHR data without any preprocessing or feature selection, UniHPF generates extremely long embedded data, given how it encodes entire EHR data in a text-encoding fashion \footnote{
Fig.~\ref{apd:tokenhist} shows the extent to which the number of tokens increases over the observation time}.
This imposes strong computational limits on the framework and necessitates an additional module for compressing the embedded data to a smaller size.

\section{Method}
\label{sec:math}

\begin{figure}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/EHR_structure.pdf}
         \caption{Illustration of EHR tables and patient representation}
         \label{fig:EHRstructure}
     \end{subfigure}
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/encoder_structure.pdf}
         \caption{Encoder framework and examples of hierarchical input $\textbf{x}_{hi}$ and flattened input $\textbf{x}_{fl}$}
         \label{fig:EncoderStructure}
     \end{subfigure}
     \caption{EHR Structure and encoder framework.}
\end{figure}


In order to search for a versatile encoder for raw text-based EHR, we examine different encoder designs.
In Section \ref{subsec:EHRSerial}, we first show how raw tabular EHR is converted into natural text, following the embedding strategy of UniHPF.
In Section \ref{subsec:EncodingFramework}, we construct both hierarchical and flattened encoder structures to confirm the effectiveness of reflecting EHR hierarchy. Also, two highly scalable model classes of CNN and Transformer are considered as backbone models \footnote{We do not consider RNNs in this work, as maximum input can be up to 8,000 tokens.}.

As shown in Fig.~\ref{fig:Pipeline},  we evaluate the significance of the encoder in downstream tasks such as prediction, reconstruction, and generation. Accordingly, we present decoder architectures for reconstruction and generation in Section \ref{subsec:TaskSpecificModels} and explanations for other task-specific models (e.g., classifier) in Section \ref{sec:expdesign}.


\subsection{EHR Serialization}
\label{subsec:EHRSerial}

\paragraph{EHR structure}
Once a patient is admitted to the intensive care unit (ICU), a series of medical events occur during the ICU stay.
Each event is recorded in one of several tables, such as \textit{prescription, diagnosis, lab events} and \textit{input events} in the hospital database. 
Each table consists of multiple rows (e.g., lab events), which in turn consist of multiple columns representing different feature variables (e.g., lab date, lab name, lab value).
The type of cell values can be categorized as textual, numeric, and itemized values (e.g., lab test ID) that can be textualized using a description from the definition table. 
Fig.~\ref{fig:EHRstructure} provides an overview of EHR structure. 

\paragraph{EHR Serialization}
In order to construct the input data, we first extract each patient's records from the multiple tables in the hospital database and sort all events chronologically.
Following the UniHPF-strategy, we formulate patient representation as
\[\textbf{x} = f(\texttt{column name} \otimes g(\texttt{cell}) \otimes \texttt{timegap})\]
where $f$ is a tokenizer, $g$ is a mapping function that converts the type of cell value to text, $\otimes$ is the concatenate function, and $\texttt{timegap}$ represents the quantized time interval between consecutive events.
In detail, $g$ converts an itemized value to a corresponding free text description (e.g., lab test ID 51385 to "Atypical Lymphocytes") and numeric values to text separated by space (e.g., 123.1 to "1 2 3 . 1”).
For $f$, resulting texts are tokenized into the sub-word level.
In this way, with minimal pre-processing, we construct the patient representation $\textbf{x}$ as a sequence of discrete tokens.

In addition, as shown in Fig.~\ref{fig:EHRstructure}, the patient representation has a two levels of hierarchy; event and feature levels.
Specifically, it is described by a sequence of events where each event consists of multiple features. 
Making use of this hierarchical relationship between events and their corresponding features, we define hierarchical input $\textbf{x}_{\hi} \in \mathbb{R}^{n_e \times n_{t/e}}$, and flattened input $\textbf{x}_{\fl} \in \mathbb{R}^{n_t}$, where $n_e$, $n_{t/e}$, and $n_t$ are, respectively, the number of events, the number of text tokens per event, and the number of flattened text tokens.

Note that padding and truncation approaches are used to make fixed $n_e$, $n_{t/e}$, and $n_t$.
Since $\textbf{x}_{\fl}$ is an unfolded version of $\textbf{x}_{\hi}$ with padding removed and events concatenated, $n_t$ is less than $n_e \times n_{t/e}$ although $\textbf{x}_{\fl} $ and $\textbf{x}_{\hi}$ contain exactly the same amount of information.
Examples of $\textbf{x}_{\hi}$ and $\textbf{x}_{\fl}$ are shown on the left in Fig.~\ref{fig:EncoderStructure}.


\subsection{Encoding framework}
\label{subsec:EncodingFramework}
\paragraph{Embedding}
Before feeding the input sequence to an encoder, we embed tokens according to the UniHPF embedding approach. Details are specified in Appendix.~\ref{apd:AdditionalEmbedding}. 
We denote the hierarchical input embedding by $\textbf{E}_{\hi} = \mathtt{Emb}(\textbf{x}_{\hi}) \in \mathbb{R}^{n_e \times n_{t/e} \times d}$, and the flattened input embedding by $\textbf{E}_{\fl} = \mathtt{Emb}(\textbf{x}_{\fl}) \in \mathbb{R}^{n_{t} \times d}$, where $d$ is the token embedding dimension.

\paragraph{Encoder}
To encode $\textbf{E}_{\hi}$ and $\mathbf{E}_{\fl}$ into latent vector $\textbf{z}$, we construct $\Encstruc$ reflecting the input structure.
 Fig.~\ref{fig:EncoderStructure} summarizes the overall encoding process.

For hierarchical embedding $\textbf{E}_{\hi}$, we use a two-stage encoder $\mathtt{Enc}_{\hi}$ consisting of a text encoder $\Enct$ for token embedding within an event, followed by an event encoder $\Ence$ for aggregating and compressing encoded events $\textbf{z}'$ into $\textbf{z}$.
Specifically, $\Enct$ takes per-event token embeddings $\{\textbf{e}_{\hi}^i\}_{i=1}^{n_e} \subset \mathbb{R}^{n_{t/e} \times d}$ as input and produces $\textbf{z}' \in \mathbb{R}^{n_e \times d'}$ with the following operation:
\[\textbf{z}' = \mathtt{Concat}(\mathtt{Flatten}([\Enct(\textbf{e}_{\hi}^1),..., \Enct(\textbf{e}_{\hi}^{n_e})]))\]
where $\mathtt{Flatten}$ is an element-wise operation that expands each $\Enct(\textbf{e}_{\hi}^i)$ into a 1D vector with $d'$ dimension and $\mathtt{Concat}$ is a function that concatenates events in a chronological order.
Note that all $\Enct$ are shared across events. 
Afterwards, $\Ence$ compresses $\textbf{z}’$ into a latent vector $\textbf{z} \in \mathbb{R}^{t \times c}$ where $t$ and $c$ are the desired temporal and channel dimension respectively. 
Such a two-stage process gives the encoder explicit information about the hierarchical structure between events and their features.

For flattened embedding $\textbf{E}_{\fl}$, we use an one-stage encoder $\mathtt{Enc}_{\fl}$ consisting only of $\Enct$, which directly compress $\textbf{E}_{\fl}$ into $\textbf{z}$.



\subsection{Encoding schemes}
\label{subsec:EncodingSchemes}

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
  \vspace*{-6mm}
    \includegraphics[width=0.48\textwidth]{images/Method/overallpipeline.pdf}
  \end{center}
  \caption{Overall pipeline. We search for a versatile encoder design and validate it in three downstream tasks: reconstruction, prediction, and generation.}
  \label{fig:Pipeline}
  \vspace*{-6mm}
\end{wrapfigure}

In this section, we describe how the input embedding 
$\textbf{E}_{\hi}$ or $\textbf{E}_{\fl}$ is compressed into $\textbf{z}$ of a desired dimension.
Note that the encoding strategy is shared for both $\Enct$ and $\Ence$.
Therefore, we can generalize the input and output of each encoder as $\textbf{E}_{input} \in \mathbb{R}^{n \times d}$ with $n$ sequence length and $d$ dimension, and $\textbf{E}_{output} \in \mathbb{R}^{n' \times d'}$ where $n'$ and $d'$ denote the desired length and hidden dimension.

We consider using CNN and Transformer as the backbone of the encoder and develop a custom encoding scheme for each of them.
We examine several Transformer-based encoding schemes summarized in \ref{apd:TransfEncoding} and decide on the encoding strategy for each backbone. 
\ref{alg:CNNlayernum} and \ref{alg:CNNlayerorder} summarize the CNN encoding scheme, while \ref{alg:Transformer} summarizes Transformer encoding scheme.
Specific examples of each algorithm are provided in Table \ref{tab:algCNN} and Table \ref{tab:algTransf}.

\subsection{Decoder}
\label{subsec:TaskSpecificModels}
We employ CNN-based and Transformer-based decoder architectures for the reconstruction and generation tasks (shown in Fig.~\ref{fig:Pipeline}).

The CNN-based decoder is designed with a symmetric structure of the CNN-based encoder.
Specifically, while the encoder layers either compress the dimension in half or leave it unchanged, the decoder layers inversely expand the dimension by two or leave it unchanged, respectively.

For the Transformer-based decoder, we reconstruct the original input $\textbf{x}$ by using cross attention between the latent vector  $\textbf{z}$ and a learnable placeholder embedding with the identical length of $\textbf{x}$.
Specifically, the placeholder embeddings are randomly initialized at first, and while passing through each layer of the decoder, the embeddings are decompressed at the channel level with cross attention applied.

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
  \vspace*{-6mm}
    \includegraphics[width=0.48\textwidth]{images/Method/transformerDecoder.pdf}
  \end{center}
  \caption{Proposed Transformer-based encoder and decoder architecture.}
  \label{fig:transformerdecoder}
  \vspace*{-6mm}
\end{wrapfigure}

As shown in the decoder of Fig.~\ref{fig:transformerdecoder}, the decoder block consists of a transformer decoder layer in which cross-attention is applied and a linear layer for channel increase.
Between the encoder and decoder, we add linear layers in order to match the latent and placeholder dimensions before applying cross attention. This is because the placeholder embedding dimension is increased with each decoder layer.
An exploration of various Transformer-based decoder architectures can be found in Appendix.~\ref{apd:TransfDec}.


\section{Experiments}
\subsection{Dataset description}
\paragraph{Source data}

We experimented with two representative datasets in the EHR domain; MIMIC-III and eICU.
The MIMIC-III dataset comprises deidentified clinical data from more than 40,000 patients admitted to the ICU of Beth Israel Deaconess Medical Center.
The eICU is populated with data from around 140,000 patients who were admitted to a combination of many critical care units throughout the continental United States.
To fully represent patients' medical trajectories, the datasets contain many types of medical events, such as laboratory test, prescription, and input event (e.g., fluid injections) with temporal information.



\paragraph{Cohort definition}
To build cohorts of patients from MIMIC-III and eICU databases, we follow the criteria on which the universal framework~\cite{hur2022unihpf} is based. 
We retrieve records of patients over 18 years old who stayed in the ICU for over 24 hours.
We filter out ICU stays with less than five medical events and use the first 12 hours of events of the first ICU stay for each hospital stay.
For both datasets, we divide patients into separate train, validation, and test sets with a ratio of 8:1:1 in a stratified manner for each target label. 

\subsection{Experimental design and model}
\label{sec:expdesign}
We perform three downstream tasks: reconstruction, prediction, and generation.
For each downstream task, we explore multiple settings for the encoder $\Encstruc$ (or additionally decoder $\Decstruc$), where $struc \in \{\hi, \fl\}$.
We use the same $struc$ for both $\Encstruc$ and $\Decstruc$.
Their backbone can either be CNN or Transformer, denoted by $C$ and $T$, respectively.


\paragraph{Reconstruction task}
In order to evaluate the efficacy of the encoder in preserving patient information, we build an autoencoder as follows: 
$$ \mathbf{\Tilde{x}} = \mathtt{Dec}_{struc}(\mathtt{Enc}_{struc}(\mathbf{x}))$$
We train the autoencoder with a cross-entropy loss between $\mathbf{x}$ and $\mathbf{\tilde{x}}$.
We experimented $(\mathtt{Enc}_{struc}, \mathtt{Dec}_{struc})$ on $(C,C), (T,C) \text{ and } (T,T)$ for $\hi$ and $\fl$.
We evaluate the reconstruction performance via token-level accuracy, the ratio of correct tokens to the total number of tokens.


\paragraph{Prediction task}
\label{para:prediction}
To perform clinical outcome prediction, we formulate the task as binary, multi-class or multi-label classification: 
$$\tilde{\textbf{y}}=\mathtt{Classifier}(\mathtt{Enc}_{struc}(\mathbf{x}))$$
The encoder and classifier are trained with the binary cross-entropy loss (cross-entropy loss for multi-class) between the predicted probabilities $\tilde{\textbf{y}}$ and the true label $\textbf{y}$.
For $\mathtt{Classifier}$, we use Transformer due to its permutation invariant nature, rather than a purely MLP-based classifier\footnote{Detailed discussion regarding the choice of classifier architecture is provided in Appendix.~\ref{apd:BuildingClassifier}}.
After linearly projecting $\textbf{x}$ into $\textbf{z}$, we pass $\textbf{z}$ through the Transformer layers.
The output is then averaged and linearly mapped to generate logits for each class.
We adopted six clinically meaningful prediction tasks following \cite{hur2022unihpf}; Diagnosis, Mortality, Final acuity Imminent Discharge, Length-Of-Stay for cases of three and seven days.
Further details of each clinical task are provided in the Appendix.~\ref{apd:DefClinicTask}.
We evaluated all prediction tasks in terms of AUROC.



\paragraph{Generation task} 
For the unconditional synthesis of textualized EHR $\textbf{x}$, autoregressive modeling of $\textbf{x}$ is challenging due to the high modeling capacity and memory inefficiency required by the considerable sequence length of UniHPF syntax.
Therefore, we use the VQ-VAE~\cite{van2017neural} approach to model the discrete latent space autoregressively. 
The VQ-VAE consists of  $\Encstruc$, $\Decstruc$, a vector quantization layer $\mathtt{VQ}$ and a learnable codebook, formulated as follows:
\begin{align*}
\textbf{z}_q &= \mathtt{VQ}(\Encstruc(\textbf{x})), \
\tilde{\textbf{x}}=\Decstruc(\textbf{z}_q) 
\\ \hat{\textbf{x}} &= \Decstruc(\hat{\textbf{z}_q}) \ \text{where} \ \hat{\textbf{z}_q} \sim p(\textbf{z}_q)
\end{align*}
where $\mathtt{VQ}$ maps each vector $\textbf{z}=\Encstruc(\textbf{x})$ into $\textbf{z}_q$ with the nearest code. 
The VQ-VAE is trained in two steps. 
First, $\Encstruc$, $\Decstruc$, and codebook are simultaneously trained to minimize the distance between $\textbf{x}$ and $\tilde{\textbf{x}}$ and the distance between $\textbf{z}$ and $\textbf{z}_q$.
Second, the Transformer-based autoregressive model is trained to learn the prior distribution over the discrete latent space $p(\textbf{z}_q)$.
Then the sampled latent code sequence is passed into the decoder to synthesize $\hat{\textbf{x}}$.
Further details of training VQ-VAE are in Appendix.~\ref{apd:VQVAE}. We conduct experiments on $(C,C)$, $(T,C)$ and $(T,T)$ for $\hi$.

We assess the quality of synthetic data quantitatively, qualitatively, and from a privacy perspective. We propose a metric to measure the preservation of table syntax and semantic consistency by comparing triples (\texttt{table}, \texttt{column name}, \texttt{cell}) in generated data with real data.
For example, the lab ID should be on a lab table, not a prescription table.
On a per-event or per-sample basis, we compute \textbf{RCE} (ratio of correct events to total events), \textbf{RUE} (ratio of correct unique events to total unique events), and \textbf{RCS} (ratio of correct samples to total samples).
Specifics regarding the evaluation algorithm and scoring metrics are listed in Appendix.~\ref{apd:SyntheticDataScoring}.
To qualitatively compare the distribution of original and synthetic data, we used t-SNE to visualize latent vectors in a two-dimensional space. 
In addition, for the privacy evaluation, we conducted a membership inference attack~\cite{shokri2017membership}, and the task definition and results are shown in Appendix.~\ref{apd:MI}.

\subsection{Implementation details}

For the CNN-based encoder (shown in Algorithm.~\ref{alg:CNNlayernum} and \ref{alg:CNNlayerorder}), we experiment on both 5x5 kernel size (with stride 2, pad 2) and 1x1 kernel size. 
For the Transformer-based encoder (Algorithm.~\ref{alg:Transformer}), we use two transformer layers for $\Enchi$ and four Performer~\cite{choromanski2020rethinking} layers for $\Encfl$, in which all layers in both $\Enchi$ and $\Encfl$ use 4 attention heads. 

We use 2 Transformer layers with 4 heads and a hidden dimension of 128 for the $\mathtt{Classifier}$.
As for the Transformer-based autoregressive model used for generation, we utilize 4 Transformer layers with 4 heads and a hidden dimension of 256.
Additionally, we select a learning rate of 5e-4 (or 5e-5 for models that failed to train), with a batch size of 16, 32, 64 for reconstruction, prediction, and generation, respectively. 
Experiments are conducted with different random seed values, with three seeds for reconstruction and prediction, and two seeds for the generation.

\subsection{Searching range}
For input embeddings $\Embhi \in \mathbb{R}^{n_e \times n_{t/e} \times d}$ and $\Embfl \in \mathbb{R}^{n_{t} \times d}$, we employ $n_e=256$, $n_{t/e}=128$ for $\Embhi$, and $n_t=8192$ for $\Embfl$.
The embedding layer $\mathtt{Emb}$ has a fixed dimension $d=256$.
For the compressed latent vector $\textbf{z} \in \mathbb{R}^{t \times c}$ of $\Embhi$ and $\Embfl$, we define the latent dimension $l = t \times c$.

For prediction and reconstruction tasks, we explore its size starting from $l$ = 256 and double it up until $l$ = 4096.
For each $l$, represented as $2^{2i-1}$ or $2^{2i}$, we search five possible cases of $t$ from $2^{i-2}$ to $2^{i+2}$ by increasing $i$.
(\textit{e.g.,} For the latent vector $\textbf{z}$ having $l=2048=2^{2*6-1}$, we search $t$ from $2^{4}$ to $2^{8}$).

However, for the generation task, we use a less compressed searching range of $l$, starting from 4096 up to 32768.
This is because the first stage in VQVAE can be viewed as conducting reconstruction along with vector quantization, in which additional information loss is inevitable.

Compression rate, indicating how many times $\Embhi$ or $\Embfl$ is larger than $\textbf{z}$, can be calculated by $\frac{n_e\times n_{t/e}\times d}{l}$ and $\frac{n_t\times d}{l}$, respectively.
(\textit{e.g.,} if $\textbf{z}$ has a shape of $(256, 8)$ in hierarchical case, the compression rate is ${\times}4096 = \frac{256 \times 128 \times 256}{2048}$).
Consequently, $\Enchi$ has a compression rate ranging from 2048 to 32768, while $\Encfl$ has a lower rate ranging from 512 to 8192.

\section{Result}

We conducted extensive experiments on building $\Encstruc$ for the above reconstruction, prediction, and generation tasks.
Specifically, we experiment on different types of backbone models, both $\hi$ and $\fl$ structures, and various combinations of ($t$, $c$) of latent vector $\textbf{z}$ $\in \mathbb{R}^{t \times c}$.


\subsection{Reconstruction}

\begin{figure}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/recon_summary/eicu_latent_dim_recon.pdf}
         \caption{Reconstruction performances arranged by the latent dimension $l$}
         \label{recon_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/recon_summary/eicu_spatial_dim_recon.pdf}
         \caption{Reconstruction performances arranged by the temporal dimension $t$}
         \label{recon_summary_temporal}
     \end{subfigure}
    \caption{Comparison of reconstruction performance for both MIMIC-III (left) and eICU (right) datasets.}
    \label{recon_summary}
\end{figure}

For the reconstruction task for MIMIC-III and eICU datasets, CNN outperforms Transformer when used as both the encoder and a decoder.
Fig.~\ref{recon_summary_latent} shows the reconstruction performances of autoencoders $(C, C)$, $(T, T)$, and $(T, C)$ at the same latent dimension $l$.
We evaluated each backbone as an encoder by comparing models with the different encoders but with the same decoder and vice versa for the decoder case.

Results in Fig.~\ref{recon_summary_latent} show that CNN is a better encoder compared to Transformer, as $(C, C)$ shows higher performance compared to $(T, C)$ both $\hi$ and $\fl$ structures.
When compared in the same manner, CNN as a decoder showed a far better performance than Transformer.
This was a much wider margin than for the encoder case.
The conclusion that CNN is better in both aspects is reinforced by the fact that the autoencoder composed solely of CNN performs better than that of Transformers.

\paragraph{Finding} 

Our experiment results show that EHR as a time series dataset has inherent temporal locality; each medical event contained in EHR is mainly correlated with events that happened in a short period.
Specifically, the reconstruction results with CNN, having a local receptive field, outperform that of Transformer, which has a global receptive field.
Moreover, as depicted in Appendix.~\ref{apd:LocalEHR}, Transformer mainly attends temporally proximal events represented by the elements near the diagonal line
, which shows an entirely different pattern in the case of prediction.
Lastly, by rearranging the results with temporal dimension $t$ as shown in Fig.~\ref{recon_summary_temporal}, CNN performs clearly better as $t$ increases, while Transformer stagnates or decreases.
Thus, in order to preserve patient information with minimal loss, it is better to keep more temporal information even within the same latent dimension.

\subsection{Prediction}

\begin{figure}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred_summary/eicu_latent_dim_pred_True_auroc_average.pdf}
         \caption{Prediction performances arranged by the latent dimension $l$}
         \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred_summary/eicu_spatial_dim_pred_True_auroc_average.pdf}
         \caption{Prediction performances arranged by the temporal dimension $t$}
         \label{pred_summary_temporal}
     \end{subfigure}
    \caption{Comparison of prediction performance for both MIMIC-III (left) and eICU (right) datasets.}
    \label{pred_summary}
\end{figure}

For the prediction tasks, the CNN-based encoder shows comparable performance to the Transformer-based encoder in the hierarchical setting.
Fig.~\ref{pred_summary} illustrates the averaged AUROC performance of the six prediction tasks for each model architecture.
As the four models share the same classifier, we compare the results based on different encoder settings.
Specific results for each task are reported in Appendix.~\ref{apd:Pred6Tasks}.
For the $\hi$ setting, the CNN-based encoder shows comparable performance to Transformer, whereas for the $\fl$ setting, CNN shows lower performance.
Such results imply that explicit information on EHR hierarchy is more effective for the CNN-based encoder than the Transformer encoder in predictive tasks.
Such results imply that explicit information on EHR hierarchy is more effective for the CNN compared to the Transformer in predictive tasks.

\paragraph{Finding} 

For the CNN-based encoder, both reconstruction and prediction tasks showed a significant positive correlation.
As shown in Fig.~\ref{apd:pca}, the CNN-based encoder learns similar latent representations for reconstruction and prediction
Moreover, as shown in Fig.~\ref{pred_summary_temporal}, keeping more temporal information by increasing $t$ improves the predictive performance, even within the same $l$.
By increasing $t$, we can thus enhance the CNN-based encoder in both aspects simultaneously, resulting in higher performance for both reconstruction and prediction tasks.

\subsection{Generation}
\label{section:Gen}

\begin{figure}
     \centering
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/mimic3_RCE.pdf}
         \caption{MIMIC-III/RCE}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/mimic3_RCS.pdf}
         \caption{MIMIC-III/RCS}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/eicu_RCE.pdf}
         \caption{eICU/RCE}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/eicu_RCS.pdf}
         \caption{eICU/RCS}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Quantitative evaluation on MIMIC-III dataset and eICU dataset. RCE and RCS represent the ratio of correct events to total events and the ratio of correct samples to total samples, respectively.}
    \label{fig:scores}
\end{figure}

\begin{figure}
     \centering
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genTsne/0_5_mimic3_2022_enc_conv_None_32768_3_3d.pdf}
         \caption{(C,C)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genTsne/0_5_mimic3_2022_enc_transf_dec_conv_32768_3_3d.pdf}
         \caption{(T,C)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genTsne/0_5_mimic3_2022_enc_transf_None_32768_3_3d.pdf}
         \caption{(T,T)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{t-SNE visualization on latent space on MIMIC-III dataset.}
    \label{fig:tsne}
\end{figure}

\paragraph{Quantitative evaluation}

As shown in Fig.~\ref{fig:scores}, we report the results of proposed metrics according to the different encoder, decoder combinations, and latent dimensions.
High RCE indicates that each generated event follows the table structure while maintaining the semantic consistency of input.
The RCS, a stricter measure, denotes the amount of synthetic patient data readily available.
In the case of latent dimension 32768, $(C,C)$ and $(T,C)$ show comparable performance. 
However, as the compression rate increases, the performance gap between $(C,C)$ and $(T,C)$ is enlarged, with $(C,C)$ showing superior performance. 
Such results indicate that the CNN-based encoder effectively preserves patient information despite a high compression rate.
$(T,T)$, on the other hand, generally shows the lowest performance compared to both $(C,C)$ and $(T,C)$.
We also report RUE on the Appendix.~\ref{apd:RUE}.

\paragraph{Qualitative evaluation}

We conduct t-SNE on the encoded latent $\textbf{z} \in \mathbb{R}^{32768}$ of $(C,C)$, $(T,C)$ and $(T,T)$ for both the original and synthetic data, as shown in Fig.~\ref{fig:tsne}.
The distributions of both the original and synthetic data surprisingly form in multiple clusters with some outliers.
For the case of $(C,C)$, although the synthetic data distribution does not cover all outliers, it shows clusterings in similar regions to the original.
On the other hand, the synthetic data of $(T,C)$ and especially $(T,T)$ also form condensed clusters that resemble those of the original data. 
However, some clusters do not contain any original data clusters.
Such results show that compared to the Transformer-based encoder, the CNN-based encoder better encodes the input with similar distributions to the original data.

Furthermore, the aforementioned privacy assessment showed a low possibility of privacy leakage due to poor membership inference performance, and details can be found in Appendix.~\ref{apd:MI}.


\newcommand\effreconwidth{0.44}
\newcommand\effpredwidth{0.46}

\begin{wrapfigure}[40]{r}{.5\textwidth}
    \vspace*{-6mm}
     \centering
     \begin{subfigure}[b]{.53\textwidth}
         \centering
         \includegraphics[width=\effreconwidth\textwidth]{images/efficiency/mimic3_recon_enc_params_cnt.pdf}
         \includegraphics[width=\effpredwidth\textwidth]{images/efficiency/mimic3_pred_enc_params_cnt.pdf}
         \caption{Model Size vs. Performance}
         \label{fig:numparams}
     \end{subfigure}
     % \hfill
     
     \begin{subfigure}[b]{.53\textwidth}
         \centering
         \includegraphics[width=\effreconwidth\textwidth]{images/efficiency/mimic3_recon_flops_cnt.pdf}
         \includegraphics[width=\effpredwidth\textwidth]{images/efficiency/mimic3_pred_flops_cnt.pdf}
         \caption{FLOPs vs. Performance}
         \label{fig:flops}
     \end{subfigure}
     % \hfill
     
     \begin{subfigure}[b]{.53\textwidth}
         \centering
         \includegraphics[width=\effreconwidth\textwidth]{images/efficiency/mimic3_recon_time_2.pdf}
         \includegraphics[width=\effpredwidth\textwidth]{images/efficiency/mimic3_pred_time_2.pdf}
         \caption{Training time vs. Performance}
         \label{fig:time}
     \end{subfigure}
     % \hfill
    \caption{Reconstruction (left) and prediction (right) performances on MIMIC-III relative to the resource (the number of parameters, FLOPs, and training time) consumed.
    In all figures, CNN having $\hi$ structure is located in the upper left corner; it shows better performance with lower cost than the others.
    For each model, we grouped variants based on $l=t\times c$ and averaged them.
    As the strategy of building $\Encstruc$ varies by the ratio of $t$ to $c$ even with same $l$, the model size is not strictly proportional to the compression rate.}
    \label{fig:efficiency}
    \vspace*{-10mm}
\end{wrapfigure}


\subsection{Structure}
We compared the hierarchical structure to the flattened one to measure the effect with all the other variables controlled.
In  Fig.~\ref{recon_summary} and ~\ref{pred_summary}, the blue histogram is generally located above the red histogram, indicating that hierarchically structuring the model led to higher performance across tasks and backbone models.
Using the inherent hierarchy of the EHR system can boost the model's performance.


\subsection{Time and Parameter Efficiency}

We compare the resource consumption of each model in our experiments.
Fig.~\ref{fig:efficiency} illustrates the parameters-performance, FLOPs-performance, and time-performance curves for the models performing the reconstruction task.
% For the number of parameters and FLOPS, we only consider the encoder without the rest of the model.
We only consider the encoder without the rest of the model for the number of parameters and time consumed for training.
Compared to the Transformer-based models, the results of the CNN-based models are located in the upper left part for all \ref{fig:numparams}, \ref{fig:flops} and \ref{fig:time}.
Thus, CNN is a better backbone for building an encoder than Transformer, even with notably fewer parameters and lower computational cost.

\section{Conclusion}
We have searched for a versatile architecture to encode the raw EHR input into a low-dimensional space when the input processed by the universal framework is on a large scale.
To the best of our knowledge, this is the first work to search for a versatile encoder not only reducing the large EHR into a manageable size but also well preserving the core information of patients to perform clinical tasks.
Even with fewer parameters and less training time, hierarchical CNN outperforms the state-of-the-art model on widely accepted tasks in the field.
Moreover, it turns out that making use of the inherent hierarchy of the EHR system can boost the performance of any backbone models and clinical tasks performed.
By conducting extensive experiments, we present concrete evidence for generalizing our research findings into real-world practice.
We capture the core tendencies while exploring these numerous settings and systematically summarize the findings to give a clear guideline on building the encoder.

\bibliographystyle{plainnat}
\bibliography{neurips_2023}

\appendix

\section{Input Embedding}
Before being embedded to the encoder, token sequence $\textbf{x}$ is first mapped to a vector representation based on a learnable lookup table.
We additionally add different types of embeddings to the vector representation:
\label{apd:AdditionalEmbedding}
\begin{itemize}
\item \textbf{Token-type embedding} 
adds table structure information to the vector representation, considering that the input is based on tabular data.
The embeddings added are \texttt{[table name]}, \texttt{[column name]}, \texttt{[column value]}, \texttt{[timegap]}, \texttt{[start token]}, \texttt{[end token]}, and \texttt{[pad token]}.

\item \textbf{Digit-place embedding} 
adds value embeddings for numeric features (e.g. dosage, rate).
% Since neural tokenizers are notorious for having difficulty processing numbers, we introduce DPE to allow models to recognize numbers naturally.
Since neural tokenizers are notorious for having difficulty in processing numbers, we use Digit-Place embedding (DPE) to allow the models to recognize numbers naturally.
DPE first splits the numeric values into digits and assigns each digit to its place value.
For example, "123.1" becomes "1 2 3 . 1”, and corresponds to “\texttt{[hundreds]}, \texttt{[tens]}, \texttt{[units]}, \texttt{[decimal point]}, \texttt{[tenth]}".
For tokens that are not a number or decimal point, we add \texttt{[non-digit]}. 

\item \textbf{Positional embedding} adds a time signal by mapping each position of the sequence to the embedding space.
Such embedding is needed for models without recurrence or convolution, such as the Transformer.
Thus, we use sinusoidal positional embedding for the Transformer-based encoder.
\end{itemize}

\section{Definition of clinical predictive task}
\label{apd:DefClinicTask}
\begin{enumerate}
\item \textit{Diagnosis Prediction} (Dx) (multi-label):
Predicting all diagnoses occurred during the entire ICU stay.
By following Clinical Classification Software (CCS) for ICD-9-CM criteria, diagnosis codes are classified into 18 categories. 

\item  \textit{Final Acuity} (Fi\_ac) (multi-class):
At the end of the ICU stay, predict where the patient will be discharged among the various places.


\item  \textit{Imminent Discharge} (Im\_disch) (multi-class):
Predict whether the patient will be discharged within the subsequent prediction window of 48 hours and, if so, where to be discharged.

\item  \textit{Mortality Prediction} (Mort) (binary):
Predict whether or not a patient will be discharged with the state ``expired'' within the prediction window of 48 hours.
The discharge state was ``expired'' within the prediction window of 48 hours.

\item  \textit{Length-of-Stay Prediction} (binary):
Predict whether the patient’s whole length of stay will be longer than 3 days or not (LOS3), and 7 days or not (LOS7).

\end{enumerate}

\section{Choice of classifier backbone for the prediction tasks}
\label{apd:BuildingClassifier}
We consider using MLP and Transformer as the backbone of the classifier for latent vector $\textbf{z}$.
When CNN encodes $\textbf{x}$ into $\textbf{z}$, the temporal order of $\textbf{x}$ is preserved (i.e., permutation equivariant).
Thus, the classifier should aggregate $z$ to be permutation invariant for better prediction.

\begin{wrapfigure}{r}{0.5\textwidth}
    \includegraphics[width=\linewidth]{images/Appendix:Classifier/classifier_backbone.pdf}
    \vspace*{-5mm}
    \centering
    \caption{Prediction results according to the classifier backbone when $z^{2048}$ is compressed by a CNN-based one-stage encoder.}
    \label{fig:clsf}
\end{wrapfigure}
For the MLP-based classifier, the latent vector $\textbf{z}$ is first flattened into a 1D vector, then linearly projected into logits.
However, only specific parameters are used to process $\textbf{z}$ at specific locations, preventing full aggregation of $\textbf{z}$ into logits.

The Transformer-based classifier, on the other hand, passes $\textbf{z}$ into the self-attention layer, resulting in complete aggregation of $\textbf{z}$ (i.e., permutation invariant).

As a result, we choose the Transformer-based classifier instead of the MLP classifier.
Fig.~\ref{fig:clsf} also shows that the CNN-based encoder using Transformer as a classifier has a higher AUROC than MLP, proving that prediction on permutation invariant features is a better choice.

\section{VQ-VAE}
\label{apd:VQVAE}
\paragraph{Stage 1. Learning a codebook}
With the conventional VQ-VAE method, latent vector $z \in \mathbb{R}^{t \times c}$ consists of $t$ fibers, and each fiber $z^i \in \mathbb{R}^c$ is mapped to the nearest code.
However, in order to improve the representation of each fiber, we divide each fiber into four pieces and replace each piece $z^{i,j} \in \mathbb{R}^{c/4}, j \in 1,...,4$ with its closest code from the codebook $\{e_k\}_{k=1}^K \in \mathbb{R}^{c/4}$ as follows:
$$\textbf{z}_q^{i,j} = e_k \ \text{where} \ k = \text{arg min}_l ||z^{i,j}-e_l||$$
As a result, $z$ is mapped into $z_q$ with $4t$ codes, and $z_q$ is fed to the decoder to reconstruct $\tilde{x}$.

The encoder, decoder, and codebook are trained end-to-end to minimize the distance between $\textbf{x}$, $\tilde{\textbf{x}}$ and $\textbf{z}$, $\textbf{z}_q$ respectively:
$$\mathcal{L}_{VQ}= ||\textbf{x}-\tilde{\textbf{x}}||^2_2 + ||\text{sg}[z]-z_q||^2_2 + \beta ||\text{sg}[z_q]-z||^2_2$$
where  sg$[\cdot]$ stands for the stop gradient operation, which supplements the non-differentiable quantization operation, and $\beta$ is a weight hyperparameter. 
In our case, we replace the second loss term with an exponential moving average for the codebook.

\paragraph{Stage 2. Learning a prior over discrete latents}
We train the Transformer-based autoregressive model to learn the prior distribution over the discrete latent space:
$$p(z_q)=\prod_i^{4t} p(z_{q,i}|z_{q,1}, ..., z_{q,i-1})$$
The autoregressive model predicts the next code based on past codes on every step to maximize the log-likelihood of the joint distribution of $p(z_q)$:
$$\mathcal{L}_{AR}=\mathbb{E}_{x \sim p(x)}[-logp(z_q)]$$
Finally, the sampled latent code sequence from $p(z_q)$ is decoded to generate $\hat{x}$.

\section{Qualitative Evaluation Method for Synthetic Data}
\label{apd:SyntheticDataScoring}
Real data $D_R$ consists of samples representing patient data, and each sample consists of multiple events $E_R$.
Each event $ E_r \in E_R $,  can be expressed as follows: $ (\texttt{table}, (\texttt{column name}, \texttt{cell}) \times \textit{n}, \texttt{timegap})$, where \textit{n} represents the number of columns for the event.
Likewise, synthetic data $D_G$ consists of samples with multiple events $E_G$. 
We evaluate the quality of synthetic data based on table syntax preservation and semantics consistency by comparing triples (\texttt{table}, \texttt{column name}, \texttt{cell}) in $E_G$ to $E_R$.
The two-step procedure is as follows: (1) Definition of a set of triples (\texttt{table}, \texttt{column name}, \texttt{content}) based on $E_R$, (2) Synthetic data evaluation based on pre-defined triples.

\paragraph{Definition of a set of triples}
Each event $E_r$ is first split into triples of (\texttt{table}, \texttt{column name}, \texttt{cell}).
Each \texttt{cell} can be categorized as either numeric or text-type.
For the (\texttt{table}, \texttt{column name}) combinations of all resulting triples from $E_R$, we remove duplicates and extract only the minimum and maximum values for numeric-type \texttt{cell}s while performing tokenization for text-type $\texttt{cell}$s.
As a result, we build a refined set of triples (\texttt{table}, \texttt{column name}, \texttt{content}).
\vspace*{-3mm}

\paragraph{Synthetic data evaluation}


\begin{algorithm}
\SetKw{kwSet}{set}
\SetKw{kwTo}{to}
\DontPrintSemicolon
\caption{Qualitative Evaluation Metric for Synthetic Data}
\label{alg:Metric}
\For {$ E_g \in  E_G $} {
    \tcp{ syntax check}
    \If {not (\texttt{order}($E_g$) or \texttt{column\_pair}($E_g$) or \texttt{table\_column}($E_g$))}{
        \Return incorrect \;
    }
    \tcp{ semantics check}
    \For{(column, content) in $E_g$} {
        \uIf {type(column) is numeric}{
            \uIf{not min\_max(content)}{
            \Return incorrect \;
            }
        }
        \uElse{
        \uIf{not sub\_word(content)}{
            \Return incorrect\;
            }
        }
    }
    \Return correct}
\end{algorithm}
\vspace*{-2mm}

We define the functions of Algorithm.~\ref{alg:Metric} as follows:

To measure syntactic consistency, 
\textbf{\textit{order}} checks whether $E_g$ starts with a table name.
\textbf{\textit{column\_pair}} checks whether columns and contents consist in a pair.
\textbf{\textit{table\_column}} checks whether the table and column names are in the pre-defined set.

To evaluate semantic consistency,
for numeric-type cells, \textbf{\textit{min\_max}} checks whether the content lies within the minimum and maximum value of $(\texttt{table}, \texttt{column name})$ in the pre-defined set.
For the text-type cells, \textbf{\textit{sub\_word}} splits the cell values into subwords and then checks whether the split content is in the pre-defined set of $(\texttt{table}, \texttt{column name})$.

Based on evaluation of each $E_g$ with Algorithm.~\ref{alg:Metric},  we use the 3 metrics below to report the synthetic data scores:
\begin{itemize}
\item \textbf{RCE}: ratio of correct events to total events
\item \textbf{RUE}: ratio of correct unique events to total unique events
\item \textbf{RCS}: ratio of correct samples to total samples
\end{itemize}
Specifically, RCE and RUE evaluate the number of correct events given all generated events on a non-unique and unique basis, respectively.
RCS evaluates the number of correct patient samples out of all generated patient samples, in which each patient sample is a batch of events.
By measuring the event-level and sample-level accuracy of $D_G$, we can analyze the consistency of $D_G$ with $D_R$. 
\vspace*{-3mm}

\iffalse
Each \texttt{content} in $E_R$ can be split based on words or sub-words by using spacing or the BERT Tokenizer, respectively.

\begin{itemize}
\item \textbf{Create Predefined Dictionary based on Tabular Input Data} \\
We evaluate the generated synthetic data based on how well the input data format is preserved. In order to do so, we create an input-based predefined dictionary such as the following:

\begin{itemize}
\item Input data table names, and corresponding column names for each table are saved in the dictionary. 

\item For non-numeric contents (i.e., tabular cell values of non-numeric columns), we save the contents of each column in two formats: word-based and subword-based. For the word-based format, we use spacing to split each content, while for the subword-based format, we use the BERT Tokenizer for splitting the contents.
The word-based and subword-based split contents are saved in the dictionary for each column in each table. 

\item For numeric contents (i.e., tabular cell values of numeric columns), we save the minimum and maximum values of each numeric column for each table.
\end{itemize}


\item \textbf{Evaluate Generated Synthetic Data} \\ 
The evaluation process consists of two steps: syntax check and semantics check. We evaluate the data based on each event.

\begin{itemize}
\item For syntax check, we first check whether each event of the synthetic data starts with a table name and whether the columns and contents consist of a pair.
Next, we evaluate whether each event's table name and columns are in the predefined dictionary.

\item For semantics check of non-numeric contents, we conduct the both word-based and subword-based evaluation. For word-based evaluation, we first split the content of each event by spacing and check whether each split word is in the predefined word-based content of the event's corresponding table name and column. 
\item For semantics check of numeric contents, we check whether the value lies within the predefined minimum and maximum value of the event's corresponding table name and column.

\end{itemize}

\item \textbf{Synthetic Data Scoring Metrics} \\
The generated synthetic data consists of multiple samples, which consist of a bundle of events. We use the above evaluation method to check if each event is correct and report the synthetic data scores based on the four metrics below.
\begin{itemize}
\item SE: (\# of correct events with subword-based evaluation) / (\# of total events)
\item SU: (\# of correct unique events with subword-based evaluation) / (\# of total unique events)
\item SS: (\# of correct samples with subword-based evaluation) / (\# of total samples)
\item U: (\# of total unique events) / (\# of total events)
\end{itemize}

\end{itemize}
\fi



\hfill \break
\hfill \break
\hfill \break
\hfill \break


\section{Additional results of qualitative evaluation (RUE)}
\label{apd:RUE}
\begin{wrapfigure}{r}{.5\textwidth}
\vspace*{-6mm}
     \centering
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/mimic3_RUE.pdf}
         \caption{RUE/mimic-III}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Method/genBarPlot/eicu_RUE.pdf}
         \caption{RUE/eicu}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Quantitative evaluation on MIMIC-III dataset and eICU dataset. RUE represents the ratio of correct unique events to total unique events.}
    
\end{wrapfigure}
We measured RUE metrics for synthetic data. 
Since RUE ignores duplicates and only considers unique events, it can measure the generative data from a different perspective than RCE.
However, as shown in Fig.~\ref{apd:RUE}, it matches other metrics in Section.~\ref{section:Gen}.


\section{Privacy evaluation}
\label{apd:MI}


\begin{wrapfigure}{r}{0.5\textwidth}
\vspace*{-15mm}
  \begin{center}
    \includegraphics[width=0.48\textwidth]{images/Method/genMI/eicu_2020_enc_conv__None_32768_128.pdf}
  \end{center}
  \caption{Recall (left) and precision (right) according to the number of real data that the attacker can access. The legend expressed the Hamming distance threshold divided by the number of tokens.}
  \label{fig:MI}
\end{wrapfigure}
Privacy evaluation is essential for assessing the quality of synthetic medical data.
Membership inference was conducted to measure privacy leakage risk, aiming to infer if a given record was used during model training.

We generated 1,000 records and sampled $n_r$ records each for train data and test data.
The attacker has access to the real records of $2n_r$ and determines if each record was used for synthetic data creation via Hamming distance threshold between the two records. 

Fig.~\ref{fig:MI} shows recall and precision of membership inference for CNN-based VQ-VAE. 
Recall is the ratio from which members of a training set are correctly inferred as members by the attacker.
Precision represents how many of the samples inferred as members are actually members of the training data set.
Precision and recall are zero when the Hamming distance threshold is zero, indicating that the synthetic data is not memorized by the model nor copied from the training data.
A precision around 0.5, regardless of the $n_r$, suggests the attacker has poor membership inference performance.


\section{Algorithm for building encoders and examples}
For CNN encoding scheme, Algorithm.~\ref{alg:CNNlayernum} and \ref{alg:CNNlayerorder} respectively summarize the number of layers by type and the order of layers.
To reduce the biased effect on the manifold in low-dimensional space when compressing only one dimension consecutively, we carefully design the order of layers to compress the temporal and channel dimensions alternately.

For Transformer, Algorithm.~\ref{alg:Transformer} summarizes encoding scheme.

We provide examples of algorithms for building encoders in Table.~\ref{tab:algCNN} and \ref{tab:algTransf} for some specific cases.

\newcommand{\dict}{D_{enc}}

\begin{algorithm} %
\DontPrintSemicolon
\SetAlgoLined
% \caption{CNN encoder: the number of layers by type}
\caption{CNN encoding scheme: the number of layers by type}
\label{alg:CNNlayernum}

\newcommand{\Ln}{L_n}
\newcommand{\Ld}{L_d}
\newcommand{\Lb}{L_{nd}}
\newcommand{\Einput}{\mathbf{E}_{input}}
\newcommand{\Eoutput}{\mathbf{E}_{output}}
\newcommand{\ninput}{n}
\newcommand{\noutput}{n'}
\newcommand{\dinput}{d}
\newcommand{\doutput}{d'}



\BlankLine
\KwIn{$\Einput \in \mathbb{R}^{n \times d}, \noutput, \doutput$}
\tcp{$(\noutput, \doutput):$ an expected shape of $\Eoutput$}
% \KwIn{$\ninput, \dinput, \noutput, \doutput$}
\KwOut{$\dict$}
\tcp{
% $(\noutput, \doutput):$ an expected shape of $\Eoutput$\\
$\Ln$ compresses $\ninput$-axis in half\\
$\Ld$ compresses $\dinput$-axis in half\\
$\Lb$ compresses $\ninput$ and $\dinput$ axes in half
} 
\newcommand{\nlayers}{n_l}
\tcp{Determine the number of layers $\nlayers$}

\newcommand{\rn}{r_n}
\newcommand{\rd}{r_d}
$\rn\leftarrow log_2(n/n')$\;
$\rd\leftarrow log_2(d/d')$\;
$n_l\leftarrow max(\rn, \rd)$\;
% $n_l\leftarrow r_t$ if $r_t > r_c$ else $r_c$\;
\BlankLine
\tcp{Decide the number of layers by type}
\uIf{$\rn > \rd$}{
$\dict\leftarrow\{\Lb:\rd,\; \Ln: \nlayers-\rd\}$\;
% \Return $[\Lb]*\rd+[\Ln]*(\nlayers-\rd)$\;
}
\uElseIf{$\rn < \rd$}{
$\dict\leftarrow\{\Lb:\rn,\; \Ld: \nlayers-\rn\}$\;
% \Return $[\Lb]*\rn+[\Ld]*(\nlayers-\rn)$\;
}
\uElse{
$\dict\leftarrow\{\Lb: \nlayers\}$ \;
% \Return $[\Lb] * \nlayers$ \;
}
\end{algorithm}

\begin{algorithm} % 수정중
\DontPrintSemicolon
\SetAlgoLined
% \caption{CNN encoder: the order of layers}
\caption{CNN encoding scheme: the order of layers}
\label{alg:CNNlayerorder}

\newcommand{\Ln}{L_n}
\newcommand{\Ld}{L_d}
\newcommand{\Lb}{L_{nd}}
\newcommand{\Einput}{\textbf{E}_{input}}
\newcommand{\Eoutput}{\textbf{E}_{output}}
\newcommand{\ninput}{n}
\newcommand{\noutput}{n'}
\newcommand{\dinput}{d}
\newcommand{\doutput}{d'}
\newcommand{\nlayers}{n_l}
\newcommand{\rn}{r_n}
\newcommand{\rd}{r_d}


\BlankLine
\KwIn{$\dict,\nlayers,\rn,\rd$}
\KwOut{encoder layers}
\newcommand{\blocknb}[1][alt]{block_{#1}}

\tcp{$\blocknb$ compresses $n$ and $d$ axes alternatively}

\BlankLine

\uIf{$\Ln\in\dict$}{
\newcommand{\numn}{num_n^{block}}
\newcommand{\numremainder}{num_n^{rem}}
\newcommand{\blockrep}{block_n}
\newcommand{\blocknbn}{block_{alt'}}
$\numn \leftarrow (\nlayers+1)//(\rd+1)$ \;
$\numremainder \leftarrow (\nlayers+1)\%(\rd+1)$ \;
$\blockrep\leftarrow[\Ln]*\text{max}(\numn, 0)$\;
$\blocknb\leftarrow\blockrep+[\Lb]$\;
$\blocknbn\leftarrow\blocknb+[\Ln]$\;
\Return ($\blocknb)*(\rd-\numremainder)+(\blocknbn)*(\numremainder)+\blockrep$\;
}

\uElseIf{$\Ld\in\dict$}{
% \uElseIf{$\rn < \rd$}{
\newcommand{\altblock}{block_{alt}}
\newcommand{\numalt}{num_{alt}}
$\altblock\leftarrow[\Lb, \Ld]$\; 
\uIf{$\nlayers-2(\rd-\rn)+1<0$}{
\newcommand{\nlodd}{n_{odd}}
$\nlodd\leftarrow\nlayers\%2$\;
% \Return $\altblock*\rn+[\Ld]*(\nlayers-2\rn)$\;
% elseif $numneg * n_l is odd$\;
\Return $[\Ld]*\nlodd+\altblock*\rn+[\Ld]*(\nlayers-2\rn-\nlodd)$\;
}
\uElse{
\uIf{$2\rn-\rd\geq0$}
{$\numalt\leftarrow\rd-\rn$}
\uElse{$\numalt\leftarrow\text{min}(r_n, r_d//2)$}

\newcommand{\numnonalt}{block_{non-alt}}

\uIf{$(\rn-\numalt)=\rd-2\numalt$}
{$\numnonalt\leftarrow[\Lb]*(\rn-\numalt)$}
\uElse{$\numnonalt\leftarrow[\Ld]*(\rd-2\numalt)$}

\Return $\numnonalt+\altblock*\numalt$\;
}
}
\uElse{
\Return $[\Lb] * \nlayers$ \;
}
\end{algorithm}

\begin{algorithm}[t]
\SetKw{kwSet}{set}
\SetKw{kwTo}{to}
\DontPrintSemicolon
\caption{Transformer encoding scheme}
\label{alg:Transformer}

\BlankLine
\KwIn{$\textbf{E}_{input} \in \mathbb{R}^{n \times d}, n', d', n_l$}
% \KwIn{$n, d, n', d', n_l$}
\KwOut{encoder layers}
$(n', d'):$ an expected shape of $\textbf{E}_{output}$\\
\tcp{
adaptive average pooling: $P_{adpt}(\mathbf{E}_{input}, n') \in \mathbb{R}^{n' \times d'}$
}
$r_c\leftarrow log_2(d/d')$\;
\BlankLine
$q\leftarrow r_d//n_l$\; 
$r\leftarrow r_d\%n_l$\; 
\BlankLine
\tcp{Define the encoder layers}
\kwSet{$L_{d_1}$} \kwTo{} decrease channel dim by $2^{q+1}$ \;
\kwSet{$L_{d_2}$} \kwTo{} decrease channel dim by $2^q$ \;

\BlankLine
\Return $[L_{d_1}] * r + [L_{d_2}] * (n_l-r) + [P_{adpt}]$\;
\end{algorithm}

\begin{table}[]
\caption{Building CNN-based encoder compressing $\textbf{E}_{input} \in \mathbb{R}^{8192 \times 256}$ to $\textbf{E}_{output} \in \mathbb{R}^{64 \times 8}$ following Algorithm.~\ref{alg:CNNlayernum} and \ref{alg:CNNlayerorder}.}
\label{tab:algCNN}
\centering
\begin{tabular}{c|cc}
\toprule
\textbf{Encoding} & \multicolumn{2}{c}{\textbf{CNN-based}} \\ \hline
Input & \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}$n=8192, d=256$\\ $\textbf{n'=64, d'=8}$\end{tabular}} \\ \midrule
\begin{tabular}[c]{@{}c@{}}Build\\ Layers\end{tabular} & \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}$r_n = log_2(8192/64)=7$\\ $r_d = log_2(256/8)=5$\\ $n_l = 7$\end{tabular}} \\ \midrule
Layer & \multicolumn{1}{c|}{Layer type} & Output shape \\ \midrule
1 & \multicolumn{1}{c|}{$L_{nd}$} & (4096,128) \\
2 & \multicolumn{1}{c|}{$L_{nd}$} & (2048,64) \\
3 & \multicolumn{1}{c|}{$L_{nd}$} & (1024,32) \\
4 & \multicolumn{1}{c|}{$L_{nd}$} & (512,16) \\
5 & \multicolumn{1}{c|}{$L_{n}$} & (256,16) \\
6 & \multicolumn{1}{c|}{$L_{nd}$} & (128,8) \\
7 & \multicolumn{1}{c|}{$L_n$} & \textbf{(64,8)} \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[]
\caption{Example of building Transformer-based encoder compressing $\textbf{E}_{input} \in \mathbb{R}^{8192 \times 256}$ to $\textbf{E}_{output} \in \mathbb{R}^{64 \times 8}$ according to Algorithm.~\ref{alg:Transformer}.}
\label{tab:algTransf}
\centering
\begin{tabular}{c|cc}
\toprule
\textbf{Encoding} & \multicolumn{2}{c}{\textbf{Transformer-based}} \\ \hline
Input & \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}$n=8192, d=256$\\ $\textbf{n'=64, d'=8}$, $n_l=4$\end{tabular}} \\ \midrule
\begin{tabular}[c]{@{}c@{}}Build\\ Layers\end{tabular} & \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}$r_d = log_2(256/8)=5$\\ $q=1, r=1$\\ $L_{d_1}$: decrease $d$ by $2^2$ \\ $L_{d_2}$: decrease $d$ by $2^1$ \end{tabular}} \\ \midrule
Layer & \multicolumn{1}{c|}{Layer type} & Output shape \\ \midrule
1 & \multicolumn{1}{c|}{$L_{d_1}$} & (8192,64) \\
2 & \multicolumn{1}{c|}{$L_{d_2}$} & (8192,32) \\
3 & \multicolumn{1}{c|}{$L_{d_2}$} & (8192,16) \\
4 & \multicolumn{1}{c|}{$L_{d_2}$} & (8192,8) \\
- & \multicolumn{1}{c|}{$P_{adpt}$} & \textbf{(64,8)} \\
\bottomrule
\end{tabular}
\end{table}




\section{Transformer encoding schemes}
\label{apd:TransfEncoding}
As shown in Algorithm.~\ref{alg:Transformer}, our proposed Transformer encoding method gradually reduces the channel dimension as the input x is passed through the encoding layers.
However, for Transformer-based encoding, it is common only to compress the temporal dimension (using the [CLS] token or mean pooling) while leaving the channel dimension unchanged.
Thus, we experiment and compare the temporal dimension compression to our channel compression method for reconstruction and prediction with $\textbf{z}$ dimension of 256 and 2048.

For $\textbf{z} \in \mathbb{R}^{1 \times 256}$, the Transformer encoder layers process $\textbf{x}$ and aggregate the temporal dimension into one by either extracting the [CLS] tokens or by mean pooling.

For $\textbf{z} \in \mathbb{R}^{1 \times 2048}$, the output of the Transformer encoder is linearly projected into 2048 dimensions and then temporally compressed.

For $\textbf{z} \in \mathbb{R}^{8 \times 256}$, we apply [CLS]-based and mean pooling-based compression with the following processes. 
For [CLS]-based compression, we insert 7 [CLS] tokens to the start of the sequence before encoding and subsequently use the 8 [CLS] tokens (i.e., encoded [CLS] output) for compression.
We apply adaptive average pooling to the encoded outputs for mean pooling-based compression.

Fig.~\ref{apd:TransfDecoding} shows the results of reconstruction and prediction. 
For the reconstruction tasks, our encoding scheme outperforms all existing methods with a significant difference in accuracy for both $\textit{l}$ = 256 and $\textit{l}$ = 2048. 
Our method also shows comparable AUROC but slightly lower than mean pooling and higher AUROC than using [CLS].

\section{Transformer decoding schemes}
\label{apd:TransfDec}

\begin{figure}
     \centering
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfDec/decoder_CA.pdf}
         \caption{AR \& CA}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfDec/decoder_SA.pdf}
         \caption{non-AR \& SA}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfDec/decoder_SAU.pdf}
         \caption{non-AR \& SA+Unpool}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Transformer decoding scheme designs}
    \label{fig:TransfDec}
\end{figure}

We experimented on four different Transformer decoding schemes (shown in Fig.~\ref{fig:TransfDec}), including the setting in Fig.~\ref{fig:transformerdecoder}, where both the encoder and decoder are Transformers.
After the latent vector $\textbf{z}$ is generated from the encoder, the decoder reconstructs input $\textbf{x}$ by using either autoregressive or non-autoregressive methods.
The autoregressive method generates $\textbf{x}$ sequentially based on tokens from previous time steps, while the non-autoregressive method generates $\textbf{x}$ at once.

\begin{wrapfigure}{r}{0.5\textwidth}
    % \vspace*{-3mm}
    \includegraphics[width=\linewidth]{images/Appendix:TransfDec/transformer_decoding.pdf}
    \centering
    \caption{Reconstruction accuracy according to Transformer decoding schemes.}
    \label{fig:TransfDecoding}
\end{wrapfigure}
For non-autoregressive decoding, $\textbf{z}$ can be passed to the decoder either indirectly as a key for cross-attention (Section.~\ref{subsec:TaskSpecificModels}) or directly for self-attention.

We use two different types of decoder inputs for self-attention.
The first input type is a vector obtained by unpooling $\textbf{z}$ to the length of original input $\textbf{x}$, followed by adding positional encoding.
Unpooling replicates adaptive mean pooling values for each pooling window by the size of the window.
Also, positional encoding was added to overcome Transformers' inability to distinguish tokens with identical values of different positions.
The other input type is a vector of length $\textbf{x}$, created by concatenating placeholder tokens to $\textbf{z}$.

As shown in Fig.~\ref{fig:TransfDecoding}, autoregressive decoding shows the lowest reconstruction accuracy and does not appear to be suitable for reconstructing long sequences.
Among the non-autoregressive decoding methods, the method of passing information of latent vector $z$ from the encoder to the decoder through cross-attention shows the most efficient reconstruction.

\section{Visualization and analysis of self-attention maps in Transformer}
\label{apd:LocalEHR}
By visualizing the self-attention map of the Transformer layer having a hierarchical structure, we analyze how the reconstruction and prediction task differ from each other.
Specifically, we choose a patient who has less than ten events, which are fully filled with pad tokens out of $n_{e}=256$ events.
Then, we draw a heat-map for the first self-attention layer of the $\Ence$ in the autoencoder $(T,T)$ and the predictive model $\mathtt{Classifier}(\mathtt{Enc}_{struc}(\mathbf{x}))$. % 각각 뭐를 target했는지
The patient's key and query medical events respectively correspond to the y and x axes in the Fig.~\ref{fig:sa}.

As shown in the figure, Transformer shows an entirely different pattern in cases of reconstruction and prediction.
For the reconstruction task illustrated in Fig.~\ref{fig:sarecon}, most of the attention heads in the Transformer mainly attend temporally proximal events represented by the elements near the diagonal line.
However, almost every query event attends specific events out of all $n_{e}$ events to perform the clinical prediction task, as depicted both in Fig.~\ref{fig:sapreddx} and \ref{fig:sapredmort}.


\section{Results of each prediction task}
\label{apd:Pred6Tasks}

Fig.~\ref{fig:pred6Tasks-mimic-latent}, \ref{fig:pred6Tasks-mimic-temporal}, \ref{fig:pred6Tasks-eicu-latent}, and
\ref{fig:pred6Tasks-eicu-temporal} show the prediction performances without averaging in a task-wise manner.
Prediction performances are arranged by the latent dimension $l$ in Fig.~\ref{fig:pred6Tasks-mimic-latent} and \ref{fig:pred6Tasks-eicu-latent}, and by the temporal dimension $t$ in Fig.~\ref{fig:pred6Tasks-mimic-temporal} and \ref{fig:pred6Tasks-eicu-temporal}.
We report these performances of each subtask on both MIMIC-III and eICU datasets.

\begin{figure}
     \centering
     \begin{subfigure}[b]{.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfEnc/transformer_encoder_recon_256.pdf}
         \caption{Reconstruction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfEnc/transformer_encoder_pred_256.pdf}
         \caption{Prediction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfEnc/transformer_encoder_recon_2048.pdf}
         \caption{Reconstruction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:TransfEnc/transformer_encoder_pred_2048.pdf}
         \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Comparison of Transformer encoding schemes.}
    \label{apd:TransfDecoding}
\end{figure}

\begin{figure}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/attention/Reconstruction_patient_11.png}
         \caption{Reconstruction}
         \label{fig:sarecon}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/attention/Prediction-dx_patient_11.png}
         \caption{Prediction-dx}
         \label{fig:sapreddx}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/attention/Prediction-mort_patient_11.png}
         \caption{Prediction-mort}
         \label{fig:sapredmort}
     \end{subfigure}
     \hfill
    \caption{Self-attention heat-map of the $\Ence$ in the hierarchically-structured Transformer.
  In $\Ence$, the input for the patient has 256 medical events as query and key vectors. 
  y and x axes in the figure respectively mean key and query event vector in each head.
  Query event vectors shows completely different pattern in reconstruction and prediction case.}
    \label{fig:sa}
\end{figure}


\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_dx.pdf}
         % \caption{Reconstruction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_fi_ac.pdf}
         % \caption{Prediction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_im_disch.pdf}
         % \caption{Reconstruction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_los3.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_los7.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_latent_dim_pred_False_auroc_mort.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Prediction performances on MIMIC-III arranged by the latent dimension $l$}
    \label{fig:pred6Tasks-mimic-latent}
\end{figure}

\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_dx.pdf}
         % \caption{Reconstruction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_fi_ac.pdf}
         % \caption{Prediction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_im_disch.pdf}
         % \caption{Reconstruction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_los3.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_los7.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/mimic3_spatial_dim_pred_False_auroc_mort.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Prediction performances on MIMIC-III arranged by the temporal dimension $t$}
    \label{fig:pred6Tasks-mimic-temporal}
\end{figure}


\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_dx.pdf}
         % \caption{Reconstruction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_fi_ac.pdf}
         % \caption{Prediction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_im_disch.pdf}
         % \caption{Reconstruction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_los3.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_los7.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_latent_dim_pred_False_auroc_mort.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Prediction performances on eICU arranged by the latent dimension $l$}
    \label{fig:pred6Tasks-eicu-latent}
\end{figure}


\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_dx.pdf}
         % \caption{Reconstruction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_fi_ac.pdf}
         % \caption{Prediction ($l=256$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_im_disch.pdf}
         % \caption{Reconstruction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_los3.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_los7.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/pred6tasks/eicu_spatial_dim_pred_False_auroc_mort.pdf}
         % \caption{Prediction ($l=2048$)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Prediction performances on eICU arranged by the temporal dimension $t$}
    \label{fig:pred6Tasks-eicu-temporal}
\end{figure}

\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:Tokenhist/event_hist.pdf}
         \caption{Token lengths of hierarchical input}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:Tokenhist/token_hist.pdf}
         \caption{Token lengths (excluding paddding)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Kernel density estimate (KDE) plot visualizing the distribution of the token lengths according to observation time in the MIMIC-III dataset.}
    \label{apd:tokenhist}
\end{figure}


\begin{figure}
     \centering
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:PCA/pred_fl_conv_conv_dx.pdf}
         \caption{CNN-based (dx)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:PCA/pred_fl_conv_conv_mort.pdf}
         \caption{CNN-based (mort)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:PCA/pred_fl_transf_transf_dx.pdf}
         \caption{Transformer-based (dx)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/Appendix:PCA/pred_fl_transf_transf_mort.pdf}
         \caption{Transformer-based (mort)}
         % \label{pred_summary_latent}
     \end{subfigure}
     \hfill
    \caption{Latent vector visualization using PCA on MIMIC-III dataset. Reconstruction for both CNN-based and Transformer-based encoders uses CNN-based decoders.}
    \label{apd:pca}
\end{figure}

\end{document}