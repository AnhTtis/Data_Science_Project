%\newpage
\appendix
% \begin{appendices}

% \section{Homeless}

% \begin{equation}
% \left[\hat{x},\hat{p}\right]=\frac{i}{2}\label{eq:Commutatorxp}
% \end{equation}
% according to the relations
% \begin{align}
% \hat{a} & =\hat{x}+i\hat{p}\label{eq:AnnihilationOperatortoPhaseSpace}\\
% \hat{a}^{\dagger} & =\hat{x}-i\hat{p}\label{eq:CreationOperatortoPhaseSpace}
% \end{align}
% where 
% \begin{equation}
% \left[\hat{a},\hat{a}^{\dagger}\right]=1\label{eq:CommutatorCreationAnnihilation}
% \end{equation}
% The number operator is further
% expressed as
% \begin{align}
% n & =\hat{a}^{\dagger}\hat{a}\\
%  & =\hat{x}^{2}+\hat{p}^{2}-\frac{1}{2}\label{eq:NumbertoPhaseSpace}
% \end{align}

% Where $\hat{H}$ is given by the sum of operators $\hat{H}=\sum_{i=1}^{N}\hat{H}_{i}$,
% the exponential propagator is synthesized according to the Trotter-Suzuki
% decomposition, where the first-order Trotter-Suzuki decomposition
% of $U$ is \cite{Suzuki.1992.387,childs2021theory} 
% \begin{equation}
% \mathcal{\mathcal{T}}_{1}=e^{-i\hat{H}_{N}\lambda}e^{-i\hat{H}_{N-1}\lambda}\cdots e^{-i\hat{H}_{1}\lambda}+\mathcal{O}\left(\lambda^{2}\right)\label{eq:TrotterFirstOrder}
% \end{equation}
% for small parameter $\lambda$, the symmetrized second-order Trotter-Suzuki
% decomposition is 
% \begin{equation}
% \mathcal{T}_{2}=e^{-i\hat{H}_{1}\lambda/2}e^{-i\hat{H}_{2}\lambda/2}\cdots e^{-i\hat{H}_{N}\lambda/2}e^{-i\hat{H}_{N}\lambda/2}\cdots e^{-i\hat{H}_{2}\lambda/2}e^{-i\hat{H}_{1}\lambda/2}+\mathcal{O}\left(\lambda^{3}\right)\label{eq:TrotterSecondOrder}
% \end{equation}
% and higher-order Trotter-Suzuki decompositions are generated as 
% \begin{equation}
% \mathcal{T}_{2p}=\mathcal{T}_{2p-2}\left(u_{p}\lambda\right)^{2}\mathcal{T}_{2p-2}\left(\left(1-4u_{p}\right)\lambda\right)\mathcal{T}_{2p-2}\left(u_{p}\lambda\right)^{2}
% \end{equation}
% for 
% \begin{equation}
% u_{p}=\frac{1}{4-4^{1/\left(2p-1\right)}}
% \end{equation}

% Where $\hat{H}$ is given by the operator product $\hat{H}=\prod_{i=1}^{M}\hat{H}_{i}$,
% the argument of the exponential is expressed as the commutator of
% two operators $\left[\hat{A},\hat{B}\right]$ and the exponential is decomposed
% according to the BCH decomposition \cite{childs2013product}, where
% the lowest-order BCH decomposition of $U$ for small parameter $\lambda$
% is (see Appendix~\ref{sec:expansion})
% \begin{equation}
% V_{1}\left(\hat{A}\lambda,\hat{B}\lambda\right)=e^{\left[\hat{A},\hat{B}\right]\lambda^{2}}\approx e^{\hat{A}\lambda}e^{\hat{B}\lambda}e^{-\hat{A}\lambda}e^{-\hat{B}\lambda}+\mathcal{O}\left(\lambda^{3}\right)\label{eq:BCHFormula}
% \end{equation}
% and higher-order BCH decompositions are determined recursively as
% \begin{align}
% V_{p+1}\left(\hat{A}\lambda,B\lambda\right) & =V_{p}\left(\hat{A}\gamma_{p}\lambda,\hat{B}\gamma_{p}\lambda\right)V_{p}\left(-\hat{A}\gamma_{p}\lambda,-\hat{B}\gamma_{p}\lambda\right)\nonumber \\
%  & \times V_{p}\left(\hat{A}\beta_{p}\lambda,\hat{B}\beta_{p}\lambda\right)^{-1}V_{p}\left(-\hat{A}\beta_{p}\lambda,-\hat{B}\beta_{p}\lambda\right)^{-1}\nonumber \\
%  & \times V_{p}\left(\hat{A}\gamma_{p}\lambda,\hat{B}\gamma_{p}\lambda\right)V_{p}\left(-\hat{A}\gamma_{p}\lambda,-\hat{B}\gamma_{p}\lambda\right)\nonumber \\
%  & +O\left(\lambda^{2p+3}\right)\label{eq:RecursiveBCH}
% \end{align}
% where 
% \begin{align}
% V_{p}\left(\hat{C},\hat{D}\right) & =\begin{cases}
% V_{p}\left(\hat{D},\hat{C}\right)^{-1} & p\text{ is odd}\\
% V_{p}\left(-\hat{D},-\hat{C}\right)^{-1} & p\text{ is even}
% \end{cases}\\
% r_{p} & =\frac{2^{\frac{1}{p+1}}}{4\left(2-2^{\frac{1}{p+1}}\right)}\\
% \beta_{p} & =\left(2r_{p}\right)^{1/2}\\
% \gamma_{p} & =\left(\frac{1}{4}+r_{p}\right)^{1/2}
% \end{align}
% Higher-order expansions are also generated by symmetrization, as detailed in Appendix~\ref{sec:symmetrization}.  When $\hat{A}$  or $\hat{B}$ itself is a commutator ({\em i.e.}, nested commutators), the BCH
% expansion is reapplied until only elementary gates remain.

% Three strategies are then used to express the argument of the desired
% exponential gate in terms of a commutator. An argument of a qubit-conditional
% gate is expressed in terms of a commutator according to the Pauli
% commutator relations

% % \begin{align}
% % \sigma^{x} & =-\frac{i}{2}\left[\sigma^{y},\sigma^{z}\right]\label{eq:PauliCommutatorx}\\
% % \sigma^{y} & =-\frac{i}{2}\left[\sigma^{z},\sigma^{x}\right]\label{eq:PauliCommutatory}\\
% % \sigma^{z} & =-\frac{i}{2}\left[\sigma^{x},\sigma^{y}\right]\label{eq:PauliCommutatorz}
% % \end{align}
% and an argument consisting of a product of an anticommutator and a
% Pauli gate is expressed in terms of the Pauli anticommutator-commutator
% relation derived in Appendix~\ref{subsec:Anti-Commutator-to-Commutator}

% \begin{align}
% \left\{ \hat{A},\hat{B}\right\} \sigma^{i} & =i\left[i\hat{A}\sigma^{j},i\hat{B}\sigma^{k}\right]\label{eq:AnticommutatortoCommutator}
% \end{align}
% Finally, an argument consisting of a product of operators is expressed
% as
% \begin{align}
% \hat{A}\hat{B}\sigma^{j} & =\frac{1}{2}\left\{ \hat{A},\hat{B}\right\} \sigma^{j}+\frac{1}{2}\left[\hat{A},\hat{B}\right]\sigma^{j}\label{eq:ProductOperators}\\
% \left\{ \hat{A},\hat{B}\right\}  & =\hat{A}\hat{B}+\hat{B}\hat{A}\\
% \left[\hat{A},\hat{B}\right] & =\hat{A}\hat{B}-\hat{B}\hat{A}
% \end{align}
% which is further decomposed in terms of the Pauli anticommutator-commutator
% relation Eq.~(\ref{eq:AnticommutatortoCommutator}).

% This systematic approach is used to generate a wide array of qubit-conditional
% gates (Section~\ref{sec:Qubit-Conditional-Cavity-Gates}), universal
% control of a qubit encoded in a cavity (Section~\ref{subsec:Universal-Control}),
% and fermionic Fermi-Hubbard lattice dynamics on bosonic quantum computers
% (Section~\ref{sec:Fermi-Hubbard-Lattice-Dynamics}). All figures can be reproduced with the code contained in the same image folder.  Time is reported in unitless quantity via multiplication by the inverse time step $1/\tau$ to provide a sense of the required gate depth that is equally applicable to differing quantum computing architectures.

\newpage\leftline{\bf APPENDICES}

\section{Obtaining \texorpdfstring{$S_1$}{}}\label{obtaining_s1}
Here, we demonstrate how to obtain the $\mathcal{S}_1$ operator, with the native gates present in the dispersive coupling regime.

% If the $S_1$ gate is not present in a given instruction set, it can be in principle compiled from simpler gates. 
% As an example of the construction of a block-encoded operator, we concatenate oscillator phase-delays with displacements of the oscillator controlled on the qubit state. 

The controlled  displacement operator with magnitude $\alpha$ is written:
\begin{equation}
    U_{d}(\alpha) = e^{i  (\alpha a^\dagger + \alpha^* a) \otimes \sigma^z }.
\end{equation}
For a Fock state $\ket{n}$, $a^\dagger a \ket{n} = n \ket{n}$; therefore $e^{i a^\dagger a \theta} a^\dagger e^{-i a^\dagger a \theta}=e^{i\theta}a^\dagger$. Taking $\alpha=\alpha^*$, we have
\begin{equation}
    e^{i(\pi/2) a^\dagger a}e^{i(\alpha(a^\dagger + a))\otimes \sigma^y} e^{-i(\pi/2) a^\dagger a} = \exp\left(\alpha \begin{bmatrix}0 & (ia^\dagger - ia)\\ (-ia^\dagger + ia) &0 \end{bmatrix} \right).
\end{equation}
This operation can be built using single-qubit operations on a controlled displacement gate with additional phase delays on the oscillator.  Both are linear optical operations or single-qubit operations, which we expect to be inexpensive in our computational model.

Next, note that 
\begin{equation}
    e^{i(\alpha(a^\dagger + a))\otimes \sigma^x} = \exp\left(\alpha\begin{bmatrix} 0 & i(a^\dagger + a) \\ i(a^\dagger +a) &0 \end{bmatrix} \right).
\end{equation}
Thus to $O(\alpha^2)$ the block-encoded creation operation can be constructed using single-qubit operations, two controlled displacement operations and linear optical operations through

\begin{equation}
    \mathcal{S}_1 \approx e^{i(\pi/2) a^\dagger a}e^{i(\alpha(a^\dagger + a))\otimes \sigma^y} e^{-i(\pi/2) a^\dagger a}e^{i(\alpha(a^\dagger + a))\otimes \sigma^x}.
\end{equation}
This provides an intuition for our strategy for compiling gates. A major goal in this work is to optimize such formulas to minimize the number of operations needed to closely approximate evolution.  To this end, symmetric and higher-order approximations of this form will be vital to achieving the optimal scaling for such formulas and in turn get a deeper understanding of the costs of hybrid boson-qubit computations.

\[
\Qcircuit @C=1em @R=.7em {
\lstick{\textrm{Cavity } \ket{0}} & \qw & \gate{\exp i \frac{\pi}{2} \hat{n}} & \gate{CD[\alpha]} & \gate{\exp - i \frac{\pi}{2} \hat{n}} & \qw & \qw\\
%%%%
\lstick{\textrm{Qubit } \ket{0}} & \gate{S} & \gate{H} & \ctrl{-1} & \gate{H} & \gate{S^\dagger} & \qw
}
\]

\section{Error analysis}\label{apndx:error-analysis}
To assess the error scaling of the addition algorithm, we must consider three sources of error: the underlying implementation error from using approximations of $\mathcal{B}_A(t)$, the error from BCH, and the error from Trotter. In \cref{apndx:implementation-error-bch-trotter}, we show that the BCH and Trotter formulas can still be applied on exponentials that have error. Then, we use these formulas in \cref{apndx:general-addition-error} to produce the error bounds for addition. Finally, in \cref{apndx:multiplication}, we produce the error bounds for multiplication. 

% approximation of operations

\subsection{Product formulas with implementation error}\label{apndx:implementation-error-bch-trotter}
We begin by formally stating the Trotter and BCH formulas when there is no implementation error:
\begin{theorem}[BCH Product Formula (Theorem 2 from \cite{Childs_2013})]\label{fact:bch}
Let $A$ and $B$ be bounded complex-valued matrices and assume without loss of generality $t \in \mathbb{R}^+$ is assumed for the purposes of asymptotic analysis to be in $o(1)$.  We then define
\begin{align}
    \bch_{1, k} (At, Bt^k) \coloneqq e^{At} e^{Bt^k} e^{-At} e^{-Bt^k}.
\end{align}
We further define $\bch_{p,k}$ recursively for $p \geq 2$ and odd $ k \geq 1$:
\begin{align}
    \bch_{p + 1, k}(At, Bt^k) &\coloneqq \bch_{p, k} (A \gamma_p t, B (\gamma_p t)^k ) \bch_{p, k} (-A\gamma_p t, - B (\gamma_p t)^k) \\
    &\times \bch_{p, k} (A \beta_p t, B (\beta_p t)^k )^{-1} \bch_{p, k} (-A \beta_p t, - B (\beta_p t)^k )^{-1} \\
    &\times \bch_{p, k} (A \gamma_p t, B (\gamma_p t)^k ) \bch_{p, k} (-A \gamma_p t, - B (\gamma_p t)^k ),
\end{align}
with the following constants:
\begin{align}
    \beta_p \coloneqq (2r_p )^{1/(k + 1)}, \gamma_p \coloneqq (1/4 + r_p )^{1 / (k + 1)}, r_p \coloneqq \frac{2^{\frac{(k + 1)}{2p + k + 1}}}{4 \left(2 - 2^{\frac{k + 1}{2p + k + 1}} \right)}.
\end{align}
This recursive formula has the following error scaling, where $\gamma = \max(\norm{A}, \norm{B}^{1/k})$~\cite{Childs_2013}: 
\begin{align}
    \bch_{p, k}(At, Bt^k) = e^{[A, B]t^{k + 1} + \mathcal{O}((\gamma t)^{2p + k})}
\end{align}
and uses $8 \cdot 6^{p - 1}$ exponentials when $k = 1$ and $4 \cdot 6^{p-1}$ exponentials otherwise. 
\end{theorem}

\begin{theorem}[Trotter Formula (Lemma 1 from \cite{berry2007efficient})]\label{fact:trotter}
Let $\{H_j: j = 1\ldots m \}$ be a set of $M$ bounded Hermitian operators acting on a Hilbert space of dimension $2^n$ and assume without loss of generality that $t\ge 0$. For $H= \sum H_j$, the error in the Trotter-Suzuki formulas of order $k$ and timestep $r$ obeys the following error bound: 
\begin{align}
    \norm{\exp\left( -it \sum_{j = 1}^m H_j \right) - \trotter_{ 2k}(\{ H_j \}, t / r)^r  } \leq 5 (2 \times 5^{k - 1} m \tau)^{2k + 1} / r^{2k},
\end{align}
% \how{see notes}
where $\tau = \norm{H} t$ and
\begin{align}\label{req:trotter-constraints}
    4 m 5^{k - 1} \tau / r &\leq 1 , \\
    (16/3) ( 2 \times 5^{k - 1} m \tau)^{2k + 1} / r^{2k } &\leq 1 ,
\end{align}
using no more than $2 m 5^{k - 1} r$ exponentials. We define the $k^\text{th}$ order Trotter formula as:
\begin{align*}
    \trotter_{2k} (\lambda) := [\trotter_{2k - 2} (p_k \lambda)]^2 \trotter_{2k - 2} ((1 - 4p_k)\lambda) [\trotter_{2k - 2} (p_k \lambda)]^2,
\end{align*}
where $p_k = (4 - 4^{1/(2k - 1)})^{-1}$ and $k > 1$. The relation has the following base case:
\begin{align*}
    \trotter_2(\lambda) = \prod_{j = 1}^m e^{H_j \lambda / 2} \prod_{j' = m}^1 e^{H_{j'} \lambda / 2}, 
\end{align*}
\end{theorem}
which implies the following corollary: 
\begin{corr}\label{corr:trotter-r}
If $r = 1$, i.e. there is no time stepping, the Trotter formula exhibits the following error scaling:
\begin{align}
    \norm{\exp \left(-it \sum_{j = 1}^m H_j \right) - \trotter_{2k}(\{H_j\}, t)} \in \mathcal{O}((\norm{H} t)^{2k + 1}),
\end{align}
using no more than $2 m 5^{k - 1}$ exponentials.
\end{corr}
% \begin{proof}
% The bound and operator count follows immediately by substituting $r = 1$.
% \end{proof}

\newcommand{\uone}{U_1(t)}
\newcommand{\utwo}{U_2(t)}
\newcommand{\uonetilde}{\widetilde{U}_{1, p_1}(t)}
\newcommand{\utwotilde}{\widetilde{U}_{2, p_2}(t)}

Both of these formulas, however, assume that our implementation of exponentials occurs without error. However, if we would like to apply our technique recursively, our matrix product formulas must account for implementation error, i.e. be able to use primitives that themselves may have error. Thus, we restate both Trotter and BCH when the operators have asymptotic error:
{
\begin{lemma}[BCH under implementation error]\label{lem:bch-with-approx}
Suppose there are some ideal operators $\uone, \utwo$ which are exponentials of some anti-Hermitian matrix, i.e.: 
\begin{align}
    \uone &= \exp t A_1, \\
    \utwo &= \exp t A_2.
\end{align}
We seek to build $\exp t^2 [A_1, A_2]$, the exponential of the commutator of the matrices. Also suppose that may approximate $\uone, \utwo$ with $\uonetilde, \utwotilde$ with the following error scaling:
\begin{align}
    \norm{\uonetilde - \uone} &\in \mathcal{O}((c t)^{p_1}), \\
    \norm{\utwotilde - \utwo} &\in \mathcal{O}((c t)^{p_2}),
\end{align}
for some $p_1, p_2 \geq 1$. Then, applying a $q^\text{th}$-ordered BCH formula, where $q = \max(\ceil{\frac{\min(p_l, p_2) - 1}{2}}, 1 )$ on the implementable $\uonetilde, \utwotilde$ can still approximate the commutator  exponential by applying \cref{fact:bch}:
\begin{align}
    \norm{\exp t^2 [A_1, A_2] - \bch_{q, r}(\uonetilde, \utwotilde)} \in \mathcal{O}((C t)^{\min (p_1, p_2)}),
\end{align}
where $C = \max(\norm{A_1}, \norm{A_2}, c)$. This procedure uses $8 \cdot 6^{q - 1}$ total exponentials.

% \how{talk about how gamma will exceed c1, c2 norms, energy scaling of system.}

\end{lemma}
\begin{proof}
Recognize that we may decompose the error involved in implementing the commutator exponential into two sources: the error incurred from the BCH formula intrinsically and the implementation error from the realizable terms. Thus, by the triangle inequality:
\begin{align}
    &\norm{\exp t^2 [A_1, A_2] - \bch_q(\uonetilde, \utwotilde)} \leq \nonumber\\
    &\; \norm{\exp t^2 [A_1, A_2] - \bch_q(\uone, \utwo)} + \norm{\bch_q(\uone, \utwo) - \bch_q(\uonetilde, \utwotilde)} .
\end{align}
We begin with the LHS term. By \cref{fact:bch}, 
\begin{align}
    \norm{\exp t^2 [A_1, A_2] - \bch_q(\uone, \utwo)} \in \mathcal{O}((C_{\textrm{BCH}} t)^{2q + 1}),
\end{align}
where $C_{\textrm{BCH}} = \max(\norm{A_1}, \norm{A_2})$. 
For the RHS, recall by Box 4.1 of Nielsen and Chuang \cite{nielsen_chuang_2010} that implementation errors accumulate at most linearly; thus, we can sum over the $8 \cdot 6^{q- 1}$ operations used by BCH. By symmetry of the BCH formula, we apply the $\uonetilde, \utwotilde$ exponentials precisely $4 \cdot 6^{q- 1}$ times. Thus:
\begin{align}
    \norm{\bch_q(\uone, \utwo) - \bch_q(\uonetilde, \utwotilde)} &\leq \sum_{j = 1}^{4 \cdot 6^{q - 1}} \mathcal{O}((c t)^{p_1}) + \mathcal{O}((c t)^{p_2}) \\ 
    &\in \mathcal{O}((c t)^{\min(p_l, p_r)}).
\end{align}
Setting $q = \max\{\ceil{\frac{\min(p_l, p_r) - 1}{2}}, 1 \} $ and recalling $\gamma \geq 1$, observe:
\begin{align}
    \norm{\exp t^2 [A_1, A_2] - \bch_q(\uonetilde, \utwotilde)} \in \mathcal{O}((C t)^{\min(p_l, p_r)}),
\end{align}
as desired.
\end{proof}
\begin{lemma}[Trotter under implementation error]\label{lem:trotter-with-approx}
Given~\cref{lem:bch-with-approx}'s assumptions, \cref{fact:trotter}'s assumptions, and assuming $\norm{A_1 + A_2} \geq 1$, an operator can be constructed by applying a $q^\text{th}$-ordered Trotter formula $\trotter_{2q}$ by setting $q = \max(\ceil{\frac{\min(p_l, p_2) - 1}{2}}, 1 )$ so that: 
% \how{this sounds weird}
\begin{align}
    \norm{\exp t (A_1 + A_2) - \trotter_q (\uonetilde, \utwotilde)} \in \mathcal{O}((C t)^{\min(p_1, p_2)}),
\end{align}
where $C = \max(\norm{A_1 + A_2}, c)$ and using no more than $4 \cdot 5^{q -1} $ operator exponentials. 
% \leq 2^{ + 1 / q} 5^{2q} \gamma^{1 + 1/2q}
% where $\gamma = \max(\norm{A_1}, \norm{A_2})$.
\end{lemma}
\begin{proof}
Similarly, we may apply the triangle inequality in order to determine a bound by separating the error accrued into the intrinsic Trotter error and the implementation error:
\begin{align}
    &\norm{\exp t (A_1 + A_2) - \trotter_{2q} (\uonetilde, \utwotilde) } \nonumber\\
    &\leq \norm{\exp t(A_1 + A_2) - \trotter_{2q} (\uone, \utwo)}\nonumber \\
    &\qquad+ \norm{\trotter_{2q} (\uone, \utwo) - \trotter_{2q} (\uonetilde, \utwotilde)}.
\end{align}
To analyze the LHS, which represents the Trotter error, \cref{corr:trotter-r} provides a bound:
\begin{align}
    \norm{\exp t(A_1 + A_2) - \trotter_{2q} (\uone, \utwo)} \in \mathcal{O}((\norm{A_1 + A_2}t)^{2q + 1}).
\end{align}
For the RHS, which represents the implementation error, recall by box 4.1 of Nielsen and Chuang \cite{nielsen_chuang_2010} that the error accrues linearly. Furthermore, the number of operations in Trotter is no more than $4 \cdot 5^{q - 1} $ operations in total. Therefore, we only apply each constituent operation at most $2 \cdot 5^{q - 1}$ times. Thus, a loose upper bound can be written as:
\begin{align}
    \norm{\trotter_{2q} (\uone, \utwo) - \trotter_{2q} (\uonetilde, \utwotilde)} &\leq \sum_{j = 1}^{4 \cdot 5^{q -1 }} \mathcal{O}((c t)^{p_1}) + \mathcal{O}((c t)^{p_2}) \\
    &\in \mathcal{O}((c t)^{\min(p_1, p_2)}).
\end{align}
It is sufficient to set $q = \max(\ceil{\frac{\min(p_1, p_2) - 1}{2}}, 1)$ so that:
\begin{align}
    &\norm{\exp t (A_1 + A_2) - \trotter_{2q} (\uonetilde, \utwotilde) } \\
    &\qquad \in \mathcal{O}((\norm{A_1 + A_2} t)^{2q + 1}) + \mathcal{O}(( c t)^{\min(p_1, p_2)}) =  \mathcal{O}((Ct)^{\min(p_1, p_2)}),
\end{align}
as desired.
\end{proof}
}


\subsection{Scaling of the addition algorithm}\label{apndx:general-addition-error}
We apply the above results to produce the error analysis of \cref{alg:adder}:
\algproduct*
% \begin{theorem}\label{thm:general-adder-error}
%     Suppose we have approximations $\tilde{\mathcal{B}}_A(t), \tilde{\mathcal{B}}_B(t)$ with the following error:
%     \begin{align}
%         \norm{\tilde{\mathcal{B}}_A(t) - \mathcal{B}_A(t)} &\in \mathcal{O}( (ct)^{p_A} ) \\
%         \norm{\Tilde{\mathcal{B}}_B(t) - \mathcal{B}_B(t)} &\in \mathcal{O} ((ct)^{p_B} ) 
%     \end{align}
%     For some constant $c$ and order $p_A, p_B \geq 1$. Then, the application of \cref{alg:adder} will yield the following scaling:
%     \begin{align}
%         \norm{\textrm{ADD}(\Tilde{\mathcal{B}}_A(t), \Tilde{\mathcal{B}}_B(t) ) - \exp it \begin{bmatrix}
%             0 & AB \\
%             (AB)^\dagger & 0 
%         \end{bmatrix}} \in \mathcal{O} ((C_{TOTAL} t)^{\min(p_A, p_B) / 2})
%     \end{align}
%     With $C_{TOTAL} = \max( \norm{AB}, \norm{(AB)^\dagger}, C_{BCH}^2)$ and $C_{BCH} = \max( \norm{A}, \norm{B}, c)$,
%     using no more than $ 1.07 \cdot 30^q $ exponentials. 
% \end{theorem}
\begin{proof}
Our proof proceeds by applying the above theorems upon our operations. By setting $q = \max(\ceil{\frac{\min(p_1, p_2) - 1}{2}}, 1)$, \cref{lem:bch-with-approx} implies that:
\begin{align}
    \norm{\textrm{BCH}_q ( X \widetilde{\mathcal{B}}_B(\tau) X, \widetilde{\mathcal{B}}_A(\tau)) -  \exp \tau^2 [A, B] \sigma^z} &\in \mathcal{O}((C_{BCH}\tau)^{p_{BCH}}), \label{eq:C}\\
    \norm{\textrm{BCH}_q (S \widetilde{\mathcal{B}}_A(\tau) S^\dagger,  X \widetilde{\mathcal{B}}_B(\tau) X) -  \exp i \tau^2 \{A, B \} \sigma^z} &\in \mathcal{O}((C_{BCH} \tau)^{p_{BCH}}), \label{eq:AC}
\end{align}
where $C_{BCH} = \max( \norm{A}, \norm{B}, c)$ and $p_{BCH} = \min (p_A, p_B) $. We'll need to set $\tau = \sqrt{\frac{t}{2}}$ to achieve the desired time evolution. Additionally, Pauli conjugation has no impact on the error scaling. Call these formulas ``Left" and ``Right":
\begin{align}
    \textrm{LEFT} &\coloneqq SH \cdot \textrm{BCH}_q ( X \widetilde{\mathcal{B}}_B(\tau) X, \widetilde{\mathcal{B}}_A(\tau)) \cdot HS^\dagger, \\
    \textrm{RIGHT} &\coloneqq H \textrm{BCH}_q (S \widetilde{\mathcal{B}}_A(\tau) S^\dagger, X\widetilde{\mathcal{B}}_B(\tau) X ) H,
\end{align}
where:
\begin{align}
    \norm{\textrm{LEFT} - \exp \tau^2 (AB - (AB)^\dagger) \sigma^y} &\in \mathcal{O}((C^2 t)^{p_{BCH} / 2}), \\
    \norm{\textrm{RIGHT} - \exp i \tau^2 (AB + (AB)^\dagger)  \sigma^x } &\in \mathcal{O}((C^2 t)^{p_{BCH} / 2}).
\end{align}
Finally, we use \cref{lem:trotter-with-approx}, implying that a Trotter formula with order $q$ has the following error scaling:
\begin{align}
    \norm{\textrm{Trotter}_s (\textrm{LEFT}, \textrm{RIGHT})  - \exp it \begin{bmatrix}
        0 & (AB)^\dagger \\
        AB & 0 
    \end{bmatrix} } \in \mathcal{O}((C_{TOTAL} t)^{p_{BCH} / 2}),
\end{align}
where: 
% \how{does this analysis work because it depends on scaling on earlier levels which depends on tau?}
\begin{align}
    C_{TOTAL} = \max \left( \norm{\begin{bmatrix}
        0 & (AB)^\dagger \\
        AB & 0
    \end{bmatrix}}, C_{BCH}^2 \right) = \max \left(\norm{AB}, \norm{(AB)^\dagger}, C_{BCH}^2 \right).
\end{align}




To bound the number of operations used, recognize that the Trotter formula requires at most $4 \cdot 5^{q - 1}$ commutators, each of which requires $8 \cdot 6^{q - 1}$ constituent operators. Thus, the total number of operators required is bounded as follows:
\begin{align}
    4 \cdot 5^{q - 1} \cdot 8 \cdot 6^{q - 1} \leq 1.07 \cdot 30^q ,
\end{align}
\end{proof}


\newcommand{\leftarbop}{\widetilde{\mathcal{S}}_{k_l, p_l}(t)}
\newcommand{\leftarbopt}{\widetilde{\mathcal{S}}_{k_l, p_l}(\tau)}
\newcommand{\leftarbopx}{\widetilde{\mathcal{S}}^X_{k_l, p_l}(\tau)}
\newcommand{\leftarbopy}{\widetilde{\mathcal{S}}^Y_{k_l, p_l}(\tau)}

\newcommand{\rightarbop}{\widetilde{\mathcal{S}}_{k_r, p_r}(t)}
\newcommand{\rightarbopt}{\widetilde{\mathcal{S}}_{k_r, p_r}(\tau)}
\newcommand{\rightarbopx}{\widetilde{\mathcal{S}}^X_{k_r, p_r}(\tau)}
\newcommand{\rightarbopxr}{\widetilde{\mathcal{S}}^X_{k_r, p_r}(\tau / r_{\textrm{BCH})}}
\newcommand{\rightarbopy}{\widetilde{\mathcal{S}}^Y_{k_r, p_r}(\tau)}
\newcommand{\rightarbopyr}{\widetilde{\mathcal{S}}^Y_{k_r, p_r}(\tau / r_{\textrm{BCH}})}
which implies the following corollary for the annihilation/creation operators:
\begin{corr}[\cref{alg:adder} applied to polynomials of annihilation/creation operators]\label{lem:adder}
Assume we can implement the following $k_l, k_r^\text{th}$ order approximations of $S$ with error scaling $p_l, p_r$:
\begin{align}
    \norm{\leftarbop - \mathcal{S}_{k_l}(t)} &\in \mathcal{O}((c t)^{p_l}), \\
    \norm{\rightarbop - \mathcal{S}_{k_r}(t)} &\in \mathcal{O}((c t)^{p_r}),
\end{align}
with $c \geq \Lambda^{\max(k_l, k_r) / 2}$. Then, we can implement higher order operators with comparable $t$ scaling:
\begin{align}
    \norm{
    \widetilde{\mathcal{S}}_{k_l + k_r, \min(p_l, p_r)}(t)  - 
    \exp \left(i t \begin{bmatrix}
    0 & ( a^\dagger )^{k_l + k_r} \\
    a^{k_l + k_r} & 0
    \end{bmatrix}
    \right)
    } \in \mathcal{O}((c^2 t)^{\min(p_l, p_r) / 2}),
\end{align}
using no more than $1.07 \cdot 30^q$ $\mathcal{S}_{k_l},  \mathcal{S}_{k_r}$ operators.
\end{corr}
\begin{proof}
To synthesize the block-encoding of higher-order annihilation/creation operators, we will directly apply 
 \cref{thm:general-adder-error}. We quantify the error by bounding the block-encoding norm. Note that:
    \begin{fact}\label{fact:norm-blockencodedxt}
A $k^\text{th}$ order block-encoded operator has a bounded norm:
\begin{align}
    \norm{\begin{bmatrix}
        0 & ( a^\dagger )^k \\
        ( a )^k & 0
    \end{bmatrix}}  \leq \Lambda^{k / 2}.
\end{align}
\end{fact}
Thus, the constant $C_\textrm{BCH} $ is bounded, as $C_\textrm{BCH} \leq \max(\Lambda^{k_l / 2}, \Lambda^{k_r / 2}, c) \leq \max( \Lambda^{\max(k_l, k_r) / 2}, c) = c$ by hypothesis. Next, observe that $\norm{AB}, \norm{(AB)^\dagger} \leq \Lambda^{(k_l + k_r) / 2} $. Thus, $C_{TOTAL} \leq \max( \Lambda^{(k_l + k_r) / 2}, c^2) = c^2$. Therefore, the final error scaling will be upper bounded by $\mathcal{O}((c^2 t )^{\min(p_l, p_r) / 2})$.
\end{proof}

% And directly apply \cref{thm:general-adder-error}. 


% \how{is there a relationship between norm M and norm Mdag?}

\subsection{Scaling of the multiplication algorithm}\label{apndx:multiplication}
\cref{alg:mult}'s error scaling follows directly from the BCH formula:
\algmult*
\begin{proof}
    We can directly apply \cref{lem:bch-with-approx} using the $\widetilde{\mathcal{B}}_A, \widetilde{\mathcal{B}}_B$ operators. When applied, we find that:
    \begin{align}
        \norm{ \textrm{BCH}_q( S \widetilde{\mathcal{B}}_A(\tau) S^\dagger, \widetilde{\mathcal{B}}_B(\tau)) - \exp 2 i \tau^2 \begin{bmatrix}
            AB & 0 \\
            0 & - BA - (BA)^\dagger
        \end{bmatrix}} \in \mathcal{O}((C \tau)^{\min(p_A, p_B)}),
    \end{align}
    where $C = \max (\norm{A}, \norm{B}, c)$ and $q = \max ( \ceil{\frac{\min(p_A, p_B) - 1}{2}}, 1) $. Then, by taking $\tau = \sqrt{\frac{t}{2}}$, we yield:
    \begin{align}
        \norm{\textrm{BCH}_q(S \widetilde{\mathcal{B}}_B(\tau) S^\dagger, \widetilde{\mathcal{B}}_A(\tau) ) - \exp i t \begin{bmatrix}
            AB & 0 \\
            0 & -BA
        \end{bmatrix}} \in \mathcal{O}((C \tau)^{\min(p_A, p_B)}) = \mathcal{O}((C^2 t)^{\min(p_A, p_B) / 2}).
    \end{align}
    By counting the number of exponentials in the result via \cref{lem:bch-with-approx} we finally find that the number of exponentials needed is at most $8 \cdot 6^{q - 1}$. 
\end{proof}


%%%%%%%%%%%%%%
\section{Phase-Space Applications}
In the following section, we derive error bounds for the two phase-space applications described: the conditional rotation gate and the controlled-phase beam splitter. However, the typical cutoff approach we employ to bound $\norm{a}, \norm{a^\dagger}$ is more complex for position and momentum operators.

To obtain error bounds, we leave all expressions in terms of $\norm{\hat{x}}, \norm{\hat{p}}$. We leave a more concrete bound --- which can be found by applying a cutoff upon both $\hat{x}, \hat{p}$ simultaneously --- to future work. 

\subsection{Conditional rotation gate}\label{subsec:cond-rot}

\resultmeasurement
\begin{proof}
    Begin by directly applying \cref{fact:bch} to identify the error scaling. This implies that:
    \begin{align}
        \norm{\textrm{BCH}_p(\exp i \tau \hat{x} \sigma^i, \exp i \tau \hat{x} \sigma^j) - \exp \tau^2 \hat{x}^2 [\sigma^i, \sigma^j] } &\in \mathcal{O}((\norm{\hat{x}} \tau)^{2p + 1}), \\
        \norm{\textrm{BCH}_p(\exp i \tau \hat{p} \sigma^i, \exp i \tau \hat{p} \sigma^j) - \exp \tau^2 \hat{p}^2 [\sigma^i, \sigma^j] } &\in \mathcal{O}((\norm{\hat{p}} \tau)^{2p + 1}).
    \end{align}
    Without loss of generality (WLOG), select $\sigma^i = \sigma^y$ and $\sigma^j = \sigma^z$ so that $[\sigma^i, \sigma^j] = 2i \sigma^x$. Then, by selecting $\tau = \sqrt{\frac{t}{2}}$, the BCH formula is an approximation of  $\mathcal{B}_{\hat{x}^2} (t)$. Thus,
    \begin{align}
        \norm{\widetilde{ \mathcal{B}}_{\hat{x}^2} - \exp i t \hat{x}^2 \sigma^x} &\in \mathcal{O}((\norm{\hat{x}}^2 t)^{p + \frac{1}{2}}).
    \end{align}
    Similarly, for $\hat{p}^2$:
    \begin{align}
        \norm{\widetilde{ \mathcal{B}}_{\hat{p}^2} - \exp i t \hat{p}^2 \sigma^x} &\in \mathcal{O}((\norm{\hat{p}}^2 t)^{p + \frac{1}{2}}).
    \end{align}
    We apply \cref{lem:trotter-with-approx} and observe:
    \begin{align}
        \norm{\textrm{Trotter}_q( \widetilde{\mathcal{B}}_{\hat{x}^2}, \widetilde{\mathcal{B}}_{\hat{p}^2}) - \exp i t (\hat{x}^2 + \hat{p}^2)\sigma^x } \in \mathcal{O}( (C t)^{p + \frac{1}{2}}),
    \end{align}
    where $C = \max( \norm{ \hat{x}^2 + \hat{p}^2 }, \norm{\hat{x}}^2, \norm{\hat{p}}^2)$ and $q = \ceil{\frac{p}{2} - \frac{1}{4}}$. This requires no more than $4 \cdot 5^{q - 1}$ operator exponentials, thus implying:
    \begin{align}
        4 \cdot 5^{q - 1} \leq 4 \cdot 5^{ \frac{p}{2} - \frac{1}{4} }.
    \end{align}
\end{proof}

% \how{new asymptotic analysis on the maintext formulas}




\subsection{Controlled-phase beam splitter gate}\label{subsec:controlled-phase}
\resultbeamsplitter
\begin{proof}
We may take a similar approach as above. Apply \cref{fact:bch}:
\begin{align}
    \norm{\textrm{BCH}_p(\exp i \tau \hat{x}_1 \sigma^i, \exp i \tau \hat{x}_2 \sigma^j) - \exp \tau^2 \hat{x}_1 \hat{x}_2 [\sigma^i, \sigma^j] } &\in \mathcal{O}((\norm{\hat{x}} \tau)^{2p + 1}), \\
    \norm{\textrm{BCH}_p(\exp i \tau \hat{p}_1 \sigma^i, \exp i \tau \hat{p}_2 \sigma^j) - \exp \tau^2 \hat{p}_1 \hat{p}_2 [\sigma^i, \sigma^j]  } &\in \mathcal{O}((\norm{\hat{p}} \tau)^{2p + 1}),
\end{align}
where we set $\norm{\hat{x}} = \max( \norm{\hat{x}_1}, \norm{\hat{x}_2})$ and $\norm{\hat{p}} = \max(\norm{\hat{p}_1}, \norm{\hat{p}_2})$. We again take $\tau = \sqrt{\frac{t}{2}}$ so that:
\begin{align}
    \norm{\widetilde{ \mathcal{B}}_{\hat{x}_1 \hat{x}_2} - \exp i t \hat{x}_1 \hat{x}_2 \sigma^x} &\in \mathcal{O}((\norm{\hat{x}}^2 t)^{p + \frac{1}{2}}), \\
    \norm{\widetilde{ \mathcal{B}}_{\hat{p}_1 \hat{p}_2} - \exp i t \hat{p}_1 \hat{p}_2 \sigma^x} &\in \mathcal{O}((\norm{\hat{p}}^2 t)^{p + \frac{1}{2}}) .
\end{align}
Applying \cref{lem:trotter-with-approx}:
\begin{align}
    \norm{\textrm{Trotter}_q( \widetilde{\mathcal{B}}_{\hat{x}_1 \hat{x}_2}, \widetilde{\mathcal{B}}_{\hat{p}_1 \hat{p}_2}) - \exp i t (\hat{x}_1 \hat{x}_2 + \hat{p}_1 \hat{p}_2)\sigma^x } \in \mathcal{O}( (C t)^{p + \frac{1}{2}}),
\end{align}
where $C = \max( \norm{ \hat{x}_1 \hat{x}_2 + \hat{p}_1 \hat{p}_2}, \norm{\hat{x}}^2, \norm{\hat{p}}^2)$ and $q = \ceil{\frac{p}{2} - \frac{1}{4}}$. This requires no more than $4 \cdot 5^{q - 1}$ operator exponentials, thus implying:
    \begin{align}
        4 \cdot 5^{q - 1} \leq 4 \cdot 5^{ \frac{p}{2} - \frac{1}{4} }.
    \end{align}
\end{proof}


\section{Fock-Space Applications}
We now introduce a series of techniques that allow us to realize polynomials of Fock-space operators. We first begin in \cref{subsec:arbitrary_power} by identifying the error scaling of an arbitrary order Fock-space block encoding, i.e. $\mathcal{B}_{a^k}$. In \cref{apndx:error-jc}, we show how the techniques can be used to simulate the Jaynes-Cummings Hamiltonian, which itself is a polynomial of Fock space operators. In \cref{subsec:state-prep}, we demonstrate how this technique can be extended beyond simulation into realizing more general operators, like a state-prep unitary.

\subsection{Realizing block encodings of arbitrary order}\label{subsec:arbitrary_power}
We seek to demonstrate the following result:
\begin{theorem}\label{thm:main}
For positive integer $k \geq 1$ and timestep $t \in\mathbb{R}$, we seek to implement the target block encoding $\mathcal{T}_k(t)$ defined as:
\begin{align}
    \mathcal{T}_{k}(t) = \exp \left( it \begin{bmatrix}
    0 &  ( a^{\dagger})^{k}  \\
    ( a )^{k} & 0
    \end{bmatrix} \right).
\end{align}
For any $\epsilon>0$ and $p > 1$ there exists an implementable unitary operation $\widetilde{\mathcal{T}}_{k, p}$ of order $p$ such that:
\begin{align}
    \norm{\mathcal{T}_k - \widetilde{\mathcal{T}}_{k, p}}\leq \epsilon,
\end{align}
and the number of applications of $\mathcal{S}_1(t)$ needed to implement the operation scales in:
\begin{align}
    r \cdot n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1} ,
\end{align}
where $r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{\epsilon^{1 / (p - 1)}} \right)$.
\end{theorem}

Because we can add two lower-order block encodings via \cref{alg:adder}, we can exploit a binary expansion to achieve arbitrary orders (e.g.~$(a^\dagger)^9 = (a^{\dagger})^{2^3} a^\dagger$). Thus, our first task is to demonstrate the implementation of these block encodings with orders that are a power of two. This is achievable through the recursive $\textrm{POWER}$ algorithm:
\begin{algorithm}[H]
\caption{POWER($k, t, p$) }\label{alg:power_of_two}
% \how{ algorithm ensure }
\begin{algorithmic}
\Require $k = 2^\ell$ for nonnegative integer $\ell$, timestep $t > 0$, order $p > 1$
\Ensure $\widetilde{\mathcal{T}}_k$ with $\norm{\widetilde{\mathcal{T}}_k  - \exp it \begin{bmatrix}
    0 & (a^\dagger)^k \\
    a^k & 0
\end{bmatrix}} \in \mathcal{O}((\Lambda^{k / 2} t)^p)$
\If{$k = 1$}
    \State \Return $\mathcal{S}_1(t)$
\Else
    \State $p' \coloneqq 2p$
    \State $\textrm{HalfOp} \coloneqq \textrm{POWER}(k/2, \sqrt{t/2}, p')$
    \State \Return $\textrm{ADD}(\textrm{HalfOp}, \textrm{HalfOp}, p', p', \sqrt{t / 2})$
\EndIf
\end{algorithmic}
\end{algorithm}

Building to the following result:
\begin{theorem}\label{lem:key-scaling}
For any $t \geq 0$, $p \geq 1$, and fixed $k = 2^\ell$ for some $\ell \geq 1$ we have that the unitary implemented by~\Cref{alg:power_of_two}, ${\rm POWER}$ acting on $\mathcal{H}_2\otimes \mathcal{H}_\Lambda$, satisfies:
\begin{align}
    \norm{ {\rm POWER}(k,t,p) - \exp \left( i t \begin{bmatrix}
    0 & (a^\dagger)^{k} \\
    ( a )^{k}  & 0
    \end{bmatrix} \right) } \in \mathcal{O}((\Lambda^{k/2} t)^{p}),
\end{align}
using no more than $ 6^{\log_2 k} \cdot 420^{kp / 2}$ unitary $\mathcal{S}_1$ operators.
% , which are defined in
\end{theorem}

To bound the error of this algorithm, we can begin by identifying the implementation error of the second-order formula, i.e. $\widetilde{\mathcal{S}}_2$, the first operator with implementation error:
\begin{lemma}[Implementing second-order block encodings]\label{corr:second_order}
Suppose we can implement the following operation without error (as defined in~\Cref{defn:SX} and subject to a bosonic cutoff):
\begin{align}
\mathcal{S}_1(t) = \exp \left( it 
\begin{bmatrix}
    0 & a^\dagger
    \\
    a & 0
\end{bmatrix} \right).
\end{align}
Then, we can approximate $\mathcal{S}_2(t) $ to the $p^\text{th}$ order, i.e. implement $\widetilde{\mathcal{S}}_2$ such that:
\begin{align}
    \norm{\widetilde{\mathcal{S}}_{2, p}(t) - \mathcal{S}_2(t)} \in \mathcal{O}((\Lambda t)^{p + \frac{1}{2}}),
\end{align}
using no more than $6 \cdot 14^p$ $\mathcal{S}_1(t)$ operations.
\end{lemma}
\begin{proof}
Note that, if $\mathcal{S}_1(t)$ is errorless, then we only need to account for error incurred by the BCH and Trotter formulas. By employing a $p^\text{th}$ order BCH formula we can produce commutator exponentials with error $\mathcal{O}((\Lambda^{1/2} \tau)^{2p + 1})$ by \cref{fact:bch} and \cref{fact:norm-blockencodedxt}.

% \how{230227 reviewed up to here}

We again set $\tau = \sqrt{\frac{t}{2}}$ so that the error scales in at worst $\mathcal{O}((\Lambda t)^{p + \frac{1}{2}})$. Then, we apply a Trotter formula \cref{lem:trotter-with-approx} of order $\ceil{\frac{p}{2}}$ so that:
\begin{align}
    \norm{\exp \left(i t \begin{bmatrix}
        0 & ( a^\dagger)^2 \\
        ( a )^2 & 0
    \end{bmatrix} \right) - \widetilde{\mathcal{S}}_2(t)} \in \mathcal{O}((Ct)^{p + \frac{1}{2}}),
\end{align}
with $C \leq \max( \Lambda, \Lambda^{2/2}) = \Lambda $ so that our worst case error scaling is $\mathcal{O}((\Lambda t)^{p + \frac{1}{2}})$. This requires no more than $2 \cdot 2 \cdot 5^{\ceil{ \frac{p}{2}} - 1}$ of the commutators, each of which required $8 \cdot 6^{p - 1}$ first order operations. Thus, the cost scales in no more than:
\begin{align}
    4 \cdot 5^{p / 2} \cdot 8 \cdot 6^{p - 1} \leq 6 \cdot 14^p
\end{align}
total number of $\mathcal{S}_1$ operations.
\end{proof}

This base case allows us to analyze the performance of \cref{alg:power_of_two}:

\begin{proof}[Proof of \cref{lem:key-scaling}]
We demonstrate the bounds inductively. The base case ($\ell = 1$) holds via \cref{corr:second_order}. For the inductive hypothesis, we assume that, for any $p' \geq 1$ and $k = 2^\ell$, we may implement $\textrm{POWER}(k, t, p')$:
\begin{align}
    \norm{ {\rm POWER}(k,t, p') - \exp \left( i t \begin{bmatrix}
    0 & ( a^\dagger )^{k} \\
    ( a )^{k}  & 0
    \end{bmatrix} \right) } \in \mathcal{O}((\Lambda^{k / 2} t)^{p'}).
\end{align}
To demonstrate the inductive step, we seek to apply \cref{lem:adder} directly to the implementable operators from the inductive hypothesis. Thus, we set $p' = 2p$ so that:
\begin{align}
    \norm{ {\rm POWER}(2k,t, p) - \exp \left( i t \begin{bmatrix}
    0 & (a^\dagger)^{2k} \\
    ( a )^{2k}  & 0
    \end{bmatrix} \right) } \in \mathcal{O}((\Lambda^{2k / 2} t)^{p' / 2}) = \mathcal{O}((\Lambda^{2k/2} t)^{p}),
\end{align}
our desired error scaling. By \cref{lem:adder}, we require an adder of order $\max(\ceil{\frac{p' - 1}{2}}, 1) \leq p + \frac{1}{2}$. Thus, the adder requires requires $1.07 \cdot 30^{p + 1/2} \leq 6 \cdot 30^p$ of the $\textrm{POWER}(k, t, p')$ operations, i.e.:
\begin{align}
    \textrm{COST}(2k, p) &\leq 6 \cdot 30^p \cdot \textrm{COST}(k, 2p)  \\
    &\leq 6 \cdot 30^p \cdot 6 \cdot 30^{2p} \cdot \textrm{COST}(k / 2, 4p) \\
    &\leq \prod_{j = 1}^{n} 6 \cdot 30^{2^{j - 1}p} \cdot \textrm{COST}(2k / 2^n, 2^n p) \\
    &\leq 6^\ell \cdot 30^{kp} \cdot \textrm{COST}(2, k p).
\end{align}
Since $\textrm{COST}(2, kp) \leq 6 \cdot 14^{kp}$ by \cref{corr:second_order}, the number of $\mathcal{S}_1$ operations is upper bounded by:
\begin{align}
    \textrm{COST}(2k, p) \leq  6^{\log_2 k + 1} \cdot 420^{k p} \implies \textrm{COST}(k, p) \leq 6^{\log_2 k} \cdot 420^{kp / 2}.
\end{align}
\end{proof}

%% this is the theorem



% \subsection{Achieving Arbitrary Orders}\label{subsec:arb_order}
% Via the BCH formulas, we can also build operators of arbitrary order. 

Together, the POWER and ADD algorithms allow us to approximate arbitrary orders. We describe a recursive algorithm below to construct any order $k \geq 1$:
\begin{algorithm}[H]
\caption{ARB\_POWER($k, t, p, l, r$) that produces $\mathcal{T}_k(t)$ for any $k \geq 1$}\label{alg:arb_power}
\begin{algorithmic}
\Require $k > 0$ and has the binary representation $k = k_n k_{n-1} ... k_1$.

\If{$r - l = 0$}
    \If{$k_r = 1$}
        \State \Return $\textrm{POWER}(H, 2^r, t, p)$
    \Else
        \State \Return $RX(t) \kron \identity$
    \EndIf
\Else
    \State \Return $\textrm{ADD}(\textrm{ARB\_POWER}(k, \sqrt{t/2}, p, l, \floor{\frac{r - l}{2}} + l), \textrm{ARB\_POWER}(k, \sqrt{t/2}, p, l + \floor{\frac{r - l}{2}} + 1, r) $
\EndIf
\end{algorithmic}
\end{algorithm}


% \how{this algorithm is extra - we use RX instead of just iterating}.
% \textbf{The theorem statement below is unclear, specifically the target operator isn't obvious to an external reader also it may be useful to reduce the number of $S_X$ for the statement of the theorem into raw number of exponentials needed since those are more likely to be the drivers of the cost.}
% \how{under the assumptions of blah blah blah this holds }

\begin{theorem}\label{thm:arb_calc}
Assuming that the $\mathcal{S}_1$ operator can be implemented without error, the \cref{alg:arb_power} produces a series of gates $\{ \mathcal{S}_1(t_i(t)) \}$ such that:
\begin{align}
    \norm{\prod_i \mathcal{S}_1(t_i(t)) - \mathcal{T}_k(t)} \in \mathcal{O}((\Lambda^{k/2} t)^{p}),
\end{align}
where $\mathcal{T}_k$ is our target operator and we have order $k > 0$. The number of $\mathcal{S}_1$ gates required is no more than $n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1}$.
\end{theorem}
\begin{proof}
We demonstrate this constructively on the worst case scenario where $k = k_n k_{n - 1} ... k_1$ and $k_n, k_{n-1}..., k_1 = 1$. WLOG, we assume $n = 2^{\ell}$ for some integer $\ell$. This is because, if $n$ not a power of two, we can simply pad the leading digits with zeros to achieve a balanced binary tree.

The proof is as follows: we first identify the error scaling necessary for each leaf node of the binary tree so that the overall formula has our desired order, then we perform the cost accounting and estimate the number of $\mathcal{S}_1$ operations required.

% \how{key idea: count the number of leaf nodes, then add the number of sx requried for each}

To achieve an error scaling of $\mathcal{O}((\Lambda^{2^n / 2} t)^p)$, the two terms being `added' below must have error scaling of order at worst $\mathcal{O}((\Lambda^{2^n / 4} t)^{2p})$ by \cref{lem:adder}, and so on for each subsequent layer. Thus, each of the leaf $\textrm{POWER}$ terms must have order at least $\mathcal{O}((\Lambda^{2^n / 2^{1 + \log_2 n} } t)^{2^{\log_2 n} p }) = \mathcal{O}(( \Lambda^{2^n / 2n} t)^{np})$.

Now, we compute the cost incurred by the formula. We begin by counting the number of times $\textrm{POWER}$ is used, then accounting for the number of $\mathcal{S}_1$ required to implement each $\textrm{POWER}$. Note that each $\textrm{POWER}$ term will be used proportionally to the number of $\textrm{ADD}$ operations necessary, so we can compute the cost of implementing each $\textrm{POWER}$ operation for the $i^\text{th}$ digit, i.e. the $\textrm{POWER}$ operation has degree $j = 2^i$. We thus bound the number of $\mathcal{S}_1$ operations required to implement this $np^\text{th}$-ordered operator: 
\begin{align}
    6^{\log_2 j} \cdot 420^{j n p / 2} = 6^{i} \cdot 420^{2^i n p / 2}.
\end{align}
Finally, we seek to bound the number of times each $\textrm{POWER}$ operator is used through the $\textrm{ADD}$ algorithm. Recall from \cref{lem:adder} that each $\textrm{ADD}$ operation requires at most $1.07 \cdot 30^q$ of the constituent operators, where $q = \max ( \ceil{\frac{\min(p_l, p_r) - 1}{2}}, 1)$ and $p_l, p_r$ are the orders of the underlying operators. By assuming symmetry of the Trotter formula for $\textrm{ADD}$, each addition requires $\frac{1}{2} 1.07 \cdot 30^q$ of the underlying operator. Thus, we can obtain a bound on the number of applications required of each fundamental $\textrm{POWER}$ operator:
\begin{align}
    \prod_{s = 1}^{\log_2 n} \frac{1}{2} 1.07 \cdot 30^{ 2^{s - 1}p + 1/2} \leq 3^{\log_2 n} 30^{np} \leq n^{1.6} 30^{np}
\end{align}
% \how{i used s here because it shows that we're adding over add alg, not the digit position}
because the $s^\text{th}$ layer of $\textrm{ADD}$ requires constituent operators of order $2^s p$, so $q \leq 2^{s - 1}p + \frac{1}{2}$. 

Finally, consider the total cost by adding up the cost of the individual $\textrm{POWER}$ operators multiplied by the number of applications required:
\begin{align}
    \sum_{i = 1}^{\log_2 n} n^{1.6} 30^{np} \cdot 6^{i} \cdot 420^{2^{i} np / 2} &\leq n^{1.6} 30^{np} 420^{n^2 p / 2} \sum_{i = 1}^{\log_2 n} 6^i \\
    &\leq n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1},
\end{align}
as desired.
\end{proof}

% \how{take some time to ensure all the different layers of t/r hold vs tau eq 16}

Now, we seek to finalize the number of ops required in terms of $\epsilon$. Recognize that we may use timeslicing to reduce the error arbitrarily. Note that:
\begin{lemma}\label{r-scaling}
Suppose we may implement $\widetilde{\mathcal{T}}_{k, p}(t)$, an approximation of $\mathcal{T}_k(t)$ with $p > 1$ such that:
\begin{align}
    \norm{\mathcal{T}_k(t) - \widetilde{\mathcal{T}}_{k, p}(t)} \in \mathcal{O}((\Lambda^{k / 2} t)^p).
\end{align}
Then, by timeslicing the approximation, we can produce $\widetilde{\mathcal{T}}_{k, p}^r(t)$ where:
\begin{align}
    \norm{\mathcal{T}_k(t) - \widetilde{\mathcal{T}}_{k, p}^r(t)} \leq \epsilon,
\end{align}
where $\widetilde{\mathcal{T}}_k^r(t)$ requires $r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{\epsilon^{1 / (p - 1)}} \right)$ applications of the $\widetilde{\mathcal{T}}_k(t)$ operator.
\end{lemma}
\begin{proof}
% $\widetilde{\mathcal{T}}_k(t)$ is implementable by \cref{thm:arb_calc}. 
% Recall by \cref{thm:arb_calc} we can implement the following operation:
% \begin{align}
%     \widetilde{\mathcal{T}}_k(t)= e^{i A_k t} + \Delta(t) t^{p + \frac{1}{2}}
% \end{align}
% With matrix error term $\norm{\Delta(t)} \in \mathcal{O}(1)$. 
We define the timeslicing of $\widetilde{T}_k(t)$ as applying $\widetilde{\mathcal{T}}_k(t/r)$ operator $r$ times:
\begin{align}
    \widetilde{\mathcal{T}}_{k, p}^r(t) = \widetilde{\mathcal{T}}_{k, p}(t / r)^r.
\end{align}
To find a Taylor expansion for $\widetilde{\mathcal{T}}_{k, p}(t / r)^r$, note the explicit form for $\widetilde{\mathcal{T}}_{k, p}(t)$:
\begin{align}
    \widetilde{\mathcal{T}}_{k, p}(t) = e^{i A_k t} + \Delta(t) (\Lambda^{k /2} t)^p,
\end{align}
where $\norm{\Delta(t)} \in \mathcal{O}(1)$.This allows us to express the refined operator as follows:
\begin{align}
    \widetilde{\mathcal{T}}_k(t/r)^r &= \left( e^{i A_k t / r} + \Delta\left( \frac{t}{r}\right) \left( \frac{t^{p}}{r^{p}} \right) \right)^r \\
    %%%%%
    &= e^{i A_k t} + \left[ \sum_{j = 1}^{r - 1} (e^{i A_k t / r})^{j} \Delta\left( \frac{t}{r} \right) (e^{i A_k t / r})^{r - 1 - j} \right] \left( \frac{(\Lambda^{k/2}t)^{p}}{r^{p}} \right) + \mathcal{O} \left(\left( \frac{\Lambda^{k/2} t}{r} \right)^{p + 1} \right),
\end{align}
Thus, when we analyze the error:
\begin{align}
    \norm{\mathcal{T}_k(t/r)^r - e^{i A_k t}} &\leq \mathcal{O} \left( r \norm{(e^{i A_k t /r})^{r - 1}} \norm{\Delta\left( \frac{t}{r} \right)} \left(  \frac{(\Lambda^{k/2}t)^{p}}{r^{p}} \right) \right) \nonumber\\
    &\subset \mathcal{O} \left( \frac{(\Lambda^{k/2}t)^{p}}{r^{p - 1}} \right).
\end{align}
To bound the implementation error by $\epsilon$, i.e. $\epsilon \in \mathcal{O} \left(  \frac{(\Lambda^{k/2}t)^{p}}{r^{p - 1}} \right)$, we should select $r$ as follows:
\begin{align}
    r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{p / (p - 1)}}{\epsilon^{1 / (p - 1)}} \right) = \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{\epsilon^{1 / (p - 1)}} \right),
\end{align}
as desired.
\end{proof}

% \how{restate cleanly the thm (2.1)}

% \how{fix below proof}

Finally, we can demonstrate our original theorem statement, allowing us to create a bound on the number of $\mathcal{S}_1$ operations necessary to achieve an arbitrarily ordered operator:
\begin{proof}[Proof of \cref{thm:main}]
By \cref{thm:arb_calc}, we can perform a single Trotter step of timestep $\frac{t}{r}$ using $n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1}$ $\mathcal{S}_1$ operations. Thus, the total number of $\mathcal{S}_1$ operations required scales in:
\begin{align}
    r \cdot n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1} ,
\end{align}
where, by \cref{r-scaling}, it is sufficient to set $r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{\epsilon^{1 / (p - 1)}} \right)$. 

\end{proof}

\subsection{Generation of nonlinear Hamiltonians}\label{apndx:error-jc}
% \ck{mention scaling with relation to max (kappa, omega)}

%\subsubsection{Combining the two terms via Trotter}
% We can combine the above results to implement our desired hamiltonian:

% Finally, by the timestepping analysis \cref{r-scaling}, we can obtain an epsilon bound:

% Thus, we can construct an approximation of arbitrary order. We conclude by proving an upper bound on the number of $\mathcal{S}_1$ exponentials required:
% \how{also need to verify tau}
% \how{clarify H}

% We can approximate an exponential of the following block-encoded Hamiltonian $H$:

% $\exp i t \begin{bmatrix}
%     H & \cdot \\
%     \cdot & \cdot
% \end{bmatrix}$
% \how{``H" the hamiltonian of 75}

% abstract: 
% \how{near linear simulation time}

% \how{compilation technique from gateset to hamiltonian simulation problem}

\resultjc
%\how{yes, this is the chi 3 model -- micheline, can you reword appropriately?}

\begin{proof}
We first show that the two Hamiltonian terms are implementable separately. Then, via Trotter, we combine them and perform an error analysis. In particular, we hope to embed the Hamiltonian such that we approximate the following operator:
\begin{align}
    \exp it \begin{bmatrix}
        H & 0 \\
        0 & \cdot
    \end{bmatrix},
\end{align}
i.e., where the Hamiltonian is embedded in the upper left hand block. Thus, when applied to a system with the $\ket{0}$ qubit, this amounts to implementing $\exp i t H $ on the mode.  

We begin by embedding the $a^\dagger a$ term. Notice that $a^\dagger a$ Hermitian; thus, we can apply \cref{alg:mult} on the $a, a^\dagger$ block encodings. By the error analysis in \cref{fact:bch} and the bound on norm from \cref{fact:norm-blockencodedxt}:
% \begin{align}
%     \norm{ \textrm{MULT}(\mathcal{B}_{a}(\tau), \mathcal{B}_{a^\dagger}(\tau)) - \exp i t \begin{bmatrix}
%         a^\dagger a & 0 \\
%         0 & a a^\dagger
%     \end{bmatrix} } \in \mathcal{O}( (C^2 t)^{\min (p_A, p_B) / 2}
% \end{align}
% Where $C = \max (\norm{}$
% \cref{fact:bch} 
\begin{align}
    \norm{\bch_q \left(\mathcal{S}_1^Y(\tau), \mathcal{S}_1(\tau) \right) - \exp 2 i \tau^2 \begin{bmatrix}
         a^\dagger   a  & 0 \\
        0 &  a    a^\dagger  
    \end{bmatrix} } \in \mathcal{O}((\Lambda^{1/2} \tau)^{2q + 1}),
\end{align}
so that, by setting $\tau = \sqrt{\frac{\omega t}{2}}$, we have: 
% \how{take omega not as constant}
\begin{align}
    \norm{\bch_q \left(\mathcal{S}_1^Y \left(\sqrt{\frac{\omega t}{2}} \right), \mathcal{S}_1\left(\sqrt{\frac{\omega t}{2}} \right) \right) - \exp i \omega t \begin{bmatrix}
         a^\dagger   a  & 0 \\
        0 &  a    a^\dagger  
    \end{bmatrix} } \in \mathcal{O}((\Lambda \omega t)^{q + \frac{1}{2}}),
\end{align}
using $8 \cdot 6^{q - 1}$ total $\mathcal{S}_1$ operations.

Recall that we can easily block-encode $( a^\dagger )^2$ and $ ( a )^2$ via \cref{alg:power_of_two}. We then apply \cref{alg:mult} to $(a^\dagger)^2, a^2$ to yield the desired upper-left block encoding. Namely, because we can implement $\mathcal{S}_{2, p}$ with the following error scaling:
% via the formulas described above. Thus, we can repeat a similar approach as above and instead use \cref{alg:mult} on the approximated operators to produce a block-encoded $( a^\dagger )^2 ( a )^2$. By \cref{corr:second_order} and \cref{lem:multiplication-alg},
\begin{align}
    \norm{\mathcal{S}_{2, p}(\tau) - \exp i \tau \begin{bmatrix}
        0 & ( a^\dagger)^2 \\
        a ^2  & 0
    \end{bmatrix}} \in \mathcal{O}((\Lambda \tau)^{p + \frac{1}{2}}),
\end{align}
using no more than $6 \cdot 14^p$ $\mathcal{S}_1$ operations, we can apply \cref{alg:mult} to find:
% We then define $\mathcal{S}_{2, p}^Y(\tau) = (S \kron \identity_\gamma) \mathcal{S}_{2, p}^Y(\tau) (S^\dagger \kron \identity_\gamma)$ and apply \cref{lem:bch-with-approx}:
\begin{align}
    \norm{\textrm{MULT} (\mathcal{S}_{2, p}(\tau), X \mathcal{S}_{2, p}(\tau) X ) - \exp 2 i \tau^2 \begin{bmatrix}
        ( a^\dagger )^2 ( a )^2 & 0 \\
        0 & ( a )^2 ( a^\dagger )^2
    \end{bmatrix} } \in \mathcal{O}((\Lambda^2 \tau)^{p + \frac{1}{2}}),
\end{align}
% \how{i don't like u}
% \how{we need to check the error of this formula because now the constant factor is larger, i believe}
by setting $\ell = \ceil{\frac{p - \frac{1}{2}}{2}} \leq \frac{p}{2} + 1 $ and thus using $8 \cdot 6^{\ell - 1}$ exponentials. When $\tau = \sqrt{\frac{\kappa t}{4}}$: 
% \how{take kappa not as constant}
\begin{align}
    \norm{\bch_\ell \left(\mathcal{S}_{2, p}^Y\left(\sqrt{\frac{\kappa t}{4}} \right), \mathcal{S}_{2, p}\left(\sqrt{\frac{\kappa t}{4}} \right) \right) - \exp i \frac{\kappa}{2} t  \begin{bmatrix}
        ( a^\dagger )^2 ( a )^2 & 0 \\
        0 & ( a )^2 ( a^\dagger )^2
    \end{bmatrix} } \in \mathcal{O}( (\Lambda^4 \kappa t)^{\frac{p}{2} + \frac{1}{4}}),
\end{align}
using no more than $8 \cdot 6^{\ell - 1} \cdot 6 \cdot 14^p \leq 48 \cdot 6^{p / 2} \cdot 14^{p} \leq 48 \cdot 35^p$ total $\mathcal{S}_1$ operators. Then, we may set $p = 2q$ so that, given no more than $48 \cdot 35^{2q}$ total $\mathcal{S}_1$ operations, we can implement the BCH formula with error scaling $\mathcal{O}((\Lambda^4 \kappa t)^{q + \frac{1}{4}})$.

Finally, we apply the Trotter formula to the two subterms via \cref{lem:trotter-with-approx}, finding:
\begin{align}
    & \Biggl\lVert
    \trotter_{2s} 
        \Biggl(\bch_q 
            \Biggl(\mathcal{S}_X^Y
                \Biggl(\sqrt{\frac{\omega t}{2}}\Biggr), 
            \mathcal{S}_X
                \left(\sqrt{\frac{\omega t}{2}})\right) 
            \Biggr) , 
    \bch_u 
            \left(\mathcal{S}_{2, p}^Y
                \left(\sqrt{\frac{\kappa t}{4}}\right), 
            \mathcal{S}_{2, p}
                \left(\sqrt{\frac{\kappa t}{4}})\right) 
            \right) 
        \Biggr) \nonumber \\
        &\qquad - \exp i t \begin{bmatrix}
        H & 0 \\
        0 & \cdot
    \end{bmatrix} 
    \Biggr\rVert  \\
    &\qquad \in \mathcal{O}((\Lambda^4 \max( \omega, \kappa) t)^{q + \frac{1}{4}}),
\end{align}
% \how{recheck}
where the constant factor can be obtained by observing the Hamiltonian norm is bounded via the triangle inequality. Now, by setting $s = \ceil{\frac{1}{2} (q - \frac{3}{4})} \leq \frac{q}{2} + \frac{5}{8}$, we can obtain the desired error scaling. This formula requires no more than $4 \cdot 5^{s - 1} $ total operations; by symmetry, we can assume each of the BCH formulas only must be applied $2 \cdot 5^{s - 1}$ times. Thus, the total number of $\mathcal{S}_1$ operations is no more than:
\begin{align}
    2 \cdot 5^{s - 1} (8 \cdot 6^{q - 1} + 48 \cdot 35^{2q}) \leq 4 \cdot 5^{\frac{q}{2}} \cdot 48 \cdot 35^{2q} \leq 192 \cdot 2900^q.
\end{align}
% \how{is this good enough lol}

% \how{move 82, 83 above eq into proof of thm 3.1}
% Begin first by assessing the number of $\mathcal{S}_1$ operations necessary to implement the Trotterized operator. From \cref{lem:trotter-with-approx}, this requires at most $5^{s - 1} + 1$ of each of the exponentials. Thus, the total cost is:
% \begin{align}
%     (5^{s -1 } + 1)(8 \cdot 6^{q - 1} + 8 \cdot 6^{p/2 + 1} \mathcal{O}(e^{2.597p})) \subset \mathcal{O}(5^{q/ 2} \cdot 6^q e^{2.597 \cdot 2 q}) \subset \mathcal{O}(e^{7.8 q})
% \end{align}

To produce an $\epsilon$ scaling, we apply \cref{r-scaling} to the Trotterized operator, implying that we require the following $r$ scaling for fixed $q$:
\begin{align}
    r \in \Omega\left( \frac{(\Lambda^{4} t)^{1 + 1 / (q - \frac{3}{4})} }{\epsilon^{1 / (q - \frac{3}{4})}} \right),
\end{align}
where the total number of $\mathcal{S}_1$ operations is no more than:
\begin{align}
    r \cdot 192 \cdot 2900^q \subset re^{\mathcal{O}(q)}.
\end{align}

\end{proof}

\subsection{Application to state preparation}\label{subsec:state-prep}
We first need to demonstrate the connection between block-encoded powers of annihilation/creation operators and state preparation. First, observe that the ideal block encoding would allow for initialization from the vacuum:
\statepreptime
\begin{proof}\label{state_prep_proof}
    The proof is algebraic; begin by producing the Taylor series expansion of the operator:
    \begin{align}
        \mathcal{T}_{k}(t) &= \exp \left( it \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix} \right) \\
        &\qquad= \sum_{j = 0}^\infty \frac{(it)^j}{j!} \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix}^j \\ 
        &\qquad= \sum_{j = 0}^\infty \frac{(it)^{2j}}{(2j)!} \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix}^{2j}
        + \sum_{j = 0}^\infty \frac{(it)^{2j + 1}}{(2j + 1)!} \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix}^{2j + 1},
    \end{align}
where the matrix products have well-defined forms:
    \begin{align}
        % \begin{bmatrix}
        %     0 & ( a^\dagger )^k \\
        %     ( a )^k & 0
        % \end{bmatrix}^{2} &= \begin{bmatrix}
        %     ( a^\dagger )^k ( a )^k & 0 \\
        %     0 & ( a )^k ( a^\dagger )^k 
        % \end{bmatrix} \\
        \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix}^{2j} &= \begin{bmatrix}
            (( a^\dagger )^k ( a )^k)^j & 0 \\
            0 & (( a )^k ( a^\dagger )^k)^j 
        \end{bmatrix}, \\
        \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix}^{2j + 1} &= \begin{bmatrix}
             0 & ( a^\dagger )^k (( a )^k ( a^\dagger )^k)^j \\
            ( a )^k (( a^\dagger )^k ( a )^k)^j & 0 
        \end{bmatrix},
    \end{align}
so that:
\begin{align}
    &\exp \left( it \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix} \right) \ket{1} \kron \ket{0} \\
        &\qquad = \sum_{j = 0}^\infty \frac{(it)^{2j}}{(2j)!} \sqrt{k!}^{2j} \ket{1} \kron \ket{0} + \sum_{j = 0}^\infty \frac{(it)^{2j + 1}}{(2j + 1)!} \sqrt{k!}^{2j + 1}  \ket{0} \kron \ket{k} \\
        &\qquad= \cos (t \sqrt{k!}) \ket{1} \kron \ket{0} + i \sin (t \sqrt{k!}) \ket{0} \kron \ket{k}.
\end{align}
When $t \sqrt{k!} = (2n + 1) \frac{\pi}{2}$ for $n \in \mathbb{N}$, the $\ket{1} \kron \ket{0}$ term vanishes and we are left with the $\ket{0} \kron \ket{k}$ Fock state, as desired.
\end{proof}

% This technique can then be extended to precisely perform $\ket{1} \ket{0} \mapsto \ket{0} \ket{k}$ while leaving all initial states intact (i.e., $\ket{1} \ket{k} \mapsto \ket{1} \ket{k} $ for $k \neq 1$. We claim:


While this result allows us to prepare the $\ket{k}$ Fock state, it also will incur unwanted transformations on starting states other than the vacuum ($\ket{1} \kron \ket{n}, n \neq 1$). By applying the BCH formula, we can isolate this operation so that it only operates on the $\ket{1} \kron \ket{0}$ term. In particular, we argue:
\resultstateprep
\begin{proof}
The general construction of the operator emerges from the use of a Trotter formula in conjunction with a phase rotation gate. Begin by defining the rotation operator:
\begin{define}
Call $R_{Z0}$ the phase-flip operator acting on some set of modes $B$ to be:
\begin{align}
    R_{Z0} := \identity \otimes (\identity - 2 \ket{0}\!\bra{0}),
\end{align}
i.e., only flip the phase for the vacuum. This operator is implementable using a 0-controlled cavity-conditioned qubit rotation gate. 

    % Define the phase-flip operator acting on some set of modes $B$ to be:
    % \begin{align}
    %     R_Z^B \ket{q} \ket{b} \mapsto (-1)^{\mathbb{I}[b \in B]} \ket{q} \ket{b}
    % \end{align}
    % I.e. only flip the phase for the modes in $S$. This has the following matrix form:
    % \begin{align}
    %     \exp \left(i \frac{\pi}{2} \begin{bmatrix}
    %     \diag(\mathcal{B}) & 0 \\
    %     0 & \diag(\mathcal{B})
    %     \end{bmatrix} \right)
    % \end{align}
    % Where $\mathcal{B} = [x \in B  : x \in [0..\Lambda]]$. \how{why is this realizable}
\end{define}
Then, because $R_{Z0}$ is self-adjoint, we can conjugate $\mathcal{T}_k(-t)$ without error as follows: 
\begin{align}
    R_{Z0} \mathcal{T}_k (-t) R_{Z0} &= R_{Z0} \exp \left( it' \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix} \right) R_{Z0} \\
        &= \exp \left( - it R_{Z0} \begin{bmatrix}
            0 & ( a^\dagger )^k \\
            ( a )^k & 0
        \end{bmatrix} R_{Z0} \right) \\
        &= \exp \left( it  \begin{bmatrix}
            0 & ( a^\dagger )^k (2 \ket{0}\!\bra{0} - \identity) \\
            (2 \ket{0}\!\bra{0} - \identity) ( a )^k  & 0
        \end{bmatrix} \right),
\end{align}
% Finally, label the operator $\check{\mathcal{T}_k}(t)$ set $t' = -t$ so that:
% \begin{align}
%      \check{\mathcal{T}_k}(t) &= R_{Z0} \exp \left( - it \begin{bmatrix}
%             0 & ( a^\dagger )^k \\
%             ( a )^k & 0
%         \end{bmatrix} \right) R_{Z0} \\
%         &= \exp \left( it \begin{bmatrix}
%             0 & -( a^\dagger )^k R_{Z0} \\
%             -R_{Z0} ( a )^k & 0
%         \end{bmatrix} \right)
% \end{align}
where specific left- and right-hand $(2 \ket{0}\!\bra{0} - \identity)$ terms vanish given the annihilation/creation operators. We then apply the Trotter formula upon $\mathcal{T}_k(t/2), R_{Z0} \mathcal{T}_k(-t/2) R_{Z0}$, yielding:
\begin{align}
    \exp \left( i t \begin{bmatrix}
        0 & ( a^\dagger )^k \ketbra{0}{0} \\
        \ketbra{0}{0} ( a )^k & 0
    \end{bmatrix} \right),
\end{align}
as desired.

% \begin{align}
%      \exp \left( it \begin{bmatrix}
%         0 & p_{k, 1} \\
%         p_{1, k} & 0 
%     \end{bmatrix} \right) = \exp \left( i \frac{t}{2} \begin{bmatrix}
%         0 & ( a^\dagger )^k (\identity - R_{Z0} ) \\
%         (\identity - R_{Z0}) ( a )^k & 0
%     \end{bmatrix} \right) 
% \end{align}

To compute the error scaling, recall our result from \cref{thm:arb_calc} which states the error scaling of $\widetilde{\mathcal{T}}_{k, p}$ (and, respectively, $R_{Z0} \widetilde{\mathcal{T}}_{k, p} R_{Z0}$):
\begin{align}
    \norm{\widetilde{\mathcal{T}}_{k, p}(t) - \mathcal{T}_k (t)} \in \mathcal{O}((\Lambda^{k/2} t)^p) ,
\end{align}
so that, by $\cref{lem:trotter-with-approx}$, 
\begin{align}
    \norm{\trotter_{2q}(\widetilde{\mathcal{T}}_{k, p}(t/2), R_{Z0} \widetilde{\mathcal{T}}_{k, p}(-t/2) R_{Z0}) - \exp \left( i t \begin{bmatrix}
        0 & ( a^\dagger )^k \ketbra{0}{0} \\
        \ketbra{0}{0} ( a )^k & 0
    \end{bmatrix} \right) } \in \mathcal{O}((\Lambda^{k/2} t)^{p}),
\end{align}
when $q = \max(\ceil{\frac{p - 1}{2}}, 1 ) $ and using no more than $4 \cdot 5^{q-1}$ operator exponentials. Thus, we can set $q = \frac{p + 1}{2} \geq \max(\ceil{\frac{p - 1}{2}}, 1 ) $ so that we use no more than $ 4 \cdot 5^{\frac{p - 1}{2}} \leq 2 \cdot 5^{p/2}$ $\widetilde{\mathcal{T}}_{k, p}$ terms.
% Where the even-$j$ terms converge to:
% \begin{align}
%     \begin{bmatrix}
%         0 & ( a^\dagger )^k (\identity - R_{Z0} ) \\
%         (\identity - R_{Z0}) ( a )^k & 0
%     \end{bmatrix}^{2j} = \\ \begin{bmatrix}
%         ( a^\dagger )^k (\identity - R_{Z0} )^2 ( a )^k & 0 \\
%         0 & (\identity - R_{Z0}) ( a )^k ( a^\dagger )^k (\identity - R_{Z0} ) 
%     \end{bmatrix}^j
% \end{align}

\end{proof}

% Observe that the commutator of the block-encoding and $R_Z^B$ takes the following form: 
% \begin{fact}
%     \begin{align}
%         &\left[ it \begin{bmatrix}
%             0 & ( a^\dagger )^k \\
%             ( a )^k & 0 
%         \end{bmatrix}, i \frac{\pi}{2} \begin{bmatrix}
%         \diag(\mathcal{B}) & 0 \\
%         0 & \diag(\mathcal{B})
%         \end{bmatrix} \right] \\
%         &\qquad= - t \frac{\pi}{2} \begin{bmatrix}
%             0 & ( a^\dagger )^k \diag(\mathcal{B}) - \diag(\mathcal{B}) ( a^\dagger )^k \\
%             ( a )^k \diag(\mathcal{B}) - \diag(\mathcal{B})( a )^k & 0
%         \end{bmatrix}
%     \end{align}
% \end{fact}

% \how{include surgical lemma}

% \ck{Givens rotations?}

Thus, our approximate operators can be applied to yield the same result with high probability:
\begin{theorem}
We can prepare the $\ket{0} \kron \ket{k}$ with probability at least $ 1- \delta$ using no more than $r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{(\delta / 2)^{1 / (p - 1)}} \right)$ $\mathcal{F}_{k, p}$ operators or at most
\begin{align}
    r \cdot 2 \cdot 5^{p/2} \cdot n^{1.6} 30^{np} 420^{n^2 p / 2} 6^{\log_2 n + 1} 
\end{align}
$\mathcal{S}_1$ operators.

\end{theorem}

\begin{proof}
Begin by identifying the $\epsilon$ precision necessary to yield a failure probability less than $\delta$. A sufficient condition would be that:
\begin{align}
    \left| \norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprepapprox \ket{1} \kron \ket{0}}^2 - \norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprep \ket{1} \kron \ket{0}}^2 \right| \leq \delta.
\end{align}
% \begin{align}
%     | \bra{1} \kron \bra{0} \mathcal{F}_{k, p}^\dagger \ketbra{0}{0} \kron \ketbra{k}{k} \mathcal{F}_{k, p} \ket{1} \kron \ket{0} - \bra{1} \kron \bra{0} \stateprep^\dagger \ketbra{0}{0} \kron \ketbra{k}{k} \stateprep \ket{1} \kron \ket{0} | \leq \delta 
% \end{align}
Observe that our idealized operator has a success probability; thus, we seek to demonstrate that:
\begin{align}
    \left|\norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprepapprox \ket{1} \kron \ket{0}}^2 - 1\right| \leq \delta .
\end{align}
Because the probability of measuring $\ket{0} \kron \ket{k}$ lies in $[0, 1]$, the above inequality holds when:
\begin{align}
    \norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprepapprox \ket{1} \kron \ket{0}}^2 \geq 1 - \delta.
\end{align}
% \begin{align}
%     \bra{1} \kron \bra{0} \mathcal{F}_{k, p}^\dagger \ketbra{0}{0} \kron \ketbra{k}{k} \mathcal{F}_{k, p} \ket{1} \kron \ket{0} \geq 1 - \delta
% \end{align}
Recognize that we can lower bound the norm:
\begin{align}
    &\norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprepapprox \ket{1} \kron \ket{0}}\\
    &\qquad= \norm{\ketbra{0}{0} \kron \ketbra{k}{k} (\stateprep - (\stateprep - \stateprepapprox)) \ket{1} \kron \ket{0}} \\
    &\qquad\geq \left| \norm{\ketbra{0}{0} \kron \ketbra{k}{k} \mathcal{F}_{k} \ket{1} \kron \ket{0}} - \norm{\ketbra{0}{0} \kron \ketbra{k}{k} (\stateprep - \stateprepapprox) \ket{1} \kron \ket{0}} \right| \\
    &\qquad\geq 1 - \norm{\stateprep - \stateprepapprox}_\infty.
\end{align}
By requiring $\norm{\stateprep - \stateprepapprox}_\infty \leq 1$. This allows us to produce a lower bound on the original LHS:
\begin{align}
    \norm{\ketbra{0}{0} \kron \ketbra{k}{k} \stateprepapprox \ket{1} \kron \ket{0}}^2 \geq 1 - 2 \norm{\stateprep - \stateprepapprox}_\infty.
\end{align}
Thus, it is sufficient for the following to hold:
\begin{align}
    1 - 2 \norm{\stateprep - \stateprepapprox}_\infty \geq 1 - \delta \iff \norm{\stateprep - \stateprepapprox}_\infty \leq \frac{\delta}{2}.
\end{align}
Apply \cref{r-scaling} to \cref{lem:fock-prep-unitary} so that the time-sliced $\stateprepapprox^r$ has:
\begin{align}
    \norm{\stateprepapprox^r - \stateprep} \leq \frac{\delta}{2},
\end{align}
by using $r \in \Theta \left( \frac{(\Lambda^{k/2}t)^{1 + 1/(p - 1)}}{(\delta / 2)^{1 / (p - 1)}} \right)$ applications of $\stateprepapprox(t/r)$. The $\mathcal{S}_1$ bound follows from a similar analysis to \cref{thm:main} applied to the result from \cref{lem:fock-prep-unitary}.

\end{proof}




\section{Universal Control of the \texorpdfstring{Span $\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $}{}
Fock Space\label{subsec:Universal-Control}}

To demonstrate the efficacy of the instruction set, we demonstrate the
use of the approach to encode a qubit in a cavity either via generation
of effective Pauli gates 
or imposition of an effective Hubbard interaction in the Jaynes-Cumming
Hamiltonian.  In this sense, the techniques presented here are analogous to those in~\cite{liu2021constructing}, in that we  use our results to effectively truncate the quantum information to a two-dimensional subspace despite the fact that the natural dynamics of the systems causes the quantum information to leak from this space into the larger Hilbert space of the cavity.

%\subsection{Effective Pauli Gate Approach\label{subsec:Effective-Pauli-Gate}}

For universal control in the restricted $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Hilbert space, we generate three effective Pauli operators $\sigma_{\text{eff}}^{x}$,
$\sigma_{\text{eff}}^{y}$, and $\sigma_{\text{eff}}^{z}$ that produce
Pauli rotations in the lowest two modes of the cavity, with minimal leakage
to higher energy states. The form of the effective Pauli operators
is determined by expressing the standard Pauli operators
\begin{align}
\sigma^{x} & =\left(\begin{array}{cc}
0 & 1\\
1 & 0
\end{array}\right),\\
\sigma^{y} & =\left(\begin{array}{cc}
0 & -i\\
i & 0
\end{array}\right),\\
\sigma^{z} & =\left(\begin{array}{cc}
1 & 0\\
0 & -1
\end{array}\right),
\end{align}
in terms of creation and annihilation operators truncated to the first
two Fock states
\begin{align}
\hat{a}_{\text{eff}}^{\dagger} & =\left(\begin{array}{cc}
0 & 0\\
1 & 0
\end{array}\right),\\
\hat{a}_{\text{eff}} & =\left(\begin{array}{cc}
0 & 1\\
0 & 0
\end{array}\right),\\
\hat{n}_{\text{eff}} & =\hat{a}^{\dagger}\hat{a}_{\text{eff}}=\left(\begin{array}{cc}
0 & 0\\
0 & 1
\end{array}\right),
\end{align}
which yields
\begin{align}
\sigma_{\text{eff}}^{x} & =\hat{a}_{\text{eff}}^{\dagger}+\hat{a}_{\text{eff}},\\
\sigma_{\text{eff}}^{y} & =i\left(\hat{a}_{\text{eff}}^{\dagger}-\hat{a}_{\text{eff}}\right),\\
\sigma_{\text{eff}}^{z} & =I-2\hat{a}_{\text{eff}}^{\dagger}\hat{a}_{\text{eff}}.
\end{align}
To reduce leakage into higher energy states, we ensure the creation
operator $\hat{a}_{\text{eff}}^{\dagger}$ only acts on the ground
state $\left|0\right>$ and the annihilation operator $\hat{a}_{\text{eff}}$
only acts on the first excited state $\left|1\right>$ with the projector
\begin{align}
\hat{P}_{0} & \approx I-\hat{n}\\
 & =\begin{cases}
0 & n=1\\
1 & n=0
\end{cases},
\end{align}
where $n$ is the number of photons in the cavity and where only the
$\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
states are populated. Since the operator is a projector, it obeys
the relation
\begin{equation}
\hat{P}_{0}^{2}=\hat{P}_{0},
\end{equation}
such that the effective Pauli gates are
\begin{align}
\sigma_{\text{eff}}^{x} & =\hat{a}_{\text{eff}}^{\dagger}\hat{P}_{0}+\hat{P}_{0}\hat{a}_{\text{eff}}\\
 & \approx\hat{a}^{\dagger}\left(I-\hat{n}\right)+\left(I-\hat{n}\right)\hat{a},\\
\sigma_{\text{eff}}^{y} & =i\left(\hat{a}_{\text{eff}}^{\dagger}\hat{P}_{0}-\hat{P}_{0}\hat{a}_{\text{eff}}\right)\\
 & \approx i\left(\hat{a}^{\dagger}\left(I-\hat{n}\right)-\left(I-\hat{n}\right)\hat{a}\right),\\
\sigma_{\text{eff}}^{z} & =I-2\hat{a}_{\text{eff}}^{\dagger}\hat{P}_{0}^{2}\hat{a}_{\text{eff}}\\
 & \approx I-2\hat{a}^{\dagger}\left(I-\hat{n}\right)\hat{a}.
\end{align}


\subsubsection*{Pauli X Gate}

Consider the infinitesimal $\sigma_{x}$-rotation gate in the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space 
\begin{align}
U_{\text{span}\left\{ 0,1\right\} ,x} & =e^{i\lambda^{2}\sigma_{\text{eff}}^{x}\sigma^{z}}\\
 & =e^{i\lambda^{2}\left(\hat{a}^{\dagger}\left(1-\hat{n}\right)+\left(1-\hat{n}\right)\hat{a}\right)\sigma^{z}}.
\end{align}
Expression of the exponent in terms of phase-space operators Eq.~\ref{eq:NumbertoPhaseSpace},
Eq.~\ref{eq:CreationOperatortoPhaseSpace}, and Eq.~\ref{eq:AnnihilationOperatortoPhaseSpace}
gives 
\begin{gather}
i\lambda^{2}\left(\hat{a}^{\dagger}\left(I-\hat{n}\right)+\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}\nonumber \\
=i\lambda^{2}\left(2\hat{x}-\left\{ \hat{x},\hat{n}\right\} +i\left[\hat{p},\hat{n}\right]\right)\sigma^{z}.
\end{gather}
The gate is therefore given by a Trotter-Suzuki decomposition 
% Eq.~\ref{eq:TrotterFirstOrder}
of three terms: $\exp\left(\left[\hat{A}_{1},\hat{B}_{1}\right]\lambda^{2}\right)=\exp\left(-i\lambda^{2}\left\{ \hat{x},\hat{n}\right\} \sigma^{z}\right)$,
$\exp\left(\left[\hat{A}_{2},\hat{B}_{2}\right]\lambda^{2}\right)=\exp\left(-\lambda^{2}\left[\hat{p},\hat{n}\right]\sigma^{z}\right)$,
and $\exp\left(2i\lambda^{2}\hat{x}\sigma^{z}\right)$. 

The terms consisting of exponentials of commutators are decomposed via BCH. The relationship between the commutator and anticommutator required for the first term is given by the Pauli anticommutation-commutation relation
\begin{align}
-i\left\{ \hat{x},\hat{n}\right\} \sigma^{z} & =-i\left(i\left[i\hat{x}\sigma^{x},i\hat{n}\sigma^{y}\right]\right)\\
 & =\left[i\hat{x}\sigma^{x},i\hat{n}\sigma^{y}\right]\\
 & =\left[\hat{A}_{1},\hat{B}_{1}\right],
\end{align}
where $\hat{A}_{1}$ corresponds to a position displacement and $\hat{B}_{1}$
corresponds to the $y$-conditional rotation gate. The argument of
the second term is already in the form of a commutator, such that
\begin{align}
\left[\hat{A}_{2},\hat{B}_{2}\right] & =-\left[\hat{p},\hat{n}\right]\sigma^{z}\\
 & =\left[i\hat{p},i\hat{n}\sigma^{z}\right],
\end{align}
where $\hat{A}_{2}$ corresponds to an \emph{unconditional} momentum boost,
and $\hat{B}_{2}$ corresponds to the $z$-conditional rotation gate.
Lastly, the third term already belongs to the instruction set architecture
and needs no further decomposition. 

The infinitesimal $\sigma_{x}$-rotation gate in the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space is therefore composed of a product of nine rotation and displacement gates or 21 displacement gates.

\subsubsection*{Pauli Y Gate}

The infinitesimal $\sigma_{y}$-rotation gate in the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space is determined analogously 
\begin{align}
U_{\text{span}\left\{ 0,1\right\} ,y} & =e^{i\lambda^{2}\sigma_{\text{eff}}^{y}\sigma^{z}}\\
 & =e^{-\lambda^{2}\left(\hat{a}^{\dagger}\left(I-\hat{n}\right)+\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}}.
\end{align}
Expression of the argument of the exponent in terms of phase-space
variables Eq.~\ref{eq:CreationOperatortoPhaseSpace} and Eq.~\ref{eq:AnnihilationOperatortoPhaseSpace}
yields 
\begin{gather}
-\lambda^{2}\left(\hat{a}^{\dagger}\left(I-\hat{n}\right)-\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}\nonumber \\
=-\lambda^{2}\left(-2i\hat{p}+\left[\hat{n},\hat{x}\right]+i\left\{ \hat{n},\hat{p}\right\} \right)\sigma^{z},
\end{gather}
such that the gate is a Trotter-Suzuki decomposition 
% Eq.~\ref{eq:TrotterFirstOrder}
of $\exp\left(\left[\hat{A}_{1},\hat{B}_{1}\right]\lambda^{2}\right)=\exp\left(-\lambda^{2}\left[n,x\right]\sigma^{z}\right)$,
$\exp\left(\left[\hat{A}_{2},\hat{B}_{2}\lambda^{2}\right]\right)=\exp\left(-i\lambda^{2}\left\{ p,n\right\} \sigma^{z}\right)$,
and $\exp\left(2i\lambda^{2}p\sigma^{z}\right)$. 

Again, the first two exponential terms are decomposed via the BCH
formula 
% Eq.~\ref{eq:BCHFormula}
. The first commutator is 
\begin{align}
\left[\hat{A}_{1},\hat{B}_{1}\right] & =\left[\hat{n},\hat{x}\right]\sigma^{z}\\
 & =\left[\hat{n}\sigma^{z},\hat{x}\right],
\end{align}
where the exponent of $\hat{A}_{1}$ is a $z$-conditional rotation
gate and the exponent of $\hat{B}_{1}$ is an unconditional position
displacement. The second commutator is given by the Pauli anticommutation-commutation
relation:
\begin{align}
i\left\{ p,n\right\} \sigma^{z} & =i\left(i\left[ip\sigma^{x},in\sigma^{y}\right]\right)\\
 & =\left[ip\sigma^{x},in\sigma^{y}\right]\\
 & =\left[\hat{A}_{2},\hat{B}_{2}\right],
\end{align}
where the exponent of $\hat{A}_{2}$ corresponds to a conditional
momentum shift and the exponent of $\hat{B}_{2}$ is a $y$-conditional
rotation gate.

The infinitesimal $\sigma_{y}$-rotation gate in the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space therefore has a lower bound gate depth of nine displacement and rotation gates or 21 in displacement gates.

\subsubsection*{Pauli Z Gate}

The infinitesimal $\sigma_{z}$-rotation gate in the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space is 
\begin{align}
U_{\text{span}\left\{ 0,1\right\} ,z} & =e^{i\lambda^{2}\sigma_{\text{eff}}^{z}\sigma^{z}}\\
 & =e^{-\lambda^{2}\left(I-2\hat{a}^{\dagger}\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}},
\end{align}
whose argument in terms of ladder operators is
\begin{gather}
-\lambda^{2}\left(I-2\hat{a}^{\dagger}\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}\nonumber \\
=-\lambda^{2}\left(I-2\hat{a}^{\dagger}a+2\hat{a}^{\dagger}\hat{a}^{\dagger}\hat{a}\hat{a}\right)\sigma^{z},
\end{gather}
Given the ladder operator commutator Eq.~\ref{eq:CommutatorCreationAnnihilation},
\begin{equation}
\hat{a}^{\dagger}\hat{a}=\hat{a}\hat{a}^{\dagger}-I,
\end{equation}
the relationship between the fourth-order ladder operator term and
the number operator is
\begin{align}
\hat{a}^{\dagger}\hat{a}^{\dagger}\hat{a}\hat{a} & =\hat{a}^{\dagger}\left(\hat{a}\hat{a}^{\dagger}-I\right)\hat{a}\\
 & =\hat{a}^{\dagger}\hat{a}\hat{a}^{\dagger}\hat{a}-\hat{a}^{\dagger}\hat{a}\\
 & =\hat{n}^{2}-\hat{n}.
\end{align}
The argument of the exponential in terms of number operators is then
\begin{equation}
-\lambda^{2}\left(I-2\hat{a}^{\dagger}\left(I-\hat{n}\right)\hat{a}\right)\sigma^{z}=-\lambda^{2}\left(I-4\hat{n}+2\hat{n}^{2}\right)\sigma^{z}.
\end{equation}
The argument is further simplified given that the state is restricted
to the first two cavity modes, as for $n=0$ and $n=1$ the quantity
$\hat{n}^{2}-\hat{n}$ is zero, as follows:
\begin{gather}
-\lambda^{2}\left(I-4\hat{n}+2\hat{n}^{2}\right)\sigma^{z}\nonumber \\
=-\lambda^{2}\left(I-2n\right)\sigma^{z}.
\end{gather}
The gate is therefore directly synthesized as the product of the qubit
rotation gate $\exp\left(-\lambda^{2}\sigma^{z}\right)$ and the $z$-conditional
rotation gate $\exp\left(2\lambda^{2}\hat{n}\sigma^{z}\right)$ for
a lower bound gate depth of two.

\subsection{Effective Hubbard-lattice interaction approach\label{subsec:Effective-Hubbard-Lattice}}

An alternative scheme to encode a qubit in a cavity with the instruction set is to map the three-dimensional quantum electrodynamics
(3D cQED) system to a qubit by imposing an $\hat{n}\left(\hat{n}-1\right)$
anharmonicity into the Jaynes-Cummings Hamiltonian that describes
the system. The anharmonicity term increases the energy gap between
higher levels of the oscillator to effectively restrict propagation
to the $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
Fock space in which there is universal control.

Consider the standard Jaynes-Cummings Hamiltonian 
\begin{equation}
\hat{H}_{\text{JC}}=\omega_{R}\hat{a}^{\dagger}\hat{a}+\frac{\omega_{Q}}{2}\sigma^{z}+g\left(\hat{a}\sigma^{+}+\hat{a}^{\dagger}\sigma^{-}\right),
\end{equation}
where $\omega_{R}$ is the cavity frequency, $\omega_{Q}$ is the
qubit frequency, and $g$ is the coupling parameter. Inclusion of
the simulated $\hat{n}\left(\hat{n}-1\right)$ anharmonicity of strength
$\Gamma$ yields 
\begin{equation}
\hat{H}_{\text{an}}=\omega_{R}\hat{a}^{\dagger}\hat{a}+\Gamma\hat{n}(\hat{n}-1)+\frac{\omega_{Q}}{2}\sigma^{z}+g(\hat{a}\sigma^{+}+\hat{a}^{\dagger}\sigma^{-}),
\end{equation}
and the system is switched between states $\left|0\right\rangle $ and
$\left|1\right\rangle $ with a weak time-$t$-dependent drive of
strength $\Omega$ at the resonance frequency $\omega_{R}$, as follows:
\begin{equation}
\hat{H}_{\text{drive}}\left(t\right)=\Omega e^{i\omega_{R}t}\hat{a}^{\dagger}+\Omega^{\star}e^{-i\omega_{R}t}\hat{a}.
\end{equation}
Synthesis of a propagator of the form $\exp\left(i\lambda^{2}\hat{n}\left(\hat{n}-1\right)\right)$
is then sufficient to employ the native 3D cQED system as a qubit.
Note the choice of $\lambda$ for practical implementation must take
into account both the time step and the fact the BCH decomposition
yields a square root in the exponential argument. The required propagator
is a Trotter-Suzuki decomposition 
% Eq.~(\ref{eq:TrotterFirstOrder})
of $\exp\left(\left[\hat{A},\hat{B}\right]\lambda^{2}\right)=\exp(i\lambda^{2}\hat{n}^{2}\sigma^{z})$
and $\exp(-i\lambda^{2}\hat{n}\sigma^{z})$. 

The first term is synthesized according to the BCH formula 
% Eq.~ (\ref{eq:BCHFormula})
with a commutator determined by the Pauli commutation relation Eq.~(\ref{eq:PauliCommutator})
as follows:
\begin{align}
\left[\hat{A},\hat{B}\right] & =i\hat{n}^{2}\sigma^{z}\\
 & =i\hat{n}^{2}\left(-\frac{i}{2}\left[\sigma^{x},\sigma^{y}\right]\right)\\
 & =\left[\frac{1}{\sqrt{2}}\hat{n}\sigma^{x},\frac{1}{\sqrt{2}}\hat{n}\sigma^{y}\right],
\end{align}
where $\hat{A}$ and $\hat{B}$ correspond to $x$-conditional and
$y$-conditional rotations, respectively. The second term is a $z$-conditional
rotation gate.

The resulting anharmonicity gate therefore has a gate depth of lower
bound five displacement and rotation gates or 45 displacement gates.

\section{Fermi-Hubbard Lattice Dynamics\label{sec:Fermi-Hubbard-Lattice-Dynamics}}

To further demonstrate the power of the  ISA, we employ the
approach to simulate fermionic dynamics on bosonic 3D cQED systems.
We consider the Fermi-Hubbard lattice Hamiltonian

\begin{align}
\hat{H}_{\text{FH}} & =\hat{T}_{\text{FH}}+\hat{V}_{\text{FH}},\label{eq:FermiHubbardHamiltonian}\\
\hat{T}_{\text{FH}} & =-J\sum_{i,\sigma}\hat{c}_{i,\sigma}^{\dagger}\hat{c}_{i+1,\sigma}+\hat{c}_{i+1,\sigma}^{\dagger}\hat{c}_{i,\sigma},\\
\hat{V}_{\text{FH}} & =U\sum_{i}\hat{n}_{i,\uparrow}\hat{n}_{i,\downarrow}.
\end{align}
The kinetic energy term $\hat{T}_{\text{FH}}$ describes the nearest-neighbor
interaction for hopping of a single spin between two sites with hopping
parameter $J$ and spin $\sigma$ given annihilation operators $\left\{ \hat{c}_{j,\sigma}\right\} $
and creation operators $\left\{ \hat{c}_{j,\sigma}^{\dagger}\right\} $
for sites $\left\{ j\right\} $. The potential energy term $\hat{V}_{\text{FH}}$
describes the same-site interaction, which gives the energetic unfavorability
of a spin up $\uparrow$ and spin down $\downarrow$ coexisting on
the same site $i$, where $\hat{n}_{j,\sigma}$ gives the number of
spin $\sigma$ particles on site $j$. According to fermion statistics,
no more than a single particle of a given spin can exist on a single
site.

Each cavity of the 3D cQED system represents either a spin up or spin
down particle on a single lattice site, for direct comparison to the
qubit-based schemes of refs.~\cite{Kivlichan.2018.110501,arute2020observation,Cade.2020.235122}.
Each cavity is connected to the cavity that represents the same site
of opposite spin to facilitate computation of the potential energy
$\hat{V}_{\text{FH}}$, as well as to cavities of the same spin on neighboring
sites to facilitate computation of the kinetic energy $\hat{T}_{\text{FH}}$.
Cavities are also connected along Jordan-Wigner strings to take into
account fermionic statistics. 

The $\text{\ensuremath{\left|0\right\rangle }}$ cavity state represents
absence of a spin and the $\text{\ensuremath{\left|1\right\rangle }}$
state represents presence of a spin. Within each cavity, only the
states in $\text{span}\left\{ \text{\ensuremath{\left|0\right\rangle }},\text{\ensuremath{\left|1\right\rangle }}\right\} $
are considered, as in Section~(\ref{subsec:Universal-Control}), which
prevents leakage into unphysical high-energy cavity states. At the
end of each operation, the cavity state must be in either the $\text{\ensuremath{\left|0\right\rangle }}$
or $\text{\ensuremath{\left|1\right\rangle }}$ state and the transmon
state must also be in the ground state $\text{\ensuremath{\left|g\right\rangle }}$,
which provides an error syndrome and therefore a degree of error detection 
not employed in qubit-based representations of the Fermi-Hubbard lattice.

Propagation of any combination of up spins and down spins is simulated
with three two-cavity gates. The first two gates -- the same-site
and hopping gates -- are defined as the propagator of the same-site
and hopping Hamiltonians, respectively. The same-site term of the
Hamiltonian for site $i$ is 
\begin{equation}
\hat{H}_{\text{same}}=U\hat{n}_{i,\uparrow}\hat{n}_{i,\downarrow}.
\end{equation}
This term is zero if only one spin is on a site and $U$ if both spins
are on the same site, which gives the diagonal Hamiltonian in the
reduced $4\times4$ Hilbert space
\begin{equation}
\hat{H}_{\text{same}}=\left[\begin{array}{cccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & U
\end{array}\right]
\end{equation}
and the diagonal propagator $U_{\text{same}}=\text{e}^{-\text{i}\hat{H}_{\text{same}}\tau}$
\begin{equation}
U_{\text{same}}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & \text{e}^{-\text{i}U\tau}
\end{array}\right].
\end{equation}
This gate is recognized as the conditional cross-Kerr interaction
of 3D cQED systems and equivalently a controlled-phase (CPHASE) gate
in the reduced subspace $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $.
The hopping term of the Hamiltonian for each $\sigma$ spin in sites
$i,\left(i+1\right)$ is 
\begin{align}
H_{\text{hop}} & =-J\left(\hat{c}_{i,\sigma}^{\dagger}\hat{c}_{i+1,\sigma}+\hat{c}_{i+1,\sigma}^{\dagger}\hat{c}_{i,\sigma}\right)\\
 & =-J\left(\hat{c}_{i,\sigma}^{\dagger}\hat{c}_{i+1,\sigma}-\hat{c}_{i,\sigma}\hat{c}_{i+1,\sigma}^{\dagger}\right),
\end{align}
where the latter expression employs the commutator relationship of
the annihilation and creation operators. The hopping Hamiltonian for
the specified mapping is then the off-diagonal matrix 
\begin{equation}
H_{\text{hop}}=\left[\begin{array}{cccc}
0 & 0 & 0 & 0\\
0 & 0 & -t & 0\\
0 & -t & 0 & 0\\
0 & 0 & 0 & 0
\end{array}\right],
\end{equation}
which gives the hopping propagator $U_{\text{hop}}=\text{e}^{-\text{i}H_{\text{hop}}\tau}$
\begin{align}
U_{\text{hop}} & =\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & \cos\left(t\tau\right) & i\sin\left(t\tau\right) & 0\\
0 & i\sin\left(t\tau\right) & \cos\left(t\tau\right) & 0\\
0 & 0 & 0 & 1
\end{array}\right],
\end{align}
which is recognized as a conditional controlled-phase beam splitter
restricted to $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
in bosonic systems and a Givens or iSWAP-like gate in the reduced
$\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
subspace \cite{Cade.2020.235122,arute2020observation}. The final
gate of the three-gate set incorporates the fermionic statistics of
the spins via the fermionic SWAP (FSWAP) gate \cite{Kivlichan.2018.110501,Cade.2020.235122}.
The content of each cavity is swapped with one of its neighbors with
inclusion of a phase where both spins are present in neighboring cavities
as follows
\begin{equation}
U_{\text{FSWAP}}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & -1
\end{array}\right],
\end{equation}
which is recognized as the product of a conditional rotation gate
and a beam-splitter on 3D cQED systems.

Finally, initial states are prepared by the universal set of gates
in $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
detailed in Section~\ref{subsec:Universal-Control}.

\subsection{Conditional cross-Kerr (CPHASE) gate}

We consider the infinitesimal conditional cross-Kerr gate
\begin{equation}
U_{\text{cross-Kerr}}=e^{i\lambda^{2}\hat{n}_{1}\hat{n}_{2}\sigma_{z}},
\end{equation}
which is also employed in GKP codes encoded in 3D cQED systems \cite{royer2022encoding}. 

The argument is expressed in terms of a commutator according to the
Pauli commutation relation Eq.~\ref{eq:PauliCommutator}, as follows:
\begin{align}
\left[A,B\right] & \lambda^{2}=i\lambda^{2}\hat{n}_{1}\hat{n}_{2}\sigma_{z}\\
 & =i\lambda^{2}\hat{n}_{1}\hat{n}_{2}\left(-\frac{i}{2}\left[\sigma^{x},\sigma^{y}\right]\right)\\
 & =\left[\frac{1}{\sqrt{2}}\hat{n}_{1}\sigma^{x},\frac{1}{\sqrt{2}}\hat{n}_{2}\sigma^{y}\right]\lambda^{2},
\end{align}
where $\hat{A}$ corresponds to an $x$-conditional rotation gate
and $B$ corresponds to a $y$-conditional rotation gate.

The resulting gate features a lower bound gate depth of four displacement and rotation gates or 16 displacement gates.

\subsection{ \texorpdfstring{$\text{Span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $}{}
conditional beam splitter gate}

In order to generate a $\text{span}\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} $
that operates only when $\hat{n}_{1}\hat{n}_{2}\ne1$ (\emph{i.e.},
$1-\hat{n}_{1}\hat{n}_{2}=0$), we formulate the infinitesimal conditional
(controlled-phase) beam-splitter gate
\begin{equation}
U_{\text{cond. beam}}=e^{-i\lambda^{2}\left(\hat{a}_{1}^{\dagger}\hat{a}_{2}+\hat{a}_{1}\hat{a}_{2}^{\dagger}\right)\left(1-\hat{n}_{1}\hat{n}_{2}\right)\sigma^{z}},
\end{equation}
which is decomposed via the Trotter-Suzuki decomposition 
% Eq.~\ref{eq:TrotterFirstOrder}
in terms of $\exp\left(-i\lambda^{2}\left(\hat{a}_{1}^{\dagger}\hat{a}_{2}+\hat{a}_{1}\hat{a}_{2}^{\dagger}\right)\sigma^{z}\right)$
and $\exp\left(i\lambda^{2}\left(\hat{a}_{1}^{\dagger}\hat{a}_{2}+\hat{a}_{1}\hat{a}_{2}^{\dagger}\right)\left(\hat{n}_{1}\hat{n}_{2}\right)\sigma^{z}\right)$.
The first term is the conditional beam splitter $U_{\text{beam split.}}$
Eq.~\ref{subsec:Conditional-(Controlled-Phase)-Beam-Splitter} and
the second term is decomposed via BCH 
% Eq.~\ref{eq:BCHFormula}
as
follows:

Given the expression of the number operator in terms of the phase-space
operators Eq.~\ref{eq:NumbertoPhaseSpace}, the argument of the second
exponential operator is 
\begin{gather}
i\lambda^{2}\left(\hat{a}_{1}^{\dagger}\hat{a}_{2}+\hat{a}_{1}\hat{a}_{2}^{\dagger}\right)\hat{n}_{1}\hat{n}_{2}\sigma^{z}\nonumber \\
=i\lambda^{2}\left(2\left(\hat{x}_{1}\hat{x}_{2}+\hat{p}_{1}\hat{p}_{2}\right)\right)\hat{n}_{1}\hat{n}_{2}\sigma^{z}.
\end{gather}
The term is then expressed as a Trotter decomposition of $\exp\left(\left[\hat{A}_{1},\hat{B}_{1}\right]\lambda^{2}\right)=\exp\left(2i\lambda^{2}\hat{x}_{1}\hat{x}_{2}\hat{n}_{1}\hat{n}_{2}\sigma^{z}\right)$
and $\exp\left(\left[\hat{A}_{2},\hat{B}_{2}\right]\lambda^{2}\right)=\exp\left(2i\lambda^{2}\hat{p}_{1}\hat{p}_{2}\hat{n}_{1}\hat{n}_{2}\sigma^{z}\right)$. 

The first commutator is given by the Pauli commutation relation Eq.~\ref{eq:PauliCommutator}
\begin{align}
\left[\hat{A}_{1},\hat{B}_{1}\right] & =2i\hat{x}_{1}\hat{x}_{2}\hat{n}_{1}\hat{n}_{2}\sigma^{z}\\
 & =2i\hat{x}_{1}\hat{x}_{2}\hat{n}_{1}\hat{n}_{2}\left(-\frac{i}{2}\left[\sigma^{x},\sigma^{y}\right]\right)\\
 & =\left[\hat{x}_{1}\hat{n}_{1}\sigma^{x},\hat{x}_{2}\hat{n}_{2}\sigma^{y}\right].
\end{align}

The $\hat{A}_{1}$ term is determined by a Trotter decomposition such that
\begin{align}
\hat{A}_{1} & =\frac{1}{2}\left\{ \hat{x}_{1},\hat{n}_{1}\right\} \sigma^{x}+\frac{1}{2}\left[\hat{x}_{1},\hat{n}_{1}\right]\sigma^{x}\\
 & =\hat{A}_{1a}+\hat{A}_{1b},
\end{align}
where according to the anticommutator to commutator relation $\hat{A}_{1a}$
is given by the BCH formula with 
\begin{align}
\left[\hat{A}_{1a^{\prime}},\hat{B}_{1a^{\prime}}\right] & =\frac{1}{2}\left\{ \hat{x}_{1},\hat{n}_{1}\right\} \sigma^{x}\\
 & =\frac{i}{2}\left[i\hat{x}_{1}\sigma^{y},i\hat{n}_{1}\sigma^{z}\right]\\
 & =\left[-\frac{1}{\sqrt{2}}\hat{x}_{1}\sigma^{y},-\frac{1}{\sqrt{2}}\hat{n}_{1}\sigma^{z}\right],
\end{align}
where $\hat{B}_{1a^{\prime}}$ is a $z$-conditional rotation gate.
Distribution of terms yields $\hat{A}_{1b}$ as 
\begin{equation}
\left[\hat{A}_{1b^{\prime}},\hat{B}_{1b^{\prime}}\right]=\left[\frac{1}{\sqrt{2}}\hat{x}_{1},\frac{1}{\sqrt{2}}\hat{n}_{1}\sigma^{x}\right],
\end{equation}
where $B_{1b^{\prime}}$ is an $x$-conditional rotation gate. 

According to the same procedure,
\begin{align}
\hat{B}_{1} & =\frac{1}{2}\left\{ \hat{x}_{2},\hat{n}_{2}\right\} \sigma^{y}+\frac{1}{2}\left[\hat{x}_{2},\hat{n}_{2}\right]\sigma^{y}\\
 & =\hat{B}_{1a}+\hat{B}_{1b},
\end{align}
where $\hat{B}_{1a}$ is given by
\begin{align}
\left[\hat{A}_{1a^{\prime\prime}},\hat{B}_{1a^{\prime\prime}}\right] & =\frac{1}{2}\left\{ \hat{x}_{2},\hat{n}_{2}\right\} \sigma^{y}\\
 & =\frac{i}{2}\left[i\hat{x}_{2}\sigma^{z},i\hat{n}_{1}\sigma^{x}\right]\\
 & =\left[-\frac{1}{\sqrt{2}}\hat{x}_{2}\sigma^{z},-\frac{1}{\sqrt{2}}\hat{n}_{2}\sigma^{x}\right],
\end{align}
with $B_{1a^{\prime\prime}}$ an $x$-conditional rotation, and $B_{1b}$
is given by 
\begin{equation}
\left[\hat{A}_{1b^{\prime\prime}},\hat{B}_{1b^{\prime\prime}}\right]=\left[\frac{1}{\sqrt{2}}\hat{x}_{2},\frac{1}{\sqrt{2}}\hat{n}_{2}\sigma^{y}\right],
\end{equation}
where $B_{1b^{\prime\prime}}$ is a $y$-conditional rotation gate.
The second term follows analogously with the position $x$ replaced
by the momentum $p$.

\subsection{Conditional FSWAP gate}

The FSWAP gate follows immediately from the conditional
cross-Kerr gate detailed above and a complete beam-splitter gate (or
conditional beam-splitter gate detailed above) as 
\begin{equation}
U_{\text{FSWAP}}=U_{\text{cond. Kerr}}U_{\text{cond. beam}}.
\end{equation}



% \end{appendices}