








\section{Preliminaries}
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{ImagesAndPrograms/QubitQumode20240725.png}
    \caption{A Qubit-Qumode Hilbert space. On the left, the qubit is a typical 2 dimensional Hilbert space. On the right, the qumode consists of Fock states of value at most $\Lambda = 4$. }
    \label{fig:device-picture}
\end{figure}

{In this section, we introduce the hybrid \qq~architecture we operate on and the matrix product formulas we will use.}

We aim to provide a generic toolbox to build unitary transformations on hybrid \qq~devices. Such devices are common in quantum systems, spanning circuit quantum electrodynamics (superconducting qubits coupled to microwave photons) to ion-trap quantum computing (for which the mechanical modes of oscillation are coupled to atomic qubits).  The challenge is that fundamentally different insights are needed to compile unitaries in the hybrid setting over typical binary-based approaches.

We review the mathematical properties of \qumode~quantum mechanics that are needed to understand the basic operations considered for the ISA architecture that we consider.  
Specifically, we present an analytic instruction set architecture (ISA) based on the Lie--Trotter--Suzuki (Trotter) and Baker--Campbell--Hausdorff (BCH) decompositions for decomposition of gates of the form $U=e^{i\hat{H}\sigma^{j}}$, where $\hat{H}$ is a Hermitian
operator composed of phase-space operators and Pauli gates. Before jumping into the specific details of our gate operations, we need to review the basics of qumode quantum mechanics as well as the mathematical results needed to use these qumode operations to compile a given unitary transformation.

\subsection{A hybrid \qq~device}
We first produce a mathematical description of a \qumode, then describe operations which can be performed on the \qumode~and qubit (\cref{fig:device-picture}).
Qumodes store bosonic states. Bosons are are already commonplace in quantum computing experiments: photons (energy quanta of the electromagnetic field) are used in photonic chips, cavity QED, and hybrid circuit QED, while phonons (quanta of mechanical vibrations) are used to couple ion-spin qubits in ion traps. However, we are interested in using the \qumode~as an explicit computational resource, rather than as a conduit for entangling operations or source of noise. 



\subsubsection{Representing the qumode}
There are two different bases that are commonly used to describe the state of the qumode: 
\begin{enumerate}
    \item \textit{Phase-space representation}, where operators are written in terms of position ($\hat{x}$) and momentum ($\hat{p}$) operators
    \item \textit{Fock-space representation}, where operators are written in terms of \qumode~creation ($a^\dagger$) and annihilation ($a$) operators.
\end{enumerate}

In the phase-space representation, the computational basis corresponds to the strength of the electric field in the case of photons (or equivalently the position of a mechanical oscillator for vibrational systems). We refer to this with the operator $\hat{x}$ and we have that for any $x\in \mathbb{R}$, $\hat{x} \ket{x} = x \ket{x}$. We also use the corresponding operator for momentum $\hat{p}$.
This describes the magnetic field for a photonic system.  In practice, cutoffs are imposed on the values of the field and further discretization error on the gates and the outputs prevents arbitrary precision readout; however, for simplicity we ignore the latter issue in order to provide a simpler if less realistic computational model and ignore the issue that even when cutoffs are imposed the vector space does not strictly form a Hilbert space without also including spatial discretization.

In the Fock-space representation, we track the number of bosons (number of photons or the energy level of the harmonic oscillator for the vibrational case) in the computational basis.  In this representation the computational basis is defined to be an eigenvector of the boson number operator $\hat{n} \ket{n} = n \ket{n}$, where $\hat{n} = a^\dagger a$ is the number operator and $a$ and $a^\dagger$ add and remove a boson from the system, respectively.  Formally this spectrum is countably infinite, but after truncation it forms a finite-dimensional Hilbert space and thus can be thought of as a qudit.  For example, assuming a cutoff $\Lambda = 3$ on the boson number $\hat n$
\begin{align}
    P_3 a^\dagger P_3 = \begin{bmatrix}
    0 & 0 & 0 & 0 \\
    1 & 0 & 0 & 0 \\
    0 & \sqrt{2} & 0 & 0 \\
    0 & 0 & \sqrt{3} & 0 
    \end{bmatrix} \qquad P_3 a P_3 = \begin{bmatrix}
    0 & 1 & 0 & 0\\
    0 & 0 & \sqrt{2} & 0 \\
    0 & 0 & 0 & \sqrt{3} \\
    0 & 0 & 0 & 0
    \end{bmatrix}.
\end{align}
Here $P_\Lambda$ is the projector onto the subspace of the cavity containing at most $\Lambda$ photons
\begin{align}
    P_\Lambda : P_\Lambda \ket{n} = \begin{cases}
    \ket{n} & n \leq \Lambda \\
    0 & \textrm{otherwise}
    \end{cases}.
\end{align}

\change{Observe that this Hilbert space has dimension $\Gamma + 1$ corresponding to the Fock states from $\ket
0$ to $\ket{\Gamma}$.}  Truncation of the Hilbert space is required to provide error bounds, otherwise the remainder terms become undefined.
Provided that an appropriate cutoff is picked for the system, the discrepancies between the truncated and untruncated systems will often be negligible. For notational clarity, we assume a cutoff of $\Lambda$ for all further equations and assume the annihilation and creation operators implicitly have the projectors $P_\Lambda$.




To incorporate the qubit's state, we 
take the tensor product of the qubit and \qumode~Hilbert spaces, so that the state space is $ \mathcal{H}_2 \kron \mathcal{H}_{\Lambda + 1}$. This means that, for example, a computational basis state will be of the form $\ket{q} \kron \ket{m} $ where the state $\ket{q}$ here can be thought of as the union of the qubits in the system, and $\ket{m}$ represents a qumode state 
where the system is either in position $x=m$ for the phase-space encoding or has $m$ photons if the Fock-space encoding is used. 




\subsubsection{Representing operations and measurements via block encodings}
Depending on whether the qumode is described in Fock or phase space, there exist two pairs of complementary \qumode~operators. In Fock space, the operators are creation and annihilation operators $a^\dagger, a$; in phase-space, the operators are position and momentum $\hat{x}, \hat{p}$.

Our techniques can be applied in both spaces because
Fock and phase-space operators have the equivalencies
\begin{align}
    \hat{x} = \frac{1}{2} (a + a^\dagger) \qquad &\Leftrightarrow \qquad a = \hat{x} + i \hat{p} \label{eq:AnnihilationOperatortoPhaseSpace},\\
    \hat{p} = -\frac{i}{2} (a - a^\dagger) \qquad &\Leftrightarrow \qquad a^\dagger = \hat{x} - i \hat{p}, \label{eq:CreationOperatortoPhaseSpace}
\end{align}
and commutation relations
\begin{align}
    [\hat{x}, \hat{p}] &= \frac{i}{2} \label{eq:Commutatorxp}, \\
    [a, a^\dagger] &= 1 \label{eq:CommutatorCreationAnnihilation}.
\end{align}

To illustrate the \qq~ISA, we define three types of operations with examples:
\begin{enumerate}
    \item \textbf{Qubit-exclusive}: these include typical qubit gates like the \textit{Pauli} ($X, Y, Z$) gates, \change{ADDED below:}
    \begin{align}
        X = \begin{bmatrix}
            0 & 1 \\
            1 & 0
        \end{bmatrix}, \qquad Y = \begin{bmatrix}
            0 & -i \\
            i & 0
        \end{bmatrix}, \qquad \begin{bmatrix}
            1 & 0 \\
            0 & -1
        \end{bmatrix},
    \end{align}
    and \textit{Hadamard} ($H$) and \textit{phase} ($S$) gates
     \begin{align}
        H = \frac{1}{\sqrt{2}} \begin{bmatrix}
            1 & 1 \\
            1 & -1
        \end{bmatrix}, \qquad S = \begin{bmatrix}
            1 & 0 \\
            0 & i
        \end{bmatrix}.
    \end{align}
    \item \textbf{Qumode-exclusive}: we assume that linear optical operations (which are at most quadratic in the field operators) can be performed on the \qumode. This includes the \textit{displacement} operations $e^{ \alpha a^\dagger + \alpha^* a }$ for $\alpha \in \mathbb{C}$, \textit{phase delays} (or phase-space rotations) $e^{-i\alpha  a^\dagger a }$, and \textit{squeezing} operations $e^{\alpha (a^\dagger)^2 -\alpha^{*}a^2}$. Qumodes can also be entangled with other qumodes via \textit{beamsplitter} operations $e^{(\alpha a^\dagger b - \alpha^{*}a b^{\dagger})}$ where $b$ is the creation operator acting on a different \qumode. In this work, we primarily focus on the single-\qumode~case.  The multi-mode case with beamsplitters is discussed in \cite{C2QA_ISA,C2QA_LGT} but without the rigorous convergence bounds provided in the present work.
    \item \textbf{Qumode-qubit entangling}: there are several entangling operations between individual \qumodes~and qubits that widely appear in the circuit QED literature. Two common operations we consider are the \textit{conditional displacement} operation \cite{eickbusch2021fast} $e^{-i\sigma^z \otimes (\alpha a^\dagger + \alpha a)}$ and the \textit{Selective Number-dependent Arbitrary Phase} (SNAP) gate \cite{SNAP-PhysRevLett.115.137002} $e^{-i  \sigma^z \otimes \sum_n\alpha_n \hat P_n }$, where $\hat P_n=|n\rangle\langle n|$ is the projector onto the $n$th Fock state.
\end{enumerate}
Note that, for clarity, we use uppercase letters for qubit-exclusive gates and lowercase letters for \qumode-exclusive or \qumode-qubit gates. For example, we use $S, X, H$ for qubit-exclusive gates and $\sigma^i$ notation for Paulis in hybrid gates.




Our compilation strategy describes operations in terms of qubit-exclusive gates and the $\mathcal{S}_1$ gate, a primitive \qumode-qubit entangling gate (\cref{defn:SX}). $\mathcal{S}_1$ is a useful ``block-encoding" primitive to compose complex gates because it embeds a first-order Fock operator in the off-diagonal blocks. ``Block-encoded" matrices refer to how ``blocks"/submatrices of a larger matrix can be expressed as an existing matrix. Block encodings are frequently used in quantum algorithm design \cite{martyn2021grand, camps_approximate_2020}.


\begin{define}[$\mathcal{S}_1$ primitive gate]\label{defn:SX}
For any $t>0$ and any positive integer cutoff $\Lambda$, we define $\mathcal{S}_1$ to be the unitary acting on the Hilbert space $\mathcal{H}_2 \otimes \mathcal{H}_{\Lambda + 1}$ that has the following representation as a block matrix
\begin{align}
    \mathcal{S}_1 = \exp \left(it \begin{bmatrix}
    0 & a^{\dagger} \\
    a & 0
    \end{bmatrix} \right).
\end{align}
Note that $\mathcal{S}_1$ can itself be decomposed into conditional displacements (see \cref{obtaining_s1}) or implemented directly via OCT \cite{PhysRevX.4.041010,PhysRevA.91.043846,Rosenblum2018,Rosenblum2023}. Also note that the block encoding can also be expressed as the sum of qumode-qubit tensor products
\begin{align}\label{eq:JC}
    \begin{bmatrix}
    0 &  a^\dagger  \\
     a & 0
    \end{bmatrix} = \ket{0}\bra{1} \kron a^\dagger  + \ket{1}\bra{0} \kron  a.
\end{align}
\end{define}

We also consider the broader class of block-encoded Hamiltonians:
\begin{define}[Block encodings]
For a qumode operator $A$ acting upon $\mathcal{H}_{\Lambda + 1}$, we denote the joint block-encoded Hamiltonian to be
    \begin{align}\label{eq:blockencodedmatrix}
        \mathcal{B}_A = \begin{bmatrix}
            0 & A \\
            A^\dagger & 0
        \end{bmatrix},
    \end{align}
so that the subscript is the upper right block and the lower left block is the transpose and complex conjugate to preserve Hermiticity. I.e., $\mathcal{B}_A$ is Hermitian for any $A$, and thus is a suitable Hamiltonian. Note that $\mathcal{B}_A$ can describe a \qq~Hamiltonian acting on $\mathcal{H}_2 \otimes \mathcal{H}_{\Lambda + 1}$. Furthermore, if $A$ Hermitian, $\exp it \mathcal{B}_A = \exp{it\sigma^x A}$, otherwise it corresponds to $\exp{it( \ket{0}\bra{1} \kron A  + \ket{1}\bra{0} \kron A^\dagger)}$.
\end{define}

In this block-encoding notation, observe that $\mathcal{S}_1 = \exp it  \mathcal{B}_{a^\dagger}$. 
Throughout this work, we consider increasingly exotic $A$ matrices that can be created via polynomials of qumode operators.

Finally, to simplify notation, we oftentimes write tensor products implicitly as follows
\begin{align}
    \sigma^i \otimes M = \sigma^i M.
\end{align}
This notation is used extensively to abbreviate the action of $\sigma^i$  on $\mathcal{H}_2$ and $M$ (which is  comprised of qumode operators) on $\mathcal{H}_{\Lambda + 1}$.

We further assume that the qubit can be measured directly, but the \qumode~can only be measured by entangling it with a qubit and reading out the state of the qubit to obtain a single classical bit of information about the qumode state \cite{C2QA_ISA}.

\subsection{Matrix product formulas}
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{ImagesAndPrograms/3-Trotter-BCH.png}
    \caption{A visualization of the Trotter and BCH formulas. (a) A Trotterized formula that approximates $e^{(M + N) t}$ via $e^{M t}, e^{N t}$ evaluated at $t'$. (b) A BCH product formula which approximates $e^{[M, N] t^2}$ via $e^{M t}, e^{N t}$ evaluated at $t, -t$.}
    \label{fig:product-formula-visualization}
\end{figure}

Matrix product formulas describe the behavior of products of matrix exponentials (namely $e^A e^B$). These formulas are well-known in Hamiltonian simulation~\cite{childs2021theory,berry2007efficient,su2021fault} and are used to approximate a discretized version of the time evolution operator $e^{-iHt}$ using the Trotter formula. Thus, they often have rigorous error bounds that describe how $e^{-iHt}$ can be approximated given constituent $e^{-iH_jt}$. In our setting, $e^{-iHt}$ will be the operation we seek to implement using the $\mathcal{S}_1$ gate. 

As stated above, we use two product formulas: the BCH formula and the Trotter formula (\cref{fig:product-formula-visualization}). The BCH formula is used to create a commutator (or anticommutator) of operators. The Trotter formula is used to add these commutators and anticommutators together. We introduce the informal theorems below:
\begin{theorem}[Informal Trotter theorem from \cite{berry2007efficient}]
    Suppose we may implement $e^{M \lambda}$ and $e^{N \lambda}$ for arbitrary $\lambda \in \mathbb{R}$ and anti-Hermitian $M, N$. Then, a $p^\text{th}$ order Trotter formula has the error scaling
    \begin{align}
        \trotter_{2p}(M\lambda, N \lambda) & = e^{(A+B)\lambda} + \mathcal{O}((\norm{M + N} \lambda)^{2p + 1}),
    \end{align}
    requiring no more than $4 \cdot 5^{ p -1}$ exponentials.
\end{theorem}

\begin{theorem}[Informal BCH theorem from \cite{Childs_2013}]\label{thm:BCH}
    Suppose we can implement the operators $e^{M \lambda}, e^{N \lambda}$ for $\lambda \in \mathbb{R}$ and anti-Hermitian $M, N$. Then, a BCH formula of order $p$ has the error scaling
    \begin{align}
        \bch_p(M\lambda, N \lambda) &= e^{[M, N] \lambda^2} + \mathcal{O}((\max (\norm{M}, \norm{N}) \lambda)^{2p + 1}), 
    \end{align}
    requiring no more than $8 \cdot 6^{ p -1}$ exponentials.
\end{theorem}

These product formulas are defined recursively and are comprised of sequences of $e^{M \lambda}, e^{N \lambda}$ gates evaluated at varying values of $\lambda$. While the sequences may be long, as there is an exponential dependence on $p$, it is important to note that these error bounds are known to be loose, so experimental implementations may benefit from improved accuracy. 

Finally, note in our notation these formulas take the logarithm matrix and output sequences of matrix exponentials which approximate a desired exponential. Additionally, note that Hamiltonians can be `conjugated', i.e. we can transform a Hamiltonian from $H$ to $U H U^\dagger$ for any unitary $U$ via:
\begin{align}
    U \exp (-i t H) U^\dagger = \exp (-it U H U^\dagger) 
\end{align}
Conjugation, Trotter, and BCH give us immense flexibility for the Hamiltonian manipulations which can be achieved (\cref{tab:all-formulas}). 



 

