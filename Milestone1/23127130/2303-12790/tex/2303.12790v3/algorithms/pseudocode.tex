\section{Pseudocodes}

The pseudocode for training is given in \cref{alg: train code} and testing in \cref{alg: test code} for \method.
\vspace{-1mm}
% ***********************
% Training code
\begin{algorithm}[!ht]
\caption{Training phase}
\label{alg: train code}
\begin{lstlisting}[language=python]
def train(images,density_maps,gt_counts):
    """
        images: [B, H, W, 3]
        density_maps: [B, H, W]
        gt_counts: [B,]
    """
    
    # Density scaling
    density_maps = (2*scale*density_maps-1)

    # Corrupt density_maps
    t = randint(0,T) # time step
    eps = normal(mean=0,std=1)  # noise: [B,H,W]
    crpt_density_maps = 
      diffusion_process(density_maps,eps,t)
    
    # Estimate noise and encoder-decoder features
    eps_pred, feats =
      denoising_network(images,crpt_density_maps,t)

    # Estimate crowd count
    count_est = counting_decoder(feats)
       
    # Compute denoising network loss
    loss = 
      l_hybrid(eps_pred, eps) + 
      count_scale * l1_loss(count_est,gt_count)
    
    return loss
\end{lstlisting}
% \vspace{-2mm}

\end{algorithm}
\vspace{-2.5mm}

% ***********************

% Testing code
\begin{algorithm}[!b]
\caption{Testing phase}
\label{alg: test code}
\begin{lstlisting}[language=python]
def testing(images, realizations):
    """
    images: [B, H, W, 3]
    realizations: N
    """
    
    # Encode image features
    feats = image_encoder(images)
    
    # noisy density maps: [B, H, W]
    density_pred = normal(mean=0, std=1)
    
    # uniform sample step size
    times = reversed(
    linespace(diffusion_steps, sampling_steps))

    # Perform DDIM sampling
    for t in times:
        # Predict noise from density_pred
        eps_hat = denoising_network(images, noisy_density, t)
        # Compute posterior of noisy density
        density_pred = q_posterior(noisy_density, eps, t)

    # Detect head locations
    locations = contours(density_pred) # [B, N, *, 2]

    # Perform crowd map fusion: [B, *, 2]
    final_locations = crowd_map_fusion(locations)

  # Compute crowd count    
  return count(final_locations) # [B, ]
\end{lstlisting}
% \vspace{-2mm}

\end{algorithm}
\newpage
