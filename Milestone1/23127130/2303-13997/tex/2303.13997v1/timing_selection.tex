According to Figure~\ref{fig:delayResult}, weight values exhibit different
timing characteristics.  Even for the same weight, different activation
transitions lead to different delays.  To identify weight values and
activations with small delays,
%to achieve supply voltage scaling and thus power reduction, 
the timing of each weight value with respect to activation transitions and
partial sum transitions in the MAC unit should be analyzed.  Two types of
timing analysis methods, dynamic timing analysis and static timing analysis,
are available for this task.  The former is conducted by applying input
transitions into a circuit and evaluating the delays of correspondingly
triggered paths, while the latter evaluates the delay statically without
considering the corresponding triggered paths.  The latter is conservative
since the delays of some paths that are not activated are also included and the
clock frequency of the circuit may be unnecessarily lowered.

To evaluate the timing profile of a weight value, an intuitive idea is to fix
the weight input into the MAC unit and then apply dynamic timing analysis with
all the transition patterns of activations and partial sums to simulate the
unit.  The challenge of this method is that the number of combined transitions
of activations and partial sums is huge, as described in
Section~\ref{sec:power}.  Simulating the delay of the MAC unit with respect to
all these combinations is thus time-consuming. 

To reduce the runtime of timing analysis, we separate the timing analysis of the
multiplier and adder in the MAC unit.  Specifically,  we apply static timing
analysis on the adder to avoid the consideration of input
transitions, because the number of inputs to the adder is very large.  On the
other hand, the multiplier is evaluated using accurate dynamic timing analysis,
%This separate timing analysis does not cause considerable timing inaccuracy 
since the delay of the multiplier usually dominates the delay of the MAC unit
and this delay can be lowered by filtering out some weight values and
activation values. 
 
%e.g.,
%$2^{(8+22)*2}=2^{60}\approx10^{18}$ in a systolic array of size $64 \times 64$.
%this weight is first fixed into a MAC unit. 
%Afterwards, 
 


%Besides optimizing the power consumption of the accelerator directly, we also aim to reduce the effective worst-case delay of the MAC unit, which enables further power savings by supply voltage scaling. This is accomplished by excluding specific weights and activations which trigger comparatively large delays on the MAC unit. The first step towards this goal is to measure the delay for each weight and activation combination, which requires timing analysis of the MAC unit.

%There are two different types of timing analysis, static and dynamic. In static timing analysis, the circuit is first abstracted to a graph. Subsequently, the graph is analyzed for the longest path leading from an input to the output, with the path length corresponding to the delay. Due to this abstraction, static timing analysis is data-independent. While static timing analysis is fast to execute, it does not report accurate delay results, but instead upper-bounds of the actual worst-case delay inside a circuit.

%Dynamic timing analysis operates by simulating all timing events inside the circuit for a given sequence of input data. While the result is more accurate compared to static timing analysis, we receive the worst-case delay only for the given input data. Also, simulating the circuit is much more time-consuming.

%Neither a pure static nor dynamic timing analysis approach is desirable for our purpose. Since static timing analysis is data-independent, it cannot consider individual activation transitions in its delay calculation. On the other hand, relying only on dynamic timing analysis would be too time-consuming, since it would require simulating $2^{(8+22)\cdot2}=2^{44}$ transitions for each weight. Therefore, we approach the timing analysis problem by applying a divide-and-conquer scheme. First, we identify the delays for the individual subcomponents of the MAC unit, the multiplier and the adder. Subsequently, we combine the delay from both components to obtain the delay of the whole MAC unit.

%First we will analyze the multiplier. The multiplier receives the weight and activation as its input and outputs the product to the adder. Since multiplication is more complex than addition, the delay of the MAC unit is dominated by the multiplier. This justifies to use more effort on the multiplier to obtain precise delay results, meaning we resort to dynamic timing analysis for the multiplier. Dynamic timing analysis is performed by simulating the multiplier for the desired weight and activation transition and measuring the delay for each product output bit. To obtain the complete timing profile, we must measure the delay for all possible weight and activation transition combinations. After this analysis step, we have the delays of the multiplier component, as depicted in Figure~\ref{fig:timingMac}. Note that delays originate from switching events at the input. Because the weight stays fixed during timing analysis, there are no delay paths starting from the weight input.
%After we have obtained the partial delays from the multiplier and adder, 
%we must combine them to obtain the final delay of the MAC unit. 

To conduct dynamic timing analysis of the multiplier for a weight value, we
simulate the multiplier by fixing the weight input and enumerating the
$2^{8\times 2}$
possible transitions of the activations. Static timing analysis of the adder is
conducted by the built-in timing analyzer in Design Compiler from Synopsys.
%feed various of activation transitions into it and measure the delay for each
%product output bit.  
To incorporate the relation between the timing paths in the multiplier and the
adder, 
%To improve the accuracy of static timing analysis for the adder, 
we evaluate the largest delay starting from each individual bit of the product
to the output of the adder.  Afterwards, the largest delay of the MAC unit with
respect to the given weight value is calculated by adding the delays from the input activation to the
output bits of the multiplier and the  delays from the corresonding
product bits to the output of the adder.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{Fig/timing_analysis_example.pdf}
    \caption{Concept of timing analysis of the MAC unit.} %Overview of the timing analysis problem for the MAC unit with example inputs and delays.}
    \label{fig:timingMac}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{Fig/delay_optimization_example.pdf}
    \caption{Concept of weight and activation selection for delay reduction.}
    \label{fig:delayOptimization}
\end{figure}
Figure~\ref{fig:timingMac} illustrates the concept of timing analysis of the
MAC unit, where the quantized weight 1, the activation transition from quantized 1 to quantized 2,
and four product bits at the output of the multiplier are used as example.
With the dynamic timing analysis applied on the multiplier, the delays from the
input activation to Product[0] and Product[1] are 5 and 8, respectively.  The
delays to the other two product bits can be 0 if the combinational paths to
them are not activated by the activation transition.  With static timing analysis applied
on the adder, the delays from the output bits of the multiplier to the output
of the adder are 4, 3, 2, 1, respectively.  Assume the delay from the partial sum
to the output of the adder is 6 returned by static timing analysis.  The
largest delay of the MAC unit is thus $\max\{5+4, 8+3, 6\}=11$. 

%After the multiplication of the weight and activation, the adder computes the final result by adding the product to the partial sum. For the adder, we decide to use static timing analysis. As previously mentioned, the delay of the adder is considerably smaller than the multiplier, so some inaccuracy in its delay will not have a large impact on the total delay of the MAC unit. Furthermore, we determine the largest delay starting from each individual bit of the product input, as depicted in Figure~\ref{fig:timingMac}. This approach reflects the fact that the delay distance is not uniform but varies across the product bits. This strategy allows us to capture the delay of the adder much more accurately than denoting the whole adder with just its largest delay. Note that we need to conduct static timing analysis of the adder only once, since this is a data-independent approach and the results are valid for all possible product and partial sum combinations.



The timing analysis method described above is applied for each weight
individually.  After that, all the delays of weights with respect to activation
transitions can be obtained.  To select weights and activations with small
delays, we first set a delay threshold and iteratively remove weights or
activations that lead to delays larger than the given threshold.  The
iterations end until all the delays of the remaining weights and activations
are smaller than the given delay threshold.  Figure~\ref{fig:delayOptimization}
illustrates an example with the delay threshold set to 90.  In the first step,
we find the largest delay 99.  Since 99 is larger than the specified threshold,
we have to remove either $w_{1}$, $a_{5}$ or $a_{8}$ to exclude the
correponding combination. Since the removal of either $w_{1}$, $a_{5}$ or
$a_{8}$ also affects other combinations in
\figname~\ref{fig:delayOptimization}, it is difficult to find the optimal
sequence to remove the weigths and activaitons. Accordingly, we randomly remove
any of them and then remove the other combinations containing the removed
weight or activation in \figname~\ref{fig:delayOptimization}.  For example,
removing $w_{1}$ also leads to the removal of the first combination in
\figname~\ref{fig:delayOptimization}. To avoid local optimum, we execute this
process several times and choose which weight or
activation to remove in each step randomly.  The removal process ends when the maximum
delay of all the combinations is lower than the given threshold 90.  The result
is a set of weights and activations that satisfy the delay requirements. While
pruned weight values can be avoided during training of neural networks, the
filtering of activations needs to be integrated into the activation function
after each layer.

%Afterwards, we again search for the largest delay and
%compare it with the threshold.  Since 96 is still larger than 90, we have to
%remove it by pruning one of the corresponding weight or activations.  $a_{1}$
%has been chosen to be removed, which leads that all pairs of weights and
%activation transitions consisting $a_{1}$ are removed. 


%With the method described above, we can obtain a set of weights and activations
%that satisfy the delay requirements.  We execute the algorithm several times
%and select the set of weights and activations that can achieve the best
%inference accuracy. 

%These steps are iterated until the delay threshold is met. When the algorithm terminates, we obtain a set of remaining weight and activation values. Restricting a DNN to this set will guarantee that the given threshold is the effective maximum delay of the MAC unit. Because of the randomization of the pruning decision, running this algorithm multiple times will produce different sets of weights and activations. While all sets fulfill the targeted delay requirement, the effect on the accuracy performance when restricting a DNN to a particular set can vary among the possible solutions. For best accuracy performance, we propose to select the most balanced set. To quantify in numbers how balanced a set is, we calculate the average gap size between the remaining weights and activations, and select the set with the smallest average gap size.
