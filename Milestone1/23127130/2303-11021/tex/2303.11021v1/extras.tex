
% \section{Extensions}
% The central idea of this work is that recursive feasibility implies constraint satisfaction, as discussed in Proposition \ref{Prop:RF_RCS}. This idea was then used to compute the different components of the robust MPC controller in Sections \ref{Sec:SuffCond_Feedback} and \ref{Sec:AlgProp}.  

% In this section, two extensions which use Proposition \ref{Prop:RF_RCS} are highlighted. First, it is shown that the proposed method can recover recursive feasibility in the traditional sense, i.e., with a back-up controller which does not require optimization.
% Second, it is shown that as a result of Proposition \ref{Prop:RF_RCS}, the design of robustness in MPC controllers can be completely decoupled from the performance objectives and the prediction horizon. 

% \subsection{Additive disturbances}
% In this section, consider the situation that $B_p=0$, i.e, the dynamics \eqref{eq:Dynamics1} are not affected by the perturbation term $p_k$. Such an uncertainty structure has been well-studied in literature \cite{zanon2021similarity,alvarado2022tractable}, and constraint tightening is one of the most popular design strategy for robust MPC in this problem setting \cite{chisci2001systems,parsi2022computationally}. 

% The closed loop approach for robust MPC can be simplified in this setting, as $\Delta_k$ does not affect the system dynamics. Moreover, existing constraint tightening methods such as \cite{parsi2022computationally} always provide a feasible initial guess of $\mathbf{t}$ to solve \eqref{eq:OfflineOpt}. 

% As the design is independent of the vertices $\Delta^j$, the superscript $^j$ can be removed from the design criteria formulated in Sections \ref{Sec:RCS_RF} and \ref{Sec:SuffCond_Feedback}. Moreover, the feedback structure used for design is of the form 
% \begin{align}\label{eq:InputParameterization_dist}
%     \hat{u}_{i|k+1} &= \hat{u}_{i+1|k} + M_i B_w w_k , \: \forall i \in \mathbb{N}_{0}^{N-2} \nonumber\\
%     \hat{u}_{N-1|k+1}&= K \hat{x}_{N|k} + M_{N{-}1} B_w w_k,
% \end{align}
% which is based on the disturbance feedback parameterization proposed in \cite{goulart2006optimization} and used in \cite{parsi2022computationally}. Using the feedback \eqref{eq:InputParameterization_dist}, the offline optimization \eqref{eq:OfflineOpt} can be modified as
% \begin{subequations}\label{eq:OfflineOpt_dist}
% \begin{align}
%     \min_{\substack{\mathbf{t},  K, \alpha,  \\
%   \{\mathbf{u}^{i}\}_{i=1}^{2n_x}, \Lambda,  \mathbf{M}}} &\norm{\mathbf{t}}_2 - \mu \alpha \label{eq:OfflineOpt_dist1}\\
%     \text{s.t.} \qquad &     \Lambda \ge 0, \quad \alpha > 0, \quad t_0 > 0, \label{eq:OfflineOpt_dist2}\\
%         \Lambda \begin{bmatrix}
%         \mathbf{H}_{xu}\mathbf{S} & 0 \\
%         0 & H_w
%     \end{bmatrix} &= \mathbf{H}_{xu}\begin{bmatrix}
%         \mathbf{L}_K &   \mathbf{C}_M
%     \end{bmatrix}, \label{eq:OfflineOpt_dist3}\\
%     \Lambda \begin{bmatrix}
%         \mathbf{b}-\mathbf{t} \\ h_w
%     \end{bmatrix} &\le \mathbf{b}-\mathbf{t},  \label{eq:OfflineOpt_dist4}\\
%     \mathbf{H}_{xu} \mathbf{S} \mathbf{s}^{i}_{\alpha} &\le \mathbf{b-t}, \quad \forall i \in \mathbb{N}_{1}^{2n_x}, \label{eq:OfflineOpt_dist5}
% \end{align}
% \end{subequations}
% which has fewer optimization variables and constraints compared to \eqref{eq:OfflineOpt}. Despite the reduction in problem size, \eqref{eq:OfflineOpt_dist} is also a nonconvex optimization due to the bilinear constraints \eqref{eq:OfflineOpt_dist4}. As proposed in \ref{Rem:InGuess}, an initial guess can be computed using the optimized constraint tightening (OCT) method from \cite{parsi2022computationally}. 

% \begin{Lemma}
%     Let $\mathbf{t}_\text{OCT}$ be the constraint tightenings computed using OCT. Then, $\mathbf{t}_\text{OCT}$ is a feasible set of tightenings $\mathbf{t}$ in \eqref{eq:OfflineOpt_dist}. 
% \end{Lemma}

% \subsection{Design of generic safety constraints}
% The central idea of this work is that recursive feasibility implies constraint satisfaction, as discussed in Proposition \ref{Prop:RF_RCS}. This idea was then used to design the robust MPC controller in Sections \ref{Sec:SuffCond_Feedback} and \ref{Sec:AlgProp}.  However, Proposition \ref{Prop:RF_RCS} does not restrict the robust MPC optimization to be of the structure \eqref{eq:OnlOptProb_reg}. Instead, a flexible parameterization of the following form can be used
% \begin{subequations}\label{eq:OnlOptProb_flex}
%     \begin{align}
%         \min_{\hat{\mathbf{u}}_k}  \quad  \hat{x}_{N|k}\tr &Q_N \hat{x}_{N|k} + \textstyle\sum_{i=0}^{N-1}  \hat{x}_{i|k}\tr Q_x \hat{x}_{i|k} +  \hat{u}_{i|k}\tr Q_u \hat{u}_{i|k} \label{eq:OnlOptProb_flex1} \\
% 		\text{s.t.} \quad &\hat{x}_{k,0}=x_k,\\
%             A&\hat{x}_{i|k} + B\hat{u}_{i|k} = \hat{x}_{i|k+1}, \:  \forall i\in \mathbb{N}_{0}^{N-1},\label{eq:OnlOptProb_flex2}\\
%              % &\qquad \qquad \nonumber\\
%             &F\hat{x}_{0|k} + G\hat{u}_{0|k}  \le b - t_0,   \label{eq:OnlOptProb_flex3} \\
%             &Y_f\hat{x}_{0|k} \le z_f, \label{eq:OnlOptProb_flex4}
%     \end{align}
% \end{subequations}
% where $t_0, z_f$ and $Y_f$ must be chosen by the designer. The optimization \eqref{eq:OnlOptProb_flex} is a flexible parameterization, because  \eqref{eq:OnlOptProb_reg} can be recovered for a specific choice of $Y_f$ and $z_f$. The 

%  However, the constraint \eqref{eq:OnlOptProb_flex3} needs to be explicitly imposed, as $t_0\ge0$ is explicitly used in Proposition \ref{Prop:RF_RCS}. Thus, instead of computing $\mathbf{t}$ offline using \eqref{eq:OfflineOpt}, the offline design task is to compute $t_0, Y_f$ and $z_f$.  

% \ani{
% Why impose future constraints at all? Why not just use N=1? Refute each reason for N
% \begin{itemize}
%     \item Typically, a large N can increase ROA, but here, because the terminal set can be chosen quite large, we do not need to compensate with N. 
%     \item A large N also helps to show robust constraint satisfaction explicitly. We do this implicitly using recursive feasibility, so large N is not required
% \end{itemize}
% Situations where N helps the controller:
% \begin{itemize}
%     \item N is useful when predictions of disturbances are available. For example, prices of energy, or prediction of solar radiation/changing constraints in system variables.
    
%     \item we ultimately want to approximate value function. N allows to use simple terminal costs, and still gives good value function approximations.
% \end{itemize}

% Main point: You do not need N for robust MPC (or safety) reasons. N=1 is sufficient! 
% }
