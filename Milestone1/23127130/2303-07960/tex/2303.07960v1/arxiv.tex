\documentclass[a4paper,USenglish,cleveref,autoref,thm-restate]{oasics-v2021}
\hideOASIcs\def\subjclassHeading{}\ccsdesc{}\global\renewcommand\ccsdesc[2][100]{}
\nolinenumbers
\bibliographystyle{plainurl}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{amsfonts}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes,snakes}
\usepackage{url}
\usepackage{xcolor}
\usepackage{xspace}

\newcommand{\cI}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\cJ}{\ensuremath{\mathcal{J}}\xspace}
\newcommand{\cK}{\ensuremath{\mathcal{K}}\xspace}
\newcommand{\cT}{\ensuremath{\mathcal{T}}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}}\xspace}

\definecolor{defblue}{rgb}{0.121,0.47,0.705}\let\emph\relax\DeclareTextFontCommand{\emph}{\color{defblue}\em}

\graphicspath{{figures/}}

\newcommand{\PQ}{PQ}
\newcommand{\PQP}{P}
\newcommand{\PQQ}{Q}
\newcommand{\MPQ}{MPQ}

\newcommand{\ie}{i.e.}
\newcommand{\eg}{e.g.}


\title{Coloring and Recognizing Directed Interval Graphs}

\author{Grzegorz Gutowski}{Theoretical Computer Science Department, Faculty of Mathematics and Computer Science, Jagiellonian University, Krak\'ow, Poland}{}{https://orcid.org/0000-0003-3313-1237}{partially supported by the National Science Center of Poland under grant no.\ 2019/35/B/ST6/02472.}
\author{Konstanty Junosza-Szaniawski}{Warsaw University of Technology, Warsaw, Poland}{}{0000-0003-0352-8583}{}
\author{Felix Klesen}{Universit\"at W\"urzburg, W\"urzburg, Germany}{}{0000-0003-1136-5673}{}
\author{Pawe\l~Rz\k{a}\.zewski}{Warsaw University of Technology, Warsaw, Poland \and Institute of Informatics, University of Warsaw, Warsaw, Poland}{}{0000-0001-7696-3848}{}
\author{Alexander~Wolff}{Universit\"at W\"urzburg, W\"urzburg, Germany}{}{0000-0001-5872-718X}{}
\author{Johannes~Zink}{Universit\"at W\"urzburg, W\"urzburg, Germany}{}{0000-0002-7398-718X}{}
\authorrunning{G.~Gutowski, K.~Junosza-Szaniawski, F.~Klesen, P.~Rz\k{a}\.zewski, A. Wolff, and J.~Zink}

\ccsdesc[500]{Mathematics of computing $\rightarrow$ Discrete mathematics $\rightarrow$ Graph Theory}
\keywords{Interval Graphs, Mixed Graphs, Graph Coloring}

\begin{document}

\maketitle

\begin{abstract}
  A \emph{mixed interval graph} is an interval graph that has, for 
  every pair of intersecting intervals, either an arc (directed
  arbitrarily) or an (undirected) edge.  We are interested in mixed
  interval graphs where the type of connection of two vertices is
  determined by geometry.  In a proper coloring of a mixed interval
  graph $G$, an interval~$u$ receives a lower (different) color than
  an interval~$v$ if $G$ contains arc $(u,v)$ (edge $\{u,v\}$).
  
  We introduce a new natural class of mixed interval graphs, which we
  call \emph{containment interval graphs}.  In such a graph, there is
  an arc~$(u,v)$ if interval~$u$ contains interval~$v$,
  and there is an edge $\{u,v\}$ if $u$ and $v$ overlap.  We show that
  these graphs can
  be recognized in polynomial time, that coloring them
  with the minimum number of colors is NP-hard, and that there is a
  2-approximation algorithm for coloring.

  For coloring general mixed interval graphs, we present a
  $\min \{\omega(G), \lambda(G) \}$-appro\-xi\-ma\-tion algorithm,
  where $\omega(G)$ is the size of a largest clique and $\lambda(G)$ is the length of a longest induced directed path in $G$.
  For the subclass of \emph{bidirectional interval graphs} (introduced
  recently), we show that optimal coloring is NP-hard.
\end{abstract}

\section{Introduction}

In a geometric intersection graph, the vertices represent geometric
objects, and two vertices are adjacent if and only if the
corresponding objects intersect.  For example, \emph{interval graphs}
are the intersection graphs of intervals on the real line.  These
graphs are well understood: interval graphs are \emph{chordal} and can
thus be colored optimally (that is, with the least number of colors)
in polynomial time.  In other words, given an interval graph~$G$, its
\emph{chromatic number} $\chi(G)$ can be computed efficiently.

The notion of coloring can be adapted to directed graphs where an arc
$(u,v)$ means that that the color of~$u$ must be smaller than that
of~$v$.  Clearly, such a coloring can only exist if the given graph is
acyclic.  Given a directed acyclic graph, its chromatic number can be
computed efficiently (via topological sorting).

A generalization of both undirected and directed graphs are
\emph{mixed graphs} that have edges and arcs.
A \emph{proper coloring} of a mixed graph~$G$ is a function
$f \colon \cI \to \NN$ such that, for any distinct vertices~$u$
and~$v$ of~$G$, the following two conditions hold:
\begin{enumerate}
\item if there is an edge $\{u,v\}$, then $f(u) \neq f(v)$, and
\item if there is an arc $(u,v)$, then $f(u) < f(v)$.
\end{enumerate}
The concept of mixed graphs was introduced by Sotskov and
Tanaev~\cite{SotskovT76} and reintroduced by Hansen, Kuplinsky, and de
Werra~\cite{HansenKW97} in the context of proper colorings of mixed
graphs.  Coloring of mixed graphs was used to model problems in
scheduling with precedence constraints; see a survey by
Sotskov~\cite{Sotskov20}.  The problem is NP-hard even for bipartite
planar graphs~\cite{RiesW08} but admits efficient algorithms for
trees~\cite{FurmanczykKZ08Trees} and series-parallel
graphs~\cite{FurmanczykKZ08SP}.

In this paper, we study \emph{mixed interval graphs}, that is, mixed graphs
whose vertices correspond to intervals.  If two intervals intersect,
the corresponding vertices are connected either by an edge or by an
arc (in one of the two directions).  We are particularly interested in
subclasses of mixed interval graphs where the type of connection of
two vertices is determined by geometry, that is, by the relative
position of the two corresponding intervals.

For example, Gutowski et al.~\cite{gmrswz-cmdig-GD22} have introduced
\emph{directional interval graphs}, where there is an edge between two
intervals that are contained in each other and there is an arc between
every two overlapping intervals, directed towards the interval that
starts and ends to the right.
They also introduced
\emph{bidirectional interval graphs} where each interval is either
\emph{left-going} or \emph{right-going}.  For left-going intervals,
the arcs are defined as in directional interval graphs.  For
right-going intervals, the symmetric definition applies.  Moreover,
two intervals are connected by an edge if they are contained in each
other or if they overlap but go in different directions.
Coloring such graphs has applications in routing edges in layered
orthogonal graph drawing according to the so-called Sugiyama
framework~\cite{stt-mvuhss-TSMC81}; the colors correspond to the
tracks for routing the edges~\cite{zwbw-ldugg-CGTA22}.  Hence,
coloring an auxiliary graph with fewer colors yields a more compact
layout.  Gutowski et al.\ showed that directional interval
graphs can be recognized in quadratic time and that their chromatic
number can be computed efficiently whereas coloring general mixed
interval graphs optimally is NP-hard.  Clearly, the
optimal coloring algorithm for directional interval graphs yields a
2-approximation for coloring bidirectional interval
graphs~\cite{gmrswz-cmdig-GD22}.

\paragraph*{Our Contribution.}

We introduce a new natural class of mixed interval graphs, which we
call \emph{containment interval graphs}.  In such a graph, there is an
arc~$(u,v)$ if interval~$u$ contains interval~$v$, and there is an
edge $\{u,v\}$ if $u$ and $v$ overlap.  For a set~\cI of intervals,
let $C[\cI]$ be the containment  
interval graph induced by~\cI.  We show that these graphs can be
recognized in polynomial
time (\cref{sec:recognition-containment}), that
coloring them optimally is NP-hard
(\cref{sec:coloring-containment-hard}), and that for every set~\cI of
intervals, it holds that $\chi(C[\cI]) \le 2\omega(C[\cI])-1$, that is,
$C[\cI]$ can be colored with fewer than  twice as many colors as the size
of the largest clique in~$C[\cI]$
(\cref{sec:two-approx-coloring-containment}).  Our constructive proof
yields a 2-approximation algorithm for coloring containment interval
graphs.

Then we prove that, for the class of bidirectional interval graphs,
optimal coloring is NP-hard (\cref{sec:bidirectional-NP-hard}).
Finally, we show that, for any mixed interval graph~$G$ without
directed cycles, it holds that
$\chi(G) \leq \omega(G) \cdot \lambda(G)$, where $\lambda(G)$ denotes
the length of a longest induced
directed path in~$G$ (\cref{sec:coloring-general}).  Since
$\chi(G) \ge \max \{\omega(G), \lambda(G)\}$,
our constructive proof for the upper bound yields a
$\min \{\omega(G), \lambda(G) \}$-approximation algorithm.
The upper bound is asymptotically tight in the worst case.

\cref{tab:results} gives an overview over known and new results
concerning the above-mentioned subclasses of mixed interval graphs.
Given a positive integer $k$, we use $[k]$ as shorthand for the set
$\{1, 2, \dots, k\}$.
When we visualize a graph coloring corresponding to a set of intervals,
we use horizontal tracks to indicate the color.
Recall that a \emph{proper} interval graph is an interval graph that
has a representation where no interval is contained in another interval.

For a mixed interval graph~$G$, the \emph{underlying undirected graph}
of~$G$, denoted by $U(G)$, has an edge for every edge or arc of~$G$.
Note that testing whether a given graph~$G$ is a mixed interval graph
is the same as testing whether $U(G)$ is an interval graph, which
takes linear time~\cite{LuekerB79}.

\begin{table}[tb]
  \centering
  \caption{Known and new results concerning subclasses of mixed
    interval graphs.  The time complexities refer to a given set of
    $n$ intervals with $m$ pairwise intersections. (We use T, P, and C
    as shorthand for Theorem, Proposition, Corollary, respectively.)}
  \label{tab:results}

  \smallskip
  
  \begin{tabular}{@{}l@{~~}c@{~}c@{\quad}c@{~}c@{\quad}c@{~}c@{\quad}c@{~}c@{\quad}c@{~}c@{}}
    \toprule
    Mixed interval & \multicolumn{8}{c@{\quad}}{Coloring}
                   & \multicolumn{2}{c@{}}{Recognition} \\
    graph class    & \multicolumn{2}{c@{\quad}}{complexity}
                   & \multicolumn{2}{c@{\quad}}{lower bd.}
                   & \multicolumn{2}{c@{\quad}}{upper bd.}
                   & \multicolumn{2}{c@{\quad}}{approx.} & \\
    \midrule
    containment    & NP-hard & T\ref{thm:containment-NP-hard}
                   & $2\omega{-}1$ & P\ref{prop:containment-two-omega}
                   & $2\omega{-}1$ & T\ref{thm:containment-two-omega}
                   & 2 & C\ref{cor:containment-two-approx}
                   & $O(nm)$ & T\ref{thm:recognition} \\
    directional    & $O(n \log n)$ & \cite{gmrswz-cmdig-GD22}
                   & & & & & 1 & \cite{gmrswz-cmdig-GD22}
                   & $O(n^2)$ & \cite{gmrswz-cmdig-GD22} \\
    bidirectional  & NP-hard & T\ref{thm:bidirectional-NP-hard}
                   & & & & & 2 & \cite{gmrswz-cmdig-GD22}
                   & \multicolumn{2}{c@{}}{open} \\
    general        & NP-hard & \cite{gmrswz-cmdig-GD22}
                   & $\lambda\omega/2$ & P\ref{prop:mixed-lower-bound}
                   & $\lambda\omega$ & T\ref{thm:mixed-upper-bound}
                   & $\min \{\omega, \lambda \}$ 
                   & T\ref{thm:mixed-upper-bound}
                   & $O(n{+}m)$ & \cite{LuekerB79} \\
    \bottomrule
  \end{tabular}
\end{table}

\section{Recognition of Containment Interval Graphs}
\label{sec:recognition-containment}

In this section we present a recognition algorithm for containment interval graphs.
Given a mixed graph~$G$, our algorithm decides whether~$G$ is a containment interval graph.
If it is, the algorithm additionally constructs a set~\cI of intervals representing~$G$, \ie, with $C[\cI]$ isomorphic with~$G$.
The algorithm works in two phases.
The first phase uses heavily the concept of a \PQ-tree, that will be defined shortly.
The algorithm carefully selects a rotation of a \PQ-tree of the underlying undirected graph~$U(G)$ of~$G$.
This corresponds to fixing the order in which the maximal cliques appear in the interval representation of~$U(G)$.
This almost fixes the interval representation.
In the second phase, the endpoints of the intervals are perturbed so that the edges and arcs in~$G$ are represented correctly.

The main result of this section is the following theorem.
\begin{theorem}
	\label{thm:recognition}
	There is an algorithm that, given a mixed graph~$G$, decides whether~$G$ is a containment interval graph.
	The algorithm runs in $O(nm)$ time,
	where $n$ is the number of vertices of~$G$
	and $m$ is the number of edges of~$G$,
	and produces a containment representation of~$G$ if~$G$ admits one.
\end{theorem}

The algorithm runs in two 
phases that we introduce separately in \cref{sec:recognition-containment-rotation}, and \cref{sec:recognition-containment-endpoints}.
But first, in \cref{sec:recognition-containment-pq}, we introduce the necessary machinery of \PQ-trees.

\subsection{\MPQ-Trees}
\label{sec:recognition-containment-pq}
For a set of pairwise intersecting intervals on the real line, let the \emph{clique point} be the leftmost point on the real line that lies in all the intervals.
Given an interval representation of an interval graph~$G$, we get a linear order of the maximal cliques of~$G$ by their clique points from left to right.
Booth and Lueker~\cite{LuekerB79} showed that a graph~$G$ is an interval graph if and only if the maximal cliques of~$G$ admit a \emph{consecutive arrangement}, \ie, a linear order such that, for each vertex~$v$, all the maximal cliques containing~$v$ occur consecutively in the order.
They have also introduced a data structure called \PQ-tree that encodes all possible consecutive arrangements of~$G$.
We present our algorithm in terms of modified \PQ-trees (\MPQ-trees, for short) as described by Korte and M{\"o}hring~\cite{KorteM85,KorteM89}.

An \emph{\MPQ-tree}~$T$ of an interval graph~$G$ is a rooted, ordered tree with two types of nodes: \PQP-nodes and \PQQ-nodes, joined by links.
Each node can have any number of children and a set of at least two consecutive links joining a \PQQ-node~$x$ with some (but not all) of its children is called a \emph{segment} of~$x$.
Further, each vertex~$v$ in~$G$ is assigned either to a \PQP-node, or to a segment of some \PQQ-node.
Based on this assignment, we \emph{store}~$v$ in the links of~$T$.
If~$v$ is assigned to a \PQP-node~$x$, we store~$v$ in the link just above~$x$ in~$T$ (adding a dummy link above the root of~$T$).
If~$v$ is assigned to a segment of a \PQQ-node~$x$, we store~$v$ in each link of the segment.
For a link $\{x,y\}$, let~$S_{xy}$ denote the set of vertices stored in $\{x,y\}$.
We say that~$v$ is \emph{above} (\emph{below}, resp.) a node~$x$ if~$v$ is stored in any of the links on the upward path (in any of the links on some downward path, resp.) from~$x$ in~$T$.
We write $A^T_x$ ($B^T_x$, resp.) for the set of all vertices in~$G$ that are above (below, resp.) node~$x$.
Observe that every vertex assigned to a \PQP-node~$x$ is above~$x$, and every vertex assigned to a segment of a \PQQ-node~$x$ is below~$x$.

The \emph{frontier} of~$T$ is the sequence of the sets $A^T_x$, where~$x$ goes through all leaves in~$T$ in the order of~$T$.
Every node of~$T$ with at least two children is \emph{branching}.
Given a \PQQ-node~$x$ of an \MPQ-tree~$T$, there are two \emph{rotations of $x$}:
having the order of the children of $x$ as in the original tree~$T$,
and reversing the order of the children of~$x$.
For a \PQP-node~$x$ of an \MPQ-tree~$T$ with $k$ children, there are $k!$ rotations of~$x$, each obtained by a different permutation of the children of~$x$.
Every tree that is obtained from~$T$ by a sequence of rotations of nodes (\ie, obtained by arbitrarily permuting the order of the children of \PQP-nodes and reversing the orders of the children of some \PQQ-nodes) is a \emph{rotation} of~$T$.
The defining property of an \MPQ-tree~$T$ of a graph~$G$ is that each leaf~$x$ of~$T$ corresponds to a maximal clique $A^T_x$ of~$G$ and the frontiers of rotations of~$T$ correspond bijectively to the consecutive arrangements of~$G$.
Observe that any two vertices adjacent in~$G$ are stored in links that are connected by an upward path in~$T$.
We say that~$T$ \emph{agrees} with an interval representation \cI of~$G$ if the order of the maximal cliques of~$G$ given by their clique points in \cI from left to right is the same as in the frontier of~$T$.
We assume the following properties of an \MPQ-tree of~$T$ (see \cite{KorteM89}, Lemma~2.2):
\begin{itemize}
	\item For a \PQP-node~$x$ with children $y_1,\ldots,y_k$, for every $i=1,\ldots,k$,
	there is at least one vertex stored in link $\{x,y_i\}$ or below $y_i$, \ie, $S_{xy_i} \cup B^T_{y_i} \neq \emptyset$.
	\item For a \PQQ-node~$x$ with children $y_1,\ldots,y_k$, we have $k \geq 3$.
	Further, for $S_i=S_{xy_i}$, we have:
	\begin{itemize}
		\item $S_1 \cap S_k = \emptyset$,
		$B^T_{y_1} \neq \emptyset$, $B^T_{y_k} \neq \emptyset$,
		$S_{1} \subsetneq S_{2}$, $S_{k} \subsetneq S_{k-1}$,
		\item $(S_i \cap S_{i+1})\setminus S_1 \neq \emptyset$, $(S_{i-1} \cap S_{i})\setminus S_k \neq \emptyset$, for $i=2,\ldots,k-1$.
	\end{itemize}
  \item For every \PQP-node~$y$ being a child of a \PQP-node~$x$, we have that $x$ is branching.
  \item For every \PQP-node~$y$ being a child of a \PQP-node~$x$, there is at least one vertex assigned to $x$ or $y$.
\end{itemize}
As a consequence, we get that a node~$x$ is not branching, then it is either a leaf \PQP-node, or a \PQP-node with just one child which is a \PQQ-node.


\subsection{Rotating \MPQ-Tree}
\label{sec:recognition-containment-rotation}
\begin{lemma}\label{lem:recognition_rotation}
	There is an algorithm that, given a containment interval graph~$G$, constructs an \MPQ-tree~$T$ that agrees with some containment representation of~$G$.
	The running time of this algorithm is in $O(nm)$
	where $n$ is the number of vertices of~$G$
	and $m$ is the number of edges of~$G$.
\end{lemma}

\begin{proof}
	Given a mixed graph~$G$, if~$G$ is a containment interval graph, then clearly~$U(G)$ is an interval graph and we can construct an \MPQ-tree~$T$ of~$U(G)$ in linear time using the algorithm by Korte and M{\"o}hring~\cite{KorteM89}.
	Further, we have that arcs induce a transitive directed acyclic graph, \ie, for every arcs $(u,v)$ and $(v,w)$, there is an arc $(u,w)$ and there is no directed cycle in $G$.
	
	We call a rotation of~$T$ \emph{correct} if it agrees with some containment representation of~$G$.
	As we assume~$G$ to be a containment interval graph, there is at least one correct rotation of~$T$, and our goal is to find some correct rotation of~$T$.
	Our algorithm decides the rotation of every node in~$T$, one-by-one, in any top-down order, \ie, from the root to the leafs.
	Thus, when the rotation of a node~$x$ is to be decided, the rotation of every node above~$x$ is already decided.
	Our algorithm keeps the invariant that before, and after, deciding the rotation of every single node, there is at least one correct rotation of~$T$ that agrees with the rotation of the already decided nodes.
	The invariant is trivially satisfied before the first rotation, and because it is satisfied after the last rotation, the algorithm constructs a correct rotation of~$T$.
	
	From now on, we focus on choosing a rotation of a single branching node~$x$.
	Let $y_1,\ldots,y_k$ denote the children of~$x$.
	We have $k \geq 2$ ($k \geq 3$ when $x$ is a \PQQ-node), and for each $i=1,\ldots,k$, let $B_i=S_{xy_i} \cup B^T_{y_i}$.
	We have $\bigcup_{i=1}^k B_i = B^T_x \neq \emptyset$.
	
  Let $\tilde T$ denote the (unknown) set of all correct rotations of $T$ that agree with the rotations of the already decided nodes.
	We have, by our invariant, that $\tilde T \neq \emptyset$,
	and our goal is to choose a rotation of $x$ that agrees with at least one rotation in $\tilde T$.
	We call any such rotation of $x$ a \emph{correct rotation of $x$}.
	
	For each vertex~$v$ above~$x$ in~$T$, it is already decided if~$v$ is above some node of~$T$ that is to the left (right, resp.) of~$x$ in all rotations in~$\tilde T$ (as this depends only on the rotation of the nodes above~$x$ in~$T$).
	If it is, then there is a maximum clique that: includes $v$, does not include any of the vertices below~$x$, and in the frontier of every $T' \in \tilde T$ is strictly to the left (right, resp.) of all maximum cliques containing vertices below $x$.
	This means that in every interval representation that agrees with some $T' \in \tilde T$, the interval representing~$v$ contains a clique-point that is strictly to the left (right, resp.) of all left endpoints (right endpoints, resp.) of intervals representing vertices below~$x$ in~$T$.
	We call such~$v$ \emph{left-$1$-bound} (\emph{right-$1$-bound}, resp.).
	Observe, that a vertex can be both left-$1$-bound and right-$1$-bound.
	If a vertex is neither left-$1$-, nor right-$1$-bound, we call it \emph{$1$-unbound}.
	For $\ell \geq 2$, if $v$ is $(\ell-1)$-unbound and has an edge to an $(\ell-1)$-left-bound ($(\ell-1)$-right-bound, resp.) vertex~$u$, we call~$v$ $\ell$-right-bound ($\ell$-left-bound, resp.)
	If a vertex is $(\ell-1)$-unbound and neither left-$\ell$-, nor right-$\ell$-bound, we call it $\ell$-unbound.
	Lastly, a vertex is \emph{$\ell$-bound} if it is left-$\ell$-bound, or right-$\ell$-bound, \emph{bound} if it is $\ell$-bound for some $\ell\geq1$, and \emph{unbound} if it is $\ell$-unbound for every $\ell \geq 1$.
	
	Observe that the properties of \MPQ-trees guarantee that for a $1$-unbound vertex~$v$, we have that either~$x$ is a \PQP-node and~$v$ is assigned to~$x$, or~$x$ is a \PQQ-node with a parent \PQP-node~$z$, $x$ is the only child of $z$, and~$v$ is assigned to~$z$.
	
\begin{claim}
  For every $\ell\geq1$,
	for an $\ell$-bound vertex $v$ and an $\ell$-unbound vertex $w$,
  there is no arc $(w,v)$.
\end{claim}
\begin{claimproof}
	We prove this by induction on $\ell$.
	For $\ell=1$, every interval of a $1$-bound vertex contains a clique-point such that if any other interval contains it, the corresponding vertex is also $1$-bound.
	For $\ell>1$, let $u$ be an $(\ell-1)$-bound vertex that certifies that $v$ is $\ell$-bound.
  By the induction hypothesis, there is no arc $(w,u)$, and there is no edge $\{u,w\}$ as $w$ is $\ell$-unbound.
  Thus, there is an arc $(u,w)$.
  Assuming to the contrary the existence of an arc $(w,v)$, we get an arc $(u,v)$ from transitivity of arcs.
  This contradicts with the existence of the edge $\{u,v\}$.
\end{claimproof}
	
\begin{claim}
  Let $v_1,\ldots,v_\ell$ be a sequence of bound vertices such that: $v_i$ is left-$i$-bound, for $i$ odd; $v_i$ is right-$i$-bound, for $i$ even; there is an edge $\{v_i,v_{i+1}\}$, for $i=1,\ldots,\ell-1$.
	For every interval representation that agrees with some $T' \in \tilde T$, for every odd (even, resp.) $i>1$,
	the interval representing~$v_{i}$ contains the left (right, resp.) endpoint of the interval representing~$v_{i-1}$.
\end{claim}
\begin{claimproof}
	By the previous claim, we have that there is an arc $(v_i,v_j)$ for every
	$i \in [\ell -2]$ and $j \in \{i+2, \dots, \ell\}$.
	We prove this by induction on $\ell$.
	For $i=2$, $v_1$ is left-$1$-bound, while $v_2$ is not,
	and there is an edge $\{v_1,v_2\}$, which means that $v_2$ contains the right endpoint of~$v_1$.
	For $i>2$, $i$ odd, we have: $v_i$ is contained in $v_{i-2}$, $v_{i-1}$ contains the right endpoint of $v_{i-2}$ by induction, $v_{i}$ does not include the right endpoint of $v_{i-1}$, and the edge $\{v_{i-1},v_{i}\}$ means that $v_{i}$ contains the left endpoint of $v_{i-1}$.
	For $i$ even, the argument is symmetric.
\end{claimproof}
	
	Observe that, intuitively, it is ``natural'' for intervals representing vertices below a node to be contained in intervals representing vertices above it.
	Let $x$ be a node in $T$, $v \in A^T_x$, and $w \in B^T_x$.
	First notice that it is impossible to have an arc $(w,v)$, \ie, it is impossible for the interval of $w$ to contain the interval of $v$.
	As $x$ is a branching node, $w$ omits clique-points in the subtree of at least one child of $x$.
	These clique-points are contained in the interval of $v$.
	It is still possible to have an edge joining a vertex above $x$ and a vertex below $x$.
	Each such edge allows us to deduce some information on the correct rotations of $x$ and these edges are crucial to our algorithm.
	
	\paragraph*{Rotating \PQQ-nodes.}
	Observe that each vertex $w \in B^T_x$ is present in at most one of $B_1$ or $B_k$.
	(Recall that $B_i=S_{xy_i} \cup B^T_{y_i}$
	for $i \in [k]$ and $y_1, \dots, y_k$ are the children of $x$.)
	
	We shall prove that if there is at least one edge joining a vertex $w$ below $x$ and a bound vertex $v$ above $x$, then there is only one correct rotation of $x$.
	If $v$ is left-$\ell$-bound (right-$\ell$-bound, resp.) then $x$ needs to be rotated so that $w$ is in the last (first, resp.) child of $x$.
	Otherwise, when bound vertices above $x$ have arcs towards vertices below $x$, then both rotations are correct.

  Assume that there is an edge for some left-$\ell$-bound $v \in A^T_x$ and $w \in B^T_x$, and $\ell$ is minimum possible (\ie there are no edges joining $\ell'$-bound vertices and $B^T_x$ for $\ell' < \ell$).
  We prove that $w$ must be assigned to or below the last child of~$x$ in every $T' \in \tilde T$.
	For $\ell=1$, $v$ is left-$1$-bound, and the left endpoint of $v$ is to the left of the left endpoint of $w$ in every containment representation that agrees with some $T' \in \tilde T$.
	Thus, to realize the edge $\{v,w\}$, the right endpoint of $v$ is to the left of the right endpoint of $w$, which requires $w$ to be in the last child of $x$ (as otherwise there is some clique-point to the right of $w$ that is in $v$).
	For $\ell>1$, there is an edge $\{v,w\}$ for some left-$\ell$-bound $v$ and $w$ below $x$.
	Let $u$ be the right-$(\ell-1)$-bound vertex with edge $\{u,v\}$.
  We know that $v$ contains the left endpoint of $u$.
	Because $\ell$ is minimum, the interval of $u$ contains the interval of $w$.
	Thus, $v$ contains the left enpoint of $w$, and in order to have the right endpoint of $w$ after the right endpoint of $v$,
	we need $w$ to be assigned to or below the last child of~$x$.
	
	Similarly if $v$ is right-bound, then $w$ must be in the first child in every $T' \in \tilde T$.

	For the second part, we assume that there is an arc from every bound vertex above $x$ towards every vertex below $x$.
	We know that there is also an arc from every bound vertex to every unbound vertex.
	Let $B$ denote the set of all vertices that are either below $x$ or unbound.
	Observe that any containment representation of $G$ has all the endpoints of intervals representing vertices in $B$ strictly inside the intersection of intervals representing bound vertices.
	Thus, reversing the order of all endpoints of intervals representing vertices in $B$ gives another containment representation of $G$.
	This other representation has the order of clique-points represented by the subtree of $x$ reversed.
	Thus, both orientations of $x$ are correct and algorithm can choose any of them.
	
	\paragraph*{Rotating \PQP-nodes.}
	We are to choose the order of the children $y_1,\ldots,y_k$ of~$x$.
	Observe that in this case, for a \PQP-node, the sets $B_1, \dots, B_k$ are pairwise disjoint, and there are neither arcs, nor edges joining two different sets $B_i$ and $B_j$.

  Now, assume $k\geq3$, and observe that for each middle child, \ie, for each $i=2,3,\ldots,k-1$, for every vertex $v \in A^T_x$ above $x$, and every vertex $w \in B_i$ assigned to or below a middle child of $x$, we have an arc $(v,w)$.
	This is because there is at least one clique-point below the first, and below the last child of $x$.
	Children assigned to or below middle children are not in these cliques.
	Thus, an interval representing $v$ must contain an interval representing $w$.

  Now, we call a child $y_i$ of $x$ to be \emph{special}, if there is an edge joining a vertex $v \in A^T_x$ with a vertex $w \in B_i$.
  We already know that there are at most two special children of~$x$, as otherwise $\tilde T = \emptyset$.
	Observe that if $\sigma$ is a correct rotation of $x$, then any $\sigma'$ that is obtained from $\sigma$ by arbitrarily permuting the middle children is also a correct rotation of $x$.
	This is because in the rotation $\sigma$, we have that all middle children of $x$ are not special, and there are neither edges nor arcs between different sets $B_i$ and $B_j$.

	Now, let us fix a single permutation $\psi$ of the children of $x$ in which every special child of $x$ is either the first, or the last child.
	Let $\psi'$ denote the permutation obtained by reversing $\psi$.
	It is easy to see that if there is a correct rotation of $x$ at all, then also either $\psi$ or $\psi'$ is a correct rotation of $x$.
	Now, we can apply the same reasoning as for the \PQQ-nodes.
	If there is at least one edge joining a vertex $w$ below $x$ and a bound vertex $v$ above $x$, then only one of $\psi$, or $\psi'$ is a correct rotation of $x$.
	Otherwise, both $\psi$, and $\psi'$ are correct rotations of $x$.

  \begin{claim}
    The rotation of a single node can be decided in time $O(n+m)$.
  \end{claim}
\begin{claimproof}
  For a \PQQ-node we first need to decide which vertices are left/right-$\ell$-bound for different $\ell$.
  We can first calculate the set $A^T_x$.
  Then traverse the tree upwards and in each node mark left/right-$1$-bound vertices.
  Then use BFS to decide which vertices in $A^T_x$ are left/right-$\ell$-bound for different $\ell$.
  This can be easily done in $O(n+m)$ time.
  
  Then, for each edge that connects an $\ell$-bound vertex $v$ with a vertex $w$, we need to decide if $w \in B_1$ or $w \in B_2$.
  Observe that the queries ``whether a vertex $w$ is in $B_i$?'' can be answered in constant time (by looking at the index of the first/last clique in the frontier that includes $w$, and on the index of the first/last clique in the frontier that is below a node $y_i$).
  Thus, we can decide the rotation of a \PQQ-node in $O(n+m)$ time.


  For a \PQP-node, we first need to decide which children are special.
  For this we need to calculate the set $A^T_x$, and sets $B^i$, and then for each edge check if it makes some child special.
  This can be easily done in $O(n+m)$ time.
  The rest of analysis is the same as for a \PQQ-node.
\end{claimproof}

  As there are $n$ nodes to rotate, and by the previous claim, we conclude that the running time of the algorithm is $O(nm)$.
\end{proof}

\subsection{Perturbing Endpoints}
\label{sec:recognition-containment-endpoints}

\begin{lemma}\label{lem:recognition_endpoints}
	There is an algorithm that, given an \MPQ-tree~$T$ that agrees with
	some containment representation of a mixed graph~$G$, constructs a
	containment representation \cI of~$G$ such that $T$ agrees
	with \cI.
	The running time of this algorithm is in $O(nm)$
	where $n$ is the number of vertices of~$G$
	and $m$ is the number of edges of~$G$.
\end{lemma}
\begin{proof}
  The frontier of~$T$ fixes the left-to-right order of clique-points of maximal-cliques in~$G$.
  We need to respect that order, but still we have some freedom in choosing the exact locations of the endpoints.
  For any vertex~$v$, let $L_v$ ($R_v$, resp.) denote the index of the first (last, resp.) clique in the frontier of~$T$ that includes $v$.
  For any $L \ge 1$ ($R \ge 1$, resp.), the \emph{left-$L$-group} (\emph{right-$R$-group}, resp.) is the set of all vertices $v$ with $L_v=L$ ($R_v=R$, resp.).
  It is easy to see that any interval representation of~$U(G)$ that agrees with~$T$ can be stretched so that, for every vertex $v$, we have that
  the left endpoint $l_v$ of~$v$ is a real in the open interval $l_v \in (L_v-\frac{1}{2},L_v)$, and the right endpoint $r_v$ of~$v$ is in the interval $r_v \in (R_v,R_v+\frac{1}{2})$.
  Obviously, any representation satisfying these conditions on the locations of the endpoints agrees with~$T$.
  We are free to determine the order among endpoints in each group independently, so that the resulting intervals are a containment representation of~$G$.

  We will now collect different order constraints on the relative location of pairs of the endpoints.
	First, consider two adjacent vertices $u$ and $v$ with $L_u = L_v$, and $R_u < R_v$.
	As the right endpoints are in different right-groups, we have $r_u < r_v$.
	If there is the edge $\{u, v\}$, then, regarding the relative order, of the left endpoints, we need to have $l_u<l_v$.
  If there is the arc $(u, v)$, then we need to have $l_u>l_v$.
	The arc $(v, u)$ is impossible to realize.
	Similarly, if any of the left/right-groups is common for $u$ and $v$, but the other one is different, the relative order of endpoints is fixed.

  We have collected information about all pairs of vertices $u$ and $v$, except for these with $L_u = L_v$ and $R_u = R_v$.
  In this case,	if there is an arc $(u, v)$ or $(v, u)$, then again the relative order of left and right endpoints is fixed.
	
  Now, we assume that there is an edge $\{u,v\}$ and we want to say something about the relative order of the endpoints.
  Clearly, we have $l_u < l_v \iff r_u < r_v$, but we would like to decide the correct order.
  For a third vertex $w$, we say that $w$ \emph{behaves the same} (\emph{differently}, resp.) on $u$ and $v$, when $w$ is connected to $u$ with the same type of connection (edge, arc towards, arc from) as to $v$ (otherwise, resp.).
	Assume that there is a vertex~$w$ with $L_u = L_v = L_w$ and $R_u = R_v \ne R_w$ that behaves differently on $u$ and $v$.
  Note that we do not have two arcs in different directions joining $w$ with $u$ and $v$ as it would imply an arc between $u$ and $v$ by transitivity.
	Thus, we assume w.l.o.g.\ that $w$ is connected by an arc $(u, w)$ or $(w, u)$ with $u$, but with an edge $\{v, w\}$ with $v$.
	Then, the relative order of $u$ and $v$ is fixed because there is only one relative order of the three left endpoints that allows for this situation.
  Similarly for the case $L_u = L_v \ne L_w$ or $R_u = R_v = R_w$.

  For a pair of vertices $u$, $v$ with the edge $\{u,v\}$, $L_u=L_v$, and $R_u=R_v$,
  if the above rule gives us the relative order of their endpoints,
  we call such pair \emph{decided}.
  Otherwise, it is \emph{undecided}.
	While there are undecided pairs, we propagate the order of the decided pairs as follows.
	Consider a vertex~$w$ with $L_u = L_w$ and $R_u = R_w$
	that behaves differently on~$u$ and~$v$,
	\ie, there is an arc $(u, w)$ (or $(w, u)$) and an edge $\{v, w\}$
	(two arcs in different directions is not possible as argued before),
	and let $\{v, w\}$ be decided.
	Then, the relative orders of the endpoints of $v$ and $w$
	and the ones of $u$ and $w$ are fixed, which means
	that the relative orders of the endpoints of $u$ and $v$ follow.
	From now on the pair $u$, $v$ is also decided and we apply this procedure as long as it is possible.

  At this point, if there are some undecided pairs left, choose any vertex $u$ from an undecided pair, and let $U$ be the set of vertices reachable from $u$ by a path of undecided edges.
  We have $|U|\geq2$, and every vertex $w \notin U$ behaves the same on any two vertices in $U$
  as otherwise we would have applied
  one of the order constraints described above.
  We remove all vertices in $U$ except $u$ and solve the smaller instance of the problem.
  
  We can find all order constraints in $O(nm)$ time
  as it suffices to consider each edge together with each vertex.

  Now, it remains to prove, that we can insert back the vetices in $U$ to the solution.
  Observe that each vertex $v$ in $U$ can be placed in the position of $u$ and this position satisfies all order constraints of $u$ against vertices not in $U$.
  Thus, we will put all the left (right, resp.) endpoints of vertices in $U$ in an $\varepsilon$ range around the left (right, resp.) endpoint of $u$.
  Consider the mixed graph induced by the vertices in $U$.
  This is a complete mixed acyclic graph and can be seen as a partially ordered set.
  
  A \emph{partially ordered set}, or a \emph{poset} for short, is a transitive directed acyclic graph.
  A poset~$P$ is \emph{total} if, for every pair of vertices~$u$ and~$v$, there is either an arc $(u,v)$ or an arc $(v,u)$ in~$P$.
  We can conveniently represent a total poset~$P$ by a linear order of its vertices $v_1 < v_2 < \dots < v_n$ meaning that there is an arc $(v_i,v_j)$ for each $1 \leq i < j \leq n$.
  A poset~$P$ is \emph{two-dimensional} if the arc set of~$P$ is the intersection of the arc sets of two total posets on the same set of vertices as~$P$.
  McConnell and Spinrad~\cite{McConnellS99} gave a linear-time algorithm that, given a directed graph~$D$ as input, decides whether~$D$ is a two-dimensional poset.
  If the answer is yes, the algorithm also constructs a \emph{realizer}, that is, (in this case) two linear orders $(R_1,R_2)$ on the vertex set of~$D$ such that
  \begin{align*}
  \textrm{arc $(u,v)$ is in~$D$} & \iff
  \left[(\textrm{$u < v$ in $R_1$}) \wedge (\textrm{$u < v$ in $R_2$})\right] \textrm{.}
  \end{align*}

  \begin{claim}
    The mixed graph induced by $U$ is a containment interval graph if and only if the poset of $U$ is two-dimensional.
  \end{claim}
  \begin{claimproof}
    First, for the ``if'' direction, assume that $U$ is two-dimensional, and let $L_1$, $L_2$ be two linear extensions of $U$ such that $U$ is the intersection of $L_1$ and $L_2$.
    Now, we construct the containment interval representation of $G[U]$ in the following way:
    We choose the locations of the left enpoints of the intervals representing the vertices in $U$ in the open interval $(-\frac{1}{2},0)$ so that their left-to-right order is exactly as in $L_1$.
    Similarly, we place right endpoints in the interval $(0, \frac{1}{2})$ so that their right-to-left order is exactly as in $L_2$.
    Now, for an arc $(u,v)$ we have that $u \leq v$ in the poset, and $u \leq_{L_1} v$ and $u \leq_{L_2} v$.
    Thus, the left endpoint of $u$ is to the left of left endpoint of $v$, and right endpoint of $u$ is to the right of the right endpoint of $v$, as required.
    Conversely, for an edge $\{u,v\}$ we have that $u$ and $v$ are incomparable in the poset, and $u \leq_{L_1} v$ and $v \leq_{L_2} u$ (or the other way around, both inequalities are reversed).
    Thus, the resulting intervals overlap without containment, and the resulting set of intervals is a containment representation of~$G[U]$.

    For the other direction, given any containment interval representation, let $L_1$ be a linear order on $U$ given by the left-to-right order of the left endpoints of the intervals, and $L_2$ be given by the right-to-lleft order of the right endpoints.
    Now, after the previous argument, it is easy to see that $L_1, L_2$ is a realizer of the poset of $U$, and $U$ is of two-dimensional.
  \end{claimproof}

  By the claim, we can realize $G[U]$ within small ranges designated to the endpoints of $u$.
  As the running time of this step is linear,
  the resulting running time of this algorithm is in $O(nm)$.
\end{proof}

\subsection{Final Proof}

\cref{thm:recognition} follows easily from \cref{lem:recognition_rotation,lem:recognition_endpoints}.

\begin{proof}[of \cref{thm:recognition}]
	Our algorithm, given a containment interval graph~$G$, applies the
	algorithm from Lemma~\ref{lem:recognition_rotation} to obtain an \MPQ-tree~$T$ that agrees with some containment representation of~$G$.
	Then, using Lemma~\ref{lem:recognition_endpoints}, it constructs a containment representation of~$G$.
	If any of the phases fails, then we know that~$G$ is not a containment interval graph, and we can reject the input.
	Otherwise, our algorithm accepts the input and returns a containment representation of~$G$.
  As both phases can be implemented to run in $O(nm)$ time, we get that our algorithm recognizes containment interval graphs in $O(nm)$ time.
\end{proof}






\section{A 2-Approximation Algorithm for Coloring Containment Interval
  Graphs}
\label{sec:two-approx-coloring-containment}

\begin{theorem}
  \label{thm:containment-two-omega}
  For any set $\cI$ of intervals, the containment interval graph
  $C[\cI]$ induced by \cI admits a proper
  coloring with at most $2 \cdot \omega(C[\cI]) - 1$ colors.
\end{theorem}
\begin{proof}
For simplicity, let $G := C[\cI]$ and $\omega := \omega(G)$.
We use induction on $\omega$. If $\omega=1$, then $G$ has no edges and clearly admits a proper coloring using only one color.
So assume that $\omega>1$ and that the theorem holds for all graphs
with smaller clique number.

Let $M(\cI)$ denote the subset of $\cI$ consisting of intervals that
are maximal with respect to the containment relation.
In particular, $C[M(\cI)]$ is a proper interval graph.  Observe that
$\bigcup M(\cI) = \bigcup \cI$.  Let $R$ be an inclusion-wise minimal
subset of $M(\cI)$ such that $\bigcup R = \bigcup \cI$.
In the example instance depicted in \cref{fig:example}, $R$ is the set
of intervals on the lowest two (gray) lines whereas the intervals in
$M(\cI)$ are marked with crosses.

\begin{claim}
  $C[R]$ is an undirected linear forest.
\end{claim}
\begin{claimproof}
  All intervals in $M(\cI)$ and thus in $R$ are incomparable with
  respect to the containment relation, so $C[R]$ has no arcs.  Note
  that $C[R]$ is a proper interval graph, so it contains no
  induced $K_{1,3}$ and no induced cycle with at least four
  vertices.  Thus we need to only prove that $C[R]$ is triangle-free.
  For contradiction, suppose otherwise.  Let $x,y,z$ induce a triangle
  in $C[R]$, ordered according to their left endpoints.  As $x,y,z$
  are pairwise overlapping, note that $y \subseteq x \cup z$,
  and thus $\bigcup (R \setminus \{y\}) = \bigcup R$. This contradicts
  the minimality of~$R$.
\end{claimproof}

By the claim above, $C[R]$ can be properly colored with colors
$\{1,2\}$.  Let $f_1$ be such a coloring.
If $R = \cI$, we are done (using only $\omega$ many colors), so
suppose that $\cI \setminus R \ne \emptyset$.
Slightly abusing notation, we define $G' := G - R$.

\begin{claim}
The largest clique in $G'$ has at most $\omega-1$ vertices.
\end{claim}
\begin{claimproof}
  As $G'$ is a subgraph of $G$, each clique in $G'$ has at most
  $\omega$ vertices.  For contradiction, suppose that there is a set
  $S \subseteq \cI \setminus R$ such that $|S|=\omega$ and all
  intervals in $S$ pairwise intersect.  By the Helly property of
  intervals,
  $\bigcap S \ne \emptyset$.  Let $p \in \bigcap S$.  Since
  $\bigcup R = \bigcup \cI$, there is an interval $r \in R$ that
  contains~$p$.  Thus $S \cup \{r\}$ is a clique in $G$ with
  $\omega +1$ vertices, which contradicts the definition of $\omega$.
\end{claimproof}

By the inductive assumption, $G'$ admits a proper coloring $f_2$ using colors $[2(\omega-1)-1]$.
Finally, we define $f \colon \cI \to [2\omega-1]$ as follows:
\[
f(x) = \begin{cases}
f_1(x) & \text{ if } x \in R,\\
f_2(x)+2 & \text{ if } x \notin R.
\end{cases}
\]
We claim that $f$ is a proper coloring of $G$.  (For an example, see
\cref{fig:example}.)

\begin{figure}[tb]
  \centering
  \includegraphics{example-two-approx}
  \caption{A set of intervals and a coloring produced by the
    2-approximation algorithm.  The intervals that lie in $M(\cI)$ in
    the top level of the recursion are marked with crosses.}
  \label{fig:example}
\end{figure}

First, note that if $x,y \in \cI$ are distinct and $x \cap y \neq \emptyset$, then $f(x) \neq f(y)$.
Indeed, if $x,y \in R$, then $f(x) = f_1(x) \neq f_1(y)=f(y)$.
If $x,y \notin R$, then $f(x) = f_2(x) +2 \neq f_2(y) + 2=f(y)$.
Finally, if, say, $x \in R$ and $y \notin R$, then $f(x) \in \{1,2\}$ and $f(y) \geq 3$.

So let us argue that the second condition in the definition of a proper coloring holds as well.
For contradiction, let $x,y$ be distinct intervals  such that $x \subseteq y$ and $f(x) < f(y)$.
Note that $x \notin M(\cI)$ and thus $x \notin R$.
This implies that $f(x)\ge3$.
Since we assumed that $f(y)>f(x)$, we have that $f(y)>3$.
Hence, $y \not\in R$.
However, by the inductive assumption, we have $f(x) = f_2(x) +2 > f_2(y)+2 = f(y)$, which yields the desired contradiction.
This completes the proof.
\end{proof}

Observe that the proof of \cref{thm:containment-two-omega} can be
easily transformed into an efficient algorithm, which yields the
following corollary.

\begin{corollary}
  \label{cor:containment-two-approx}
  There is a 2-approximation algorithm for coloring interval
  containment graphs properly.  Given a set of $n$ intervals, the
  algorithm runs in $O(n \log n)$ time.  
\end{corollary}

\begin{proof}
  For any graph~$G$, we have $ \chi(G) \geq \omega(G)$.  Hence, the
  approximation factor follows directly from
  \cref{thm:containment-two-omega}.
 
  It remains to implement the constructive proof of
  \cref{thm:containment-two-omega} efficiently.
  Let~\cI be the given set of intervals.  For each
  interval~$I$ in \cI, let~$r_I$ be the right endpoint of~$I$.
  We go through the intervals from left to right in several phases.
  In each phase, we use two colors, except possibly in the last phase
  where we may only use one color.  For the first phase, we reserve
  colors~1 and~2, for the second phase, we reserve colors~3 and~4 etc.
  We use an augmented balanced binary search tree~\cT to store the
  intervals in~\cI.  We will query~\cT in two ways.  A query of
  type~Q1 in~\cT with a
  value~$x \in \mathbb{R} \cup \{-\infty\}$ will return, among all
  intervals whose left endpoint is at least~$x$, one with leftmost
  left endpoint (and $\mathit{nil}$ if such an interval does not exist).
  A query of type Q2 in \cT with a value $y \in \mathbb{R}$ will return,
  among all intervals whose left endpoint is at most~$y$, one with
  rightmost right endpoint (and $\mathit{nil}$ if such an interval
  does not exist).  Note that the two queries are not symmetric.

  Initially, \cT stores all intervals in~\cI.
  We start each phase by Q1-querying~\cT with $-\infty$.  This yields
  the leftmost interval~$I$ in~\cI.  We color~$I$ with the smaller
  color~$c=2i-1$ reserved for the current phase~$i$.  Whenever we have
  colored an interval, we immediately remove it from~\cT.  Then we
  Q2-query~\cT with the  
  right endpoint~$r_I$ of~$I$.  If \cT returns $\mathit{nil}$ or an
  interval~$I'$ that lies completely to the left of~$r_I$, we Q1-query
  \cT with $r_I$ for the next interval~$I''$.  If $I''$ exists, then
  we color it, too, with color~$c$.  Otherwise, that is, if $I''$
  does not exist, we start a new phase.  Finally, if the interval $I'$
  overlaps with the previous interval~$I$, we color~$I'$ with the
  other color $c' \ne c$ that we reserved for the current phase.
  Then we continue with the next Q2-query as above (where $I'$ now
  plays the role of~$I$).

  It remains to implement the balanced binary search tree~\cT.  
  The key of an interval is its left endpoint.  For
  simplicity, we assume that the intervals are stored in the leaves
  of~\cT and that the key of each inner node is the maximum of the
  keys in its left subtree.  This suffices to answer queries of type~Q1. 
  For queries of type Q2, we augment~\cT by storing, with each
  node~$\nu$, a value $\max(\nu)$ that we set to the maximum of the
  right endpoints among all intervals in the subtree rooted at~$\nu$.
  (We also store a pointer $\mu(\nu)$ to the interval that yields the
  maximum.)  In a Q2-query with a value~$y$, we search for the largest
  key~$k \le y$.  Let~$\pi$ be the search path in~\cT, and initialize~$m$
  with~$-\infty$.  When traversing~$\pi$, we inspect each node~$\nu$ that 
  hangs off~$\pi$ on the left side.  If $\max(\nu)>m$, then we set
  $m=\max(\nu)$ and $\rho=\mu(\nu)$.  When we reach a leaf, $\rho$
  points to an interval whose right endpoint is maximum among
  all intervals whose left endpoint is at most~$y$.

  The runtime of $O(n \log n)$ is obvious since we insert, query, and
  delete each interval in $O(\log n)$ time in each of the two data
  structures exactly once.
\end{proof}

\begin{proposition}
  \label{prop:containment-two-omega}
  There is an infinite family $(\cI_n)_{n \ge 1}$ of sets of intervals
  with $|\cI_n|=3 \cdot 2^{n-1}-2$, 
  $\chi(\cI_n)=2n-1$, and $\omega(\cI_n)=n$.
\end{proposition}

\begin{proof}
The construction is iterative.
The family $\cI_1$ consists of a single interval of unit length.

Now let $n>1$ and suppose that we have defined~$\cI_{n-1}$ and want to
define~$\cI_n$.
We introduce two new intervals $\ell_n$ and $r_n$, both of length $3^{n-1}$, that overlap slightly.
Then we introduce two copies of $\cI_{n-1}$.
All intervals of one copy are contained in $\ell_n \setminus r_n$, and all intervals of the other copy are contained in $r_n \setminus \ell_n$.

The number of intervals in $\cI_n$ is given by the recursion: $f(1)=1$ and $f(n) = 2f(n-1)+2$, 
which solves to $f(n) = 3 \cdot 2^{n-1} - 2$. Furthermore, it is straightforward to observe that with each step of the construction,
the size of a largest clique increases by $1$.

We claim that, for $i \in [n]$, in any proper coloring of $\cI_n$, the difference between the largest and the smallest color used is at least $2n-2$.
This is obvious for $\cI_1$.  Assume that the claim holds for
$\cI_{n-1}$.  Consider any proper coloring of~$\cI_n$, and let $m$ be
the minimum color used in this coloring.
The colors of $\ell_n$ and $r_n$ must be different.
Without loss of generality, suppose that the color of $r_n$ is larger
than the color of $\ell_n$.
In particular, the color of $r_n$ is at least $m+1$.
Now consider the copy of $\cI_{n-1}$ contained in $r_n$. 
The color of each interval in this copy must be larger than the
color of $r_n$, so in particular the minimum color used for this copy
of $\cI_{n-1}$ is at least $m+2$.
By the inductive assumption, some interval in this copy of~$\cI_{n-1}$
receives a color that is at least $m+2 + 2(n-1)-2 = 2n-2+m$.
Summing up, the difference between the largest and the smallest color
used for $\cI_n$ is at least $2n-2$.

Now, as the minimum color is~$1$, we conclude that $\chi(\cI_n) \geq 2n-1$.

For the upper bound, 
we color~$\cI_n$ as follows.
For $n=1$, we color the only interval with color $1$.
For $n > 1$, we color $\ell_n$ with color~$1$ and $r_n$ with color~$2$.
Next, for each of the two copies of $\cI_{n-1}$, we use the proper
coloring defined inductively with all colors increased by $2$, see
\cref{fig:lower-bound-two-omega}.
\end{proof}

\begin{figure}[tb]
  \centering
  \includegraphics{lower-bound-two-omega}
  \caption{Instance for the proof of \cref{prop:containment-two-omega}
    for $n=3$: $|\cI_n|=3 \cdot 2^{n-1}-2=10$, $\omega(\cI_n)=n=3$, and
    $\chi(\cI_n)=2n-1=5$.}
  \label{fig:lower-bound-two-omega}
\end{figure}


\section{Coloring Containment Interval Graphs Is NP-Hard}
\label{sec:coloring-containment-hard}

\begin{theorem}
	\label{thm:containment-NP-hard}
	Given a set \cI of intervals and a positive integer $k$, it is
	NP-hard to decide whether $k$ colors suffice to color $C[\cI]$, that
	is, whether $\chi(C[\cI]) \le k$.
\end{theorem}

\begin{proof}
	We describe a reduction from (exact) 3-\textsc{Sat}, i.e.,
	the satisfiability problem where every clause contains exactly three literals.
	Let $\varphi = C_1 \wedge C_2 \wedge \dots \wedge C_m$ be an
	instance of 3-\textsc{Sat} where,
	for each clause $C_i$ ($i \in [m]$),
	the literals are negated or unnegated variables from the set
	$\{x_1,x_2,\dots,x_n\}$.
	
	Let $j \in [n]$.  The variable gadget for~$x_j$ consists of two
	``Christmas trees'', which are cliques containing only arcs;
        see \cref{fig:variable-gadget}.
	We refer to them as \emph{red} and \emph{gray} Christmas tree
	and we let their longest intervals overlap.
        \Cref{fig:variable-gadget} depicts two representations of the
        same gadget for a variable~$x$, each with its own coloring of the
        intervals (encoded by the height of the intervals; see the
        numbers at the right side of the gray box).  The left
        representation and its coloring correspond to assigning
        true to~$x$, the right representation corresponds to assigning
        false.
	\begin{figure}[tb]
		\centering
		\includegraphics[page=2]{containment-variable-gadget}
		\hfill
		\includegraphics[page=1]{containment-variable-gadget}
		
		\caption{Variable gadget for the proof of
			\cref{thm:containment-NP-hard} in its two states.  The blue
			intervals with dots extend to the clause gadgets.  The topmost
			blue interval
			(starting immediately to the right of a gray interval) indicates
			that $x$ is part of a clause~$C_j$ with $j>i$; the blue interval
			(with a small gap) that starts immediately to the right of a red
			interval indicates that $\neg x$ is part of the clause~$C_i$.}
		\label{fig:variable-gadget}
	\end{figure}
	The height of such a
	tree is the number of intervals that are contained in one another.
	The height of the red tree is $H-1$ minus the number of occurrences
	of literals $x_{j'}$ and $\neg x_{j'}$ with $j'<j$ in~$\varphi$,
	where $H = 5 (m+1)$.
	The height of the gray tree is that of the red tree minus the number
	of occurrences of $\neg x_j$ in~$\varphi$.
	We say that $x_j$ is set to true if the bottom interval of
	the gray Christmas tree has color~1 and $x_j$ is set to false otherwise.

	For $i \in [m]$, the gadget for clause $C_i$ consists of a
        Christmas tree (blue in \cref{fig:clause-gadget}) of height
        $H-(5i+2)=5(m-i)+3$.  All clause gadgets are placed to the
        right of all variable gadgets, in the order $C_1,\dots,C_m$
        from left to right.
        
	\begin{figure}[tb]
		\centering
		\includegraphics[page=1]{containment-clause-gadget}
		
		\bigskip
		
		\includegraphics[page=2]{containment-clause-gadget}
		\caption{Variable gadgets (red and gray) and clause gadgets (blue)
			for the 3-\textsc{Sat} instance
			$(\neg x_2 \vee \neg x_4 \vee x_5) \wedge (x_1 \vee \neg x_3 \vee x_4)
			\wedge (\neg x_1 \vee x_2 \vee x_3)$ with a fulfilling truth
			assignment (above) and a non-fulfilling assignment (below).  Note
			that the latter uses one color more (is one level higher).}
		\label{fig:clause-gadget}
	\end{figure}
	
	The key idea to transport a Boolean value from a variable gadget
	to a clause gadget is to add, for each occurrence of a literal
	$\ell_j \in \{x_j, \neg x_j\}$ in a clause~$C_i$, an ``arm''
	(blue intervals in \cref{fig:variable-gadget,fig:clause-gadget})
	that ends to the right of all Christmas trees and starts
	immediately to the right of the $5i$-th interval of the gray tree
	(if $\ell_j=x_j$) or of the red tree (if $\ell_j=\neg x_j$)
	corresponding to~$\ell_j$.  The arm is represented by a sequence of
	intervals that are separated by a small gap within each Christmas
	tree (such that, for any two arms, their gaps are disjoint
	and the resulting intervals do not contain each other).
	Presuming that the total number of colors is~$H$,
	two intervals of the same arm that are separated by a gap
	need to get the same color because, at the gap, $H-2$
	colors are occupied by other intervals and the one remaining
	``wrong'' color is blocked due to the intervals depicted in green
	in \cref{fig:variable-gadget,fig:clause-gadget},
	which need to get color $H$ or $H-1$ and
	are contained by the (blue) intervals of the arms.
	
	If any of the literals in $C_i$ is true, then its arm can use
	color~$5i$.  Then, the arms of the other literals that occur in~$C_i$
	can use colors $5i+1$ and $5i+2$.  This allows a small
	Christmas tree (blue in \cref{fig:clause-gadget})
	of height $5(m-i)+3$ being contained in the rightmost intervals
	of the arms that represent clause~$C_i$
	to use the colors $\{5i+3,5i+4,\dots,H\}$.
	
	If none of the literals in $C_i$ is true, then none of their arms
	can use color~$5i$.  Hence, they must use colors $5i+1$, $5i+2$, and
	$5i+3$ (or higher).
	This forces the small (blue) Christmas tree
	of clause~$C_i$ to use colors $\{5i+4,\dots,H,H+1\}$. 
	
	Thus, a 
	coloring with $H$ colors exists if and only if
	$\varphi$ is satisfiable.
\end{proof}



\section{Coloring Bidirectional Interval Graphs Is NP-Hard}
\label{sec:bidirectional-NP-hard}

\begin{theorem}
  \label{thm:bidirectional-NP-hard}
  Given a set \cI of intervals and a positive integer $k$, it is
  NP-hard to decide whether $k$ colors suffice to color $B[\cI]$, that
  is, whether $\chi(B[\cI]) \le k$.
\end{theorem}

\begin{figure}[tb]
\centering
\includegraphics[page=2]{bidi-variable-gadget}
\hfill
\includegraphics[page=1]{bidi-variable-gadget}


\caption{Variable gadget for the proof of
	\cref{thm:bidirectional-NP-hard} in its two states.
	Intervals directions are indicated by arrow heads.
	The blue intervals extend (to the right)
	to the clause gadgets of only negated variables.
	The two blue arrow heads starting next to the red intervals
	indicate that the clause~$C_i$ and a clause~$C_j$ with $j>i$
	contain the literal $\neg x$.}
\label{fig:bidi-variable-gadget}
\end{figure}

\begin{proof}
  We use the same ideas as in the proof of
  \cref{thm:containment-NP-hard}, but now
  we reduce from \textsc{Monotone 3-Sat},
  the version of \textsc{3-Sat} where every clause
  contains only negated or only unnegated variables as literals.
  For an overview see
  \cref{fig:bidi-variable-gadget,fig:bidi-clause-gadget}.
  The maximum color sufficient for a yes-instance is again~$H = 5(m+1)$.
  
  Observe that now a clique containing only arcs
  is a ``staircase'' instead of a Christmas tree.
  Consequently, each variable is now represented by
  a \emph{red} right-going and a \emph{gray} left-going staircase;
  see \cref{fig:bidi-variable-gadget}.
  
  For a clause $C_i$ with only negated literals,
  we again have three ``arms'' starting
  to the right of the $5i$-th interval of the red staircase
  of the three corresponding variables;
  see the blue intervals in \cref{fig:bidi-variable-gadget,fig:bidi-clause-gadget}.
  The intervals of these arms are left-going
  and they are not split by a gap at the other variable gadgets
  this time because now we need to contain the left-going
  intervals of the staircases to have edges instead of arcs.
  They end below a left-going \emph{blue} staircase
  (see \cref{fig:bidi-clause-gadget} on the upper right side)
  of height $5(m-i)+3$ whose maximum color is $H$
  if and only if none of the corresponding arms
  gets a color greater than $5i + 2$.
  
\begin{figure}[tb]
\centering
\includegraphics[page=1,scale=.92]{bidi-clause-gadget}

\medskip

\includegraphics[page=2,scale=.92]{bidi-clause-gadget}
\caption{Variable gadgets (red and gray) and clause gadgets (green and blue)
	for the \textsc{Monotone 3-Sat} instance
	$(x_1 \vee x_2 \vee x_4) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)
	\wedge (\neg x_2 \vee \neg x_3 \vee \neg x_4)$ with a fulfilling truth
	assignment (top) and a non-fulfilling assignment (bottom),
	which use $H$ and $H + 1$ colors, respectively.
	Interval directions are indicated by arrow heads.}
\label{fig:bidi-clause-gadget}
\end{figure}

  Note that we need to avoid arcs between the arms.
  Therefore, we let every arm have a gap below
  each blue staircase it passes.
  These gaps do not overlap and
  their order is inverse to the order of the left endpoints
  of the involved intervals.
  We continue the arm with a right-going interval
  (to avoid an arc with the blue staircase and the other arms)
  ending to the right of the blue staircase,
  where we continue again with a left-going interval.
  Consider such an arm with intervals $I$ and $I'$
  (going in different directions) around a gap.
  At this gap, it is important that
  no color smaller than the color of $I$ is available for $I'$,
  forcing $I'$ to also get the color of~$I$.
  Hence, we add long left-going intervals blocking
  every color not occupied by an arm or the blue staircase;
  see the orange intervals in \cref{fig:bidi-clause-gadget}.
  
  For every clause with only unnegated literals,
  we use the same construction but mirrored;
  see the green intervals and staircases in \cref{fig:bidi-clause-gadget}.
  
  We now have the same conditions as
  in the proof of \cref{thm:containment-NP-hard}
  and, therefore, the same correctness argument applies,
  which concludes the proof.
\end{proof}



\section{Coloring General Mixed Interval Graphs}
\label{sec:coloring-general}

In this section we consider a further generalization of mixed interval
graphs.  We are dealing with an interval graph $G$ whose edges can be
arbitrarily oriented (or stay undirected).  In other words, the edge
directions are not related to the geometry of the intervals.

Observe that a proper coloring of $G$ exists if and only if $G$ does
not contain a directed cycle.  Let $\chi(G)$ denote the minimum number
of colors in a proper coloring of $G$, if it exists, or $\infty$ otherwise.
We point out that the existence of a directed cycle can be determined
in polynomial time (using, for example, depth-first search algorithm).

Note that clearly we have $\omega(G) \leq \chi(G)$.
However, there is another parameter that enforces a large chromatic
number even in sparse graphs.
A \emph{directed path} (of length $t$) in $G$ is a sequence of
vertices $\langle v_1,v_2,\dots,v_t \rangle$, such that, for each
$i \in [t-1]$, the arc $(v_i,v_{i+1})$ exists.
Let $\lambda(G)$ denote the length of a longest induced directed
path in~$G$.

Note that if $\langle v_1,v_2,\dots,v_\ell \rangle$ is a directed path
in $G$, then in any proper coloring of $G$, the vertices of the path
receive pairwise distinct colors.  Thus we have $\lambda(G) \leq
\chi(G)$, and consequently $\chi(G) \ge \max \{\omega(G), \lambda(G)\}$.

\begin{theorem}
  \label{thm:mixed-upper-bound}
  Let $G$ be a mixed interval graph without directed cycles.
  Then $\chi(G) \leq \omega(G) \cdot \lambda(G)$.
\end{theorem}
\begin{proof}
  Let $V$ denote the vertex set of $G$.  Let $G^{\to}$ be the graph
  obtained from $G$ by removing all edges.  Clearly,
  $G^{\to}$ is a DAG.  We partition $V$ into \emph{layers}
  $L_0,L_1,\ldots$ as follows.  The set~$L_0$ consists of the vertices
  that are sources in $G^{\to}$, i.e., they do not have incoming
  arcs.  Then, for $i=1,2,\ldots$, we iteratively define $L_i$ to be
  the set of sources in $G^{\to} \setminus \bigcup_{j=0}^{i-1} L_j$.
  Note that $\lambda(G) = \max \{ i \colon L_i \ne \emptyset \}$.  For
  each $x \in V$, let $\ell(x)$ denote the unique $i$ such that
  $x \in L_i$.

  Recall that 
  $U(G)$ is an (undirected) interval graph, and thus
  $\chi(U(G))=\omega(U(G))=\omega(G)$.  Let $c \colon V \to [\omega(U(G))]$
  be an optimal proper coloring of~$U(G)$.

  Now we define a coloring $f$ of $G$: to each vertex~$x$ of~$G$, we
  assign the 
  number $\ell(x)\omega(G)+c(x)$.
  We order these colors
  lexicographically.  Clearly, their number is bounded by
  $\lambda(G) \cdot \omega(G)$.  We claim that $f$ is a proper
  coloring.

  Consider an edge $\{x,y\}$. As this is also an edge in $U(G)$,
  we obtain that $c(x) \neq c(y)$, and so $f(x) \neq f(y)$.  Now
  consider an arc directed from $x$ to $y$. The existence of such an
  arc implies that $\ell(x) < \ell(y)$, and thus $f(x) < f(y)$.
\end{proof}

For some instances, the above bound is asymptotically tight.

\begin{proposition}
  \label{prop:mixed-lower-bound}
  There is an infinite family $(G_k)_{k \ge 1}$ of mixed interval
  graphs with $|V(G_k)|=k^2$, $\omega(G_k)=2k$, $\lambda(G_k)=k$,
  and $\chi(G_k)=k^2=\omega(G_k)\cdot\lambda(G_k)/2$.
\end{proposition}

\begin{proof}
  Let $\cI_k=\cI_{k,1} \cup \cI_{k,2} \cup \dots \cup \cI_{k,k}$ be a set of
  $k^2$ intervals defined as follows; see \cref{fig:mixed-example}
  for~$\cI_4$.  For $i \in [k]$, let $\cI_{k,i}$ be a multiset that
  contains $k$ copies of the interval $[i,i+1.1]$.  Note that, for
  $i \in [k-1]$, every interval in $\cI_{k,i}$ intersects every interval
  in~$\cI_{k,i+1}$.  Let $G_k$ be a mixed interval graph for the
  set~$\cI_k$.  We direct the edges of~$G_k$ as follows.  Let $\{I,I'\}$
  be a pair of intervals in $\cI_k$ that intersect each other.  If $I$
  and $I'$ are copies of the same interval, then $\{I,I'\}$ is an
  edge in~$G_k$.  Otherwise, $(I,I')$ is an arc in~$G_k$, assuming
  that~$I$ lies further to the left than~$I'$.
  It is easy to see that $G_k$ has the desired properties.
\end{proof}

Note that the mixed interval graphs that we constructed in the proof
above are even directional interval graphs.

\begin{figure}[tb]
  \centering
  \includegraphics{mixed-example}
  \caption{For any $k \ge 1$, the set
    $I_k=I_{k,1} \cup I_{k,2} \cup \dots \cup I_{k,k}$ of $k^2$
    intervals gives rise to a mixed interval graph~$G_k$ with
    $\chi(G_k)=k^2=\omega(G_k)\cdot\lambda(G_k)/2$.}
  \label{fig:mixed-example}
\end{figure}


\section{Open Problems}

The obvious open problems are improvements to the results in
\cref{tab:results}, in particular: Is there a constant-factor
approximation algorithm for coloring general mixed interval graphs?
Is there a polynomial-time recognition algorithm for bidirectional
interval graphs?  For applications in graph drawing, a better-than-2
approximation for coloring bidirectional interval graphs is of
particular interest.


\subsubsection*{Acknowledgments.}

We are indebted to Krzysztof Fleszar, Zbigniew Lonc, Karolina Okrasa,
and Marta Piecyk for fruitful discussions.


\bibliography{arxiv}

\end{document}

% vim:ts=2:sts=2:sw=2:expandtab
