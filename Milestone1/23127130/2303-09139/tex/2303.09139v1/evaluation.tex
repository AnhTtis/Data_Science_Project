\section{Evaluation}
We have implemented our algorithms in C++ on an Intel Core i7 CPU running with 16GB of RAM. We use the CGAL library to build the medial axis graph $G$. We evaluate our method on three categories of robots: the single differential-drive robot, the Dubin's car, and the differential-drive robot with trailer (truck for short) as in \cite{bareiss2015generalized}, where we tune the parameters such that the maximal turning curvature of the trajectory is $0.19$ for a Dubin's car, and $0.22$ for a truck-like robot. In all three testing scenarios, we use GRVO \cite{bareiss2015generalized} as our local navigation algorithm. We set the vehicle size to $4\times5$ square units and, the medial axis sampling interval to $0.02$ units, and we use $\eta=1.6-2.6, R=15-30$. We randomly put the agents in the open area and repeat 50 times in each scenario. The average computational cost over these scenarios is summarized in~\prettyref{fig:FPS}, and it largely depends on the number of robots. Our bottleneck lies in the collision detection between robots of non-circular shapes.
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\linewidth]{figs/Robot2FPS.pdf}
\caption{\label{fig:FPS} \small{We plot the averaged computational cost of our method (frames per second) against the number of robots.}}
\vspace{-15px}
\end{figure}

\subsection{Baselines}
\begin{wraptable}{r}{0.25\textwidth}
\centering
\scalebox{.8}{
\begin{tabular}{ccc}
\toprule
    & Bridge  &  Ours   \\
\midrule
I   & 212     & 0.6     \\
II  & 122     & 3.3     \\
III & 12      & 0.2     \\
IV  & 19      & 4       \\
\bottomrule
\end{tabular}}
\caption{\label{table:precompute}\small{This table shows the average computational time (seconds) during the precomputation stage of Bridge and our method on 4 scenarios.}}
\end{wraptable}
There are several prior works on improving the success rate of local navigation methods. Our first baseline is the GRVO algorithm~\cite{bareiss2015generalized} without our modulation. Our second baseline is the grouped sampling-based algorithm (Bridge)~\cite{he2017efficient}. This algorithm aims at solving the same problem as ours. They use a sampling-based method to precompute a set of corridors across narrow passages, in which nonholonomic agent trajectories can be efficiently generated by interpolation. Agents follow these interpolated trajectories in the corridor while collisions are handled using local navigation techniques. Finally, we also consider the GRVO algorithm with adapted Implicit Coordination method (GRVO+following)~\cite{7487147}. As the major difference from our method, the IC algorithm allows an agent to communicate with neighbors to coordinate desired velocities.

\subsection{Benchmark Problems}
We consider 4 challenging benchmarks, illustrated in \prettyref{fig:results}. The trajectories generated by different methods are compared and evaluated in three aspects: the average length of agent trajectories, the rate of success of finding feasible motion plans, and the frame rate per second (FPS). Quantitative results, corresponding to an average of over $50$ simulations with randomly generated agent configurations in an assigned sub-area of the scenarios, are summarized in \prettyref{table:profile}.

\TE{Benchmark I:} We use a dumb-like environment, shown in \prettyref{fig:results} (a), where multiple agents move from one side to the other. We observe that our method allows the agents to determine that they will meet agents from the other side and the POIs lie in the narrow central passage. Our method then has agents on one side retreat from the narrow space and return to the left side of the scene to wait for agents from the other side to pass through before moving on. For this example, most other local navigation methods, including GRVO and GRVO+following, fail. 

\TE{Benchmark II:} As shown in \prettyref{fig:results} (b), we place a group of agents in a complex, bee-shaped environment. Agents start from one corner of the freespace and repeatedly yield other upcoming agents. The results in \prettyref{table:profile} show that our method can always compute a feasible motion plan, while prior techniques cause many collisions resulting in deadlock configurations. The only rival algorithm that exhibits a high success rate is Bridge, which uses a sampling-based motion planner during the precomputation stage. In comparison, the precomputation involved in our method is only used to find the medial axis graph of $\mathcal{F}$, which can be accomplished much faster as profiled in \prettyref{table:precompute}.

\TE{Benchmark III:} As shown in \prettyref{fig:results} (c), we use a small maze involving two long obstacles, with agents again placed randomly. The Bridge algorithm outperforms our method for this benchmark in terms of trajectory length, although the success rates of both algorithms are $100\%$. This is due to inaccuracies in detecting and shifting POIs, where our method does not account for in-between obstacles.

\TE{Benchmark IV:} Our last and most challenging benchmark involves a single narrow passage with a garage in the middle for agents to perform yielding. As illustrated in \prettyref{fig:results} (d), our POI shifting procedure allows agent to be directed to the garage, while all prior methods fail.

\begin{comment}
\subsection{Benchmark Problems}
\begin{figure*}[ht]
\centering
\scalebox{.9}{
\setlength{\tabcolsep}{3px}
\begin{tabular}{ccc}
\includegraphics[width=0.24\linewidth,trim=1px 1px 1px 1px,clip]{figs/d0.png}\put(-90,5){(b)}&
\includegraphics[width=0.24\linewidth,trim=6px 6px 6px 6px,clip]{figs/d1.png}\put(-90,5){(c)}&
\includegraphics[width=0.24\linewidth,trim=6px 6px 6px 6px,clip]{figs/d2.png}\put(-90,5){(d)}\\
\includegraphics[width=0.24\linewidth,trim=1px 1px 1px 1px,clip]{figs/t0.png}&
\includegraphics[width=0.24\linewidth,trim=6px 6px 6px 6px,clip]{figs/t1.png}&
\includegraphics[width=0.24\linewidth,trim=6px 6px 6px 6px,clip]{figs/t2.png}\\
\end{tabular}}
\caption{\label{fig:results} \small{The others two groups of examples we have done to compare our approach with previous works. We used differential wheels and  truck-like vehicle to verified our  work in a narrow passenger challenge scene. From the results, we can see our work took a little bit overhead in precomputing and pass though the narrow area and reach their goals without deadlock.}}
\end{figure*}
\end{comment}