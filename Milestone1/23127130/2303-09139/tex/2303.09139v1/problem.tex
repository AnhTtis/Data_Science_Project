\section{Problem Formulation \& Background}
We assume there are $N$ nonholonomic agents with the configuration of $i$th agent being $x_i(t)$ at time instance the $t$. The agent moves in a 2D freespace $\mathcal{F}\subset\mathbb{R}^2$ according to the following differential drive model:
\begin{align*}
\dot{x}_i(t)=f_i(x_i,u_i),
\end{align*}
where $u_i$ is the control signal. With each agent starting from an initial configuration $x_i(0)$, our goal is to find $u_i(t)$ for $t\in[0,T]$ such that $p(x_i(T))$ is close enough to some goal position $g_i$, where $p(\bullet)$ is the configuration-to-position mapping function. Given $g_i$, local navigation algorithms~\cite{van2011reciprocal,bareiss2015generalized} would direct agents via a desired velocity $v_i^*$ and modulate $u_i$ to locally avoid collisions. We build our method on the generalized RVO algorithm denoted as a function:
\begin{align*}
u_i(t)\triangleq\text{GRVO}(v_i^*,x_i(t)).
\end{align*}
Such modulation typically exhibits yielding behaviors allowing a crowd of agents to move around each other and continue towards their respective goals. However, extra space is required for local yielding to be successful. This property is exploited in prior work~\cite{Solovey-RSS-15} to design centralized navigation algorithms for holonomic agents, while nonholonomic agents typically require even larger yielding space. The choice of desired velocity is another key to the success of local navigation. A prominent choice is $v_i^*\triangleq g_i-p(x_i(t))$, which is valid in open areas with small obstacles. For more complex or obstacle-rich environments, a set of reference trajectories must be computed to guide agents across large obstacles.

\begin{figure}[h]
\centering
\scalebox{.8}{\includegraphics[width=0.9\linewidth]{figs/medialaxis.pdf}}
\caption{\label{fig:MedialAxis} \small{We illustrate the discretized medial axis for the U-shaped environment, where red dots belong to $V$ and black dashed edges belong to $E$. Each $s_i\in V$ is associated with a circular domain (black circle) with radius defined as $r(s_i)$ (black arrow). A reference trajectory is computed by first projecting $x_i(0)$ (blue) and $g_i$ (green) to $G$ and then computing the shortened path on $G$.}}
\vspace{-10px}
\end{figure}
\subsection{Blum Medial-Axis}
Our method makes extensive use of the medial axis of $\mathcal{F}$ to 1) estimate the area required by the yielding behavior and 2) compute reference trajectories. The definition of Blum medial-axis~\cite{blum1978shape} or skeleton is as follows. Given a 2D object defined by a \textbf{closed, oriented} boundary $\partial\mathcal{F}$, a Blum medial axis is a set. For every point $s$ in this set, we can find a unique circle centered at $s$ that is tangent to at least two points of $\partial\mathcal{F}$. This circle is known as the circular domain or domain of $s$ and we denote its radius as $r(s)$. A practical method like \cite{telea2006variational} would compute a discretized Blum medial axis, which is a graph $G=<V,E>$, where the set of vertices is sampled skeleton points $V=\{s_i\}$ at regular intervals connected by edges in $E$. As illustrated in \prettyref{fig:MedialAxis}, we compute a reference trajectory for the $i$th agent by first projecting $x_i(0)$ and $g_i$ to the closest vertices and then searching for a trajectory along $G$ via Dijkstra's algorithm.

\subsection{Trajectory Following with Yielding}
Given a reference trajectory, we have $x_i$ track the trajectory by designing the desired velocity $v_i^*$. Specifically, we set the desired velocity to be the negative gradient of a cost function $v_i^*\triangleq\nabla_{p(x_i)} -c(p(x_i))$ defined as:
\begin{align*}
c(p(x_i))\triangleq c_\text{follow}(p(x_i))+c_\text{bias}(p(x_i)),
\end{align*}
where $c_\text{follow}$ guides $x_i$ to move forward along the reference trajectory and $c_\text{bias}$ penalizes bias from the trajectory. We use an idea similar to the Frenet-frame-based tracking method \cite{werling2010optimal}. Specifically, we first compute the closest $s_i\in{V}$ to $x_i(t)$ that belongs to the reference trajectory. We denote $s_{i+1}$ as the next node in $V$ that also belongs to the reference trajectory, then we define:
\begin{align*}
c_\text{follow}(p(x_i))\triangleq& -(s_{i+1}-s_i)^T\dot{p}(x_i)\\
c_\text{bias}\triangleq& \|p(x_i)-s_i\|^2.
\end{align*}
In the next section, we describe a method to avoid deadlock configurations in narrow passages, allowing the yielding behaviors generated by $\text{GRVO}$ to have a high success rate.