\section{BFT in a nutshell}
\label{background}

%  --- Assumptions --- \\
% 1) Byz General problem and Byzantine fault model \\
% 2) Synchrony models \\

% --- Guarantees --- \\
% 3) BFT SMR Liveness and Safety, BFT Consensus Liveness and Safety. \\
% 4) PBFT - can we explain it in a simplified version e.g., generic model of a BFT protocol

In this section, we review a few basics of \ac{BFT} protocols.

\subsection{Assumptions}

\subsubsection{The Byzantine Fault Model}


A faulty process may behave arbitrarily in the Byzantine fault model, even exhibiting malicious and colluding behavior with other Byzantine processes. The model always assumes that only a threshold $f$ out of $n$ participants is Byzantine, while all others ($n-f$) are correct and show behavior that exactly matches the protocol description. 
Although described as arbitrary, the behavior and possibilities of a Byzantine process are still limited by its resources and computational feasibility, e.g., it can not break strong cryptographic primitives. Lamport showed with the
Byzantine generals' problem that achieving consensus with $f$ Byzantine participants is impossible %in a synchronous system 
if $f \geq n/3$ and solvable for $f < n/3 $ in the partially synchronous or asynchronous model (\cf \cref{sec:background:synchrony})~\cite{pease1980reaching, lamport1982byzantine, dwork1988consensus}.
An adversary is often modeled as being in control over all $f$ Byzantine processes. The adversary's access to information can be \textit{limited} through private channels between replicas or \textit{unlimited} if the adversary is modeled to have full disclosure on all messages sent over the network. Lastly, the adversary is assumed either \textit{static}, i.e., has to make his selection initially without the possibility to change it later on, or \textit{adaptive}, in which the adversary can change the nodes as long as not exceeding the threshold $f$ at any given time.


% Explain the BFT model here. There are some slightly different views on the power of an attacker..
% n= 3f+1 result, impossibility for n <= 3f , LSP paper citation \\
% -- Byzantine nodes behave arbitrarily \\
% -- ! but bounded by computation power \\
% -- power of adversary: \\
% --- adaptive or non-adaptive \\
% --- global knowledge or limited to "his" selected nodes \\
% --- power to control the network and delay messages for given time spans? \\



\subsubsection{Synchrony Models}\label{sec:background:synchrony}

BFT protocols rely on synchrony models to capture temporal behavior and timing assumptions, which are important for the concrete protocol designs. %In particular, these models capture 
% assumptions we make about time needed for a message to be sent between two processes over the network, or the time needed by some process to perform a local computation. 
In this subsection, we review popular models (see \cref{table:background:synchrony}) and discuss how they affect  practical system design.



\paragraph{Asynchronous System Model}
No assumptions are made about upper bounds for network transmissions or performing local computations. These are said to complete \textit{eventually}, meaning they happen after an unknown (but \textit{finite}) amount of time. For instance, the network cannot \enquote{swallow up} messages by infinitely delaying them. The asynchronous model is the most general, yet it complicates the design of protocols in this model since no timers can be used in the protocol description. It was proven impossible to deterministically achieve consensus in the presence of faults in an asynchronous system~\cite{fischer1985impossibility}. This problem is solvable in a synchronous system\cite{pease1980reaching} where timers can be used to detect failures.

\paragraph{Synchronous System Model}
Here we assume that strict assumptions can be made about the timeliness of all events. In particular, the synchronous system model assumes the existence of a known upper bound $\delta$ for the time needed for both message transmissions over the network and local computations. In practice, choosing $\delta$ to model a system can be bothersome: If the correctness of decisions depends on it, it must not be underestimated; however, if it is chosen too large, it may negatively impact the performance of a system.

\paragraph{Partially Synchronous System Model}
Dwork et al. proposed a sweet spot between the synchronous and asynchronous model~\cite{DLS88}. Partial synchrony comes in two versions: \textit{Unknown bounds} partial synchrony assumes an unknown bound that always holds. \textit{Global stabilization time (GST)} partial synchrony assumes the bound is initially known but only holds \textit{eventually}, \ie after some unknown time span which is modeled by the GST. The latter is often also referred to as \textit{eventual synchrony} since the system behaves exactly like a synchronous system as soon as GST is reached. Partial synchrony is popular among many BFT protocols (like PBFT) that guarantee liveness only under partial synchrony but always remain safe even when the system is asynchronous.


\begin{table}[!tbp]
	\centering
	\resizebox{\columnwidth}{!}{ 
	\begin{tabular}{*3c}
		\toprule
		System model & Bound $\delta$ exists?  & Bound holds ...\\
		\midrule

		Synchronous & known $\delta$ & always  \\

		Eventually synchronous & known $\delta$ & after unknown GST    \\
		Partially synchronous  & unknown $\delta$ & always  \\

		Asynchronous   & \multicolumn{2}{c}{unbounded } \\
		\bottomrule
	\end{tabular}
	}
\caption{Overview over different synchrony models.}
\label{table:background:synchrony}
\end{table}

\subsection{State Machine Replication and Consensus}

\textit{\ac{SMR}} is a technique for achieving fault tolerance by replicating a centralized service on several independent replicas, which emulate the service. 
Replicas agree on inputs (transactions) proposed by clients and thus ensure a consistent state and matching results. 
Such agreement is typically achieved through a consensus protocol.
% For coordinating replicas and ensuring a consistent state among them, often an agreement pattern is used, which can be finally obtained from a consensus protocol. 
A \textit{consensus} protocol guarantees that all correct participants eventually decide on the same value from a set of proposed input values. Moreover, an SMR protocol additionally requires \textit{output consolidation}: The client needs to collect at least $f+1$ matching responses from different replicas to assert its correctness. Formally, SMR should satisfy the following guarantees:

\begin{itemize}[leftmargin=1em, itemsep=.1em, parsep=.1em, topsep=.1em,partopsep=.1em]

\item \textit{Safety} (\textit{Linearizability}): The replicated service 
behaves like a centralized implementation that executes transactions atomically one at a time~\cite{castro2000phd}.

\item \textit{Liveness} (\textit{Termination}): Any transaction issued by a correct client eventually  completes~\cite{lynch1996distributed}.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{img/ViewInstanceandPBFTstages2-horizontal2.pdf}
    \caption{A simplified BFT SMR protocol model.}
    \label{fig:bft-simple}
\end{figure}

\subsection{BFT Simplified}

% \lj{Should we introduce f in this section?}
% \todo{f, voting phase, commit phase}


A BFT protocol implements \ac{SMR} in a Byzantine fault model.
To explain BFT protocols, we employ an abstract model (see \cref{fig:bft-simple}) that contains many common design aspects from BFT protocols, and we borrow some terminology from PBFT.
BFT protocols can be leaderless~\cite{borran2010leader, antoniadis2021leaderless} or work with multiple leaders~\cite{alqahtani2021bigbft, cong2018blockchain, stathakopoulou2019mir}, but most BFT protocol designs operate using a single leader. %(a restriction that we are willing to make for our simplified model and for the purpose of exposition). \todo{welche restriction?}

To implement \ac{SMR}, replicas must repeatedly agree on a block containing one or more inputs. 
We refer to one such agreement as an \textit{instance}. 
To reach agreement typically requires the successful execution of two or more \textit{protocol stages}.
The two protocol stages, {\smaller\textsc{prepare}} and {\smaller\textsc{commit}} of PBFT are shown in \cref{fig:bft-simple}.
Each protocol stage includes \textit{dissemination} of one or multiple proposals, \textit{voting} for a proposal by all replicas, and 
\textit{aggregation} of votes. 
In some protocols and stages, replicas only vote on whether aggregation was successful. 
Thus, dissemination may be omitted, as shown in the commit stage in \cref{fig:bft-simple}.
During aggregation, matching votes from different replicas are gathered to form a \textit{quorum certificate}: Quorum certificates contain votes from sufficiently many replicas to ensure that no two different values can receive a certificate; the value is now \textit{committed}.


After reaching an agreement in one instance, transactions in the decided (committed) block are ready for their \textit{execution} in all correct replicas. Subsequently, correct replicas reply back to the respective clients. 

In addition to instances, BFT protocols typically operate in logical views, where each \textit{view} describes one composition of replicas and may use a predefined leader or certain dissemination pattern.
While some protocols perform all stages of different instances in one view as long as agreement can be reached, as is shown in \cref{fig:bft-simple}, other protocols change the view for every stage or instance.
To change the view requires a \textit{view change} mechanism.
If not sufficiently many replicas reach agreement, \eg due to a faulty leader, the view change mechanism can synchronize replicas, replace the protocol leader, and eventually ensure progress by installing a leader under whom agreement instances finally succeed.
During view change, replicas exchange quorum certificates to ensure that agreements from previous views are continued in the next.


% The BFT protocol operates in logical rounds. 
% A \textit{view} describes the composition of replicas for a round and who is leader. Moreover, a view that allows progress (\ie under a correct leader) can be reused for many rounds. In each round, replicas employ an \textit{agreement pattern} to decide a block, which is usually realised as multiple stage-based voting (\ie a two phase commit rule) to secure consistency across changing views. For instance, in PBFT~\cite{castro1999practical}, these stages are \textsc{pre-prepare}, \textsc{prepare} and \textsc{commit}.
% The necessary votes are gathered from different replicas, thus forming \textit{quorums}: All quorums are sufficiently large to pair-wise intersect in at least one correct replica, thus ensuring safety (\ie consistency of decisions) among all correct replicas. 






