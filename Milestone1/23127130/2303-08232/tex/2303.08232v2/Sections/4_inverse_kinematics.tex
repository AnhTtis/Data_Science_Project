\section{Kinematics Solver} \label{sec:ik}

An optimization-based IK solver is used to compute quasi-statically stable whole-body configurations given a set of kinematic tasks. We solve the IK problem using Sequential Quadratic Programming (SQP) due to its generality and success on humanoids \cite{brossette2018multicontact, rouxel2022multicontact, beeson2015trac}. At every solve step, a desired velocity $\mathbf{v}_d\in\mathbb{R}^{n+6}$ is computed to drive the model towards a configuration that achieves the desired task objectives, where $n$ is the number of actuated degrees of freedom in the robot. Note that $\mathbf{v}_d$ represents the velocity of the solver model and is independent of the controller's velocity. The IK iteratively solves the following Quadratic Program (QP): \begin{equation}
\begin{aligned}
 \label{eq:IKQP}
    \min_{\mathbf{v}_d} \quad   & c_{\mathrm{nom}} + c_{\mathbf{J}} + c_{\mathbf{v}_d}    \\
    \textrm{s.t.} \quad         & \mathbf{v}_{min} \leq \mathbf{v}_d \leq \mathbf{v}_{max}      % \\
    % \quad                       & \mathbf{C}\mathbf{v}_d \leq \mathbf{d}
\end{aligned}
\end{equation}

The objective function terms are given by: %\vspace{1mm}

\renewcommand{\arraystretch}{1.35}
\setlength{\tabcolsep}{2.5pt}

\begin{tabular}{ll}
 Nominal Objective: & $         c_{\mathrm{nom}}    = (\mathbf{v}_d - \mathbf{v}_{\mathrm{nom}})^T  \mathbf{C}_{\mathrm{nom}}    (\mathbf{v}_d - \mathbf{v}_{\mathrm{nom}}) $ \\
 Kinematic Tasks: & $         c_{\mathbf{J}}      = (\mathbf{J}\mathbf{v}_d - \mathbf{p})^T       \mathbf{C}_{\mathbf{J}}      (\mathbf{J}\mathbf{v}_d - \mathbf{p}) $ \\
 Velocity Cost: & $   c_{\mathbf{v}_d}      = \mathbf{v}_d^T \mathbf{C}_{\mathbf{v}_d} \mathbf{v}_d$,
\end{tabular}

where the terms are given by:

\begin{itemize}
    \item $\mathbf{v}_{\mathrm{nom}}$ drives the robot to a nominal whole-body configuration, which by default is the controller's current configuration. The user can set the nominal configuration as IK's current solution as by selecting ``snap ghost'' (Fig. \ref{fig:teleop_combo}(d)), which is generally used for larger motions where the controller and IK differ significantly.
    \item $\mathbf{J} = [\mathbf{J}^T_1 \ldots \mathbf{J}^T_k]^T$ and $\mathbf{p} = [\mathbf{p}^T_1 \ldots \mathbf{p}^T_k]^T$ are the stacked Jacobian matrices and motion objectives computed as feedback terms from the kinematic tasks and $\mathbf{C_J} = \mathrm{diag}(\mathbf{w}_0, \ldots, \mathbf{w}_k)$ is a block-diagonal weight matrix, which is detailed below.
    \item $\mathbf{v}_{min}$ and $\mathbf{v}_{max}$ bound the joint velocity so the joint remains within its bounds within the update period $\Delta T$.
    % \item $\mathbf{A}$ is the linear centroidal momentum matrix \cite{orin2008centroidal} and $\mathbf{h}=\mathbf{A}\mathbf{v}_d$ is the linear momentum. $\mathbf{H}$ constrains the centroidal momentum to such that the CoM remains inside the support region.
    % \item $\mathbf{C}, \mathbf{d}$ constrain the CoM to remain in the support region during the solver tick, detailed in Sec. \ref{sec:com_constraint}.  
    \item $\mathbf{C}_{\mathrm{nom}} = 0.5\,\mathbf{I}_{n+6}$ and $\mathbf{C}_{\mathbf{v}_d} = 0.1\,\mathbf{I}_{n+6}$ are constant weight matrices.
\end{itemize}

With each solve iteration, the candidate keyframe configuration $\mathbf{q}_d$ is updated by integrating the computed velocities (Eq. \ref{ikupdate}), where $\Delta T$ is the solver update period. \begin{equation} \label{ikupdate}
    \mathbf{q}_d \leftarrow \mathbf{q}_d + \mathbf{v}_d \Delta T
\end{equation}

For kinematic task $i$, a task Jacobian $\mathbf{J}_i$ and feedback motion $\mathbf{p}_i$ are used to compute a feedback term:

\begin{itemize}
    \item Joint Position: $\mathbf{J}_i$ is a selection matrix for the joint and $\mathbf{p}_i$ is a velocity proportional to the position error.
    \item Center of Mass: $\mathbf{J}_i$ is the linear centroidal momentum matrix $\mathbf{A}$ \cite{orin2008centroidal} and the objective $\mathbf{p}_i$ is a momentum proportional to the linear position error.
    \item Taskspace Posture and Contact Point: $\mathbf{J}_i$ is the geometric Jacobian \cite{spong2020robot} of the control frame $F_p$ (Sec. \ref{sec:task_generation}). A proportional feedback law on the relative transform between $F_p$ and $F_d$ is used to compute $\mathbf{p}_i$ \cite{bullo1995proportional}.
\end{itemize}

Kinematic tasks are each assigned a weight matrix $\mathbf{w}_i = w_i \mathbf{I}_{N_i}$, where $w_i$ is computed from the task's priority given by Tab. \ref{tab:weights} and $N_i$ is the tasks's dimensionality. Note that the CoM task weight is scaled down by the robot mass $m$ so feedback is only dependent on kinematic quantities. For Taskspace Posture, Center of Mass and Contact Points, a selection matrix $\mathbf{S}_i$ is used to only provide feedback for the constrained axes. This is done by premultiplying both the Jacobian and objective by $\mathbf{S}_i$.

\renewcommand{\arraystretch}{1.2}
\begin{table}[t!]
\centering
\captionof{table}{Kinematic Task Weights} \label{tab:weights} 
\begin{tabular}{ c c c c } 
 \hline
 & Soft & Mid & Hard \\ 
 \hline
Taskspace Posture & 0.1 & 1.0 & 10.0 \\ 
CoM & $0.01/m$ & $0.1/m$ & $1.0/m$ \\ 
Joint Position & 0.1 & 1.0 & 10.0 \\ 
Contact Point & 50.0 & 200.0 & 500.0 \\ 
 \hline
\end{tabular}
\end{table}

\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{Figures/FeasibilityComboFigure2.PNG}
    \caption{(a) Contact anchor color indicates whether a contact is removable. The operator can select a contact and preview the CoM region in the absence of the contact. The CoM region shown is a preview with the right arm contact removed, which is currently infeasible. The preview robot turns red if a keyframe is invalid (b) or yellow if the keyframe transition is invalid. In (c), although the keyframe is valid, the keyframe transition requires the CoM to leave the CoM feasible region before placing the left hand. (d) Actuation feasibility can be visualized by a force polytope at contact points and by indicating joint torque saturation. In this figure the right knee and elbow are a darker shade, indicating they are close to torque saturation.}
    \label{fig:feasibility}
\end{figure*}

% Following the approaches by Bretl et al. \cite{bretl2008testing} and Orsolino et al. \cite{orsolino2020feasible}, we compute a feasible 

% The vector $\boldsymbol{\rho} = [\rho_{00} \ldots \rho_{N_cm}]^T$ is the stacked set of basis vector multipliers of the $N_c$ contact points. The static equilibrium feasibility condition is given by

% \begin{equation} \label{eq:StaticFeasibility}
% \begin{aligned}
%     \exists \boldsymbol{\rho}   \quad   &    \\
%     \textrm{s.t.}               \quad   &  \boldsymbol{\rho} > 0  \\
%                                 \quad   &  
% \end{aligned}
% \end{equation}



% The CoM constraint region used to compute $\mathbf{H}$ is computed by imposing friction \cite{bretl2008testing} and actuation \cite{orsolino2020feasible} constraints. The region is approximated by solving a series of Linear Programs in which friction and actuation limits are imposed as inequality constraints on contact forces. To model the actuation constraints for a contact point $i$, a force polytope $\mathscr{P}_i$ is computed which represents the set of actuation-consistent forces at the contact point \cite{chiacchio1997force}:

% \begin{equation}
%     \mathscr{P}_i = \{ \mathbf{f}_i \in \mathbb{R}^3 \; | \; \underline{\mathbf{\tau}} \leq \mathbf{J}^T \mathbf{f}_i \leq \bar{\mathbf{\tau}} \}
% \end{equation}

% Where $\underline{\mathbf{\tau}}$ and $\bar{\mathbf{\tau}}$ are the lower and upper torque bounds along the contacting limb and $\mathbf{J}$ is the Jacobian of the contact point. We compute the vertices of the force polytope by projecting each actuation limit $\mathbf{\tau}_{lim}$ using the pseudoinverse of the contact Jacobian to get the corresponding force $\mathbf{f}_{lim}$.

% \begin{equation}
%     \mathbf{f}_{lim} = (\mathbf{J}^T)^{\dagger} \mathbf{\tau}_{lim}
% \end{equation}

% For a limb with $n$ joints, the force polytope is backed out by iterating over each permutation of the $2^{n}$ values of $\tau_{lim}$.
