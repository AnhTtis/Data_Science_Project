\section{Feasibility Estimation} \label{sec:feasbility}

% During teleoperation, visual cues inform the operator of keyframe feasibility (Fig. \ref{fig:feasibility}). This visual feedback is based on three motion feasibility checks: contact removal feasibility, keyframe configuration feasibility and keyframe transition feasibility.

During teleoperation, motion feasibility is assessed for the candidate keyframe and keyframe transition. In \ref{sec:com_feas} we present our approach for assessing the CoM stability margin \cite{bretl2008testing, orsolino2020feasible} based on the preview robot's state. In \ref{sec:interpolation} we present our method for anchor-based kinematic interpolation. In \ref{sec:feasibility_visualization} we then present our approach for visual feasibility cues which are based on three motion feasibility checks: contact removal feasibility, keyframe configuration feasibility and keyframe transition feasibility.

\subsection{CoM Stability Margin} \label{sec:com_feas}

The set of contact point anchors describes the candidate keyframe's contact state. A contact anchor $i$ is parameterized by a contact point position $\mathbf{r}_i$, contact normal $\mathbf{n}_i$ and contact force $\mathbf{f}_i$. The jointspace rigid body equations of motion \cite{featherstone2014rigid} for the quasi-static case of $\mathbf{\ddot{q}} \approx \mathbf{\dot{q}} \approx \mathbf{0}$ are given by:
\begin{equation}\label{eq:static_eq_eom}
    \mathbf{G} - \boldsymbol{\tau} = \sum_{i=1}^{N_c} \mathbf{J}^T_{c,i} \mathbf{f}_i = \mathbf{J}^T_c \mathbf{f} \,.
\end{equation} 
Where $N_c$ is the number of contact points, $\mathbf{G}$ is the gravitational torque vector, $\boldsymbol{\tau}$ are the set of joint torques, and $\mathbf{J}_{c,i}\in \mathbb{R}^{3\times n}$ is the Jacobian for contact $i$. A stacked contact Jacobian $\mathbf{J}_c$ and force vector $\mathbf{f}$ are used for brevity. For a given keyframe, static equilibrium is expressed as the feasibility problem:
%
% The friction cone at a contact point is modeled with the conventional polyhedral approximation \cite{koolen2016design, orsolino2020feasible}, consisting of $m$ basis vectors $\boldsymbol{\beta}_{ij}$, $j=\{1\ldots m\}$ with corresponding basis vector multipliers $\rho_{ij}$. Contact point $i$ has a contact force

% \begin{equation}
%     \mathbf{f}_i = \sum_{j=1}^m \rho_{ij} \boldsymbol{\beta}_{ij} \,.
% \end{equation}
%
\begin{equation} \label{eq:StaticFeasibility}
\begin{aligned}
    \exists \, \mathbf{f} \;\; \textrm{s.t.}   \quad &  \mathbf{f}_i \in \mathscr{K}_i  \\
                                            \quad &   \sum_i \mathbf{f}_i = -m\mathbf{g} \\ 
                                            \quad &   \sum_i \mathbf{r}_i \times \mathbf{f}_i = -\mathbf{c} \times (m\mathbf{g}) \\
                                            \quad &   \mathbf{G} - \boldsymbol{\tau}^{+} \leq \mathbf{J}^T_c\mathbf{f} \leq \mathbf{G} - \boldsymbol{\tau}^{-},
\end{aligned}
\end{equation}
where $\mathscr{K}_i$ is the friction cone of contact $i$, $\mathbf{g} = (0,0,-9.81)^T$ is gravitational acceleration, $\mathbf{c}$ is the CoM position and $\boldsymbol{\tau}^{-}, \boldsymbol{\tau}^{+}$ are the lower and upper joint torque bounds. The standard linearized friction model \cite{bouyarmane2018multi} is used so that Eq. \ref{eq:StaticFeasibility} contains only linear constraints. Using this set of linear constraints, we compute the preview robot's CoM stability margin using the Iterative Projection algorithm introduced by Bretl et al. \cite{bretl2008testing}. This approach recursively solves a Linear Program to compute maximal CoM displacements along a set of query directions (see Appendix for details on region calculation). If the preview robot's CoM is inside this region, it indicates the posture is quasi-statically stable with respect to friction and actuation constraints.

%%%% TODO

% Otherwise, the CoM is constrained to remain inside the feasible region. CoM $xy$ displacement is expressed as a function of the centroidal mass momentum matrix $\mathbf{A}\in \mathbb{R}^{6 \times (n+6)}$ \cite{orin2008centroidal}, which maps $\mathbf{v}_d$ to centroidal momentum. A selection matrix $\mathbf{S}_{xy}$ selects the linear $xy$ momentum components.
% \begin{equation}
%     \mathbf{c}_{k+1} - \mathbf{c}_k = \mathbf{S}_{xy}\mathbf{Av}_d \Delta T,
% \end{equation}
% Where $\mathbf{c}_k$ is the $xy$ position of the CoM for tick $k$. For each support region vertex $h_i$ and corresponding edge normal $h^{\perp}_i$ (Fig. \ref{fig:CoMConstraintFig}), the CoM feasibility constraint is: \begin{equation}
%     (h_i - (\mathbf{c}_k + \mathbf{Av}_d \Delta T)) \cdot h^{\perp}_i \geq 0 \,\,.
% \end{equation} 
% The constraints of each vertex are stacked into $\mathbf{C}$ and $\mathbf{d}$ in order to constrain the CoM to remain in the feasible region.

% \begin{figure}
%     \centering
%     \includegraphics[width=0.54\columnwidth]{Figures/CoMConstraintFig.PNG}
%     \caption{The solver maintains static equilibrium by computing a feasible CoM region and imposing geometric constraints as a function of edge vertices $h_i$ and edge normals $h^{\perp}_i$.}
%     \label{fig:CoMConstraintFig}
% \end{figure}

\subsection{Kinematic Interpolation} \label{sec:interpolation}

% Interpolation between two keyframes is achieved by blending the weights and setpoints of the two sets of kinematic tasks and performing.

Kinematic interpolation is done by computing a set of intermediate whole-body configurations that smoothly blend the kinematic task sets between two consecutive keyframes $K_0$ (start) and $K_1$ (end). To do this, each kinematic task is assigned a corresponding task on the opposite side of interpolation. While this is trivial for tasks expressed in both $K_0$ and $K_1$, we create additional ``placeholder'' tasks for those only present in $K_0$ or $K_1$. The placeholder task corresponding to task $T$ is given zero weight and a setpoint equal to $T$ expressed in the opposite keyframe. For example, if a taskspace posture task for the hand is present in $K_0$ but not $K_1$, the placeholder setpoint is the frame $F_p$ on the hand expressed in $K_1$.

The intermediate configurations are computed by interpolating along discrete, evenly-spaced points parameterized by a phase variable $s = \frac{i}{N_I+1}, i = \{1, 2, ..., N_I\}$. Kinematic task weights are interpolated using the formula:
\begin{equation}
    w(s) = w_0 (1-s)^{\alpha_0} + w_1 s ^ {\alpha_1},
\end{equation}
where $w_0$ and $w_1$ are the kinematic task's weight at the start and end of interpolation and $\alpha_0$, $\alpha_1$ are tuning parameters. Kinematic task setpoints are interpolated linearly for spatial and joint positions. Orientation setpoints are interpolated using Spherical Linear Interpolation (Slerp) \cite{shoemake1985animating}. Additionally, for joints that do not contain a nominal task we create a joint position task to bias the start and end of interpolation to match the keyframe configurations with a fixed bias weight of $w_b=1.5$ and tuning exponent $\alpha=6$. In all other cases, weights are interpolated linearly with $\alpha=1$.

We find that a value $N_I=12$ is sufficient for validating transitions between consecutive keyframes due to sufficient resolution while still yielding a fast computation time of 77ms (see Tab. \ref{tab:timing}). For $N_I=12$, we observe an average deviation of 2mm for contacting links and 4mm for non-contacting links when compared to interpolating at significantly higher values of $N_I$. 

Contact switches occur at either the start or end of interpolation. Therefore, the active set of contact points during interpolation are contact points present in both $K_0$ and $K_1$.

\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{Figures/ResultsComboFig.jpg}
    \caption{Experiment 1 (simulation): the robot was teleoperated from an initial crouching stance to standing with handholds available in front and to the left of the robot. Experiment 2 (hardware): a modification of the experiment 1 script was deployed to a physical Valkyrie robot. The robot places both hands on the cinder blocks and lifts the right knee to place the right foot on the ground. Experiment 3 (simulation): the robot braces against a wall using the forearm and swings the left foot over an obstacle.}
    \label{fig:results_combo}
\end{figure*}

\subsection{Feasibility Visualization} \label{sec:feasibility_visualization}

To compute if a contact is removable, a modified feasible CoM region is computed with the given contact removed. A contact is considered removable only if the CoM is contained in the modified feasible region. Removability is continuously updated for all contacts as the keyframe configuration changes and non-removable contacts are marked visually and cannot be removed. The operator can select a contact and preview the CoM feasible region if it were removed in order to adjust the CoM accordingly before removing a contact as shown in Fig. \ref{fig:feasibility}(a).

The candidate keyframe and the $N_I$ interpolated configurations are checked for kinematic and static feasibility. Each of the $(1 + N_I)$ configurations has the following checks:

\begin{itemize}
    \item Kinematics-Statics solver (Eq. \ref{eq:IKQP}) cost converges such that successive costs are within a bound $\epsilon_{ik} = 10^{-5}$.
    \item Contact point anchors track with a bound $\epsilon_c=10^{-3}$\si{\meter}.
    \item The feasible CoM region contains the CoM, indicating friction and actuation constraints are statically achieved.
    \item Configuration has no environment collisions among non-contacting links.
\end{itemize}

The preview robot color is modified to reflect whether the candidate keyframe or transition is infeasible. In the event the preview robot is near actuation limits, the operator is also aided by visual cues to determine the joint that is actuation-limited and how to adjust the posture (Fig. \ref{fig:feasibility}(d)). Given the candidate keyframe's contact state, a static force distribution $\mathbf{f}_g$ is computed (see Appendix for details). The corresponding joint torques $\boldsymbol{\tau}_g$ are computed from Eq. \ref{eq:static_eq_eom}:
\begin{equation}\label{eq:static_torques}
    \boldsymbol{\tau}_g = \mathbf{G} - \mathbf{J}^T_c \mathbf{f}_g.
\end{equation}
The color of joint position anchors is updated so that elements of $\boldsymbol{\tau}_g$ near the torque bounds are colored red to alert the operator.
The force polytope $\mathscr{P}_i$ at a contact anchor $i$ can also be visualized, given by \cite{chiacchio1997force}: 
\begin{equation}
    \mathscr{P}_i = \{ \mathbf{f}_i \in \mathbb{R}^3 \; | \; \boldsymbol{\tau}^{-} \leq \mathbf{J}_{c,i}^T \mathbf{f}_i \leq \boldsymbol{\tau}^{+} \} \,.
\end{equation}
This can be useful if the polytope's ``major axis'' has an intuitive preferred orientation, such as vertical when contacting the ground or horizontal when bracing against a wall. 

% To compute joint torque margin, we first solve for an optimal force distribution at the candidate keyframe:
% \begin{equation} \label{eq:ForceDistribution}
% \begin{aligned}
%     \min_{\mathbf{f}} \; \lvert\lvert \mathbf{f} \rvert\rvert ^2 \;\; \textrm{s.t.}   \quad &  \mathbf{A}_{f} \mathbf{f} = \mathbf{b}_{f} - \mathbf{A}_c\mathbf{c}_{xy}  \\
%                         \quad &  \mathbf{C}_{f} \mathbf{f} \leq \mathbf{d}_f
% \end{aligned}
% \end{equation}

% Eq. \ref{eq:ForceDistribution} is a reformulation of Eq. \ref{eq:feasible_region} with $\mathbf{c}_{xy}$ fixed at the keyframe's CoM. 