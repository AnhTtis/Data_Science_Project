\section{INVERSE KINEMATICS SOLVER} \label{sec:ik}

% Should be short overview, this isn't the focus of the paper but is necessary to explain the UI elements, etc.

% Outline of IK:
% - Explain robot terminology, q/v, etc. (maybe skip)
% - Explain sequential quadratic program approach
% - Go through QP configuration
%   > Priveleged configuration
%   > Momentum constraint
%   > Collision checking
%   > Velocity regularization
%   > Joint limits 
%   > Spatial velocities
%   > Joint velocities
%   > CoM feedback

An optimization based inverse kinematics solver is used to compute whole-body configurations based on the operator's input. We solve the IK problem using sequential quadratic programming (SQP) due to its generality and success on humanoids \cite{fallon2015architecture, beeson2015trac}. The IK iteratively solves the following quadratic program (QP):

\begin{equation} \label{eq:IKQP}
\begin{aligned}
    \min_{\mathbf{v}_d} \quad   & c_{\mathrm{nom}} + c_{\mathbf{J}} + c_{\mathbf{v}_d}    \\
    \textrm{s.t.} \quad         & \mathbf{v}_{min} \leq \mathbf{v}_d \leq \mathbf{v}_{max}      \\
    \quad                       & \mathbf{A}\mathbf{v}_d \leq \mathbf{H}
\end{aligned}
\end{equation}

The objective function terms are given by: \vspace{1mm}

\renewcommand{\arraystretch}{1.35}
\setlength{\tabcolsep}{2.5pt}

\begin{tabular}{ll}
 Nominal Objective: & $         c_{\mathrm{nom}}    = (\mathbf{v}_d - \mathbf{v}_{\mathrm{nom}})^T  \mathbf{C}_{\mathrm{nom}}    (\mathbf{v}_d - \mathbf{v}_{\mathrm{nom}}) $ \\
 Kinematic Objective: & $         c_{\mathbf{J}}      = (\mathbf{J}\mathbf{v}_d - \mathbf{p})^T       \mathbf{C}_{\mathbf{J}}      (\mathbf{J}\mathbf{v}_d - \mathbf{p}) $ \\
 Velocity Cost: & $   c_{\mathbf{v}_d}      = \mathbf{v}_d^T \mathbf{C}_{\mathbf{v}_d} \mathbf{v}_d$
\end{tabular}
\\

Where the terms are given by:
\begin{itemize}
    \item $\mathbf{v}_d$ is the vector of desired joint velocities % and $\mathbf{q}$ is the corresponding vector of joint positions.
    \item $\mathbf{v}_{\mathrm{nom}}$ drives the robot to a nominal whole-body configuration.
    \item $\mathbf{J} = [\mathbf{J}^T_1 \ldots \mathbf{J}^T_k]^T$ and $\mathbf{p} = [\mathbf{p}^T_1 \ldots \mathbf{p}^T_k]^T$ are the stacked Jacobian matrices and motion objectives computed as feedback terms from desired kinematic objectives, which is detailed below.
    \item $\mathbf{v}_{min}$ and $\mathbf{v}_{max}$ bound the joint velocity. A nominal set of bounds are used unless a joint is near a limit, in which case the velocity is constrained such that the joint remains within its range of motion within the update tick $\Delta T$.
    \item $\mathbf{A}$ is the linear centroidal momentum matrix \cite{orin2008centroidal} and $\mathbf{h}=\mathbf{A}\mathbf{v}_d$ is the linear momentum. $\mathbf{H}$ constrains the centroidal momentum to such that the CoM remains inside the support region.% during the update tick.
    \item $\mathbf{C}_{\mathrm{nom}}$, $\mathbf{C}_{\mathbf{J}}$, and $\mathbf{C}_{\mathbf{v}_d}$ are positive diagonal weight matrices.
\end{itemize}

The term \textit{controller robot} denotes the real or simulated robot running a controller and the term \textit{puppet robot} denotes the model which the inverse kinematics solver updates (due to its role in the interface, see Sec. \ref{sec:vrui}).
The puppet model initializes to the controller robot's current configuration and the QP in Eq. (\ref{eq:IKQP}) is iteratively solved until the cost term converges or a maximum number of iterations is reached. With each iteration, the puppet model is updated by integrating the computed velocities according to Eq. (\ref{ikupdate}).

\begin{equation} \label{ikupdate}
    \mathbf{q} \leftarrow \mathbf{q} + \mathbf{v}_d \Delta T
\end{equation}

\subsection{Motion Tasks}

A set of motion tasks are computed from the desired kinematic tasks. The motion task with index $i$ is given by:

\begin{equation}
    \mathbf{J}_i \mathbf{v}_d = \mathbf{p}_i
\end{equation}

A motion objective $\mathbf{p}_i$ is computed from a feedback controller on a desired kinematic task. Kinematic tasks consist of:

\begin{itemize}
    \item Joint position, in which $\mathbf{J}_i$ is a selection matrix for the joint and $\mathbf{p}_i$ is a velocity towards a desired position.
    \item Center of Mass (CoM) of the robot, in which a desired CoM position in world is specified. The Jacobian is the linear centroidal momentum matrix $\mathbf{A}$ and the objective $\mathbf{p}_i$ drives towards the desired CoM position.
    \item Spatial pose of a rigid body, in which a desired position and orientation in world and corresponding frame fixed to the rigid body are specified. A proportional feedback law on the error transform is used to compute $\mathbf{p}_i$ \cite{bullo1995proportional}.
    \item Environment collision avoidance, in which $\mathbf{J}_i$ is the jacobian of a detected collision point and $\mathbf{p}_i$ is a velocity separating the collision.
\end{itemize}

For the CoM and spatial pose tasks, a selection matrix $\mathbf{S}_i$ can be used to constrain certain spatial components of a task. This is done by premultiplying both the Jacobian and objective by $\mathbf{S}_i$. Motion tasks have a corresponding weight matrix $\mathbf{w}_i$, such that $\mathbf{C}_{nom}$, $\mathbf{C}_{J}$ and $\mathbf{C}_{\mathbf{v}_d}$ have the block-diagonal form:

\begin{equation}
\mathbf{C} = \mathrm{diag}(\mathbf{w}_0 , \ldots , \mathbf{w}_k)    
\end{equation}

This formulation is adopted from \cite{koolen2016design}, which details the calculation of motion objectives and feedback controllers.

\subsection{Environment and Collision Modelling}

Robot and environment collision meshes are modelled as a set of convex polytopes and the environment polytopes are assumed to be known. Robot polytopes are attached to a corresponding rigid body and environment polytopes are fixed in world. The Expanding Polytope Algorithm (EPA) is used to check for collisions between pairs of polytopes \cite{van2003collision}. This algorithm provides additional data such as nearest points in the absence of a collision and maximum penetrating points in the presence of a collision. During each iteration of the IK all pairs of robot and environment meshes are checked for collisions. Any detected collision is converted to a high-weight feedback command which separates the colliding meshes. % within the update tick. 
% A collision vector $\mathbf{z}_c$ is computed as the difference between the maximum penetrating points, such that moving the rigid body by this offset will separate the polytopes.

\subsection{CoM Constraint Region and Contact Force Polytopes}

The CoM constraint region used to compute $\mathbf{H}$ can be constructed by either a simple flat ground contact model or by including the environment mesh in the contact model. For the flat ground model, the CoM is constrained to the convex hull of the robot's contact points. For scenarios where the robot is not in flat ground contact, the IK can compute a generalized support region. This constraint region follows the approach by Bretl et al. \cite{bretl2008testing} to compute a friction-consistent region and its extension in \cite{orsolino2020feasible} to include actuation constraints. The region is approximated by solving a series of Linear Programs in which friction and actuation limits are included as inequality constraints. To model the actuation constraints for a contact point $i$, a force polytope $\mathscr{P}_i$ is computed which represents the set of actuation-consistent forces at the contact point \cite{chiacchio1997force}:

\begin{equation}
    \mathscr{P}_i = \{ \mathbf{f}_i \in \mathbb{R}^3 \; | \; \underline{\mathbf{\tau}} \leq \mathbf{J}^T \mathbf{f}_i \leq \bar{\mathbf{\tau}} \}
\end{equation}

Where $\underline{\mathbf{\tau}}$ and $\bar{\mathbf{\tau}}$ are the lower and upper torque bounds along the contacting limb and $\mathbf{J}$ is the Jacobian of the contact point. We compute the vertices of the force polytope by projecting each actuation limit $\mathbf{\tau}_{lim}$ using the pseudoinverse of the contact Jacobian to get the corresponding force $\mathbf{f}_{lim}$.

\begin{equation}
    \mathbf{f}_{lim} = (\mathbf{J}^T)^{\dagger} \mathbf{\tau}_{lim}
\end{equation}

For a limb with $n$ joints, the force polytope is backed out by iterating through each permutation of the $2^{n}$ values of $\tau_{lim}$. In addition to being used to compute the CoM constraint region, the contact force polytopes are provided as visual cues to the operator.

% Info on feasible region. Most is a recapitulation of other work, prob don't need to include?

% The set of feasible CoM positions $\mathscr{C}$ is given by:

% \begin{equation} \label{eq:support_region}
% \begin{aligned}
%     \mathscr{C} = \Bigl\{ \mathbf{c}_{xy} \; |  & \; \mathbf{A}_1 \mathbf{f} + \mathbf{A}_2 \mathbf{c}_{xy} = \mathbf{g}      \\
%                                                 & \; \mathbf{B}\mathbf{f} \leq \mathbf{0}, \,\; \mathbf{G}\mathbf{f} \leq \mathbf{d} \Bigr\}  \\
% \end{aligned}
% \end{equation}

% Where $\mathbf{c}_{xy}$ is the CoM xy position. Static equilibrium is enforced through $\mathbf{A}_1$, $\mathbf{A}_2$ and $\mathbf{g}$ enforce static equilibrium, 