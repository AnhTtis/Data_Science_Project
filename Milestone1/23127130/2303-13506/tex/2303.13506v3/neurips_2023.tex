\documentclass{article}










   \usepackage[final, nonatbib]{neurips_2023}


\usepackage[utf8]{inputenc} %
\usepackage[T1]{fontenc}    %
\usepackage{hyperref}       %
\usepackage{url}            %
\usepackage{booktabs}       %
\usepackage{amsfonts}       %
\usepackage{nicefrac}       %
\usepackage{microtype}      %
\usepackage{xcolor}         %

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{bbm}
\usepackage{bm}
\newcommand{\R}{\mathbb{R}}
\newcommand{\mat}[1]{\mathbf{#1}}
\usepackage{graphicx}
\usepackage{tcolorbox}
\usepackage{cleveref}



\usepackage[maxcitenames=2, maxbibnames=99, sorting=none]{biblatex}
\addbibresource{refs.bib}

\definecolor{midnightblue}{rgb}{0.1, 0.1, 0.44}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linktoc = all,
    citecolor=midnightblue,
    filecolor=black,
    linkcolor=midnightblue,
    urlcolor=black
}

\usepackage{tcolorbox}
\definecolor{lightred}{RGB}{255,175,175}  %
\definecolor{lgray}{RGB}{220,220,220}
\newtcbox{\tok}[1][white]{
  on line,
  arc=0pt,
  outer arc=0pt,
  colback=#1,
  colframe=lgray,
  boxsep=0pt,
  boxrule=0.2pt,
  left=0.05pt,
  right=0.05pt,
  top=0.05pt,
  bottom=0.05pt,
  height=7pt,  %
  valign=center  %
}

\newtcbox{\ttok}[1][white]{
  on line,
  arc=0pt,
  outer arc=0pt,
  colback=#1,
  colframe=lgray,
  boxsep=0pt,
  boxrule=0.3pt,
  left=0.1pt,
  right=0.1pt,
  top=0.1pt,
  bottom=0.1pt,
  height=10pt,  %
  valign=center  %
}

\DeclareUnicodeCharacter{2009}{\,}
\DeclareUnicodeCharacter{0097}{}

\title{The Quantization Model of Neural Scaling}




\author{%
  Eric J. Michaud\thanks{ericjm@mit.edu}, Ziming Liu, Uzay Girit, and Max Tegmark\\
  MIT \& IAIFI
}


\begin{document}


\maketitle


\begin{abstract}
We propose the \emph{Quantization Model} of neural scaling laws, explaining both the observed power law dropoff of loss with model and data size, and also the sudden emergence of new capabilities with scale. 
We derive this model from what we call the \emph{Quantization Hypothesis}, 
where network knowledge and skills are ``quantized'' into discrete chunks (\emph{quanta}).
We show that when quanta are learned in order of decreasing use frequency, then a power law in use frequencies explains observed power law scaling of loss. We validate this prediction on toy datasets, then study how scaling curves decompose for large language models. 
Using language model gradients, we automatically decompose model behavior into a diverse set of skills (quanta). 
We tentatively find that the frequency at which these quanta are used in the training distribution roughly follows a power law corresponding with the empirical scaling exponent for language models, a prediction of our theory.\footnote{Project code can be found at: \url{https://github.com/ejmichaud/quantization-model}.}
\end{abstract}


\section{Introduction}




In the aggregate, larger neural networks trained on more data perform better than smaller neural networks trained on less data, in a predictable way. Across a range of studies, mean test loss has been observed to decrease as a power law in both the number of network parameters ($L \propto N^{-\alpha_N}$) and the number of training samples ($L \propto D^{-\alpha_D}$) \parencite{hestness2017deep, rosenfeld2019constructive, kaplan2020scaling, henighan2020scaling, gordon2021data, zhai2022scaling, hoffmann2022training}. Although aggregate performance changes smoothly with scale, when particular capabilities are examined, larger models often have emergent abilities, i.e., qualitatively different performance than smaller models~\parencite{wei2022emergent, Steinhardt2022}. Understanding and reconciling both facets of scaling -- the predictable power law decrease in loss and the emergence of new capabilities at scale -- is of both theoretical and practical interest~\parencite{ganguli2022predictability}. Understanding how scaling changes what neural networks learn is entangled with core questions: what are deep neural networks doing internally, and will they will continue to improve with scale?

Recent studies of the internals of neural networks have found a variety of impressive algorithms learned by gradient descent~\parencite{olah2020zoom, cammarata2020curve, nanda2023progress, li2022emergent, wang2022interpretability}. As more work is put into understanding the structures learned by neural networks (the task of \textit{mechanistic interpretability}), we may find more and more \emph{circuits}~\parencite{olah2020zoom, elhage2021mathematical} in models, intelligible internal algorithms for accomplishing prediction in specific contexts. Can such analysis be scaled up to frontier models~\parencite{lieberum2023does}? Two assumptions which, if true, would make us more optimistic about mechanistically understanding large models include (1) decomposability/modularity/sparsity~\parencite{casper2022graphical, bricken2023monosemanticity, frankle2018lottery, bayazit2023discovering} -- that large models are decomposable into parts, and only a small number of these parts are relevant to the model's behavior on any given sample and (2) universality~\parencite{liConvergentLearningDifferent2016a, olah2020zoom, nguyenWideDeepNetworks2021, dravidRosettaNeuronsMining2023} -- that similar structures recur across models of increasing size. Recently, \textcite{olsson2022context} found encouraging evidence for universality of ``induction heads'' across LLMs and found that these emerge in a discrete transition during training.

In this paper, we articulate the \emph{Quantization Hypothesis}, a set of informal conjectures about the \emph{decomposability} of networks into smaller parts, the \emph{universality} of computations performed across model scales, the \emph{discreteness} of what models learn, and about how properties of the data distribution produce power law neural scaling. In particular, we hypothesize that to many prediction problems, there corresponds a particular enumerable set of indivisible pieces of knowledge or skills that models must learn, and that model performance is determined by \emph{which} of these elements models successfully learn. We call these basic building blocks of model performance the \textbf{quanta}:
\begin{center}
\begin{tcolorbox}[colframe=black, boxrule=1pt, colback=white, width=0.80\textwidth]
\textbf{Quantum (plural quanta)}: An indivisible computational module that, for example, retrieves a fact, implements an algorithm, or more generally corresponds to some basic skill possessed by a model.
\end{tcolorbox}
\end{center}

\begin{figure}[t!]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\fontsize{10}{10}\selectfont\rule{0pt}{2.25ex}\textbf{LLM skill ``quanta'' auto-discovered in text}} \\
        \hline
        \multicolumn{1}{|c|}{\fontsize{8}{10}\selectfont\textbf{Cluster 50}: incrementing numerical sequences} & \multicolumn{1}{c|}{\fontsize{8}{10}\selectfont\textbf{Cluster 100}: predicting newlines in line length limited text} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster50}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster100}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{
        We auto-discover \emph{quanta} -- basic units of model knowledge/skill -- for a language model. Here we show collections of next-token prediction samples which our method clustered together, each corresponding to some coherent model behavior. We indicate the token which was predicted from the context before it with a red highlight.
        We indicate newlines using ``\texttt{\textbackslash n}''. See~\Cref{sec:llm-quanta-discovery} for explanation.
    }
    \label{fig:cluster-examples}
\end{figure}

We use this terminology in analogy to Max Planck's assumption in 1900 that energy is quantized into discrete chunks (quanta) -- here we imagine that knowledge/skills are quantized into discrete chunks (quanta). Since ``quantization'' is commonly used in machine learning in the context of low-precision arithmetic, we suggest ``knowledge quantization'' or ``skill quantization'' to refer to our notion of quantization. We will see that a Zipfian distribution governing the ``use frequency'' of the quanta produces power law neural scaling, where the effect of scaling is to learn an increasing number of discrete quanta, and smooth scaling laws average over small discrete jumps in model performance.

This paper is organized as follows: in~\Cref{sec:THEORY} we give a theoretical model of power law neural scaling from the Quantization Hypothesis. In \Cref{sec:SPARSEPARITY} we construct toy datasets satisfying the hypothesis, where smooth power laws average over many discrete jumps in model performance. In \Cref{sec:llms} we then analyze how power law scaling decomposes for real LLMs. In \Cref{sec:llm-quanta-discovery}, we develop a method for automatically discovering quanta in language models by clustering their behavior into basic coherent skills, and analyze the statistics of these clusters, concluding in \Cref{sec:discussion}.
















































    


    
   
    


\section{Theory}\label{sec:THEORY}






    

Consider the task of modeling the distribution of text on the internet. Successful prediction requires an immense amount of knowledge, and the ability to perform diverse computations, due to the immense complexity and diversity of the world and therefore of human language. For instance, in order to predict what word will come next in a conversation between two physicists, one must ``know'' much about physics. In order to continue the text \mbox{``\texttt{2534 + 7261 = }''}, one must be able to perform arithmetic (for large enough numbers, memorization becomes a highly inefficient strategy)~\cite{branwen2021scaling}. A great many distinct types of computations are present in the world in the processes that \emph{produce} text, and so \emph{predicting} text requires those computations to be present in our models.

In this paper, we conjecture the Quantization (or Quanta) Hypothesis:
\begin{center}
\begin{tcolorbox}[colframe=black, boxrule=1pt, colback=white, width=0.95\textwidth]
\begin{enumerate}
    \item[QH1] Many natural prediction problems decompose into an enumerable set of computations, pieces of knowledge, or skills, which models must learn to reduce loss. We call these \textbf{quanta}, and model them as being \emph{discrete}, -- they are either learned or not learned. Model performance is determined by \emph{which} quanta have been learned.

    \item[QH2] Some quanta are more useful for reducing loss than others, leading to a natural ordering of the quanta. We call the ordered quanta the \textbf{Q Sequence}. Optimally trained networks should therefore learn the quanta in that order. The effect of scaling is to learn \emph{more} of the quanta in the Q Sequence, so scaling performance is simply determined by \emph{how many} quanta are successfully learned. 
    
    \item[QH3] The frequencies at which the quanta are used for prediction follow a power law.

\end{enumerate}
\end{tcolorbox}
\end{center}

\def\q{{\bf q}}

Together these can result in power law neural scaling. 
We model the Quantization Hypothesis as follows, referring to the below as the ``Quantization (or Quanta) Model''.
Let $\q$ denote a bit string whose $k^{\rm th}$ bit $\q_k=1$ if the $k^{\rm th}$ quantum in the Q Sequence has been learned, and $\q_k=0$ otherwise.
QH1 implies that the mean loss $L$ is simply a function of $\q$.
QH2 implies that when $n\equiv\sum_k \q_k$ quanta have been learned, we have $\q_k=1$ for $k\le n$. Let $L_n$ denote the mean loss in this case. From QH3, we have that the $k^{\rm th}$ quantum benefits prediction on a randomly chosen sample with probability 
\begin{equation}
p_k = \frac{1}{\zeta(\alpha+1)} k^{-(\alpha+1)}\propto k^{-(\alpha+1)}
\end{equation}
for a Zipf power law $\alpha>0$,
where $\zeta(s)\equiv\sum_{k=1}^\infty k^{-s}$.
Let us also assume that learning the $k^{\rm th}$ quantum reduces average loss from $b_k$ before it is learned to $a_k$ after it is learned on the samples where it is utilized. If $a_k$ and $b_k$ are $k$-independent ($a_k=a$, $b_k=b$), then a model that has learned the first $n$ quanta will have expected loss
\begin{eqnarray}
    L_n &=&\sum_{k=1}^n a p_k + \sum_{k=n+1}^\infty b p_k
        =\sum_{k=1}^\infty a p_k + \sum_{k=n+1}^\infty (b-a) p_k\nonumber\\
        &\approx&a + \frac{b-a}{\zeta(\alpha+1)}\int_n^\infty k^{-(\alpha+1)} dk =
    a + \frac{b-a}{\alpha\zeta(\alpha+1)}n^{-\alpha}.
\end{eqnarray}
In other words, $L_\infty=a$ and $(L_n-L_\infty)\propto n^{-\alpha}$ is a power law.

In \Cref{sec:appendix-general-scaling-laws}, we provide analogous derivations for other assumptions for $a_k$ and $b_k$, 
and find that a range of assumptions produce curves that are exact or approximate power laws -- the latter include a small logarithmic correction.


In the derivation above, we assumed that all samples are what we will refer to as 
{\it monogenic}, meaning that prediction relies on at most a single quantum, 
akin to how monogenic traits in biology (e.g.\ cystic fibrosis) depend on a single gene.
By assuming that all samples are monogenic, we can write the expected loss as a sum over quanta, weighted by the fraction of samples which rely on that quanta $p_k$. We further explore the idea of monogenic vs.\ polygenic samples in~\Cref{sec:llm-scaling-taxonomy}.
So far we have seen how the Quantization Hypothesis can produce power law scaling as a function of the number of quanta learned $n$. We will now give one possible mechanism by which this can translate into power law scaling in parameters, data, etc.:

\noindent\textbf{Parameter scaling}: In networks of finite size, network capacity can bottleneck how many quanta are learned. If we assume that all quanta require the same capacity of $C$ network parameters, then a network with $N$ parameters can learn roughly $n \approx N / C$ quanta. Therefore $L(N) - L_\infty \propto n^{-\alpha} \approx (N/C)^{-\alpha} \propto N^{-\alpha}$, we so we get power law scaling in $N$ with exponent $\alpha_N = \alpha$.

\noindent\textbf{Data scaling (multi-epoch)}: For data scaling, we assume that for each quantum, a threshold of $\tau$ examples utilizing quantum $k$ are needed in the training set for quantum $k$ to be learned\footnote{This type of threshold has precedent, e.g. for the algorithmic tasks where ``grokking'' occurs~\parencite{power2022grokking}.}. With $D$ training samples, approximately $Dp_k$ samples relying on quantum $k$ will be present, and solving for $Dp_n = \tau$ we get the last quantum to be learned will be $n \propto (D / \tau)^{1/(\alpha+1)}$ since $p_k \propto k^{-(\alpha+1)}$. Under this model, we get scaling in data samples $L(D) - L_\infty \propto n^{-\alpha} \propto \left( D / \tau)\right)^{-\alpha/(\alpha+1)} \propto D^{-\alpha/(\alpha+1)}$, and so $\alpha_D = \alpha / (\alpha + 1)$.
From our earlier result that $\alpha_N = \alpha$, we would therefore predict that $\alpha_D = \alpha_N / (\alpha_N + 1)$. We discuss whether this relationship holds empirically for data and parameter scaling exponents observed across a variety of studies in \Cref{sec:parameter-vs-data-scaling-review}.

\noindent\textbf{Data scaling (single-epoch)}: In multi-epoch training, the information contained in the training dataset can bottleneck which quanta are learned. However, the rate of convergence of SGD can also bottleneck performance. For single-epoch training, a greater number of training samples allows one to train for longer. In our model, the amount that each quantum reduces mean loss by follows a power law. If the magnitude of the gradients for learning these quanta also follow a power law, then the convergence time for each quanta may follow a power law too. If the number of steps to learn quantum $k$ is $\propto 1/p_k$, then if the first quantum requires $T$ steps to be learned, quantum $n$ will require $T n^{\alpha+1}$ steps, and so $n = (S/T)^{1/(\alpha+1)}$ quanta can be learned in $S$ steps. This gives scaling in training steps $L(S) - L_\infty \propto n^{-\alpha} \approx (S/T)^{-\alpha/(\alpha+1)} \propto S^{-\alpha/(\alpha+1)}$, and so $\alpha_S = \alpha / (\alpha + 1)$.
Under this model, multi-epoch and single-epoch data scaling exponents coincide: $\alpha_D = \alpha_S$. 























    






    
    


















\section{Proof of concept: a toy dataset}\label{sec:SPARSEPARITY}

In this section, we will describe a toy dataset consisting of distinct subtasks which are power law distributed in frequency. We observe power law neural scaling in data and parameters on this task, and find that the mechanism of neural scaling coincides with our theory from~\Cref{sec:THEORY}. It is therefore possible for scaling laws to arise from the Quantization Model for data with the right structure. We leave a study of whether natural datasets (e.g. natural modeling) possess such structure to~\Cref{sec:llms}.

    

\subsection{The ``multitask sparse parity'' dataset}

The toy task we will construct consists of many subtasks -- distinct types of inputs which each require corresponding distinct computations (quanta). For each subtask, we choose a variant of the ``sparse parity'' problem, recently studied in \cite{barak2022hidden}. The sparse parity prediction problem is simple: given a bit string of length $n$, compute the parity (sum mod 2) of a fixed subset of $k$ of those bits. We introduce an extension of this task, which we call ``multitask sparse parity''. Beyond $n$ and $k$, multitask sparse parity adds an additional parameter $n_\text{tasks}$, the number of subtasks (number of distinct versions of sparse parity) present in the dataset. To construct the task, we first choose $n_\text{tasks}$ random subsets $S_i$ of $k$ indices from $\{1, 2, \ldots, n\}$: $S_i \subset \{1, 2, \ldots, n\}$ and $|S_i| = k$, where $i = 1, 2, \ldots, n_\text{tasks}$. Input bit strings are length $n_\text{tasks} + n$. We call the first $n_\text{tasks}$ bits the \emph{control bits} and the last $n$ bits the \emph{task bits}. If control bit $i$ is active, then the parity is computed from the subset $S_i$ of the task bits. The control bits 1-hot encode the task number: on a given input, only one control bit is set to $1$ at a time -- the rest are zero. For the sample shown below, since control bit $2$ is active, the answer is the parity of the task bits $S_2 = \{2, 7\}$, which is $0$ for this input:

\begin{center}
    \includegraphics[width=0.85\textwidth]{figures/sparse-parity-diagram.pdf}
\end{center}

We impose a uniform distribution over the task bits. On the control bits, we impose a Zipfian distribution: the probability that a sample has control bit $i$ active (and therefore the parity must be computed from the subset $S_i$ of the task bits) is $\frac{1}{Z} i^{-(\alpha+1)}$ where $Z = \sum_{i=1}^{n_\text{tasks}} i^{-(\alpha+1)}$. This imposes a power law distribution over subtasks in data. Since answers are parities, this task can be treated as a binary classification problem on the subset of bit strings $\{0, 1\}^{n_\text{tasks} + n}$ where for each string all but one bit of the first $n_\text{tasks}$ bits are zero.



    




    

\subsection{Power law scaling and emergence}

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/parameters-steps-data-emergence-and-scaling-scalingtop.png}
    \caption{\textbf{Top:} Neural networks exhibit power law scaling in loss w.r.t.\ parameters $N$, training time $S$, and training samples $D$ (for multi-epoch training) when trained on the multitask sparse parity dataset. Here $\alpha = 0.4$ and we plot lines $\propto N^{-\alpha}$, $\propto S^{-\alpha/(\alpha+1)}$, $\propto D^{-\alpha / (\alpha+1)}$. \textbf{Bottom:} neural scaling broken down by subtask. Scaling behavior on individual subtasks exhibits emergence, where subtasks are suddenly learned above a particular scale. Power law neural scaling of mean test loss averages over a large number of qualitative changes in network performance (when broken down by subtask), with loss being driven to zero on an increasing number of subtasks which are power law distributed in frequency, a realization of the mechanism of neural scaling discussed in \Cref{sec:THEORY}.
    }
    \label{fig:data-parameter-parity-scaling}
\end{figure}

We train ReLU MLPs with a single hidden layer to solve this task with cross-entropy loss. The input dimension is $n_\text{tasks} + n$. We use the Adam optimizer with a learning rate of $10^{-3}$. To study scaling with respect to the number of model parameters, we train networks of varying width by sampling batches online. 
Within an individual single-epoch training run, we can study scaling in steps $S$. To study scaling with respect to multi-epoch training dataset size $D$, we use a network of sufficient width for capacity to not be a bottleneck, and for varying $D$ we sample a training set of $D$ samples and train for multiple epochs, recording model performance when mean test loss is lowest (early-stopping). 

Training dynamics on the multitask sparse parity problem are highly nontrivial -- on each individual subtask, loss follows a reverse-S curve, dropping after an initial plateau. This transition happens at different times for different subtasks, so the overall loss decreases smoothly, averaging over these transitions. See~\Cref{sec:appendix-multitask-parity} for more discussion of training dynamics.

\Cref{fig:data-parameter-parity-scaling} shows scaling curves on the multitask sparse parity problem. For the results shown, we used $n_\text{tasks} = 500$, $n = 100$, $k = 3$, $\alpha=0.4$, and a batch size of $20000$. We vary training dataset size from 1e4 to 5e6 and vary hidden-layer width from 10 to 500 neurons. We train for 2e5 steps. In line with the theory from~\Cref{sec:THEORY}, we find that as we scale training data and parameters, networks learn more and more quanta (reducing loss on more and more subtasks), roughly in order of their frequency, and that this is what drives neural scaling. 
We see that scaling w.r.t.\ parameters is noisier than data scaling, possibly due to model initialization having some influence on which quanta are learned (for our data scaling experiments, we use the same seed and same model size for all runs). We also see that for scaling on individual subtasks, there is a rough scale of data or parameters below which networks do not learn the task, and above which they do. Smooth power law scaling therefore averages over a large number of emergent changes in model performance when properly decomposed by subtask, a proof of concept that the Quantization Model can be the mechanism of neural scaling for data with the right structure. See~\Cref{sec:appendix-multitask-parity} for additional results and discussion on how the scaling exponents $\alpha_N, \alpha_S, \alpha_D$ relate to the subtask distribution power law exponent $\alpha + 1$ empirically.








    




 




\section{Decomposing LLM scaling laws}\label{sec:llms}


\begin{figure}
    \centering
    \includegraphics{figures/pythia-scaling-tripanel.png}
    \caption{\textbf{Left:} Scaling of mean test loss w.r.t.\ non-embedding parameters for the Pythia models~\cite{biderman2023pythia}. The parameter scaling exponent $\alpha_N$ is measured to be $\approx 0.083$ from the first six points along the curve (the seventh model appears to break the trend). \textbf{Center:} the distribution $p(L)$ over losses on individual samples for models of different size. Losses $\approx 0$ are by far the most common, and larger models achieve $\approx 0$ loss on an increasing fraction of samples. \textbf{Right:} the expected loss integrand $L p(L)$ for models of different sizes. Low-loss samples contribute minimal mass to the mean loss, which is instead dominated by samples with much higher loss of 5-10 bits (depending on scale).}
    \label{fig:mean-and-distribution-llm-scaling}
\end{figure}

We now study how scaling curves for large language models decompose. For our experiments, we use the Pythia model suite from Eleuther AI~\parencite{biderman2023pythia}, a set of decoder-only transformers of varying size trained on approximately 300 billion tokens of The Pile~\parencite{gao2020pile}. 
We evaluate several models in the suite (ranging from 19m to 6.4b non-embedding parameters) on approximately 10 million tokens from the test set of The Pile. We record cross-entropy loss on every token, enabling us to study how loss on individual tokens, as well as how the distribution over losses, changes with model scale. 

\subsection{The distribution over per-token losses}

In \Cref{fig:mean-and-distribution-llm-scaling}, we show how the distribution over losses scales with model size. First, we find that for the first six models in the Pythia sequence, the mean loss scales as a power law with exponent $\alpha_N = 0.083$, roughly in line with the parameter scaling exponent of $0.076$ measured in \cite{kaplan2020scaling}.
The 6.4b model does not fit the scaling curve well, so we excluded its loss when measuring the scaling exponent. Next, we plot the probability distribution over per-token losses $p(L)$. We find that losses close to zero are by far the most common, and that scaling increases the portion of approximately-zero losses. We also plot $L p(L)$, the probability density over losses weighted by loss. The mean loss is the area under this curve. We see that despite approximately-zero-loss tokens being by far the most common, they do not contribute much mass to the mean loss. See~\Cref{fig:mean-and-distribution-llm-scaling-dynamics} for how these distributions change over training steps rather than across model size.
We note that neural scaling in the wild is much more complicated than for multitask sparse parity -- notably, the distribution over losses is not bimodal. 
We leave a detailed study of whether the statistics of neural scaling in LLMs are compatible with prior models of neural scaling to future work.


\begin{figure}[t]
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{1}{|c|}{\fontsize{10}{14}\selectfont\textbf{Monogenic sample}} & \multicolumn{1}{c|}{\fontsize{10}{14}\selectfont\textbf{Polygenic sample}} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokensinghsirsa.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokensinghsirsa}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokenfruit-influx.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokenfruit-influx}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Per-sample scaling curves can have diverse behavior. Here we show extreme examples where scaling (of loss on predicting the highlighted token) is abrupt versus smooth. If the Quantization Hypothesis describes language modeling, then samples with sharp scaling would be \emph{monogenic}, displaying sharp emergence at a particular model scale when the relevant quantum is learned. Samples with gradual scaling would be \emph{polygenic}, where many quanta, emerging at different scales, marginally improve the loss. We show additional examples in~\Cref{fig:llm-diverse-scaling-behaviors-more}.
    }
    \label{fig:llm-diverse-scaling-behaviors}
    
\end{figure}

\subsection{Monogenic versus polygenic scaling curves}\label{sec:llm-scaling-taxonomy}

In our introduction of the Quantization Hypothesis in~\Cref{sec:THEORY} and our multitask sparse parity study in~\Cref{sec:SPARSEPARITY} we modeled network performance on individual samples as benefitting from a single quantum -- all samples belong to a single subtask, which is either solved or not solved in a binary fashion. In our model and on multitask sparse parity, scaling curves on individual examples all exhibit emergence -- loss on individual examples undergoes a sharp transition at a particular scale of parameters or data. Do we observe this in large language models?

Inspecting a large number of per-token (per-sample) scaling curves, we observe a variety of scaling behaviors. On some samples, loss drops at a particular scale. More typically though, loss improves at multiple scales. 
If the Quantization Hypothesis is true and the effect of scaling is to simply add new quanta to the model, then for per-sample loss curves to show progress at multiple scales, those samples must benefit from multiple quanta additively. 
As first mentioned in~\Cref{sec:THEORY}, we borrow terminology from genetics and refer to prediction problems for which the model's performance is determined by a single quantum as \emph{monogenic} (akin to when a single gene determines a trait) and as \emph{polygenic} when multiple quanta influence performance (in analogy to when multiple genes contribute to a trait).
In multitask sparse parity, all prediction problems are monogenic. 
In natural language, we observe that model performance on most tokens improves at multiple scales, suggesting that most tokens are polygenic, but we can find tokens for which loss drops as a single phase transition in scale. Polygenicity forms a spectrum: the smoothness of the loss curve can vary substantially between examples, presumably with some prediction problems using few quanta and others using many. In~\Cref{fig:llm-diverse-scaling-behaviors}, we show extreme examples of both monogenic and polygenic samples.

Note that our monogenic/polygenic taxonomy of model behaviors assumes that QH1 and QH2 are true. However, it could be the case that there isn't an underlying discreteness to what is learned, or that scaling totally changes what networks learn, rather than simply adding additional quanta. Whether scaling truly has the effect we described will have to be investigated in future studies of the internals of neural networks. We also note that it is possible that sharp transitions in the per-token loss curves could be due to noise -- if we had multiple runs with different random seeds for each model scale, we could better test whether the mean loss across seeds decreases smoothly or if there is a genuine discreteness where gradual progress is impossible for apparently ``monogenic'' tokens.

\section{The quanta of language modeling}\label{sec:llm-quanta-discovery}

We have conjectured that the internals and behavior of language models are decomposable into an enumerable set of modules and associated skills (quanta). What might these basic building blocks of LLMs be? In this section, we develop a preliminary method to discover quanta. In particular, we will attempt to cluster tokens in a language corpus according to what knowledge or skill LLMs use to predict those tokens from their context. Our goal is to find coherent clusters of language model behavior that each reveal some distinct skill that the model has learned. Note that in \emph{clustering} tokens to discover quanta, we are making the likely unrealistic assumption that these tokens are monogenic -- that there is only one quantum involved in predicting each token. Not also that these clusters of behavior will not give us a mechanistic understanding of the quanta, but simply provide examples of LLM skills which could be studied further in future work.

We propose the use of gradients to cluster next-token prediction samples, where a ``sample'' consists of a token and its context in some document. Given some model, we will cluster two samples together if the gradient of the model's loss on each sample w.r.t.\ the model's parameters is similar for the two samples. The intuition for using gradients is as follows: if a model uses the same internal module to generate its prediction on two samples, then the gradients for parameters within the module may be nonzero and similar for the two samples (and possibly $\approx 0$ for parameters in irrelevant modules). If a model uses different modules to generate its prediction on different samples, then the gradients may not overlap. We therefore use gradient similarity as a proxy for \emph{mechanistic similarity} -- whether a model uses similar mechanisms/modules to generate its prediction on distinct samples. While crude, we find that gradients contain enough information to allow us to automatically discover many coherent clusters of LLM behavior using the following algorithm:


\textbf{Quanta Discovery from Gradients (QDG)}: We will use spectral clustering on gradients to find clusters of samples whose gradient has nonzero cosine similarity. Given a set of samples $(x_i, y_i)$ and a model $f_\theta$, we compute gradients for each sample $g_i = \nabla_\theta L(f_\theta(x_i), y_i)$. We then normalize these gradients $g_i \mapsto \hat{g}_i$ so that $\hat{g}_i \cdot \hat{g}_i = 1$. Let $A$ be a matrix whose rows are the normalized gradients: $A_{i, \cdot} = \hat{g}_i$. If we are clustering $d$ samples and our model has $n$ parameters, $A$ has shape $(d, n)$. We compute an affinity matrix $C = A A^T$, a matrix of shape $(d, d)$ where $C_{ij} = \hat{g}_i \cdot \hat{g}_j$, the cosine similarity between gradients $g_i, g_j$. From this, we compute an affinity matrix of the angular similarities $\hat{C}$ (which take values in $[0, 1]$) via $\hat{C}_{ij} = 1 - \arccos(C_{ij})/\pi$. We then perform spectral clustering with $\hat{C}$ to cluster samples.

\begin{figure}[t!]
    \centering
    \includegraphics{figures/similarity-matrix-and-rank-frequency-envelope.png}
    \caption{\textbf{Left:} angular similarity between model gradients for a variety of natural language samples. Samples are reordered according to their QDG cluster (with 400 clusters) to reveal the block-diagonal structure of the similarity matrix. We visualize a small part of the overall similarity matrix in this plot -- note that not all clusters are as visibly distinct as the ones shown. 
    \textbf{Right:} rank-frequency plot of QDG clusters. We measure the slope of the envelope of the rank-frequency curves from cluster rank 100-1000 to be $\approx -1.24$, which is a steeper than the slope of -1.08 expected from the measured parameter-scaling exponent from~\Cref{fig:mean-and-distribution-llm-scaling}, though within the margin of error given the uncertainty of our clustering methodology. See~\Cref{sec:appendix-clustering-analysis} for a discussion of the bias/uncertainty of our method.}
    \label{fig:llm-similarity-and-frequency}
\end{figure}

QDG is expensive to compute for large models and for large numbers of samples. We therefore only apply it to the smallest model in the Pythia suite, which has 19m non-embedding parameters. We cluster 10000 tokens on which this model is confident and correct in its prediction, achieving less than $0.1$ nats of cross-entropy. See \Cref{sec:appendix-qdg-details} for more detail.

We find that many, though not all, QDG clusters reveal some coherent model behavior. We show examples from clusters in \Cref{fig:cluster-examples} and \Cref{fig:cluster-examples-more}. These clusters were found with the spectral clustering hyperparameter \texttt{n\_clusters = 400}. While most clusters involve the prediction of the same token, manually inspecting these clusters we find that they usually involve predicting the same token for a coherent reason, rather than being based merely on having the same output. We also find clusters for more abstract prediction rules. For instance, the quantum shown on the left column of~\Cref{fig:cluster-examples} is the skill of incrementing a numerical sequence, and the examples involve predicting a variety of different tokens representing numbers.

\subsection{The natural distribution over language modeling quanta}\label{sec:llm-subtask-distribution}

In our model, some quanta are more frequently used than others. If these frequencies follow a power law in accordance with the Quantization Hypothesis, then we may expect QDG cluster sizes to be governed by a power law. The measured scaling exponent of $\alpha_N = 0.083$ from~\Cref{fig:mean-and-distribution-llm-scaling} implies a power law distribution over quanta with exponent $-1.083$. Do the cluster sizes follow this?

\Cref{fig:llm-similarity-and-frequency} shows rank-frequency curves for clusters discovered with QDG for varying choices of \texttt{n\_clusters}. These curves sort the clusters according to their size and then plot size against cluster index (rank). We plot rank-frequency curves for many choices of \texttt{n\_clusters} since it is unclear a priori which \texttt{n\_clusters} to use. When we measure the slope of the rank-frequency curve, we measure it from the envelope formed by the many rank-frequency curves, a practice which we discuss in~\Cref{sec:appendix-clustering-analysis}. Biases in the clustering algorithm and inherent noise in model gradients make clustering imperfect, and lead to high uncertainty of our the measured power law exponent. From our analysis in~\Cref{sec:appendix-clustering-analysis}, we think that extracting the power law exponent over quanta utilization frequency by measuring the slope of the rank-frequency curve should have uncertainty of at least 0.2. We also note that some rank-frequency curves don't look like a clean power law. In~\Cref{sec:appendix-clustering-analysis}, \Cref{fig:toy_clustering_d_noise} we find that we can get similar-looking curves in a toy model of this clustering process when the dimension and noise is high. Between ranks 100-1000, we measure a slope of $\approx -1.24$, about $0.16$ off our expected slope of $-1.08$, and so within the margin of error. We are encouraged that the size of our discovered clusters seem to decay at a rate (very roughly) compatible with observed neural scaling exponents, in line with our theory. However, less naive clustering schemes, operating on more samples with more clusters, could be useful to sharpen this measurement.






    










\section{Related Work}

\textbf{Models of neural scaling}: Several models of neural scaling laws have been proposed in prior work. \textcite{sharma2022scaling} explain power law scaling w.r.t.\ model parameters using an argument from approximation theory, which relates neural scaling exponents to the dimension of the data manifold $d$. \textcite{michaud2023precision} point out that effective dimension $d$ could be generalized to the maximum arity of the target function's computation graph for sparse compositional problems. \textcite{bahri2021explaining} generalized the model of \textcite{sharma2022scaling} to scaling w.r.t.\ dataset size, additionally relating scaling exponents to the power law spectrum of certain kernels. \textcite{maloney2022solvable} develop an exactly solvable random-feature model of scaling, from which they derive a joint parameter-data scaling law. \textcite{bordelon2020spectrum} develop a model of data scaling for kernels, decomposing the generalization error into a sum over eigenmodes, whereas we decompose error into a sum over quanta. Arguably the closest prior work to ours is \textcite{hutter2021learning}, who develops a model of data scaling wherein a discrete set of ``features'' must be learned. In this model, a feature is learned if it occurs at least once in the training set. If the features are Zipfian distributed, this produces power law scaling in expectation but with high variance. In our model, using a data threshold $\tau \gg 1$ lowers the variance in the scaling curve, and we also considered scaling w.r.t.\ parameters and applied the model to real networks.

\textbf{Understanding emergent abilities}: \textcite{wei2022emergent} and \textcite{srivastava2022beyond} document examples of emergent abilities in large language models, though \textcite{schaeffer2023emergent} suggest that these examples are an artifact of the metric used to evaluate performance. 
\textcite{arora2023theory} develop a framework for the emergence of ``skills'', where predicting text requires combining multiple different skills from an underlying set of language skills.

\textbf{Miscellaneous}: The topic of phase transitions in machine learning is not new~\parencite{saitta2011phase}, but our work was strongly influenced by the recent work of \textcite{olsson2022context} who observe a phase change from the formation of induction heads and especially \textcite{nanda2023progress} who conjecture that phase changes may be ubiquitous. \textcite{simon2023stepwise} also exhibit a task where learning proceeds as a series of discrete steps. \textcite{chen2023skill} develop a framework for understanding LLM ``skills'' in a hierarchy and for choosing data to more efficiently learn desired skills. \textcite{chan2022data} study how a Zipfian data distribution influences in-context learning.


\section{Discussion}
\label{sec:discussion}

\textbf{Summary}: The Quantization Hypothesis posits that for some types of prediction problems, models must learn a discrete (quantized) set of modules/knowledge/skills (quanta). When data is distributed in such a way that the ``use frequencies'' of these quanta follow a power law, then power law neural scaling can arise as models learn more and more quanta, with smooth scaling curves averaging over many small cases of emergence. We presented a toy dataset where neural scaling exhibits these properties. We then documented how language model scaling curves decompose, beyond simply how the mean loss scales. Lastly, we developed a method to discover quanta from the internal structure of trained models, from which we were able to enumerate a large number of skills of a small language model. The frequencies at which the quanta we discover are used for prediction in natural text seem to roughly track the power law our theory would predict, though this measurement is quite imprecise.

\textbf{Limitations}: While the Quantization Hypothesis appears to hold for our toy datasets, much work remains in investigating to what extent it holds for natural tasks like language modeling. Probably our riskiest assumption was that there is an underlying discreteness to \emph{everything} that models learn. Gradual scaling seems typical in LLMs~\cite{schaeffer2023emergent}, and it could be more parsimonious to model neural scaling as an underlying smooth process rather than to assume that most tasks are highly polygenic with underlying discrete quanta. Note also that in our model of scaling w.r.t.\ parameters $N$, having more parameters merely increases the capacity of the network. In practice however, larger networks are more efficient learners~\cite{hoffmann2022training}, and one can trade off between parameters and data, whereas in our model parameters and data independently bottleneck the number of quanta that can be learned. Additionally, we modeled the quanta as being independent, where learning order is given just by the use frequencies, but it could make more sense to think of the quanta as living in a hierarchical dependency graph. Lastly, our QDG method is neither very principled nor scalable, and much better methods could likely be developed to discover quanta and study their statistics for larger models and across more samples.

\textbf{Implications for emergence and forecasting}: \textcite{srivastava2022beyond} find that on some tasks, neural scaling has high ``linearity'', with gradual improvements to scale, with other tasks displaying ``breakthroughness'', where performance improves sharply at some scale. In our model, high linearly would result from a task's relevant quanta being widely spread along the Q Sequence, and high breakthroughness would result from a task being monogenic or from the relevant quanta being close together in the Q Sequence. Our model also suggests that future capabilities could be forecasted if one could estimate the frequency at which that skill would benefit prediction in the training corpus. 

\textbf{Implications for mechanistic interpretability}: If the Quantization Hypothesis is correct, then understanding a network reduces to enumerating its quanta. Having done this, the quanta could perhaps then be translated into a more interpretable format (something like code), studied in this format, and eventually executed in this format, rather than via the operation of the network.

\textbf{Outlook}: Lastly, our decomposition of networks into quanta is reminiscent of Minsky's \emph{Society of Mind}~\cite{minsky1988society} perspective that minds are decomposable into individually mindless ``agents''. If this decomposition is indeed possible, then the quanta (agents) become natural objects of study within networks. This \emph{mesoscale} understanding of networks, in terms of the internal modules which collectively constitute their performance, could perhaps act like statistical physics for deep learning, allowing us to bridge our microscale understanding of low-level training dynamics and our macroscale understanding of model performance. 










\begin{ack}
We thank Tamay Besiroglu, Neel Nanda, Tony Wang, David Bau, Ben Edelman, Brian Cheung, Wes Gurnee, Stephen Casper, Peter Hase, Davis Brown, Eleni Shor, Max Nadeau, and Xander Davies for helpful conversations and feedback. We thank Lauro Langosco for helping with code to visualize samples from The Pile. This work was supported by the Foundational Questions Institute, the Rothberg Family Fund for Cognitive Science, the NSF Graduate Research Fellowship (Grant No. 2141064), and IAIFI through NSF grant PHY-2019786.
\end{ack}

\printbibliography


\newpage
\section*{Appendix}
\appendix

\section{More general scaling laws}\label{sec:appendix-general-scaling-laws}

If one learns the first $n$ quanta, reducing the loss from $b_k$ to $a_k$ ($1\leq k\leq n$), while the loss remains $b_k$ for $k>n$, the expected loss is given by:
\begin{equation}
L_n = \sum_{k=1}^n a_kp_k + \sum_{k=n+1}^\infty b_kp_k.
\end{equation}
In the main text, we used $a_k=a$ and $b_k=b$ for our model. However, one can imagine a variety of other choices for $a_k$ and $b_k$.



{\bf Case 1} $b_k=-{\rm log}\ p_k$ and $a_k=0$, where $p_k=k^{-(\alpha+1)}/\zeta(\alpha+1)$. This baseline for $b_k$ is the error of a model which outputs the token frequencies, independent of the context (assuming that quanta involve the prediction of a particular token). The expected loss is given by:
\begin{equation}
L_n = \sum_{k=1}^n 0 \cdot p_k + \sum_{k=n+1}^\infty (-{\rm log\ }p_k)\cdot p_k \approx \frac{1+\alpha+\alpha{\rm log}\zeta(\alpha+1)}{\alpha^2\zeta(\alpha+1)}n^{-\alpha} + \frac{\alpha+1}{\alpha\zeta(\alpha+1)}n^{-\alpha}{\rm log\ }n,
\end{equation}
which contains a power law term $n^{-\alpha}$ plus a log term $n^{-\alpha}{\rm log\ }n$. For very large $n$, the log term can be ignored, so $L$ is still approximately a power law of $n$ with exponent $-\alpha$, shown in Figure~\ref{fig:log_power_law}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/log_power_law.pdf}
    \caption{Comparing different scaling laws. Setting $a_k=0$, we compare $b_k=-{\rm log}\ p_k$ (solid lines) and $b_k=1$ (dashed lines) for different alphas. Although the $b_k=-{\rm log}\ p_k$ case would cause an extra loss term $n^{-\alpha}{\rm log}n$ in additional to the power law term $n^{-\alpha}$, the loss becomes a power law asymptotically when $n$ becomes large.} 
    \label{fig:log_power_law}
\end{figure}

{\bf Case 2} $b_k=-{\rm log}\ p_k$ and $ a_k=-{\rm log}\ (Cp_k)\ (C>1)$, where $p_k=k^{-(\alpha+1)}/\zeta(\alpha+1)$. The expected loss is given by:
\begin{equation}
L_n = \sum_{k=1}^n (-{\rm log\ }(Cp_k)) \cdot p_k + \sum_{k=n+1}^\infty (-{\rm log\ }p_k)\cdot p_k \approx \frac{{\rm log}C}{\alpha\zeta(\alpha+1)}n^{-\alpha}-{\rm log}C+\frac{1+\alpha+\alpha{\rm log}\zeta(\alpha+1)}{\alpha^2\zeta(\alpha+1)},
\end{equation}
which is a power law $n^{-\alpha}$ plus a constant. 


\section{Additional results on multitask sparse parity}\label{sec:appendix-multitask-parity}

\noindent\textbf{Training dynamics}: When loss is broken down by subtask on multitask sparse parity, learning curves consist of many reverse-S shaped curves, and mean loss decreases smoothly as an average over these curves. In~\Cref{fig:sparse-parity-training-dynamics}, we show loss versus time for each subtask for training runs in both the single-epoch and multi-epoch regimes. In~\Cref{fig:sparse-parity-convergence-time} we show how convergence time for each subtask relates to the frequency of that subtask.

\begin{figure}[h!]
    \centering
    \includegraphics[width=5.5in]{figures/parity-subtask-timeseries-infinite-and-finite-data.jpg}
    \caption{Training dynamics on the multitask sparse parity dataset consist of many ``phase transitions'' when decomposed by subtask -- the loss curve for each subtask drops following an initial plateau of no apparent progress, in line with~\cite{barak2022hidden}. The mean loss decreases smoothly, averaging over these phase transitions in the model's performance on subtasks. We show curves for single-epoch training (top) and multi-epoch training on 5 million samples (bottom). The dashed red line indicates the early stopping point where mean test loss is minimized. For these runs, $\alpha = 0.4$.}
    \label{fig:sparse-parity-training-dynamics}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics{figures/sparse-parity-convergence-time.pdf}
    \caption{Convergence time for each subtask versus the frequency of that subtask. We see that convergence time $S_k$ on subtask $k$ is $S_k \propto p_k^{-0.81}$ rather than $S_k \propto p_k^{-1}$ as we had expected. This leads to a steeper scaling w.r.t.\ $S$ than expected from theory. For these experiments, we used $\alpha = 0.4$, and so we would have predicted $\alpha_S \approx 0.29$ but instead we get $\alpha_S \approx 0.45$. We consider the model to have converged on a subtask once it gets mean test loss less than 0.1 bits on that subtask.}
    \label{fig:sparse-parity-convergence-time}
\end{figure}

\bigbreak
\noindent\textbf{Scaling for varying $\alpha$}: In~\Cref{fig:sparse-parity-varying-alpha-scaling} we show scaling curves on multitask sparse parity in $N, S, D$ for a variety of quanta distribution parameters $\alpha$. While all scaling curves appear to be power laws, the relationship between $\alpha_N, \alpha_S, \alpha_D$ and $\alpha$ is not precisely as predicted by theory:

\begin{enumerate}
    \item \textbf{Parameter scaling:} We observe that the relationship between $\alpha_N$ and $\alpha$ deviates a bit from the prediction $\alpha_N = \alpha$, with $\alpha_N < \alpha$ for small $\alpha$ and $\alpha_N > \alpha$ for large $\alpha$. Perhaps model size does not influence learning just by changing capacity, but also by affecting optimization.

    \item \textbf{Step scaling:} We observe that $\alpha_S$ is consistently higher than the theoretical prediction $\alpha / (\alpha + 1)$. In~\Cref{fig:sparse-parity-convergence-time}, we saw that the number of steps to convergence for each subtask did not precisely follow $S_k \propto p_k^{-1}$, but was closer to $S_k \propto p_k^{-0.81}$. This means that many subtasks converge faster than we would expect, producing a steeper scaling curve.

    \item \textbf{Data scalaing:} We observe that $\alpha_D$ is substantially higher than the theoretical prediction $\alpha / (\alpha + 1)$ for small $\alpha$. We think this may be related to the fact that early-stopping cuts off training before all subtasks are learned as observed in~\Cref{fig:sparse-parity-training-dynamics}. In~\Cref{fig:sparse-parity-varying-alpha-n-scaling}, we show how the number of subtasks learned $n$, when we include subtasks learned after early-stopping, seems to be in line with theory: $n \propto D^{1/(\alpha+1)}$. 

\end{enumerate}

Better understanding the precise nature of power law scaling on multitask sparse parity is an interesting avenue for future work.


\begin{figure}
    \centering
    \includegraphics{figures/sparse-parity-data-scaling-dependence-n.pdf}
    \caption{Number of subtasks learned ($n$), including subtasks learned after early-stopping would have terminated the training run, versus training samples $D$ for a variety of $\alpha$. We see that the relation $n \propto D^{1/(\alpha+1)}$ approximately holds, in line with theory. Deviation from theory for the scaling exponent of loss $L$ w.r.t.\ $D$ therefore likely originates from our failure to regularize network training, leading to early-stopping ending training before some subtasks can be learned.}
    \label{fig:sparse-parity-varying-alpha-n-scaling}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics{figures/sparse-parity-all-scaling-varying-alpha.pdf}
    \caption{Scaling in parameters ($N$), single-epoch training time ($S$), and multi-epoch training samples $(D)$ for varying quanta power law distribution parameter $\alpha$ on multitask sparse parity. We notice that scaling curves in steps $S$ are typically steeper than the $\alpha_S = \alpha / (\alpha + 1)$ predicted from theory, and that for low $\alpha$ the scaling curves in $D$ also deviate from theory substantially.}
    \label{fig:sparse-parity-varying-alpha-scaling}
\end{figure}








\newpage
\section{Additional results on language models}

In \Cref{fig:mean-and-distribution-llm-scaling-dynamics} we show how the distribution over losses changes across time during a training run, rather than across model scales like in~\Cref{fig:mean-and-distribution-llm-scaling}.

\begin{figure}
    \centering
    \includegraphics{figures/pythia-dynamics-tripanel.png}
    \caption{\textbf{Left:} Training curves (scaling w.r.t.\ steps $S$) of mean test loss for Pythia models. We measure exponents $\alpha_S$ between 0.037 and 0.06. \textbf{Center:} the distribution $p(L)$ over time. Over time, models achieve $\approx 0$ loss on an increasing fraction of tokens, similar to scaling in model size. \textbf{Right:} The distribution $L \cdot p(L)$ over time.}
    \label{fig:mean-and-distribution-llm-scaling-dynamics}
\end{figure}

\begin{figure}[t]
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{1}{|c|}{\fontsize{10}{14}\selectfont\textbf{Monogenic samples}} & \multicolumn{1}{c|}{\fontsize{10}{14}\selectfont\textbf{Polygenic samples}} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokenneilmackinnon.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokenneilmackinnon}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokenssep-normal.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokenssep-normal}
        \end{minipage} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokenessmarshall.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokenessmarshall}
        \end{minipage} & 
        \begin{minipage}[t]{0.48\textwidth}
            \includegraphics[width=0.99\textwidth]{figures/tokenscaling/tokenonconsumer.pdf}
            \fontsize{9}{10}\selectfont
            \input{texts/tokenpile/tokenonconsumer}
        \end{minipage} \\
    \hline
    \end{tabular}
    \caption{Additional LLM scaling curves on individual samples which exhibit sharp vs smooth improvement. If the Quantization Hypothesis is true for language modeling, then we would interpret samples with sharp drops as ``monogenic'' and samples with gradual progress as ``polygenic''. 
    }
    \label{fig:llm-diverse-scaling-behaviors-more}
\end{figure}

In~\Cref{fig:cluster-examples-more} we show additional examples from clusters discovered with QDG.



\begin{figure}[t]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{1}{|c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 146}: comma after day of month} & \multicolumn{1}{c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 269}: ``s'' after starting year of decade} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster146}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster269}
        \end{minipage} \\
        \hline
        \multicolumn{1}{|c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 278}: colon after CSS property} & \multicolumn{1}{c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 292}: protocol separator in URLs} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster278}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/pile/cluster292}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Additional examples of clusters of inputs discovered by QDG. Like in~\Cref{fig:cluster-examples}, we used 10000 samples and \texttt{n\_clusters} of 400.}
    \label{fig:cluster-examples-more}
\end{figure}



\subsection{Details of application of QDG to LLMs}\label{sec:appendix-qdg-details}
When applying QDG to language models, we use gradients within self-attention and MLP layers, but do not include embed, unembed, or layer norm gradients when we flatten and concatenate gradients into a vector $g$.\footnote{We exclude gradients for embed and unembed parameters because they are high dimensional and also because they may contain information more about the input and output rather than the computations the model performs internally. We exclude layer norm gradients because they appeared to contain less information about clusters in toy experiments.} We choose samples $(x_i, y_i)$ for which our 19m-parameter model achieves a cross-entropy loss less than $0.1$ nats. We filter based on this criteria since (1) we cannot cluster samples based on model mechanism if the model does not have such a mechanism for performing prediction correctly on those samples and (2) our intuition that samples with particularly low loss are more likely to be monogenic. We further exclude samples which can be solved via induction on the context\footnote{We filter (copying) induction problems by excluding samples where the token which is to be predicted is the last token in a trigram which occurred earlier in the context. This is not a very comprehensive filtering scheme.}, since such samples are quite common (possibly interfering with our task of finding diverse quanta) and since early experiments indicated that QDG had trouble clustering such samples together. We choose 10000 such samples to perform clustering on from the test set of The Pile. After computing the affinity matrix $\hat{C}$, we use the spectral clustering implementation from scikit-learn~\parencite{scikit-learn} with labels assigned via k-means.

\section{Quanta discovery on TinyStories}

We also apply QDG to TinyStories-33M, a language model trained on the TinyStories dataset~\cite{eldan2023tinystories}. We consider only tokens on which TinyStories-33M achieves a loss less than 1 bit of cross-entropy. We apply QDG to 10000 such samples, clustering their gradients with spectral clustering with \texttt{n\_clusters = 400}. We show some samples from the resulting clusters in~\Cref{fig:tinystories-clusters}. Many of these clusters reflect some simple recurring pattern in the TinyStories dataset, like predicting `` time'' after ``Once upon a'', which many documents in the dataset start with. Some other clusters are more interesting however, like Cluster 11, which seems to involve predicting the correct noun in a sentence where that noun was referred to earlier in the sentence or in previous sentences.

\begin{figure}[t]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\fontsize{10}{10}\selectfont\rule{0pt}{2.25ex}\textbf{Example ``quanta'' for the TinyStories dataset}} \\
        \hline
        \multicolumn{1}{|c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 11}: predicting the correct noun} & \multicolumn{1}{c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 31}: `` time'' after ``Once upon a''} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/tinystories/cluster11}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/tinystories/cluster31}
        \end{minipage} \\
        \hline
        \multicolumn{1}{|c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 75}: comma after temporal phrase} & \multicolumn{1}{c|}{\rule{0pt}{2.25ex}\fontsize{8}{10}\selectfont\textbf{Cluster 77}: beginning of quote} \\
        \hline
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/tinystories/cluster75}
        \end{minipage} &
        \begin{minipage}[t]{0.48\textwidth}
            \fontsize{6}{7}\selectfont
            \input{texts/tinystories/cluster77}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Examples of clusters within the TinyStories dataset, discovered by QDG on the \mbox{TinyStories-33M} model. Here we just show samples from four out of 400 \texttt{n\_clusters}}
    \label{fig:tinystories-clusters}
\end{figure}




\newpage
\section{The difficulty of estimating the power law exponent from clusters}\label{sec:appendix-clustering-analysis}

In~\Cref{sec:llm-subtask-distribution}, when we looked at the distribution over elements in each cluster, we did not perfectly recover a Zipf distribution with exponent $\approx 1.08$ that we expected from our theory. In this section, we describe the difficulty of accurately estimating such an exponent with our method. 

\subsection{QDG on multitask sparse parity}

\begin{figure}[h!]
    \centering
    \includegraphics{figures/similarity-matrix-and-rank-frequency-envelope-sparseparity.png}
    \caption{Similarity matrix and rank-frequency plots from QDG on multitask sparse parity. Despite sparse parity having a known decomposition into subtasks which are power law distributed in frequency, we do not recover this same power law from samples. We used $\alpha = 0.4$ for the frequency distribution for an expected rank-frequency power law exponent of -1.4, but measure a rank-frequency envelope slope closer to -1.1.}
    \label{fig:sparse-parity-similarity-and-envelope}
\end{figure}

As a first experiment, we performed QDG on multitask sparse parity, where there is a known, artificially-imposed power law distribution over subtasks. We train a width-500 single-hidden-layer ReLU MLP on multitask sparse parity with $\alpha = 0.4$ and with $n=100$, $k=3$, and $n_\text{tasks} = 500$. We then took 10000 samples which the network achieves $\approx 0$ loss on (sampled from the Zipf distribution over subtasks with exponent 1.4). We compute gradients of cross-entropy loss w.r.t.\ all model parameters for these samples, and then perform QDG just like for LLMs. We show results in~\Cref{fig:sparse-parity-similarity-and-envelope}. We plot the full similarity matrix where samples are ordered according to their a priori known subtask, rather than their cluster from QDG, and  see a clear pattern where elements from the same subtask have on average higher angular similarity than elements between subtasks. However, from the rank-frequency plot of the clusters, we do not recover a slope of -1.4, but rather a lower slope of $\approx -1.1$. This shows that even when there is an exact decomposition of inputs into subtasks with a known Zipf distribution over these subtasks, that we do not perfectly recover this Zipf distribution from QDG. 

\subsection{A toy model of QDG uncertainty and bias}

{\bf A toy model:} To understand the bias of spectral clustering, we develop the following toy model. We assume the dataset has $N=1000$ subtasks, each subtask containing $n_i=\lfloor\frac{A}{i^\alpha}\rfloor (1\leq i\leq N)$ tokens ($A=1000$). We use a Gaussian distribution $\mathcal{N}(\mat{m}_i,\sigma^2\mat{I}_{d\times d})$ to model gradients within a subtask $i$, where $d$ is the embedding dimension, $\sigma$ is the noise level, and $\mat{m}_i$ is the Gaussian mean. $\mat{m}_i$ itself is drawn from the standard Gaussian distribution $\mat{m}_i\sim \mathcal{N}(\mat{0}, \mat{I}_{d\times d})$. We define the similarity between two vectors $\mat{x}, \mat{y}$ to be ${\rm sim}\equiv 1+\frac{\mat{x}}{|\mat{x}|}\cdot \frac{\mat{y}}{|\mat{y}|}$. We compute pairwise similarity between all $\sum_{i=1}^N n_i$ tokens, and input the similarity matrix to the spectral clustering algorithm. We also need to specify the number of clusters $k$.


We have two hyperparameters in the toy model, the embedding dimension $d$ and the noise level $\sigma$. We need to determine them such that this toy model can decently imitate LLM results (Figure~\ref{fig:llm-similarity-and-frequency}). We fix $\alpha=1$, sweeping $d=\{30,100,1000\}$, $\sigma=\{0,0.5,2.0\}$, and $k=\{100,200,500\}$. As shown in Figure~\ref{fig:toy_clustering_d_noise}, the high-dimension ($d=1000$) large-noise ($\sigma=2.0$) scheme seem to best agree with the LLM results, since the $k=200$ curve can reproduce the sag and the cliff present in LLM curves.

Estimating $\alpha$ from the frequency curve is hard, in fact, the slope depends on $k$ and the region used to estimate it. However, we observe that different $k$ curves form a clear envelope, whose slope is robust in a reasonably wide region. The envelope slope seems to indicate $\alpha$. We fix $d=1000$ and $\sigma=2.0$, sweeping $\alpha=\{0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5\}$. For each $\alpha$, we estimate the slope of the envelope. Although there is clear correlation between the estimated envelope and $\alpha$, if we use the envelope slope to estimate $\alpha$, the error is on the order of 0.2, as shown in Figure~\ref{fig:toy_clustering_envelope}.

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{figures/toy_clustering_d_noise.pdf}
    \caption{To understand the bias of spectral clustering, we apply spectral clustering to a toy model with different embedding dimension $d$, noise scale $\sigma$ and number of cluster $k$. The high-dimension ($d=1000$) large-noise ($\sigma=2.0$) scheme seems to best agree with the LLM results (Figure~\ref{fig:llm-similarity-and-frequency}).}
    \label{fig:toy_clustering_d_noise}
\end{figure}

\begin{figure}
    \centering\includegraphics[width=0.8\linewidth]{figures/toy_clustering_envelope_notparity.pdf}\includegraphics[width=0.19\linewidth]{figures/toy_clustering_compare.pdf}
    \caption{The difficulty of measuring $\alpha$ from curves. We apply spectral clustering to a toy model with different $\alpha$ and number of clusters $k$. For a fixed  $\alpha$, different $k$ curves define an envelope. One could use the envelope slope to infer $\alpha$, but this incurs errors around 0.2.}
    \label{fig:toy_clustering_envelope}
\end{figure}


\newpage
\section{Parameter and data scaling exponents across studies}\label{sec:parameter-vs-data-scaling-review}

In~\Cref{fig:parameter-data-scaling-exponents-review}, we show $\alpha_N$ and $\alpha_D$ (or possibly $\alpha_S$, depending on the study) for a variety of prior studies of deep learning scaling, as compiled by~\textcite{epoch2023scalinglawsliteraturereview}. While the data is messy, it is intriguing that most of the \textcite{rosenfeld2019constructive} samples lie below the $\alpha_D = \alpha_N$ line, as our model would predict. The scaling exponents from \textcite{hoffmann2022training} are slightly closer to our prediction than the relation $\alpha_D = \alpha_N$, which has been proposed by other models of neural scaling laws. Overall though, the existing empirical results are too messy to definitively support or contradict our model.

\begin{figure}[h!]
    \centering
    \includegraphics{figures/scaling-scatter-linear-scale.pdf}
    \caption{Parameter and data scaling exponents from various studies of deep learning scaling, compiled from the database of neural scaling laws from~\cite{epoch2023scalinglawsliteraturereview}. Our model of scaling predicts that $\alpha_D = \alpha_N / (\alpha_N + 1)$, indicated with the solid black line. Visible points are from \cite{rosenfeld2019constructive, kaplan2020scaling, hoffmann2022training, gordon2021data, droppo2021scaling}. \cite{ardalani2022understanding} is above the visible window of the figure.}
    \label{fig:parameter-data-scaling-exponents-review}
\end{figure}

\section{Estimates of compute used for our experiments}

\textbf{Multitask sparse parity}: Our training script takes roughly 1-4 hours (depending on network size) to perform a single-epoch training run on a GPU. When training multi-epoch on a fixed dataset, runs take typically between 3-10 minutes, with some outliers taking much longer. Our largest experiment was for~\Cref{fig:sparse-parity-varying-alpha-scaling}, where we trained networks of varying width on data with varying distributions over subtasks (with different power law exponents). 467 runs completed with a total running time of approximately 1450 hours. These experiments were run on a cluster with heterogeneous hardware. Availble GPUs include NVIDIA A100, RTXA6000, QUADRORTX6000, GEFORCERTX2080TI, GEFORCERTX2080, GEFORCEGTX1080TI, titan-x, and tesla-v100.

\textbf{Pythia model scaling evaluations}: We evaluated Pythia models on NVIDIA A100 80GBs. We do not have available the running time used when computing loss on approximately ten million tokens (for which we reported scaling statistics on), although it was likely less than an hour per model. The most expensive experiments were for~\Cref{fig:mean-and-distribution-llm-scaling-dynamics}, where we evaluated the first four models in the Pythia suite across 143 checkpoints for a total of 572 evaluations. We likely used some hundreds of A100-hours for this, though possibly less than 100 hours.

\textbf{QDG}: We ran our QDG experiments on an NVIDIA A100 80GB. For the smallest Pythia model and for 10000 samples, it takes a few hours to compute the similarity matrix. We performed this computation only a handful of times.


\end{document}