%!TEX root = ../main.tex
\section{Related Work}
\label{sec:relatedwork}
There are three fundamental problems in CBF: deployment, verification, and synthesis. The first focuses on designing a safe controller (online) when a valid CBF is given, while the latter two try to find such a valid CBF (offline).

{\bf Deployment}.
Online safe control given a CBF can be formulated as a quadratic program~\cite{ames2014cdc-cbforigin} in the absence of model uncertainty, and a second-order cone program~\cite{long2022ral-robustsocp,dhiman2021tac-robustsocp} or semi-infinite program~\cite{wei2022acc-uncertainsynthesis} when uncertainty exists. These convex programs can typically be solved efficiently.


{\bf Verification \& synthesis: SOS methods}. 
Sum-of-squares (SOS) programming has shown increasing potential in CBF verification and synthesis because it can handle infinite constraints and preserve computational tractability (in theory, SOS program is convex and can be solved in polynomial time, but practically it gets intractable when the size grows).
Early works \cite{prajna2004hscc-bfsynthesis,prajna2006automatica-bfsynthesis} consider barrier function synthesis without control input. With control input, classical methods formulate the synthesis problem as a bilinear SOS program, assuming a nominal~\cite{ames2019ecc-cbftheapp} or parameterized~\cite{wang2022arxiv-safetysynver} controller (which is a sufficient but unnecessary condition for a valid CBF). 
Recent works~\cite{clark22arxiv-cbf,dai2022arxiv-clfcbfsynveri,zhao22arxiv-cbfsos} remove the assumption of an explicit controller. For instance, \cite{zhao22arxiv-cbfsos} considers box-like control limits and formulates a single nonlinear SOS program. These works, however, share two shortcomings: (i) they base their algorithms upon alternation and lack global convergence guarantees; (ii) they do not handle dynamics uncertainty and general convex control constraints. Our framework aims to resolve these drawbacks.

{\bf Verification \& synthesis: sampling methods}.
Another popular line of research constructs a robust CBF by sampling a finite number of states and using Lipschitz conditions to bound the discretization error. They use evolutionary algorithms~\cite{wei2022acc-uncertainsynthesis}, constrained PAC learning~\cite{robey2021ifac-rcbfhybrid}, or convex optimization~\cite{lindemann2021arxiv-rcbfsafeexpert} to search for a robust barrier function. These algorithms require Lipschitz conditions and they can suffer from the curse of dimensionality (number of samples grows exponentially \wrt state dimension).

{\bf Other methods}. 
Handcrafted CBFs can be designed for specific systems such as controllable linear system~\cite{clark2021automatica-controllablelinear} and Euler-Lagrange system~\cite{cortez2020acc-eluerlag}. 
\cite{tonkens2022iros-refining}~uses Hamilton-Jacobi-Bellman reachability to iteratively refine a CBF, 
and~\cite{chen21cdc-backup} leverages a backup control policy.
Deep learning-based methods are also emerging. Safe reinforcement learning algorithms learn \cite{ma2022l4dc-saferl} or adapt \cite{chen2021lcss-saferl,westenbroek2021ifac-saferl} safety certificates along with a control policy without rigorous validation. Neural CBFs adopt a post-hoc validation after learning, such as satisfiability modulo theory~\cite{zhao2021fac-provableneuralcbf} and Lipschitz methods~\cite{jin2020arxiv-provableneuralcbf}.