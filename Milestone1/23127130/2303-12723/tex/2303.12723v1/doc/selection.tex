\section{Adaptive Framework}
\begin{figure*}
    \centering
    \includegraphics[width=0.99\linewidth]{figs/workflow.pdf}
    \caption{Overall workflow of AdaOPC. Colored blocks are functional modules. Red dashed lines represent library update flow.}
    \label{fig:workflow}
\end{figure*}
\subsection{Workflow Overview}
Our proposed workflow is visualized in \Cref{fig:workflow}.
In \Cref{solverpool}, we firstly introduce the extensible solver selection module to choose OPC solver for different patterns. 
In \Cref{library} we will demonstrate the dynamic graph-based Pattern library, one of the key components of AdaOPC framework for mask Optimization efficiency improvement. 
An approximate nearest neighbor searching(ANNS) method will be utilized to match similar patterns. 
\Cref{embedding} specified how we embed patterns into high dimensional vectors for pattern matching in the library using supervised contrastive learning.
\Cref{shift} will further discuss the mask reusability and requirement. A proof of the shift equivariance during lithography is provided to validate the feasibility, along with the solution by shift calibration.

% \subsection{Adaptive Pattern Recognizer} \label{recognizer}
% As we discussed previously, machine learning-based methods face the challenge of uncertainty of performance despite its remarkable advantage of fast inference speed. 
% As far as we concerned, state-of-art Deep learning approaches already reached good performance for an overall evaluation on a test set of patterns.
% However, the problem of OPC has minimal tolerance of error caused by lithography. The process strictly requires the corrected mask to be printable.

\subsection{Extensible OPC Solver Selection} \label{solverpool}
Our framework maintains a flexible solver pool to select suitable OPC solutions for different patterns based on their complexity. We divide sliced design patterns into two groups: critical and non-critical patterns. Then we use a solver selector to choose which OPC solver to use. This Solver selector can be regarded as a 2-class classifier and built with a simple deep learning classification model. We use Resnet-18 \cite{he2016deep} as backbone network with objective to minimize the cross-entropy loss $L$:
\begin{equation}
    L = - \frac{1}{N} \sum_{i}^{N} y_{i}\log(p_{i}) + (1 - y_{i})\log(1 - p_{i}) ,
\end{equation}
where $y_{i}$ is the 1/0 label for critical pattern of sample $i$, $p_{i}$ is the probability predicted by classifier model. The model is trained to predict $p_{i}$ as close as $y_{i}$. Without bells and whistles, such simple network + loss combination is capable of performing a fast and accurate prediction on pattern class.

For non-critical patterns, we build our ML-Solver using a generative neural network model, consistent with one of the SOTA ML-based OPC solvers DAMO-DMG \cite{chen2021damo}. We also pick U-Net++ with residual blocks inserted in the bottleneck as our model structure and train the generative model with the same strategy as \cite{chen2021damo}. The only difference is the training data. We prepare our own training dataset with patterns from a real full-scale design and mask generated by a robust OPC engine, of which the lithography model is an authentic one instead of a DNN simulator as in \cite{chen2021damo}. Such data preparation aligns with the real OPC scenario, where the only ground truth we have is the lithography model.

For critical patterns, we use rigorous numerical optimization method as \cite{gao2014mosaic} with GPU acceleration by CUDA, despite that deep learning approaches already reached good performance for an overall evaluation on some test sets of patterns. Data-driven black-box deep learning model may learn to mimic and reverse the diffraction effect very well. Nevertheless, they might have difficulty dealing with optical interference of incident light caused by complex neighboring components. 
% In that case, ILT methods are flexible analytical solutions which iteratively optimize mask through many rounds of lithography.
In that case, the rigorous numerical optimization solver provides an analytical solution regardless of the geometric complexity of patterns.
Moreover, in a real OPC scenario with a new design and even possibly a new lithography engine, patterns and optimized masks generated by robust methods can be the dataset to train the machine learning model to adapt to new settings. 

Note that the solver pool is extensible. Any powerful OPC solution with certain strengths for certain patterns holds the possibility to be imported as a replacement or complementary candidate. If more than two solvers are in the solver pool, we can simply modify the classifier loss:
\begin{equation}
    L = -\frac{1}{N}\sum_{i}^{N}\sum_{c=1}^{C} y_{ic}\log(p_{ic}) ,
\end{equation}
where $C$ is the number of pattern classes, the same as the number of corresponding OPC solvers. $y_{ic}$ is the 1/0 label for whether this pattern belongs to class $c$. In this way, we can simply transform the problem into a multi-classification case.