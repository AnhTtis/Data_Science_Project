\documentclass[journal=jacsat,manuscript=article]{achemso}
\setkeys{acs}{maxauthors=99}
\usepackage[utf8]{inputenc}
\usepackage{physics}
\usepackage{braket}
\usepackage{bm}%
\usepackage[hidelinks]{hyperref}%
\SectionNumbersOn 
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{qcircuit}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{enumitem}
\setlist{nosep}
\usepackage{courier}
\usepackage[version=4]{mhchem}

\usepackage{listings}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\linespread{0.9}\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    basewidth=0.55em,
}

\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Code Snippet}

\newcommand{\bp}[1]{\vspace{\baselineskip}\noindent\textbf{#1}}
\definecolor{bkgd}{RGB}{240,242,246}
\definecolor{orange-red}{rgb}{1.0, 0.27, 0.0}
\newcommand{\fancylink}[2]{\colorbox{bkgd}{\color{orange-red}\href{#1}{\sf {#2}}}}

\newcommand{\tc}{\textsc{TensorCircuit}}
\newcommand{\tcc}{\textsc{TenCirChem}}
\newcommand{\jax}{\textsc{JAX}}
\newcommand{\numpy}{\textsc{NumPy}}
\newcommand{\cupy}{\textsc{CuPy}}
\newcommand{\pyscf}{\textsc{PySCF}}
\newcommand{\scipy}{\textsc{SciPy}}
\newcommand{\reno}{\textsc{Renormalizer}}
\newcommand{\openfermion}{\textsc{OpenFermion}}
\newcommand{\opteinsum}{\textsc{opt\_einsum}}
\newcommand{\qiskit}{\textsc{QisKit}}
\newcommand{\qiskitnature}{\textsc{QisKit-Nature}}
\newcommand{\pennylane}{\textsc{PennyLane}}
\newcommand{\tequilla}{\textsc{Tequilla}}
\newcommand{\mindquantum}{\textsc{MindQuantum}}
\newcommand{\qschem}{\textsc{Q$^2$ Chemistry}}
\newcommand{\qforte}{\textsc{QForte}}
\newcommand{\nex}{N_{\rm{ex}}}
\newcommand{\nshots}{N_{\rm{shots}}}

\usepackage{cancel}
\newcommand{\fix}[1]{\textcolor{red}{#1}}
\renewcommand{\cancel}[1]{}
\renewcommand{\fix}[1]{#1}

\title{TenCirChem: An Efficient Quantum Computational Chemistry Package for the NISQ Era}

\author{Weitang Li}
\email{liw31@gmail.com}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}


\author{Jonathan Allcock}
\affiliation{Tencent Quantum Lab, Hongkong, 999077, China}

\author{Lixue Cheng}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Shi-Xin Zhang}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Yu-Qin Chen}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Jonathan P. Mailoa}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Zhigang Shuai}
\affiliation{Department of Chemistry, Tsinghua University, Beijing, 100084, China}
\alsoaffiliation{School of Science and Engineering, The Chinese University of Hong Kong, Shenzhen, 518172, China}

\author{Shengyu Zhang}
\email{shengyzhang@tencent.com}
\affiliation{Tencent Quantum Lab, Hongkong, 999077, China}


\begin{document}

\begin{abstract}
    \tcc{} is an open-source Python library for simulating variational quantum algorithms for quantum computational chemistry.
    \fix{
     \tcc{} shows high-performance on the simulation of unitary coupled-cluster circuits, using compact representations of quantum states and excitation operators. Additionally, \tcc{} supports noisy circuit simulation and provides algorithms for variational quantum dynamics. \tcc{}'s capabilities are demonstrated through various examples, such as the calculation of the potential energy curve of \ce{H2O} with a 6-31G(d) basis set using a 34-qubit quantum circuit, the examination of the impact of quantum gate errors on the variational energy of the \ce{H2} molecule, and the exploration of the Marcus inverted region for charge transfer rate based on variational quantum dynamics.
    Furthermore, \tcc{} is capable of running real quantum hardware experiments, making it a versatile tool for both simulation and experimentation in the field of quantum computational chemistry.
    }
\end{abstract}

\maketitle

\section{Introduction}
Quantum computation leverages quantum effects to store and process data, which could lead to a revolution in computational chemistry~\cite{mcclean2016theory, cao2019quantum, bauer2020quantum, mcardle2020quantum, liu2022quantum}.
\fix{\cancel{As the era of} With the advent of noisy intermediate scale quantum (NISQ) computing~\cite{Preskill18} \cancel{gathers steam}}, devices with tens \fix{\cancel{to hundreds}} of error-prone qubits are increasingly becoming available \fix{for use} to researchers and the public~\cite{arute2019quantum,gong2021quantum, xu2023digital, google2023suppressing}.  Since such devices are not capable of running large-depth structured quantum algorithms, the question of how to best utilize them to solve chemistry problems is \fix{\cancel{one}} of deep scientific and commercial significance.
In recent years, following pioneering proposals such as the variational quantum eigensolver (VQE)~\cite{peruzzo2014variational}, research has focused on variational algorithms based on parameterized quantum circuits (PQC)~\cite{o2016scalable, cerezo2021variational, tilly2022variational}. 
In the long term, the quantum phase estimation (QPE) algorithm offers a promising route to evaluating the energy of molecular systems, as it may potentially provide an exponential advantage over classical full configuration interaction (FCI) treatment~\cite{aspuru2005simulated, lee2023evaluating}.
However, compared with VQE, the circuit depths required to run QPE are typically far too deep to run on near-term quantum devices, making VQE the approach of choice in the NISQ era.

VQE uses a parameterized quantum circuit to represent a system's wavefunction and works by tuning the circuit parameters to minimize the energy variationally.
In this setting, the quantum circuit plays the same role as the ansatz in classical quantum chemistry algorithms and, similarly, a variety of different \fix{\cancel{ansatze}ans\"{a}tze} have been proposed.
The first such proposal was the \fix{disentangled} unitary coupled cluster (UCC) ansatz~\cite{peruzzo2014variational}, which is a variant of the classical coupled cluster method.
\fix{While disentangled UCC differs from the traditional UCC ansatz developed for classical computers~\cite{bartlett1989alternative, kutzelnigg1991error}, 
for brevity, in the following, we will omit the word ``disentangled''. }
UCC is known to be difficult to implement in classical computers, yet the ansatz can be transformed into a PQC straightforwardly~\cite{anand2022quantum} and implemented on a quantum computer.
While excitations are commonly restricted to single and double excitations -- a case referred to as UCCSD -- a number of other variants of UCC have also been proposed~\cite{lee2018generalized, grimsley2019adaptive, elfving2021simulating}.
Another popular family of \fix{\cancel{ansatze}ans\"{a}tze} is the hardware-efficient ansatz (HEA)~\cite{kandala2017hardware}, which is designed to be first and foremost
easily implementable on a target quantum hardware platform, and includes fewer quantum chemistry heuristics compared to UCC.
In addition to ground state properties\fix{,} such as molecular energy, chemists are also interested in quantum dynamics~\cite{ollitrault2021molecular}.
Under the PQC framework, the time evolution of the circuit parameters can be determined using time-dependent variational principles~\cite{li2017efficient, yuan2019theory}. 

While the quality and availability of quantum computing hardware continue to improve, the majority of real experiments are currently still constrained to small numbers of qubits and very \fix{\cancel{short}shallow} circuits \fix{\cancel{depths}}~\cite{kandala2017hardware, colless2018computation, kandala2019error, rice2021quantum, gao2021applications, kirsopp2022quantum}.  
\fix{
Furthermore, optimizing circuit parameters on real devices is challenging: gradient-based methods are inefficient, as they rely on computing finite differences or parameter-shifts~\cite{mitarai2018quantum, schuld2019evaluating}, and both gradient and gradient-free methods are susceptible to noise.
}
These factors mean that, for the foreseeable future, the classical simulation of variational quantum algorithms will play an important role in studying and analyzing their performance and viability.  Although a variety of simulation software is currently available, there remain opportunities to significantly improve \fix{efficiency, functionality, and flexibility}.

Here we introduce \tcc{}, an \fix{efficient} open-source Python library for simulating variational quantum chemistry algorithms, designed to be easy to use as a black box while allowing for a high degree of flexibility and customizability.
\tcc{} is powered by \tc{}~\cite{zhang2023tensorcircuit}, a recently released quantum circuit simulation package featuring an advanced tensor network contraction simulation engine.
A recently developed algorithm to efficiently simulate the UCC ansatz on classical computers~\cite{chen2021quantum, kottmann2021feasible, rubin2021fermionic} is also implemented in \tcc{} with notable performance optimizations.
We demonstrate how to use \tcc{} by providing concrete code snippets, as well as links to online tutorials for features\fix{,} such as efficient UCC calculation, noisy circuit simulation, and quantum dynamics simulation.
In the examples, we include an accurate UCCSD potential energy curve of the water molecule corresponding to 34 qubits, the influence of quantum gate error rate and measurement shots on VQE energy, the spin relaxation dynamics of the spin-boson model, and much more.

The paper is structured as follows.
In the rest of the section, we briefly review variational quantum algorithms for quantum chemistry and existing simulation packages.
In Sec.~\ref{sec:overview}, we present the overall architecture and workflow of \tcc{} with an emphasis on \fix{\cancel{their}related} theoretical background.
Secs.~\ref{sec:ucc}, \ref{sec:hea}, and \ref{sec:dynamics} illustrate the features contained in the \tcc{} modules through code snippets and detailed simulation examples.


\subsection{Variational quantum algorithms for quantum chemistry}
\label{sec:intro-vqa}
Variational quantum algorithms for quantum chemistry have been an active area of research since the original VQE proposal~\cite{peruzzo2014variational}.
For both ground state properties and quantum dynamics, 
while details vary, proposed protocols typically adhere to the following workflow:

\bp{Input.} The input to the problem is the system Hamiltonian in second-quantized form.
For electronic structure problems, this can be expressed as
\begin{equation}
\label{eq:ham-abinit}
    H = \sum_{pq}h_{pq}a^\dagger_p a_q + \fix{\frac{1}{2}}\sum_{pqrs}h_{pqrs}a^\dagger_p a^\dagger_q a_r a_s + E_{\rm{nuc}}, \
\end{equation}
where $h_{pq}$ and $h_{pqrs} = [ps|qr]$ are one-electron and two-electron integrals, and $a^\dagger_p, a_p$ are fermionic creation and annihilation operators, respectively, acting on the $p$-th spin-orbital.
$E_{\rm{nuc}}$ is the nuclear repulsion energy.
For quantum dynamics simulations, the Hamiltonian varies from system to system,
and may contain only electronic terms~\cite{lee2021simulation, lee2022simulating} 
or both electronic and vibrational terms~\cite{ollitrault2020nonadiabatic, lee2022variational}. 
The latter is referred to as vibronic-coupling Hamiltonians.

\bp{Conversion to qubits.} The Hamiltonian, either electronic or vibronic-coupling,
is converted into an $N$-qubit Hamiltonian of the form
\begin{equation}
\label{eq:ham-pauli}
    H = \sum_j^M \alpha_j P_j, \
\end{equation}
where the $\alpha_j$ are real coefficients, $M$ is the total number of terms, and the $P_j$ are Pauli strings of the form $P_j = \sigma_{i_1}\otimes \sigma_{i_2}\otimes\ldots \sigma_{i_N}$ where the \fix{$\sigma_{i_k}$} are single qubit Pauli operators or the identity. 
For electronic Hamiltonians, the Jordan-Wigner transformation~\cite{JW28}, parity transformation~\cite{bravyi2002fermionic, seeley2012bravyi} and Bravyi-Kitaev transformation~\cite{seeley2012bravyi} are popular choices to perform this conversion.
The Jordan-Wigner and Bravyi-Kitaev transformations require one qubit per spin-orbital, 
while the parity transformation is able to save 2 qubits, relative to these other methods, due to electron number conservation in each spin sector.
For vibronic-coupling Hamiltonians, the nuclear states also need to be encoded into qubits via unary or binary encodings~\cite{sawaya2020resource}. 

\bp{Choice of ansatz.} A parameterized ansatz state $\ket{\psi(\theta)} = U(\theta)\ket{\psi_0}$ is selected, where $U(\theta)$ is the unitary corresponding to a quantum circuit characterized by a vector $\theta$ of tunable parameters, and $\ket{\psi_0}$ is a chosen reference state or initial state.
The core role of quantum computers \fix{or quantum processing units} (QPUs) in variational algorithms is to use quantum circuits to execute $U(\theta)$ and prepare $\ket{\psi(\theta)}$.
Thus, the ability of the variational ansatz in expressing the system wavefunction is a key factor
impacting the accuracy of variational quantum algorithms for quantum chemistry.
For electronic Hamiltonians, the proposed \fix{\cancel{ansatze}ans\"{a}tze} generally fall into unitary coupled cluster (UCC) based approaches~\cite{peruzzo2014variational, grimsley2019adaptive, nam2020ground, li2022toward, guo2022experimental}, 
and hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze}~\cite{kandala2017hardware,colless2018computation, kandala2019error, rice2021quantum, gao2021applications, kirsopp2022quantum}.
For quantum dynamics simulation,
the appropriate family of ansatz varies from system to system.
The variational Hamiltonian ansatz~\cite{wecker2015progress, miessen2021quantum} and adaptive ansatz~\cite{yao2021adaptive} \fix{automate the task of constructing problem-specific circuit ans\"{a}tze}.


\bp{Updating parameters.} In the case of VQE, 
\fix{
because the true ground state energy $E_0$ of the system gives a lower bound on the energy expectation value $\langle H \rangle_\theta := \bra{\psi(\theta)}H \ket{\psi(\theta)}$, $\langle H \rangle_\theta$ is minimized with respect to the parameters $\theta$, 
}
which \fix{in turn} gives an upper bound on $E_0$ i.e.,
\begin{align*}
    E_0 &\le \min_{\theta}\langle H \rangle_\theta.
\end{align*}
The quality of this bound depends \fix{\cancel{not only}} on the chosen ansatz. In general, the function is non-convex and one can only expect to find a local minimum, which depends on the parameter initializations and the optimization protocol used.
For dynamics problems, the parameters are propagated according to time-dependent variational principles,
of which McLachlan's variational principle 
is among the most popular choices for quantum computing~\cite{broeckhove1988equivalence, yuan2019theory}.
McLachlan's variational principle minimizes the distance between the ideal time derivative $-iH\ket{\psi(\theta)}$, i.e.
and actual time derivative $\pdv{}{t}\ket{\psi(\theta)}$
\begin{equation}
    \min_{\dot \theta} \norm{\left(\pdv{}{t} + iH\right )\ket{\psi(\theta)}}. \
\end{equation}
At each time step, $\dot \theta = \pdv{\theta}{t}$ is solved and then $\theta$ is evolved numerically according to $\dot \theta$.
The equation of motion for $\theta_k$, the $k$th element in vector $\theta$, is
\begin{equation}
\label{eq:eom-theta}
\sum_k M_{jk} \dot \theta_k =  V_j  , \
\end{equation}
where
\begin{equation}
\label{eq:dynamic-mv}
    M_{jk} = \Re{ \pdv{\bra{\psi}}{\theta_j} \pdv{\ket{\psi}}{\theta_k}  } , \
    V_j = \Im{  \pdv{\bra{\psi}}{\theta_j}  H \ket{\psi} }
\end{equation}
Both $M_{jk}$ and $V_j$
can be evaluated on a quantum computer with one additional ancilla qubit via the Hadamard test~\cite{li2017efficient}.
$\dot \theta_k$ can then be deduced using a standard linear equation solver on a classical computer.
After that, $\theta_k$ is propagated in time with time step $\tau$ either by the simple forward Euler method
$\theta_k(t + \tau) = \theta_k(t) + \tau \dot \theta_k(t)$
or more sophisticated initial value problem solvers\fix{,} such as Runge-Kutta solvers.


\subsection{Existing packages: Challenges and opportunities} 
A number of useful software packages are currently available, which facilitate the research, design, and validation of quantum computational chemistry algorithms.
A variety of general quantum computing packages, such as \qiskit{}~\cite{qiskit}, \pennylane{}~\cite{bergholm2018pennylane}, and \mindquantum{}~\cite{mq_2021}, have modules or sub-packages dedicated to chemistry applications, and there are also standalone quantum simulation packages that are mostly or completely 
designed for quantum computational chemistry, such as \tequilla{}~\cite{kottmann2021tequila}, \qschem{}~\cite{fan2022q}, and \qforte{}~\cite{stair2022qforte}. 

The efficiency and scalability of the packages depend crucially on the underlying circuit simulation algorithm.
The most commonly encountered quantum circuit simulator is statevector simulator, which is implemented in all simulation packages mentioned above.
By using statevector simulator, all (exponentially many with respect to the number of qubits) amplitudes of the wavefunction are computed and stored. For such simulators, the largest simulated UCC circuit to date contains fewer than 30 qubits~\cite{cao2022progress}.
In contrast, \fix{\cancel{M}m}atrix product state (MPS) simulators are able to tackle larger circuits, with \fix{around 100 qubits~\cite{schollwock2011density, shang2023towards}} possible.
Among the packages mentioned above,  \qiskit{}, \pennylane{}, and \qschem{} have implemented the MPS simulator.
However, MPS simulation involves approximations which could be problematic for the validation of quantum algorithms.
Another challenge for software development is noisy circuit simulation and interfacing with hardware.
\fix{
These features can help researchers better understand the behavior of quantum algorithms in real-world conditions, facilitating the development of noise-resilient quantum algorithms and better error mitigation techniques~\cite{ollitrault2020hardware, miessen2021quantum, li2022toward}, which are essential for building practical quantum computers.}
\qiskit{} is currently the only package capable of noisy circuit simulation \fix{and interfacing with quantum hardware. \cancel{and}Furthermore,} to the best of the authors' knowledge, quantum dynamics algorithms of molecular systems are not implemented in any packages currently available.


\tc{} is a recent open-source quantum circuit simulator based on tensor network contraction which -- in certain cases -- enables the simulation of up to 600 qubits without any approximation~\cite{zhang2023tensorcircuit}.
Differences between tensor network contraction simulators and MPS simulators are described in Sec.~\ref{sec:overview-engines}.
\tc{} is built upon industry-leading machine learning frameworks\fix{,} such as \jax{}~\cite{jax2018github}
and employs automatic differentiation (AD),
just-in-time (JIT) compilation, and vectorized parallelism to accelerate simulation.
\tc{} also possesses a fully-fledged noise model which enables efficient noisy circuit simulation. 
With its \tc{} backend, 
\tcc{} provides a competitive option for developing and analyzing quantum computational chemistry algorithms.
\fix{The role of \tc{} in \tcc{} is described in more detail in Sec.~\ref{sec:archi-workflow}.}



\section{TenCirChem Overview and Theoretical Backgrounds}
\label{sec:overview}

In this section, we provide a high-level picture of \tcc{} by introducing its architecture and typical workflow. In addition, we present the theoretical background relevant to the code examples found in Secs.~\ref{sec:ucc}, \ref{sec:hea} and \ref{sec:dynamics}.

\subsection{Architecture and workflow}
\label{sec:archi-workflow}
\bp{Architecture.} \tcc{}
consists of two primary modules (Fig.~\ref{fig:architecture}), corresponding to (i) electronic structure and (ii) quantum dynamics.
Both modules contain a set of pre-built \fix{\cancel{ansatze}ans\"{a}tze}, and user-specified custom \fix{\cancel{ansatze}ans\"{a}tze} are also supported.
Due to the popularity and unique mathematical structure of the UCC ansatz, an efficient simulation engine \lstinline{"civector"}
is implemented specifically for its efficient simulation. The details of the engine are included in the Supporting Information.
In short, the engine exploits particle number conservation to store the system wavefunction in \textit{configuration interaction vector} (\lstinline{"civector"}) form and uses \textit{UCC factor expansion} to accelerate simulation.
This engine relies heavily on \fix{the FCI module of} \pyscf{}~\cite{sun2018pyscf} \fix{for the construction and manipulation of the configuration interaction vector}.
\fix{
In addition, the gradient is evaluated by auto-differentiation with reversible computing, which is more memory-efficient than the traditional reverse-mode auto-differentiation implemented in standard machine-learning packages~\cite{luo2020yao}.
}
The \lstinline{"tensornetwork"} engine uses the \tc{} tensor network contraction kernels to perform circuit simulation. \fix{A variant of the \lstinline{"tensornetwork"} engine is } the \lstinline{"tensornetwork-noise"} engine\fix{, which} further includes circuit gate noise and measurement uncertainty in the simulation using the relevant utilities implemented in \tc{}.
\fix{The \lstinline{"qpu"} engine delegates circuit execution to real QPUs through \tc{}.}


\begin{figure}[htp]
    \centering
    \includegraphics[width=1.0\textwidth]{archi.png}
\caption{The architecture of \tcc{}. The electronic structure and quantum dynamics modules are described in depth in Secs.~\ref{sec:ucc}, \ref{sec:hea} and \ref{sec:dynamics}. See Sec.~\ref{sec:supported-ansatz} for more information on the supported ans\"{a}tze. For more details on engines and backends see Sec.~\ref{sec:overview-engines}.}
    \label{fig:architecture}
\end{figure}



\bp{Workflow.} As mentioned in the introduction, the starting point for variational quantum chemistry algorithms is normally taken to be the Hamiltonian in the second-quantized form.  For electronic structure problems, this means specifying the one- and two-electron integrals $h_{pq}$ and $h_{pqrs}$ in Eq.~\ref{eq:ham-abinit}. 
In \tcc{} this can be done either directly, by inputting these numbers explicitly, or indirectly, by specifying the 3D coordinates, atom types, and basis sets of each of the atoms in a molecule and having \pyscf{} compute the integrals automatically.  
The \fix{\cancel{general}} Hamiltonian \fix{\cancel{met}} in quantum dynamics is defined using the \reno{} \cite{renormalizer} package by specifying each term in the Hamiltonian.

Next, the Jordan-Wigner, parity \fix{or Bravyi-Kitaev conversion} from electronic Hamiltonian (Eq.~\ref{eq:ham-abinit}) to qubit Hamiltonian (Eq.~\ref{eq:ham-pauli}) is performed by \openfermion{}~\cite{mcclean2020openfermion}. 
The encoding of nuclear states to qubits and the construction of the \fix{\cancel{ansatze}ans\"{a}tze} are performed within the \tcc{} package.
The workflow and the underlying packages are summarized in Fig.~\ref{fig:workflow}\fix{, 
in accordance with Sec.~\ref{sec:intro-vqa}}, and will be elaborated on in the following sections.
Standard infrastructure packages, such as \numpy{} and \scipy{}, are omitted for brevity.
\fix{The specific tasks of each underlying package are summarized below:
\begin{itemize}
    \item \pyscf{}: specifying molecules; calculating integrals; configuration interaction vector construction and manipulation.
    \item \openfermion{}: specifying operators in fermion operator or qubit operator format; conversion from fermion operator to qubit operator.
    \item \reno{}: specifying general quantum dynamics Hamiltonian; conversion from symbolic operators to numeric operators.
    \item \tc{}: constructing custom PQC as ansatz; quantum circuit simulation via tensor network contraction; interfacing with QPU.
\end{itemize}
}


\begin{figure}
\centering
\tikzstyle{base} = [rectangle, rounded corners, thick,
scale=0.85,
minimum width=4cm, 
text width=3.5cm,
minimum height=2cm,
text centered]
\tikzstyle{comment} = [rectangle, rounded corners, thick,
scale=0.85,
minimum height=2cm]
\tikzstyle{task} = [base, draw=black]
\tikzstyle{arrow} = [very thick,->,>=stealth]
\begin{tikzpicture}[node distance=2.5cm]

\node (n1) [task]  {Specify Hamiltonian};
\node (n2) [task, xshift=5cm]  {Convert to qubits};
\node (n3) [task, xshift=10cm]  {Construct ansatz};
\node (n4) [task, xshift=15cm]  {Simulate circuit and update parameter};

\node (m1) [base, below of=n1] {\textcolor{black}{\pyscf{}$^{a}$} \\  \textcolor{black}{\openfermion{}$^{a}$} \\ \textcolor{black}{\reno{}$^{b}$} };
\node (m2) [base, below of=n2] {\textcolor{black}{\openfermion{}$^{a}$} \\ \textcolor{orange}{\tcc{}$^{b}$}};
\node (m3) [base, below of=n3] {\textcolor{orange}{\tcc{}$^{a, b}$}};
\node (m4) [base, below of=n4] {\textcolor{orange}{\tcc{}$^{a, b}$} \\ \textcolor{black}{\tc{}$^{a, b}$} \\ \textcolor{black}{\pyscf{}$^{a}$}};

\node (m1) [comment, below=1.5cm of m1.west, anchor=west]  {$^{a}$For electronic structure. $^{b}$For quantum dynamics.};

\draw [arrow] (n1) -- (n2);
\draw [arrow] (n2) -- (n3);
\draw [arrow] (n3) -- (n4);
\end{tikzpicture}
\caption{Typical workflow of variational quantum algorithms and the underlying packages used for each task in \tcc{}. }
    \label{fig:workflow}
\end{figure}

\subsection{Conversion to qubits}
Quantum simulation of physical systems requires converting fermions (for electronic structure calculations) and bosons (for encoding nuclear wavefunctions and quantum dynamics) to qubits.
\subsubsection{Electronic Structure}
Fermionic creation and annihilation operators obey the anticommutation properties
\begin{equation}
 \begin{aligned}
    \{a_i, a^\dagger_j\} & = a_i a^\dagger_j + a^\dagger_j a_i = \delta_{ij} \\
     \{a^\dagger_i, a^\dagger_j\} & =  \{a_i, a_j\} = 0
\end{aligned}
\end{equation}
while the qubit creation operator $c^\dagger = \frac{1}{2}(X - iY)$ and annihilation operator $c =\frac{1}{2} (X+iY)$ obey the commutation properties
\begin{equation}
    \{c_i, c^\dagger_j\} = \delta_{ij} , \quad [c^\dagger_i, c^\dagger_j] =  [c_i, c_j] = 0.
\end{equation}
To comply with the required fermionic anticommutation properties,
the Jordan-Wigner transformation~\cite{JW28} can be used to map fermionic ladder operators into products of Pauli $Z$ and qubit ladder operators
\begin{equation}
    a_j = \bigotimes_{l=0}^{j-1} Z_l \otimes c_j. 
\end{equation}
Alternatively, the parity transformation~\cite{bravyi2002fermionic, seeley2012bravyi} achieves  the same goal by letting each qubit record the parity of all preceding orbitals and itself. The mapping is then
\begin{equation}
    a_j = (c_j \otimes \ket{0} \bra{0}_{j-1} - c^\dagger_j \otimes \ket{1} \bra{1}_{j-1}  ) \otimes \bigotimes_{l={j+1}}^{N-1} X_l 
\end{equation}
where $N$ is the total number of qubits.
If the ansatz conserves the total particle number, then the last qubit will not change during computation and can be removed without loss of accuracy.
If $S_z$ is also conserved, another qubit can be saved.
Thus, the parity transformation uses 2 fewer qubits than the Jordan-Wigner transformation. 
In \tcc{}, both transformations are carried out by calling \openfermion{}.

\subsubsection{Quantum Dynamics}
\label{sec:overview-conv-dynamics}
One of the key differences between quantum dynamics simulation and electronic structure calculations
is that quantum dynamics requires incorporating nuclear information in time evolution.
Similar to the case of electrons, a proper basis set must first be chosen to represent the nuclear wavefunction and operators in second-quantized form~\cite{mcardle2019digital, ollitrault2020hardware, ollitrault2020nonadiabatic}.
One popular choice is the harmonic eigenbasis, 
in which the nuclear position operator $x$ and momentum operator $p$ are expressed as
\begin{equation}
\begin{aligned}
x & = \sqrt{\frac{1}{2m\omega}} (b^\dagger + b), \ \\
p & = i\sqrt{\frac{m\omega}{2}} (b^\dagger - b), \
\end{aligned}
\end{equation}
where $m$ is the oscillator mass,
$\omega$ is the oscillator frequency and
$b^\dagger$ ($b$) are bosonic creation (annihilation) operators respectively.
The infinite boson levels are then truncated to the lowest $N$ levels for further encoding.
Other choices for the nuclear basis set include the real-space grid basis 
and a variety of discrete value representations~\cite{colbert1992novel}.
In any case, each nuclear degree of freedom is represented by a finite number of basis states $\ket{\psi} = \sum_i^N c_i \ket{i}$.


In quantum simulation, each bosonic basis vector $\ket{i}$ must be encoded into qubits, so that the system wavefunction can be described by a quantum circuit and operators can be represented by Pauli strings.
The principle for the encoding is equivalent to that of encoding integers into bit strings, and there are two common encoding strategies -- based on unary and binary encodings --
requiring $\order{N}$ and $\order{\log{N}}$ qubits, respectively~\cite{sawaya2020resource}.
Binary encoding with Gray codes is a variant of the standard binary encoding that involves changing only one bit between consecutive integers, which can be used to facilitate the efficient encoding of operators $b^\dagger$ and $b$.
\tcc{} supports all of the encoding schemes \fix{and} by default uses binary encoding with Gray codes because of its compact representation.
We note that an efficient variational encoding scheme requiring only $\order{1}$ qubits was proposed recently~\cite{li2023efficient}. 


\subsection{Supported \fix{\cancel{ansatze}ans\"{a}tze}}\label{sec:supported-ansatz}
\tcc{} supports three classes of variational \fix{\cancel{ansatze}ans\"{a}tze}: (i) Unitary Coupled Cluster (UCC) -- 
 of which UCCSD, $k$-UpCCGSD, and paired UCCD (pUCCD) are variants --, (ii) Hardware-Efficient, and (iii) Variational Hamiltonian.

 \subsubsection{Unitary Coupled Cluster Ansatz}
 \label{sec:overview-ucc}
UCC \fix{\cancel{ansatze}ans\"{a}tze} have the form
 \begin{align}\label{eq:ucc}
     e^{T(\theta)}\ket{\phi}
 \end{align}
 where 
 \begin{align}\label{eq:ucc-excitations}
     T(\theta) &=\sum_{pq} \theta_{pq}\left( a^\dagger_p a_q - \text{h.c.}\right)+ \sum_{pqrs}\theta_{pqrs}\left(a^\dagger_p a^\dagger_q a_r a_s - \text{h.c.}\right)\ldots,
 \end{align}
$\theta$ denotes the vector of tunable parameters $\theta_{pq}, \theta_{pqrs}, \ldots$, and $\ket{\phi} = \ket{\text{HF}}$ is the Hartree--Fock state.  In general, excitations of any order are permitted, although it is common to only consider single and double excitations, in which case the ansatz is referred to as UCCSD.
The indices are usually confined to excitations from occupied orbitals to virtual (unoccupied) orbitals.
``Generalized'' excitations do not have to satisfy this requirement 
.
The generalized counterpart of UCCSD is UCCGSD~\cite{lee2018generalized}.

As the terms in Eq.~\ref{eq:ucc-excitations} do not necessarily commute, the exact implementation of Eq.~\ref{eq:ucc} on a gate model quantum computer is difficult.
In fact, to the best of our knowledge the ansatz defined by Eq.~\ref{eq:ucc} and Eq.~\ref{eq:ucc-excitations}
is never used in any practical VQE algorithm.
Instead, one considers a Trotterized approximation of the ansatz, also referred to as disentangled UCC~\cite{evangelista2019exact}. 
Although disentangled UCC is traditionally viewed as an approximation to the original UCC,
it can in fact exactly represent general fermionic states \fix{given appropriate operator ordering}
and should probably be considered as an alternative ansatz to the original UCC~\cite{evangelista2019exact}.
In general, the disentangled UCC ansatz can be written as
\begin{equation}
\label{eq:ucc2}
    \ket{\Psi(\theta)}_{\text{UCC}} := \prod_{k=\nex{}}^1 e^{\theta_k G_k} \ket{\phi}, \
\end{equation}
where each
$G_k$ is the anti-Hermitian excitation operator for each term in Eq.~\ref{eq:ucc-excitations}, 
and $\nex$ is  the total number of excitations. In the following, the terms $e^{\theta_k G_k}$ are referred to as UCC factors.
The UCC \fix{\cancel{ansatze}ans\"{a}tze} implemented in \tcc{} can all be viewed as special cases of Eq.~\ref{eq:ucc2}.
The specific formulation of UCCSD, $k$-UpCCGSD, and pUCCD are reviewed in the Supporting Information. 



\subsubsection{Hardware-Efficient Ansatz}
Hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze} are designed to be easily implementable on NISQ devices but do not necessarily preserve symmetries in molecular systems.
Finding the global minimum for such circuits can be challenging due to the vanishing gradient phenomenon and the presence of local minima~\cite{mcclean2018barren, choy2023molecular}.
However, because the required circuit depths can be much smaller than for UCC, 
hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze} are widely used in quantum computational chemistry experiments performed on real quantum processors~\cite{kandala2017hardware, colless2018computation, kandala2019error, rice2021quantum, gao2021applications, kirsopp2022quantum}.
\tcc{} implements one of the most popular hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze}, the $R_y$ ansatz~\cite{gao2021computational, gao2021applications,mihalikova2022cost, choy2023molecular},
whose circuit consists of interleaved layers of $R_y$ and CNOT gates
\begin{equation}
    \ket{\Psi(\theta)}_{R_y} :=  \prod_{l=k}^1 \left [ L_{R_y}^{(l)}(\theta) L_{\rm{CNOT}}^{(l)} \right ] L_{R_y}^{(0)}(\theta) \ket{\phi}, 
\end{equation}
where $k$ is the total number of layers, and the layers are defined as
\begin{equation}
\begin{aligned}
L_{\rm{CNOT}}^{(l)} & = \prod_{j=N-1}^{1} \textrm{CNOT}_{j, j+1}, \ \\
 L_{R_y}^{(l)}(\theta) & =  \prod_{j=N}^{1} \textrm{RY}_{j}(\theta_{lj}). \
\end{aligned}
\end{equation}
The gate subscripts refer to the qubit index on which the gate acts and $N$ is the total number of qubits.
An example of the ansatz is depicted in Fig.~\ref{fig:ry}.
One reason for using the $R_y$ gate is that it enforces the wavefunction coefficients to be real, which is a desired property for electronic structure problems.

As a huge number of possible hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze} can be defined,
instead of providing templates for all of them, \tcc{} allows the hardware-efficient \fix{\cancel{ansatze}ans\"{a}tze} from the \qiskit{} library to be directly imported, and other customized \fix{\cancel{ansatze}ans\"{a}tze} can be defined by the user using \tc{} (see Sec.~\ref{sec:noisy-basic} for examples).

\subsubsection{Variational Hamiltonian Ansatz}
For quantum dynamics simulations, \tcc{} provides utilities to construct the 
variational Hamiltonian ansatz~\cite{wecker2015progress, miessen2021quantum}
based on user-specified Hamiltonians.
This type of ansatz \fix{depends on the Pauli strings $P_j$ contained in the Hamiltonian and thus encodes Hamiltonian information}.
Suppose the Hamiltonian is composed of $M$ Pauli strings $P_j$, as defined in Eq.~\ref{eq:ham-pauli}. The corresponding variational Hamiltonian ansatz has the form
\begin{equation}
\label{eq:dynamic-vha}
    | \Psi \rangle = \prod_l^k \prod_j^M e^{-i \theta_{lj} P_j} | \phi \rangle, 
\end{equation}
where $| \phi \rangle$ is the initial state of the system, $\theta_{kj}$ is the circuit parameter, and $k$ is a parameter defining the number of layers in the ansatz.
This heuristic construction is based on the fact that, in the short time limit, the system wavefunction $e^{-iHt}\ket{\phi}$ can be exactly described by Eq.~\ref{eq:dynamic-vha}\fix{\cancel{ with finite $k$}}.

\subsection{Engines and Backends}
\label{sec:overview-engines}
We use the term ``engine'' to refer to the methods -- such as \lstinline{"tensornetwork"} and \lstinline{"civector"} -- used to simulate the quantum circuits in \tcc{}.
The term ``backend'' refers to the underlying numerical package used to perform the simulation, such as \numpy{} and \jax{}.
The most common engine in \tcc{} is the \lstinline{"tensornetwork"} engine powered by \tc{},
which views the quantum circuit as a network of low-rank tensors and performs circuit simulation via tensor network contraction~\cite{markov2008simulating}.
This approach can offer significant advantages over full statevector simulators which may encounter memory bottlenecks.
As a result, tensor network contraction is the most frequently used method for performing large-scale quantum circuit simulations\fix{,} such as the simulation of random circuits used in quantum supremacy experiments~\cite{liu2021closing, pan2022simulation}.
\fix{
When contracting a tensor network, it is crucial to find an efficient contraction path.
The default contraction path finder in \tcc{} is based on a greedy algorithm,
which has minimal overhead, but may not be satisfactory for large quantum circuits.
The customization of contraction paths is possible via \tc{}.
}


We note that \fix{the tensor network contraction simulator} should not be confused with an MPS simulator~\cite{schollwock2011density}, although the two do share a number of things in common.
In particular, the tensor network contraction method does not assume the circuit wavefunction to adopt MPS form and does not perform any truncations to the wavefunction.

The \fix{tensor network simulator} can also be extended to the simulation of noisy circuits, using density matrix $\rho$.
\fix{The simulation of noisy quantum circuits is thus twice as memory intensive as pure state simulation.
We stress that the engine does not perform any truncation to the target density matrix, which is different from a number of preceding works~\cite{noh2020efficient, cheng2021simulating}.}
In the presence of noise, 
unfortunately, symmetries encoded in the ansatz are broken and cannot be exploited.
In \tc{}, noise channels $\mathcal{E}$ are defined by their corresponding Kraus operators $K_i$, i.e.,
\begin{equation}
    \mathcal{E}(\rho) = \sum_i K_i \rho K_i^\dagger\ .
\end{equation}
The action of $\{K_i\}$ on the circuit is achieved by transforming them into a superoperator.
\fix{
More specifically, if the channel acts on $N$ qubits, it is converted to a matrix with size $4^N\times 4^N$,
as a node in the density matrix tensor network.
We note that \tc{} supports noisy circuit simulation via Monte-Carlo sampling in addition to using density matrices, although this algorithm is not currently implemented in \tcc{}.
}

Of the various backends supported by \tcc{}, the \jax{} backend is perhaps the most versatile and can generally be used in most cases. This backend also supports GPU and TPU calculations once \jax{} is properly configured. 
If the \lstinline{"civector"} engine is used, the \numpy{} and \cupy{} backends are preferred for CPU and GPU calculations, respectively.
The reason for this is that the code in the \lstinline{"civector"} engine is highly optimized and just-in-time (JIT) compilation overheads become a bottleneck.


\subsection{Installing and contributing to \tcc{}}
\tcc{} is written in Python and can be installed via \lstinline{pip install tencirchem} 
using the command line.
The source code is hosted on the GitHub repository \url{https://github.com/tencent-quantum-lab/TenCirChem}.
We welcome all members of the quantum chemistry community to contribute to the continued development of \tcc{}.

\section{The Electronic Structure Module I. Unitary-Coupled Cluster ansatz }
\label{sec:ucc}

\subsection{Basic Usage}


The basic usage of \tcc{} can be illustrated in five lines of codes, which we demonstrate below using the UCCSD ansatz to find the minimum energy of an \ce{H_2} molecule:


\begin{lstlisting}[language=Python, caption=Simple UCCSD calculation for the hydrogen molecule., label={lst:uccsd-simple}]
from tencirchem import M, UCCSD

h2 = M(atom=[["H", 0, 0, 0], ["H", 0, 0, 0.741]])

uccsd = UCCSD(h2)
uccsd.kernel()
uccsd.print_summary(include_circuit=True)
\end{lstlisting}

The remainder of this section will explain Code Snippet~\ref{lst:uccsd-simple} in more detail.
The corresponding \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/ucc_functions.ipynb}{Jupyter Notebook} is available online.

\subsubsection{Defining the molecule and basis set}
\tcc{} uses the \pyscf{} \lstinline{Mole} object to define the molecule of interest.
In other words, \lstinline{from tencirchem import M} is equivalent to \lstinline{from pyscf import M}.
The syntax for defining molecules is thus the same as that for \pyscf{}.
For example, using 3D coordinates,
atom types and coordinates  (in Angstroms) are specified in a list as shown in Code Snippet~\ref{lst:uccsd-simple}.
By default, the STO-3G minimal basis set is used, but \pyscf{} allows other basis sets to be specified via the \lstinline{basis} argument, e.g.,
\begin{lstlisting}[language=Python]
h2 = M(atom=[["H", 0, 0, 0], ["H", 0, 0, 0.741]], basis="cc-pvdz")
\end{lstlisting}


\bp{Built-in molecules.} In addition to specifying molecules by hand, the user can import a number of pre-specified molecules in STO-3G basis set from the \lstinline{tencirchem.molecule} module for debugging and fast prototyping, e.g.,
\begin{lstlisting}[language=Python]
from tencirchem.molecule import h2, h4, h8
\end{lstlisting} 
Once imported, the molecules can be used exactly as if they had been defined manually. 
The coordinates and the basis sets of these built-in molecules can be obtained by inspecting the \lstinline{Mole} object with \lstinline{m.atom} and \lstinline{m.basis} respectively.
The \lstinline{tencirchem.molecule.h2} molecule -- with a bond distance of 0.741 Ã… -- is frequently used in the following code examples.

\subsubsection{Specifying the ansatz and obtaining reference energies}
Once the \lstinline{h2} molecule has been specified, we initialize the UCCSD ansatz via the line
\begin{lstlisting}[language=Python]
uccsd = UCCSD(h2)
\end{lstlisting}
In addition to UCCSD, \tcc{} supports the $k$-UpCCGSD and pUCCD \fix{\cancel{ansatze}ans\"{a}tze}. These are based on the UCC base class, and can be implemented in a similar way to UCCSD once imported via:
\begin{lstlisting}[language=Python]
from tencirchem import KUPCCGSD, PUCCD
\end{lstlisting}

Ansatz information is accessible through class attributes (see Code Snippet~\ref{lst:attributes}).
The conventions for the orbital indices are described in the Supporting Information.
\begin{lstlisting}[language=Python, caption={Several useful attributes of the UCCSD class. Example corresponds to the \ce{H2} molecule.},label={lst:attributes}]
>>> # two single excitations and one double excitation
>>> uccsd.ex_ops
[(3, 2), (1, 0), (1, 3, 2, 0)]
>>> # `param_ids` maps excitation operators to parameters
>>> # some excitation operators share the same parameter due to symmetry
>>> uccsd.param_ids
[0, 0, 1]
>>> uccsd.init_guess  # generated by MP2
[0.0, -0.07260814651571333]
>>> uccsd.params # the optimized parameters
array([ 3.40632986e-17, -1.12995353e-01])
\end{lstlisting}


\bp{UCCSD class as a toolbox.} The \lstinline{UCCSD} class also allows other useful attributes to be obtained (see Code Snippet~\ref{lst:toolbox}).
The purpose is to make information in \tcc{} easy to inspect, facilitating its use as a handy toolbox.
For example, one may use the \lstinline{UCCSD} class to inspect for molecular attributes, electron integrals, reference energies and the
Jordan-Wigner transformed Hamiltonian, all of which are available 
without needing to first call the \lstinline{uccsd.kernel()} method.

\begin{lstlisting}[language=Python, caption={Several other useful attributes of the UCCSD class are also directly available without first needing to call the \lstinline{uccsd.kernel()} method.},label={lst:toolbox}]
>>> uccsd.n_qubits, uccsd.n_elec
(4, 2)
>>> # PySCF objects
>>> uccsd.mol, uccsd.hf
(<pyscf.gto.mole.Mole at 0x7f9daec92b90>, <pyscf.scf.hf.RHF at 0x7f9d92d1ec10>)
>>> # reference energies
>>> uccsd.e_hf, uccsd.e_mp2, uccsd.e_ccsd, uccsd.e_fci, uccsd.e_nuc
(-1.116706137236105,
 -1.1298675557838804,
 -1.1372745709766439,
 -1.1372744055294395,
 0.7141392859919029)
>>> # one and two-body integrals in molecular orbital basis, chemists' notation
>>> uccsd.int1e.shape, uccsd.int2e.shape
((2, 2), (2, 2, 2, 2))
>>> uccsd.h_fermion_op  # Hamiltonian as openfermion FermionOperator
0.7141392859919029 [] +
-1.2527052599711868 [0^ 0] +
-0.48227117798977825 [0^ 1^ 0 1] +
-0.6745650967143663 [0^ 2^ 0 2] +
[...... The rest of the output omitted ......]
>>> uccsd.h_qubit_op  # Hamiltonian as openfermion QubitOperator
(-0.09835117053027564+0j) [] +
(0.04531660419443148+0j) [X0 X1 X2 X3] +
(0.04531660419443148+0j) [X0 X1 Y2 Y3] +
(0.04531660419443148+0j) [Y0 Y1 X2 X3] +
[...... The rest of the output omitted ......]
\end{lstlisting}



\bp{Specifying integrals directly.} Rather than using a molecule as the input to UCCSD, one may define a UCCSD object by specifying the one and two electron integrals, without needing to explicitly refer to a molecule.  That is, applying UCCSD to the second-quantized \textit{ab initio} Hamiltonian Eq.~\ref{eq:ham-abinit}
can be done via 
\begin{lstlisting}[language=Python]
uccsd_from_integral = UCCSD.from_integral(int1e, int2e, n_elec, e_core)
\end{lstlisting}
with 
\begin{itemize}
    \item \lstinline{int1e}: an array of shape $(N,N)$  with $p,q$-th element storing the one-electron integral $h_{pq}$.
    Here $N$ is the number of spatial orbitals.
    \item \lstinline{int2e}: an array of shape $(N, N, N, N)$ with $p,q,r,s$-th element storing the two-electron integral $(pq|rs)$, in spatial orbital and chemists' notation.
    \item \lstinline{n_elec}: an integer specifying the total number of electrons in the system. Currently,  \tcc{} only supports closed-shell molecules.
    \item \lstinline{e_core}: a floating-point number for the nuclear repulsion energy $E_{\rm{nuc}}$ or the core energy if frozen occupied orbitals are involved. 
\end{itemize}

\subsubsection{Optimizing the energy}
\label{sec:ucc-optimize}
The command \lstinline{uccsd.kernel()} runs the optimization procedure to minimize the ansatz energy with respect to the variational parameters, and returns the minimum energy found. 
 By default, \tcc{} uses the L-BFGS-B optimizer implemented in \textsc{SciPy}~\cite{2020SciPy-NMeth}.
 Once \lstinline{uccsd.kernel()} has been run, the minimum ansatz  energy can be accessed by \lstinline{uccsd.energy()} or \lstinline{uccsd.e_ucc}.
The system statevector and configuration interaction vector are available by \lstinline{uccsd.statevector()} and \lstinline{uccsd.civector()}, e.g.,
\begin{lstlisting}[language=python]
>>> uccsd.civector() # configuration interaction vector
array([ 9.93623806e-01,  1.08284918e-16,  1.08284918e-16, -1.12746318e-01])
\end{lstlisting}
The optimized parameters can be obtained by \lstinline{uccsd.params}, and
the one- and two-body reduced density matrices are available 
by \lstinline{uccsd.make_rdm1()}
and \lstinline{uccsd.make_rdm2()}, respectively. 
Functions such as \lstinline{uccsd.energy}, \lstinline{uccsd.statevector}, and \lstinline{uccsd.civector} also accept custom circuit variational parameters
. For example,
\begin{lstlisting}[language=python]
>>> # if all parameters are zero, then the UCC energy is identical to HF energy
>>> uccsd.energy(np.zeros(uccsd.n_params)), uccsd.e_hf
(-1.1167061372361045, -1.116706137236105)
\end{lstlisting}

\subsubsection{Outputting quantum circuits}
\label{sec:circuit_output}

The quantum circuit corresponding to the ansatz state can be obtained via
\begin{lstlisting}[language=Python]
c = uccsd.get_circuit()
\end{lstlisting}
which returns a \tc{} \lstinline{Circuit} object, which can then be inspected, manipulated and executed.
For example, a summary of the gates in the circuit can be obtained by
\begin{lstlisting}[language=Python]
c.gate_summary()
\end{lstlisting}
Also, conversion of the circuit from \tc{} to Qiskit format is straightforward:
\begin{lstlisting}[language=Python]
c_qiskit = c.to_qiskit()
\end{lstlisting}
By default, \tcc{} compiles circuits using the efficient method of Yordanov, Arvidsson-Shukur, and Barnes (YAB)~\cite{yordanov2020efficient, magoulas2023cnot}\fix{, } which is based on multi-qubit controlled rotations (see Fig.~\ref{fig:uccsd_h2_circuit}).
\fix{Currently triple or higher order excitations are not implemented in \tcc{}.}
\lstinline{uccsd.get_circuit(decompose_multicontrol=True)} generates the circuit with the multi-qubit controlled gate decomposed into elementary rotation gates and CNOT gates.
This decomposition is useful for noisy circuit simulation or execution on hardware. See Code Snippet~\ref{lst:noisy-ucc} for an example.
Compilation via a more traditional Trotterized method is also possible, using
\begin{lstlisting}[language=Python]
c = uccsd.get_circuit(trotter=True)
\end{lstlisting}
although this can lead to circuits significantly deeper than those compiled by the YAB method~\cite{yordanov2020efficient}. 

\begin{figure}[h!]
    \centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.2em @!R { \\
	 	\nghost{{q}_{0} :  } & \lstick{{q}_{0} :  } & \qw & \ctrl{1} & \gate{R_y(\theta_0)} & \ctrl{1} & \ctrl{2} & \qw & \ctrl{3} & \gate{R_y(\theta_1)} & \ctrl{3} & \qw & \ctrl{2} & \qw & \qw\\
	 	\nghost{{q}_{1} :  } & \lstick{{q}_{1} :  } & \gate{X} & \targ & \ctrl{-1} & \targ & \qw & \targ & \qw & \ctrlo{-1} & \qw & \targ & \qw & \qw & \qw\\
	 	\nghost{{q}_{2} :  } & \lstick{{q}_{2} :  } & \qw & \ctrl{1} & \gate{R_y(\theta_0)} & \ctrl{1} & \targ & \qw & \qw & \ctrlo{-1} & \qw & \qw & \targ & \qw & \qw\\
	 	\nghost{{q}_{3} :  } & \lstick{{q}_{3} :  } & \gate{X} & \targ & \ctrl{-1} & \targ & \qw & \ctrl{-2} & \targ & \ctrl{-1} & \targ & \ctrl{-2} & \qw & \qw & \qw\\
\\ }}
\caption{The quantum circuit corresponding to the UCCSD ansatz for the \ce{H_2} molecule with STO-3G basis, compiled by the method \fix{\cancel{of} in Ref.~\citenum{yordanov2020efficient}}. The two $X$ gates at the left of the circuit are used to create the initial Hartree--Fock state $\ket{0101}$. The multicontrol gate applies a parameterized $R_y$ rotation to one of the four qubits, conditioned on the state of the other three.}
    \label{fig:uccsd_h2_circuit}
\end{figure}



\subsection{Applications and benchmarking}
\label{sec:ucc-app}
\fix{
In this section, we use concrete examples to demonstrate the efficiency and flexibility of \tcc{}.
All calculations are carried out on a single computational node with the \lstinline{"civector"} engine. 
Throughout the paper, the wall time reported only accounts for VQE optimization time. Classical pre-processings, such as obtaining integrals and Hartree--Fock calculation, are not included in the reported time.
}
\subsubsection{Hydrogen chains and the hydrogen molecule}
Table\fix{\cancel{.}}~\ref{tab:ucc-hchain} gives the time required by \tcc{} to compute the minimum UCCSD energy for chains 
of increasing numbers of hydrogen atoms, using an STO-3G basis set.
Atoms in each chain are uniformly distributed with an interatomic distance set to 0.8 Ã….
The largest system simulated is \ce{H16}, corresponding to 32 qubits. For such a system, storing the wavefunction in Fock space alone is already an arduous task,
while the running time for \tcc{} is still acceptable. Whereas other common quantum simulation packages usually struggle to simulate \ce{H10} (which requires 20 qubits),
\tcc{} is able to obtain the UCCSD ground state energy of this chain in 14 seconds on a single GPU node.
\fix{As a concrete example, \textsc{Qiskit-Nature} version 0.5.2 spends 34 seconds simulating \ce{H4} and 943 seconds simulating \ce{H6}, and reports an out-of-memory error when simulating larger systems.
Other packages, such as \pennylane{} and \tequilla{}, show similar performance.
We note that the high efficiency of \tcc{} is primarily due to the \lstinline{"civector"} engine and hardware acceleration plays a relatively minor role.}

\begin{table}[h]
\caption{\label{tab:ucc-hchain}
UCCSD ground state energy optimization time for hydrogen chains using \tcc{}.
CPU calculations are based on an Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz
while GPU calculations use the NVIDIA(R) Tesla(R) V100-PCIE-32GB. Energy errors are with respect to FCI energy, and could be reduced by adding more excitation operators in the ansatz~\cite{evangelista2019exact}.
}
\begin{tabular}{lrrrrrrr}
\hline
Molecule & Qubits & Excitations & Parameters & Device & Time & Energy  & Error \\
 &  &  &  &  & (s) & (mH)  & (mH) \\
\hline
\ce{H4 }      & 8   &  18  & 11           & CPU     & 0.05   & -2,167.55    & 0.01       \\
\ce{H6 }      & 12  &  69  & 39           & CPU     & 0.4    &  -3,204.14   & 0.27       \\
\ce{H8 }      & 16  &  200 & 108          & CPU     & 1.9    &  -4,242.52   & 0.88       \\
\ce{H10}      & 20  &  467 & 246          & GPU     & 14     & -5,282.21    & 1.37       \\
\ce{H12}      & 24  &  954 & 495          & GPU     & 51   &  -6,322.29     & 2.13       \\
\ce{H14}      & 28  &  1,749 & 899        & GPU     & 2,093  & -7,362.81    & 2.92       \\
\ce{H16}      & 32  &  2,976 & 1,520      & GPU     & 50,909  &  -8,403.63  & 3.72       \\
\hline
\end{tabular}
\end{table}

The hydrogen chain actually represents a class of molecular systems that are particularly difficult to simulate
in \tcc{}. 
In these systems, the number of spatial orbitals $N$ is the same as the number of electrons $M$.
In the following, we consider a case at the other extreme, where $M \ll N$, and simulate the potential energy curve of the $\ce{H2}$ molecule using the cc-pVTZ basis set~\cite{dunning1989gaussian}. This corresponds to $M=2$, $N=28$ and a VQE circuit on 56 qubits.
Running on a single laptop CPU, \tcc{} is able to produce all UCCSD energy values in Table~\ref{tab:ucc-h2} in 20 seconds.
Because of the small value of $M$, both the dimension of the configuration interaction space (784) and the number of excitation operators (155) are small.
\fix{
Since the \lstinline{"civector"} engine is exact, 
the small error in Table~\ref{tab:ucc-h2} is likely due to the inexactness of the disentangled UCC ansatz.
}


\begin{table}[h]
\caption{\label{tab:ucc-h2}
UCCSD/cc-pVTZ calculation of \ce{H2} in \fix{\tcc{}}, using a VQE circuit on 56 qubits. Energy errors are with respect to FCI.
}
\begin{tabular}{lrr}
\hline
Atom distance (Ã…) & Energy(mH)  & Error (mH) \\
\hline
0.3   & -692.85983   & 0.00000 \\
0.6   & -1153.51794   & 0.00000 \\
0.9   & -1160.41280   & 0.00001 \\
1.2   & -1112.06753   & 0.00005 \\
1.5   & -1066.16823   & 0.00014 \\
1.8   & -1034.07993   & 0.00023 \\
2.1   & -1015.56097   & 0.00028 \\
2.4   & -1006.42068   & 0.00029 \\
2.7   & -1002.39048   & 0.00028 \\
\hline
\end{tabular}
\end{table}

\subsubsection{Potential energy curve of H$_2$O}

We now compute the potential energy curve of a realistic molecule, \ce{H2O}.
The \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/example/water_pes.py}{Python script} to produce the data is available online.
This molecule has been used to benchmark many quantum algorithms~\cite{li2019quantum,ryabinkin2020iterative},
yet previous works usually use a minimal basis set or small active space.
Here, we use \tcc{} to calculate the UCCSD energy of \ce{H2O} with 6-31G(d) basis set~\cite{hehre1972self, hariharan1973influence}
with only the $1s$ orbital of the \ce{O} atom frozen.
This corresponds to 8 electrons in 17 orbitals, a quantum circuit on 34 qubits, and an ansatz involving 565 independent parameters and 1078 excitations.

We study the symmetric stretching of the O-H bond with the H-O-H angle fixed at the experimental value of 104.45Â°~\cite{hoy1979precise}.
Results are summarized in Fig.~\ref{fig:h2o}.
The UCCSD energy by \tcc{} is very close to the FCI solution with a slight deviation observed at long bond lengths.
The equilibrium bond length is determined to be 0.97 Ã…, in good agreement with the experimental value (0.9584 Ã…).
To highlight the necessity of using an appropriate basis set,
in Fig.~\ref{fig:h2o} the FCI energy using the minimal STO-3G basis set is also given.
As expected, the energy corresponding to the STO-3G basis set is significantly higher than that corresponding to the 6-31G(d) basis set. Furthermore, the equilibrium bond distance predicted using the STO-3G basis set is 1.02 Ã…, 
significantly larger than the experimental value.
\fix{On average, \tcc{} takes approximately 15 minutes to produce each UCCSD energy value in Fig.~\ref{fig:h2o}, using the same GPU platform as in Table~\ref{tab:ucc-hchain}.}


\begin{figure}[htp]
    \centering
    \includegraphics[width=0.75\textwidth]{h2o.pdf}
\caption{Potential energy curve for the symmetric stretching of the O-H bond in \ce{H2O} with 6-31G(d) basis set. The $1s$ orbital of the O atom is frozen and the whole system is described by an (8e, 17o) active space and a quantum circuit on 34 qubits. The FCI energy with STO-3G basis set is included for comparison.}
    \label{fig:h2o}
\end{figure}


\subsubsection{Hubbard model}

As a final example, we use \tcc{} and UCCSD to calculate the ground state energy of the one-dimensional Hubbard model at half-filling.
The full \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/hubbard_model.ipynb}{Jupyter Notebook} is available online.
The Hamiltonian is
\begin{equation}
    H = -t \sum_{j, \sigma} (c^\dagger_{j+1, \sigma} c_{j, \sigma} + c^\dagger_{j, \sigma} c_{j+1, \sigma}) + U \sum_j n_{j \uparrow}  n_{j \downarrow}, \
\end{equation}
where $c^\dagger_{j, \sigma}$ ($c_{j, \sigma}$) creates (annihilates) an electron with spin $\sigma$ at site $j$,
$n_{j \uparrow}$ and $n_{j \downarrow}$ are electron occupation number operators at site $j$,
$t$ is the hopping integral and $U$ characterizes the Coulomb repulsion interaction strength.  We assume periodic boundary conditions.



Although the Hubbard model is not directly related to any molecular systems,
the Hamiltonian is a special case of the \textit{ab initio} Hamiltonian of Eq.~\ref{eq:ham-abinit}, and thus \tcc{} allows the construction of the corresponding \lstinline{UCCSD} objects by specifying the one-body and two-body integrals.


\begin{lstlisting}[language=Python, caption=Calculation of the UCCSD energy of half-filled Hubbard model.]
import numpy as np
from tencirchem import UCCSD

n = 6  # the number of sites
n_elec = n  # half filled
t = U = 1  # model parameters

# setup the integrals
int1e = np.zeros((n,n))
for i in range(n - 1):
    int1e[i, i + 1] = int1e[i + 1, i] = -t
int1e[n - 1, 0] = int1e[0, n - 1] = -t
int2e = np.zeros((n, n, n, n))
for i in range(n):
    int2e[i, i, i, i] = U
    
# do the calculation
uccsd = UCCSD.from_integral(int1e, int2e, n_elec)
uccsd.kernel()
\end{lstlisting}

Results are shown in Fig.~\ref{fig:hubbard}.
When $U/t$ is small, both CCSD and UCCSD coincide well with the FCI solution.
As $U/t$ increases, CCSD deviates from the FCI solution, whereas the UCCSD solution tracks the FCI value much more closely, indicating that UCCSD can be better than CCSD at capturing strong correlations,
a finding consistent with \fix{a} previous report~\cite{sokolov2020quantum}.

To better recover \fix{\cancel{the}} static correlation using UCCSD, more terms can be added to the UCC ansatz
or one may consider combining UCC with other algorithms\fix{,} such as density matrix embedding theory~\cite{knizia2012density, knizia2013density, motta2017towards, mineh2022solving, li2022toward}.
\fix{On average, \tcc{} requires 0.1 seconds to calculate each UCCSD energy value in Fig.~\ref{fig:hubbard} on a regular CPU without GPU acceleration.}

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.5\textwidth]{hubbard.pdf}
\caption{Ground state energy of one-dimensional half-filled Hubbard model by UCCSD with increasing coulomb repulsion strength $U/t$. The UCCSD energy computed by \tcc{} tracks the FCI value significantly better than CCSD does.}
    \label{fig:hubbard}
\end{figure}




\section{The Electronic Structure Module II. Hardware-efficient Ansatz and Noisy Circuit Simulation}
\label{sec:hea}
\fix{
 In real-world quantum computing systems, noise and errors are inevitable due to factors such as imperfect hardware, decoherence, and finite-shot measurement uncertainty.
Noisy circuit simulators allow researchers to simulate the effects of noise on quantum circuits and get a better understanding of the behavior of quantum algorithms in realistic conditions.
}
In this section, we use the hydrogen molecule $\rm{H}_2$ to illustrate
how to perform noisy circuit simulation in \tcc{}. After using the parity transformation, the corresponding Hamiltonian acts on 2 qubits.
The \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/noisy_simulation.ipynb}{Jupyter Notebook} for this section is available online.

\subsection{Basis Usage}
\label{sec:noisy-basic}
\tcc{} uses the \lstinline{HEA} (Hardware-Efficient Ansatz) class for noisy circuit simulation, 
which has a different interface from the UCC classes encountered in Sec.~\ref{sec:ucc}. 
A primary motivation for using HEA \fix{\cancel{ansatze}ans\"{a}tze} is that almost all UCC circuits (with perhaps pUCCD circuits being the exception) are too large for both noisy circuit simulation as well as execution on currently available quantum devices.  In contrast, HEA circuits are, by design, constructed to be implementable on whatever device is available.

\fix{
Another reason is that, from a user's perspective, the \lstinline{HEA} class ought to provide a greater degree of low-level customization compared to the UCC classes.
For example, for noiseless UCC simulation, the ansatz is defined by excitation operators and compilation to native gates is of less interest. Conversely, in the context of noisy HEA circuit simulation, it is imperative to give users complete control over the ansatz circuit.
}
Nevertheless, noisy UCC circuit simulation can be carried out within \tcc{} without much additional effort, which will be demonstrated in Sec.~\ref{sec:noisy-basic-ansatz}.

\subsubsection{Specifying the Hamiltonian and the ansatz}
\label{sec:noisy-basis-inputs}
Unlike \lstinline{UCC}, the \lstinline{HEA} class 
is not initialized by specifying \fix{\cancel{molecular inputs}the molecule}.
Rather, \lstinline{HEA} takes as inputs (i) the Hamiltonian in \lstinline{openfermion.QubitOperator} form 
and (ii) the circuit ansatz.

Within \openfermion{}, the Hamiltonian can be constructed by interfacing with quantum chemistry packages\fix{,}  such as \pyscf{} using
\lstinline{openfermion.MolecularData}.
\begin{lstlisting}[language=python, caption={Construction of the system Hamiltonian in fermion operator form using \openfermion.}]
from openfermion import MolecularData
from openfermionpyscf import run_pyscf

geometry = [["H", [0, 0, 0]], ['H', [0, 0, 0.741]]]
basis = "STO-3G"
multiplicity = 1
molecule = MolecularData(geometry, basis, multiplicity)
molecule = run_pyscf(molecule)
h_fermion_op = molecule.get_molecular_hamiltonian()
\end{lstlisting}

An alternative approach is to use the \lstinline{UCC} class attributes\fix{,}  such as \lstinline{uccsd.h_fermion_op}. 

\begin{lstlisting}[language=Python, caption={Construction of the system Hamiltonian in qubit operator form using \lstinline{UCCSD} class attributes.}, label={lst:ham-hea}]
from tencirchem import UCCSD, parity
from tencirchem.molecule import h2

uccsd = UCCSD(h2)
# Hamiltonian as openfermion.FermionOperator
h_fermion_op = uccsd.h_fermion_op
# use parity transformation for qubit Hamiltonian and remove 2 qubits
h_qubit_op = parity(h_fermion_op, uccsd.n_qubits, uccsd.n_elec)
\end{lstlisting}

The ansatz is defined using \tc{}.
In the example below, we construct a 1-layer $R_y$ ansatz comprising 4 parameters
and the circuit diagram is depicted in Fig.~\ref{fig:ry}.
The initial parameters create the HF state $\ket{01}$  under parity transformation.
\fix{
In addition to defining the ansatz from scratch,
it is also possible to use a pre-defined ansatz, which will be discussed more thoroughly in Sec.~\ref{sec:noisy-basic-ansatz}.
}

\begin{lstlisting}[language=Python, caption=Defining the 1-layer $R_y$ ansatz using \tc{}.]
import numpy as np
from tensorcircuit import Circuit

n_qubits = 2
n_params = 4
init_guess = [0, np.pi, 0, 0]
def get_circuit(params):
    c = Circuit(n_qubits)
    # the ansatz body
    c.ry(0, theta=params[0])
    c.ry(1, theta=params[1])
    c.cnot(0, 1)
    c.ry(0, theta=params[2])
    c.ry(1, theta=params[3])
    return c
\end{lstlisting}

\begin{figure}

    \centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=1.0em @!R { \\
\nghost{{q}_{0} :  } & \lstick{{q}_{0} :  } & \gate{R_y(\theta_0)} &\ctrl{1} & \gate{R_y(\theta_2)} & \qw \\
\nghost{{q}_{1} :  } & \lstick{{q}_{1} :  } & \gate{R_y(\theta_1)}  & \targ & \gate{R_y(\theta_3)} & \qw \\
\\ }}
\caption{Circuit diagram for a 2-qubit 1-layered $R_y$ ansatz. More layers can be added by repeating the CNOT and $R_y$ rotation unit.}
\label{fig:ry}
\end{figure}

\subsubsection{Noisy circuit simulation and optimization}
The remaining workflow is similar to the \lstinline{UCCSD} case: (i) create an \lstinline{HEA} instance, (ii) 
run the kernel, and (iii) print the summary:
\begin{lstlisting}[language=Python]
from tencirchem import HEA
hea = HEA(h_qubit_op, get_circuit, init_guess, engine="tensornetwork-noise")
hea.kernel()
hea.print_summary()
\end{lstlisting}
The default optimizer used is again L-BFGS-B from \scipy{}.

The gradients are evaluated by the parameter-shift rule~\cite{mitarai2018quantum, schuld2019evaluating}.
The parameter-shift rule uses two separate circuits to evaluate the gradient of one parameter.
Its essence can be summarized using a single-qubit single-gate illustrative example.
Suppose the circuit wavefunction is $\ket{\psi} = e^{\theta R} \ket{\phi}$ with $R^2 = -I$.
This leads to $\ket{\psi} = (\cos{\theta} + \sin{\theta} R ) \ket{\phi}$, and the energy expectation is then
\begin{equation}
    \braket{E}(\theta) = \cos^2{\theta} \braket{\phi|H|\phi} + \sin{\theta}\cos{\theta} \braket{\phi|RH + HR|\phi}
     + \sin^2{\theta} \braket{\phi|RHR|\phi}\ .
\end{equation}
Thus
\begin{equation}
    \pdv{\braket{E}}{\theta} = \braket{E}(\theta + \frac{\pi}{4}) - \braket{E}(\theta - \frac{\pi}{4})\ .
\end{equation}
The expression is slightly different from the literature where $e^{\frac{\theta}{2}R}$ is usually assumed.


By default, using the \lstinline{"tensornetwork-noise"} engine (line 2) adds isotropic depolarizing noise\fix{~\cite{nielsen2002quantum}} with error probability $p=0.02$
\begin{equation}
    \mathcal{E}(\rho) = (1 - p)\rho + \frac{p}{15} \sum_{i=1}^{15} \mathcal{P}_j \rho \mathcal{P}_j. \
\end{equation}
to each CNOT gate in the circuit. Here $\rho$ is the density matrix, and the $\mathcal{P}_j$ are the two-qubit Pauli matrices (excluding the identity operator $I$).
 Hereafter we will also refer to $p$ as the CNOT error probability. 
 The value $p=0.02$ corresponds to approximately 98\% CNOT average gate fidelity, defined as
 \begin{equation}
     F = \int \braket{\psi|\mathcal{E}(\ket{\psi}\bra{\psi})|\psi} d \psi = 1 - \frac{4}{5}p. \
 \end{equation}
Single qubit gate noise is not included. The energy obtained in this case is -1.1203.

Other noise models can be specified using the \lstinline{NoiseConf} class from \tc{}, as illustrated below:

\begin{lstlisting}[language=Python, caption={A simple customized noise model with depolarizing error probability $p=0.25$, corresponding to average gate fidelity of  80\%. 
The energy obtained is -0.9245, higher than the value of -1.1203 obtained from the $p=0.02$ case.}]
from tensorcircuit.noisemodel import NoiseConf
from tensorcircuit.channels import isotropicdepolarizingchannel

engine_conf = NoiseConf()
# larger noise, corresponding to 80%
channel = isotropicdepolarizingchannel(p=0.25, num_qubits=2)
engine_conf.add_noise("cnot", channel)

hea = HEA(h_qubit_op, get_circuit, init_guess, \
          engine="tensornetwork-noise", engine_conf=engine_conf)
hea.kernel()
hea.print_summary()
\end{lstlisting}

In addition to the depolarizing channel, \tc{} supports the amplitude damping channel, phase damping channel, and thermal relaxation channel\fix{~\cite{nielsen2002quantum}}.

The \lstinline{"tensornetwork-noise"} engine does not consider measurement uncertainty. Measurement uncertainty can be accounted for using the \lstinline{"tensornetwork-noise&shot"} engine, as shown below:

\begin{lstlisting}[language=Python, caption={Accounting for measurement uncerainty in noisy circuit simulation using the \lstinline{"tensornetwork-noise&shot"} engine.}]
>>> # number of shots: 4096
>>> for i in range(5):
>>>    print(hea.energy(engine="tensornetwork-noise&shot"))
-0.9209869918508058
-0.9306141224500795
-0.9176478740443613
-0.929275708950061
-0.9241459510180587
>>> # number of shots: 4096 * 128"
>>> hea.shots = 4096 * 128
>>> for i in range(5):
>>>    print(hea.energy(engine="tensornetwork-noise&shot"))
-0.9246797253478469
-0.9251027083245665
-0.9243841547125008
-0.9236478492038139
-0.9248303187894168
\end{lstlisting}
By default, the number of measurement shots made for each term in the Hamiltonian is 4096.  Increasing the number of measurement shots decreases the energy uncertainty.
Here the engine is switched temporarily at runtime,
and specifying the engine while initializing the \lstinline{HEA} class is also viable, 
by \lstinline{hea=HEA(*args, engine=engine)}. 

\fix{
If desired, a real quantum hardware engine can be specified by setting the engine to \lstinline{"qpu"}.
The circuit is then executed on a 9-qubit super-conducting QPU hosted by the Tencent Quantum Lab quantum cloud service.
A private token is required for successful execution.
The platform is currently under closed beta and we are developing more features. 
The access token and configuration documents can be requested by sending an email to the authors.
}


If noiseless results are desired for the HEA ansatz, this can be achieved by using the \lstinline{"tensornetwork"} engine, i.e.,  \lstinline{hea.energy(engine="tensornetwork")}.  In this case, the energy is in exact agreement with the FCI energy for the hydrogen molecule system.

\subsubsection{Using pre-defined \fix{\cancel{ansatze}ans\"{a}tze}}
\label{sec:noisy-basic-ansatz}
At the end of the section, we show how to use pre-defined ansatze for noisy circuit simulation.
TenCirChem has implemented the $R_y$ ansatz.
In the following code the \lstinline{HEA} instance is rebuilt using the \lstinline{HEA.ry} function, 
which constructs the qubit Hamiltonian and the $R_y$ ansatz automatically.
The result after running the kernel is exactly the same as what we've illustrated step by step above.

\begin{lstlisting}[language=Python]
hea = HEA.ry(uccsd.int1e, uccsd.int2e, uccsd.n_elec, uccsd.e_core,  \
             n_layers=1, engine="tensornetwork-noise")
hea.kernel()
\end{lstlisting}

If desired, the UCC ansatz defined in the \lstinline{UCC} class can be fed into the \lstinline{HEA} class for noisy circuit simulation. 
The following code snippet shows how to simulate the UCCSD circuit of the \ce{H2} molecule in the presence of noise.
As described in Sec.~\ref{sec:circuit_output}, \tcc{} by default uses a multi-qubit controlled $R_y$ gate for UCC circuit simulation, which has to be decomposed into elementary gates before actual execution on quantum computers. 
The gradient is turned off because the parameter-shift rule is not directly applicable to the circuit
in which multiple gates share the same parameter.
The COBYLA optimizer implemented in \scipy{}~\cite{2020SciPy-NMeth} is used for optimization.
The energy obtained is -0.8358, which is significantly higher than \fix{the energy by the} HEA ansatz, because there are 18 noisy CNOT gates in the circuit.
\fix{We comment that simulating UCC circuits with the \lstinline{HEA} class is non-standard.
Usually, it is necessary to simplify the ansatz before execution under realistic hardware conditions~\cite{peruzzo2014variational, o2016scalable}.}

\begin{lstlisting}[language=Python, caption={Noisy simulation of UCC circuits.}, label={lst:noisy-ucc}]
from functools import partial
get_circuit = partial(uccsd.get_circuit, decompose_multicontrol=True)
hea = HEA(uccsd.h_qubit_op, get_circuit, uccsd.init_guess, \
          engine="tensornetwork-noise")
hea.grad = "free"
hea.kernel()
\end{lstlisting}

\subsection{Applications}

\subsubsection{Effect of gate noise on VQE energy}
\label{sec:app-noise}
As a first application, we show how the CNOT depolarizing error affects the optimized VQE energy. Results are shown in Fig.~\ref{fig:error-probability}.
The $R_y$ hardware-efficient ansatz and the \ce{H2} molecule with parity transformation are used, as in Sec.~\ref{sec:noisy-basic}.

We additionally test how the number of ansatz layers affects the obtained energy.
If a one-layer ansatz is adopted, the energy increases linearly with the error probability up to $p=0.8$. This is a consequence of the fact that this ansatz, when compiled into a quantum circuit, contains only a single CNOT gate.
Increasing the number of layers does not lead to more accurate energy estimation. 
Rather, the noise caused by more CNOT gates in the ansatz further degrades the results.
\tcc{} requires approximately 1 second to produce each data point in Fig.~\ref{fig:error-probability}, which involves iterating the VQE parameter optimization procedure until convergence.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.7\textwidth]{error-probability.pdf}
\caption{The VQE ground state energy of \ce{H2} with parity transformation in the presence of depolarizing error, characterized by the error probability $p$. The $R_y$ hardware-efficient ansatz is used, with between 1 and 3 layers.}
    \label{fig:error-probability}
\end{figure}

\subsubsection{Effect of measurement shots on VQE energy uncertainty}
Here we show how the number of measurement shots $\nshots$ affects the standard deviation of the optimized VQE energy. Results are shown in Fig~\ref{fig:uncertainty}.
The \ce{H2} molecule of Sec.~\ref{sec:app-noise} is used with a single layer $R_y$ ansatz.
We test $\nshots$ values from $2^8$ to $2^{13}$.
For each value of $\nshots$ investigated, the system energy $E$ is evaluated 64 times and the standard deviation is calculated.
Note that the circuit parameters are kept constant at the optimal value and the VQE iteration is not run.

As expected, the standard deviation of $E$ is proportional to $\sqrt{\frac{1}{\nshots}}$~\cite{mcclean2016theory}.
Increasing the error probability $p$ causes a larger standard deviation of the energy, although the effect is far less significant than that caused by adjusting $\nshots$.
\tcc{} requires approximately 1 second to produce a single data point in Fig.~\ref{fig:uncertainty}, each of which involves 64 separate energy evaluations.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.5\textwidth]{uncertainty.pdf}
\caption{The VQE energy in the presence of depolarizing error, characterized by the error probability $p$. The $R_y$ circuit with 1 layer is used as the ansatz.}
    \label{fig:uncertainty}
\end{figure}

\fix{
\subsubsection{Running quantum hardware experiments}
In this section, we use QPUs to compute the VQE energy of the \ce{H2} molecule, and the results are summarized in Fig.~\ref{fig:h2_qpu}.
We use the same one-layered $R_y$ ansatz described in previous sections.
To reduce the computational cost, the parameter vector is reduced to $[\theta, \pi, 0, 0]$ with only one variable $\theta$.
Noiseless simulation shows that using this ansatz is sufficient to reach the FCI energy.
On QPU, 8192 shots are taken to determine the expectation value of each term in the Hamiltonian.
The error is mitigated by standard readout error mitigation.
For each set of circuit parameters, the energy is evaluated 8 times to produce the final energy expectation and its standard deviation.
We first compute the potential energy curve using the classically optimized parameter and then run the full VQE optimization starting from $\theta=0$.
In both cases, the QPU engine can correctly describe the dissociation curve of the \ce{H2} molecule.
Moreover, we observe that the energy standard deviation increases as the bond length decreases.
This is because at short bond lengths the Pauli strings have large coefficients due to strong interaction between the particles.
}
\begin{figure}[htp]
    \centering
    \includegraphics[width=0.5\textwidth]{h2_qpu.pdf}
\caption{\fix{The VQE potential energy curve of \ce{H2} computed on a QPU backend. QPU energies obtained from the classically optimized parameter and full VQE optimization process are both shown.}}
    \label{fig:h2_qpu}
\end{figure}



\section{The Quantum Dynamics Module}
\label{sec:dynamics}

\subsection{Basic Usage}

\subsubsection{Defining the Hamiltonian and basis set}
The first step in quantum dynamics simulations is specifying the Hamiltonian.
In this section, we focus on the spin-boson model with 1 bosonic mode:
\begin{equation}
\label{eq:dynamic-sbm}
H = \frac{\epsilon}{2} \sigma_z + \Delta \sigma_x + \omega  b^\dagger b + g \sigma_z ( b^\dagger +  b)    
\end{equation}
where $\sigma_z = Z$ and $\sigma_x = X$ are Pauli matrices, $\epsilon$ is the eigenfrequency and $\Delta$ is the tunnelling rate.
\fix{
The spin-boson model is a classical model for a variety of chemical processes, 
such as electron transfer and photochemistry~\cite{leggett1987dynamics}.
}
For ease of demonstration, we truncate the allowed boson states to two levels. 
More sophisticated examples can be found in Sec.~\ref{sec:dynamic-app} and in the online \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/sbm_dynamics.ipynb}{Jupyter Notebook}.

Defining the system Hamiltonian and basis sets is performed as follows:

\begin{lstlisting}[language=Python, caption=Defining the system Hamiltonian and basis set for 1-mode spin-boson model.]
from tencirchem import Op, BasisHalfSpin, BasisSHO

epsilon = 0
delta = 1
omega = 1
g = 0.5

ham_terms = [
    Op("sigma_z", "spin", epsilon),
    Op("sigma_x", "spin", delta),
    Op(r"b^\dagger b", "boson", omega),
    Op("sigma_z", "spin", g) * Op(r"b^\dagger+b", "boson")
]
basis = [BasisHalfSpin("spin"), BasisSHO("boson", omega=omega, nbas=2)]
\end{lstlisting}
The \lstinline{Op} and the basis set classes are directly imported from the \reno{} package.
Each term in the Hamiltonian takes three arguments: (i) the operator symbol; (ii) the name of the associated degree of freedom; and (iii) the (optional) coefficient.

In setting the basis sets (line 14), \lstinline{BasisSHO} refers to the simple harmonic oscillator basis,
and \lstinline{nbas=2} restricts the phonon states to the lowest two levels.



Conversion of the Hamiltonian and basis sets into qubits is then performed in \tcc{} using the \lstinline{qubit_encode_op} and \lstinline{qubit_encode_basis} commands, as illustrated below:

\begin{lstlisting}[language=Python, caption={Transformation from physical basis set into qubit spin basis.  Here we use the binary encoding with Gray code approach (see Sec.~\ref{sec:overview-conv-dynamics}) to encode the bosonic states.}]
from tencirchem.dynamic import qubit_encode_op, qubit_encode_basis
boson_encoding = "gray"
ham_terms_spin, constant = qubit_encode_op(ham_terms, basis, boson_encoding)
basis_spin = qubit_encode_basis(basis, boson_encoding)
\end{lstlisting}

After transformation, the Hamiltonian and basis sets can be inspected as follows:
\begin{lstlisting}[language=Python, caption=Inspection of the transformed Hamiltonian.]
>>> ham_terms_spin
[Op('X', ['spin'], 1.0),
 Op('Z', [('boson', 'TCCQUBIT-0')], -0.5),
 Op('Z X', ['spin', ('boson', 'TCCQUBIT-0')], 0.5)]
>>> basis_spin
[BasisHalfSpin(dof: spin, nbas: 2),
 BasisHalfSpin(dof: ('boson', 'TCCQUBIT-0'), nbas: 2)]
\end{lstlisting}
As expected, the Hamiltonian is now expressed in terms of Pauli strings and the basis sets are all transformed to the spin-$\frac{1}{2}$ basis set.
\fix{
Here, the term in square brackets in each operator of the above Code Snippet represents the label(s) of the spin-$\frac{1}{2}$ basis on which the Pauli operators are defined.
}
As we restrict to two phonon levels, only one spin-$\frac{1}{2}$ basis set \fix{with label \lstinline{('boson', 'TCCQUBIT-0')}} is generated, i.e., the phonon mode is represented by a single qubit.

\subsubsection{Construct the ansastz}


The variational Hamiltonian ansatz (see Fig.~\ref{fig:dynamics_circuit}) defined in Eq.~\ref{eq:dynamic-vha} can now be constructed using the \lstinline{get_ansatz} function, and the Jacobian then obtained by \lstinline{get_jacobian_func}:

\begin{lstlisting}[language=Python, caption=Construction of the ansatz and the function to evaluate the Jacobian.]
import tensorcircuit as tc
from tencirchem import set_backend
from tencirchem.dynamic import get_ansatz, get_jacobian_func

# dynamics simulation requires auto-differentiation from JAX.
set_backend("jax")

# the initial state
init_circuit = tc.Circuit(len(basis_spin))
# number of layers 
n_layers = 3
# get the ansatz. Note that the spin basis is fed in
ansatz = get_ansatz(ham_terms_spin, basis_spin, n_layers, init_circuit)

# ansatz accepts parameters and outputs wavefunction
import numpy as np
print(ansatz(np.zeros(n_layers * len(ham_terms_spin))))
# the function to evaluate the jacobian of the wavefunction
jacobian_func = get_jacobian_func(ansatz)
\end{lstlisting}


\begin{figure}[h]
    \centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=1.0em @!R { \\
\nghost{{q}_{0} :  } & \lstick{{q}_{0} :  } & \gate{e^{-i\theta_0 X}} & \multigate{1}{e^{-i\theta_2ZX}} & \gate{e^{-i\theta_3 X}} & \multigate{1}{e^{-i\theta_5ZX}} & \gate{e^{-i\theta_6 X}} &  \multigate{1}{e^{-i\theta_8ZX}} & \qw \\
\nghost{{q}_{1} :  } & \lstick{{q}_{1} :  } & \gate{e^{-i\theta_1 Z}} &  \ghost{e^{-i\theta_2ZX}}  & \gate{e^{-i\theta_4 Z}} & \ghost{e^{-i\theta_5ZX}} & \gate{e^{-i\theta_7 Z}} & \ghost{e^{-i\theta_8ZX}}& \qw \\
\\ }}
\caption{Quantum circuit corresponding to the 3-layered variational Hamiltonian ansatz for the 1-mode spin-boson model using binary encoding with Gray code. $q_0$ represents the spin and $q_1$ represents  the boson.}
    \label{fig:dynamics_circuit}
\end{figure}

Here, \lstinline{basis_spin} defines the ordering of the qubits in the circuit. 
More specifically, the first and second elements in \lstinline{basis_spin} refer to the spin and boson respectively, and thus in the quantum circuit the first qubit represents the spin and the second qubit represents the boson. Note that the backend needs to be set to \jax{} explicitly because the default \numpy{} backend does not support automatic differentiation.


\subsubsection{Time evolution}
With the ansatz function to calculate the wavefunction and its Jacobian, 
the equation of motion Eq.~\ref{eq:dynamic-mv} can now be readily solved to determine $\dot \theta_k$.
The following code wraps the derivative function in \scipy{} format and solves the initial value problem. 
The wavefunction is evolved from time $t=0$ to $t=10$ using a time interval of $0.1$.

\begin{lstlisting}[language=Python, caption=Time evolution of the spin-boson system.]
from tencirchem import get_dense_operator
from tencirchem.dynamic import get_deriv
# the Hamiltonian in dense matrix format
h = get_dense_operator(basis_spin, ham_terms_spin)
# time derivative for circuit parameters in the scipy solve_ivp format
def scipy_deriv(t, _theta):
    return get_deriv(ansatz, jacobian_func, _theta, h)
from scipy.integrate import solve_ivp
# time step
tau = 0.1
# initial value
theta = np.zeros(n_layers * len(ham_terms_spin))
for n in range(100):
    # time evolution
    scipy_sol = solve_ivp(scipy_deriv, [n * tau, (n + 1) * tau], theta)
    # time evolved parameter
    theta = scipy_sol.y[:, -1]
\end{lstlisting}

Note that \tcc{} also provides a high-level interface for simulating dynamics, e.g., 

\begin{lstlisting}[language=Python, caption=Time evolution of the spin-boson system using the \lstinline{TimeEvolution} class.]
from tencirchem import TimeEvolution

te = TimeEvolution(ham_terms, basis)
for i in range(100):
    te.kernel(0.1)
\end{lstlisting}

Using this interface, the user need only specify the Hamiltonian and the basis sets, 
and encoding to qubits is carried out automatically using binary encoding with Gray code.
\fix{Configuration of the encoding strategy, the circuit initial condition, and the number of layers in the ansatz are also supported.}

\subsection{Implementation}

\tcc{} uses classical matrix manipulations to calculate the $M$ matrix and $V$ vector in the equation of motion (Eq.~\ref{eq:eom-theta}) instead of 
faithfully simulating the quantum circuit.
The first step is to obtain the Jacobian $\pdv{\ket{\Psi}}{\theta_k}$ by forward-mode auto-differentiation via the \jax{} backend.
\fix{
Forward-mode auto-differentiation is preferred over reverse-mode auto-differentiation in this case, because usually there are more amplitudes in $\ket{\Psi}$ than parameters $\theta_k$.
The whole matrix $M$ is then calculated by a single matrix-matrix multiplication according to Eq.~\ref{eq:dynamic-mv}.
Similarly, the whole vector $V$ is calculated by computing $H\ket{\psi}$ via a single matrix-vector multiplication, and then another matrix-vector multiplication between the Jacobian and $H\ket{\psi}$.
}
This implementation minimizes the just-in-time compile time in \jax{},
because evaluating the Jacobian is the only bottleneck that needs to be compiled during the workflow.
The $M$ matrix is usually not invertible due to linear dependencies in $\pdv{\ket{\Psi}}{\theta_k}$.
It\fix{\cancel{'s}s} eigenvalues $\lambda_i$ are modified with $\lambda_i \rightarrow \lambda_i + \epsilon e^{-\lambda_i / \epsilon}$
for regularization, where $\epsilon$ is a pre-defined small number, typically $1 \times 10^{-5}$.

\subsection{Applications}
\label{sec:dynamic-app}

\subsubsection{Spin relaxation of spin-boson model}
Here we show the simulated dynamics of the 1-mode spin-boson model defined in Eq.~\ref{eq:dynamic-sbm}, with parameters $\epsilon = 0$, $\Delta = 1$, $\omega = 1$ and $g = 0.5$.
Unlike the previous example which truncated the boson to the lowest two states, here we allow 8 bosonic states, and the corresponding circuit acts on 4 qubits.
The simulated results are shown in Fig.~\ref{fig:sbm}, and are in good agreement with the solution with exact diagonalization.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.7\textwidth]{sbm.pdf}
\caption{Spin relaxation of the 1-mode spin-boson model simulated by variational quantum dynamics.}
    \label{fig:sbm}
\end{figure}

\subsubsection{Marcus inverted region of the charge transfer model}
In this section, we simulate the charge transfer or oxidation-reduction reaction between two molecules using the Marcus model~\cite{shuai2020applying}
\begin{equation}
    H = -V(a^\dagger_0 a_1 + a^\dagger_1 a_0) + \Delta G a^\dagger_1 a_1 + \omega \sum_{i=0, 1} b^\dagger_i b_i + g \omega \sum_{i=0, 1} a^\dagger_i a_i (b^\dagger_i + b_i). \
\end{equation}
Here $a_0$ and $a_1$ are annihilation operators for the charge on the first and the second molecule respectively.
We assume transfer integral $V=-0.1$, dimensionless coupling constant $g=1$, and vibration frequency $\omega=0.5$.
The Marcus charge transfer theory predicts that, by decreasing the reaction Gibbs free energy change $\Delta G$, the reaction rate $k$ will first increase and then decrease, according to
\begin{equation}
\label{eq:marcus}
 k = \frac{V^2}{\hbar} \sqrt{\frac{\pi\beta}{\lambda}} \exp{-\frac{\beta(\lambda + \Delta G)^2}{4\lambda}}   
\end{equation}
where $\lambda = 2g^2\omega$ is the reorganization energy and $\beta$ is the inverse temperature.
Due to the quadratic term on the exponential, the maximum rate is reached when $\Delta G=-\lambda=-1$.

In the simulation,
we again truncate the number of boson states to 8, and thus the Hamiltonian is encoded into 7 qubits using the Gray code method.
The charge is initially set to be located at the first molecule and the nuclear coordinates are relaxed
according to the localized charge~\cite{kloss2019multiset}.
The system is then evolved to $t=8$ using \tcc{} and we compute $\braket{a^\dagger_0 a_0}$ (the charge occupation on the first molecule) as a function of time, with $\Delta G$ ranging from 0 to -2.
The full \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/marcus.ipynb}{Jupyter Notebook} is available online.

Results are shown in Fig.~\ref{fig:marcus}(a).
During an initial period ($t<2$), the reaction rate increases with $t$.
For $2 < t < 8$, the reaction reaches a steady state and the reaction rate is approximately constant.



In Fig.~\ref{fig:marcus}(b) we plot the reaction rate $k$ from $t=2$ to $t=8$.
Since the effect of temperature is not modeled in this simulation, $\beta$ is fit to a value of 2.71 by matching the simulated $k(\Delta G)$ data with the least square method.
The simulated rate reaches the maximum at $\Delta G=-1$, in agreement with the theoretical prediction.
\fix{We also include the charge transfer rate from full quantum nuclear tunneling enabled charge transfer theory~\cite{nan2009nuclear}, which predicts a very similar parabolic curve without fitting $\beta$.}


\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{marcus.pdf}
\caption{(a) Charge occupation on the first molecule versus time at several values of $\Delta G$. (b) Charge transfer rate $k$ as a function of $\Delta G$, for $2 < t < 8$. The dots are from a linear fit based on $\braket{a^\dagger_0 a_0}(t) = -kt+c$ to the linear region in (a) and the dashed \fix{lines are the predictions of the Marcus theory (Eq.~\ref{eq:marcus}) and full quantum charge transfer theory}.}
    \label{fig:marcus}
\end{figure}




\section{Summary and Outlook}

In this paper, we introduce \tcc{}, a Python-based open-source library for quantum computational chemistry,
hosted on the GitHub repository \url{https://github.com/tencent-quantum-lab/TenCirChem}.
\tcc{} aims to provide both black-box calculations of existing quantum algorithms
and flexible interfaces for rapid prototyping
of novel computational methods.
\tcc{} features high-performance UCC calculations, noisy circuit simulation with both quantum gate error and measurement noise,
and variational quantum dynamics simulation.
\tcc{} is designed to
expose its internal data structure for inspection and modification,
enabling in-depth customization.
Although written in Python, \tcc{} reaches state-of-the-art performance
via the powerful \tc{} backend and various chemistry-focused optimizations\fix{,}  such as UCC factor expansion.
Its efficiency is demonstrated by the exact UCCSD simulation of \ce{H16} in STO-3G basis (32 qubits), \ce{H2} in cc-pVTZ basis (56 qubits), and \ce{H2O} in 6-31G(d) basis (34 qubits), requiring only moderate computational time and hardware.


The development of \tcc{} is an ongoing process.
In the future, \fix{additional QPU engine configuration options will be provided}.
Features such as 
\fix{support for higher order excitations,}
the treatment of open-shell systems,
algorithms for excited states and periodic systems,
algorithms for fault-tolerant quantum computers,
further performance optimization,
and more code examples reproducing published algorithms
are also under active consideration.

\begin{acknowledgement}
The authors thank Zhaofeng Ye for designing the \tcc{} logo.
Weitang Li would like to thank Sainan Huai and Tianqi Cai for their helpful discussions.
This work is supported by the National Natural Science Foundation of China through grant numbers 22273005 and 21788102.
This work is also supported by Shenzhen Science and Technology Program.
\end{acknowledgement}

\section*{Supporting Information}
The Supporting Information is available free of charge online, including
\begin{itemize}
    \item A brief review of UCC \fix{\cancel{ansatze}ans\"{a}tze} implemented in \tcc{}.
    \item The conventions for orbital indices and qubit indices in \tcc{}.
    \item The output of the \lstinline{print_summary} command.
    \item \fix{\cancel{The a} A}dvanced feature\fix{s} of the UCC classes.
    \item The algorithm for efficient simulation of UCC circuits.
\end{itemize}

\providecommand{\latin}[1]{#1}
\makeatletter
\providecommand{\doi}
  {\begingroup\let\do\@makeother\dospecials
  \catcode`\{=1 \catcode`\}=2 \doi@aux}
\providecommand{\doi@aux}[1]{\endgroup\texttt{#1}}
\makeatother
\providecommand*\mcitethebibliography{\thebibliography}
\csname @ifundefined\endcsname{endmcitethebibliography}
  {\let\endmcitethebibliography\endthebibliography}{}
\begin{mcitethebibliography}{100}
\providecommand*\natexlab[1]{#1}
\providecommand*\mciteSetBstSublistMode[1]{}
\providecommand*\mciteSetBstMaxWidthForm[2]{}
\providecommand*\mciteBstWouldAddEndPuncttrue
  {\def\EndOfBibitem{\unskip.}}
\providecommand*\mciteBstWouldAddEndPunctfalse
  {\let\EndOfBibitem\relax}
\providecommand*\mciteSetBstMidEndSepPunct[3]{}
\providecommand*\mciteSetBstSublistLabelBeginEnd[3]{}
\providecommand*\EndOfBibitem{}
\mciteSetBstSublistMode{f}
\mciteSetBstMaxWidthForm{subitem}{(\alph{mcitesubitemcount})}
\mciteSetBstSublistLabelBeginEnd
  {\mcitemaxwidthsubitemform\space}
  {\relax}
  {\relax}

\bibitem[McClean \latin{et~al.}(2016)McClean, Romero, Babbush, and
  Aspuru-Guzik]{mcclean2016theory}
McClean,~J.~R.; Romero,~J.; Babbush,~R.; Aspuru-Guzik,~A. The theory of
  variational hybrid quantum-classical algorithms. \emph{New J. Phys.}
  \textbf{2016}, \emph{18}, 023023\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Cao \latin{et~al.}(2019)Cao, Romero, Olson, Degroote, Johnson,
  Kieferov{\'a}, Kivlichan, Menke, Peropadre, Sawaya, Sim, Veis, and
  Aspuru-Guzik]{cao2019quantum}
Cao,~Y.; Romero,~J.; Olson,~J.~P.; Degroote,~M.; Johnson,~P.~D.;
  Kieferov{\'a},~M.; Kivlichan,~I.~D.; Menke,~T.; Peropadre,~B.; Sawaya,~N.~P.;
  Sim,~S.; Veis,~L.; Aspuru-Guzik,~A. Quantum chemistry in the age of quantum
  computing. \emph{Chem. Rev.} \textbf{2019}, \emph{119}, 10856--10915\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Bauer \latin{et~al.}(2020)Bauer, Bravyi, Motta, and
  Chan]{bauer2020quantum}
Bauer,~B.; Bravyi,~S.; Motta,~M.; Chan,~G. K.-L. Quantum algorithms for quantum
  chemistry and quantum materials science. \emph{Chem. Rev.} \textbf{2020},
  \emph{120}, 12685--12717\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[McArdle \latin{et~al.}(2020)McArdle, Endo, Aspuru-Guzik, Benjamin, and
  Yuan]{mcardle2020quantum}
McArdle,~S.; Endo,~S.; Aspuru-Guzik,~A.; Benjamin,~S.~C.; Yuan,~X. Quantum
  computational chemistry. \emph{Rev. Mod. Phys.} \textbf{2020}, \emph{92},
  015003\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Liu \latin{et~al.}(2022)Liu, Fan, Li, and Yang]{liu2022quantum}
Liu,~J.; Fan,~Y.; Li,~Z.; Yang,~J. Quantum algorithms for electronic
  structures: basis sets and boundary conditions. \emph{Chem. Soc. Rev.}
  \textbf{2022}, \relax
\mciteBstWouldAddEndPunctfalse
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Preskill(2018)]{Preskill18}
Preskill,~J. Quantum {C}omputing in the {NISQ} era and beyond. \emph{{Quantum}}
  \textbf{2018}, \emph{2}, 79\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Arute \latin{et~al.}(2019)Arute, Arya, Babbush, Bacon, Bardin,
  Barends, Biswas, Boixo, Brandao, Buell, Burkett, Chen, Chen, Chiaro, Collins,
  Courtney, Dunsworth, Farhi, Foxen, Fowler, Gidney, Giustina, Graff, Guerin,
  Habegger, Harrigan, Hartmann, Ho, Hoffmann, Huang, Humble, Isakov, Jeffrey,
  Jiang, Kafri, Kechedzhi, Kelly, Klimov, Knysh, Korotkov, Kostritsa, Landhuis,
  Lindmark, Lucero, Lyakh, Mandr{\`a}, McClean, McEwen, Megrant, Mi,
  Michielsen, Mohseni, Mutus, Naaman, Neeley, Neill, Niu, Ostby, Petukhov,
  Platt, Quintana, Rieffel, Roushan, Rubin, Sank, Satzinger, Smelyanskiy, Sung,
  Trevithick, Vainsencher, Villalonga, White, Yao, Yeh, Zalcman, Neven, and
  Martinis]{arute2019quantum}
Arute,~F.; Arya,~K.; Babbush,~R.; Bacon,~D.; Bardin,~J.~C.; Barends,~R.;
  Biswas,~R.; Boixo,~S.; Brandao,~F. G. S.~L.; Buell,~D.~A.; Burkett,~B.;
  Chen,~Y.; Chen,~Z.; Chiaro,~B.; Collins,~R.; Courtney,~W.; Dunsworth,~A.;
  Farhi,~E.; Foxen,~B.; Fowler,~A.; Gidney,~C.; Giustina,~M.; Graff,~R.;
  Guerin,~K.; Habegger,~S.; Harrigan,~M.~P.; Hartmann,~M.~J.; Ho,~A.;
  Hoffmann,~M.; Huang,~T.; Humble,~T.~S.; Isakov,~S.~V.; Jeffrey,~E.;
  Jiang,~Z.; Kafri,~D.; Kechedzhi,~K.; Kelly,~J.; Klimov,~P.~V.; Knysh,~S.;
  Korotkov,~A.; Kostritsa,~F.; Landhuis,~D.; Lindmark,~M.; Lucero,~E.;
  Lyakh,~D.; Mandr{\`a},~S.; McClean,~J.~R.; McEwen,~M.; Megrant,~A.; Mi,~X.;
  Michielsen,~K.; Mohseni,~M.; Mutus,~J.; Naaman,~O.; Neeley,~M.; Neill,~C.;
  Niu,~M.~Y.; Ostby,~E.; Petukhov,~A.; Platt,~J.~C.; Quintana,~C.;
  Rieffel,~E.~G.; Roushan,~P.; Rubin,~N.~C.; Sank,~D.; Satzinger,~K.~J.;
  Smelyanskiy,~V.; Sung,~K.~J.; Trevithick,~M.~D.; Vainsencher,~A.;
  Villalonga,~B.; White,~T.; Yao,~Z.~J.; Yeh,~P.; Zalcman,~A.; Neven,~H.;
  Martinis,~J.~M. Quantum supremacy using a programmable superconducting
  processor. \emph{Nature} \textbf{2019}, \emph{574}, 505--510\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Gong \latin{et~al.}(2021)Gong, Wang, Zha, Chen, Huang, Wu, Zhu, Zhao,
  Li, Guo, Qian, Ye, Chen, Ying, Yu, Fan, Wu, Su, Deng, Rong, Zhang, Cao, Lin,
  Xu, Sun, Guo, Li, Liang, Bastidas, Nemoto, Munro, Huo, Lu, Peng, Zhu, and
  Pan]{gong2021quantum}
Gong,~M.; Wang,~S.; Zha,~C.; Chen,~M.-C.; Huang,~H.-L.; Wu,~Y.; Zhu,~Q.;
  Zhao,~Y.; Li,~S.; Guo,~S.; Qian,~H.; Ye,~Y.; Chen,~F.; Ying,~C.; Yu,~J.;
  Fan,~D.; Wu,~D.; Su,~H.; Deng,~H.; Rong,~H.; Zhang,~K.; Cao,~S.; Lin,~J.;
  Xu,~Y.; Sun,~L.; Guo,~C.; Li,~N.; Liang,~F.; Bastidas,~V.~M.; Nemoto,~K.;
  Munro,~W.~J.; Huo,~Y.-H.; Lu,~C.-Y.; Peng,~C.-Z.; Zhu,~X.; Pan,~J.-W. Quantum
  walks on a programmable two-dimensional 62-qubit superconducting processor.
  \emph{Science} \textbf{2021}, \emph{372}, 948--952\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Xu \latin{et~al.}(2023)Xu, Sun, Wang, Xiang, Bao, Zhu, Shen, Song,
  Zhang, Ren, Zhang, Dong, Deng, Chen, Wu, Tan, Gao, Jin, Zhu, Zhang, Wang,
  Zou, Zhong, Zhang, Li, Jiang, Yu, Yao, Wang, Li, Guo, Song, Wang, and
  Deng]{xu2023digital}
Xu,~S.; Sun,~Z.-Z.; Wang,~K.; Xiang,~L.; Bao,~Z.; Zhu,~Z.; Shen,~F.; Song,~Z.;
  Zhang,~P.; Ren,~W.; Zhang,~X.; Dong,~H.; Deng,~J.; Chen,~J.; Wu,~Y.; Tan,~Z.;
  Gao,~Y.; Jin,~F.; Zhu,~X.; Zhang,~C.; Wang,~N.; Zou,~Y.; Zhong,~J.;
  Zhang,~A.; Li,~W.; Jiang,~W.; Yu,~L.-W.; Yao,~Y.; Wang,~Z.; Li,~H.; Guo,~Q.;
  Song,~C.; Wang,~H.; Deng,~D.-L. Digital Simulation of Projective Non-Abelian
  Anyons with 68 Superconducting Qubits. \emph{Chin. Phys. Lett.}
  \textbf{2023}, \emph{40}, 60301--060301\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[{Google Quantum AI}(2023)]{google2023suppressing}
{Google Quantum AI}, Suppressing quantum errors by scaling a surface code
  logical qubit. \emph{Nature} \textbf{2023}, \emph{614}, 676--681\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Peruzzo \latin{et~al.}(2014)Peruzzo, McClean, Shadbolt, Yung, Zhou,
  Love, Aspuru-Guzik, and Oâ€™brien]{peruzzo2014variational}
Peruzzo,~A.; McClean,~J.; Shadbolt,~P.; Yung,~M.-H.; Zhou,~X.-Q.; Love,~P.~J.;
  Aspuru-Guzik,~A.; Oâ€™brien,~J.~L. A variational eigenvalue solver on a
  photonic quantum processor. \emph{Nat. Commun.} \textbf{2014}, \emph{5},
  4213\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[O'Malley \latin{et~al.}(2016)O'Malley, Babbush, Kivlichan, Romero,
  McClean, Barends, Kelly, Roushan, Tranter, Ding, Campbell, Chen, Chen,
  Chiaro, Dunsworth, Fowler, Jeffrey, Lucero, Megrant, Mutus, Neeley, Neill,
  Quintana, Sank, Vainsencher, Wenner, White, Coveney, Love, Neven,
  Aspuru-Guzik, and Martinis]{o2016scalable}
O'Malley,~P. J.~J.; Babbush,~R.; Kivlichan,~I.~D.; Romero,~J.; McClean,~J.~R.;
  Barends,~R.; Kelly,~J.; Roushan,~P.; Tranter,~A.; Ding,~N.; Campbell,~B.;
  Chen,~Y.; Chen,~Z.; Chiaro,~B.; Dunsworth,~A.; Fowler,~A.~G.; Jeffrey,~E.;
  Lucero,~E.; Megrant,~A.; Mutus,~J.~Y.; Neeley,~M.; Neill,~C.; Quintana,~C.;
  Sank,~D.; Vainsencher,~A.; Wenner,~J.; White,~T.~C.; Coveney,~P.~V.;
  Love,~P.~J.; Neven,~H.; Aspuru-Guzik,~A.; Martinis,~J.~M. Scalable quantum
  simulation of molecular energies. \emph{Phys. Rev. X.} \textbf{2016},
  \emph{6}, 031007\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Cerezo \latin{et~al.}(2021)Cerezo, Arrasmith, Babbush, Benjamin, Endo,
  Fujii, McClean, Mitarai, Yuan, Cincio, and Coles]{cerezo2021variational}
Cerezo,~M.; Arrasmith,~A.; Babbush,~R.; Benjamin,~S.~C.; Endo,~S.; Fujii,~K.;
  McClean,~J.~R.; Mitarai,~K.; Yuan,~X.; Cincio,~L.; Coles,~P.~J. Variational
  quantum algorithms. \emph{Nat. Rev. Phys.} \textbf{2021}, \emph{3},
  625--644\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Tilly \latin{et~al.}(2022)Tilly, Chen, Cao, Picozzi, Setia, Li, Grant,
  Wossnig, Rungger, Booth, and Tennyson]{tilly2022variational}
Tilly,~J.; Chen,~H.; Cao,~S.; Picozzi,~D.; Setia,~K.; Li,~Y.; Grant,~E.;
  Wossnig,~L.; Rungger,~I.; Booth,~G.~H.; Tennyson,~J. The variational quantum
  eigensolver: a review of methods and best practices. \emph{Phys. Rep.}
  \textbf{2022}, \emph{986}, 1--128\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Aspuru-Guzik \latin{et~al.}(2005)Aspuru-Guzik, Dutoi, Love, and
  Head-Gordon]{aspuru2005simulated}
Aspuru-Guzik,~A.; Dutoi,~A.~D.; Love,~P.~J.; Head-Gordon,~M. Simulated quantum
  computation of molecular energies. \emph{Science} \textbf{2005}, \emph{309},
  1704--1707\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Lee \latin{et~al.}(2023)Lee, Lee, Zhai, Tong, Dalzell, Kumar, Helms,
  Gray, Cui, Liu, Kastoryano, Babbush, Preskill, Reichman, Campbell, Valeev,
  Lin, and Chan]{lee2023evaluating}
Lee,~S.; Lee,~J.; Zhai,~H.; Tong,~Y.; Dalzell,~A.~M.; Kumar,~A.; Helms,~P.;
  Gray,~J.; Cui,~Z.-H.; Liu,~W.; Kastoryano,~M.; Babbush,~R.; Preskill,~J.;
  Reichman,~D.~R.; Campbell,~E.~T.; Valeev,~E.~F.; Lin,~L.; Chan,~G. K.-L.
  Evaluating the evidence for exponential quantum advantage in ground-state
  quantum chemistry. \emph{Nature Commun.} \textbf{2023}, \emph{14}, 1952\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Bartlett \latin{et~al.}(1989)Bartlett, Kucharski, and
  Noga]{bartlett1989alternative}
Bartlett,~R.~J.; Kucharski,~S.~A.; Noga,~J. Alternative coupled-cluster
  ans{\"a}tze II. The unitary coupled-cluster method. \emph{Chem. Phys. Lett.}
  \textbf{1989}, \emph{155}, 133--140\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kutzelnigg(1991)]{kutzelnigg1991error}
Kutzelnigg,~W. Error analysis and improvements of coupled-cluster theory.
  \emph{Theor. Chim. Acta} \textbf{1991}, \emph{80}, 349--386\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Anand \latin{et~al.}(2022)Anand, Schleich, Alperin-Lea, Jensen, Sim,
  D{\'\i}az-Tinoco, Kottmann, Degroote, Izmaylov, and
  Aspuru-Guzik]{anand2022quantum}
Anand,~A.; Schleich,~P.; Alperin-Lea,~S.; Jensen,~P.~W.; Sim,~S.;
  D{\'\i}az-Tinoco,~M.; Kottmann,~J.~S.; Degroote,~M.; Izmaylov,~A.~F.;
  Aspuru-Guzik,~A. A quantum computing view on unitary coupled cluster theory.
  \emph{Chem. Soc. Rev.} \textbf{2022}, \relax
\mciteBstWouldAddEndPunctfalse
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Lee \latin{et~al.}(2018)Lee, Huggins, Head-Gordon, and
  Whaley]{lee2018generalized}
Lee,~J.; Huggins,~W.~J.; Head-Gordon,~M.; Whaley,~K.~B. Generalized unitary
  coupled cluster wave functions for quantum computation. \emph{J. Chem. Theory
  and Comput.} \textbf{2018}, \emph{15}, 311--324\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Grimsley \latin{et~al.}(2019)Grimsley, Economou, Barnes, and
  Mayhall]{grimsley2019adaptive}
Grimsley,~H.~R.; Economou,~S.~E.; Barnes,~E.; Mayhall,~N.~J. An adaptive
  variational algorithm for exact molecular simulations on a quantum computer.
  \emph{Nat. Commun.} \textbf{2019}, \emph{10}, 1--9\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Elfving \latin{et~al.}(2021)Elfving, Millaruelo, G{\'a}mez, and
  Gogolin]{elfving2021simulating}
Elfving,~V.~E.; Millaruelo,~M.; G{\'a}mez,~J.~A.; Gogolin,~C. Simulating
  quantum chemistry in the seniority-zero space on qubit-based quantum
  computers. \emph{Phys. Rev. A} \textbf{2021}, \emph{103}, 032605\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kandala \latin{et~al.}(2017)Kandala, Mezzacapo, Temme, Takita, Brink,
  Chow, and Gambetta]{kandala2017hardware}
Kandala,~A.; Mezzacapo,~A.; Temme,~K.; Takita,~M.; Brink,~M.; Chow,~J.~M.;
  Gambetta,~J.~M. Hardware-efficient variational quantum eigensolver for small
  molecules and quantum magnets. \emph{Nature} \textbf{2017}, \emph{549},
  242--246\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Ollitrault \latin{et~al.}(2021)Ollitrault, Miessen, and
  Tavernelli]{ollitrault2021molecular}
Ollitrault,~P.~J.; Miessen,~A.; Tavernelli,~I. Molecular quantum dynamics: A
  quantum computing perspective. \emph{Acc. Chem. Res.} \textbf{2021},
  \emph{54}, 4229--4238\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Li and Benjamin(2017)Li, and Benjamin]{li2017efficient}
Li,~Y.; Benjamin,~S.~C. Efficient variational quantum simulator incorporating
  active error minimization. \emph{Phys. Rev. X} \textbf{2017}, \emph{7},
  021050\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Yuan \latin{et~al.}(2019)Yuan, Endo, Zhao, Li, and
  Benjamin]{yuan2019theory}
Yuan,~X.; Endo,~S.; Zhao,~Q.; Li,~Y.; Benjamin,~S.~C. Theory of variational
  quantum simulation. \emph{Quantum} \textbf{2019}, \emph{3}, 191\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Colless \latin{et~al.}(2018)Colless, Ramasesh, Dahlen, Blok,
  Kimchi-Schwartz, McClean, Carter, de~Jong, and
  Siddiqi]{colless2018computation}
Colless,~J.~I.; Ramasesh,~V.~V.; Dahlen,~D.; Blok,~M.~S.;
  Kimchi-Schwartz,~M.~E.; McClean,~J.~R.; Carter,~J.; de~Jong,~W.~A.;
  Siddiqi,~I. Computation of molecular spectra on a quantum processor with an
  error-resilient algorithm. \emph{Phys. Rev. X.} \textbf{2018}, \emph{8},
  011021\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kandala \latin{et~al.}(2019)Kandala, Temme, C{\'o}rcoles, Mezzacapo,
  Chow, and Gambetta]{kandala2019error}
Kandala,~A.; Temme,~K.; C{\'o}rcoles,~A.~D.; Mezzacapo,~A.; Chow,~J.~M.;
  Gambetta,~J.~M. Error mitigation extends the computational reach of a noisy
  quantum processor. \emph{Nature} \textbf{2019}, \emph{567}, 491--495\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Rice \latin{et~al.}(2021)Rice, Gujarati, Motta, Takeshita, Lee,
  Latone, and Garcia]{rice2021quantum}
Rice,~J.~E.; Gujarati,~T.~P.; Motta,~M.; Takeshita,~T.~Y.; Lee,~E.;
  Latone,~J.~A.; Garcia,~J.~M. Quantum computation of dominant products in
  lithium--sulfur batteries. \emph{J. Chem. Phys.} \textbf{2021}, \emph{154},
  134115\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Gao \latin{et~al.}(2021)Gao, Jones, Motta, Sugawara, Watanabe,
  Kobayashi, Watanabe, Ohnishi, Nakamura, and Yamamoto]{gao2021applications}
Gao,~Q.; Jones,~G.~O.; Motta,~M.; Sugawara,~M.; Watanabe,~H.~C.; Kobayashi,~T.;
  Watanabe,~E.; Ohnishi,~Y.-y.; Nakamura,~H.; Yamamoto,~N. Applications of
  quantum computing for investigations of electronic transitions in
  phenylsulfonyl-carbazole {TADF} emitters. \emph{npj Comput. Mater.}
  \textbf{2021}, \emph{7}, 70\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kirsopp \latin{et~al.}(2022)Kirsopp, Di~Paola, Manrique, Krompiec,
  Greene-Diniz, Guba, Meyder, Wolf, Strahm, and
  Mu{\~n}oz~Ramo]{kirsopp2022quantum}
Kirsopp,~J.~J.; Di~Paola,~C.; Manrique,~D.~Z.; Krompiec,~M.; Greene-Diniz,~G.;
  Guba,~W.; Meyder,~A.; Wolf,~D.; Strahm,~M.; Mu{\~n}oz~Ramo,~D. Quantum
  computational quantification of protein-ligand interactions. \emph{Int. J.
  Quantum Chem.} \textbf{2022}, \emph{122}, e26975\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Mitarai \latin{et~al.}(2018)Mitarai, Negoro, Kitagawa, and
  Fujii]{mitarai2018quantum}
Mitarai,~K.; Negoro,~M.; Kitagawa,~M.; Fujii,~K. Quantum circuit learning.
  \emph{Phys. Rev. A} \textbf{2018}, \emph{98}, 032309\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Schuld \latin{et~al.}(2019)Schuld, Bergholm, Gogolin, Izaac, and
  Killoran]{schuld2019evaluating}
Schuld,~M.; Bergholm,~V.; Gogolin,~C.; Izaac,~J.; Killoran,~N. Evaluating
  analytic gradients on quantum hardware. \emph{Phys. Rev. A} \textbf{2019},
  \emph{99}, 032331\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Zhang \latin{et~al.}(2023)Zhang, Allcock, Wan, Liu, Sun, Yu, Yang,
  Qiu, Ye, Chen, Lee, Zheng, Jian, Yao, Hsieh, and
  Zhang]{zhang2023tensorcircuit}
Zhang,~S.-X.; Allcock,~J.; Wan,~Z.-Q.; Liu,~S.; Sun,~J.; Yu,~H.; Yang,~X.-H.;
  Qiu,~J.; Ye,~Z.; Chen,~Y.-Q.; Lee,~C.-K.; Zheng,~Y.-C.; Jian,~S.-K.; Yao,~H.;
  Hsieh,~C.-Y.; Zhang,~S. Tensorcircuit: {A} quantum software framework for the
  {NISQ} era. \emph{Quantum} \textbf{2023}, \emph{7}, 912\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Chen \latin{et~al.}(2021)Chen, Cheng, and Freericks]{chen2021quantum}
Chen,~J.; Cheng,~H.-P.; Freericks,~J.~K. Quantum-inspired algorithm for the
  factorized form of unitary coupled cluster theory. \emph{J. Chem. Theory and
  Comput.} \textbf{2021}, \emph{17}, 841--847\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kottmann \latin{et~al.}(2021)Kottmann, Anand, and
  Aspuru-Guzik]{kottmann2021feasible}
Kottmann,~J.~S.; Anand,~A.; Aspuru-Guzik,~A. A feasible approach for
  automatically differentiable unitary coupled-cluster on quantum computers.
  \emph{Chem. Sci.} \textbf{2021}, \emph{12}, 3497--3508\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Rubin \latin{et~al.}(2021)Rubin, Gunst, White, Freitag, Throssell,
  Chan, Babbush, and Shiozaki]{rubin2021fermionic}
Rubin,~N.~C.; Gunst,~K.; White,~A.; Freitag,~L.; Throssell,~K.; Chan,~G. K.-L.;
  Babbush,~R.; Shiozaki,~T. The Fermionic Quantum Emulator. \emph{Quantum}
  \textbf{2021}, \emph{5}, 568\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Lee \latin{et~al.}(2021)Lee, Hsieh, Zhang, and Shi]{lee2021simulation}
Lee,~C.-K.; Hsieh,~C.-Y.; Zhang,~S.; Shi,~L. Simulation of Condensed-Phase
  Spectroscopy with Near-Term Digital Quantum Computers. \emph{J. Chem. Theory
  and Comput.} \textbf{2021}, \emph{17}, 7178--7186\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Lee \latin{et~al.}(2022)Lee, Zhong~Lau, Shi, and
  Kwek]{lee2022simulating}
Lee,~C.-K.; Zhong~Lau,~J.~W.; Shi,~L.; Kwek,~L.~C. Simulating energy transfer
  in molecular systems with digital quantum computers. \emph{J. Chem. Theory
  and Comput.} \textbf{2022}, \emph{18}, 1347--1358\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Ollitrault \latin{et~al.}(2020)Ollitrault, Mazzola, and
  Tavernelli]{ollitrault2020nonadiabatic}
Ollitrault,~P.~J.; Mazzola,~G.; Tavernelli,~I. Nonadiabatic molecular quantum
  dynamics with quantum computers. \emph{Phys. Rev. Lett.} \textbf{2020},
  \emph{125}, 260511\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Lee \latin{et~al.}(2022)Lee, Hsieh, Zhang, and
  Shi]{lee2022variational}
Lee,~C.-K.; Hsieh,~C.-Y.; Zhang,~S.; Shi,~L. Variational Quantum Simulation of
  Chemical Dynamics with Quantum Computers. \emph{J. Chem. Theory and Comput.}
  \textbf{2022}, \emph{18}, 2105--2113\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Jordan and Wigner(1928)Jordan, and Wigner]{JW28}
Jordan,~P.; Wigner,~E. {\"U}ber das Paulische {\"A}quivalenzverbot.
  \emph{Zeitschrift f{\"u}r Physik} \textbf{1928}, \emph{47}, 631--651\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Bravyi and Kitaev(2002)Bravyi, and Kitaev]{bravyi2002fermionic}
Bravyi,~S.~B.; Kitaev,~A.~Y. Fermionic quantum computation. \emph{Ann. Phys.}
  \textbf{2002}, \emph{298}, 210--226\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Seeley \latin{et~al.}(2012)Seeley, Richard, and
  Love]{seeley2012bravyi}
Seeley,~J.~T.; Richard,~M.~J.; Love,~P.~J. The {Bravyi-Kitaev} transformation
  for quantum computation of electronic structure. \emph{J. Chem. Phys.}
  \textbf{2012}, \emph{137}, 224109\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Sawaya \latin{et~al.}(2020)Sawaya, Menke, Kyaw, Johri, Aspuru-Guzik,
  and Guerreschi]{sawaya2020resource}
Sawaya,~N.~P.; Menke,~T.; Kyaw,~T.~H.; Johri,~S.; Aspuru-Guzik,~A.;
  Guerreschi,~G.~G. Resource-efficient digital quantum simulation of $d$-level
  systems for photonic, vibrational, and spin-$s$ Hamiltonians. \emph{npj
  Quantum Inf.} \textbf{2020}, \emph{6}, 1--13\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Nam \latin{et~al.}(2020)Nam, Chen, Pisenti, Wright, Delaney, Maslov,
  Brown, Allen, Amini, Apisdorf, Beck, Blinov, Chaplin, Chmielewski, Collins,
  Debnath, Hudek, Ducore, Keesan, Kreikemeier, Mizrahi, Solomon, Williams,
  Wong-Campos, Moehring, Monroe, and Kim]{nam2020ground}
Nam,~Y.; Chen,~J.-S.; Pisenti,~N.~C.; Wright,~K.; Delaney,~C.; Maslov,~D.;
  Brown,~K.~R.; Allen,~S.; Amini,~J.~M.; Apisdorf,~J.; Beck,~K.~M.; Blinov,~A.;
  Chaplin,~V.; Chmielewski,~M.; Collins,~C.; Debnath,~S.; Hudek,~K.~M.;
  Ducore,~A.~M.; Keesan,~M.; Kreikemeier,~S.~M.; Mizrahi,~J.; Solomon,~P.;
  Williams,~M.; Wong-Campos,~J.~D.; Moehring,~D.; Monroe,~C.; Kim,~J.
  Ground-state energy estimation of the water molecule on a trapped-ion quantum
  computer. \emph{npj Quantum Inf.} \textbf{2020}, \emph{6}, 33\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Li \latin{et~al.}(2022)Li, Huang, Cao, Huang, Shuai, Sun, Sun, Yuan,
  and Lv]{li2022toward}
Li,~W.; Huang,~Z.; Cao,~C.; Huang,~Y.; Shuai,~Z.; Sun,~X.; Sun,~J.; Yuan,~X.;
  Lv,~D. Toward practical quantum embedding simulation of realistic chemical
  systems on near-term quantum computers. \emph{Chem. Sci.} \textbf{2022},
  \emph{13}, 8953--8962\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Guo \latin{et~al.}(2022)Guo, Sun, Qian, Gong, Zhang, Chen, Ye, Wu,
  Cao, Liu, Zha, Ying, Zhu, Huang, Zhao, Li, Wang, Yu, Fan, Wu, Su, Deng, Rong,
  Li, Zhang, Chung, Liang, Lin, Xu, Sun, Guo, Li, Huo, Peng, Lu, Yuan, Zhu, and
  Pan]{guo2022experimental}
Guo,~S.; Sun,~J.; Qian,~H.; Gong,~M.; Zhang,~Y.; Chen,~F.; Ye,~Y.; Wu,~Y.;
  Cao,~S.; Liu,~K.; Zha,~C.; Ying,~C.; Zhu,~Q.; Huang,~H.-L.; Zhao,~Y.; Li,~S.;
  Wang,~S.; Yu,~J.; Fan,~D.; Wu,~D.; Su,~H.; Deng,~H.; Rong,~H.; Li,~Y.;
  Zhang,~K.; Chung,~T.-H.; Liang,~F.; Lin,~J.; Xu,~Y.; Sun,~L.; Guo,~C.;
  Li,~N.; Huo,~Y.-H.; Peng,~C.-Z.; Lu,~C.-Y.; Yuan,~X.; Zhu,~X.; Pan,~J.-W.
  Experimental quantum computational chemistry with optimised unitary coupled
  cluster ansatz. \emph{arXiv preprint arXiv:2212.08006} \textbf{2022}, \relax
\mciteBstWouldAddEndPunctfalse
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Wecker \latin{et~al.}(2015)Wecker, Hastings, and
  Troyer]{wecker2015progress}
Wecker,~D.; Hastings,~M.~B.; Troyer,~M. Progress towards practical quantum
  variational algorithms. \emph{Phys. Rev. A} \textbf{2015}, \emph{92},
  042303\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Miessen \latin{et~al.}(2021)Miessen, Ollitrault, and
  Tavernelli]{miessen2021quantum}
Miessen,~A.; Ollitrault,~P.~J.; Tavernelli,~I. Quantum algorithms for quantum
  dynamics: a performance study on the spin-boson model. \emph{Phys. Rev. Res.}
  \textbf{2021}, \emph{3}, 043212\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Yao \latin{et~al.}(2021)Yao, Gomes, Zhang, Wang, Ho, Iadecola, and
  Orth]{yao2021adaptive}
Yao,~Y.-X.; Gomes,~N.; Zhang,~F.; Wang,~C.-Z.; Ho,~K.-M.; Iadecola,~T.;
  Orth,~P.~P. Adaptive variational quantum dynamics simulations. \emph{PRX
  Quantum} \textbf{2021}, \emph{2}, 030307\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Broeckhove \latin{et~al.}(1988)Broeckhove, Lathouwers, Kesteloot, and
  Van~Leuven]{broeckhove1988equivalence}
Broeckhove,~J.; Lathouwers,~L.; Kesteloot,~E.; Van~Leuven,~P. On the
  equivalence of time-dependent variational principles. \emph{Chem. Phys.
  Lett.} \textbf{1988}, \emph{149}, 547--550\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[{Qiskit contributors}(2023)]{qiskit}
{Qiskit contributors}, \emph{Qiskit: An Open-source Framework for Quantum
  Computing}; IBM, 2023\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[{Bergholm} \latin{et~al.}(2018){Bergholm}, {Izaac}, {Schuld},
  {Gogolin}, {Ahmed}, {Ajith}, {Sohaib Alam}, {Alonso-Linaje},
  {AkashNarayanan}, {Asadi}, {Arrazola}, {Azad}, {Banning}, {Blank}, {Bromley},
  {Cordier}, {Ceroni}, {Delgado}, {Di Matteo}, {Dusko}, {Garg}, {Guala},
  {Hayes}, {Hill}, {Ijaz}, {Isacsson}, {Ittah}, {Jahangiri}, {Jain}, {Jiang},
  {Khandelwal}, {Kottmann}, {Lang}, {Lee}, {Loke}, {Lowe}, {McKiernan},
  {Meyer}, {Monta{\~n}ez-Barrera}, {Moyard}, {Niu}, {O'Riordan}, {Oud},
  {Panigrahi}, {Park}, {Polatajko}, {Quesada}, {Roberts}, {S{\'a}}, {Schoch},
  {Shi}, {Shu}, {Sim}, {Singh}, {Strandberg}, {Soni}, {Sz{\'a}va}, {Thabet},
  {Vargas-Hern{\'a}ndez}, {Vincent}, {Vitucci}, {Weber}, {Wierichs},
  {Wiersema}, {Willmann}, {Wong}, {Zhang}, and
  {Killoran}]{bergholm2018pennylane}
{Bergholm},~V.; {Izaac},~J.; {Schuld},~M.; {Gogolin},~C.; {Ahmed},~S.;
  {Ajith},~V.; {Sohaib Alam},~M.; {Alonso-Linaje},~G.; {AkashNarayanan},~B.;
  {Asadi},~A.; {Arrazola},~J.~M.; {Azad},~U.; {Banning},~S.; {Blank},~C.;
  {Bromley},~T.~R.; {Cordier},~B.~A.; {Ceroni},~J.; {Delgado},~A.; {Di
  Matteo},~O.; {Dusko},~A.; {Garg},~T.; {Guala},~D.; {Hayes},~A.; {Hill},~R.;
  {Ijaz},~A.; {Isacsson},~T.; {Ittah},~D.; {Jahangiri},~S.; {Jain},~P.;
  {Jiang},~E.; {Khandelwal},~A.; {Kottmann},~K.; {Lang},~R.~A.; {Lee},~C.;
  {Loke},~T.; {Lowe},~A.; {McKiernan},~K.; {Meyer},~J.~J.;
  {Monta{\~n}ez-Barrera},~J.~A.; {Moyard},~R.; {Niu},~Z.; {O'Riordan},~L.~J.;
  {Oud},~S.; {Panigrahi},~A.; {Park},~C.-Y.; {Polatajko},~D.; {Quesada},~N.;
  {Roberts},~C.; {S{\'a}},~N.; {Schoch},~I.; {Shi},~B.; {Shu},~S.; {Sim},~S.;
  {Singh},~A.; {Strandberg},~I.; {Soni},~J.; {Sz{\'a}va},~A.; {Thabet},~S.;
  {Vargas-Hern{\'a}ndez},~R.~A.; {Vincent},~T.; {Vitucci},~N.; {Weber},~M.;
  {Wierichs},~D.; {Wiersema},~R.; {Willmann},~M.; {Wong},~V.; {Zhang},~S.;
  {Killoran},~N. Pennylane: Automatic differentiation of hybrid
  quantum-classical computations. \emph{arXiv preprint arXiv:1811.04968}
  \textbf{2018}, \relax
\mciteBstWouldAddEndPunctfalse
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[{MindQuantum Developer}(2021)]{mq_2021}
{MindQuantum Developer}, MindQuantum, version 0.6.0. 2021;
  \url{https://gitee.com/mindspore/mindquantum} (Accessed May 29, 2023)\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kottmann \latin{et~al.}(2021)Kottmann, Alperin-Lea, Tamayo-Mendoza,
  Cervera-Lierta, Lavigne, Yen, Verteletskyi, Schleich, Anand, Degroote,
  Chaney, Kesibi, Curnow, Solo, Tsilimigkounakis, Zendejas-Morales, Izmaylov,
  and Aspuru-Guzik]{kottmann2021tequila}
Kottmann,~J.~S.; Alperin-Lea,~S.; Tamayo-Mendoza,~T.; Cervera-Lierta,~A.;
  Lavigne,~C.; Yen,~T.-C.; Verteletskyi,~V.; Schleich,~P.; Anand,~A.;
  Degroote,~M.; Chaney,~S.; Kesibi,~M.; Curnow,~N.~G.; Solo,~B.;
  Tsilimigkounakis,~G.; Zendejas-Morales,~C.; Izmaylov,~A.~F.; Aspuru-Guzik,~A.
  Tequila: A platform for rapid development of quantum algorithms.
  \emph{Quantum Sci. Technol.} \textbf{2021}, \emph{6}, 024009\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Fan \latin{et~al.}(2022)Fan, Liu, Zeng, Xu, Shang, Li, and
  Yang]{fan2022q}
Fan,~Y.; Liu,~J.; Zeng,~X.; Xu,~Z.; Shang,~H.; Li,~Z.; Yang,~J. Q$^2$
  Chemistry: A quantum computation platform for quantum chemistry. \emph{arXiv
  preprint arXiv:2208.10978} \textbf{2022}, \relax
\mciteBstWouldAddEndPunctfalse
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Stair and Evangelista(2022)Stair, and Evangelista]{stair2022qforte}
Stair,~N.~H.; Evangelista,~F.~A. {QForte}: An efficient state-vector emulator
  and quantum algorithms library for molecular electronic structure. \emph{J.
  Chem. Theory and Comput.} \textbf{2022}, \emph{18}, 1555--1568\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Cao \latin{et~al.}(2022)Cao, Hu, Zhang, Xu, Chen, Yu, Li, Hu, Lv, and
  Yung]{cao2022progress}
Cao,~C.; Hu,~J.; Zhang,~W.; Xu,~X.; Chen,~D.; Yu,~F.; Li,~J.; Hu,~H.-S.;
  Lv,~D.; Yung,~M.-H. Progress toward larger molecular simulation on a quantum
  computer: Simulating a system with up to 28 qubits accelerated by point-group
  symmetry. \emph{Phys. Rev. A} \textbf{2022}, \emph{105}, 062452\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Schollw{\"o}ck(2011)]{schollwock2011density}
Schollw{\"o}ck,~U. The density-matrix renormalization group in the age of
  matrix product states. \emph{Ann. Phys.} \textbf{2011}, \emph{326},
  96--192\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Shang \latin{et~al.}(2023)Shang, Fan, Shen, Guo, Liu, Duan, Li, and
  Li]{shang2023towards}
Shang,~H.; Fan,~Y.; Shen,~L.; Guo,~C.; Liu,~J.; Duan,~X.; Li,~F.; Li,~Z.
  Towards practical and massively parallel quantum computing emulation for
  quantum chemistry. \emph{npj Quantum Inf.} \textbf{2023}, \emph{9}, 33\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Ollitrault \latin{et~al.}(2020)Ollitrault, Baiardi, Reiher, and
  Tavernelli]{ollitrault2020hardware}
Ollitrault,~P.~J.; Baiardi,~A.; Reiher,~M.; Tavernelli,~I. Hardware efficient
  quantum algorithms for vibrational structure calculations. \emph{Chem. Sci.}
  \textbf{2020}, \emph{11}, 6842--6855\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Bradbury \latin{et~al.}(2018)Bradbury, Frostig, Hawkins, Johnson,
  Leary, Maclaurin, Necula, Paszke, Vander{P}las, Wanderman-{M}ilne, and
  Zhang]{jax2018github}
Bradbury,~J.; Frostig,~R.; Hawkins,~P.; Johnson,~M.~J.; Leary,~C.;
  Maclaurin,~D.; Necula,~G.; Paszke,~A.; Vander{P}las,~J.;
  Wanderman-{M}ilne,~S.; Zhang,~Q. {JAX}: composable transformations of
  {P}ython+{N}um{P}y programs. 2018; \url{http://github.com/google/jax}
  (Accessed May 29, 2023)\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Sun \latin{et~al.}(2018)Sun, Berkelbach, Blunt, Booth, Guo, Li, Liu,
  McClain, Sayfutyarova, Sharma, Wouters, and Chan]{sun2018pyscf}
Sun,~Q.; Berkelbach,~T.~C.; Blunt,~N.~S.; Booth,~G.~H.; Guo,~S.; Li,~Z.;
  Liu,~J.; McClain,~J.; Sayfutyarova,~E.~R.; Sharma,~S.; Wouters,~S.; Chan,~G.
  K.-L. {PySCF}: the {Python}-based simulations of chemistry framework.
  \emph{Wiley Interdiscip. Rev. Comput. Mol. Sci.} \textbf{2018}, \emph{8},
  e1340\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Luo \latin{et~al.}(2020)Luo, Liu, Zhang, and Wang]{luo2020yao}
Luo,~X.-Z.; Liu,~J.-G.; Zhang,~P.; Wang,~L. Yao. jl: Extensible, efficient
  framework for quantum algorithm design. \emph{Quantum} \textbf{2020},
  \emph{4}, 341\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Ren \latin{et~al.}(2021)Ren, Li, Jiang, Wang, and Shuai]{renormalizer}
Ren,~J.; Li,~W.; Jiang,~T.; Wang,~Y.; Shuai,~Z. The \textsc{Renormalizer}
  Package. https://github.com/shuaigroup/Renormalizer. 2021;
  \url{https://github.com/shuaigroup/Renormalizer} (Accessed May 29,
  2023)\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[McClean \latin{et~al.}(2020)McClean, Rubin, Sung, Kivlichan,
  Bonet-Monroig, Cao, Dai, Fried, Gidney, Gimby, Gokhale, HÃ¤ner, Hardikar,
  HavlÃ­Äek, Higgott, Huang, Izaac, Jiang, Liu, McArdle, Neeley, Oâ€™Brien,
  Oâ€™Gorman, Ozfidan, Radin, Romero, Sawaya, Senjean, Setia, Sim, Steiger,
  Steudtner, Sun, Sun, Wang, Zhang, and Babbush]{mcclean2020openfermion}
McClean,~J.~R.; Rubin,~N.~C.; Sung,~K.~J.; Kivlichan,~I.~D.; Bonet-Monroig,~X.;
  Cao,~Y.; Dai,~C.; Fried,~E.~S.; Gidney,~C.; Gimby,~B.; Gokhale,~P.;
  HÃ¤ner,~T.; Hardikar,~T.; HavlÃ­Äek,~V.; Higgott,~O.; Huang,~C.; Izaac,~J.;
  Jiang,~Z.; Liu,~X.; McArdle,~S.; Neeley,~M.; Oâ€™Brien,~T.; Oâ€™Gorman,~B.;
  Ozfidan,~I.; Radin,~M.~D.; Romero,~J.; Sawaya,~N. P.~D.; Senjean,~B.;
  Setia,~K.; Sim,~S.; Steiger,~D.~S.; Steudtner,~M.; Sun,~Q.; Sun,~W.;
  Wang,~D.; Zhang,~F.; Babbush,~R. OpenFermion: The electronic structure
  package for quantum computers. \emph{Quantum Sci. Technol.} \textbf{2020},
  \emph{5}, 034014\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[McArdle \latin{et~al.}(2019)McArdle, Mayorov, Shan, Benjamin, and
  Yuan]{mcardle2019digital}
McArdle,~S.; Mayorov,~A.; Shan,~X.; Benjamin,~S.; Yuan,~X. Digital quantum
  simulation of molecular vibrations. \emph{Chem. Sci.} \textbf{2019},
  \emph{10}, 5725--5735\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Colbert and Miller(1992)Colbert, and Miller]{colbert1992novel}
Colbert,~D.~T.; Miller,~W.~H. A novel discrete variable representation for
  quantum mechanical reactive scattering via the $S$-matrix {Kohn} method.
  \emph{J. Chem. Phys.} \textbf{1992}, \emph{96}, 1982--1991\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Li \latin{et~al.}(2023)Li, Ren, Huai, Cai, Shuai, and
  Zhang]{li2023efficient}
Li,~W.; Ren,~J.; Huai,~S.; Cai,~T.; Shuai,~Z.; Zhang,~S. Efficient quantum
  simulation of electron-phonon systems by variational basis state encoder.
  \emph{Phys. Rev. Res.} \textbf{2023}, \emph{5}, 023046\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Evangelista \latin{et~al.}(2019)Evangelista, Chan, and
  Scuseria]{evangelista2019exact}
Evangelista,~F.~A.; Chan,~G. K.-L.; Scuseria,~G.~E. Exact parameterization of
  fermionic wave functions via unitary coupled cluster theory. \emph{J. Chem.
  Phys.} \textbf{2019}, \emph{151}, 244112\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[McClean \latin{et~al.}(2018)McClean, Boixo, Smelyanskiy, Babbush, and
  Neven]{mcclean2018barren}
McClean,~J.~R.; Boixo,~S.; Smelyanskiy,~V.~N.; Babbush,~R.; Neven,~H. Barren
  plateaus in quantum neural network training landscapes. \emph{Nat. Commun.}
  \textbf{2018}, \emph{9}, 4812\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Choy and Wales(2023)Choy, and Wales]{choy2023molecular}
Choy,~B.; Wales,~D.~J. Molecular Energy Landscapes of Hardware-Efficient Ansatz
  in Quantum Computing. \emph{J. Chem. Theory and Comput.} \textbf{2023},
  \emph{19}, 1197--1206\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Gao \latin{et~al.}(2021)Gao, Nakamura, Gujarati, Jones, Rice, Wood,
  Pistoia, Garcia, and Yamamoto]{gao2021computational}
Gao,~Q.; Nakamura,~H.; Gujarati,~T.~P.; Jones,~G.~O.; Rice,~J.~E.; Wood,~S.~P.;
  Pistoia,~M.; Garcia,~J.~M.; Yamamoto,~N. Computational investigations of the
  lithium superoxide dimer rearrangement on noisy quantum devices. \emph{J.
  Phys. Chem. A} \textbf{2021}, \emph{125}, 1827--1836\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Mih{\'a}likov{\'a} \latin{et~al.}(2022)Mih{\'a}likov{\'a}, Pivoluska,
  Plesch, Fri{\'a}k, Nagaj, and {\v{S}}ob]{mihalikova2022cost}
Mih{\'a}likov{\'a},~I.; Pivoluska,~M.; Plesch,~M.; Fri{\'a}k,~M.; Nagaj,~D.;
  {\v{S}}ob,~M. The Cost of Improving the Precision of the Variational Quantum
  Eigensolver for Quantum Chemistry. \emph{Nanomaterials} \textbf{2022},
  \emph{12}, 243\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Markov and Shi(2008)Markov, and Shi]{markov2008simulating}
Markov,~I.~L.; Shi,~Y. Simulating quantum computation by contracting tensor
  networks. \emph{SIAM J. Comput.} \textbf{2008}, \emph{38}, 963--981\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Liu \latin{et~al.}(2021)Liu, Liu, Li, Fu, Yang, Song, Zhao, Wang,
  Peng, Chen, Guo, Huang, Wu, and Chen]{liu2021closing}
Liu,~Y.~A.; Liu,~X.~L.; Li,~F.~N.; Fu,~H.; Yang,~Y.; Song,~J.; Zhao,~P.;
  Wang,~Z.; Peng,~D.; Chen,~H.; Guo,~C.; Huang,~H.; Wu,~W.; Chen,~D. Closing
  the "quantum supremacy" gap: achieving real-time simulation of a random
  quantum circuit using a new {Sunway} supercomputer. In \emph{Proceedings of the
  International Conference for High Performance Computing, Networking, Storage
  and Analysis}. 2021; pp 1--12\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Pan and Zhang(2022)Pan, and Zhang]{pan2022simulation}
Pan,~F.; Zhang,~P. Simulation of quantum circuits using the big-batch tensor
  network method. \emph{Phys. Rev. Lett.} \textbf{2022}, \emph{128},
  030501\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Noh \latin{et~al.}(2020)Noh, Jiang, and Fefferman]{noh2020efficient}
Noh,~K.; Jiang,~L.; Fefferman,~B. Efficient classical simulation of noisy
  random quantum circuits in one dimension. \emph{Quantum} \textbf{2020},
  \emph{4}, 318\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Cheng \latin{et~al.}(2021)Cheng, Cao, Zhang, Liu, Hou, Xu, and
  Zeng]{cheng2021simulating}
Cheng,~S.; Cao,~C.; Zhang,~C.; Liu,~Y.; Hou,~S.-Y.; Xu,~P.; Zeng,~B. Simulating
  noisy quantum circuits with matrix product density operators. \emph{Phys.
  Rev. Res.} \textbf{2021}, \emph{3}, 023005\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Virtanen \latin{et~al.}(2020)Virtanen, Gommers, Oliphant, Haberland,
  Reddy, Cournapeau, Burovski, Peterson, Weckesser, Bright, {van der Walt},
  Brett, Wilson, Millman, Mayorov, Nelson, Jones, Kern, Larson, Carey, Polat,
  Feng, Moore, {VanderPlas}, Laxalde, Perktold, Cimrman, Henriksen, Quintero,
  Harris, Archibald, Ribeiro, Pedregosa, {van Mulbregt}, and {SciPy 1.0
  Contributors}]{2020SciPy-NMeth}
Virtanen,~P.; Gommers,~R.; Oliphant,~T.~E.; Haberland,~M.; Reddy,~T.;
  Cournapeau,~D.; Burovski,~E.; Peterson,~P.; Weckesser,~W.; Bright,~J.; {van
  der Walt},~S.~J.; Brett,~M.; Wilson,~J.; Millman,~K.~J.; Mayorov,~N.;
  Nelson,~A. R.~J.; Jones,~E.; Kern,~R.; Larson,~E.; Carey,~C.~J.;
  Polat,~{\.I}.; Feng,~Y.; Moore,~E.~W.; {VanderPlas},~J.; Laxalde,~D.;
  Perktold,~J.; Cimrman,~R.; Henriksen,~I.; Quintero,~E.~A.; Harris,~C.~R.;
  Archibald,~A.~M.; Ribeiro,~A.~H.; Pedregosa,~F.; {van Mulbregt},~P.; {SciPy
  1.0 Contributors}, {SciPy} 1.0: Fundamental Algorithms for Scientific
  Computing in Python. \emph{Nat. Methods} \textbf{2020}, \emph{17},
  261--272\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Yordanov \latin{et~al.}(2020)Yordanov, Arvidsson-Shukur, and
  Barnes]{yordanov2020efficient}
Yordanov,~Y.~S.; Arvidsson-Shukur,~D.~R.; Barnes,~C.~H. Efficient quantum
  circuits for quantum computational chemistry. \emph{Phys. Rev. A}
  \textbf{2020}, \emph{102}, 062612\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Magoulas and Evangelista(2023)Magoulas, and
  Evangelista]{magoulas2023cnot}
Magoulas,~I.; Evangelista,~F.~A. {CNOT}-Efficient Circuits for Arbitrary Rank
  Many-Body Fermionic and Qubit Excitations. \emph{J. Chem. Theory Comput.}
  \textbf{2023}, \emph{19}, 822--836\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Dunning~Jr(1989)]{dunning1989gaussian}
Dunning~Jr,~T.~H. Gaussian basis sets for use in correlated molecular
  calculations. {I.} The atoms boron through neon and hydrogen. \emph{J. Chem.
  Phys.} \textbf{1989}, \emph{90}, 1007--1023\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Li \latin{et~al.}(2019)Li, Liu, Wang, Ashhab, Cui, Chen, Peng, and
  Du]{li2019quantum}
Li,~Z.; Liu,~X.; Wang,~H.; Ashhab,~S.; Cui,~J.; Chen,~H.; Peng,~X.; Du,~J.
  Quantum simulation of resonant transitions for solving the eigenproblem of an
  effective water {Hamiltonian}. \emph{Phys. Rev. Lett.} \textbf{2019},
  \emph{122}, 090504\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Ryabinkin \latin{et~al.}(2020)Ryabinkin, Lang, Genin, and
  Izmaylov]{ryabinkin2020iterative}
Ryabinkin,~I.~G.; Lang,~R.~A.; Genin,~S.~N.; Izmaylov,~A.~F. Iterative qubit
  coupled cluster approach with efficient screening of generators. \emph{J.
  Chem. Theory and Comput.} \textbf{2020}, \emph{16}, 1055--1063\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Hehre \latin{et~al.}(1972)Hehre, Ditchfield, and Pople]{hehre1972self}
Hehre,~W.~J.; Ditchfield,~R.; Pople,~J.~A. Self-consistent molecular orbital
  methods. {XII.} Further extensions of {Gaussian}-type basis sets for use in
  molecular orbital studies of organic molecules. \emph{J. Chem. Phys.}
  \textbf{1972}, \emph{56}, 2257--2261\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Hariharan and Pople(1973)Hariharan, and Pople]{hariharan1973influence}
Hariharan,~P.~C.; Pople,~J.~A. The influence of polarization functions on
  molecular orbital hydrogenation energies. \emph{Theor. Chim. Acta}
  \textbf{1973}, \emph{28}, 213--222\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Hoy and Bunker(1979)Hoy, and Bunker]{hoy1979precise}
Hoy,~A.; Bunker,~P.~R. A precise solution of the rotation bending
  Schr{\"o}dinger equation for a triatomic molecule with application to the
  water molecule. \emph{J. Mol. Spectrosc.} \textbf{1979}, \emph{74},
  1--8\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Sokolov \latin{et~al.}(2020)Sokolov, Barkoutsos, Ollitrault,
  Greenberg, Rice, Pistoia, and Tavernelli]{sokolov2020quantum}
Sokolov,~I.~O.; Barkoutsos,~P.~K.; Ollitrault,~P.~J.; Greenberg,~D.; Rice,~J.;
  Pistoia,~M.; Tavernelli,~I. Quantum orbital-optimized unitary coupled cluster
  methods in the strongly correlated regime: Can quantum algorithms outperform
  their classical equivalents? \emph{J. Chem. Phys.} \textbf{2020}, \emph{152},
  124107\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Knizia and Chan(2012)Knizia, and Chan]{knizia2012density}
Knizia,~G.; Chan,~G. K.-L. Density matrix embedding: A simple alternative to
  dynamical mean-field theory. \emph{Phys. Rev. Lett.} \textbf{2012},
  \emph{109}, 186404\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Knizia and Chan(2013)Knizia, and Chan]{knizia2013density}
Knizia,~G.; Chan,~G. K.-L. Density matrix embedding: A strong-coupling quantum
  embedding theory. \emph{J. Chem. Theory Comput.} \textbf{2013}, \emph{9},
  1428--1432\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Motta \latin{et~al.}(2017)Motta, Ceperley, Chan, Gomez, Gull, Guo,
  Jim{\'{e} }nez-Hoyos, Lan, Li, Ma, Millis, Prokof'ev, Ray, Scuseria, Sorella,
  Stoudenmire, Sun, Tupitsyn, White, Zgid, and Zhang]{motta2017towards}
Motta,~M.; Ceperley,~D.~M.; Chan,~G. K.-L.; Gomez,~J.~A.; Gull,~E.; Guo,~S.;
  Jim{\'{e} }nez-Hoyos,~C.~A.; Lan,~T.~N.; Li,~J.; Ma,~F.; Millis,~A.~J.;
  Prokof'ev,~N.~V.; Ray,~U.; Scuseria,~G.~E.; Sorella,~S.; Stoudenmire,~E.~M.;
  Sun,~Q.; Tupitsyn,~I.~S.; White,~S.~R.; Zgid,~D.; Zhang,~S. Towards the
  solution of the many-electron problem in real materials: Equation of state of
  the hydrogen chain with state-of-the-art many-body methods. \emph{Phys. Rev.
  X} \textbf{2017}, \emph{7}, 031059\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Mineh and Montanaro(2022)Mineh, and Montanaro]{mineh2022solving}
Mineh,~L.; Montanaro,~A. Solving the {Hubbard} model using density matrix
  embedding theory and the variational quantum eigensolver. \emph{Phys. Rev. B}
  \textbf{2022}, \emph{105}, 125117\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Nielsen and Chuang(2010)Nielsen, and Chuang]{nielsen2002quantum}
Nielsen,~M.~A.; Chuang,~I. \emph{Quantum computation and quantum information};
  Cambridge University Press, 2010\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Leggett \latin{et~al.}(1987)Leggett, Chakravarty, Dorsey, Fisher,
  Garg, and Zwerger]{leggett1987dynamics}
Leggett,~A.~J.; Chakravarty,~S.; Dorsey,~A.~T.; Fisher,~M.~P.; Garg,~A.;
  Zwerger,~W. Dynamics of the dissipative two-state system. \emph{Rev. Mod.
  Phys.} \textbf{1987}, \emph{59}, 1\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Shuai \latin{et~al.}(2020)Shuai, Li, Ren, Jiang, and
  Geng]{shuai2020applying}
Shuai,~Z.; Li,~W.; Ren,~J.; Jiang,~Y.; Geng,~H. Applying Marcus theory to
  describe the carrier transports in organic semiconductors: Limitations and
  beyond. \emph{J. Chem. Phys.} \textbf{2020}, \emph{153}, 080902\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Kloss \latin{et~al.}(2019)Kloss, Reichman, and
  Tempelaar]{kloss2019multiset}
Kloss,~B.; Reichman,~D.~R.; Tempelaar,~R. Multiset matrix product state
  calculations reveal mobile {Franck-Condon} excitations under strong
  {Holstein}-type coupling. \emph{Phys. Rev. Lett.} \textbf{2019}, \emph{123},
  126601\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\bibitem[Nan \latin{et~al.}(2009)Nan, Yang, Wang, Shuai, and
  Zhao]{nan2009nuclear}
Nan,~G.; Yang,~X.; Wang,~L.; Shuai,~Z.; Zhao,~Y. Nuclear tunneling effects of
  charge transport in rubrene, tetracene, and pentacene. \emph{Phys. Rev. B}
  \textbf{2009}, \emph{79}, 115203\relax
\mciteBstWouldAddEndPuncttrue
\mciteSetBstMidEndSepPunct{\mcitedefaultmidpunct}
{\mcitedefaultendpunct}{\mcitedefaultseppunct}\relax
\EndOfBibitem
\end{mcitethebibliography}

\end{document}
