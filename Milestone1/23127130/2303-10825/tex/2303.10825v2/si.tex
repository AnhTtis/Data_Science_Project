\documentclass[journal=jacsat,manuscript=article]{achemso}
\setkeys{acs}{maxauthors=299}
\usepackage[utf8]{inputenc}
\usepackage{physics}
\usepackage{braket}
\usepackage{bm}% bold math
\usepackage[hidelinks]{hyperref}% add hypertext capabilities
\SectionNumbersOn 
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{qcircuit}
%\usepackage{quantikz}
\usepackage{tikz}
\usetikzlibrary{positioning}
% smaller spacing in itemize
\usepackage{enumitem}
\setlist{nosep}
% lstlisting font
\usepackage{courier}
\usepackage[version=4]{mhchem}

\usepackage{listings}
% Code annotations
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\linespread{0.9}\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    basewidth=0.55em,
}

\lstset{style=mystyle}
% change listing to code snippet
\renewcommand{\lstlistingname}{Code Snippet S\hspace{-0.14cm}}

\newcommand{\bp}[1]{\vspace{\baselineskip}\noindent\textbf{#1}}
\definecolor{bkgd}{RGB}{240,242,246}
\definecolor{orange-red}{rgb}{1.0, 0.27, 0.0}
\newcommand{\fancylink}[2]{\colorbox{bkgd}{\color{orange-red}\href{#1}{\sf {#2}}}}

\newcommand{\tc}{\textsc{TensorCircuit}}
\newcommand{\tcc}{\textsc{TenCirChem}}
\newcommand{\jax}{\textsc{JAX}}
\newcommand{\numpy}{\textsc{NumPy}}
\newcommand{\cupy}{\textsc{CuPy}}
\newcommand{\pyscf}{\textsc{PySCF}}
\newcommand{\scipy}{\textsc{SciPy}}
\newcommand{\reno}{\textsc{Renormalizer}}
\newcommand{\openfermion}{\textsc{OpenFermion}}
\newcommand{\opteinsum}{\textsc{opt\_einsum}}
\newcommand{\qiskit}{\textsc{QisKit}}
\newcommand{\qiskitnature}{\textsc{QisKit-Nature}}
\newcommand{\pennylane}{\textsc{PennyLane}}
\newcommand{\tequilla}{\textsc{Tequilla}}
\newcommand{\mindquantum}{\textsc{MindQuantum}}
\newcommand{\qschem}{\textsc{Q$^2$ Chemistry}}
\newcommand{\qforte}{\textsc{QForte}}
\newcommand{\nex}{N_{\rm{ex}}}
\newcommand{\nshots}{N_{\rm{shots}}}


\newcommand{\jon}[1]{\textcolor{red}{#1}}
\newcommand{\jpm}[1]{\textcolor{blue}{#1}}
\newcommand{\wtli}[1]{\textcolor{cyan}{#1}}
\newcommand{\lc}[1]{\textcolor{purple}{#1}}

\makeatletter
\renewcommand \thesection{S\@arabic\c@section}
\renewcommand\thetable{S\@arabic\c@table}
\renewcommand \thefigure{S\@arabic\c@figure}
\renewcommand*{\thepage}{S\arabic{page} }
\makeatother

\title{Supplementary Materials for TenCirChem: An Efficient Quantum Computational Chemistry Package for the NISQ Era}

\author{Weitang Li}
\email{liw31@gmail.com}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}


\author{Jonathan Allcock}
%\email{jonallcock@tencent.com}
\affiliation{Tencent Quantum Lab, Hongkong, 999077, China}

\author{Lixue Cheng}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Shi-Xin Zhang}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Yu-Qin Chen}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Jonathan P. Mailoa}
\affiliation{Tencent Quantum Lab, Shenzhen, 518057, China}

\author{Zhigang Shuai}
\affiliation{Department of Chemistry, Tsinghua University, Beijing, 100084, China}
\alsoaffiliation{School of Science and Engineering, The Chinese University of Hong Kong, Shenzhen, 518172, China}

\author{Shengyu Zhang}
\email{shengyzhang@tencent.com}
\affiliation{Tencent Quantum Lab, Hongkong, 999077, China}


\begin{document}

\maketitle
%We don't need TOC here
%\tableofcontents

\section{Review of UCC ansatz}
We start with the general expression
\begin{equation}
\label{eq:ucc2}
    \ket{\Psi(\theta)}_{\text{UCC}} := \prod_{k=\nex{}}^1 e^{\theta_k G_k} \ket{\phi}. \
\end{equation}

\subsection{UCCSD}
For the most common case of single and double excitations, the $G_k$ has the form
\begin{equation}
\label{eq:g-single-double}
    G_k = \begin{cases}
        a^\dagger_p a_q - \text{h.c.} , \\
        a^\dagger_p a^\dagger_q a_r a_s - \text{h.c.}
        \end{cases}
\end{equation}

In this case, the disentangled UCC ansatz -- which is known as the UCCSD ansatz -- has the form
\begin{equation}
\label{eq:uccsd}
    \ket{\Psi(\theta)}_{\text{UCCSD}} := \prod_{pqrs}e^{\theta_{pqrs}(a^\dagger_p a^\dagger_q a_r a_s - \text{h.c.})}\prod_{pq}e^{\theta_{pq}(a_p^\dagger a_q - \text{h.c.})}\ket{\phi} \ .
\end{equation}
%In the remainder of this paper, we will refer to the first-order Trotterized version of the UCCSD ansatz as the the ``UCCSD ansatz".
If the number of spin-orbitals is $N$, then the number of gates in the corresponding circuit scales as $\order{N^4}$~\cite{o2019generalized}.
% if have time, explain the traditional approach in more detail, such as the scaling of the number of gates.

\subsection{$k$-UpCCGSD}
This is a variant of the UCC ansatz which satisfies both high accuracy and low ($\order{N^2}$) gate count requirements.~\cite{lee2018generalized}
Here ``G'', ``p'' and ``$k$'' stand for generalized excitation, paired double excitations, and repeating the ansatz $k$ times, respectively.
By pairing double excitations, the number of double excitations is reduced from $\order{N^4}$ to $\order{N^2}$.
More specifically, the ansatz has the form
\begin{equation}
\label{eq:kupccgsd}
    \ket{\Psi(\theta)}_{k\text{-UpCCGSD}} := \prod_{l=1}^k \prod_{pq}e^{\theta_{kpq}^{(2)}(a^\dagger_{p\alpha} a^\dagger_{p\beta} a_{q\beta} a_{q\alpha} - \text{h.c.})}\prod_{rs}e^{\theta_{krs}^{(1)}(a_r^\dagger a_s - \text{h.c.})}\ket{\phi} \ .
\end{equation}
Here $a^\dagger_{p\alpha} a^\dagger_{p\beta} a_{q\beta} a_{q\alpha}$ means spin-paired double excitations from the $q$-th spatial orbital to the $p$-th spatial orbital. 



\subsection{pUCCD}
This is an efficient ansatz requiring only $\order{N}$ circuit depth and half as many qubits as other UCC ans\"{a}tze~\cite{henderson2015pair, elfving2021simulating, o2022purification, zhao2022orbital}.
pUCCD allows only paired double excitations, 
which enables one qubit to represent one spatial orbital instead of one spin orbital,
and removes the need to perform the fermion-qubit mapping.
Thus, the $\order{N^2}$ excitations can be executed on a quantum computer efficiently using a compact circuit with a linear depth of Givens-SWAP gates~\cite{elfving2021simulating}.
The Hamiltonian also takes a simpler form in this case, with only $N^2$ terms:
\begin{equation}
    H = \sum_p h_p c^\dagger_p c_p + \sum_{pq} v_{pq} c^\dagger_p c_q + \sum_{p \neq q} w_{pq} c^\dagger_p c_p c^\dagger_q c_q + E_{\rm{nuc}} \ ,
\end{equation}
where $h_p = 2h_{pp}$, $v_{pq} = (pq|pq)$ and $\omega_{pq} = 2 (pp|qq) - (pq|pq)$.
Here $p$ and $q$ are indices for spatial orbitals.
A drawback of this ansatz is its compromised accuracy, which is comparable to the doubly occupied configuration interaction (DOCI) method \cite{weinhold1967reduced} in quantum chemistry.

\section{Conventions}
\label{sec:preliminary}
In this section, we introduce the conventions used in \tcc{}, particularly for static electronic structure problems. 

\bp{Excitations. }\tcc{} uses tuples to denote unitary fermionic excitations:
\begin{itemize}
    \item $(p,q)$: denotes single excitations $a_p^\dagger a_q- a_q^\dagger a_p$
    \item $(p,q,r,s)$:  denotes double excitations $a_p^\dagger a_q^\dagger a_r a_s - a_s^\dagger a_r^\dagger a_q a_p$
\end{itemize} 
Higher-order excitations are handled similarly. e.g., a $k$-th order excitation is represented by a tuple of length $2k$, with the first half corresponding to the excitation operators, and the second half corresponding to the annihilation operators, and Hermitian conjugation is implied, e.g., $(p,q,r,s,t,u)$ denotes $a_p^\dagger a_q^\dagger a_r^\dagger a_s a_t a_u - \text{h.c.}$


\bp{Spin-orbital indexing.} Spin orbitals are indexed from 0 and ordered according to the following rules:
\begin{itemize}
    \item Beta (down) spins first, followed by alpha (up) spins
    \item Low energy orbitals first, followed by high energy orbitals
\end{itemize}


\bp{Qubit indexing.} Qubits are numbered from 0, with multi-qubit registers numbered  with the zeroth qubit on the left, e.g. $\ket{0}_{q_0}\ket{1}_{q_2}\ket{0}_{q_2}$. Unless necessary, we will omit subscripts and use a more compact notation e.g.\ $\ket{010}$ to denote multi-qubit states.  In quantum circuit diagrams qubit numbers increase downwards, starting from qubit zero at the top. Throughout, we assume the Jordan-Wigner encoding where the occupancy of spin-orbital $i$  (using the above ordering) corresponds  to the state of qubit $N - 1 - i$ where $N$ is the total number of qubits.
In other words, the qubit ordering is reversed spin-orbitals ordering.

The conventions described above are summarized in Fig.~\ref{fig:excitations}, 
taking a 4-electron and 4-orbital system as an example.
Following the qubit indexing convention above, the restricted Hartree--Fock (HF) state for such a system is represented as 00110011 in bitstring form.
The highest orbital with $\alpha$-spin comes first in the bitstring, and the lowest orbital with $\beta$-spin comes last.
In quantum chemistry language, 00110011 refers to a configuration with orbitals 5, 4, 1, and 0 occupied,
while in quantum computing language, 00110011 refers to a direct product state
with the 2nd, 3rd, 6th, and 7th qubits in state $\ket{1}$ and the rest in state $\ket{0}$.
Upon application of the excitation operator (6, 2, 0, 4), the HF state transforms to 01100110.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.65\textwidth]{excitations.png}
\caption{An example of the conventions used for excitations, orbital indexing, and qubit indexing. The HF state of a 4 electron, 4 orbital system is represented as bitstring 00110011. The state is excited to 01100110 via the excitation operator (6, 2, 0, 4).}
    \label{fig:excitations}
\end{figure}

\section{\lstinline{print_summary} output}
In this section, we provide an overview of the output by the \lstinline{print_summary} command (see Code Snippet~\ref{lst:print_summary}).  This summary is divided into a number of blocks:

\begin{lstlisting}[caption={UCCSD ansatz applied to the \ce{H_2} molecule: output of the \lstinline{print_summary} command.}, label={lst:print_summary}]
################################ Ansatz ###############################
 #qubits  #params  #excitations initial condition
       4        2             3               RHF
############################### Circuit ###############################
 #qubits  #gates  #CNOT  #multicontrol  depth #FLOP
       4      15     10              1      9  2160
############################### Energy ################################
       energy (Hartree)  error (mH) correlation energy (%)
HF            -1.116706   20.568268                 -0.000
MP2           -1.129868    7.406850                 63.989
CCSD          -1.137275   -0.000165                100.001
UCCSD         -1.137274    0.000000                100.000
FCI           -1.137274    0.000000                100.000
############################# Excitations #############################
     excitation configuration     parameter  initial guess
0        (3, 2)          1001  1.082849e-16       0.000000
1        (1, 0)          0110  1.082849e-16       0.000000
2  (1, 3, 2, 0)          1010 -1.129866e-01      -0.072608
######################### Optimization Result #########################
            e: -1.1372744055294384
          fun: array(-1.13727441)
     hess_inv: <2x2 LbfgsInvHessProduct with dtype=float64>
   init_guess: [0.0, -0.07260814651571333]
          jac: array([-9.60813938e-19, -1.11022302e-16])
      message: 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
         nfev: 6
          nit: 4
         njev: 6
     opt_time: 0.02926015853881836
 staging_time: 4.5299530029296875e-06
       status: 0
      success: True
            x: array([ 1.08284918e-16, -1.12986561e-01])
\end{lstlisting}


\bp{Ansatz (lines 1-3).}  From here we see that the UCCSD ansatz is mapped (via the Jordan-Wigner transformation) to a variational quantum circuit on $4$ qubits, with two tunable parameters.  The circuit corresponds to $3$ excitation operators, which are detailed in the \lstinline{Excitations} block of the summary.  The fact that there are only two tunable parameters for three excitation operators is due to symmetry.

\bp{Circuit (lines 4-6).}  This block details the number of quantum gates that the Jordan-Wigner transformed ansatz is compiled to.  By default, \tcc{} uses the efficient circuit decomposition of \cite{yordanov2020efficient} for circuit compilation. 
The circuit depth is estimated using \qiskit{} and, as the running time of computing this estimate can be non-negligible for large circuits, the \lstinline{include_circuit=True} option
is by default False. 
The floating point operation count (FLOP) required to calculate the circuit statevector via tensor network contraction 
is estimated by the \opteinsum{} package \cite{daniel2018opt} using the default greedy contraction path-finding algorithm.

Note that, in the absence of noise, computing the output of the circuit does not require the circuit to first be decomposed explicitly into gates.  Instead, \tcc{} makes use of \textit{UCC factor expansion} (See Sec.~\ref{sec:ucc-theory}) to perform this computation more efficiently. However, if one wishes to simulate noisy quantum circuits -- corresponding, for instance, to realistic quantum hardware -- then an explicit gate decomposition is necessary. 

\bp{Energy (lines 7-13).}  This block includes the final UCCSD energy corresponding to the optimized parameter values, as well as other benchmark energies computed by \pyscf{} at Hartree--Fock, second-order Møller–Plesset perturbation theory (MP2), CCSD, and FCI levels of theory.  


\bp{Excitations (lines 14-18).}  This block gives further details on the ansatz, which takes the form
\begin{align*}
e^{\theta_2 G_2}  e^{\theta_1 G_1}  e^{\theta_0 G_0}\ket{\text{HF}},
\end{align*}
where $\theta_0$ is set to be equal to $\theta_1$ due to symmetry, and where
\begin{align*}
    G_0 &= a_2^\dagger a_3 - a_3^\dagger a_2, \\
    G_1 &= a_0^\dagger a_1 - a_1^\dagger a_0, \\
    G_2 &= a_0^\dagger a_2^\dagger a_3a_1 - a_1^\dagger a_3^\dagger a_2a_0.
\end{align*}
The convention for spin-orbital indices 
is described in Sec.~\ref{sec:preliminary}.
The minimum energy found corresponds to parameter values of $\theta_0 = \theta_1 = 1.05\times 10^{-16}$ and $\theta_2 = -1.13\times 10^{-1}$.  These final values were obtained from initial guesses of $0,0, -0.0726$ respectively, which correspond to the MP2 excitation amplitudes.  The configuration bitstrings obtained after applying each excitation to $\ket{\text{HF}}$ are also given here. 
Note that the Hermitian conjugation part of the excitation 
operator annihilates $\ket{\text{HF}}$ and thus has no effect.
For comparison, the configuration bitstring corresponding to the Hartree--Fock state is 0101.

\bp{Optimization Result (lines 19-33).}  This block gives details of the procedure used to optimize the ansatz parameters, including the number of iterations required (\lstinline{nit: 3}) as well as the final energy obtained for the UCCSD ansatz (\lstinline{e: -1.137...}). 


\section{The UCC classes: advanced features}
\subsection{User-specified UCC ans\"{a}tze}
UCCSD, $k$-UpCCGSD, and pUCCD are all special cases of UCC, where the excitations are restricted to take a certain form.  No setup is required for these three kinds of ansatz from users: once imported they can be used directly, e.g., via \lstinline{PUCCD(h2).kernel()}.


More general UCC ans\"{a}tze can be defined by directly specifying the corresponding excitations. 
This could be helpful, for instance, in investigating new quantum computational chemistry algorithms.  
% based on UCC, as was the case for the
% ADAPT-VQE algorithm which relies heavily on customized UCC ~\cite{grimsley2019adaptive}.
In Sec.~\ref{sec:adapt-vqe}, we will illustrate the power of this approach by implementing the ADAPT-VQE~\cite{grimsley2019adaptive} using \tcc{}, and we first provide a simpler example and implement the PUCCD ansatz from scratch (see Code Snippet~\ref{lst:custom_ucc}).
\begin{lstlisting}[language=Python, caption={Implementing the PUCCD ansatz from scratch by using a custom UCC ansatz.}, label={lst:custom_ucc}]
import numpy as np
from tencirchem import UCC, PUCCD
from tencirchem.molecule import h4

puccd = PUCCD(h4)
ucc = UCC(h4)

# only paired excitations are included
ucc.ex_ops = [
    (6, 2, 0, 4),
    (7, 3, 0, 4),
    (6, 2, 1, 5),
    (7, 3, 1, 5),
]

e1 = puccd.kernel()
# evaluate UCC energy using the PUCCD circuit parameter
e2 = ucc.energy(puccd.params)
# e1 is the same as e2
np.testing.assert_allclose(e1, e2, atol=1e-6)
\end{lstlisting}
Here, a \lstinline{UCC} class with only paired excitations is used to reproduce the \lstinline{PUCCD} class
for the \ce{H4} molecule.
The configuration is done by directly setting the \lstinline{ex_ops} attribute with tuples for the excitations.
\lstinline{param_ids} and \lstinline{initial_guess} can be set similarly 
and the full \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/example/custom_excitation.py}{Python script} is available online.
Although internally the \lstinline{UCC} class uses a quantum circuit of 8 qubits 
for simulation and the \lstinline{PUCCD} class uses only 4 qubits because of the restriction of paired excitations,
%\jon{(Comment) how can the user further set only 4 qubits to be used when using custom UCC?}
the corresponding energies with the same set of circuit parameters are exactly the same.
If custom UCC with paired excitation is desired, the \lstinline{UCC} class can be initialized with the \lstinline{hcb=True} argument.
For the index of the spin-orbitals and excitation operators, Fig.~\ref{fig:excitations} is a helpful reference.


\subsection{Active Space Approximation}
\label{sec:active-space}
As NISQ quantum hardware is limited in the number of qubits available, the active space approximation 
is frequently adopted to reduce the problem size~\cite{reiher2017elucidating, takeshita2020increasing, mizukami2020orbital, mccaskey2019quantum, o2022purification, huang2022variational}.
In many cases, inner shell molecular orbitals can be treated at the mean-field level without significant loss of accuracy, and this approximation is thus also sometimes dubbed the frozen core approximation.
Denote the set of frozen occupied spin-orbitals by $\Omega$.
The frozen core provides an effective repulsion potential $V^{\rm{eff}}$  to the remaining electrons
\begin{equation}
\label{eq:effective-pot}
    V^{\rm{eff}}_{pq} = \sum_{m \in \Omega} \left ( [mm|pq] - [mp|qm] \right).    \ 
\end{equation}
The frozen core also bears the mean-field core energy which effectively modifies
the core energy $E_{\rm{nuc}}$
\begin{equation}
    E_{\rm{core}} = E_{\rm{nuc}} + \sum_{m \in \Omega} h_{mm} + \frac{1}{2}\sum_{m, n \in \Omega} \left ( [mm|nn] - [mn|nm] \right ). \
\end{equation}
Thus, the \textit{ab initio} Hamiltonian is rewritten as
\begin{equation}
\label{eq:ham-abinit-as}
    H = \sum_{pq}(h_{pq} + V^{\rm{eff}}_{pq})a^\dagger_p a_q + \sum_{pqrs}h_{pqrs}a^\dagger_p a^\dagger_q a_r a_s + E_{\rm{core}},  \
\end{equation}
where $p$, $q$, $r$ and $s$ refer to spin-orbitals not included in $\Omega$.

%The following code performs a (2e, 2o) active space calculation of the \ce{H8} chain.
Making use of an active space approximation in \tcc{} is straightforward 
%\jon{(Comment) do we need to explain the (2e, 2o) notation?} \lc{I don't think we need to explain, it's just the common practice in chemistry}
: 
\begin{lstlisting}[language=Python, caption={UCCSD calculation of \ce{H8} with (2e, 2o) active space approximation. Note that the electron integrals in the active space are readily 
accessible via \lstinline{uccsd.int1e} and \lstinline{uccsd.int2e}.}]
from tencirchem import UCCSD
from tencirchem.molecule import h8
# (2e, 2o) active space
uccsd = UCCSD(h8, active_space=(2, 2))
uccsd.kernel()
uccsd.print_summary()
\end{lstlisting}

% \subsubsection{UCCSD-CASSCF}
% The complete active-space self-consistent field (CASSCF) method~\cite{roos1980complete}
% is one of the most common methods to treat multi-reference systems.
% CASSCF rotates the molecular orbitals in addition to solving the active space using the FCI kernel.
% In practice, the exponential scaling of the FCI kernel limits the size of the active space to systems with at most 16 electrons and 16 orbitals.
% In order to treat systems with strong correlations spreading over more than (16e, 16o),
% alternative solvers to FCI, such as density matrix renormalization group (DMRG)~\cite{ghosh2008orbital,nakatani2017density}, 
% and FCI quantum Monte Carlo (FCIQMC)~\cite{li2016combining} have been used to implement CASSCF in larger active spaces.
% Recently, orbital-optimized UCC and using UCCSD as a CASSCF solver have also been proposed~\cite{sokolov2020quantum, mizukami2020orbital, takeshita2020increasing}.
% The following code snippet shows how to carry out UCCSD-CASSCF calculation by interfacing \tcc{} with \pyscf{}~\cite{sun2017general}. 
% Each \lstinline{UCC} class can be transformed to a \pyscf{} FCI solver
% and the CASSCF algorithm implemented within the \pyscf{} package is then called 
% with the \lstinline{UCC} class as the kernel.
% Another example for orbital-optimized pUCCD calculation is available as a \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/example/oo_puccd.py}{Python script} online.

% \begin{lstlisting}[language=Python, caption={UCCSD-CASSCF calculation of \ce{H8} with (2e, 2o) active space.}]
% from pyscf.mcscf import CASSCF
% from tencirchem import UCCSD
% from tencirchem.molecule import h8
% # normal PySCF workflow
% hf = h8.HF()
% hf.kernel()
% casscf = CASSCF(hf, 2, 2)
% # set the FCI solver for CASSCF to be UCCSD
% casscf.fcisolver = UCCSD.as_pyscf_solver()
% casscf.kernel()
% \end{lstlisting}
% %\jon{(Comment) do we need to explain more what we mean by using uccsd as an fci solver for casscf? e.g. what equation is actually being solved? Or is this section aimed at people already familiar with what this is?}
% By interfacing with \pyscf{}, it is also straightforward to calculate nuclear gradients for the UCC ansatz,
% as demonstrated in the online \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/example/nuc_grad.py}{Python script}.


\subsection{Engines, Backends, and GPU}
Different engines can be specified by the \lstinline{engine} argument, e.g.,
\begin{lstlisting}[language=Python]
from tencirchem import UCCSD
from tencirchem.molecule import h4
uccsd = UCCSD(h4, engine="civector-large")
print(uccsd.kernel())
print(uccsd.energy(engine="tensornetwork"))
\end{lstlisting}
and, similar to \tc{}, computational backends can be switched at runtime as follows:
\begin{lstlisting}[language=Python]
from tencirchem import set_dtype, set_backend
set_dtype("complex64")
set_backend("cupy")
\end{lstlisting}
There are two ways to use GPUs with \tcc{}. The first is to set the backend to \lstinline{"cupy"}.
The second is to set the backend to \lstinline{"jax"} and make sure that CUDA support for \jax{} is \href{https://github.com/google/jax#installation}{properly configured}.


\subsection{Code Example: Implementing ADAPT-VQE}
\label{sec:adapt-vqe}

In this section, 
we illustrate how to use \tcc{} to build novel algorithms by implementing ADAPT-VQE~\cite{grimsley2019adaptive}.
The complete \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/adapt_vqe.ipynb}{Jupyter Notebook} tutorial is available online.
The first step of the algorithm is to construct an excitation operator pool, as shown below.
Here we use all of the single and double excitations as described in Eq.~\ref{eq:g-single-double}.
Operators with the same parameter are grouped together in the operator pool so as to prevent spin contamination.
\begin{lstlisting}[language=Python, caption=Construction of an operator pool for the ADAPT-VQE algorithm.]
from tencirchem import UCC
from tencirchem.molecule import h4

ucc = UCC(h4)

# get all single and double excitations
# param_id maps operators to parameters (some operators share the same parameter)
ex1_ops, ex1_param_ids, _ = ucc.get_ex1_ops()
ex2_ops, ex2_param_ids, _ = ucc.get_ex2_ops()

# group the operators to form an operator pool
from collections import defaultdict
op_pool = defaultdict(list)
for ex1_op, ex1_id in zip(ex1_ops, ex1_param_ids):
    op_pool[(1, ex1_id)].append(ex1_op)
for ex2_op, ex2_id in zip(ex2_ops, ex2_param_ids):
    op_pool[(2, ex2_id)].append(ex2_op)
op_pool = list(op_pool.values())
\end{lstlisting}

Once the operator pool is formed, ADAPT-VQE constructs the ansatz by selecting operators in the pool iteratively, with new operators chosen to maximize the absolute energy gradient.  That is, suppose the ansatz wavefunction at a certain point in the process is $\ket{\psi}$ and the operator selected is $G_k$, then
the new ansatz, defined to be
\begin{equation}
    \ket{\Psi} = e^{\theta_k G_k} \ket{\psi}, \
\end{equation}
has a corresponding energy gradient 
\begin{equation}
    \pdv{\braket{E}}{\theta_k} = 2 \braket{\Psi|HG_k|\Psi}. \
\end{equation}
ADAPT-VQE selects $G_k$ from the operator pool such that
\begin{equation}
    \pdv{\braket{E}}{\theta_k} \bigg{|}_{\theta_k=0} = 2 \braket{\psi|HG_k|\psi} 
\end{equation}
is maximized. If multiple operators sharing the same parameter are added at the same time,
then their gradients are added together. The iterative process by which the ansatz is constructed terminates when the norm of the gradient vector falls below a predefined threshold $\epsilon$.

In the following, $\ket{\psi}$ is obtained by \lstinline{ucc.civector()} as a vector in the configuration interaction space.
\lstinline{ucc.hamiltonian(psi)} applies $H$ onto $\ket{\psi}$ and
\lstinline{ucc.apply_excitation} applies $G_k$ onto $\ket{\psi}$.

\begin{lstlisting}[language=Python, caption={Implementation of the ADAPT-VQE iteration. The complete tutorial is available online as a  \fancylink{https://github.com/tencent-quantum-lab/TenCirChem/blob/master/docs/source/tutorial_jupyter/adapt_vqe.ipynb}{Jupyter Notebook}.}]
import numpy as np

ucc.ex_ops = []
ucc.params = []
ucc.param_ids = []

MAX_ITER = 100
EPSILON = 1e-3
for i in range(MAX_ITER):
    # calculate gradient of each operator from the pool
    op_gradient_list = []
    psi = ucc.civector()
    bra = ucc.hamiltonian(psi)
    for op_list in op_pool:
        grad = bra.conj() @ ucc.apply_excitation(psi, op_list[0])
        if len(op_list) == 2:
            grad += bra.conj() @ ucc.apply_excitation(psi, op_list[1])
        op_gradient_list.append(2 * grad)
    if np.linalg.norm(op_gradient_list) < EPSILON:
        break
    chosen_op_list = op_pool[np.argmax(np.abs(op_gradient_list))]
    # update ansatz and run calculation
    ucc.ex_ops.extend(chosen_op_list)
    ucc.params = list(ucc.params) + [0]
    ucc.param_ids.extend([len(ucc.params) - 1] * len(chosen_op_list))
    ucc.init_guess = ucc.params
    ucc.kernel()
\end{lstlisting}


\section{Efficient UCC circuit simulation algorithms}
We now introduce the algorithm behind efficient UCC circuit simulation that makes \tcc{} capable of accurately simulating deep UCC circuits with more than 32 qubits.
We will first introduce the UCC factor expansion technique,  which forms the backbone of the \lstinline{"civector"} engine. 
We then move on to an efficient algorithm to evaluate energy gradients with respect to circuit parameters and other implementation details.
\subsection{UCC factor expansion}
\label{sec:ucc-theory}
In this section, we introduce the UCC factor expansion technique used to achieve efficient simulations of UCC circuits in \tcc{}.
Benchmark results are included in the main text. 
We emphasize that the
techniques described in this section are specific for efficiently simulating an ideal circuit \textit{classically}, 
but are not applicable (without large overhead costs) for real hardware or noisy circuit simulations.

\subsubsection{Traditional approach.}
Recall that the general UCC ansatz can be written as $\ket{\Psi} = \prod_{k=\nex{}}^1 e^{\theta_k G_k} \ket{\phi}$.
To compile each UCC factor $e^{\theta_k G_k}$ into a quantum circuit, 
the traditional approach is to transform
$G_k$ (in the remainder of this section we will refer to $G_k$ simply as $G$) into commutable Pauli strings,
and then simulate each Pauli string via Hamiltonian evolution.
Another approach is the YAB method described in the main text, 
which relies on multi-qubit controlled rotations.
The \lstinline{"tensornetwork"} engine follows the YAB method to simulate the UCC circuit.

\subsubsection{Factor expansion approach.}
In the more efficient \lstinline{"civector"} engine, 
we use a different approach to classically simulate the UCC circuit, which involves expanding each UCC factor into a polynomial form, implementable only on a classical computer.
While this formalism has been published multiple times in a variety of contexts~\cite{chen2021quantum, kottmann2021feasible, rubin2021fermionic}, to the best of our knowledge, \tcc{} is the first package to use such a technique for large-scale UCC circuit simulation.

In the most general case, $G$ can be written as $G = g - g^\dagger$, with
\begin{equation}\label{eq:general-G}
    g^{i_1 \dots i_m}_{j_1 \dots j_m} = a^\dagger_{i_1} \cdots a^\dagger_{i_m} a_{j_1} \cdots a_{j_m}, \
\end{equation}
where $m$ is the order of the excitation.
$g^\dagger g$ is a projector onto the space that is not annihilated by $g$~\cite{rubin2021fermionic}:
\begin{equation}
    \left (g^{i_1 \dots i_m}_{j_1 \dots j_m} \right )^\dagger g^{i_1 \dots i_m}_{j_1 \dots j_m} = (1-n_{i_1}) \cdots (1 - n_{i_m}) n_{j_1} \cdots n_{j_m}, \
\end{equation}
where $n$ is the occupation number operator.
It follows that $g^\dagger g g^\dagger = g^\dagger$.
Using this equation, together with $gg = g^\dagger g^\dagger = 0$,
it is straightforward to show that $G$ has the property
\begin{equation}
    G^3 = g^\dagger - g = -G.
\end{equation}

The corresponding UCC factor can then be expanded as
\begin{equation}
\label{eq:expanding-ucc}
\begin{aligned}
    e^{\theta G} %& = \sum_{j=0} \frac{(\theta G)^j}{j!} \\
    & = 1 + \theta G + \frac{\theta^2 G^2}{2} - \frac{\theta^3 G}{3!} 
    - \frac{\theta^4 G^2}{4!} + \frac{\theta^5 G}{5!} + \cdots \\
    & = 1 + G^2 + \sum_{j=0} \frac{(-1)^j \theta^{2j+1}}{(2j+1)!} G  
    - \sum_{j=0} \frac{(-1)^j \theta^{2j}}{(2j)!} G^2  \\
    & = 1 + \sin{\theta}G + ( 1 - \cos{\theta} ) G^2 
\end{aligned}
\end{equation}
In the special case of $G^2=-I$, the famous formula $e^{\theta G}=\cos\theta + \sin\theta G$ is recovered.
Supposing $\ket{\psi}$ is any intermediate state during circuit execution,
multiplying  $\ket{\psi}$  with Eq.~\ref{eq:expanding-ucc} yields
\begin{equation}\label{eq:ucc-poly}
    e^{\theta G} \ket{\psi} = \ket{\psi} + \sin{\theta} G \ket{\psi} + ( 1 - \cos{\theta} ) G^2  \ket{\psi}.
\end{equation}
Thus, to evaluate $e^{\theta G} \ket{\psi}$ it is sufficient to evaluate  $ G \ket{\psi} $ and $ G^2 \ket{\psi} $.

The advantages of using Eq.~\ref{eq:ucc-poly} compared to the traditional approaches are twofold.
First, Eq.~\ref{eq:expanding-ucc} significantly saves on the number of matrix multiplications required to simulate $e^{\theta G} \ket{\psi}$.
Second, as both $G$ and $G^2$ conserve particle numbers in the up and down spin sectors,
{\tcc} is able to store $\ket{\psi}$ in the particle-number conserving space instead of the whole Fock space,
just as in the standard FCI calculation.
Thus, in the following, we use configuration interaction space 
to denote this particle-number conserving sector of the Fock space. 
In traditional UCC circuit simulations,  where each quantum gate is realized by matrix multiplication,
storing wavefunction in configuration interaction space
is not possible because a single $H$ gate or $X$ gate is able to destroy the particle number conserving property.

Representing the quantum state in configuration interaction space greatly reduces the memory requirements for UCC simulation.
A closed-shell molecule with $N$ spatial orbitals and $M$ electrons has Fock space of dimension $2^{2N}$.
In contrast, the number of possible configurations in each spin sector is $C^{N}_{M/2}$, and the dimension of its configuration interaction space is only $\left ( C^{N}_{M/2} \right)^2$ .
In addition, because $G$ and $\ket{\phi}$ are both real, $\ket{\psi}$ can be represented by real numbers rather than complex numbers in classical computers. 
In Table~\ref{tab:ci-memory}, we list the memory requirements to represent wavefunctions in configuration interaction spaces and Fock spaces for several values of $N$ and $M$.
While the required memory using configuration interaction space still scales exponentially, in practice the memory saving compared with using Fock space is significant, particularly so when $|N-M|$ is large.

\begin{table}[h]
\caption{\label{tab:ci-memory}
Memory requirements to represent system wavefunctions in configuration interaction space and Fock space.
In configuration interaction space each amplitude is stored by a 64-bit floating-point number
and in Fock space each amplitude is stored by a 128-bit complex number.
}
\begin{tabular}{ccrrrrc}
\hline
\multirow{2}{*}{$N$}  & \multirow{2}{*}{$M$} & \multicolumn{2}{c}{Configuration Interaction Space} & \multicolumn{2}{c}{Fock Space}     & \multirow{2}{*}{Memory Saving}    \\
                    &                    & \multicolumn{1}{c}{Dimension} & \multicolumn{1}{c}{Memory}  & \multicolumn{1}{c}{Dimension} & \multicolumn{1}{c}{Memory} & \\ 
                    \hline
2 & 2 & 4 & 32 B & 16 & 256 B & 8x \\
\multirow{2}{*}{4}  & 2    &   16    &   128 B & \multirow{2}{*}{256}  &  \multirow{2}{*}{4.1 kB} &  32x   \\
                    & 4    &   36     &   288 B   &        &    &   14x  \\ 
\multirow{2}{*}{8}  & 4    &   784    &   6.3 kB & \multirow{2}{*}{65,536}  &  \multirow{2}{*}{1.0 MB} &  167x   \\
                    & 8    &   4,900     &   39.2 kB   &        &    &   27x  \\ 
\multirow{2}{*}{16}  & 8    &   3,312,400 &   26.5 MB & \multirow{2}{*}{4,294,967,296}  &  \multirow{2}{*}{68.7 GB} &  2,593x   \\
                    & 16    &   165,636,900  &   1.3 GB   &        &    &   52x  \\ 
48 & 4 & 1,272,384 & 10.1 MB &$ 7.9 \times 10^{28}$ & 1.3 QB &  $1.2\times 10^{23}$x \\
\hline
\end{tabular}
\end{table}

\subsection{Gradients with respect to circuit parameters}
\label{sec:ucc-gradient}
\tcc{} uses an efficient algorithm to calculate the energy gradient with respect to the parameters~\cite{luo2020yao}.
The algorithm is applicable to the \lstinline{"civector"} engine, and for the \lstinline{"tensornetwork"} engine traditional auto-differentiation is implemented.
For $j=1,2,\ldots, N_{ex}$ define
\begin{equation}
    \ket{\psi_j} = \prod_{k=j}^1 e^{\theta_k G_k} \ket{\phi}, \
\end{equation}
and  $\ket{\psi'_j}$
\begin{equation}
    \langle \psi'_j |  = \langle \psi | \hat H \prod_{k=\nex}^{j} e^{\theta_k G_k}, \
\end{equation}
where $H$ is the system Hamiltonian.
The energy expectation value can be written as
\begin{equation}
    \langle E \rangle = \langle \psi'_{j+1} | \psi_j \rangle, \
\end{equation}
and the energy gradient as
\begin{equation}
\label{eq:grad-numerical}
        \frac{\partial \langle E \rangle}{\partial \theta_j} =
    2\langle \psi'_{j+1} |  G_j | \psi_j \rangle. \
\end{equation}

Once $| \psi \rangle$ is obtained, $\langle \psi^{(1)}_{\nex+1} |=\langle \psi | \hat H$
and $| \psi_{\nex} \rangle = |\psi \rangle$
are calculated. The remaining $\langle \psi'_j |$ and $| \psi_{j-1} \rangle$ are then obtained by the recurrence relation
\begin{equation}
    \begin{aligned}
    \langle \psi'_j | & = \langle \psi'_{j+1} | e^{\theta_j G_j}, \ \\
    | \psi_{j-1} \rangle & = e^{-\theta_{j} G_{j}}  | \psi_{j} \rangle, \
    \end{aligned}
\end{equation}
and, for each $\langle \psi'_{j} |$ and $| \psi_{j-1} \rangle$ pair,
$\frac{\partial \langle E \rangle}{\partial \theta_j}$ is evaluated by Eq.~\ref{eq:grad-numerical}.
This algorithm thus computes all gradients in one iteration over $j$, 
requiring only a constant amount of memory.

\subsection{Other techniques for efficient simulation}

With UCC factor expansion and efficient gradient computation, \tcc{} is able to simulate much larger molecular systems compared to traditional simulation packages. 
% In general, the computational cost is essentially at the same level as FCI calculations \jon{(Comment) any justification for this claim? Isn't FCI very expensive? If we don't beat FCI why not just use FCI?}.
\tcc{} also use several other techniques to accelerate calculations. In particular (i)
  initial values of $\theta_k$ are set to the corresponding $t_2$ amplitudes obtained by MP2, to enable faster convergence; (ii)
%For closed-shell molecules, configurations with spin-flip symmetry look, when ask also ask ci space
double excitation operators with $t_2$ very close to zero are screened out by default
because the excitation is likely prohibited by molecular point-group symmetry~\cite{cao2022progress}; (iii)
double excitation operators are also sorted by $t_2$ amplitudes 
to avoid ambiguous ans\"{a}tze~\cite{grimsley2019trotterized}.

\bibliography{refs}

\end{document}
