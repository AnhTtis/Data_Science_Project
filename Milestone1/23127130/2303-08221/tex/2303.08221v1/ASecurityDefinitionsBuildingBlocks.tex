
\section{Building Blocks}
\label{sec:securitydefinitionsbuildingblocks}

\subsection{Bilinear Maps}

Let $\Ga$, $\Gb$ and $\Gt$ be groups of prime order $\p$. A map $\e: \Ga \times \Gb \rightarrow \Gt$ must satisfy bilinearity, i.e., $\e(\ga^x,\gb^y)=e(\ga,\gb)^{xy}$; non-degeneracy, i.e., for all generators $\ga \in \Ga$ and $\gb \in \Gb$, $\e(\ga,\gb)$ generates $\Gt$; and efficiency, i.e., there exists an efficient algorithm $\BilinearSetup(1^\securityparameter)$ that outputs the pairing group setup $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb)$ and an efficient algorithm to compute $\e(a,b)$ for any $a \in \Ga$, $b \in \Gb$. In type 3 pairings, $\Ga \neq \Gb$ and there exists no efficiently computable homomorphism $f : \Gb \rightarrow \Ga$.

\subsection{Assumptions}
\label{subsec:bilinearMaps}

We recall the assumptions that are needed to prove the security of our schemes.

% \subsection{Bilinear Maps Assumptions}
% \begin{definition}\label{assump1}[Assumption 1~\cite{cryptoeprint:2022:011}]
% Let $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb)$ be a bilinear group setting of type 3, with $\ga$ (respectively $\gb$) a generator of $\Ga$ (respectively $\Gb$). Initialize $\sstate \gets \emptyset$. Let $H: \Ga \rightarrow \Ga$ be a random oracle that, on input $r \in \Ga$, if there is a tuple $(r,\h) \in \sstate$, outputs $h$, else picks up random $h \gets \Ga$ such that there is no entry $(\cdot,\h) \notin \sstate$ and stores $\sstate \gets \sstate \cup \{(r,h)\}$. For $(\ga^x, \ga^y)$ and $(\gb^x, \gb^y)$, where $x,y \in \Zp$ are random, we define the oracle $\mathcal{O}(m,r)$ that, on input $m\gets \Zp$ and $r \gets \Ga$, calls $\h \gets H(r)$ and outputs the pair $P = (\h, \allowbreak \h^{x+my})$. Given $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\ga^y,\gb^x, \gb^y)$ and unlimited access to the oracles $H$ and $\mathcal{O}$, no adversary can efficiently generate such a pair, with $\h \neq 1_{\Ga}$, for a new scalar $m^{\ast}$ not asked to $\mathcal{O}$.
% \end{definition}

% \begin{definition}\label{assump1}[Assumption 1~\cite{DBLP:conf/ctrsa/PointchevalS16}]
% Let $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb)$ be a bilinear group setting of type 3, with $\ga$ (respectively $\gb$) a generator of $\Ga$ (respectively $\Gb$). For $(\ga^x, \ga^y)$ and $(\gb^x, \gb^y)$, where $x,y \in \Zp$ are random, we define the oracle $\mathcal{O}(m)$ on input $m\gets \Zp$ that chooses a random $\h \in \Ga$ and outputs the pair $P = (\h, \h^{x+my})$. Given $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\ga^y,\gb^x, \gb^y)$ and unlimited access to this oracle, no adversary can efficiently generate such a pair, with $\h \neq 1_{\Ga}$, for a new scalar $m^{\ast}$ not asked to $\mathcal{O}$.
% \end{definition}

% \begin{definition}\label{assump2}[Assumption 2~\cite{cryptoeprint:2022:011}]
% Assumption 2 is a weaker version of Assumption 1. The only difference is that the adversary receives $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gb^x, \allowbreak \gb^y)$ instead of $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\ga^y,\gb^x, \allowbreak \gb^y)$.
% \end{definition}

% \begin{definition}\label{assump2}[Assumption 2~\cite{DBLP:conf/ctrsa/PointchevalS16}]
% Assumption 2 is a weaker version of Assumption 1. Let $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb)$ be a bilinear group setting of type 3, with $\ga$ (respectively $\gb$) a generator of $\Ga$ (respectively $\Gb$). For $(\gb^x, \gb^y)$, where $x,y \in \Zp$ are random, we define the oracle $\mathcal{O}(m)$ on input $m\gets \Zp$ that chooses a random $\h \in \Ga$ and outputs the pair $P = (\h, \h^{x+my})$. Given $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gb^x, \gb^y)$ and unlimited access to this oracle, no adversary can efficiently generate such a pair, with $\h \neq 1_{\Ga}$, for a new scalar $m^{\ast}$ not asked to $\mathcal{O}$.
% \end{definition}

\begin{definition}\label{xdh}[XDH and SXDH Assumptions ~\cite{DBLP:journals/iacr/BallardGMM05}]
Given $(\p, \allowbreak \Ga, \allowbreak \Gb,\allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb)$, the external Diffie-Hellman assumption states that the decisional Diffie-Hellman problem is intractable in $\Ga$ or in $\Gb$. The symmetric external Diffie-Hellman assumption states that it is intractable in both $\Ga$ and $\Gb$.
\end{definition}

\begin{definition}\label{sdh}[$q$-SDH Assumption~\cite{DBLP:journals/joc/BonehB08}]
Given $(\ga,\allowbreak\ga^{x},\allowbreak\ga^{x^2},\allowbreak\ldots,\allowbreak\ga^{x^q})\allowbreak \in \allowbreak \Ga^{q+1}$, the strong Diffie-Hellman assumption states that it is hard to output a pair $(m,\allowbreak \ga^{1/(x+m)})\in \Zp \times \Ga$.
\end{definition}

\begin{definition}\label{ddhi}[$y$-DDHI Assumption~\cite{DBLP:conf/eurocrypt/CamenischHL05}]
Let $\Ga$ be a group of prime order $q$ and let $\ga$ be a generator of $\Ga$. Given $(\ga, \allowbreak \ga^{x}, \ldots, \allowbreak \ga^{(x^y)}, \allowbreak R)$ for a random $x \gets \Zp$, the decisional Diffie-Hellman inversion assumption states that it is hard to decide if $R= \ga^{1/x}$ or not.
\end{definition}

\begin{definition}\label{bdhi}[$N$-BDHI Assumption~\cite{DBLP:journals/iacr/BonehB04a}]
Given $(\p,\allowbreak\Ga,\allowbreak\Gb,\allowbreak \Gt,\allowbreak\e,\allowbreak\ga,\allowbreak\gb)$ and the tuple $(\{\ga^{y^i}\}_{i=0}^{N},\{\gb^{y^i}\}_{i=0}^{N}) \in \Ga^{N+1} \times \Gb^{N+1}$, the bilinear Diffie-Hellman inversion assumption states that it is hard to compute $\e(\ga,\gb)^{1/y} \in \Gt$.
\end{definition}

\begin{definition}\label{mxdh}[$N$-MXDH' Assumption~\cite{DBLP:conf/pkc/PointchevalST17}]
$\forall N \in \mathbb{N^\ast}$, we define $C = N^3 - N^2$, $S = C + 1$, $E = N^2 - N$, $D = S + E$, and $P = D + C$. Given $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb)$ and $\{(\ga^{\gamma^k}, \allowbreak \h^{\gamma^k})_{k=0}^{P}, \allowbreak  (\ga^{\alpha \delta \gamma^{-k}}, \allowbreak  \h^{\alpha \delta \gamma^{-k}})_{k=0}^{E}, \allowbreak (\ga^{\chi \gamma^{k}}, \allowbreak \h^{\chi \gamma^{k}})_{k=D+1}^{P}, \allowbreak (\ga^{\alpha \gamma^{-k}}, \allowbreak \ga^{\chi \gamma^{k}/ \alpha}, \allowbreak \h^{\chi \gamma^{k}/ \alpha})_{k=0}^{C}\} \allowbreak \in \allowbreak \Ga^{2P+5S+2E+2}$, as well as $(\gb^{\gamma^{k}},\gb^{\alpha \gamma^{-k}})_{k=0}^{C} \in \Gb^{2S}$ and a pair $(\ga^{z_1},\h^{z_2}) \in \Ga^2$, it is hard to decide whether $z_1 = z_2 = \delta + \chi \gamma^{D}/\alpha$ or $(z_1, \allowbreak z_2)$ is random.

\end{definition}

\begin{definition}\label{dhe}[$n$-DHE~\cite{DBLP:conf/pkc/CamenischKS09}]
Let $(\p,\allowbreak\G,\allowbreak\Gb,\allowbreak \Gt,\allowbreak\e,\allowbreak\g,\allowbreak\gb) \allowbreak\leftarrow \allowbreak\BilinearSetup(1^k)$ and $\alpha \allowbreak\gets \allowbreak\Zp$. Given $(\p,\allowbreak\G,\allowbreak\Gb,\allowbreak \Gt,\allowbreak\e,\allowbreak\g,\allowbreak\gb)$ and a tuple $(\g_1,\allowbreak\gb_1,\allowbreak\ldots,\allowbreak\g_n,\allowbreak\gb_n,\allowbreak\g_{n+2},\allowbreak\ldots,\allowbreak\g_{2n})$ such that $\g_i \allowbreak = \allowbreak\g^{(\alpha^i)}$ and $\gb_i \allowbreak= \allowbreak \gb^{(\alpha^i)}$, for any p.p.t.\ adversary $\Adversary$, $\mathrm{Pr}[\g^{(\alpha^{n+1})} \allowbreak\leftarrow \allowbreak \Adversary(\p,\allowbreak\G,\allowbreak\Gb,\allowbreak \Gt,\allowbreak\e,\allowbreak \g,\allowbreak \gb,\allowbreak \g_1,\allowbreak\gb_1,\allowbreak\ldots,\allowbreak\g_n,\allowbreak\gb_n,\allowbreak\g_{n+2},\allowbreak\ldots,\allowbreak\g_{2n})] \allowbreak\leq \allowbreak \epsilon(k)$.
\end{definition}

\subsection{Zero-Knowledge Arguments of Knowledge}
\label{subsec:zkpk}

Informally speaking, a zero-knowledge argument of knowledge is a two-party protocol between a prover and a verifier with two properties. First, it should be a proof of knowledge, i.e., there should exist a knowledge extractor that extracts the secret input from a successful prover with all but negligible probability. Second, it should be zero-knowledge, i.e., for all possible verifiers there exists a simulator that, without knowledge of the secret input, yields a distribution that cannot be distinguished from the interaction with a real prover.

To express a zero-knowledge argument of knowledge, we follow the notation introduced by Camenisch and Stadler~\cite{camsta97a}, i.e., we denote as  $\ZKPK\{(w): y=f(w)\}$ a ``{\em zero-knowledge proof of knowledge of the secret input $w$ such that $y=f(w)$}'', where $w$ is a secret input, while $y$ and the function $f$ are publicly known.

Let $\mathcal{L}$ be a language in NP. We can associate to any NP-language $\mathcal{L}$ a polynomial time recognizable relation $\mathcal{R}_{\mathcal{L}}$ defining $\mathcal{L}$ as $\mathcal{L} = \{x: \exists w\ \mathrm{s.t.}\ (x,w) \in \mathcal{R}_{\mathcal{L}} \}$, where $|w| \leq \mathrm{poly}(|x|)$. The string $w$ is called a witness for membership of $x \in \mathcal{L}$.

A protocol $\Sigma = (\mathcal{P}, \mathcal{V})$ for an NP-language $\mathcal{L}$ is an interactive proof system. The prover $\mathcal{P}$ and the verifier $\mathcal{V}$ know an instance $x$ of the language $\mathcal{L}$. The prover $\mathcal{P}$ also knows a witness $w$ for membership of $x \in \mathcal{L}$. $\Sigma$-protocols have a 3-move shape where the first message $\alpha$, called \emph{commitment}, is sent by the prover. The second message $\beta$, called \emph{challenge}, is chosen randomly and sent by the verifier. The last message $\gamma$, called \emph{response}, is sent by the prover. A $\Sigma$-protocol fulfills the properties of completeness, honest-verifier zero-knowledge, and special soundness defined in Faust et al.~\cite{faust2012non}.

In our e-cash schemes, zero-knowledge arguments of knowledge based on the Fiat-Shamir transform~\cite{fiasha86} are used. The Fiat-Shamir transform removes the interaction between the prover $\mathcal{P}$ and the verifier $\mathcal{V}$ of a $\Sigma$ protocol by replacing the challenge with a hash value $H(\alpha,x)$  computed by the prover, where $H$ is modeled as a random oracle. (It is possible to include an additional message $m$ as input to $H$, i.e. $H(\alpha,x,m)$, turning the argument of knowledge into a \emph{signature of knowledge} of the message $m$.) An argument  $\pi$ consists of $(\alpha, H(\alpha,x), \gamma)$. The Fiat-Shamir system is denoted by $(\mathcal{P}^{H}, \mathcal{V}^{H})$ and fulfills the properties of zero-knowledge and weak simulation extractability defined in Faust et al.~\cite{faust2012non}, which we recall below.


% \subsection{Zero-Knowledge Arguments of Knowledge}
% \label{subsec:zkpksecurity}

% Informally speaking, a zero-knowledge argument of knowledge is a two-party protocol between a prover and a verifier with two properties. First, it should be a proof of knowledge, i.e., there should exist a knowledge extractor that extracts the secret input from a successful prover with all but negligible probability. Second, it should be zero-knowledge, i.e., for all possible verifiers there exists a simulator that, without knowledge of the secret input, yields a distribution that cannot be distinguished from the interaction with a real prover.

% To express a zero-knowledge argument of knowledge, we follow the notation introduced by Camenisch and Stadler~\cite{camsta97a}, i.e., we denote as  $\ZKPK\{(w): y=f(w)\}$ a ``{\em zero-knowledge proof of knowledge of the secret input $w$ such that $y=f(w)$}'', where $w$ is a secret input, while $y$ and the function $f$ are publicly known.

% Let $\mathcal{L}$ be a language in NP. We can associate to any NP-language $\mathcal{L}$ a polynomial time recognizable relation $\mathcal{R}_{\mathcal{L}}$ defining $\mathcal{L}$ as $\mathcal{L} = \{x: \exists w\ \mathrm{s.t.}\ (x,w) \in \mathcal{R}_{\mathcal{L}} \}$, where $|w| \leq \mathrm{poly}(|x|)$. The string $w$ is called a witness for membership of $x \in \mathcal{L}$.

% A protocol $\Sigma = (\mathcal{P}, \mathcal{V})$ for an NP-language $\mathcal{L}$ is an interactive proof system. The prover $\mathcal{P}$ and the verifier $\mathcal{V}$ know an instance $x$ of the language $\mathcal{L}$. The prover $\mathcal{P}$ also knows a witness $w$ for membership of $x \in \mathcal{L}$. $\Sigma$-protocols have a 3-move shape where the first message $\alpha$, called \emph{commitment}, is sent by the prover. The second message $\beta$, called \emph{challenge}, is chosen randomly and sent by the verifier. The last message $\gamma$, called \emph{response}, is sent by the prover. A $\Sigma$-protocol fulfills the properties of completeness, honest-verifier zero-knowledge, and special soundness defined in Faust et al.~\cite{faust2012non}.

% In our e-cash schemes, zero-knowledge arguments of knowledge based on the Fiat-Shamir transform~\cite{fiasha86} are used. The Fiat-Shamir transform removes the interaction between the prover $\mathcal{P}$ and the verifier $\mathcal{V}$ of a $\Sigma$ protocol by replacing the challenge with a hash value $H(\alpha,x)$  computed by the prover, where $H$ is modeled as a random oracle. (It is possible to include an additional message $m$ as input to $H$, i.e. $H(\alpha,x,m)$, turning the argument of knowledge into a \emph{signature of knowledge} of the message $m$.) An argument  $\pi$ consists of $(\alpha, H(\alpha,x), \gamma)$. The Fiat-Shamir system is denoted by $(\mathcal{P}^{H}, \mathcal{V}^{H})$ and fulfills the properties of zero-knowledge and weak simulation extractability defined in Faust et al.~\cite{faust2012non}, which we recall below.
%We recall the security defintions for non-interactive ZK arguments of knowledge in~\cite{faust2012non}.
\begin{definition}[Zero-Knowledge]\label{def:zero-knowledge}
Define the zero knowledge simulator $\mathcal{S}$ as follows. $\mathcal{S}$ is a stateful algorithm that can operate in two modes: $(h_i, st) \gets \mathcal{S}(1,st,q_i)$ answers random oracle queries $q_i$, while $(\pi, st) \gets \mathcal{S}(2,st,x)$ outputs a simulated proof $\pi$ for an instance $x$. $\mathcal{S}(1,\cdots)$ and $\mathcal{S}(2,\cdots)$ share the state $st$ that is updated after each operation.

Let $\mathcal{L}$ be a language in NP. Denote with $(\mathcal{S}_1, \mathcal{S}_2)$ the oracles such that $\mathcal{S}_1(q_i)$ returns the first output of $(h_i, st) \gets \mathcal{S}(1,st,q_i)$ and $\mathcal{S}_2(x,w)$ returns the first output of $(\pi, st) \gets \mathcal{S}(2,st,x)$ if $(x,w) \in \mathcal{R}_{\mathcal{L}}$. A protocol $(\mathcal{P}^{H}, \mathcal{V}^{H})$ is a non-interactive zero-knowledge proof for the language $\mathcal{L}$ in the random oracle model if there exists a ppt simulator $\mathcal{S}$ such that for all ppt distinguishers $\mathcal{D}$ we have
\begin{equation*}
\Prob[\mathcal{D}^{H(\cdot),\mathcal{P}^{H}(\cdot,\cdot)}(1^k) = 1] \approx \Prob[\mathcal{D}^{\mathcal{S}_1(\cdot),\mathcal{S}_2(\cdot,\cdot)}(1^k)=1],
\end{equation*}
where both $\mathcal{P}$ and $\mathcal{S}_2$ oracles output $\bot$ if $(x,w) \notin \mathcal{R}_{\mathcal{L}}$.

\end{definition}

\begin{definition}[Weak Simulation Extractability]\label{def:weakse}
Let $\mathcal{L}$ be a language in NP. Consider a non-interactive zero-knowledge proof system $(\mathcal{P}^{H}, \mathcal{V}^{H})$ for $\mathcal{L}$ with zero-knowledge simulator $\mathcal{S}$. Let $(\mathcal{S}_1,\mathcal{S}'_2)$ be oracles returning  the first output of $(h_i, st) \gets \mathcal{S}(1,st,q_i)$ and $(\pi, st) \gets \mathcal{S}(2,st,x)$ respectively. $(\mathcal{P}^{H}, \mathcal{V}^{H})$ is weakly simulation extractable  with extraction error $\nu$ and with respect to $\mathcal{S}$ in the random oracle model, if for all ppt adversaries $\Adversary$ there exists an efficient algorithm $\mathcal{E}_{\Adversary}$ with access to the answers $(\mathcal{T}_{H}, \mathcal{T})$ of $(\mathcal{S}_1,\mathcal{S}'_2)$ respectively such that the following holds. Let
\begin{align*}
& \mathrm{acc} = \Prob[(x^{\ast},\pi^{\ast}) \gets \Adversary^{\mathcal{S}_1(\cdot),\mathcal{S}'_2(\cdot)}(1^k;\rho): \\ & (x^{\ast},\pi^{\ast})\notin \mathcal{T}; \mathcal{V}^{\mathcal{S}_1}(x^{\ast},\pi^{\ast})=1] \\
& \mathrm{ext} = \Prob[(x^{\ast},\pi^{\ast}) \gets \Adversary^{\mathcal{S}_1(\cdot),\mathcal{S}'_2(\cdot)}(1^k;\rho); \\ & \indent w^{\ast} \gets \mathcal{E}_{\Adversary}(x^{\ast},\pi^{\ast};\rho,\mathcal{T}_H,\mathcal{T}): (x^{\ast},\pi^{\ast}) \notin \mathcal{T}; (x^{\ast},w^{\ast}) \in  \mathcal{R}_{\mathcal{L}}],
\end{align*}
where the probability space in both cases is over the random choices of $\mathcal{S}$ and the adversary's random tape $\rho$. Then, there exists a constant $d > 0$ and a polynomial $p$ such that whenever $\mathrm{acc} \geq \nu$, we have $\mathrm{ext} \geq (1/p)(\mathrm{acc}-\nu)^{d}$.
\end{definition}


\paragraph{Types of proofs.} We use known results for computing ZK proofs of discrete logarithms~\cite{camsta97a}. A protocol proving knowledge of exponents $(w_1, \allowbreak \ldots, \allowbreak w_n)$ that satisfy the formula  $\phi(w_1, \allowbreak \ldots, \allowbreak w_n)$ is described as
 \begin{equation}
\label{eq-knowsApp}
\ZKPK\{(w_1, \ldots, w_n): 1=\phi(w_1, \ldots, w_n)\} \end{equation}
The formula $\phi(w_1, \ldots,\allowbreak w_n)$ consists of conjunctions and disjunctions of ``atoms''. An atom expresses {\em  group relations}, such as
\begin{equation*}
    \prod_{j=1}^k g_j^{f_j}=1
\end{equation*}
where the $g_j$'s are elements of prime order groups and the $f_j$'s are polynomials in the variables $(w_1, \allowbreak \ldots, \allowbreak w_n)$.

A proof system for (\ref{eq-knowsApp}) can be transformed into a proof system for more expressive statements about secret exponents $\myvar{sexps}$ and secret bases $\myvar{sbases}$:
\begin{equation}
\label{eq-knows-secretApp}
\ZKPK\{(\myvar{sexps}, \myvar{sbases}): 1=\phi(\myvar{sexps}, \myvar{bases}\cup\myvar{sbases})\}
\end{equation}
The transformation adds an additional base $h$ to the public bases. For each $g_j \in \myvar{sbases}$, the transformation picks a random exponent $\rho_j$ and computes a blinded base $g_j'=g_j \h^{\rho_j}$. The transformation adds $g'_j$ to the public bases $\myvar{bases}$, $\rho_j$ to the secret exponents $\myvar{sexps}$, and rewrites $g_j^{f_j}$ into ${g_j'}^{f_j} h^{-f_j \rho_j}$.

The proof system supports pairing product equations
\begin{equation}
\prod_{j=1}^k e(g_j,\tilde{g}_j)^{f_j}=1
\end{equation}
in groups of prime order with a bilinear map $\e$, by treating the target group $\Gt$ as the group of the proof system. The embedding for secret bases is unchanged, except for the case in which both bases in a pairing are secret. In this case, $e(g_j,\tilde{g}_j)^{f_j}$ must be transformed into $e(g'_j,\tilde{g}'_j)^{f_j} e(g_j',\tilde{h})^{-f_j \tilde\rho_j} e(h,\tilde{g}'_j)^{-f_j \rho_j} \allowbreak e(h,\tilde{h})^{f_j \rho_j \tilde\rho_j}$.

\subsection{Commitment Schemes}
\label{subsec:commitmentSchemes}

A commitment scheme consists of algorithms $\ComSetup$, $\ComCommit$ and $\ComVerify$. The algorithm $\ComSetup(1^{\securityparameter})$ generates the parameters of the commitment scheme $\paramscom$, which include a description of the message space $\commessagespace$. $\ComCommit(\paramscom, \commessage)$ outputs a commitment $\com$ to $\commessage$ and auxiliary information $\open$. A commitment is opened by revealing $(\commessage, \allowbreak\open)$ and checking whether $\ComVerify(\paramscom,\com,\commessage,\open)$ outputs $1$ or $0$. 
% We recall the security properties of the commitment schemes in~\S\ref{subsec:commitmentSchemessecurity}.

A commitment scheme should fulfill the \emph{correctness}, \emph{hiding} and \emph{binding} properties. We recall the definitions of those properties below.

\begin{definition}[Correctness]
Correctness requires that $\ComVerify$ accepts all commitments created by algorithm $\ComCommit$, i.e., for all $\commessage \in \commessagespace$
\begin{equation*}
\Prob \left[
\begin{array}{c}
\paramscom \leftarrow \ComSetup(1^{\securityparameter});\
(\com, \open) \leftarrow \ComCommit(\paramscom, \commessage):\ \\
%\open \leftarrow \ComProve(\paramscom, \com, \commessage, \open):\ \\
1 = \ComVerify(\paramscom, \com, \commessage, \open)
\end{array}
\right] = 1~.
\end{equation*}
\end{definition}


\begin{definition}[Hiding Property]\label{def:hiding}
The hiding property ensures that a commitment $\com$ to $\commessage$ does not reveal any information about $\commessage$. For any ppt adversary $\Adversary$, the hiding property is defined as follows:
\begin{equation*}
\Prob \left[
\begin{array}{l}
\paramscom \leftarrow \ComSetup(1^{\securityparameter});\ \\
(\commessage_0, \commessage_1, \cstate) \leftarrow \Adversary(\paramscom);\ \\
\bit \leftarrow \{0,1\};\ (\com, \open) \leftarrow \ComCommit(\paramscom, \commessage_{\bit});\ \\
\bit' \leftarrow \Adversary(\cstate,\com):\ \\
\commessage_0 \in \commessagespace\ \land\ \commessage_1 \in \commessagespace\ \land\ \bit = \bit'
\end{array}
\right] \leq \frac{1}{2} + \negligible(\securityparameter)~.
\end{equation*}
\end{definition}

\begin{definition}[Binding Property]
The binding property ensures that $\com$ cannot be opened to another value $\commessage'$. For any ppt adversary $\Adversary$, the binding property is defined as follows:
\begin{equation*}
\Prob \left[
\begin{array}{l}
\paramscom \leftarrow \ComSetup(1^{\securityparameter});\\
(\com, \commessage, \open, \commessage', \open') \leftarrow \Adversary(\paramscom):\ \\
\commessage \in \commessagespace\ \land\ \commessage' \in \commessagespace\ \land \commessage \neq \commessage' \\ \land\ 1 = \ComVerify(\paramscom, \com, \commessage, \open)\  \\
\land\ 1 = \ComVerify(\paramscom, \com, \commessage', \open')
\end{array}
\right] \leq \negligible(\securityparameter)~.
\end{equation*}
\end{definition}

Our e-cash schemes use the commitment scheme by Pedersen~\cite{DBLP:conf/crypto/Pedersen91} to commit to elements $x \in \Zp$, where $p$ is a prime. This commitment scheme is perfectly hiding and computationally binding under the discrete logarithm assumption. The Pedersen commitment scheme consists of the following algorithms.
\begin{description}[leftmargin=0pt]

\item[$\bullet$ $\ComSetup(1^{k})$.] On input the security parameter $1^k$, pick random generators $\g,\h$ of a group $\Gp$ of prime order $\p$. Output $\paramscom = (g,h, \commessagespace)$, where $\commessagespace = \mathbb{Z}_{p}$.

\item[$\bullet$ $\ComCommit(\paramscom,x)$.] Check that $x \in \commessagespace$. Pick random value $\open \in \Zp$, compute $\com = \g^{\open} \h^{x}$, and output $\com$.

\item[$\bullet$ $\ComVerify(\paramscom,\com,x',\open')$.] Recompute $\com' = \g^{\open'} \h^{x'}$. If $\com \allowbreak = \allowbreak \com'$ then output $\accept$ else $\reject$.

\end{description}
%The Pedersen commitment scheme can be extended to allow the computation of commitments to more than one message, as shown in~\S\ref{subsec:commitmentSchemessecurity}.


% \subsection{Commitment Schemes}
% \label{subsec:commitmentSchemessecurity}


% A commitment scheme consists of algorithms $\ComSetup$, $\ComCommit$ and $\ComVerify$. The algorithm $\ComSetup(1^{\securityparameter})$ generates the parameters of the commitment scheme $\paramscom$, which include a description of the message space $\commessagespace$. $\ComCommit(\paramscom, \commessage)$ outputs a commitment $\com$ to $\commessage$ and auxiliary information $\open$. A commitment is opened by revealing $(\commessage, \allowbreak\open)$ and checking whether $\ComVerify(\paramscom,\com,\commessage,\open)$ outputs $1$ or $0$.
%We recall the security properties of the commitment schemes.



When committing to a tuple of messages, the Pedersen commitment scheme works as follows.
\begin{description}[leftmargin=0pt]

\item[$\bullet$ $\ComSetup(1^{\securityparameter},l)$.] On input the security parameter $1^\securityparameter$ and an upper bound $l$ on the number of elements to be committed, pick $l+1$ random generators $\h_1,\ldots,\h_l,\g$ of a group $\Gp$ of prime order $\p$. Output $\paramscom = (h_1,\ldots,h_l,g, \commessagespace)$, where $\commessagespace = \mathbb{Z}_{p}^{l}$.

\item[$\bullet$ $\ComCommit(\paramscom,\langle x_1,\ldots,x_l \rangle)$.] Pick random value $\open \gets \mathbb{Z}_{p}$, compute $\com = \g^{\open} \prod_{i = 1}^{l} \h_{i}^{x_i}$ and output $\com$.

\item[$\bullet$ $\ComVerify(\paramscom,\com,\langle x'_1,\ldots,x'_l \rangle,\open')$.] Recompute commitment $\com' = \g^{\open'} \prod_{i = 1}^{l} \h_{i}^{x'_i}$. If it is the case that $\com = \com'$ then output $\accept$ else $\reject$.

\end{description}



\subsection{Signature Schemes}
\label{subsec:signatureSchemes}

A signature scheme consists of the algorithms $\SKeygen$, $\SSign$, and $\SVerifySig$. $\SKeygen(1^\securityparameter)$ outputs a secret key $\ssk$ and a public key $\spk$, which include a description of the message space $\smessagespace$. $\SSign(\ssk, \smsg)$ outputs a signature $\ssig$ on message $\smsg \in \smessagespace$. $\SVerifySig(\spk,\ssig,\smsg)$ outputs $1$ if $\ssig$ is a valid signature on $\smsg$ and $0$ otherwise. This definition can be extended to blocks of messages $(\smsg_1, \ldots, \smsg_q)$. In this case, $\SKeygen(1^\securityparameter,q)$ receives the maximum number of messages as input. % A signature scheme must fulfill the correctness and existential unforgeability properties~\cite{DBLP:journals/siamcomp/GoldwasserMR88}.
%A signature scheme must fulfill the correctness and existential unforgeability properties~\cite{DBLP:journals/siamcomp/GoldwasserMR88}, which we define in~\S\ref{sec:sigsecurity}.
A signature scheme must fulfill the correctness and existential unforgeability properties~\cite{DBLP:journals/siamcomp/GoldwasserMR88}, which we recall below.
% We recall the definitions of correctness and existential unforgeability for signature schemes.
\begin{definition}[Correctness]
Correctness ensures that the algorithm $\SVerifySig$ accepts the signatures created by the algorithm $\SSign$ on input a secret key computed by algorithm  $\SKeygen$. More formally,  correctness is defined as follows.
\begin{equation*}
\Prob \left[
\begin{array}{l}
(\ssk, \spk)  \gets \SKeygen(1^\securityparameter);\
\smsg  \gets \smessagespace;\ \\
\ssig  \gets \SSign(\ssk, \smsg):\
1 = \SVerifySig(\spk, \ssig, \smsg)\
\end{array}
\right] = 1
\end{equation*}
\end{definition}

\begin{definition}[Existential Unforgeability]\label{def:unf}
The property of existential unforgeability  ensures that it is not feasible to output a signature on a message without knowledge of the secret key or of another signature on that message. Let $\SOracleSign$ be an oracle that, on input $\ssk$ and a message $\smsg \in \smessagespace$, outputs $\SSign(\ssk, \allowbreak \smsg)$, and let $\ssetsign$ be a set that contains the messages sent to $\SOracleSign$. More formally, for any ppt adversary $\Adversary$, existential unforgeability is defined as follows.
\begin{equation*}
\Prob \left[
\begin{array}{l}
(\ssk, \spk)  \gets \SKeygen(1^\securityparameter);\
(\smsg, \ssig)  \gets \Adversary(\spk)^{\SOracleSign(\ssk, \cdot)}:\ \\
1 = \SVerifySig(\spk, \ssig, \smsg)\ \land\ \smsg \in \smessagespace\ \land\ \smsg \notin \ssetsign\ \\
\end{array}
\right] \leq \epsilon(\securityparameter)
\end{equation*}
\end{definition}

\noindent \textbf{Pointcheval-Sanders (PS) signatures.}
The PS signature scheme is defined as follows~\cite{DBLP:conf/ctrsa/PointchevalS16}.
\begin{description}

\item[$\SKeygen(1^\securityparameter, q)$.] Run $\BilinearSetup(1^\securityparameter)$ to obtain a pairing group setup $\theta = (\p,\Ga,\Gb,\allowbreak \Gt,\e,\allowbreak \ga, \allowbreak \gb)$. Pick random secret key $(x, \allowbreak y_1, \ldots, \allowbreak y_q) \gets \mathbb{Z}_p^{q+1}$. Output the secret key $\ssk = (\theta, \allowbreak x, \allowbreak y_1, \allowbreak \ldots \allowbreak y_q)$ and the public key $\spk = (\theta, \tilde{\alpha}, \beta_1, \tilde{\beta}_1, \ldots, \beta_q, \tilde{\beta}_q) \gets (\theta, \allowbreak \gb^x, \allowbreak \ga^{y_1}, \allowbreak \gb^{y_1}, \allowbreak \ldots, \allowbreak \ga^{y_q}, \allowbreak \gb^{y_q})$.

\item[$\SSign(\ssk, \smsg_1, \ldots, \smsg_q)$.] Parse $\ssk$ as $(\theta, x, y_1, \ldots, y_q)$. Pick up random $r \gets \Zp$ and set $h \gets \ga^r$. Output the signature $\ssig = (h, s) \gets (h, h^{x+y_1\smsg_1+ \ldots +y_q\smsg_q})$.

\item[$\SVerifySig(\spk,\ssig, \smsg_1, \ldots, \smsg_q)$.] Output $1$ if $\e(h, \tilde{\alpha} \prod_{j=1}^{q} \tilde{\beta}_j^{\smsg_j}) \allowbreak = \allowbreak \e(s, \gb)$ and $h \neq 1$. Otherwise output $0$.

\end{description}
This signature scheme is randomizable. To randomize a signature $\ssig = (h, \allowbreak s)$, pick random $r' \gets \Zp$ and compute $\ssig' = (h^{r'}, s^{r'})$. The elements $(\beta_1, \allowbreak \ldots, \allowbreak \beta_q)$ in the public key are needed for the blind signature issuance protocol in~\cite{DBLP:conf/ctrsa/PointchevalS16}, as well as for the issuance protocols of Coconut and of our e-cash schemes. 




\noindent \textbf{Pointcheval-Sanders signatures in the random oracle model.} Coconut and our e-cash schemes use a variant of PS signatures in which, in algorithm $\SSign$, the random generator $h$ is computed via a hash function, which is modeled as a random oracle (RO). This variant has been formalized in~\cite{cryptoeprint:2022:011} as PS signatures in the RO model.


% Our e-cash schemes use a variant of the Pointcheval-Sanders signature scheme in the random oracle model, which is described in~\cite{cryptoeprint:2022:011} to analyze the security of Coconut.

In~\cite{cryptoeprint:2022:011}, the syntax of algorithm $\SSign$ is as follows. $\SSign$ uses a random oracle $H:\fromesspace \allowbreak \rightarrow \allowbreak \frolength$. $\SSign(\ssk, \allowbreak \smsg_1, \allowbreak \ldots \allowbreak \smsg_q, \allowbreak \sr, \allowbreak \sstate)$ receives as input a secret key $\ssk$, a tuple of messages $(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q)$, a value $\sr \allowbreak \in \allowbreak \fromesspace$ and state information $\sstate$, which stores tuples of the form $(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q, \allowbreak \sr)$. $\SSign$ outputs a signature $\ssig$ on $(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q)$ if $\sstate$ does not contain a tuple $(\smsg'_1, \allowbreak \ldots, \allowbreak \smsg'_q, \allowbreak \sr')$ such that $(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q) \neq (\smsg'_1, \allowbreak \ldots, \allowbreak \smsg'_q)$ and $\sr = \sr'$. $\SSign$ also outputs updated state information $\sstate'$.

The PS signature scheme in the RO model scheme works as follows. The algorithms $\SKeygen$ and $\SVerifySig$ remain unmodified.
\begin{description}%[leftmargin=10pt]

\item[$\SSign(\ssk, \smsg_1, \ldots, \smsg_q, \sr, \sstate)$.] Parse $\ssk$ as $(\theta, x, y_1, \ldots, y_q)$. If $\sstate$ contains a tuple $(\smsg'_1, \allowbreak \ldots, \allowbreak \smsg'_q, \allowbreak \sr')$ such that $(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q) \neq (\smsg'_1, \allowbreak \ldots, \allowbreak \smsg'_q)$ and $\sr = \sr'$, output $\ssig = \bot$ and $\sstate' =\sstate$. Otherwise compute $\h \gets H(\sr)$ and output the signature $\ssig = (h, s) \gets (h, h^{x+y_1\smsg_1+ \ldots +y_q\smsg_q})$ and the updated state information $\sstate' = \sstate \cup \{(\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q,\sr)\}$.

\end{description}
We recall the definition of the existential unforgeability property in the RO model below.
\begin{definition}[Existential Unforgeability in the RO~\cite{cryptoeprint:2022:011}]\label{def:unfro}
For any ppt adversary $\Adversary$, existential unforgeability in the RO model is defined as follows.
\begin{equation*}
\Prob \left[
\begin{array}{l}
(\ssk, \spk)  \gets \SKeygen(1^\securityparameter);\ \\
(\smsg, \ssig)  \gets \Adversary(\spk)^{\SOracleSign(\ssk, \cdot, \cdot), H(\cdot)}:\ \\
1 = \SVerifySig(\spk, \ssig, \smsg)\ \land\ \smsg \in \smessagespace\ \land\ \smsg \notin \ssetsign\ \\
\end{array}
\right] \leq \epsilon(\securityparameter)
\end{equation*}
$\SOracleSign(\ssk, \cdot, \cdot)$ works as follows. On input $\ssk$, a message $\smsg = (\smsg_1, \allowbreak \ldots, \allowbreak \smsg_q)$ and the value $\sr$, $\SOracleSign$ runs $(\ssig, \sstate') \gets \SSign(\ssk, \smsg_1, \ldots, \smsg_q, \sr, \sstate)$. $\SOracleSign$ replaces $\sstate$ by $\sstate'$ and returns $\ssig$ to $\Adversary$. ($\sstate$ is empty in the first invocation of $\SOracleSign$.) $\ssetsign$ is a set that contains the messages sent to $\SOracleSign$.
\end{definition}
In comparison to the definition of existential unforgeability (see Definition~\ref{def:unf}), $\Adversary$ has access to the random oracle $H$, and the signing oracle is modified to follow the new syntax. The PS scheme in the RO model is existentially unforgeable under the generalized PS assumption proposed in~\cite{DBLP:journals/istr/KimLAP21,DBLP:journals/iacr/KimSAP21}.


\noindent \textbf{Structure-Preserving Signature (SPS) scheme.} In a SPS scheme, the public key, the messages, and the signatures are group elements in $\Ga$ and $\Gb$, and verification must consist purely in the checking of pairing product equations. Our divisible e-cash scheme uses the SPS scheme in~\cite{DBLP:conf/crypto/AbeGHO11}. In this SPS scheme, $a$ elements in $\Ga$ and $b$ elements in $\Gb$ are signed.
\begin{description}[leftmargin=10pt]

\item[$\SKeygen(\grp,a,b)$.] Let $\grp \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \g, \allowbreak \gb)$ be the bilinear map parameters. Pick at random $u_1, \allowbreak \dots, \allowbreak u_b, \allowbreak y, \allowbreak w_1, \dots\allowbreak w_a, \allowbreak z \gets \Zp^*$ and compute $U_i  \allowbreak = \allowbreak g^{u_i}$, $i \allowbreak \in \allowbreak [1..b]$, $Y \allowbreak = \allowbreak \gb^y$, $W_i \allowbreak = \allowbreak \gb^{w_i}$, $i \allowbreak \in \allowbreak [1..a]$ and $Z \allowbreak = \allowbreak \gb^z$. Return the verification key $\spk \allowbreak \gets \allowbreak (\grp, \allowbreak U_1, \allowbreak \dots, \allowbreak U_b, \allowbreak Y, \allowbreak W_1, \allowbreak \dots, \allowbreak W_a,\allowbreak Z)$ and the signing key $\ssk \allowbreak \gets \allowbreak (\spk, \allowbreak u_1, \allowbreak \dots, \allowbreak u_b, \allowbreak y, \allowbreak w_1,\allowbreak \dots, \allowbreak w_a, \allowbreak z)$.

\item[$\SSign(\ssk,\langle m_1,\dots,m_{a+b} \rangle)$.] Pick $r \allowbreak \gets \allowbreak \Zp^*$, and set
\begin{align*}
    R \allowbreak \gets \allowbreak \g^r, \quad S \allowbreak \gets \allowbreak \g^{z-ry} \prod_{i=1}^a m_i^{-w_i}, \quad T \allowbreak \gets \allowbreak (\gb \prod_{i=1}^b  \allowbreak m_{a+i}^{-u_i})^{1/r},
\end{align*}
and output the signature $\ssig \gets (R, \allowbreak S, \allowbreak T)$.

\item[$\SVerifySig(\spk, \ssig,\langle m_1,\dots,m_{a+b} \rangle)$.] Output $\accept$ if it is satisfied that
\begin{equation*}
 \e(R,Y)\allowbreak \e(S,\gb)\prod_{i=1}^a \e(m_i,\allowbreak W_i) \allowbreak = \allowbreak \e(g, \allowbreak Z)
\end{equation*}
\noindent and
\begin{equation*}
\e(R,T) \prod_{i=1}^b \e(U_i,m_{a+i}) \allowbreak = \allowbreak \e(\ga, \allowbreak \gb)
\end{equation*}
\end{description}






% \subsection{Signature Schemes}
% \label{subsec:securitysignatures}





% \paragraph{Proving security under the original Pointcheval-Sanders scheme.} The Assumption 2 in~\cite{cryptoeprint:2022:011} is a variant in the RO model of the Assumption 2 in~\cite{DBLP:conf/ctrsa/PointchevalS16} used to prove security of the original Pointcheval-Sanders signature scheme in~\cite{DBLP:conf/ctrsa/PointchevalS16}. We remark that it is possible to modify our e-cash constructions (and Coconut) to reduce their security to the original Pointcheval-Sanders signature scheme. We will describe this modification, which adds an extra ZK argument of knowledge, in~\S\ref{sec:compactecash}.

% We also remark that Pointcheval and Sanders have proposed a variant of their scheme~\cite{DBLP:conf/ctrsa/PointchevalS18} that is secure under a more standard q-type assumption. This variant adds a random message to be signed. Our e-cash schemes can also be modified in that fashion to prove security under that assumption.

\subsection{Pseudorandom Functions}
\label{subsec:pseudorandomfunction}

Pseudorandom functions (PF)~\cite{DBLP:journals/jacm/GoldreichGM86,DBLP:conf/pkc/BoyleGI14} are a family of indexed
functions $F = \{F_s\}$ such that: (1) given the index $s$, $F_s$ can be efficiently evaluated on all inputs; (2) no
probabilistic polynomial-time algorithm without $s$ can distinguish evaluations $F_s(x_i)$ for inputs $x_i$ of its choice from random values. 
% We recall in \S\ref{subsec:pseudorandomfunctions} the definition in~\cite{DBLP:conf/pkc/BoyleGI14}.
We recall the definition of pseudorandom functions in~\cite{DBLP:conf/pkc/BoyleGI14}.
\begin{definition}[Pseudorandom Function Family]\label{def:pseudorandom}
A family of functions $\mathcal{F} = \{F_s\}_{s \in S}$, indexed by a set $S$, and where $F_s: D \rightarrow R$ for all $s$, is a pseudorandom function (PRF) family if for a randomly chosen $s$, and all PPT $\mathcal{A}$, the distinguishing advantage $\Pr_{s \leftarrow S}[\mathcal{A}^{f_s(\cdot)} \allowbreak = \allowbreak 1] \allowbreak - \Pr_{f\leftarrow(D\rightarrow R)}[\mathcal{A}^{f(\cdot)}=1]$ is negligible, where $(D \rightarrow R)$ denotes the set of all functions from $D$ to $R$.
\end{definition}

Our compact e-cash scheme uses the PF in~\cite{DBLP:conf/eurocrypt/CamenischHL05}, which works as follows. For every $n$, a function $f$ is defined by the tuple $(\Ga, \p, \ga, s)$, where $\Ga$ is a group of order $\p$, $\p$ is an $n$-bit prime, $\ga$ is a generator of $\Ga$, and $s$ is a seed in $\Zp$. For any input $x \in \Zp$ (except for $x = -1\ \mathrm{mod}\ \p$), the function $f_{\G,\p,\ga,s}(\cdot)$, which we denote as $f_{\ga,s}$ for fixed values of $(\Ga,\p,\ga)$, is defined as $f_{\ga,s}(x)=\ga^{1/(s+x+1)}$. This PF is secure under the $y$-DDHI assumption in $\Ga$, which we recall in \S\ref{subsec:bilinearMaps}. This PF is based on the verifiable random function in~\cite{DBLP:conf/pkc/DodisY05}, which is secure under the $y$-DBDHI assumption.

\subsection{Notation}
\label{subsec:notation}

In Table~\ref{tab:notation}, we summarize the notation used in our paper.
\begin{table}
    \centering
    \caption{Table of symbols}
    {\small
    \begin{tabular}{|l|l|} \hline
        \multicolumn{1}{|c|}{Symbol} & \multicolumn{1}{|c|}{Meaning}  \\ \hline
        \multicolumn{2}{|c|}{Bilinear Maps} \\ \hline
        $\e$ & Bilinear map \\
        $\BilinearSetup$ & Bilinear setup \\
        $\p$ & Prime number  \\ 
        $\Ga$ & Group of order $\p$   \\ 
        $\Gb$ & Group of order $\p$ \\ 
        $\Gt$ & Group of order $\p$ \\ 
        $\ga$ & Generator of $\Ga$  \\ 
        $\gb$ & Generator of $\Gb$  \\
        $\Zp$ & Integers modulo $\p$ \\ \hline
        \multicolumn{2}{|c|}{Security Definitions} \\ \hline
        $\Adversary$ & Adversary \\
        $\Environment$ & Environment \\
        $\Simulator$ & Simulator \\
        $\Functionality$ & Ideal Functionality \\
        $\pid$ & Party identifier \\
        $\sid$ & Session identifier \\
        $\qid$ & Query identifier \\ 
        $\Prob$ & Probability \\
        $\mathcal{O}$ & Oracle \\
        $\securityparameter$ & Security parameter \\
        $\negligible$ & Negligible function \\ \hline
        \multicolumn{2}{|c|}{E-cash} \\ \hline
        $\CEC$ & Threshold issuance offline anonymous e-cash \\ 
        $\fcecUser$ & User \\
        $\fcecProvider$ & Provider \\
        $\fcecAuthority$ & Authority \\
        $n$ & Number of authorities \\
        $t$ & Threshold \\
        $L$ & Number of coins in a full wallet \\
        $V$ & Number of coins spent in a payment \\
        $\cecparams$ & Parameters \\
        $\ssk_{\fcecAuthority}$ & Authority secret key \\
        $\spk_{\fcecAuthority}$ & Authority public key  \\
        $\ssk_{\fcecUser}$ & User secret key \\
        $\spk_{\fcecUser}$ & User public key \\
        $\cecrequest$ & Withdrawal request \\
        $\cecresponse$ & Withdrawal response \\
        $\cecwallet$ & Wallet \\
        $\cecpayment$ & Payment \\
        $\cecpaymentinfo$ & Payment information \\
        $\BB$ & Bulletin Board \\ \hline
    \end{tabular}
    \label{tab:notation}
}
% \vspace{-5mm}
\end{table}



% \subsection{Pseudorandom Functions}
% \label{subsec:pseudorandomfunctions}

% \subsection{Dynamic Accumulators}
% \label{subsec:accumulators}

% A dynamic accumulator consists of the following algorithms~\cite{DBLP:conf/pkc/CamenischKS09}:
% \begin{description}[leftmargin=10pt]

% \item[$\AccGen(1^\securityparameter, n)$.] On input the security parameter $1^\securityparameter$ and the size $n$ of the set of values that can be accumulated, output a key pair $(\accsk, \accpk)$, an empty accumulator value $\accval_{\emptyset}$ and an initial state $\accstate_{\emptyset}$.

% \item[$\AccAdd(\accsk, i, \accval_{V}, \accstate_{U})$.] On input the secret key $\accsk$, the value $i$, an accumulator value $\accval_{V}$ and the state $\accstate_{U}$, output a new accumulator value $\accval_{V\cup\{i\}}$ and a new state $\accstate_{U\cup\{i\}}$, together with a witness $\accwit_i$ for $i$. $U$ is the set of all elements ever added to the accumulator but not necessarily contained in the current accumulator.

% \item[$\AccUpdate(\accpk, V, \accstate_{U})$.] On input the public key $\accpk$, the set $V$ and the state $\accstate_{U}$, output an accumulator $\accval_{V}$ for values $V \subset U$.

% \item[$\AccWitUpdate(\accpk, \accwit_i, V_w, \accval_V, V, \accstate_{U})$.] On input the public key $\accpk$, a witness $\accwit_i$ for $i$, the set $V_w$ of accumulated values when the witness $\accwit_i$ was created, an accumulator value $\accval_V$, the set $V$, and state information $\accstate_{U}$, if $\accwit_i$ is a valid witness for $\accval_{V_w}$ and $i \allowbreak \in \allowbreak V$, output an updated witness $\accwit'_i$ for $i$ being accumulated in $\accval_V$.

% \item[$\AccVerify(\accpk, i, \accwit_i, \accval_V)$.] On input the public key $\accpk$, a value $i$, a witness $\accwit_i$, and an accumulator value $\accval_V$, output $1$ if $\accwit_i$ is a valid witness for $i$ being accumulated in $\accval_V$.

% \end{description}

% \noindent A secure accumulator should fulfill the following property~\cite{DBLP:conf/pkc/CamenischKS09}:
% \begin{equation*}
% \Prob \left[
% \begin{array}{l}
% (\accsk, \accpk, \accval_\mathcal{O}, \accstate_\mathcal{O})  \gets \AccGen(1^\securityparameter);\ \\
% (i, \accwit_i)  \gets \Adversary(\accpk,\accval_\mathcal{O}, \accstate_\mathcal{O})^{\AccOracleAdd(.), \AccOracleUpdate(.)}:\ \\
% 1 = \AccVerify(\accpk, i, \accwit_i, \accval_\mathcal{O})\ \land\ i \notin V_{\mathcal{O}}
% \end{array}
% \right] \leq \epsilon(\securityparameter)
% \end{equation*}
% The oracles $\AccOracleAdd(.)$ and $\AccOracleUpdate(.)$ keep track of shared variables $\accval_\mathcal{O}$, $\accstate_\mathcal{O}$ and a set $V_{\mathcal{O}}$ that is initialized to $\emptyset$. The oracle $\AccOracleAdd(i)$ outputs $(\accval_\mathcal{O}, \allowbreak \accstate_\mathcal{O}, \allowbreak \accwit_i) \allowbreak \gets \allowbreak \AccAdd(\accsk, \allowbreak i, \allowbreak \accval_{\mathcal{O}}, \allowbreak \accstate_{\mathcal{O}})$ and adds $i$ to $V_{\mathcal{O}}$. The oracle $\AccOracleUpdate(V)$ outputs $\accval_{\mathcal{O}} \allowbreak \gets \allowbreak \AccUpdate(\accpk, \allowbreak V, \allowbreak \accstate_{\mathcal{O}})$ and sets $V_{\mathcal{O}}$ to $V$.


% We recall the construction in~\cite{DBLP:conf/pkc/CamenischKS09}. We describe here a version of the construction that uses asymmetric pairings. 
% \begin{description}[leftmargin=10pt]


% \item[$\AccGen(1^{k},n)$.] Set groups $(\p,\G,\Gb,\allowbreak \Gt,\e,\g,\gb) \leftarrow \BilinearSetup(1^k)$,  pick $\alpha \gets \Zp$ and set $(\g_1,\allowbreak\gb_1,\allowbreak\ldots,\allowbreak\g_n,\gb_n,\allowbreak\g_{n+2},\ldots,\allowbreak\g_{2n})$, where $\g_i \allowbreak = \allowbreak \g^{(\alpha^i)}$ and $\gb_i \allowbreak = \allowbreak \gb^{(\alpha^i)}$. Generate a key pair $(\ssk, \spk)$ for an existentially unforgeable signature scheme. Output $\accpk \gets (\p,\G,\Gb,\allowbreak \Gt,\e,\g,\gb,\spk, z = \e(\ga,\gb)^{\alpha^{n+1}})$, $\accsk \gets (\p,\G,\Gb,\allowbreak \Gt,\allowbreak\e,\allowbreak\g,\allowbreak\gb,\allowbreak\alpha,\ssk)$, $\accval_{\emptyset} = 1$, and $\accstate_{\emptyset} \gets (\emptyset, \g_1,\allowbreak\gb_1,\allowbreak\ldots,\allowbreak\g_n,\gb_n,\allowbreak\g_{n+2},\ldots,\allowbreak\g_{2n})$.

% \item[$\AccAdd(\accsk, i, \accval_{V}, \accstate_{U})$.] Compute $w \gets \prod_{j \in V}^{j\neq i} \g_{n+1 - j + i}$. Compute a signature $\ssig_i$ on $\gb_i||i$ under the signing key $\accsk$. The algorithm outputs $\accwit_i \gets (w,\ssig_i,\gb_i)$, an updated accumulator value $\accval_{V\cup\{i\}} = \accval_{V} \cdot \g_{n+1-i}$, and $\accstate_{U\cup\{i\}} \gets (U\cup\{i\},\g_1,\allowbreak\gb_1,\allowbreak\ldots,\allowbreak\g_n,\gb_n,\allowbreak\g_{n+2},\ldots,\allowbreak\g_{2n})$.

% \item[$\AccUpdate(\accpk, V, \accstate_{U})$.] If $V \subset U$, output $\accval_V = \prod_{j \in V} \g_{n+1-j}$, else output $\bot$.

% \item[$\AccWitUpdate(\accpk, \accwit_i, V_w, \accval_V, V, \accstate_{U})$.] Parse $\accwit_i$ as $(w, \allowbreak \ssig_i, \allowbreak \gb_i)$. If $i \in V$ and $V \cup V_w \subset U$, compute
% \begin{equation*}
% w' = w \cdot \frac{\prod\limits_{j \in V \setminus V_w} g_{n+1-j+i}}{\prod\limits_{j \in V_w \setminus V} g_{n+1-j+i}}
% \end{equation*}
% Output the updated witness $\accwit'_i \gets (w', \allowbreak \ssig_i, \allowbreak \gb_i)$. Otherwise output $\bot$.

% \item[$\AccVerify(\accpk, i, \accwit_i, \accval_V)$.] Parse $\accwit_i$ as $(w, \allowbreak \ssig_i, \allowbreak \gb_i)$. Output $1$ if $\ssig_i$ is a valid signature on $\gb_i||i$ under public key $\spk$ and 
% \begin{equation*}
% z=\frac{\e(\accval_{V},\gb_i)}{\e(w,\g)}
% \end{equation*}
% Otherwise, output $0$.

% \end{description}
% This construction is secure under the $n$-DHE assumption (Definition~\ref{dhe}).