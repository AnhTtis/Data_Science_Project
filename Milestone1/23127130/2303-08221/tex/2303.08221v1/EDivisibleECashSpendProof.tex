
\section{Complete Description of the Divisible E-Cash Scheme}
\label{sec:divisibleEcashSpend}

The zero-knowledge argument of knowledge in algorithm $\cecSpend$ in~\S\ref{sec:divisibleecash} involves proving knowledge of secret bases. For this purpose, the transformation described in~\S\ref{subsec:zkpk} needs to be applied. In algorithm $\cecSetup$, the generators $\psi \allowbreak \in \allowbreak \Ga$ and $\tilde{\psi} \allowbreak \in \allowbreak \Gb$ are added. In algorithm $\cecSpend$, the secret bases are blinded, and the zero-knowledge argument is modified accordingly. We describe below the modified algorithms $\cecSetup$, $\cecSpend$ and $\cecSpendVf$. Moreover, we also describe the algorithms  $\cecKeyGenA$, $\cecKeyGenU$, $\cecRequest$, $\cecRequestVf$, $\cecWithdraw$, $\cecWithdrawVf$ and $\cecCreateWallet$, which were not depicted in~\S\ref{sec:divisibleecash}.

\begin{description}[leftmargin=*]

\item[$\cecSetup(1^{\securityparameter}, L)$.] Execute the following steps:

\begin{itemize}

    \item Run $\grp = (\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb) \gets \BilinearSetup(1^\securityparameter)$.

    \item Pick random generators $\eta, \allowbreak \gamma_1, \allowbreak \gamma_2, \psi \in \Ga$ and $\tilde{\psi} \in \Gb$.

    \item Generate random scalars $(z,y) \allowbreak \gets \allowbreak \Zp$ and, for $l \allowbreak \in \allowbreak [1,L]$, $a_l \gets \Zp$.

    \item Compute $(\varsigma, \theta) \gets (\ga^z, \eta^z)$.

    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $(\varsigma_l, \theta_l) \allowbreak \gets \allowbreak (\varsigma^{y^l}, \allowbreak \theta^{y^l})$.

    \item For $k \in [0,L-1]$, compute $\tilde{\delta}_k \gets \gb^{y^k}$.

    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $\eta_l \gets \ga^{a_l}$.

    \item For $l \allowbreak \in \allowbreak [1,L]$, for $k \allowbreak \in \allowbreak [0, \allowbreak l-1]$, compute $\tilde{\eta}_{l,k} \allowbreak \gets \allowbreak \gb^{-a_l \cdot y^k}$.

    \item Run the algorithm $(\spk_{sps}, \allowbreak \ssk_{sps}) \allowbreak \gets \allowbreak \SKeygen(\grp,\allowbreak 2,\allowbreak 0)$ of the structure-preserving signature scheme in~\S\ref{subsec:signatureSchemes}.

    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $\tau_l \gets \SSign(\ssk_{sps},\langle \varsigma_l, \theta_l \rangle)$.

    \item Set the parameters for users $\cecparams_u \gets (\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb, \allowbreak \eta, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \{\eta_l, \allowbreak \varsigma_l, \allowbreak \theta_l, \allowbreak \tau_l\}_{l=1}^L, \allowbreak \spk_{sps}, \allowbreak \psi, \allowbreak \tilde{\psi})$. Set the additional parameters for authorities $\cecparams_a \allowbreak \gets \allowbreak (\{\tilde{\delta}_k\}_{k=0}^{L-1}, \allowbreak \{\langle \tilde{\eta}_{l,k} \rangle_{k=0}^{l-1}\}_{l=1}^{L-1})$.

    \item Set the parameters $\cecparams \gets (\cecparams_u, \cecparams_a)$.

    \item Output $\cecparams$.

\end{itemize}

\item[$\cecKeyGenA(\cecparams_u, t, n)$.] Execute the following steps:
\begin{itemize}

    \item Choose $(1 + 2)$ polynomials $(v, w_1, w_2)$ of degree $(t - 1)$ with random coefficients in $\Zp$.

    \item Set $(x, y_1, y_2) \gets (v(0), w_1(0), w_2(0))$.

    \item For $i = 1$ to $n$, set the secret key $\ssk_{\fcecAuthority_i}$ of each authority $\fcecAuthority_i$ as $\ssk_{\fcecAuthority_i} \allowbreak = \allowbreak (x_i, \allowbreak y_{i,1}, \allowbreak y_{i,2}) \allowbreak \gets \allowbreak (v(i),\allowbreak w_1(i), \allowbreak w_2(i))$.

    \item For $i = 1$ to $n$, set the verification key $\spk_{\fcecAuthority_i}$ of each authority $\fcecAuthority_i$ as $\spk_{\fcecAuthority_i} \allowbreak = \allowbreak (\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1},  \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2}) \allowbreak \gets \allowbreak (\gb^{x_i}, \allowbreak \ga^{y_{i,1}}, \allowbreak \gb^{y_{i,1}},  \allowbreak \ga^{y_{i,2}}, \allowbreak \gb^{y_{i,2}})$.

    \item Compute the verification key $\spk = (\cecparams_u, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \allowbreak \beta_{2}, \tilde{\beta}_{2}) \allowbreak \gets \allowbreak (\cecparams_u, \allowbreak \gb^{x}, \allowbreak \ga^{y_{1}}, \allowbreak \gb^{y_{1}}, \allowbreak \ga^{y_{2}}, \allowbreak \gb^{y_{2}})$.

    \item Output $(\spk, \langle \spk_{\fcecAuthority_i}, \ssk_{\fcecAuthority_i} \rangle_{i =1}^{n})$.

\end{itemize}

\item[$\cecKeyGenU(\cecparams_u)$.] Execute the following steps:
\begin{itemize}

    \item Pick random $\ssk_{\fcecUser_j} \gets \Zp$ and compute $\spk_{\fcecUser_j} \gets \ga^{\ssk_{\fcecUser_j}}$.

    \item Output $(\ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$.

\end{itemize}

\item[$\cecRequest(\cecparams_u, \ssk_{\fcecUser_j})$.] Execute the following steps:

\begin{itemize}

    \item Pick random $\cecsn \gets \Zp$ and set $(\cecmes_{1}, \allowbreak \cecmes_{2}) \allowbreak = (\ssk_{\fcecUser_j}, \allowbreak \cecsn)$.

    \item Pick random $o \gets \Zp$ and compute  $\com = \ga^{o} \prod_{j=1}^{2} \gamma_j^{\cecmes_{j}}$.

    \item Compute $\h \gets H(\com)$, where $H$ is modeled as a random oracle.

    \item Compute commitments to each of the messages. For $j = 1$ to $2$, pick random $o_{j} \gets \Zp$ and set $\com_{j} = \ga^{o_{j}} \h^{\cecmes_{j}}$.

    \item Compute a ZK argument of knowledge $\pi_s$ via the Fiat-Shamir heuristic for the following relation:
    \begin{align*}
        \pi_s =  & \NIZK\{(\cecmes_{1}, \cecmes_{2}, o, o_{1}, o_{2}): \\ &
        \com = \ga^{o} \prod_{j=1}^{2} \gamma_j^{\cecmes_{j}}\ \land\  \spk_{\fcecUser_j} \gets \ga^{\cecmes_{1}} \land\ \\ &
        \{\com_{j}= \ga^{o_{j}} \h^{\cecmes_{j}} \}_{\forall j \in [1,2]}  \}
    \end{align*}

    \item Set $\cecrequestinfo \allowbreak \gets \allowbreak (\h, \allowbreak o_{1}, \allowbreak o_{2}, \allowbreak \cecsn)$.

    \item Set $\cecrequest \allowbreak \gets \allowbreak (\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$.

    \item Output $\cecrequest$ and $\cecrequestinfo$.

\end{itemize}

\item[$\cecRequestVf(\cecparams_u, \cecrequest, \spk_{\fcecUser_j})$.] Execute the following steps:
\begin{itemize}

    \item Parse $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$.

    \item Compute $\h' \gets H(\com)$, where $H$ is modeled as a random oracle. Output $0$ if $\h \neq \h'$.

    \item Verify $\pi_s$ by using the tuple $(\cecparams_u, \allowbreak \h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2})$. Output $0$ if the proof $\pi_s$ is not correct, else output $1$.

\end{itemize}

\item[$\cecWithdraw(\cecparams_u, \ssk_{\fcecAuthority_i}, \cecrequest)$.] Execute the following steps:
\begin{itemize}

    \item Parse $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$.

    \item Parse $\ssk_{\fcecAuthority_i}$ as $(x_i, \allowbreak y_{i,1}, \allowbreak y_{i,2})$.

    \item Compute $c = \h^{x_i} \prod_{j=1}^{2} \com_j^{y_{i,j}}$.

    \item Set the blinded signature share $\hat{\sigma}_{i} \allowbreak \gets \allowbreak (\h, \allowbreak c)$.

    \item Output $\cecresponse \gets \hat{\sigma}_{i}$.

\end{itemize}

\item[$\cecWithdrawVf(\cecparams_u, \spk_{\fcecAuthority_i}, \ssk_{\fcecUser_j}, \cecresponse, \cecrequestinfo)$.] Execute the following steps:

\begin{itemize}

    \item Parse $\cecrequestinfo$ as $(\h', \allowbreak o_{1},  \allowbreak o_{2}, \allowbreak \cecsn)$.

    \item Parse $\cecresponse$ as $\hat{\sigma}_{i} \allowbreak = \allowbreak (\h, \allowbreak c)$. Output $0$ if $\h \allowbreak \neq \allowbreak \h'$.

    \item Parse $\spk_{\fcecAuthority_i}$ as $(\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1}, \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2})$.

    \item Compute $\sigma_{i} \allowbreak = \allowbreak (\h, \allowbreak s) \allowbreak \gets \allowbreak (\h, \allowbreak c \prod_{j=1}^{2} \beta_{i,j}^{-o_{j}})$.

    \item Set $(\cecmes_{1}, \cecmes_{2}) = (\ssk_{\fcecUser_j}, \cecsn)$. Output $0$ if $\e(\h, \tilde{\alpha}_i \prod_{j=1}^{2} \tilde{\beta}_{i,j}^{\cecmes_{j}}) = \e(s, \gb)$ does not hold.

    \item Output $\cecwallet_i \gets (i,\sigma_{i},\cecsn)$.

\end{itemize}


\item[$\cecCreateWallet(\spk, \ssk_{\fcecUser_j}, \cecset, \langle \cecwallet_i \rangle_{i \in \cecset})$.] Execute the following steps:
\begin{itemize}

    \item If $|\cecset| \neq t$, output $0$.

    \item For all $i \in \cecset$, evaluate at 0 the Lagrange basis polynomials
    \begin{equation*}
        l_i = [\prod_{j \in \cecset,j\neq i} (0-j)] [\prod_{j\in\cecset,j\neq i} (i-j)]^{-1}\ \mathrm{mod}\ \p
    \end{equation*}

    \item For all $i \in \cecset$, parse $\cecwallet_{i}$ as  $(i,\sigma_{i},\cecsn)$ and $\sigma_{i}$ as $(\h, \allowbreak s_i)$.

    \item Compute the signature $\sigma = (\h, s) \gets (\h, \allowbreak \prod_{i \in \cecset} s_{i}^{l_i})$.

    \item Parse $\spk$ as $(\cecparams_u, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Set $(\cecmes_{1}, \allowbreak \cecmes_{2}) \allowbreak = \allowbreak (\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ and output $0$ if $\e(\h, \tilde{\alpha} \prod_{j=1}^{2} \tilde{\beta}_j^{\cecmes_{j}}) = \e(s, \gb)$ does not hold, else output $\cecwallet \allowbreak \gets \allowbreak (\sigma, \allowbreak \cecsn, l)$, where $l$ is a counter from $1$ to $L$ initialized to $1$.

\end{itemize}




\item[$\cecSpend(\spk, \ssk_{\fcecUser_j}, \cecwallet, \cecpaymentinfo, V)$.] Execute the following steps:

\begin{itemize}

    \item Parse $\cecwallet$ as $(\sigma, \allowbreak \cecsn, \allowbreak l)$. If $l+V \geq L$, output $0$.

    \item Parse $\sigma$ as $(\h, \allowbreak s)$.

    \item Parse $\spk$ as $(\cecparams_u, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Pick random scalars $r \gets \Zp$ and $r' \gets \Zp$.

    \item Compute $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$.

    \item Compute $\kappa \gets \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn}  \gb^{r}$.

    \item Pick random scalars $r_1,r_2 \gets \Zp$.

    \item Compute $\phi_{V,l} = (\phi_{V,l}[1],\phi_{V,l}[2]) \gets (\ga^{r_1}, \varsigma_l^\cecsn \eta_{V}^{r_1})$.

    \item Set $R \gets H(\cecpaymentinfo)$, where $H$ is a collision-resistant hash function, and set $\varphi_{V,l} = (\varphi_{V,l}[1],\varphi_{V,l}[2]) \gets (\ga^{r_2}, (\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn} \eta_{V}^{r_2})$.

    \item Take $\cecparams_u$ from $\spk$. Take the public key $\spk_{sps} \allowbreak = \allowbreak (Y, \allowbreak W_1, \allowbreak W_2, \allowbreak Z)$ and the signature $\tau_{l+V-1} \allowbreak = \allowbreak (R_{l+V-1}, \allowbreak S_{l+V-1}, \allowbreak T_{l+V-1})$.

    \item Pick random $(\rho_{\varsigma_l}, \rho_{\theta_l}, \rho_{\varsigma_{l+V-1}}, \rho_{\theta_{l+V-1}}, \rho_{R_{l+V-1}}, \rho_{S_{l+V-1}}, \rho_{T_{l+V-1}}) \allowbreak \gets \allowbreak \Zp$.

    \item Compute the blinded bases $\varsigma'_l \allowbreak \gets \allowbreak  \varsigma_l \psi^{\rho_{\varsigma_l}}$, $\theta'_l \allowbreak \gets \allowbreak  \theta_l \psi^{\rho_{\theta_l}}$, $\varsigma'_{l+V-1} \allowbreak \gets \allowbreak \varsigma_{l+V-1}  \psi^{\rho_{\varsigma_{l+V-1}}}$ and $\theta'_{l+V-1} \allowbreak \gets \allowbreak \theta_{l+V-1}  \psi^{\rho_{\theta_{l+V-1}}}$, and the blinded bases for the signature $R'_{l+V-1} \allowbreak \gets \allowbreak R_{l+V-1}  \psi^{\rho_{R_{l+V-1}}}$, $S'_{l+V-1} \allowbreak \gets \allowbreak S_{l+V-1}  \psi^{\rho_{S_{l+V-1}}}$ and $T'_{l+V-1} \allowbreak \gets \allowbreak T_{l+V-1}  \tilde{\psi}^{\rho_{T_{l+V-1}}}$.

    \item Compute $\rho_1 \gets -\cecsn \rho_{\varsigma_l}$, $\rho_2 \gets -\cecsn \rho_{\theta_l}$ and $\rho_3 \gets \rho_{R_{l+V-1}}\rho_{T_{l+V-1}}$.

    \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
    \begin{align}
        \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, r_1, r_2, \rho_{\varsigma_l}, \rho_{\theta_l}, \rho_{\varsigma_{l+V-1}}, \rho_{\theta_{l+V-1}}, \nonumber \\ & \rho_{R_{l+V-1}}, \rho_{S_{l+V-1}},  \rho_{T_{l+V-1}}, \rho_1, \rho_2, \rho_3): \nonumber \\ &
        \kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\ \label{equ1}\\&
        \phi_{V,l}[1] = \ga^{r_1}\ \land\ \phi_{V,l}[2] = (\varsigma'_l)^{\cecsn} \psi^{\rho_1} \eta_{V}^{r_1}\ \land\ \label{equ2} \\&
        \varphi_{V,l}[1] = \ga^{r_2}\ \land\ \varphi_{V,l}[2] = (\ga^R)^{\ssk_{\fcecUser_j}} (\theta'_l)^{\cecsn} \psi^{\rho_2} \eta_{V}^{r_2}\ \land\ \label{equ3} \\&
        \e(\varsigma'_l, \tilde{\delta}_{V-1})  \e(\psi, \tilde{\delta}_{V-1})^{-\rho_{\varsigma_l}} = \e(\varsigma'_{l+V-1},\tilde{g}) \e(\psi,\tilde{g})^{-\rho_{\varsigma_{l+V-1}}}\ \land\ \label{equ4}\\& \e(\theta'_l, \tilde{\delta}_{V-1}) \e(\psi, \tilde{\delta}_{V-1})^{-\rho_{\theta_l}} = \e(\theta'_{l+V-1}, \tilde{g}) \e(\psi,\tilde{g})^{-\rho_{\theta_{l+V-1}}}\ \land\ \label{equ5} \\&
        \e(R'_{l+V-1},Y) \e(\psi,Y)^{-\rho_{R_{l+V-1}}} \e(S'_{l+V-1}, \gb) \e(\psi,\gb)^{-\rho_{S_{l+V-1}}} \cdot \nonumber \\& e(\varsigma'_{l+V-1}, W_1)  e(\psi, W_1)^{-\rho_{\varsigma_{l+V-1}}} e(\theta'_{l+V-1}, W_2) e(\psi, W_2)^{-\rho_{\theta_{l+V-1}}} \cdot \nonumber \\& \e(\ga, Z)^{-1} =1\ \land \label{equ6} \\&
        \e(R'_{l+V-1},T'_{l+V-1}) \e(R'_{l+V-1},\tilde{\psi})^{-\rho_{T_{l+V-1}}} \cdot \nonumber \\& \e(\psi,T'_{l+V-1})^{-\rho_{R_{l+V-1}}} \e(\psi,\tilde{\psi})^{\rho_3} \e(\ga, \gb)^{-1} =1 \label{equ7}
    \end{align}
     Equation~\ref{equ1} is part of the proof of possession of the wallet signature that signs $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Equation~\ref{equ2} and \ref{equ3} prove that $\phi_{V,l}$ and the security tag $\varphi_{V,l}$ are well-formed and are computed on input $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Equation~\ref{equ4}, \ref{equ5}, \ref{equ6} and \ref{equ7}  prove that the values $\varsigma_l$ and $\theta_l$, which were used to compute  $\phi_{V,l}$ and $\varphi_{V,l}$ respectively, are part of the public parameters and fulfill $l \leq L-V+1$. This is accomplished by proving possession of a signature on $\varsigma_{l+V-1}$ and $\theta_{l+V-1}$ in equations~\ref{equ6} and \ref{equ7}, and proving that the indices of $\varsigma_{l+V-1}$ and $\theta_{l+V-1}$ and $\varsigma_l$ and $\theta_l$ are related by a difference of $V-1$ is equation~\ref{equ4} and \ref{equ5} respectively. This non-interactive argument signs the payment information $\cecpaymentinfo$.

    \item Output a payment $\cecpayment \gets (\kappa, \sigma', \phi_{V,l}, \varphi_{V,l}, \allowbreak \varsigma'_l, \allowbreak \theta'_l, \allowbreak \varsigma'_{l+V-1}, \allowbreak \theta'_{l+V-1}, \allowbreak R'_{l+V-1}, \allowbreak S'_{l+V-1}, \allowbreak T'_{l+V-1}, \allowbreak R, \allowbreak \pi_v, \allowbreak V)$ and an updated wallet $\cecwallet' \gets (\sigma, \allowbreak \cecsn, \allowbreak l+V)$.

\end{itemize}

\item[$\cecSpendVf(\spk, \cecpayment, \cecpaymentinfo)$.] Execute the following steps:

\begin{itemize}

    \item Parse $\cecpayment$ as $(\kappa, \sigma', \phi_{V,l}, \varphi_{V,l}, \varsigma'_l, \allowbreak \theta'_l, \allowbreak \varsigma'_{l+V-1}, \allowbreak \theta'_{l+V-1}, \allowbreak R'_{l+V-1}, \allowbreak S'_{l+V-1}, \allowbreak T'_{l+V-1}, \allowbreak R, \allowbreak \pi_v, \allowbreak V)$.

    \item Parse $\sigma'$ as $(\h', \allowbreak s')$ and output $0$ if $\h' = 1$ or if $\e(\h', \kappa) \allowbreak = \allowbreak \e(s',\gb)$ does not hold.

    \item Output $0$ if $R \neq H(\cecpaymentinfo)$ or if $\cecpaymentinfo$ does not contain the identifier of the merchant.

    \item Verify $\pi_v$ by using $\cecpaymentinfo$, $\spk$,  $\phi_{V,l}$, $\varphi_{V,l}$, $\varsigma'_l$, $\theta'_l$, $\varsigma'_{l+V-1}$, $\theta'_{l+V-1}$, $R'_{l+V-1}$, $S'_{l+V-1}$, $T'_{l+V-1}$, $V$, $R$ and $\kappa$. Output $0$ if the proof is not correct, else output $V$.

\end{itemize}

\item[$\cecIdentify(\cecparams, \cecPK, \cecpayment_1, \cecpayment_2, \cecpaymentinfo_1, \cecpaymentinfo_2)$.] Execute these steps:
\begin{itemize}

    \item Parse $\cecpayment_1$ as  $(\kappa_1, \allowbreak \sigma'_1, \allowbreak \phi_{V_1,l_1,1}, \allowbreak \varphi_{V_1,l_1,1}, \varsigma'_{l_1,1}, \allowbreak \theta'_{l_1,1}, \allowbreak \varsigma'_{l_1+V_1-1,1}, \allowbreak \theta'_{l_1+V_1-1,1}, \allowbreak \\ R'_{l_1+V_1-1,1}, \allowbreak S'_{l_1+V_1-1,1}, \allowbreak T'_{l_1+V_1-1,1}, \allowbreak R_1, \allowbreak \pi_{v,1}, \allowbreak V_1)$.

    \item Parse $\cecpayment_2$ as $(\kappa_2, \allowbreak \sigma'_2, \allowbreak \phi_{V_2,l_2,2}, \allowbreak \varphi_{V_2,l_2,2}, \varsigma'_{l_2,2}, \allowbreak \theta'_{l_2,2}, \allowbreak \varsigma'_{l_2+V_2-1,2}, \allowbreak \theta'_{l_2+V_2-1,2}, \allowbreak \\ R'_{l_2+V_2-1,2}, \allowbreak S'_{l_2+V_2-1,2}, \allowbreak T'_{l_2+V_2-1,2}, \allowbreak R_2, \allowbreak \pi_{v,2}, \allowbreak V_2)$.

    \item For $k \in [0,V_1-1]$, compute the serial numbers $\mathrm{SN}_{k,1} \allowbreak \gets \allowbreak \e(\phi_{V_1,l_1,1}[2], \tilde{\delta}_k) \allowbreak \e(\phi_{V_1,l_1,1}[1], \tilde{\eta}_{V_1,k})$.  For $k \in [0,V_2-1]$, compute $\mathrm{SN}_{k,2} \allowbreak \gets \allowbreak \e(\phi_{V_2,l_2,2}[2], \tilde{\delta}_k) \allowbreak \e(\phi_{V_2,l_2,2}[1], \tilde{\eta}_{V_2,k})$.

    \item Output $1$ if none of the serial numbers $\mathrm{SN}_{k_1,1}$, for $k_1 \in [0,V_1-1]$, is equal to $\mathrm{SN}_{k_2,2}$, for $k_2 \in [0,V_2-1]$.

    \item Else, output $\cecpaymentinfo_1$ if $\cecpaymentinfo_1 = \cecpaymentinfo_2$.

    \item Else, let $k_1 \in [0,V_1-1]$ and $k_2 \in [0,V_2-1]$ be two indices such that $\mathrm{SN}_{k_1,1}=\mathrm{SN}_{k_2,2}$. Compute
    \begin{align*}
        T_1 \gets \e(\varphi_{V_1,l_1,1}[2],\tilde{\delta}_{k_1}) \e(\varphi_{V_1,l_1,1}[1],\tilde{\eta}_{V_1,k_1}),
    \end{align*}
    and
    \begin{align*}
        T_2 \gets \e(\varphi_{V_2,l_2,2}[2],\tilde{\delta}_{k_2}) \e(\varphi_{V_2,l_2,2}[1],\tilde{\eta}_{V_2,k_2}).
    \end{align*}
    For each $\spk_{\fcecUser_j} \in \mathrm{PK}$, check whether $T_1T_2^{-1} = \e(\spk_{\fcecUser_j},\tilde{\delta}_{k_1}^{R_1}\tilde{\delta}_{k_2}^{-R_2})$ and output $\spk_{\fcecUser_j}$ if the equality holds. Output $\bot$ if the equality does not hold for any $\spk_{\fcecUser_j} \in \mathrm{PK}$.

\end{itemize}

\end{description}
