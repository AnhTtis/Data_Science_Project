\subsection{Ideal Functionality}\label{sec:idealfun}\label{sec:idealfunctionalityCEC}

We define the security properties of offline e-cash with threshold issuance in the ideal-world/real-world paradigm. %, which allows one to define and analyze the security of cryptographic protocols so that security is retained under arbitrary composition with other protocols~\cite{DBLP:conf/focs/Canetti01}. 
% The security of a protocol is defined by means of an ideal protocol that carries out the desired task. In the ideal protocol, all parties send their inputs to an ideal functionality  $\Functionality$  for the task, which locally computes the outputs of the task and provides each party with its prescribed output. 
To this end, in Figure~\ref{fig:idealfun} we define the ideal functionality 
$\Functionality_{\CEC}$. $\Functionality_{\CEC}$ interacts with authorities $(\fcecAuthority_1, \ldots, \fcecAuthority_n)$, any number of users $\fcecUser_j$ and any number of providers $\fcecProvider_k$. $\Functionality_{\CEC}$ is parameterized by a threshold $t$, a universe of pseudonyms $\fcecunivnym$, a universe of wallet identifiers $\fcecunivwalletid$, a universe of request identifiers $\fcecunivrequestid$, a universe of payment information $\fcecunivpaymentinfo$, and a number $L$ of coins in a wallet. In~\S\ref{sec:securitydefinitionsbuildingblocks}, we define the security properties of the cryptographic primitives used in our $\CEC$ schemes. 

\paragraph{Remarks about $\Functionality_{\CEC}$.} When describing ideal functionalities, we use the conventions introduced in~\cite{DBLP:conf/crypto/CamenischDR16} and summarised in~\S\ref{sec:securitymodel}. 
\begin{description}[leftmargin=*, noitemsep,topsep=0pt]

\item[Aborts.] When invoked by any party, $\Functionality_{\CEC}$ first checks the correctness of the input. $\Functionality_{\CEC}$ aborts if any of the inputs does not belong to the correct domain. $\Functionality_{\CEC}$ also aborts if an interface is invoked at an incorrect moment in the protocol. For example, an authority $\fcecAuthority_i$ cannot invoke the $\fcecissue$ interface on input a request identifier $\fcecrequestid$ if that authority did not receive a request associated with $\fcecrequestid$. Similar abortion conditions are listed when $\Functionality_{\CEC}$ receives a message from the simulator $\Simulator$.


\item[Session identifier.] The session identifier $\sid$ has the structure $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$. This allows any authorities $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n)$ to create an instance of $\Functionality_{\CEC}$. After the first invocation of $\Functionality_{\CEC}$, $\Functionality_{\CEC}$ implicitly checks that the session identifier in a message is equal to the one received in the first invocation.

\item[Query identifiers.] Before $\Functionality_{\CEC}$ queries $\Simulator$, $\Functionality_{\CEC}$ saves its state, which is recovered when receiving a response from $\Simulator$. If an interface, e.g. $\fcecrequest$, can be invoked by a party more than once, $\Functionality_{\CEC}$ creates a query identifier $\qid$, which allows $\Functionality_{\CEC}$ to match a query to $\Simulator$ to a response from $\Simulator$. Creating $\qid$ is not necessary if an interface, such as $\fcecsetup$, can be invoked only once by each authority, and the authority identifier is revealed to $\Simulator$.

\end{description}

\begin{figure*}
    \begin{framed}
        {\small
        \vspace*{-10pt}
        \begin{multicols}{2}
        \begin{enumerate}[leftmargin=*]
        
        \item On input $(\fcecsetupini, \allowbreak \sid)$ from an authority $\fcecAuthority_i$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $\sid \neq (\fcecAuthority_1, \ldots, \fcecAuthority_n, \sid')$, or if $\fcecAuthority_i \notin \sid$, or if $n < t$, or if $(\sid, \fcecAuthority_i, 0)$ is already stored.
        
            \item Store $(\sid, \fcecAuthority_i, 0)$ and send $(\fcecsetupsim, \allowbreak \sid, \allowbreak \fcecAuthority_i)$ to $\Simulator$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecsetuprep, \allowbreak \sid, \allowbreak \fcecAuthority_i)$ from $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $(\sid, \fcecAuthority_i, 0)$ is not stored or if $(\sid, \fcecAuthority_i, 1)$ is already stored.
        
            \item Store $(\sid, \fcecAuthority_i, 1)$ and send $(\fcecsetupend, \allowbreak \sid)$ to $\fcecAuthority_i$.
        
        \end{itemize}
        
        \item On input $(\fcecregisterini, \allowbreak \sid)$ from  user $\fcecUser_j$ or provider $\fcecProvider_k$:
        
        \begin{itemize}[leftmargin=*]
        
        \item Abort if there is a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak 0)$ stored.
        
        \item Store $(\sid, \allowbreak \fcecUser_j, \allowbreak 0)$ and send $(\fcecregistersim, \allowbreak \sid, \allowbreak \fcecUser_j)$ to $\Simulator$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecregisterrep, \allowbreak \sid, \allowbreak \fcecUser_j)$ from the simulator $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
        \item Abort if $(\sid, \allowbreak \fcecUser_j, \allowbreak 0)$ is not stored or if $(\sid, \allowbreak \fcecUser_j, \allowbreak 1)$ is stored.
        
        \item Store $(\sid, \allowbreak \fcecUser_j, \allowbreak 1)$ and send $(\fcecregisterend, \allowbreak \sid)$ to $\fcecUser_j$.
        
        \end{itemize}
        
        \item On input $(\fcecrequestini, \allowbreak \sid, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$ from user $\fcecUser_j$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $\sid \allowbreak \neq \allowbreak (\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$, or if $\fcecAuthority_i \allowbreak \notin \allowbreak \sid$, or if $n < t$, or if $\fcecrequestid \allowbreak \notin \allowbreak \fcecunivrequestid$.
        
            \item Abort if $(\sid, \allowbreak \fcecUser_j, \allowbreak 1)$ is not stored, or if $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecAuthority'_i, \allowbreak \fcecrequestid', \allowbreak \fcecwalletnum, \allowbreak \mathrm{user})$ stored such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$, $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$ and $\fcecrequestid' = \fcecrequestid$.
        
            \item Store $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{user})$.
        
            \item If $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ is not stored, store $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$, where $\fcecwalletcount$ is a counter of the number of wallets of $\fcecUser_j$ initialized to $1$, and $\fcecdb$ is a (initially empty) database. 
            % $\fcecdb$ has entries of the form $[\fcecwalletnum, \allowbreak \fcecwalletid, l, \allowbreak \fcecauthset]$, where $\fcecwalletnum$ is the wallet number, $\fcecwalletid$ is a wallet identifier, $l$ is the number of coins spent from the wallet $\fcecwalletnum$, and $\fcecauthset$ is the set of authorities that issued requests for the creation of this wallet.
        
            \item If $\fcecwalletnum \allowbreak \notin \allowbreak [1, \allowbreak \fcecwalletcount]$, set $\fcecwalletcount \allowbreak \gets \allowbreak \fcecwalletcount + \allowbreak 1$, set $\fcecwalletnum \allowbreak \gets \allowbreak \fcecwalletcount$, pick random $\fcecwalletid \allowbreak \gets \allowbreak \fcecunivwalletid$, and store an entry $[\fcecwalletnum, \allowbreak \fcecwalletid, 0, \allowbreak \emptyset]$ in $\fcecdb$. Update $\fcecwalletcount$ and $\fcecdb$ in the tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$.
        
            % \item If there is not an entry $[\fcecwalletnum, \allowbreak \fcecwalletid, l, \allowbreak \fcecauthset]$ in $\fcecdb$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$, add an entry $[\fcecrequestid, \allowbreak 0, \allowbreak \emptyset]$ to $\fcecdb$.
        
            \item Create a fresh $\qid$ and store $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$.
        
            %\item If this is the first request sent by $\fcecUser_j$, set $b \gets 1$, else set $b \gets 0$.
        
            \item If $\fcecAuthority_i$ is honest, send $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$ to the simulator $\Simulator$, else pick $\fcecwalletid$ from the entry $[\fcecwalletnum', \allowbreak \fcecwalletid, 0, \allowbreak \emptyset] \allowbreak \in \allowbreak \fcecdb$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$ and send $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecwalletid)$ to the simulator $\Simulator$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecrequestrep, \allowbreak \sid, \allowbreak \qid)$ from the simulator $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $(\qid', \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \fcecrequestid, \allowbreak \fcecwalletnum)$ such that $\qid' \allowbreak = \allowbreak \qid$ is not stored, or if $(\sid, \allowbreak \fcecAuthority_i, \allowbreak 1)$ is not stored.
    
        
            \item Store $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{authority})$, delete $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$, and send $(\fcecrequestend, \allowbreak \sid, \allowbreak \fcecUser_j, \allowbreak \fcecrequestid)$ to $\fcecAuthority_i$.
        
        \end{itemize}
        
        % ---------------------------------------------------------
        \item On input $(\fcecissueini, \allowbreak \sid, \allowbreak \fcecUser_j, \allowbreak \fcecrequestid)$ from an authority $\fcecAuthority_i$:
        
            \begin{itemize}[leftmargin=*]
        
                \item Abort if a tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecAuthority'_i, \allowbreak \fcecrequestid', \allowbreak \fcecwalletnum, \allowbreak \mathrm{authority})$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$, $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$ and $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ is not stored.
        
                \item Create a fresh $\qid$, store $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{issue})$ and delete $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{authority})$.
        
                \item Send $(\fcecissuesim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecAuthority_i, \allowbreak \fcecUser_j)$ to the simulator $\Simulator$.
        
            \end{itemize}
        
            \item[S.] On input $(\fcecissuerep, \allowbreak \sid, \allowbreak \qid)$ from the simulator $\Simulator$:
        
            \begin{itemize}[leftmargin=*]
        
                \item Abort if $(\qid', \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{issue})$ such that $\qid' = \qid$ is not stored.
        
                \item If $\fcecUser_j$ or $\fcecAuthority_i$ are honest, take the tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$, and replace the entry $[\fcecwalletnum', \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset]$ in $\fcecdb$ such that $\fcecwalletnum' = \fcecwalletnum$ by $[\fcecwalletnum', \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset \cup \{\fcecAuthority_i\}]$.
        
                \item Delete $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum, \allowbreak \mathrm{issue})$, and delete $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecAuthority'_i, \allowbreak \fcecrequestid', \allowbreak \fcecwalletnum, \allowbreak \mathrm{user})$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$, $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$ and $\fcecrequestid' = \fcecrequestid$.
        
                \item Send $(\fcecissueend, \allowbreak \sid, \allowbreak \fcecrequestid, \allowbreak \fcecAuthority_i)$ to $\fcecUser_j$.
        
            \end{itemize}
        
        \item On input $(\fcecspendini, \allowbreak \sid, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ from $\fcecUser_j$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $\fcecnym \allowbreak \notin \allowbreak \fcecunivnym$, or if $\cecpaymentinfo \allowbreak \notin \allowbreak \fcecunivpaymentinfo$, or if $\cecpaymentinfo$ does not contain $\fcecProvider_k$, or if $(\sid,  \allowbreak \fcecUser'_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ is not stored.
        
            \item Abort if there is not an entry $[\fcecwalletnum', \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset] \allowbreak \in \allowbreak \fcecdb$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$. Else, proceed as follows:
            \begin{itemize}[leftmargin=*]
        
                \item Abort if $\fcecUser_j$ is honest and either $V \notin [1,L]$ or $l \allowbreak + \allowbreak V \allowbreak > \allowbreak L$.
        
                \item Abort if $\fcecUser_j$ is corrupt and $\fcecdsset \notin [1,L]$. Else overwrite $V \gets |\fcecdsset|$.
        
                \item Abort if $|\fcecauthset| \allowbreak < \allowbreak t'$, where $t' \allowbreak = \allowbreak t$, if $\fcecUser_j$ is honest, or $t' \allowbreak = \allowbreak t - \allowbreak \tilde{t}$, if $\fcecUser_j$ is corrupt and there are $\tilde{t}$ corrupt authorities.
        
            \end{itemize}
        
            \item If $\fcecUser_j$ is honest, update $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset]$ to $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak l+V, \allowbreak \fcecauthset]$.
        
            \item Create a fresh $\qid$ and store $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$.
        
            \item Send $(\fcecspendsim, \allowbreak \sid, \allowbreak \qid)$ to $\Simulator$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecspendrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $(\qid', \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ such that $\qid' \allowbreak = \allowbreak \qid$ is not stored and if $(\sid, \allowbreak \fcecProvider'_k, \allowbreak 1)$ such that $\fcecProvider'_k \allowbreak = \allowbreak \fcecProvider_k$ is not stored.
        
            \item Create a random unique payment identifier $\fcecpaymentid$ and store $(\sid, \allowbreak \fcecpaymentid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k, \allowbreak 0)$.
        
            \item Delete $(\qid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$.
        
            \item Send $(\fcecspendend, \allowbreak \fcecpaymentid, \allowbreak V, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym)$ to $\fcecProvider_k$.
        
        \end{itemize}
        
        \item On input $(\fcecdepositini, \allowbreak \sid, \allowbreak \fcecpaymentid)$ from a provider $\fcecProvider_k$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if a tuple $(\sid, \allowbreak \fcecpaymentid', \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider'_k, \allowbreak b)$ such that $\fcecpaymentid' \allowbreak = \allowbreak \fcecpaymentid$, $\fcecProvider'_k \allowbreak = \allowbreak \fcecProvider'_k$ and $b \allowbreak = \allowbreak 0$ is not stored.
        
            \item Create a fresh $\qid$ and store $(\qid, \allowbreak \fcecpaymentid, \allowbreak \fcecProvider_k)$.
        
            \item If $\fcecUser_j$ is corrupt and there is at least one corrupt authority, send $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ to $\Simulator$. Else if $\fcecUser_j$ is honest and there is at least one corrupt authority, send $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid, \allowbreak V, \allowbreak \cecpaymentinfo)$ to $\Simulator$. Else, send $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid)$ to $\Simulator$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecdepositrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if a tuple $(\qid', \allowbreak \fcecpaymentid, \allowbreak \fcecProvider_k)$ such that $\qid' \allowbreak = \allowbreak \qid$ is not stored.
        
            \item Update the stored tuple $(\sid, \allowbreak \fcecpaymentid', \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider'_k, \allowbreak b)$ such that $\fcecpaymentid' \allowbreak = \allowbreak \fcecpaymentid$, $\fcecProvider'_k \allowbreak = \allowbreak \fcecProvider'_k$ and $b \allowbreak = \allowbreak 0$ to contain $b = 1$.
        
            \item Delete $(\qid, \allowbreak \fcecpaymentid, \allowbreak \fcecProvider_k)$.
        
            \item Send $(\fcecdepositend, \allowbreak \sid, \allowbreak \fcecpaymentid)$ to $\fcecProvider_k$.
        
        \end{itemize}
        
        \item On input $(\fcecdepvfini, \allowbreak \sid, \allowbreak \fcecusers, \allowbreak \cecpaymentinfo)$ from an authority $\fcecAuthority_i$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $(\sid, \fcecAuthority'_i, 1)$ such that $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$ is not stored or if there exists $\fcecUser_j \allowbreak \in \allowbreak \fcecusers$ such that a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak 1)$ is not stored.
        
            \item Create a fresh $\qid$ and store $(\qid, \allowbreak \fcecusers, \allowbreak \cecpaymentinfo, \allowbreak \fcecAuthority_i)$.
        
            \item Send $(\fcecdepvfsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecusers', \allowbreak \fcecnumdeposits)$ to $\Simulator$. $\fcecusers'$ is the set of users $\fcecUser_j \allowbreak \in \allowbreak \fcecusers$ such that $\fcecUser_j$ did not send a request to $\fcecAuthority_i$ and $\fcecUser_j$ was not received previously as input by $\fcecAuthority_i$ in another set $\fcecusers$. $\fcecnumdeposits$ is the number of payments deposited since $\fcecdepvf$ was last invoked by $\fcecAuthority_i$.
        
        \end{itemize}
        
        \item[S.] On input $(\fcecdepvfrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:
        
        \begin{itemize}[leftmargin=*]
        
            \item Abort if $(\qid', \allowbreak \fcecusers, \allowbreak \cecpaymentinfo, \allowbreak \fcecAuthority_i)$ such that $\qid' \allowbreak = \allowbreak \qid$ is not stored.
        
            \item If there is no tuple $(\sid, \allowbreak \fcecpaymentid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo', \allowbreak \fcecnym, \allowbreak \fcecProvider_k, \allowbreak b)$ such that $\cecpaymentinfo' = \cecpaymentinfo$ and $b = 1$, set $c \allowbreak \gets \allowbreak 0$.
        
            \item If there are $K > 1$ tuples $(\sid, \allowbreak \fcecpaymentid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo', \allowbreak \fcecnym, \allowbreak \fcecProvider_k, \allowbreak b)$ such that $\cecpaymentinfo' = \cecpaymentinfo$ and $b = 1$, set $c \allowbreak \gets \allowbreak (\fcecProvider_1,\ldots,\fcecProvider_K)$, where $(\fcecProvider_1,\ldots,\fcecProvider_K)$ are the provider identities such that either $\fcecProvider_k$ is not included in $\cecpaymentinfo$, or there are two or more tuples deposited by $\fcecProvider_k$.
        
            \item If there is 1 tuple $(\sid, \allowbreak \fcecpaymentid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo', \allowbreak \fcecnym, \allowbreak \fcecProvider_k, \allowbreak b)$ such that $\cecpaymentinfo' = \cecpaymentinfo$ and $b = 1$, proceed as follows:
        
            \begin{itemize}[leftmargin=*]
        
                \item If $\fcecProvider_k$ is not in $\cecpaymentinfo$, output $c \allowbreak \gets \allowbreak \fcecProvider_k$.
        
                \item Else, if $\fcecUser_j$ is honest, set $c \allowbreak \gets \allowbreak 1$.
        
                \item Else, if $\fcecUser_j$ is corrupt, check if there are other tuples $(\sid, \allowbreak \fcecpaymentid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletnum', \allowbreak V, \allowbreak \fcecdsset', \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k, \allowbreak b)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$, $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum'$ and $b \allowbreak = \allowbreak 1$. For all such tuples, check if $\fcecdsset' \cap \fcecdsset = \emptyset$. If that is the case for all tuples, set $c \allowbreak \gets \allowbreak 1$. Else, if $\fcecUser_j \allowbreak \in \allowbreak \fcecusers$, set $c \allowbreak \gets \allowbreak \fcecUser_j$, else set $c \allowbreak \gets \allowbreak \bot$.
        
            \end{itemize}
        
            \item Delete $(\qid, \allowbreak \fcecusers, \allowbreak \cecpaymentinfo, \allowbreak \fcecAuthority_i)$.
        
            \item Send $(\fcecdepvfend, \allowbreak \sid, \allowbreak \cecpaymentinfo, \allowbreak c)$ to $\fcecAuthority_i$.
        
        \end{itemize}
        
        \end{enumerate}
        \end{multicols}
        }
   \end{framed}
\vspace*{-3mm}
\caption{Ideal Functionality $\Functionality_{\CEC}$}
\label{fig:idealfun}
\end{figure*}

\paragraph{Description of $\Functionality_{\CEC}$.} In the following, we explain how each of the interfaces of $\Functionality_{\CEC}$ works:

\circled{1} An authority $\fcecAuthority_i$ uses the $\fcecsetup$ interface to set up $\Functionality_{\CEC}$. $\Functionality_{\CEC}$ stores the fact that $\fcecAuthority_i$ has run the setup interface and enforces that each authority runs the setup interface only once. The simulator $\Simulator$ is allowed to learn that $\fcecAuthority_i$ has run the setup interface. $\Functionality_{\CEC}$ allows each authority $\fcecAuthority_i$ to run the setup interface independently of other authorities, i.e.\ the execution of the setup interface for one authority can be finalized without the involvement of other authorities. Therefore, $\Functionality_{\CEC}$ is realizable by protocols where authorities run the setup interface independently of each other. For example, protocols where each authority creates its own keys, or protocols where authorities obtain their keys from a trusted third party that generates them. $\Functionality_{\CEC}$ can be modified so that it is realizable by protocols in which the setup interface requires interaction between authorities, e.g. protocols that use a distributed key generation protocol as a building block.


\circled{2} A user $\fcecUser_j$ or a provider $\fcecProvider_k$ use the $\fcecregister$ interface to register. $\Functionality_{\CEC}$ stores the fact that $\fcecUser_j$ or $\fcecProvider_k$ has registered, and enforces that each user or provider runs the registration interface only once. The simulator $\Simulator$ is allowed to learn that $\fcecUser_j$ or $\fcecProvider_k$ has run the setup interface. 

\circled{3} 
A user $\fcecUser_j$ runs the $\fcecrequest$ interface given an authority identifier $\fcecAuthority_i$, a request identifier $\fcecrequestid$ and a wallet number $\fcecwalletnum$. The request identifier $\fcecrequestid$ is used to bind a request to its subsequent issuance, while the wallet number $\fcecwalletnum$ is used to associate the request to a wallet. $\Functionality_{\CEC}$ checks that the user has run the registration interface, and that there is not a request pending from $\fcecUser_j$ to $\fcecAuthority_i$ with the same identifier. Then, if a database for $\fcecUser_j$ is not stored, $\Functionality_{\CEC}$ stores a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletcount, \allowbreak \fcecdb)$, where $\fcecwalletcount$ is a counter of the number of wallets of $\fcecUser_j$ initialized to $1$, and $\fcecdb$ is a (initially empty) database. $\fcecdb$ has entries of the form $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset]$, where $\fcecwalletnum$ is the wallet number, $\fcecwalletid$ is a wallet identifier, $l$ is the number of coins spent from the wallet $\fcecwalletnum$, and $\fcecauthset$ is the set of authorities that issued requests for the creation of this wallet.
If $\fcecwalletnum$ received as input is such that $\fcecwalletnum \allowbreak \notin \allowbreak [1, \fcecwalletcount]$, then $\Functionality_{\CEC}$ increments $\fcecwalletcount$, sets $\fcecwalletnum \allowbreak \gets \allowbreak \fcecwalletcount$, picks a random wallet identifier $\fcecwalletid$ and stores a new entry $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak 0, \allowbreak \emptyset]$ in the database for $\fcecUser_j$. The reason for creating $\fcecwalletid$ is that, in our e-cash schemes, requests for the same wallet can be linked to each other if authorities communicate with each other. Therefore, when $\fcecAuthority_i$ is dishonest, $\Functionality_{\CEC}$ leaks $\fcecwalletid$ to the simulator $\Simulator$. $\Functionality_{\CEC}$ does not leak $\fcecwalletnum$ because dishonest authorities do not necessarily learn how many wallets a user requests.

After being prompted by the simulator $\Simulator$, $\Functionality_{\CEC}$ checks that $\fcecAuthority_i$ has run the setup interface, records that $\fcecUser_j$ sends a request to $\fcecAuthority_i$ with identifier $\fcecrequestid$ for wallet $\fcecwalletnum$, and sends $\fcecUser_j$ and $\fcecrequestid$ to $\fcecAuthority_i$. %We remark that $\Functionality_{\CEC}$ does not prevent $\fcecUser_j$ from sending more than one request with identifier $\fcecrequestid$ to $\fcecAuthority_i$. In that case, $\fcecUser_j$ simply sends the request to the authority more than once.

\circled{4} An authority $\fcecAuthority_i$ runs the $\fcecissue$ interface given a user identifier $\fcecUser_j$ and a request identifier $\fcecrequestid$. $\Functionality_{\CEC}$ checks whether there is a request identifier $\fcecrequestid$ pending for a request from $\fcecUser_j$ to $\fcecAuthority_i$. In that case, after being prompted by the simulator $\Simulator$, $\Functionality_{\CEC}$ records that $\fcecAuthority_i$ has run the issuance for the request $\fcecrequestid$. Concretely, $\Functionality_{\CEC}$ updates the entry $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset]$ in $\fcecdb$ such that $\fcecwalletnum$ is the wallet number associated with $\fcecrequestid$ to contain $\fcecAuthority_i$ in the set $\fcecauthset$. Finally, $\Functionality_{\CEC}$ informs $\fcecUser_j$ that $\fcecAuthority_i$ has run the issuance for the request $\fcecrequestid$.

\circled{5} A user $\fcecUser_j$ runs the $\fcecspend$ interface given a wallet number $\fcecwalletnum$, a number $V$ of coins to be spent, a set of coin indices $\fcecdsset$, payment information $\cecpaymentinfo$, a pseudonym $\fcecnym$ and a provider identifier $\fcecProvider_k$. 
% $\fcecUser_j$ wishes to spend coins in the wallet $\fcecwalletnum$ with the provider $\fcecProvider_k$. 
The payment information $\cecpaymentinfo$ should be unique for each spending, but $\Functionality_{\CEC}$ checks that later when verifying a deposit. If $\fcecUser_j$ is honest, $\Functionality_{\CEC}$ checks that there are enough non-spent coins related to $\fcecwalletnum$ ($l+V \leq L$, where $l$ is in the entry $[\fcecwalletnum, \allowbreak \fcecwalletid, \allowbreak l, \allowbreak \fcecauthset] \allowbreak \in \allowbreak \fcecdb)$ and in that case adds $V$ to the number of spent coins. In contrast, if $\fcecUser_j$ is corrupt, $\Functionality_{\CEC}$ records that the coins with indices $\fcecdsset$ are spent, regardless of whether they were spent before or not.  $\Functionality_{\CEC}$ also checks that enough authorities have issued the wallet $\fcecwalletnum$ to $\fcecUser_j$. In that case, after being prompted by the simulator, $\Functionality_{\CEC}$ checks that $\fcecProvider_k$ has run the registration interface and creates a payment identifier $\fcecpaymentid$ to store the information related to this spending. Finally $\Functionality_{\CEC}$ sends $\fcecpaymentid$, $V$, $\cecpaymentinfo$ and $\fcecnym$ to $\fcecProvider_k$. We remark that $\fcecProvider_k$ does not learn $\fcecUser_j$, and $\fcecnym$ can be different for each spending so that spendings by $\fcecUser_j$ are unlinkable to each other and to the request phase.

\circled{6} A provider $\fcecProvider_k$ runs the $\fcecdeposit$ interface on input a payment identifier $\fcecpaymentid$. If there is a payment with identifier $\fcecpaymentid$ related to $\fcecProvider_k$ that is not deposited, $\Functionality_{\CEC}$ proceeds to deposit it. If no authorities are corrupt, $\Functionality_{\CEC}$ does not leak to $\Simulator$ any information about the deposited payment. However, if at least one authority is corrupt and the user that computed the payment is corrupt, $\Functionality_{\CEC}$ leaks the full information about the payment. If at least one authority is corrupt but the user that computed the payment is honest, the authority leaks the number $V$ of coins spent and the payment information $\cecpaymentinfo$. After being prompted by the simulator, $\Functionality_{\CEC}$ marks that payment as deposited and informs $\fcecProvider_k$ that the payment has been deposited.

\circled{7} An honest authority $\fcecAuthority_i$ runs the $\fcecdepvf$ interface given a list of user identifiers $\fcecusers$ and payment information $\cecpaymentinfo$. $\Functionality_{\CEC}$ checks that $\fcecAuthority_i$ has run the setup interface and that all the users in $\fcecusers$ have run the registration interface.  $\Functionality_{\CEC}$ leaks to the simulator the identities of those users in $\fcecusers$ that were unknown by $\fcecAuthority_i$. This is done because, in our protocol, $\fcecAuthority_i$ needs to retrieve the public key for that user, and the adversary learns that. $\Functionality_{\CEC}$ also leaks the number of deposits that were made since the last time $\fcecAuthority_i$ run the deposit verification interface. This is done because, in our protocol, the authority needs to read the new deposits from the bulletin board, and the adversary learns that.



After being prompted by the simulator, $\Functionality_{\CEC}$ checks the deposited payment with payment information $\cecpaymentinfo$. If no such deposited payment exists, $\Functionality_{\CEC}$ sets $c \gets 0$. If there is more than one deposited payment with $\cecpaymentinfo$, $\Functionality_{\CEC}$ sets $c$ to contain the identifiers of the provider(s) that deposited those payments more than once, or just once if the identity of the provider is not in $\cecpaymentinfo$. If there is 1 such tuple,  $\Functionality_{\CEC}$ sets $c$ to the identity of the provider that deposited the payment if that identity is not in $\cecpaymentinfo$. Else, $\Functionality_{\CEC}$ sets $c \gets 1$ if the user that made a payment with $\cecpaymentinfo$ is honest, which means that there has not been a double spending. If the user is corrupt, $\Functionality_{\CEC}$ checks whether there are deposited payments where the coins spent in the payment related with $\cecpaymentinfo$ have also been spent. If that is not the case, $\Functionality_{\CEC}$ sets $c \allowbreak \gets \allowbreak 1$. Else, if the user identifier is in $\fcecusers$, $\Functionality_{\CEC}$ sets $c$ to the identifier of the user that double spent, and otherwise sets $c \allowbreak \gets \allowbreak \bot$, which indicates that double spending has been detected but the user has not been identified. $\Functionality_{\CEC}$ sends $c$ along with $\cecpaymentinfo$ to $\fcecAuthority_i$.




% \vspace{5pt}
\paragraph{Security properties.} We now argue that $\Functionality_{\CEC}$ guarantees the security properties
defined in \S\ref{sec:securityoffec}. 
\begin{description}[leftmargin=*, noitemsep,topsep=0pt]

    \item[Traceability.] In the $\fcecspend$ interface, when a user wishes to spend coins in the wallet $\fcecwalletnum$, $\Functionality_{\CEC}$ checks that the user has been issued that wallet by at least $t-\tilde{t}$ authorities. This guarantees that users cannot forge wallets. Moreover, in the $\fcecdepvf$ interface, $\Functionality_{\CEC}$ guarantees that, if coins were double spent, the user is identified whenever the user identifier is included in the set $\fcecusers$. $\Functionality_{\CEC}$ also finds providers guilty of wrongly depositing a payment, either when they deposit a payment with the same $\cecpaymentinfo$ more than once, or when they deposit a payment with $\cecpaymentinfo$ that does not contain the provider's identity.

    \item[Unlinkability.] In the $\fcecspend$ interface, the user identity is not revealed to the provider. The provider only receives a pseudonym, which can be different at each spending. This guarantees that payments from the same user cannot be linked with each other or to withdrawals by that user.

    \item[Exculpability.] $\Functionality_{\CEC}$ never finds an honest user guilty of double spending. Therefore, any protocol that realizes $\Functionality_{\CEC}$ must guarantee that.

    \item[Clearance.] In the $\fcecdepvf$ interface,  $\Functionality_{\CEC}$ never accepts a deposit as valid if the identity of the provider that made the deposit is not contained in $\cecpaymentinfo$.

\end{description}
We remark that $\Functionality_{\CEC}$ does not take into account the case where $t$ or more authorities are corrupt. We will analyze the security of construction $\mathrm{\Pi}_{\CEC}$ under the assumption that at most $t-1$ authorities are corrupt.