
\section{Construction $\mathrm{\Pi}_{\CEC}$}
\label{sec:constructionCEC}

\begin{figure*}
    \begin{framed}
        {\small
        \vspace*{-10pt}
        \begin{multicols}{2}
        \begin{enumerate}[leftmargin=*]

    \item On input $(\fcecsetupini, \allowbreak \sid)$, $\fcecAuthority_i$ does the following:

    \begin{itemize}[leftmargin=*]

        \item Abort if $\sid \neq (\fcecAuthority_1, \ldots, \fcecAuthority_n, \sid')$, or if $\fcecAuthority_i \allowbreak \notin \allowbreak \sid$, or if $n < t$.

        \item Abort if $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak  \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ is already stored.

        % \item Send $(\fcrsgetini, \allowbreak \sid)$ to $\Functionality_{\CRS}^{\cecSetup}$. In its first invocation, $\Functionality_{\CRS}^{\cecSetup}$ runs the algorithm $\cecparams \allowbreak \gets \allowbreak \cecSetup(1^{\securityparameter}, \allowbreak L)$. $\Functionality_{\CRS}^{\cecSetup}$ sends $(\fcrsgetend, \allowbreak \sid, \allowbreak \cecparams)$ to $\fcecAuthority_i$.

        \item Send $(\fkggetkeyini, \allowbreak \sid)$ to $\Functionality_{\KG}$. In its first invocation, $\Functionality_{\KG}$ runs $\cecparams \allowbreak \gets \allowbreak \cecSetup(1^{\securityparameter}, \allowbreak L)$ and $(\spk, \allowbreak \langle \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]}) \allowbreak \gets \allowbreak \cecKeyGenA(\cecparams, \allowbreak t, \allowbreak n)$. $\Functionality_{\KG}$ sends $(\fkggetkeyend, \allowbreak \sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ to $\fcecAuthority_i$.

        \item Store $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak  \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ and output $(\fcecsetupend, \sid)$.

    \end{itemize}

    \item On input $(\fcecregisterini, \sid)$, $\fcecUser_j$ (or  $\fcecProvider_k$) does the following:

    \begin{itemize}[leftmargin=*]

        % \item Abort if $\sid \neq (\fcecAuthority_1, \ldots, \fcecAuthority_n, \sid')$.

        \item Abort if $(\sid, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$ is already stored.

        \item Send $(\fkgretrieveini, \allowbreak \sid)$ to $\Functionality_{\KG}$. $\Functionality_{\KG}$ sends $(\fkgretrieveend,  \allowbreak \sid,  \allowbreak \fkgvalue)$. If $\fkgvalue = (\cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$, store $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$, else abort.

        \item Run $(\ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j}) \gets \cecKeyGenU(\cecparams)$.

        \item Set $\sid_{\Freg} \gets (\fcecUser_j, \sid')$ and send $(\fregregisterini, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$ to $\Functionality_{\Freg}$. $\Functionality_{\Freg}$ sends $(\fregregisterend, \allowbreak \sid_{\Freg})$ to $\fcecUser_j$.

        \item Store $(\sid, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$ and output $(\fcecregisterend, \allowbreak \sid)$.

    \end{itemize}

    \item On input $(\fcecrequestini, \allowbreak \sid, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$, $\fcecUser_j$ and $\fcecAuthority_i$ do:

    \begin{itemize}[leftmargin=*]

        \item $\fcecUser_j$ aborts if $\sid \allowbreak \neq \allowbreak (\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$, or if $\fcecAuthority_i \allowbreak \notin \allowbreak \sid$, or if $n \allowbreak < \allowbreak t$, or if $\fcecrequestid \allowbreak \notin \allowbreak \fcecunivrequestid$, or if $(\sid, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$ is not stored, or if there is $(\sid, \allowbreak \fcecAuthority'_i, \allowbreak \fcecrequestid', \allowbreak \fcecwalletnum)$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$.

        \item If there is not a tuple $(\sid, \allowbreak \fcecwalletcount)$, $\fcecUser_j$ stores $(\sid, \allowbreak 0)$.

        \item If $\fcecwalletnum \allowbreak \notin \allowbreak [1, \allowbreak \fcecwalletcount]$, $\fcecUser_j$ sets $\fcecwalletcount \allowbreak \gets \allowbreak \fcecwalletcount \allowbreak + \allowbreak 1$, sets $\fcecwalletnum \allowbreak \gets \allowbreak \fcecwalletcount$, runs $(\cecrequest, \allowbreak \cecrequestinfo) \allowbreak \gets \allowbreak \cecRequest(\cecparams, \allowbreak \ssk_{\fcecUser_j})$, stores $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecrequest, \allowbreak \cecrequestinfo)$ and updates $(\sid, \allowbreak \fcecwalletcount)$. $\fcecUser_j$ stores $(\sid, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$.

        % \item $\fcecUser_j$ updates the stored tuple $(\sid, \allowbreak \fcecrequestid', \allowbreak \cecrequest, \allowbreak \cecrequestinfo, \allowbreak \fcecauthset)$ such that $\fcecrequestid' = \fcecrequestid$ to $(\sid, \allowbreak \fcecrequestid', \allowbreak \cecrequest, \allowbreak \cecrequestinfo, \allowbreak \fcecauthset \cup \{\fcecAuthority_i\})$.

        \item $\fcecUser_j$ sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecUser_j,\fcecAuthority_i,\sid')$ and sends $(\fsmtsendini, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecrequest \rangle)$ to $\Functionality_{\SMT}$.

        \item $\fcecAuthority_i$ receives $(\fsmtsendend, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecrequest \rangle)$ from $\Functionality_{\SMT}$.

        \item $\fcecAuthority_i$ aborts if $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak  \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ is not stored.

        \item $\fcecAuthority_i$ aborts if there is a tuple $(\sid, \allowbreak \fcecrequestid', \allowbreak \cecrequest, \allowbreak \fcecUser'_j)$ stored such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$.

        \item $\fcecAuthority_i$ parses $\sid_{\SMT}$ as $(\fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \sid')$. If $(\sid, \allowbreak \fcecUser'_j, \spk_{\fcecUser_j})$ such that $\fcecUser'_j = \fcecUser_j$ is not stored, $\fcecAuthority_i$ does the following:
        \begin{itemize}

            \item $\fcecAuthority_i$ sets $\sid_{\Freg} \allowbreak \gets \allowbreak (\fcecUser_j, \allowbreak \sid')$ and sends $(\fregretrieveini, \allowbreak \sid_{\Freg})$ to $\Functionality_{\Freg}$. $\Functionality_{\Freg}$ sends $(\fregretrieveend, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$ to $\fcecAuthority_i$.

            \item If $\spk_{\fcecUser_j} = \bot$, $\fcecAuthority_i$ aborts, else $\fcecAuthority_i$ stores $(\sid, \allowbreak \fcecUser_j, \spk_{\fcecUser_j})$.

        \end{itemize}

        \item $\fcecAuthority_i$ runs $b \gets \cecRequestVf(\cecparams, \allowbreak \cecrequest, \allowbreak \spk_{\fcecUser_j})$. If $b \allowbreak = \allowbreak 0$, $\fcecAuthority_i$ aborts, else $\fcecAuthority_i$ stores $(\sid, \allowbreak \fcecrequestid, \allowbreak \cecrequest, \allowbreak \fcecUser_j)$.

        \item $\fcecAuthority_i$ outputs $(\fcecrequestend, \sid, \fcecUser_j, \fcecrequestid)$.


    \end{itemize}

    \item On input $(\fcecissueini, \sid, \fcecUser_j, \fcecrequestid)$, $\fcecAuthority_i$ and $\fcecUser_j$  do the following:

    \begin{itemize}[leftmargin=*]

        \item $\fcecAuthority_i$ aborts if $(\sid, \allowbreak \fcecrequestid', \allowbreak \cecrequest, \allowbreak \fcecUser'_j)$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ is not stored.

        \item $\fcecAuthority_i$ runs $\cecresponse \allowbreak \gets \allowbreak \cecWithdraw(\cecparams, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \cecrequest)$.

        \item $\fcecAuthority_i$ deletes $(\sid, \allowbreak \fcecrequestid, \allowbreak \cecrequest, \allowbreak \fcecUser_j)$, sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecAuthority_i, \allowbreak \fcecUser_j, \allowbreak \sid')$ and sends $(\fsmtsendini, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecresponse \rangle)$ to $\Functionality_{\SMT}$.

        % \item If $(\sid, \allowbreak \fcecrequestid', \allowbreak \fcecUser'_j, \allowbreak \cecresponse)$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ is not stored, $\fcecAuthority_i$ runs $\cecresponse \allowbreak \gets \allowbreak \cecWithdraw(\cecparams, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \cecrequest)$ and stores $(\sid, \allowbreak \fcecrequestid, \allowbreak \fcecUser_j, \allowbreak \cecresponse)$.

        \item $\fcecUser_j$ receives $(\fsmtsendend, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecresponse \rangle)$ from $\Functionality_{\SMT}$.

        \item $\fcecUser_j$ parses $\sid_{\SMT}$ as $(\fcecAuthority_i, \allowbreak \fcecUser_j, \allowbreak \sid')$. $\fcecUser_j$ aborts if a tuple $(\sid, \allowbreak \fcecAuthority'_i, \allowbreak \fcecrequestid', \allowbreak \fcecwalletnum)$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority'_i$ is not stored. Else $\fcecUser_j$ takes the stored tuple $(\sid, \allowbreak \fcecwalletnum', \allowbreak \cecrequest, \allowbreak \cecrequestinfo)$ such that $\fcecwalletnum' = \fcecwalletnum$ and runs $\cecwallet_i \allowbreak \gets \allowbreak \cecWithdrawVf(\cecparams, \allowbreak \spk_{\fcecAuthority_i}, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \cecresponse, \allowbreak \cecrequestinfo)$. If $\cecwallet_i \allowbreak = \allowbreak 0$, $\fcecUser_j$ aborts.

        \item If there is not a tuple $(\sid, \allowbreak \fcecwalletnum', \allowbreak \cecset, \allowbreak \fcecwalletset)$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$, $\fcecUser_j$ stores $(\sid, \allowbreak \fcecwalletnum, \allowbreak \emptyset, \allowbreak \emptyset)$.

        \item $\fcecUser_j$ updates $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecset, \allowbreak \fcecwalletset)$ to $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecset \cup \{i\}, \allowbreak \fcecwalletset \cup \{\cecwallet_i\})$.

        \item If $(\sid, \allowbreak \fcecwalletnum', \allowbreak \cecwallet)$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$ is not stored, and if $|\cecset| \allowbreak  \geq \allowbreak t$ in the tuple $(\sid, \allowbreak \fcecwalletnum', \allowbreak \cecset, \allowbreak \fcecwalletset)$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$, then $\fcecUser_j$ runs $\cecwallet \allowbreak \gets \allowbreak \cecCreateWallet(\spk, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \cecset, \allowbreak \fcecwalletset)$ and stores $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecwallet)$.

        \item $\fcecUser_j$ deletes $(\sid, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$.

        \item Output $(\fcecissueend, \allowbreak \sid, \allowbreak \fcecrequestid, \allowbreak \fcecAuthority_i)$.

    \end{itemize}

    \item On input $(\fcecspendini, \allowbreak \sid, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \fcecProvider_k)$, $\fcecUser_j$ and $\fcecAuthority_i$ do:

    \begin{itemize}[leftmargin=*]

        \item $\fcecUser_j$ aborts if $\fcecnym \allowbreak \notin \allowbreak \fcecunivnym$, or if $\cecpaymentinfo \allowbreak \notin \allowbreak \fcecunivpaymentinfo$, or if $\cecpaymentinfo$ does not contain $\fcecProvider_k$, or if $(\sid, \allowbreak \fcecwalletnum', \allowbreak \cecwallet)$ such that $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$ is not stored, or if $V \allowbreak \notin \allowbreak [1,L]$.

        \item $\fcecUser_j$ runs $b \allowbreak \gets \allowbreak \cecSpend(\spk, \allowbreak \ssk_{\fcecUser_j}, \allowbreak \cecwallet, \allowbreak \cecpaymentinfo, \allowbreak V)$. If $b \allowbreak = \allowbreak 0$, $\fcecUser_j$ aborts. Else $\fcecUser_j$ parses $b$ as $(\cecwallet', \allowbreak \cecpayment)$ and updates the stored tuple $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecwallet)$ to $(\sid, \allowbreak \fcecwalletnum, \allowbreak \cecwallet')$.

        \item $\fcecUser_j$ sends $(\fnymsendini, \allowbreak \sid, \allowbreak \langle \cecpayment, \cecpaymentinfo \rangle, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ to $\Functionality_{\NYM}$.

        \item $\fcecProvider_k$ receives $(\fnymsendend, \allowbreak \sid, \langle \cecpayment, \cecpaymentinfo \rangle, \allowbreak \fcecnym)$ from  $\Functionality_{\NYM}$.

        \item $\fcecProvider_k$ aborts if $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$ is not stored, or if $\cecpaymentinfo$ does not contain $\fcecProvider_k$.

        \item $\fcecProvider_k$ runs $b \allowbreak \gets \allowbreak \cecSpendVf(\spk, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo)$. If $b \allowbreak = \allowbreak 0$, $\fcecProvider_k$ aborts, else $\fcecProvider_k$ sets $V \gets b$, creates a random unique payment identifier $\fcecpaymentid$ and stores $(\sid, \allowbreak \fcecpaymentid, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo, \allowbreak V, \allowbreak 0)$.

        \item $\fcecProvider_k$ outputs $(\fcecspendend, \allowbreak \fcecpaymentid, \allowbreak V, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym)$.



    \end{itemize}

    \item On input $(\fcecdepositini, \allowbreak \sid, \allowbreak \fcecpaymentid)$, $\fcecProvider_k$ does the following:

    \begin{itemize}[leftmargin=*]

        \item Abort if a tuple $(\sid, \allowbreak \fcecpaymentid', \allowbreak \cecpayment, \allowbreak \cecpaymentinfo, \allowbreak V, \allowbreak b)$ such that $\fcecpaymentid' \allowbreak = \allowbreak \fcecpaymentid$ and $b \allowbreak = \allowbreak 0$ is not stored.

        \item Send $(\fbbwriteini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle)$ to the functionality $\Functionality_{\BB}$. $\Functionality_{\BB}$ sends $(\fbbwriteend, \allowbreak \sid)$ to $\fcecProvider_k$.

        \item Update the tuple $(\sid, \allowbreak \fcecpaymentid, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo, \allowbreak V, \allowbreak b)$ so that $b \allowbreak = \allowbreak 1$.

        \item Output $(\fcecdepositend, \allowbreak \sid, \allowbreak \fcecpaymentid)$.

    \end{itemize}

    \item On input $(\fcecdepvfini, \allowbreak \sid, \allowbreak \fcecusers, \allowbreak \cecpaymentinfo)$ from an authority $\fcecAuthority_i$:

    \begin{itemize}[leftmargin=*]

        \item Abort if $(\sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ is not stored.

        \item For all $\fcecUser_j \allowbreak \in \allowbreak \fcecusers$, if $(\sid, \allowbreak \fcecUser'_j, \spk_{\fcecUser_j})$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ is not stored, do the following:
        \begin{itemize}[leftmargin=*]

            \item Set $\sid_{\Freg} \allowbreak \gets \allowbreak (\fcecUser_j, \allowbreak \sid')$ and send $(\fregretrieveini, \allowbreak \sid_{\Freg})$ to $\Functionality_{\Freg}$. $\Functionality_{\Freg}$ sends back $(\fregretrieveend, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$.

            \item If $\spk_{\fcecUser_j} \allowbreak = \allowbreak \bot$, abort, else store $(\sid, \allowbreak \fcecUser_j, \spk_{\fcecUser_j})$.

        \end{itemize}

        \item Include in $\cecPK$ the public keys $\spk_{\fcecUser_j}$ in all the stored tuples $(\sid, \allowbreak \fcecUser_j, \allowbreak \spk_{\fcecUser_j})$ such that $\fcecUser_j \allowbreak \in \allowbreak \fcecusers$.

        \item If $(\sid, \allowbreak \fbbindex)$ is not stored, set $\fbbindex \allowbreak = \allowbreak 1$ and store $(\sid, \allowbreak \fbbindex)$.

        \item While $\fbbmessage' \neq \bot$, do the following:

        \begin{itemize}[leftmargin=*]

            \item Send $(\fbbgetbbini, \allowbreak \sid, \allowbreak \fbbindex)$ to $\Functionality_{\BB}$. $\Functionality_{\BB}$ sends back $(\fbbgetbbend, \allowbreak \sid, \allowbreak \fbbmessage')$. If $\fbbmessage' \allowbreak = \allowbreak (\fcecProvider_k, \cecpayment, \allowbreak \cecpaymentinfo)$, Store $(\sid, \allowbreak \fcecProvider_k, \cecpayment, \allowbreak \cecpaymentinfo)$.

            \item Increment $\fbbindex$.

        \end{itemize}

        \item Update $\fbbindex$ in the tuple $(\sid, \allowbreak \fbbindex)$.

        \item Find all the stored tuples $(\sid, \allowbreak \fcecProvider_k, \cecpayment, \allowbreak \cecpaymentinfo')$ such that $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$ and do the following:

        \begin{itemize}[leftmargin=*]

            \item If there is no tuple such that $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$, set $c \allowbreak \gets \allowbreak 0$.

            \item If there are $K \allowbreak > \allowbreak 1$ tuples such that $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$, set $c \allowbreak \gets \allowbreak (\fcecProvider_1, \allowbreak \ldots, \allowbreak \fcecProvider_K)$, where $(\fcecProvider_1, \allowbreak \ldots, \allowbreak \fcecProvider_K)$ are providers that deposited payments with $\cecpaymentinfo$ more than once, or that deposited a payment such that $\fcecProvider_k$ is not included in $\cecpaymentinfo$.

            \item If there is one tuple such that $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$, output $c \allowbreak \gets \allowbreak \fcecProvider_k$ if the identity of the provider is not in $\cecpaymentinfo$. Else, for all the remaining tuples $(\sid, \allowbreak \fcecProvider'_k, \cecpayment', \allowbreak \cecpaymentinfo')$, run the algorithm $c \allowbreak \gets \allowbreak \cecIdentify(\cecparams, \allowbreak \cecPK, \allowbreak \cecpayment, \allowbreak \cecpayment', \allowbreak \cecpaymentinfo, \allowbreak \cecpaymentinfo')$ until $c \allowbreak \neq \allowbreak 1$. If $c \allowbreak = \allowbreak 1$ for all tuples, set $c \allowbreak \gets \allowbreak 1$.

            % If, for any of those tuples, $c \allowbreak = \allowbreak \spk_{\fcecUser_j}$, and there is a tuple $(\sid, \allowbreak \fcecUser_j, \spk_{\fcecUser'_j})$ such that $\spk'_{\fcecUser_j} \allowbreak = \allowbreak \spk_{\fcecUser_j}$ and $\fcecUser_j \in \fcecusers$, then set $c \allowbreak \gets \allowbreak \fcecUser_j$. Else, set $c \gets 1$.

        \end{itemize}

    \item Output $(\fcecdepvfend, \allowbreak \sid, \allowbreak \cecpaymentinfo, \allowbreak c)$.

    \end{itemize}
    \end{enumerate}
    \end{multicols}
        }
   \end{framed}
\vspace*{-3mm}
\caption{Construction $\Pi_{\CEC}$}
\label{fig:constructionEC}
\end{figure*}

In Figure~\ref{fig:constructionEC}, we describe our construction $\mathrm{\Pi}_{\CEC}$ for $\Functionality_{\CEC}$. 
$\mathrm{\Pi}_{\CEC}$ uses
the ideal functionalities $\Functionality_{\SMT}$ for secure message transmission, $\Functionality_{\NYM}$ for a pseudonymous channel, $\Functionality_{\KG}$ for key generation, $\Functionality_{\Freg}$ for registration and $\Functionality_{\BB}$ for an authenticated bulletin board, which are described in~\ref{sec:functionalitiesFULL}. $\Functionality_{\SMT}$ is used for the communication channel between users and authorities in the $\fcecrequest$ and $\fcecissue$ interfaces, while $\Functionality_{\NYM}$ is used for the communication channel between users and providers in the $\fcecspend$ interface. $\Functionality_{\KG}$ runs algorithms $\cecSetup$ and $\cecKeyGenA$, and is used in the $\fcecsetup$ and $\fcecregister$ interfaces to generate and distribute both the parameters of the scheme and the keys of the authorities. $\Functionality_{\Freg}$ is used in the $\fcecregister$ interface to register the user public keys, and in the $\fcecissue$ and $\fcecdepvf$ interfaces to give those keys to authorities. $\Functionality_{\BB}$ is used in the $\fcecdeposit$ interface to deposit payments, and in the $\fcecdepvf$ interface to let authorities retrieve the deposited payments. We remark that $\mathrm{\Pi}_{\CEC}$ also uses a functionality for random oracle $\Functionality_{\RO}$ as in~\cite{cryptoeprint:2022:011} to model the random oracle queries done in the algorithms used as a building block. However, this is omitted in the description of $\mathrm{\Pi}_{\CEC}$.

Additionally, $\mathrm{\Pi}_{\CEC}$ uses the algorithms defined below. We define these algorithms to simplify the description of $\mathrm{\Pi}_{\CEC}$. In \S\ref{sec:instantiation}, we instantiate them for both our compact and divisible e-cash schemes.
\begin{description}[leftmargin=10pt]

\item[$\cecSetup(1^{\securityparameter}, L)$.] It computes the system parameters $\cecparams$ on input the security parameter $1^{\securityparameter}$ and 
the number of coins $L$ in a full wallet. These parameters are publicly available.

\item[$\cecKeyGenA(\cecparams, t, n)$.] Given $\cecparams$, the threshold $t$, and the number of authorities $n$, output the public verification key $\spk$ and the key pairs $(\ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})_{i\in[1,n]}$ for each of the authorities.

\item[$\cecKeyGenU(\cecparams)$.] It is run by each user $\fcecUser_j$ to generate 
a secret key and a public key $(\ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$.

\item[$\cecRequest(\cecparams, \ssk_{\fcecUser_j})$.] On input $\cecparams$ and the secret key $\ssk_{\fcecUser_j}$ of the user $\fcecUser_j$, output a request $\cecrequest$ and request information $\cecrequestinfo$.

\item[$\cecRequestVf(\cecparams, \cecrequest, \spk_{\fcecUser_j})$.] Given $\cecparams$, a request $\cecrequest$ and the public key $\spk_{\fcecUser_j}$ of the user $\fcecUser_j$, output $1$ if the request is valid and $0$ otherwise.

\item[$\cecWithdraw(\cecparams, \ssk_{\fcecAuthority_i}, \cecrequest)$.] On input $\cecparams$, the secret key of authority $\fcecAuthority_i$ and a request $\cecrequest$, output a response $\cecresponse$.

\item[$\cecWithdrawVf(\cecparams, \spk_{\fcecAuthority_i}, \ssk_{\fcecUser_j}, \cecresponse, \cecrequestinfo)$.] Given $\cecparams$, the public key $\spk_{\fcecAuthority_i}$ of authority $\fcecAuthority_i$, the secret key $\ssk_{\fcecUser_j}$ of user $\fcecUser_j$, a response $\cecresponse$ and request information $\cecrequestinfo$, output a partial wallet $\cecwallet_i$ if the response $\cecresponse$ is correct and is associated to a request with request information $\cecrequestinfo$, else output $0$.

\item[$\cecCreateWallet(\spk, \ssk_{\fcecUser_j}, \cecset, \langle \cecwallet_i \rangle_{i \in \cecset})$.] 
Given the public key $\spk$, the secret key $\ssk_{\fcecUser_j}$, a set of indices $\cecset \in [1,n]$ and partial wallets $\langle \cecwallet_i \rangle_{i \in \cecset}$, output a wallet $\cecwallet$ if $|\cecset| \geq t$, else output $0$.

\item[$\cecSpend(\spk, \ssk_{\fcecUser_j}, \cecwallet, \cecpaymentinfo,  V)$.] Given the public key $\spk$, the secret key $\ssk_{\fcecUser_j}$, a wallet $\cecwallet$, payment information $\cecpaymentinfo$, and a number of coins $V$, outputs an updated wallet $\cecwallet'$ and a payment $\cecpayment$ if there are $V$ non-spent coins in $\cecwallet$ or $0$ otherwise.


\item[$\cecSpendVf(\spk, \cecpayment, \cecpaymentinfo)$.] Given the public key $\spk$, a payment $\cecpayment$, and payment information $\cecpaymentinfo$, 
output the number $V$ of coins received 
if the payment is correct, or $0$ otherwise.

\item[$\cecIdentify(\cecparams, \cecPK, \cecpayment_1, \cecpayment_2, \cecpaymentinfo_1, \cecpaymentinfo_2)$.] Given $\cecparams$, a list of user public keys $\cecPK$, and two payments $\cecpayment_1$ and $\cecpayment_2$ with respective payment information $\cecpaymentinfo_1$ and $\cecpaymentinfo_2$:
\begin{itemize}
    \item Output $1$ if $\cecpayment_1$ and $\cecpayment_2$ are payments where different coins were used.
    \item Else, output $\cecpaymentinfo_1$ if $\cecpaymentinfo_1 \allowbreak = \allowbreak \cecpaymentinfo_2$, which indicates that the payment has been double deposited.
    \item Else, output the public key $\spk_{\fcecUser_j} \allowbreak \in \allowbreak \cecPK$ of the user $\fcecUser_j$ that double spent a coin in payments $\cecpayment_1$ and $\cecpayment_2$.
    \item Else, output $\bot$.
\end{itemize}
\end{description}

\paragraph{Remark about $\Pi_{\CEC}$.} In the $\fcecregister$ interface, providers generate their own key pair, although it is not used later in the protocol. This is done to simplify the description of the protocol by making users and providers call the same $\fcecregister$ interface. Nevertheless, when the protocol is instantiated by replacing the ideal functionalities used as building blocks with concrete protocols that realize them, providers will need to generate their own keys.
