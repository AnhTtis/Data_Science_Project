\section{Security Proof for Our Compact E-Cash Scheme}
\label{sec:securityProofCompact}

To prove that construction $\mathrm{\Pi}_\CEC$, instantiated with the algorithms of the compact e-cash scheme in~\S\ref{sec:compactecash}, securely realizes the ideal functionality $\Functionality_{\CEC}$, we have to show that for any environment $\Environment$ and any adversary $\Adversary$ there exists a simulator $\Simulator$ such that $\Environment$ cannot distinguish between whether it is interacting with $\Adversary$ and the protocol in the real world or with $\Simulator$ and $\Functionality_{\CEC}$. The simulator thereby plays the role of all honest parties in the real world and interacts with $\Functionality_{\CEC}$ for all corrupt parties in the ideal world.

$\Simulator$ runs a copy of any adversary $\Adversary$, which is used to provide to $\Environment$ a view that is indistinguishable from the view given by $\Adversary$ in the real world. To achieve that, $\Simulator$ must simulate the real-world protocol towards the copy of $\Adversary$, in such a way that $\Adversary$ cannot distinguish an interaction with $\Simulator$ from an interaction with the real-world protocol. $\Simulator$ uses the information provided by $\Functionality_{\CEC}$ to provide a simulation of the real-world protocol.

Our simulator $\Simulator$ runs copies of the functionalities $\Functionality_{\SMT}$, $\Functionality_{\NYM}$, $\Functionality_{\KG}$, $\Functionality_{\Freg}$ and $\Functionality_{\BB}$. When any of the copies of these functionalities aborts, $\Simulator$ implicitly forwards the abortion message to the adversary if the functionality sends the abortion message to a corrupt party.

$\Simulator$ also runs copies of the extractors $\mathcal{E}_{s}$ and $\mathcal{E}_{v}$ and simulators  $\mathcal{S}_{s}$ and $\mathcal{S}_{v}$ for the non-interactive zero-knowledge arguments of knowledge $\pi_s$ and $\pi_v$, which are computed through the Fiat-Shamir transform. We remark that they involve calls to the random oracle and rewinding of the adversary. For simplicity, we omit those details.

\paragraph{Challenges in the proof.} Our compact e-cash scheme with threshold issuance is based on an existing compact e-cash scheme~\cite{DBLP:conf/eurocrypt/CamenischHL05}. We instantiate that scheme with the Pointcheval-Sanders signature scheme, and then we use an existing threshold issuance protocol for Pointcheval-Sanders signatures~\cite{cryptoeprint:2022:011} to provide threshold issuance. Nevertheless, the security proof does not follow straightforwardly from the proofs in~\cite{DBLP:conf/eurocrypt/CamenischHL05,cryptoeprint:2022:011}. 

First, in the blind issuance protocol of the compact e-cash scheme in~\cite{DBLP:conf/eurocrypt/CamenischHL05} one of the coin secrets is chosen jointly between the user and the bank, i.e. both the bank and the user add randomness to compute the secret. In a threshold issuance setting, it would be necessary that all the authorities add the same randomness without communicating between them. While adding a mechanism to do that is possible, in order to improve efficiency we decided to have the secret be chosen by the user only. This implies that, when a corrupt user picks up the secrets of two wallets, the user could pick up the secrets in such a way that two coins have the same serial number. Consequently, when those coins are spent, there is a situation in which double spending is detected (because serial numbers are the same), although no double spending has happened. In that case, we prove that the identification algorithm cannot output the public key of an honest user, and we are able to do that under the discrete logarithm assumption. 

Second, to improve efficiency, we use only one coin secret instead of the two coins secrets used in [14]. When using two coin secrets, it is straightforward to show that serial numbers and double spending tags do not reveal any information about the secrets by using the pseudorandomness property of the pseudorandom function. However, when using the same secret for both, but a different generator, we need to add an additional reduction to the XDH assumption. 

% We analyze the security of $\mathrm{\Pi_{\CEC}}$ when up to $t-1$ authorities $\fcecAuthority_i$, (a subset of) service providers $\fcecProvider_k$ and (a subset of) users $\fcecUser_j$ are corrupt.

\paragraph{Simulator.} We describe the simulator $\Simulator$ for the case in which a subset of users $\fcecUser_j$, a subset of providers $\fcecProvider_k$ and up to $t-1$ authorities are corrupt. $\Simulator$ simulates the honest parties in the protocol $\mathrm{\Pi_{\CEC}}$ and runs copies of the ideal functionalities involved.

\begin{description}[leftmargin=*]

    \item[Honest authority $\fcecAuthority_i$ starts setup.] When the functionality $\Functionality_{\CEC}$ sends the message $(\fcecsetupsim, \allowbreak \sid, \allowbreak \fcecAuthority_i)$,  the simulator $\Simulator$ runs a copy of the functionality $\Functionality_{\KG}$ on input $(\fkggetkeyini, \allowbreak \sid)$. When the functionality $\Functionality_{\KG}$ sends the message $(\fkggetkeysim, \allowbreak \sid, \allowbreak \qid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Honest authority $\fcecAuthority_i$ ends setup.] When the adversary $\Adversary$ sends the message $(\fkggetkeyrep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs a copy of $\Functionality_{\KG}$ on input that message. When $\Functionality_{\KG}$ sends $(\fkggetkeyend, \allowbreak \sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$, $\Simulator$ sends $(\fcecsetuprep, \allowbreak \sid, \allowbreak \fcecAuthority_i)$ to $\Functionality_{\CEC}$.

    \item[Corrupt authority $\tilde{\fcecAuthority}_i$ starts setup.] When a corrupt authority $\tilde{\fcecAuthority}_i$ sends the message $(\fkggetkeyini, \allowbreak \sid)$, $\Simulator$ runs a copy of $\Functionality_{\KG}$ on input that message. When $\Functionality_{\KG}$ sends $(\fkggetkeysim, \allowbreak \sid, \allowbreak \qid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$, $\Simulator$ forwards that message to $\tilde{\fcecAuthority}_i$.

    \item[Corrupt authority $\tilde{\fcecAuthority}_i$ ends setup.] When  $\tilde{\fcecAuthority}_i$ sends the message $(\fkggetkeyrep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs a copy of $\Functionality_{\KG}$ on input that message. When $\Functionality_{\KG}$ sends $(\fkggetkeyend, \allowbreak \sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\tilde{\fcecAuthority}_i}, \allowbreak \spk_{\tilde{\fcecAuthority}_i})$, $\Simulator$ sends $(\fcecsetupini, \allowbreak \sid)$ to the functionality $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecsetupsim, \allowbreak \sid, \allowbreak \tilde{\fcecAuthority}_i)$, the simulator $\Simulator$ sends the message $(\fcecsetuprep, \allowbreak \sid, \allowbreak \tilde{\fcecAuthority}_i)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecsetupend, \allowbreak \sid)$, $\Simulator$ sends the message $(\fkggetkeyend, \allowbreak \sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\tilde{\fcecAuthority}_i}, \allowbreak \spk_{\tilde{\fcecAuthority}_i})$ to $\tilde{\fcecAuthority}_i$.

    \item[Honest user (or provider) requests keys.] When $\Functionality_{\CEC}$ sends the message $(\fcecregistersim, \allowbreak \sid, \allowbreak \fcecUser_j)$, $\Simulator$ runs a copy of $\Functionality_{\KG}$ on input $(\fkgretrieveini, \allowbreak \sid)$. When the functionality $\Functionality_{\KG}$ sends the message $(\fkgretrievesim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \fkgvalue)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Honest user (or provider) receives and registers keys.] When $\Adversary$ sends $(\fkgretrieverep, \allowbreak \sid, \allowbreak \ssid)$, $\Simulator$ runs $\Functionality_{\KG}$ on input that message. When the functionality $\Functionality_{\KG}$ sends $(\fkgretrieveend, \allowbreak \sid, \allowbreak \fkgvalue)$, the simulator $\Simulator$ runs $(\ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j}) \gets \cecKeyGenU(\cecparams)$, sets $\sid_{\Freg} \gets (\fcecUser_j, \sid')$ and runs a copy of $\Functionality_{\Freg}$ on input the message $(\fregregisterini, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$. When $\Functionality_{\Freg}$ sends the message $(\fregregistersim, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Honest user (or provider) finalizes the registration of keys.] When $\Adversary$ sends the message $(\fregregisterrep, \allowbreak \sid_{\Freg})$, $\Simulator$ runs $\Functionality_{\Freg}$ on input that message. When $\Functionality_{\Freg}$ sends $(\fregregisterend, \allowbreak \sid_{\Freg})$, $\Simulator$ sends $(\fcecregisterrep, \allowbreak \sid, \allowbreak \fcecUser_j)$ to $\Functionality_{\CEC}$.

    \item[Corrupt user (or provider) requests keys.] When $\Adversary$ sends the message $(\fkgretrieveini, \allowbreak \sid)$, $\Simulator$ runs $\Functionality_{\KG}$ on input that message. When $\Functionality_{\KG}$ sends $(\fkgretrievesim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \fkgvalue)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt user (or provider) receives keys.]  When $\Adversary$ sends the message $(\fkgretrieverep, \allowbreak \sid, \allowbreak \ssid)$, $\Simulator$ runs $\Functionality_{\KG}$ on input that message. When $\Functionality_{\KG}$ sends $(\fkgretrieveend, \allowbreak \sid, \allowbreak \fkgvalue)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt user (or provider) registers keys.] When $\Adversary$ sends the message $(\fregregisterini, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$, $\Simulator$ runs $\Functionality_{\Freg}$ on input that message. When the functionality $\Functionality_{\Freg}$ sends $(\fregregistersim, \allowbreak \sid_{\Freg}, \allowbreak \spk_{\fcecUser_j})$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt user (or provider) finishes the registration of keys.]  When $\Adversary$ sends $(\fregregisterrep, \allowbreak \sid_{\Freg})$, $\Simulator$ runs $\Functionality_{\Freg}$ on input that message. When $\Functionality_{\Freg}$ sends $(\fregregisterend, \allowbreak \sid_{\Freg})$, the simulator $\Simulator$, acting as the corrupt user $\fcecUser_j$, sends $(\fcecregisterini, \allowbreak \sid)$ to  $\Functionality_{\CEC}$. When the functionality $\Functionality_{\CEC}$ sends $(\fcecregistersim, \allowbreak \sid, \allowbreak \fcecUser_j)$, the simulator $\Simulator$ sends $(\fcecregisterrep, \allowbreak \sid, \allowbreak \fcecUser_j)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends the message $(\fcecregisterend, \allowbreak \sid)$, $\Simulator$  sends $(\fregregisterend, \allowbreak \sid_{\Freg})$ to $\Adversary$.

    \item[Honest user sends a request to honest authority.]  When $\Functionality_{\CEC}$ sends $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$, the simulator $\Simulator$ parses the session identifier $\sid$ as $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$, sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \sid')$ and sends $(\fsmtsendsim, \allowbreak \sid_{\SMT}, \ssid, \allowbreak \SMTfleakage(\SMTmessage))$ to $\Adversary$, where $\SMTfleakage(\SMTmessage)$ is equal to the length of the message that the honest user sends to an authority in the $\fcecrequest$ interface.

    \item[Adversary forwards request.] When the adversary $\Adversary$ sends the message $(\fsmtsendrep, \allowbreak \sid_{\SMT}, \allowbreak \ssid)$ to reply to $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$, $\Simulator$ checks if a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$ is stored. If not, $\Simulator$ runs the procedure in Figure~\ref{fig:proc4}. After that, $\Simulator$ sends the message $(\fcecrequestrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Honest user sends a request to corrupt authority.]  When $\Functionality_{\CEC}$ sends $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \fcecwalletid)$, $\Simulator$ checks if a tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletid', \allowbreak  \fcecwalletnum)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\fcecwalletid' \allowbreak = \allowbreak \fcecwalletid$ is stored. If not, $\Simulator$ does the following:
    \begin{itemize}

        \item Pick up the stored tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletcount)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$. (This tuple is initialized to $\fcecwalletcount \allowbreak = \allowbreak 0$.)

        \item Set $\fcecwalletcount \allowbreak \gets \allowbreak \fcecwalletcount \allowbreak + \allowbreak 1$.

        \item Set $\fcecwalletnum \allowbreak \gets \allowbreak \fcecwalletcount$.

        \item Store $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletid, \allowbreak  \fcecwalletnum)$.

        \item Update $\fcecwalletcount$ in the tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletcount)$.

    \end{itemize}
    $\Simulator$ parses the session identifier $\sid$ as $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$, sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecUser_j,\fcecAuthority_i,\sid')$ and sends $(\fsmtsendsim, \allowbreak \sid_{\SMT}, \ssid, \allowbreak \SMTfleakage(\SMTmessage))$ to $\Adversary$, where $\SMTfleakage(\SMTmessage)$ is equal to the length of the message that the honest user sends to an authority in the $\fcecrequest$ interface.

    \item[Corrupt authority receives request from honest user.] When $\Functionality_{\CEC}$ sends $(\fcecrequestend, \allowbreak \sid, \allowbreak \fcecUser_j, \allowbreak \fcecrequestid)$ to a corrupt authority $\tilde{\fcecAuthority}_i$, $\Simulator$ retrieves the stored tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletid, \allowbreak  \fcecwalletnum)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\fcecwalletid$ was received before in the message $(\fcecrequestsim, \ldots)$ associated with the message $(\fcecrequestend, \ldots)$ received now. $\Simulator$ runs a copy of a user on input $(\fcecrequestini, \allowbreak \sid, \allowbreak \tilde{\fcecAuthority}_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$. (We remark that $\fcecwalletnum$ used a input to the copy of the user is not necessarily equal to the value of $\fcecwalletnum$ received by the honest user from the environment. However, it is enough to ensure that the same $\fcecwalletnum$ is used for each $\fcecwalletid$ received from $\Functionality_{\CEC}$, so that the copy of the user produces the same request for each $\fcecwalletid$.) When the copy of the user runs algorithm $\cecRequest$, $\Simulator$ uses the public key $\spk_{\fcecUser_j}$ that was previously computed for user $\fcecUser_j$. $\Simulator$ also uses the simulator $\mathcal{S}_s$ to compute a simulated proof $\pi_s$, and sets $\com$, $\com_{1}$ and $\com_{2}$ to be commitments to random messages. When the copy of the user sends the message $(\fsmtsendini, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecrequest \rangle)$ to $\Functionality_{\SMT}$, $\Simulator$ runs $\Functionality_{\SMT}$ on input that message. When $\Functionality_{\SMT}$ sends the message $(\fsmtsendsim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \SMTfleakage(\SMTmessage))$, $\Simulator$ runs $\Functionality_{\SMT}$ on input $(\fsmtsendrep, \allowbreak \sid, \allowbreak \ssid)$. When $\Functionality_{\SMT}$ sends $(\fsmtsendend, \allowbreak \sid, \allowbreak \langle \fcecrequestid, \allowbreak \cecrequest \rangle)$, $\Simulator$ forwards that message to $\tilde{\fcecAuthority}_i$.

    \item[Corrupt authority requests user keys.] When the adversary $\Adversary$ sends $(\fregretrieveini, \allowbreak \sid_{\Freg})$, $\Simulator$ runs a copy of $\Functionality_{\Freg}$ on input that message. When $\Functionality_{\Freg}$ sends $(\fregregistersim, \allowbreak \sid, \allowbreak \fregvalue)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt authority receives user keys.] When the adversary $\Adversary$ sends $(\fregregisterrep, \allowbreak \sid)$, $\Simulator$ runs $\Functionality_{\Freg}$ on input that message. When $\Functionality_{\Freg}$ sends $(\fregretrieveend, \allowbreak \sid_{\Freg}, \allowbreak \fregvalue)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt user requests credential.] When the adversary $\Adversary$ sends the message $(\fsmtsendini, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecrequest \rangle)$, $\Simulator$ runs $\Functionality_{\SMT}$ on input that message. When $\Functionality_{\SMT}$ sends $(\fsmtsendsim, \allowbreak \sid_{\SMT}, \allowbreak \ssid, \allowbreak \SMTfleakage(\SMTmessage))$, $\Simulator$ sends that message to $\Adversary$.

      \begin{figure}
    \begin{framed}
    \begin{center}
    Procedure: Retrieve user key
    \end{center}

      \begin{itemize}[leftmargin=*]

            \item The simulator $\Simulator$ sets $\sid_{\Freg} \allowbreak \gets \allowbreak (\fcecUser_j, \allowbreak \sid')$ and runs the functionality $\Functionality_{\Freg}$ on input $(\fregretrieveini, \allowbreak \sid_{\Freg})$. When $\Functionality_{\Freg}$ sends
            $(\fregretrievesim, \allowbreak \sid_{\Freg}, \allowbreak \ssid, \allowbreak \fregvalue')$, $\Simulator$ forwards that message to $\Adversary$.

            \item When $\Adversary$ sends $(\fregretrieverep, \allowbreak \sid_{\Freg}, \allowbreak \ssid)$, $\Simulator$ runs $\Functionality_{\Freg}$ on input that message. When $\Functionality_{\Freg}$ sends $(\fregretrieveend, \allowbreak \sid_{\Freg}, \allowbreak \fregvalue')$, if $\fregvalue' = \bot$, $\Simulator$ aborts, else $\Simulator$ stores $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$.

        \end{itemize}

       \end{framed}
    \caption{Procedure for simulating user key retrieval.}
    \label{fig:proc4}
    \end{figure}


    \item[Honest authority receives request from corrupt user.] When \newline the adversary $\Adversary$ sends $(\fsmtsendrep, \allowbreak \sid_{\SMT}, \allowbreak \ssid)$, $\Simulator$ runs $\Functionality_{\SMT}$ on input that message. When $\Functionality_{\SMT}$ sends the message $(\fsmtsendend, \allowbreak \sid_{\SMT}, \allowbreak \SMTmessage)$, $\Simulator$ parses the message $\SMTmessage$ as $\langle \fcecrequestid, \allowbreak \cecrequest \rangle$ and $\sid_{\SMT}$ as $(\fcecUser_j, \allowbreak \fcecAuthority_i, \allowbreak \sid')$. $\Simulator$ does the following:
    \begin{itemize}

        \item Abort if the authority $\fcecAuthority_i$ did not end the setup.

        \item Check if a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$ is stored. If not, $\Simulator$ runs the procedure in Figure~\ref{fig:proc4}.

        \item Abort if there is a stored tuple $(\fcecUser'_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\{\fcecrequestid, \fcecAuthority_i\} \allowbreak \in \allowbreak \fcecsetrequestid$. Here $\Simulator$ aborts because there is a request pending with the same request identifier $\fcecrequestid$ from $\fcecUser_j$ for $\fcecAuthority_i$, like it is done in the real protocol.

        \item If there is a stored tuple $(\fcecUser'_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest', \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\cecrequest' \allowbreak = \allowbreak \cecrequest$, then update the set $\fcecsetrequestid \allowbreak \gets \allowbreak \fcecsetrequestid \cup \{\fcecrequestid, \fcecAuthority_i\}$ in that tuple and take $\fcecwalletnum$ from that tuple. Else do the following:

        \begin{itemize}

            \item Follow the steps of an honest authority in $\mathrm{\Pi}_{\CEC}$ to verify $\cecrequest$. This involves verifying the request by running the algorithm $b \allowbreak \gets \allowbreak \cecRequestVf(\cecparams, \allowbreak \cecrequest, \allowbreak \spk_{\fcecUser_j})$. ($\Simulator$ checked before that the corrupt user registered $\spk_{\fcecUser_j}$  through the procedure in Figure~\ref{fig:proc4}.) Abort if $b \allowbreak = \allowbreak 0$.

            \item Parse $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$. Run the extractor $\mathcal{E}_{s}$ to extract the witness $\langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2} \rangle$ from $\pi_s$.

            \item If there is a tuple stored $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \langle \h, \allowbreak \com', \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s \rangle, \langle \cecmes'_{1}, \allowbreak \cecmes'_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$  such that $\com' \allowbreak = \allowbreak \com$ but $(\cecmes'_{1}, \allowbreak \cecmes'_{2}) \allowbreak \neq \allowbreak  (\cecmes_{1}, \allowbreak \cecmes_{2})$, $\Simulator$ outputs failure.

            \item If there is a stored tuple $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$ such that $\cecrequest \allowbreak = \allowbreak \allowbreak \langle \h, \allowbreak \com', \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s \rangle$ and $\com' \allowbreak = \allowbreak \com$, then take $\fcecwalletnum$ from that tuple and store a tuple $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$, where $\fcecsetrequestid \allowbreak \gets \allowbreak \{\fcecrequestid, \allowbreak \fcecAuthority_i\}$ and $\langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle$ is the witness that was output by the extractor $\mathcal{E}_{s}$. (We remark that $\fcecwalletnum$ is the same because, if $\com$ is the same in two requests, the partial signatures obtained from two different authorities can be aggregated, even if the values $(\com_{1}, \allowbreak \com_{2}, \allowbreak  \allowbreak \pi_s)$ are different.) Else do the following:

            \begin{itemize}

                \item Pick up the stored tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletcount)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$. (This tuple is initialized to $\fcecwalletcount \allowbreak = \allowbreak 0$.)

                \item Set $\fcecwalletcount \allowbreak \gets \allowbreak \fcecwalletcount \allowbreak + \allowbreak 1$.

                \item Set $\fcecwalletnum \allowbreak \gets \allowbreak \fcecwalletcount$.

                \item Store $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$, where $\fcecsetrequestid \allowbreak \gets \allowbreak \{\fcecrequestid, \fcecAuthority_i\}$.

                \item Update $\fcecwalletcount$ in the tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletcount)$.

            \end{itemize}

        \end{itemize}

        $\Simulator$ sends $(\fcecrequestini, \allowbreak \sid, \allowbreak \fcecAuthority_i, \allowbreak \fcecrequestid, \allowbreak \fcecwalletnum)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecrequestsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecAuthority_i)$, $\Simulator$ sends the message $(\fcecrequestrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \end{itemize}

    \item[Honest authority issues attribute.] When the functionality $\Functionality_{\CEC}$ sends the message $(\fcecissuesim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecAuthority_i, \allowbreak \fcecUser_j)$, $\Simulator$ parses $\sid$ as $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n, \allowbreak \sid')$, sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecAuthority_i, \allowbreak \fcecUser_j, \allowbreak \sid')$ and sends the message $(\fsmtsendsim, \allowbreak \sid_{\SMT}, \allowbreak \ssid, \allowbreak \SMTfleakage(\SMTmessage))$, where $\SMTfleakage(\SMTmessage)$ is the length of the message that an honest authority sends in the $\fcecissue$ interface.

    \item[Adversary forwards issuance.] When the adversary $\Adversary$ sends the message $(\fsmtsendrep, \allowbreak \sid_{\SMT}, \allowbreak \ssid)$, $\Simulator$ sends $(\fcecissuerep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Corrupt user receives issuance.] When $\Functionality_{\CEC}$ sends the message $(\fcecissueend, \allowbreak \sid, \allowbreak \fcecrequestid, \allowbreak \fcecAuthority_i)$ to a corrupt user $\fcecUser_j$, the simulator $\Simulator$ finds the stored tuple $(\fcecUser'_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and there is element $\{\fcecrequestid', \allowbreak \fcecAuthority'_i\} \allowbreak \in \allowbreak \fcecsetrequestid$ such that $\fcecrequestid' \allowbreak = \allowbreak \fcecrequestid$ and $\fcecAuthority'_i \allowbreak = \allowbreak \fcecAuthority_i$. $\Simulator$ parses $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$. $\Simulator$ parses the secret key $\ssk_{\fcecAuthority_i}$ as $(x_i, \allowbreak y_{i,1}, \allowbreak y_{i,2})$, computes $c = \h^{x_i} \prod_{j=1}^{2} \com_j^{y_{i,j}}$ and sets the blinded signature share $\hat{\sigma}_{i} \allowbreak \gets \allowbreak (\h, \allowbreak c)$ as in $\mathrm{\Pi}_{\CEC}$. If a tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletnum', \allowbreak \cecset)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$ is not stored, $\Simulator$ stores a tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \{i\})$, else updates $\cecset \allowbreak \gets \allowbreak \cecset \cup \{i\}$ in the tuple $(\sid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \cecset)$. After that, $\Simulator$ removes  $\{\fcecrequestid, \allowbreak \fcecAuthority_i\}$ from the set $\fcecsetrequestid$ in the tuple $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \cecrequest, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$. Finally, $\Simulator$ sets $\sid_{\SMT} \allowbreak \gets \allowbreak (\fcecAuthority_i, \allowbreak \fcecUser_j, \allowbreak \sid')$, sets $\cecresponse \gets \hat{\sigma}_{i}$ and sends $(\fsmtsendend, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecresponse \rangle)$ to $\Adversary$.

    \item[Corrupt authority issues attribute.] When a corrupt authority $\tilde{\fcecAuthority}_i$ sends the message $(\fsmtsendini, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecresponse \rangle)$, $\Simulator$ runs $\Functionality_{\SMT}$ on input that message. When the functionality $\Functionality_{\SMT}$ sends $(\fsmtsendsim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \SMTfleakage(\SMTmessage))$, $\Simulator$ sends that message to $\Adversary$.

    \item[Honest user receives issuance from corrupt authority.] After the adversary $\Adversary$ sends the message $(\fsmtsendrep, \allowbreak \sid, \allowbreak \ssid)$, the simulator $\Simulator$ runs $\Functionality_{\SMT}$ on input that message. When  $\Functionality_{\SMT}$ sends $(\fsmtsendend, \allowbreak \sid_{\SMT}, \allowbreak \langle \fcecrequestid, \allowbreak \cecresponse \rangle)$, the simulator $\Simulator$  parses $\sid_{\SMT}$ as $(\fcecAuthority_i, \allowbreak \fcecUser_j, \allowbreak \sid')$ and runs the copy of the user $\fcecUser_j$ on input that message. We remark that the copy of the user finds the request identifier $\fcecrequestid$ of the request associated with this issuance message, or aborts if it is not found. When the copy of the user outputs $(\fcecissueend, \allowbreak \sid, \allowbreak \fcecrequestid, \allowbreak \fcecAuthority_i)$, $\Simulator$ sends $(\fcecissueini, \allowbreak \sid, \allowbreak \fcecUser_j, \allowbreak \fcecrequestid)$  to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecissuesim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecAuthority_i, \allowbreak \fcecUser_j)$, $\Simulator$ sends $(\fcecissuerep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Honest user begins spending.] When $\Functionality_{\CEC}$ sends $(\fcecspendsim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ sends $(\fnymsendsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fnymleakage(\fnymmessage))$ to $\Adversary$, where $\fnymleakage(\fnymmessage)$ is the length of the message $\langle \cecpayment, \allowbreak \cecpaymentinfo \rangle$ sent by an honest user in the spend interface. Here we consider that the length does not change depending on the number of spent coins. This can be achieved by setting a maximum number of coins to be spent and sending always messages whose length is the length of the message when the maximum number of coins is spent.

    \item[Adversary forwards spending.] When $\Adversary$ sends $(\fnymsendrep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ sends $(\fcecspendrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Corrupt provider receives spending.]  When $\Functionality_{\CEC}$ sends the message $(\fcecspendend, \allowbreak \fcecpaymentid, \allowbreak V, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym)$, $\Simulator$ sets the payment $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ by running the procedure in Figure~\ref{fig:proc2}. $\Simulator$ stores $(\sid, \allowbreak \fcecpaymentid, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo)$ and sends the message $(\fnymsendend, \allowbreak \sid, \langle \cecpayment, \cecpaymentinfo \rangle, \allowbreak \fcecnym)$  to $\Adversary$.

    \item[Corrupt user begins spending.] When the adversary $\Adversary$ sends  $(\fnymsendini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$,  $\Simulator$ runs $\Functionality_{\NYM}$ on input that message. When $\Functionality_{\NYM}$ sends $(\fnymreplysim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fnymleakage(\fnymmessage))$, $\Simulator$ sends that message to $\Adversary$.

    \item[Honest provider receives spending from corrupt user.] After the adversary $\Adversary$ sends the message $(\fnymreplyrep, \allowbreak \sid, \allowbreak \qid)$, the simulator $\Simulator$ runs $\Functionality_{\NYM}$ on input that message. When the functionality $\Functionality_{\NYM}$ sends $(\fnymsendend, \allowbreak \sid, \langle \cecpayment, \cecpaymentinfo \rangle, \allowbreak \fcecnym)$, $\Simulator$ runs $b \allowbreak \gets \allowbreak \cecSpendVf(\spk, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo)$. If $b \allowbreak = \allowbreak 0$, $\Simulator$ aborts. Otherwise $\Simulator$ runs the procedure in Figure~\ref{fig:proc1} to check the payment and store a tuple $(\cecpayment, \allowbreak \cecpaymentinfo, \langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$. After that, $\Simulator$ checks that the algorithm for identification of double spenders identifies the double spender properly by running the procedure in Figure~\ref{fig:proc3}.


    $\Simulator$ sets $\fcecdsset \allowbreak \gets \allowbreak \{l_k | k \in [0,V-1]\}$ and sends $(\fcecspendini, \allowbreak \sid, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ to $\Functionality_{\CEC}$. When the functionality $\Functionality_{\CEC}$ sends the message $(\fcecspendsim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ sends  $(\fcecspendrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Honest provider begins deposit of honest user $\fcecUser_j$ payment.] If there are not corrupt authorities, $\Functionality_{\CEC}$ sends $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid)$ and $\Simulator$ picks up random $\cecpaymentinfo \allowbreak \gets \allowbreak \fcecunivpaymentinfo$ and $V \allowbreak \gets \allowbreak [1,L]$. If there is at least one corrupt authority, $\Functionality_{\CEC}$ sends the message $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid, \allowbreak V, \allowbreak \cecpaymentinfo)$.

    After receiving the message from $\Functionality_{\CEC}$, $\Simulator$ runs the procedure in Figure~\ref{fig:proc2} to simulate an honest user payment $\cecpayment$. $\Simulator$ runs a copy of $\Functionality_{\BB}$ on input $(\fbbwriteini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle)$. When $\Functionality_{\BB}$ sends $(\fbbwritesim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Honest provider starts deposit of corrupt user $\fcecUser_j$ payment.] When $\Functionality_{\CEC}$ sends the message $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$, $\Simulator$ finds the tuple $(\cecpayment, \allowbreak \cecpaymentinfo', \langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$, where $\cecpayment$ is  $(\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V'-1]}, \allowbreak V', \allowbreak C, \allowbreak \pi_v)$, such that $\ssk_{\fcecUser_j}$ is the secret key corresponding to the public key registered by the corrupt user $\fcecUser_j$, $\cecsn$ is the serial number associated with the wallet $\fcecwalletnum$, $V' \allowbreak = \allowbreak V$, $\langle l_k \rangle_{k\in[0,V-1]} = \fcecdsset$, and $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$. $\Simulator$ runs  $\Functionality_{\BB}$ on input $(\fbbwriteini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle)$. When $\Functionality_{\BB}$ sends $(\fbbwritesim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ forwards that message to $\Adversary$. We remark that $\Functionality_{\CEC}$ sends $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ instead $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid)$ when the deposit corresponds to a payment made by a corrupt user and when at least one authority is corrupt. When all the authorities are honest, the adversary in the real world does not have access to the information in $\Functionality_{\BB}$, and thus the simulator does not need to learn from $\Functionality_{\CEC}$ whether a payment made by a corrupt user has been deposited.

    \item[Honest provider ends deposit.] When the adversary $\Adversary$ sends the message $(\fbbwriterep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs $\Functionality_{\BB}$ on input that message. When $\Functionality_{\BB}$ sends $(\fbbwriteend, \allowbreak \sid)$, $\Simulator$ sends $(\fcecdepositrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \begin{figure}
    \begin{framed}
    \begin{center}
    Procedure: Simulate honest user payment
    \end{center}

    \begin{itemize}[leftmargin=*]

        \item Pick random $r \gets \Zp$ and $r' \gets \Zp$.

        \item Compute $\sigma' = (\h',s') \gets (\ga^{r'}, \ga^{r r'})$.

        \item Compute $\kappa \gets \gb^{r}$.

        \item For $k \allowbreak \in \allowbreak [0, \allowbreak V-1]$, pick random $S_k \allowbreak \gets \allowbreak \Ga$, $T_k \allowbreak \gets \allowbreak \Ga$ and $A_k \allowbreak \gets \allowbreak \Ga$.

        \item Pick random $C \allowbreak \gets \allowbreak \Ga$.

        \item Run the simulator $\mathcal{S}_{v}$ to compute a simulated proof $\pi_v$.

    \end{itemize}

    \end{framed}
    \caption{Procedure for simulating an honest user payment.}
    \label{fig:proc2}
    \end{figure}



    \begin{figure}
    \begin{framed}
    \begin{center}
    Procedure: Check Corrupt User Payment
    \end{center}

    \begin{itemize}[leftmargin=*]

        \item $\Simulator$ parses $\cecpayment$ as $(\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$.

        \item $\Simulator$ runs the extractor $\mathcal{E}_v$ to extract the witness $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$ from the proof $\pi_v$.

        \item $\Simulator$ parses $\sigma'$ as $(\h', \allowbreak s')$ and computes $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$.

        \item $\Simulator$ runs the verification equation $\e(\hat{\h}, \allowbreak \tilde{\alpha} \allowbreak \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn}) \allowbreak =  \allowbreak \e(\hat{s}, \allowbreak \gb)$ of the Pointcheval-Sanders signature scheme. If the verification equation does not hold, $\Simulator$ outputs failure.

        \item $\Simulator$ finds a tuple $(\fcecUser_j, \allowbreak \fcecwalletnum, \allowbreak \fcecsetrequestid, \allowbreak \langle \h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s \rangle, \allowbreak \langle \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2}  \rangle)$ such that $\cecmes_{1} \allowbreak = \allowbreak \ssk_{\fcecUser_j}$ and $\cecmes_{2} \allowbreak = \allowbreak \cecsn$. If such a tuple is not stored, $\Simulator$ outputs failure, else $\Simulator$ takes $\fcecUser_j$ and $\fcecwalletnum$ from that tuple. We remark that, in this tuple, $\fcecUser_j$ is always the identity of a corrupt user.

        \item $\Simulator$ finds a tuple $(\sid, \allowbreak \fcecUser'_j, \allowbreak \fcecwalletnum', \allowbreak \cecset)$ such that $\fcecUser'_j \allowbreak = \allowbreak \fcecUser_j$ and $\fcecwalletnum' \allowbreak = \allowbreak \fcecwalletnum$.  $\Simulator$ outputs failure if such a tuple is not stored, or if $|\cecset| < t-\tilde{t}$, where $\tilde{t}$ is the number of corrupt authorities.

       \item For $k \in [0,V-1]$, $\Simulator$ checks whether $S_k = \delta^{1/(\cecsn+l_k+1)}$ and $T_k \allowbreak = \allowbreak \ga^{\ssk_{\fcecUser_j} + R_k/(\cecsn+l_k+1)}$, where $R_k \gets H'(\cecpaymentinfo,k)$. If any of those checks fails, $\Simulator$ outputs failure.

        \item $\Simulator$ stores the tuple $(\cecpayment, \allowbreak \cecpaymentinfo, \langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$.

  \end{itemize}

  \end{framed}
  \caption{Procedure for checking a corrupt user payment.}
  \label{fig:proc1}
\end{figure}


    \begin{figure}
    \begin{framed}
    \begin{center}
        Procedure: Check Double Spending
    \end{center}

       \begin{itemize}[leftmargin=*]

        \item $\Simulator$ takes the tuple $(\cecpayment, \allowbreak \cecpaymentinfo, \langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$ for the payment made by a corrupt user.

        \item For all the stored tuples $(\cecpayment', \allowbreak \cecpaymentinfo', \langle \ssk'_{\fcecUser_j}, \allowbreak \cecsn', \allowbreak r', \allowbreak o'_c, \allowbreak \langle l'_k, \allowbreak o'_{a_k}, \allowbreak \mu'_k, \allowbreak o'_{\mu_k} \rangle_{k=0}^{V'-1} \rangle)$, $\Simulator$ checks whether $\ssk'_{\fcecUser_j} \allowbreak = \allowbreak \ssk_{\fcecUser_j}$, $\cecsn' \allowbreak = \allowbreak \cecsn$ and $\langle l'_k \rangle_{k\in[0,V'-1]} \cap \langle l_k \rangle_{k\in[0,V-1]} \allowbreak \neq \allowbreak \emptyset$, which means that there is a double spending. $\Simulator$ sets $\cecPK$ to contain all the registered public keys and runs the algorithm $c \allowbreak \gets \allowbreak \cecIdentify(\cecparams, \allowbreak \cecPK, \allowbreak \cecpayment, \allowbreak \cecpayment', \allowbreak \cecpaymentinfo, \allowbreak \cecpaymentinfo')$. Then $\Simulator$ proceeds as follows:

        \begin{itemize}

            \item If there is double spending, $\Simulator$ does the following:
            \begin{itemize}

                \item If $\cecpaymentinfo \allowbreak = \allowbreak \cecpaymentinfo'$ and $c \allowbreak \neq \allowbreak \cecpaymentinfo$, $\Simulator$ outputs failure. We note that authorities verify that $\cecpaymentinfo$ contains an identifier of the provider that deposited the payment. This avoids that an honest provider can be found guilty when an adversarial provider e.g.\ double deposits a payment with payment information $\cecpaymentinfo$ that contains the identifier of an honest provider.

                \item If $\cecpaymentinfo \allowbreak \neq \allowbreak \cecpaymentinfo'$ and $c \allowbreak \neq \allowbreak \spk_{\fcecUser_j}$, where $\spk_{\fcecUser_j}$ is the public key associated with secret key $\ssk_{\fcecUser_j}$, $\Simulator$ outputs failure.

            \end{itemize}

            \item If there is not double spending, and if $c \allowbreak = \allowbreak \spk_{\fcecUser_j}$, where $\spk_{\fcecUser_j}$ is a public key associated with an honest user, $\Simulator$ outputs failure. We remark that it is possible for the adversary to produce two payments where there is not double-spending, and yet the algorithm $\cecIdentify$ detects double spending. When that happens, we must ensure that algorithm $\cecIdentify$ does not output the public key of an honest user. We recall that authorities verify that $\cecpaymentinfo$ contains an identifier of the provider that deposited the payment, which also avoids an honest provider from being framed in this case.

        \end{itemize}

    \end{itemize}

      \end{framed}
  \caption{Procedure for checking double spending.}
  \label{fig:proc3}
\end{figure}


    \item[Corrupt provider begins deposit.] When $\Adversary$ sends $(\fbbwriteini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle)$, the simulator $\Simulator$ checks if a tuple $(\sid, \allowbreak \fcecpaymentid, \allowbreak \cecpayment', \allowbreak \cecpaymentinfo')$ such that $\cecpayment' \allowbreak = \allowbreak \cecpayment$ and  $\cecpaymentinfo' \allowbreak = \allowbreak \cecpaymentinfo$ is stored. If it is stored, which means that this is a payment that was sent to $\Adversary$ by the simulator acting as an honest user, $\Simulator$ takes $\fcecpaymentid$ from that tuple and proceeds with step 2 below. Otherwise we are in the case of a payment that a corrupt user sent to a corrupt provider, and thus $\Simulator$ did not receive it during the spending phase. $\Simulator$ proceeds with step 1.

    \noindent \emph{Step 1.} $\Simulator$ proceeds as follows:
    \begin{itemize}

        \item $\Simulator$ runs $b \allowbreak \gets \allowbreak \cecSpendVf(\spk, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo)$. If $b \allowbreak = \allowbreak 0$, the simulator $\Simulator$ aborts.

        \item $\Simulator$ runs the procedure in Figure~\ref{fig:proc1} to store $(\cecpayment, \allowbreak \cecpaymentinfo, \langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$.

        \item The simulator $\Simulator$ checks that the algorithm for identification of double spenders identifies the double spender properly by running the procedure in Figure~\ref{fig:proc3}.

    \end{itemize}
    $\Simulator$ sets $\fcecdsset \allowbreak \gets \allowbreak \{l_k | k \in [0,V-1]\}$, picks a random pseudonym $\fcecnym \allowbreak \gets \allowbreak \fcecunivnym$, takes the identity $\fcecProvider_k$ of the corrupt provider that sent the message $(\fbbwriteini, \ldots)$, and sends $(\fcecspendini, \allowbreak \sid, \allowbreak \fcecwalletnum, \allowbreak V, \allowbreak \fcecdsset, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym, \allowbreak \fcecProvider_k)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends the message $(\fcecspendsim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ sends  $(\fcecspendrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends the message $(\fcecspendend, \allowbreak \fcecpaymentid, \allowbreak V, \allowbreak \cecpaymentinfo, \allowbreak \fcecnym)$, $\Simulator$ proceeds with step 2.



    \noindent \emph{Step 2.} $\Simulator$ sends $(\fcecdepositini, \allowbreak \sid, \allowbreak \fcecpaymentid)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecdepositsim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs a copy of $\Functionality_{\BB}$ on input the message $(\fbbwriteini, \allowbreak \sid, \allowbreak \langle \cecpayment, \allowbreak \cecpaymentinfo \rangle)$. When $\Functionality_{\BB}$ sends the message $(\fbbwritesim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt provider ends deposit.] When the adversary $\Adversary$ sends the message $(\fbbwriterep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs the copy of $\Functionality_{\BB}$ on input that message. When $\Functionality_{\BB}$ sends $(\fbbwriteend, \allowbreak \sid)$, $\Simulator$ sends $(\fcecdepositrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$. When $\Functionality_{\CEC}$ sends $(\fcecdepositend, \allowbreak \sid, \allowbreak \fcecpaymentid)$, $\Simulator$ sends  $(\fbbwriteend, \allowbreak \sid)$ to $\Adversary$.

    \item[Honest authority runs deposit verification.] When $\Functionality_{\CEC}$ sends the message $(\fcecdepvfsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fcecusers', \allowbreak \fcecnumdeposits)$, for all $\fcecUser_j \allowbreak \in \allowbreak \fcecusers'$, $\Simulator$ runs the procedure in Figure~\ref{fig:proc4}. After that, for $i=1$ to $\fcecnumdeposits$, $\Simulator$ does the following:
    \begin{itemize}

        \item Send $(\fbbgetbbsim, \allowbreak \sid, \allowbreak \qid)$ to $\Adversary$.

        \item Receive $(\fbbgetbbrep, \allowbreak \sid, \allowbreak \qid)$ from $\Adversary$.

    \end{itemize}
    $\Simulator$ sends $(\fcecdepvfrep, \allowbreak \sid, \allowbreak \qid)$ to $\Functionality_{\CEC}$.

    \item[Corrupt authority starts reading of bulletin board.] When $\Adversary$ sends $(\fbbgetbbini, \allowbreak \sid, \allowbreak \fbbindex)$, $\Simulator$ runs $\Functionality_{\BB}$ on input that message. When $\Functionality_{\BB}$ sends $(\fbbgetbbsim, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ forwards that message to $\Adversary$.

    \item[Corrupt authority ends reading of bulletin board.] When the adversary $\Adversary$ sends $(\fbbgetbbrep, \allowbreak \sid, \allowbreak \qid)$, $\Simulator$ runs $\Functionality_{\BB}$ on input that message. When $\Functionality_{\BB}$ sends $(\fbbgetbbend, \allowbreak \sid, \allowbreak \fbbmessage')$, $\Simulator$ parses $\fbbmessage'$ as $(\fcecProvider_k, \allowbreak \cecpayment, \allowbreak \cecpaymentinfo)$. If $(\cecpayment, \allowbreak \cecpaymentinfo)$ is a payment that was computed by $\Simulator$, $\Simulator$ parses $\cecpayment$ as $(\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ and checks whether any serial number $S_k$ is equal to any of the other serial numbers stored in the payments in $\Functionality_{\BB}$. If that is the case, $\Simulator$ outputs failure. Otherwise $\Simulator$ sends $(\fbbgetbbend, \allowbreak \sid, \allowbreak \fbbmessage')$ to $\Adversary$. We remark that payments computed by the adversary were already checked before by $\Simulator$ through the procedure in Figure~\ref{fig:proc3}.

\end{description}

\begin{theorem} \label{th:all}
	When a subset of users $\fcecUser_j$, a subset of providers $\fcecProvider_k$ and up to $t-1$ authorities $\fcecAuthority_i$ are corrupt, $\mathrm{\Pi}_{\CEC}$ securely realizes $\Functionality_{\CEC}$ in the random oracle model and in the $(\Functionality_{\SMT}, \allowbreak \Functionality_{\NYM}, \allowbreak \Functionality_{\KG}, \allowbreak \Functionality_{\Freg}, \allowbreak \Functionality_{\BB})$-hybrid model if the non-interactive proof of knowledge scheme is zero-knowledge and provides weak simulation extractability, the signature scheme by Pointcheval-Sanders in the RO model is unforgeable, the commmitment scheme is hiding and binding, the function in~\S\ref{subsec:pseudorandomfunction} is pseudorandom, and the hash function $H'$ is collision-resistant.
\end{theorem}

\paragraph{Proof of Theorem~\ref{th:all}.}
We show by means of a series of hybrid games that the environment $\Environment$ cannot distinguish between the ensemble $\RealEnsemble_{\mathrm{\Pi}_{\CEC},\Adversary,\Environment}$ and the ensemble $\IdealEnsemble_{\Functionality_{\CEC},\Simulator,\Environment}$ with non-negligible probability. We denote by $\Prob[\Gam i]$ the probability that the environment distinguishes $\Gam i$ from the real-world protocol.
\begin{description}[leftmargin=*]

	\item[$\Gam 0$:] This game corresponds to the execution of the real-world protocol. Therefore, $\Prob[\Gam 0] = 0$.

	\item[$\Gam 1$:] This game proceeds as $\Gam 0$, except that $\Gam 1$ runs the extractor $\mathcal{E}_s$ for the non-interactive ZK proofs of knowledge $\pi_s$ sent by the adversary. Under the weak simulation extractability property of the proof system (Definition~\ref{def:weakse}), we have that $|\Pr[\Gam 1]-\Pr[\Gam 0]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{ext}}$.

	\item[$\Gam 2$:] This game proceeds as $\Gam 1$, except that $\Gam 2$ outputs failure if two request messages were received from the adversary with commitments $\com'$ and $\com$ and proofs $\pi'_s$ and $\pi_s$ such that $\com' \allowbreak = \allowbreak \com$ but, after extraction of the witnesses $(\cecmes'_{1}, \allowbreak \cecmes'_{2}, \allowbreak o', \allowbreak o'_{1}, \allowbreak o'_{2})$ from $\pi'_s$ and $(\cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2})$ from $\pi_s$, $(\cecmes'_{1}, \allowbreak \cecmes'_{2}) \allowbreak \neq \allowbreak  (\cecmes_{1}, \allowbreak \cecmes_{2})$. Under the binding property of the commitment scheme, we have that $|\Pr[\Gam 2]-\Pr[\Gam 1]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{bin}}$.

	\begin{proof}
	 Given an adversary that makes $\Gam 2$ output failure with non-negligible probability, we construct an algorithm $B$ that breaks the binding property of the commitment scheme with non-negligible probability. $B$ works as follows. $B$ receives the parameters of the Pedersen commitment scheme $\paramscom \allowbreak = (\ga, \allowbreak \gamma_1, \allowbreak \gamma_2)$ from the challenger. When running $\Functionality_{\KG}$, $B$ uses those parameters to set the values $(\ga, \allowbreak \gamma_1, \allowbreak \gamma_2)$ in the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$. When the adversary sends two requests with commitments $\com'$ and $\com$ and proofs $\pi'_s$ and $\pi_s$ such that $\com' \allowbreak = \allowbreak \com$ but, after extraction of the witnesses $(\cecmes'_{1}, \allowbreak \cecmes'_{2}, \allowbreak o', \allowbreak o'_{1}, \allowbreak o'_{2})$ from $\pi'_s$ and $(\cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2})$ from $\pi_s$, it holds that $(\cecmes'_{1}, \allowbreak \cecmes'_{2}) \allowbreak \neq \allowbreak  (\cecmes_{1}, \allowbreak \cecmes_{2})$, $B$ sends $(\com, \cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \cecmes'_{1}, \allowbreak \cecmes'_{2}, \allowbreak o')$ to the challenger.
	\end{proof}

	\item[$\Gam 3$:] This game proceeds as $\Gam 2$, except that $\Gam 3$ runs the extractor $\mathcal{E}_v$ for the non-interactive ZK proofs of knowledge $\pi_v$ sent by the adversary. Under the weak simulation extractability property of the proof system (Definition~\ref{def:weakse}), we have that $|\Pr[\Gam 3]-\Pr[\Gam 2]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{ext}}$.

	\item[$\Gam 4$:] This game proceeds as $\Gam 3$, except that, after extracting the witness $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$ from a proof $\pi_v$, $\Gam 4$ takes the payment $\cecpayment \allowbreak = \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that contains $\pi_v$ and parses $\sigma'$ as $(\h', \allowbreak s')$. $\Gam 4$ computes $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$. Then $\Gam 4$ outputs failure if $\hat{\sigma}$ is not a valid signature. As shown below, the computation $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$ always produces a valid signature, and thus $|\Pr[\Gam 4]-\Pr[\Gam 3]| \allowbreak = \allowbreak 0$.
	\begin{proof}
	We follow the proof in~\cite{cryptoeprint:2022:011}. We observe that, after extraction from $\pi_v$ is successful, $\kappa$ is of the form $\kappa \allowbreak \gets \allowbreak  \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$. We also know that the following equality holds
	\begin{equation*}
	    \e(\h', \kappa) = \e(s',\gb)
	\end{equation*}
	If we replace $\kappa$ by $\tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$, we have that
	\begin{equation*}
	    \e(\h', \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}) = \e(s',\gb)
	\end{equation*}
	If we now multiply the two sides of the equality by $\e(\h',\gb^{-r})$, we have that
	\begin{equation*}
	    \e(\h', \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}) \e(\h',\gb^{-r}) = \e(s',\gb) \e(\h',\gb^{-r})
	\end{equation*}
	and this gives us
	\begin{equation*}
	    \e(\h', \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn}) = \e(s' (\h')^{-r},\gb)
	\end{equation*}
	which is the verification equation of the Pointcheval-Sanders signature scheme for the signature $(\h', s' (\h')^{-r})$. Therefore, the computation $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$ always produces a valid signature.
	\end{proof}


	\item[$\Gam 5$:] This game proceeds as $\Gam 4$, except that $\Gam 5$ outputs failure if, after computing the signature $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$ on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$, it is the case that the adversary was not issued at least $t-\tilde{t}$ signatures from $t-\tilde{t}$ different authorities on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Under the unforgeability property of Pointcheval-Sanders signatures in the random oracle model, we have that $|\Pr[\Gam 5]-\Pr[\Gam 4]| \leq \Adv_{\Adversary}^{\mathsf{unf}}\cdot ((n-\tilde{t})!/((t-1-\tilde{t})!(n-t+1)!))$, where $n$ is the number of authorities, $t$ is the threshold and $\tilde{t}$ is the number of corrupt authorities.
	\begin{proof}
	 We follow the proof in~\cite{cryptoeprint:2022:011}. We construct an algorithm $B$ that interacts with the challenger of the existential unforgeability game in the RO model (Definition~\ref{def:unfro}) and the adversary $\Adversary$ and that shows that, if $\Adversary$ makes $\Gam 5$ output failure with non-negligible probability, then $\Adversary$ can be used by $B$ to break the existential unforgeability property in the RO model of Pointcheval-Sanders signatures.

	 $B$ receives a public key $(\theta, \allowbreak \tilde{\alpha}, \allowbreak \beta_1, \tilde{\beta}_1, \allowbreak \beta_2, \allowbreak \tilde{\beta}_2)$ from the challenger. To set up the keys when running functionality $\Functionality_{\KG}$, $B$ proceeds as follows.
	 \begin{itemize}

        \item $B$ uses the bilinear map setup $\theta$ to set $\cecparams$. $B$ uses the public key received from the challenger to set the verification key $\spk = (\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \allowbreak \beta_{2}, \tilde{\beta}_{2})$.

        \item Let $\mathbb{T}$ be the set of indices of corrupt authorities. Let $\mathbb{U}$ be a set of indices of size $t-1-|\mathbb{T}|$ picked at random from $[1,n] \allowbreak \setminus \allowbreak \mathbb{T}$. Let $\mathbb{S}' \gets \mathbb{T} \cup \mathbb{U}$. To compute the secret keys and public keys of the authorities $\fcecAuthority_i$ such that $i \allowbreak \in \allowbreak \mathbb{S}'$, $B$ picks random $(x_i, \allowbreak y_{i,1},  \allowbreak y_{i,2}) \allowbreak \gets \allowbreak \Zp$ and computes $\spk_{\fcecAuthority_i} \allowbreak = \allowbreak (\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1}, \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2}) \allowbreak \gets \allowbreak (\gb^{x_i}, \allowbreak \ga^{y_{i,1}}, \allowbreak \gb^{y_{i,1}}, \allowbreak \ga^{y_{i,2}}, \allowbreak \gb^{y_{i,2}})$.

        \item Let $\mathbb{S} \allowbreak \gets \allowbreak \mathbb{S}' \allowbreak \cup \allowbreak \{0\}$ and let $\mathbb{D} \allowbreak = \allowbreak [1,n] \setminus \mathbb{S}'$. To compute the public keys of the remaining authorities, i.e. the authorities in the set $\mathbb{D}$, $B$ does the following. Let $(\tilde{\alpha}_0, \allowbreak \beta_{0,1}, \allowbreak \tilde{\beta}_{0,1}, \allowbreak \beta_{0,2}, \allowbreak \tilde{\beta}_{0,2}) \gets (\tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \allowbreak \beta_{2}, \tilde{\beta}_{2})$. For all $d \in \mathbb{D}$:
        \begin{itemize}

            \item For all $i \in \mathbb{S}$, evaluate at $d$ the Lagrange basis polynomials
            \begin{equation*}
                l_i = [\prod_{j\in\mathbb{S},j\neq i} (d-j)] [\prod_{j\in\mathbb{S},j\neq i} (i-j)]^{-1}\ \mathrm{mod}\ \p
            \end{equation*}

            \item  For all $i \in \mathbb{S}$, take $(\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1}, \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2})$ and then do $\spk_{\fcecAuthority_d} = (\tilde{\alpha}_d, \allowbreak \beta_{d,1}, \allowbreak \tilde{\beta}_{d,1}, \allowbreak \beta_{d,2}, \allowbreak \tilde{\beta}_{d,2}) = ( \prod_{i \in \mathbb{S}} \tilde{\alpha}_i^{l_i}, \allowbreak \prod_{i \in \mathbb{S}} \beta_{i,1}^{l_i}, \allowbreak \prod_{i \in \mathbb{S}} \tilde{\beta}_{i,1}^{l_i},  \allowbreak \prod_{i \in \mathbb{S}} \beta_{i,2}^{l_i}, \allowbreak \prod_{i \in \mathbb{S}} \tilde{\beta}_{i,2}^{l_i})$.

        \end{itemize}

    \end{itemize}

    To reply the random oracle queries $H(\com)$ of the adversary $\Adversary$, $B$ forwards the query $\com$ to the random oracle provided by the challenger and sends $\Adversary$ the response $\h$ given by the challenger.

    When $\Adversary$ sends a valid request $\cecrequest \allowbreak \gets \allowbreak (\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$, $B$ runs the extractor $\mathcal{E}_{s}$ to extract the witness $(\cecmes_{1}, \allowbreak \cecmes_{2}, \allowbreak o, \allowbreak o_{1}, \allowbreak o_{2})$ from $\pi_s$. $B$ outputs failure if two request messages were received with commitments $\com'$ and $\com$ and proofs $\pi'_s$ and $\pi_s$ such that $\com' \allowbreak = \allowbreak \com$ but, after extraction of the witnesses from $\pi'_s$ and $\pi_s$, $(m'_1, \allowbreak m'_2) \allowbreak \neq \allowbreak  (m_1, \allowbreak m_2)$. As shown in $\Gam 2$, the probability that $B$ fails is negligible if the commitment scheme is binding. This guarantees that $\com$ is different for each tuple of messages $(m'_1, \allowbreak m'_2)$, which is necessary when querying the signing oracle.

    If the request is sent to an authority $\fcecAuthority_{i}$ such that $i \allowbreak \in \allowbreak \mathbb{U}$, $B$ computes an issuance message by following $\mathrm{\Pi}_{\CEC}$ and stores $(m_1, \allowbreak m_2, \allowbreak \fcecAuthority_i)$. (We note that in this case $B$ knows the secret key of the authority.) If the request is sent to $\fcecAuthority_{d}$ such that $d \allowbreak \in \allowbreak \mathbb{D}$, $B$ proceeds as follows:

    \begin{itemize}

        \item $B$ submits the message tuple $(m_1, \allowbreak m_2)$ that was extracted by $\mathcal{E}_{s}$ and the commitment $\com$ to the signing oracle provided by the challenger. The challenger sends a signature $\sigma_{0} \allowbreak = \allowbreak (\h, \allowbreak s_{0})$ and state information $\sstate'$.

        \item For all $i \allowbreak \in \allowbreak \mathbb{S}'$, $B$ computes a signature $\sigma_{i} = (\h, s_{i})$ by using the secret keys of authorities in $\mathbb{S}'$.

        \item For all $i \allowbreak \in \allowbreak \mathbb{S}$, $B$ evaluates at $d$ the Lagrange basis polynomials
        \begin{equation*}
            l_i = [\prod_{j\in\mathbb{S},j\neq i} (d-j)] [\prod_{j\in \mathbb{S},j\neq i} (i-j)]^{-1}\ \mathrm{mod}\ \p
        \end{equation*}

        \item $B$ computes the signature $\sigma_d = (\h, s_d) \gets (\h, \prod_{i \in \mathbb{S}} s_i^{l_i})$. We note that in this computation the signature sent by the challenger is used.

        \item $B$ computes $\hat{\sigma}_{d} = (\h, s_{d} \beta_{d,1}^{o_1} \beta_{d,2}^{o_2})$ and includes it in the issuance message sent to $\Adversary$. $B$ stores  $(m_1, \allowbreak m_2, \fcecAuthority_d)$.

    \end{itemize}



	After the adversary $\Adversary$ sends a valid payment $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$, $B$ proceeds as follows.
	\begin{itemize}

        \item $B$ runs the extractor $\mathcal{E}_v$ to extract the witness  $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$ from the proof $\pi_v$.

        \item $B$ parses $\sigma'$ as $(\h', \allowbreak s')$ and computes $\hat{\sigma} \allowbreak = \allowbreak (\hat{\h}, \allowbreak \hat{s}) \allowbreak = \allowbreak (\h', \allowbreak s' (\h')^{-r})$. $B$ runs the verification equation $\e(\hat{\h}, \allowbreak \tilde{\alpha} \allowbreak \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn}) \allowbreak =  \allowbreak \e(\hat{s}, \allowbreak \gb)$ of the Pointcheval-Sanders signature scheme.  If for any signature $\hat{\sigma}_l$ the verification equation does not hold, $B$ outputs failure. As shown in $\Gam 4$, the probability that $B$ outputs failure is $0$.

        \item $B$ checks that there are at least $t-|\mathbb{T}|$ tuples $(m_{1}, \allowbreak m_{2}, \allowbreak \fcecAuthority_i)$ stored for $t-|\mathbb{T}|$ honest authorities. If that is the case, $B$ does nothing because $\Adversary$ was issued enough signatures to compute the payment. Else, if the adversary $\Adversary$ received less than $t-|\mathbb{T}|$ signatures from honest authorities, but $\Adversary$ did receive a signature from an authority $\fcecAuthority_{d}$ such that $d \allowbreak \in \allowbreak \mathbb{D}$, $B$ fails because $B$ had to the query signing oracle to issue that signature to the adversary and therefore he cannot use $\hat{\sigma}$ as a forgery. However, if $\Adversary$ received less than $t-|\mathbb{T}|$ signatures from honest authorities, and all those authorities $\fcecAuthority_{i}$ are such that $i \allowbreak \in \allowbreak \mathbb{U}$, $B$ sends $\hat{\sigma}$ to the challenger to win the existential unforgeability game.

    \end{itemize}

	Finally, the probability that $B$ fails can be bound as follows. $B$ needs to query the signing oracle of the challenger whenever $\Adversary$ requests a signature from an authority $\fcecAuthority_{d}$ such that $d \in \mathbb{D}$. Therefore, when $\Adversary$ is able to show a signature without receiving $t - |\mathbb{T}|$ signatures shares from $t - |\mathbb{T}|$ different honest authorities, $B$ fails whenever $\Adversary$ did request a signature from an authority $\fcecAuthority_{d}$ such that $d \in \mathbb{D}$. In the worst case, $\Adversary$ received $t-1-|\mathbb{T}|$ signatures from $t-1-|\mathbb{T}|$ honest authorities. In that worst case, $B$ only succeeds when those $t-1-|\mathbb{T}|$ authorities are those authorities $\fcecAuthority_{i}$ such that $i \in \mathbb{U}$.  The probability that $B$ succeeds, i.e. the probability that $\Adversary$ picks those $t-1-|\mathbb{T}|$ authorities from the set of $n-|\mathbb{T}|$ authorities is given by the inverse of the number of $(t-1-|\mathbb{T}|)$-element combinations of $n-|\mathbb{T}|$ objects taken without repetition
    \begin{equation*}
        \frac{(t-1-|\mathbb{T}|)!(n-t+1!)}{(n-|\mathbb{T}|)!}
    \end{equation*}
    We remark that, in the frequent case in which $t=n$, then $B$ succeeds with probability $1/(t-|\mathbb{T}|)$.
	\end{proof}

	\item[$\Gam 6$:] This game proceeds as $\Gam 5$, except that, after extracting the witness $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$ from a proof $\pi_v$, $\Gam 6$ takes the payment $\cecpayment \allowbreak = \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that contains $\pi_v$ and the associated payment information $\cecpaymentinfo$ and computes the serial numbers $S'_{k} \allowbreak \gets \allowbreak \delta^{1/(\cecsn+l_k+1)}$ and the double spending tags $T'_k \allowbreak \gets \allowbreak \ga^{\ssk_{\fcecUser_j} + R_{k}/(\cecsn+l_k+1)}$, where $R_k \allowbreak = \allowbreak H'(\cecpaymentinfo, \allowbreak k)$. Then $\Gam 6$ outputs failure if, for any $k \allowbreak \in \allowbreak [0,V-1]$, $S'_k \allowbreak \neq \allowbreak S_k$ or $T'_k \allowbreak \neq \allowbreak T_k$. Under the hardness of the discrete logarithm problem, $|\Pr[\Gam 6]-\Pr[\Gam 5]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{dlog}}$.
    \begin{proof}
     We have an adversary $\Adversary$ that, with non-negligible probability, sends payment information $\cecpaymentinfo$ and a payment   $\cecpayment \allowbreak = \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ such that, after extracting from $\pi_v$ the witness $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$ and computing $S'_{k} \allowbreak \gets \allowbreak \delta^{1/(\cecsn+l_k+1)}$ and $T'_k \allowbreak \gets \allowbreak \ga^{\ssk_{\fcecUser_j} + R_{k}/(\cecsn+l_k+1)}$ for all $k \allowbreak \in \allowbreak [0,V-1]$, we have that $S'_k \allowbreak \neq \allowbreak S_k$ or  $T'_k \allowbreak \neq \allowbreak T_k$ for some $k \allowbreak \in \allowbreak [0,V-1]$. We construct an algorithm $B$ that uses that adversary to solve the discrete logarithm problem.

    $B$ works as follows. Given an instance $(h, \allowbreak h^x)$ of the discrete logarithm problem, when running the functionality $\Functionality_{\KG}$ to set up the parameters $\cecparams \gets (\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gamma_1,\gamma_2,\delta, L)$, $B$ sets $\ga \allowbreak \gets \allowbreak  h$ and $\gamma_1 \allowbreak \gets \allowbreak h^x$. When the adversary outputs a payment $\cecpayment$ that fulfills the condition described above for a certain $k \allowbreak \in \allowbreak [0,V-1]$, $B$ outputs
    \begin{equation*}
    x \allowbreak \gets \allowbreak \frac{(o_{a_k}+o_c)\mu_k+o_{\mu_k}}{1-((\cecsn+l_k+1)\mu_k)}
    \end{equation*}
    We show that the discrete logarithm $x$ is computed correctly as follows. The non-interactive ZK proof of knowledge $\pi_v$ is described by
    \begin{align*}
        \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, o_c, \langle l_k, o_{a_k}, \mu_k, o_{\mu_k} \rangle_{k=0}^{V-1}): \\
        &\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\ C = \ga^{o_c} \gamma_1^{\cecsn}\ \land\  \\&
        \langle A_k = \ga^{o_{a_k}} \gamma_1^{l_k}\ \land\ l_k \in [0,L-1]\ \land\ \\&
        S_k=\delta^{\mu_k}\ \land\ \gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}\ \land\ \\&
        T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}\  \rangle_{k\in[0,V-1]}
        \}
    \end{align*}
    After successful extraction of the witness $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1})$, we know that the statements proven by $\pi_v$ hold. In the case that $S'_k \allowbreak \neq \allowbreak S_k$ for some $k \allowbreak \in \allowbreak [0,V-1]$, we have that
    \begin{equation*}
    \delta^{1/(\cecsn+l_k+1)} \neq \delta^{\mu_k}
    \end{equation*}
    and thus $1/(\cecsn+l_k+1) \neq {\mu_k}$.
    In the case that $T'_k \allowbreak \neq \allowbreak T_k$ for some $k \allowbreak \in \allowbreak [0,V-1]$, we have that
    \begin{equation*}
    \ga^{\ssk_{\fcecUser_j} + R_{k}/(\cecsn+l_k+1)} \neq \ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}
    \end{equation*}
    and thus we can also deduce that $1/(\cecsn+l_k+1) \neq {\mu_k}$.

    We also have the following:
    \begin{align*}
    \gamma_1 &=  (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}} \\&
    = (\ga^{o_{a_k}} \gamma_1^{l_k} \ga^{o_c} \gamma_1^{\cecsn} \gamma_1)^{\mu_k} \ga^{o_{\mu_k}} \\ &
    = \gamma_1^{(\cecsn+l_k+1)\mu_k} \ga^{(o_{a_k}+o_c)\mu_k+o_{\mu_k}}
    \end{align*}
    and therefore
    \begin{equation*}
    \gamma_1 = \ga^{\frac{(o_{a_k}+o_c)\mu_k+o_{\mu_k}}{1-((\cecsn+l_k+1)\mu_k)}}
    \end{equation*}
    This equation shows that, when $1/(\cecsn+l_k+1) \allowbreak \neq \allowbreak {\mu_k}$, we can compute the discrete logarithm $x$ as described above.
    \end{proof}

	\item[$\Gam 7$:] This game proceeds as $\Gam 6$, except that in $\Gam 7$ the non-interactive ZK proofs of knowledge $\pi_v$ that are sent to the adversary are replaced by simulated proofs computed by the simulator $\mathcal{S}_{v}$. Under the zero-knowledge property of the proof system (see Definition~\ref{def:zero-knowledge}), we have that $|\Pr[\Gam 7]-\Pr[\Gam 6]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{zk}}$.

	\item[$\Gam 8$:] This game proceeds as $\Gam 7$, except that in $\Gam 8$, for the payments $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that are sent to the adversary, the values $\kappa$ and $\sigma'$ are computed as follows:
	\begin{itemize}

	    \item Pick random $t \gets \Zp$ and $t' \gets \Zp$.

        \item Compute $\sigma' = (\h',s') \gets (\ga^{t'}, \ga^{t t'})$.

        \item Compute $\kappa \gets \gb^{t}$.

	\end{itemize}
	As shown below, $|\Pr[\Gam 8]-\Pr[\Gam 7]| = 0$.
	\begin{proof}
	 This proof follows the proof in~\cite{cryptoeprint:2022:011}. We show that values $\kappa$ and $\sigma'$ follow the same distribution as the ones computed by the honest user in the real-world protocol. Observe that the honest user computes the following:
    \begin{itemize}

        \item Pick random $r \gets \Zp$ and $r' \gets \Zp$.

        \item Set $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$, where we have that
        \begin{align*}
             (\h^{r'}, s^{r'}(\h')^{r}) & = (\h^{r'}, \allowbreak \h^{(x+\ssk_{\fcecUser_j} y_{1} + \cecsn y_{2} + r)r'}) \\ &
             = (\ga^{u r'}, \ga^{(x+\ssk_{\fcecUser_j} y_{1} + \cecsn y_{2} + r) u r'})
        \end{align*}
        \item Set $\kappa \gets \alpha \beta_1^{\ssk_{\fcecUser_j}} \beta_2^{\cecsn} \gb^{r} = \gb^{x+\ssk_{\fcecUser_j} y_{1} + \cecsn y_{2} + r}$.

    \end{itemize}
    Therefore, $t$ corresponds to $(x+\ssk_{\fcecUser_j} y_{1} + \cecsn y_{2} + r_l)$ and $t'$ corresponds to $u r'$, where $u$ is a random value such that $\h = \ga^{u}$. Both $(x+ \ssk_{\fcecUser_j} y_{1} + \cecsn y_{2} + r)$ and $u r'$ are random. Observe as well that the verification equation $\e(\h', \kappa) = \e(s',\gb)$ still holds because $\e(\ga^{t'}, \gb^{t}) = \e(\ga^{t t'},\gb)$.
	\end{proof}

	\item[$\Gam 9$:] This game proceeds as $\Gam 8$, except that in $\Gam 9$ the non-interactive ZK proofs of knowledge $\pi_s$ that are sent to the adversary are replaced by simulated proofs computed by the simulator $\mathcal{S}_{s}$. Under the zero-knowledge property of the proof system (see Definition~\ref{def:zero-knowledge}), we have that $|\Pr[\Gam 9]-\Pr[\Gam 8]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{zk}}$.

	\item[$\Gam 10$:] This game proceeds as $\Gam 9$, except that in $\Gam 10$, in each request that is sent to the adversary, the values $(\com_1, \allowbreak \com_2)$ are replaced by $\com_{1} \allowbreak \gets \allowbreak \ga^{o_{1}} \h^{\cecmes_{1}}$ and $\com_{2} \allowbreak \gets \allowbreak \ga^{o_{2}} \h^{\cecmes_{2}}$, where $(o_1, \allowbreak \cecmes_1, \allowbreak o_2, \allowbreak \cecmes_2)$ are random values in $\Zp$. At this point, the non-interactive ZK proofs of knowledge $\pi_s$ are simulated proofs of false statements. We also remark that, after $\Gam 8$, the computation of payment messages does not use the signatures obtained in the issuance phase. Since the values $(\com_1, \allowbreak \com_2)$ are uniformly distributed at random, this change does not alter the view of the environment and we have that $|\Pr[\Gam 10]-\Pr[\Gam 9]| = 0$.

	\item[$\Gam 11$:] This game proceeds as $\Gam 10$, except that in $\Gam 11$, in each request that is sent to the adversary, the value $\com$ is replaced by picking random $\com \allowbreak \gets \allowbreak \Ga$. Under the hiding property of the commitment scheme,  $|\Pr[\Gam 11]-\Pr[\Gam 10]| \allowbreak \leq \allowbreak N \cdot\Adv_{\Adversary}^{\mathsf{hid}}$, where $N$ is the number of commitments $\com$ sent to the adversary. Since the Pedersen commitment scheme is perfectly hiding, $|\Pr[\Gam 11]-\Pr[\Gam 10]| \allowbreak = \allowbreak 0$.

	\begin{proof}
	The proof uses a sequence of games $\Gam 10.i$, for $i=0$ to $N$. $\Gam 10.0$ is equal to $\Gam 10$, whereas $\Gam 10.N$ is equal to $\Gam 11$. In $\Gam 10.i$, the first $i$ commitments sent to the adversary are set to random values, whereas the remaining ones are set as in $\Gam 10$.

	Given an adversary that distinguishes between $\Gam 10.i$ and $\Gam 10.(i+1)$ with non-negligible probability, we construct an algorithm $B$ that breaks the hiding property of the commitment scheme. $B$ works as follows. $B$ receives the parameters of the Pedersen commitment scheme $\paramscom \allowbreak = (\ga, \allowbreak \gamma_1, \allowbreak \gamma_2)$ from the challenger. When running $\Functionality_{\KG}$, $B$ uses those parameters to set the values $(\ga, \allowbreak \gamma_1, \allowbreak \gamma_2)$ in the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$. To compute the first $i$ commitments, $B$ sets $\com$ to random. To compute the commitment $i+1$, $B$ sends the messages $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ to the challenger. $B$ sets $\com$ to the challenge commitment received from the challenger. As can be seen, if the challenge commitment commits to $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$, then we are in $\Gam 10.i$, whereas if the challenge commitment commits to a random message, then we are in $\Gam 10.(i+1)$. The remaining commitments are computed as in $\Gam 10$. $B$ sends the adversarial guess to distinguish between $\Gam 10.i$ and $\Gam 10.(i+1)$ to the challenger of the hiding game.
	\end{proof}

   	\item[$\Gam 12$:] This game proceeds as $\Gam 11$, except that in $\Gam 12$, for the payments $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that are sent to the adversary, for all $k \allowbreak \in \allowbreak [0,V-1]$, the values $A_k \allowbreak \gets \allowbreak \Ga$ are set to random elements in $\Ga$. The value $C$ is also set to a random element in $\Ga$. Under the hiding property of the commitment scheme, we have that $|\Pr[\Gam 12]-\Pr[\Gam 11]| \allowbreak \leq \allowbreak N \cdot\Adv_{\Adversary}^{\mathsf{hid}}$, where $N$ is the number of commitments $C$ and $A_k$ sent to the adversary. Since the Pedersen commitment scheme is perfectly hiding, $|\Pr[\Gam 12]-\Pr[\Gam 11]| \allowbreak = \allowbreak 0$. We omit the proof, which is similar to the proof of indistinguishability between $\Gam 10$ and $\Gam 11$.

	\item[$\Gam 13$:] This game proceeds as $\Gam 12$, except that in $\Gam 13$, for the payments $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that are sent to the adversary,  for all $k \allowbreak \in \allowbreak [0,V-1]$, the values $S_k$ and $T_k$ are computed by doing $S_k \allowbreak \gets \allowbreak \delta^{r_k}$ and $T_k \allowbreak \gets \allowbreak \ga^{\ssk_{\fcecUser_j}}  (\ga^{r_k})^{R_{k}}$, where $r_k \gets \Zp$ is picked up randomly. Under the pseudorandomness property of the pseudorandom function, we have that $|\Pr[\Gam 13]-\Pr[\Gam 12]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{pseu}}$.
	\begin{proof}
	 Given an adversary that is able to distinguish $\Gam 12$ from $\Gam 13$ with non-negligible probability, we construct an algorithm $B$ that breaks the pseudorandomness property of the pseudorandom function $f_{\G,\p,\ga,s}(\cdot)$ described in~\S\ref{subsec:pseudorandomfunction}. $B$ receives from the challenger the parameters $(\Ga, \allowbreak \p, \allowbreak \ga)$. When running $\Functionality_{\KG}$, $B$ picks up random $a \allowbreak \in \allowbreak \Zp$, computes $\delta \allowbreak \gets \allowbreak \ga^{1/a}$ and sets the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$. We remark that, after $\Gam 11$, request messages are computed without requiring knowledge of the coin secret $\cecsn$, and so $B$ does not need to know the secret $s$ of the pseudorandom function to compute them. Similarly, after $\Gam 12$, payment messages are computed without requiring knowledge of the coin secret $\cecsn$.  To compute a payment $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ to be sent to the adversary, $B$ follows the changes described up to $\Gam 12$ and, additionally, to compute $\langle S_k, \allowbreak T_k \rangle_{k\in[0,V-1]}$, $B$ does the following. For all $k\in[0,V-1]$, $B$ sends the coin index $l_k$ to the oracle of the challenger, which provides a response $Z_k$. $B$ sets $T_k \allowbreak \gets \allowbreak \ga^{\ssk_{\fcecUser_j}}  (Z_k)^{R_{k}}$ and $S_k \allowbreak \gets \allowbreak Z_k^{1/a}$. As can be seen, if $Z_k = f_{\G,\p,\ga,s}(l_k)$, $T_k$ and $S_k$ are computed as in $\Gam 12$, whereas if $Z_k$ is random, $Z_k$ are computed as in $\Gam 13$. Therefore, $B$ uses the guess of the adversary to distinguish between $\Gam 12$ and $\Gam 13$ in order to break the pseudorandomness property of the pseudorandom function.
	\end{proof}



	\item[$\Gam 14$:] This game proceeds as $\Gam 13$, except that in $\Gam 14$, for the payments $\cecpayment \allowbreak \gets \allowbreak (\kappa, \allowbreak \sigma', \allowbreak \langle S_k, \allowbreak T_k, \allowbreak A_k \rangle_{k\in[0,V-1]}, \allowbreak V, \allowbreak C, \allowbreak \pi_v)$ that are sent to the adversary,  for all $k \allowbreak \in \allowbreak [0,V-1]$, the values $S_k$ and $T_k$ are computed by picking random $S_k \allowbreak \gets \Ga$ and $T_k \allowbreak \gets \allowbreak \Ga$. Under the external Diffie-Hellman (XDH)  assumption in $\Ga$, we have that $|\Pr[\Gam 14]-\Pr[\Gam 13]| \allowbreak \leq \allowbreak N_{s} \cdot \Adv_{\Adversary}^{\mathsf{xdh}}$, where $N_{s}$ is the number of serial numbers and double spending tags sent to the adversary.
	\begin{proof}
	The proof uses a sequence of games $\Gam 13.i$, for $i=0$ to $N_{s}$. $\Gam 13.0$ is equal to $\Gam 13$, whereas $\Gam 13.(N_{s})$ is equal to $\Gam 14$. In $\Gam 13.i$, the values $S_k$ and $T_k$ of the first $i$ payments sent to the adversary are set to random values, whereas in the remaining payments they are set as in $\Gam 13$.

	Given an adversary that distinguishes between $\Gam 13.i$ and $\Gam 13.(i+1)$ with non-negligible probability, we construct an algorithm $B$ that uses that adversary to solve the XDH problem with non-negligible probability. $B$ works as follows. Given an instance $(h, \allowbreak h^a, \allowbreak h^b, \allowbreak Z)$ of the XDH problem in $\Ga$, when running $\Functionality_{\KG}$ to set up the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e,\allowbreak \ga,\allowbreak \gb,\allowbreak \gamma_1,\allowbreak \gamma_2,\allowbreak \delta, \allowbreak L)$, $B$ sets $\ga \allowbreak \gets \allowbreak \h^a$ and $\delta \allowbreak \gets \allowbreak h$. When setting the $i+1$ serial number and double spending tag sent to the adversary, $B$ sets $S_k \allowbreak \gets \allowbreak \h^b$ and $T_k \allowbreak \gets \allowbreak \ga^{\ssk_{\fcecUser_j}}  (Z)^{R_{k}}$. As can be seen, when $Z$ is random, $S_k$ and $T_k$ are random values and we are thus in $\Gam 13.(i+1)$. In contrast, when $Z \allowbreak = \allowbreak h^{ab}$, we have that $S_k \allowbreak = \allowbreak h^b \allowbreak = \allowbreak \delta^b$ and $T_k \allowbreak = \allowbreak (h^a)^{\ssk_{\fcecUser_j}} (h^{ab})^{R_{k}} = \allowbreak (\ga)^{\ssk_{\fcecUser_j}} (\ga^{b})^{R_{k}}$, and thus the distribution is equal to that of $\Gam 13.i$. Therefore, $B$ can use the guess of the adversary to distinguish between $\Gam 13.i$ and $\Gam 13.(i+1)$ in order to solve the XDH problem in $\Ga$ with non-negligible probability.
	\end{proof}





    \item[$\Gam 15$:] This game proceeds as $\Gam 14$, except that $\Gam 15$ checks that algorithm $\cecIdentify$ identifies the double spender when there is double spending. To do that, when the adversary sends two valid payments $(\cecpayment, \allowbreak \cecpaymentinfo)$ and $(\cecpayment', \allowbreak \cecpaymentinfo')$, after extracting the witness $\langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$ from the proofs $\pi_v \allowbreak \in \allowbreak \cecpayment$ and $\langle \ssk'_{\fcecUser_j}, \allowbreak \cecsn', \allowbreak r', \allowbreak o'_c, \allowbreak \langle l'_k, \allowbreak o'_{a_k}, \allowbreak \mu'_k, \allowbreak o'_{\mu_k} \rangle_{k=0}^{V'-1} \rangle)$  from the proof $\pi'_v \allowbreak \in \allowbreak \cecpayment'$, $\Gam 15$ checks whether $\ssk'_{\fcecUser_j} \allowbreak = \allowbreak \ssk_{\fcecUser_j}$, $\cecsn' \allowbreak = \allowbreak \cecsn$ and $\langle l'_k \rangle_{k\in[0,V'-1]} \cap \langle l_k \rangle_{k\in[0,V-1]} \allowbreak \neq \allowbreak \emptyset$, which means that there is a double spending. In that case $\Gam 15$ sets $\cecPK$ to contain all the registered public keys and runs the algorithm $c \allowbreak \gets \allowbreak \cecIdentify(\cecparams, \allowbreak \cecPK, \allowbreak \cecpayment, \allowbreak \cecpayment', \allowbreak \cecpaymentinfo, \allowbreak \cecpaymentinfo')$. Then $\Gam 15$ does the following:
    \begin{itemize}

                \item If $\cecpaymentinfo \allowbreak = \allowbreak \cecpaymentinfo'$ and $c \allowbreak \neq \allowbreak \cecpaymentinfo$, $\Gam 15$ outputs failure.

                \item If $\cecpaymentinfo \allowbreak \neq \allowbreak \cecpaymentinfo'$ and $c \allowbreak \neq \allowbreak \spk_{\fcecUser_j}$, where $\spk_{\fcecUser_j}$ is the public key associated with secret key $\ssk_{\fcecUser_j}$, $\Gam 15$ outputs failure.

    \end{itemize}
    The probability that $\Gam 15$ fails is negligible under the collision-resistance property of the hash function $H'$, i.e. we have that $|\Pr[\Gam 15]-\Pr[\Gam 14]| \allowbreak \leq \allowbreak \Adv_{\Adversary}^{\mathsf{col-res}}$.
    \begin{proof}
    In $\Gam 6$, we have shown that, if a payment is valid, under the hardness of the discrete logarithm assumption, the serial numbers $S_k$ and the double-spending tags $T_k$ are correctly computed. Hence, if there are two payments with witnesses  $\langle \ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$ and $\langle \ssk'_{\fcecUser_j}, \allowbreak \cecsn', \allowbreak r', \allowbreak o'_c, \allowbreak \langle l'_k, \allowbreak o'_{a_k}, \allowbreak \mu'_k, \allowbreak o'_{\mu_k} \rangle_{k=0}^{V'-1} \rangle)$ such that $\ssk'_{\fcecUser_j} \allowbreak = \allowbreak \ssk_{\fcecUser_j}$, $\cecsn' \allowbreak = \allowbreak \cecsn$ and $\langle l'_k \rangle_{k\in[0,V'-1]} \cap \langle l_k \rangle_{k\in[0,V-1]} \allowbreak \neq \allowbreak \emptyset$, the proof in $\Gam 6$ guarantees that, for those coin indices such that $l'_{k'} \allowbreak = \allowbreak l_k$ (where $k' \allowbreak \in \allowbreak [0,V'-1]$ and $k \allowbreak \in \allowbreak [0,V-1]$), it is the case that $S'_{k'} \allowbreak = \allowbreak S_k = \allowbreak \delta^{1/(\cecsn+l_k+1)}$. Therefore, the algorithm $\cecIdentify$ always detects double spending.

    After detecting double spending, the algorithm $\cecIdentify$ checks if $\cecpaymentinfo \allowbreak = \allowbreak \cecpaymentinfo'$ and in that case sets $c \allowbreak = \allowbreak \cecpaymentinfo$. Therefore, the first condition under which $\Gam 15$ fails never happens.

    If $\cecpaymentinfo \allowbreak \neq \allowbreak \cecpaymentinfo'$, algorithm $\cecIdentify$ computes
    \begin{equation*}
    \spk_{\fcecUser_j} \gets ((T'_{k'})^{R_{k}}/T_{k}^{R'_{k'}})^{(R_{k}-R'_{k'})^{-1}}
    \end{equation*}
    We have that $R_k \allowbreak = \allowbreak H'(\cecpaymentinfo,k)$ and $R'_{k'} \allowbreak = \allowbreak H'(\cecpaymentinfo',k')$. The proof in $\Gam 6$ also guarantees that the double spending tags are correctly computed. Hence, we know that $T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{1/(\cecsn+l_k+1)})^{R_{k}}$ and $T'_{k'}=\ga^{\ssk_{\fcecUser_j}} (\ga^{1/(\cecsn+l_{k}+1)})^{R'_{k'}}$. Let $Z \allowbreak = \allowbreak \ga^{1/(\cecsn+l_k+1)}$. We have that
    \begin{align*}
    \spk_{\fcecUser_j} & = ((T'_{k'})^{R_{k}}/T_{k}^{R'_{k'}})^{(R_{k}-R'_{k'})^{-1}} \\ & = ((\ga^{\ssk_{\fcecUser_j}} (Z)^{R'_{k'}})^{R_k} / (\ga^{\ssk_{\fcecUser_j}} (Z)^{R_{k}})^{R'_{k'}})^{(R_{k}-R'_{k'})^{-1}} \\&
    = ((\ga^{\ssk_{\fcecUser_j} R_k} (Z)^{R'_{k'}R_k}) / (\ga^{\ssk_{\fcecUser_j}R'_{k'}} (Z)^{R_{k}R'_{k'}}))^{(R_{k}-R'_{k'})^{-1}} \\&
    = (\ga^{\ssk_{\fcecUser_j} R_k}  / \ga^{\ssk_{\fcecUser_j}R'_{k'}} )^{(R_{k}-R'_{k'})^{-1}} \\ &
    = (\ga^{\ssk_{\fcecUser_j} (R_k-R'_{k'})}  )^{(R_{k}-R'_{k'})^{-1}} \\ &
    = \ga^{\ssk_{\fcecUser_j}}
    \end{align*}
    Therefore, algorithm $\cecIdentify$ outputs the public key of the double spender, except when $R_{k} \allowbreak = \allowbreak R'_{k'}$. Given that $R_k \allowbreak = \allowbreak H'(\cecpaymentinfo,k)$ and $R'_{k'} \allowbreak = \allowbreak H'(\cecpaymentinfo',k')$, if $R_{k} \allowbreak = \allowbreak R'_{k'}$, a collision for the hash function $H'$ has been found.
    \end{proof}


    \item[$\Gam 16$:] This game proceeds as $\Gam 15$, except that, even if there is not double spending, $\Gam 16$ sets $\cecPK$ to contain all the registered public keys and runs the algorithm $c \allowbreak \gets \allowbreak \cecIdentify(\cecparams, \allowbreak \cecPK, \allowbreak \cecpayment, \allowbreak \cecpayment', \allowbreak \cecpaymentinfo, \allowbreak \cecpaymentinfo')$. If it is the case that $c \allowbreak = \allowbreak \spk_{\fcecUser_j}$, where $\spk_{\fcecUser_j}$ is a public key associated with an honest user, $\Gam 16$ outputs failure. We show that $\Gam 16$ outputs failure with negligible probability under the hardness of the discrete logarithm problem, i.e. $|\Pr[\Gam 16]-\Pr[\Gam 15]| \allowbreak \leq \allowbreak N_{u} \allowbreak \cdot \allowbreak \Adv_{\Adversary}^{\mathsf{dlog}}$, where $N_u$ is the number of public keys of honest users.
    \begin{proof}
    Given an adversary that makes $\Gam 16$ fail with non-negligible probability, we construct an algorithm $B$ that solves the discrete logarithm problem with non-negligible probability. $B$ works as follows. $B$ receives an instance $(h, \allowbreak h^x)$ of the discrete logarithm problem from the challenger. When running $\Functionality_{\KG}$, $B$ sets $\ga \allowbreak \gets h$ and sets the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$. $B$ picks randomly an honest user $\fcecUser_j$ and, when that user registers her public key, $B$ sets $\spk_{\fcecUser_j} \allowbreak \gets \allowbreak \h^x$. We remark that, since $\Gam 9$, knowledge of $\ssk_{\fcecUser_j}$ is not needed to compute request messages. We also remark that, since $\Gam 8$, knowledge of $\ssk_{\fcecUser_j}$ is not needed to compute payment messages. Therefore, $B$ can simulate those messages without knowledge of $\ssk_{\fcecUser_j}$.

    At some point $B$ receives from the adversary two payments $(\cecpayment, \allowbreak \cecpaymentinfo)$ and $(\cecpayment', \allowbreak \cecpaymentinfo')$ that make $\Gam 16$ fail. If the public key $\spk_{\fcecUser_j}$ obtained after running $\cecIdentify$ is different from the value $h^x$ received from the challenger, $B$ fails. Otherwise $B$ computes $\ssk_{\fcecUser_j}$ as follows. First, $B$ extracts the witness $\langle \ssk, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$ from the proofs $\pi_v \allowbreak \in \allowbreak \cecpayment$ and $\langle \ssk', \allowbreak \cecsn', \allowbreak r', \allowbreak o'_c, \allowbreak \langle l'_k, \allowbreak o'_{a_k}, \allowbreak \mu'_k, \allowbreak o'_{\mu_k} \rangle_{k=0}^{V'-1} \rangle)$ from the proof $\pi'_v \allowbreak \in \allowbreak \cecpayment'$. Given that double spending has been detected, and that in $\Gam 6$ we proved that serial numbers and double spending tags are correctly computed, we know that there is $S_k \in \cecpayment$ and $S'_{k'} \in \cecpayment'$ such that $S_k = S'_{k'} = \delta^b$, where $b= (1/(\cecsn+l_k+1)) = (1/(\cecsn'+l'_{k'}+1))$. Therefore, we also know that the double spending tags are of the form $T_k \allowbreak = \allowbreak \ga^{\ssk + b R_{k}}$ and $T'_{k'} \allowbreak = \allowbreak \ga^{\ssk' + b R'_{k'}}$. From the computation of algorithm $\cecIdentify$, we have that
    \begin{align*}
    \spk_{\fcecUser_j} & = ((T'_{k'})^{R_{k}}/T_{k}^{R'_{k'}})^{(R_{k}-R'_{k'})^{-1}} \\ &
    = ((\ga^{\ssk' + b R'_{k'}})^{R_{k}}/(\ga^{\ssk + b R_{k}})^{R'_{k'}})^{(R_{k}-R'_{k'})^{-1}} \\ &
    = ((\ga^{R_{k} \ssk' + b R_{k} R'_{k'}})/(\ga^{R'_{k'} \ssk + b R_{k} R'_{k'}}))^{(R_{k}-R'_{k'})^{-1}} \\ &
    = (\ga^{R_{k} \ssk' - R'_{k'} \ssk })^{(R_{k}-R'_{k'})^{-1}} \\ &
    = (\ga^{(R_{k} \ssk' - R'_{k'} \ssk)/ (R_{k}-R'_{k'})}) \\ &
    \end{align*}
    Therefore, $B$ computes $x \gets (R_{k} \ssk' - R'_{k'} \ssk)/ (R_{k}-R'_{k'})$ to solve the discrete logarithm problem. If the adversary succeeds with probability $\alpha$, $B$ succeeds with probability $\alpha/N_{u}$, where $N_u$ is the number of public keys of honest users.
    \end{proof}

    \item[$\Gam 17$:] This game proceeds as $\Gam 16$, except that $\Gam 17$ outputs failure when the serial number of a payment computed by an honest user is equal to a serial number of another payment. The probability that two serial numbers have the same value is bounded by $N_s/|\Ga|$, where $N_s$ is the number of serial numbers and $|\Ga|$ is the size of $\Ga$. Additionally, we show below that the probability that an adversarial user computes a payment with a serial number that is equal to a serial number in a payment computed by an honest user is negligible thanks to the hardness of the discrete logarithm problem. Therefore, we have that $|\Pr[\Gam 17]-\Pr[\Gam 16]| \allowbreak \leq \allowbreak N_s/|\Ga| + N_{s} \allowbreak \cdot \allowbreak \Adv_{\Adversary}^{\mathsf{dlog}}$.
    \begin{proof}
    Given an adversary that makes $\Gam 17$ fail with non-negligible probability, we construct an algorithm $B$ that solves the discrete logarithm problem with non-negligible probability. $B$ works as follows. $B$ receives an instance $(h, \allowbreak h^x)$ of the discrete logarithm problem from the challenger. When running $\Functionality_{\KG}$, $B$ sets $\delta \allowbreak \gets h$ and sets the parameters $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$. $B$ picks randomly a serial number in a payment computed by an honest user and sets $S_k \allowbreak \gets \allowbreak h^x$. We recall that, since $\Gam 14$, serial numbers in payments computed by honest users are random values in $\Ga$.

    At some point, $B$ finds that a payment received from the adversary has a serial number that is equal to a serial number in a payment computed by an honest user. If that serial number is not equal to $h^x$, $B$ fails. Otherwise $B$ extracts the witness $\langle \ssk, \allowbreak \cecsn, \allowbreak r, \allowbreak o_c, \allowbreak \langle l_k, \allowbreak o_{a_k}, \allowbreak \mu_k, \allowbreak o_{\mu_k} \rangle_{k=0}^{V-1} \rangle)$ from the proof $\pi_v$ in the payment $\cecpayment$ sent by the adversary. Thanks to the proof in $\Gam 6$, we know that the serial number $S_k \allowbreak = \allowbreak h^x$ in $\cecpayment$ is of the form $S_k \allowbreak = \allowbreak \delta^{1/(\cecsn+l_k+1)}$. Therefore, $B$ outputs $x \allowbreak \gets \allowbreak 1/(\cecsn+l_k+1)$. If the adversary succeeds with probability $\alpha$, $B$ succeeds with probability $\alpha/N_{s}$, where $N_s$ is the number of serial numbers.
    \end{proof}

\end{description}
The distribution of $\Gam 17$ is identical to that of our simulation. In $\Gam 17$, the request message is computed without knowledge of the values $\ssk_{\fcecUser_j}$ and $\cecsn$. The payment is computed without knowledge of the signatures and without knowledge of the signed messages $\ssk_{\fcecUser_j}$ and $\cecsn$. Additionally, it is guaranteed that the adversary cannot compute a payment on a wallet defined by $\ssk_{\fcecUser_j}$ and $\cecsn$ unless the adversary obtained enough signatures from honest authorities. It is also guaranteed that, if the adversary double spends coins, then an adversarial user or provider will be identified. Moreover, it is guaranteed that an honest user or provider will not be found guilty of double spending. The overall advantage of the environment to distinguish between the real and the ideal protocol is $|\Pr[\Gam 17]-\Pr[\Gam 0]| \leq \Adv_{\Adversary}^{\mathsf{ext}} + \Adv_{\Adversary}^{\mathsf{bin}} + \Adv_{\Adversary}^{\mathsf{unf}}\cdot ((n-\tilde{t})!/((t-1-\tilde{t})!(n-t+1)!)) + \Adv_{\Adversary}^{\mathsf{zk}} + (N_u+N_s+1) \cdot\Adv_{\Adversary}^{\mathsf{dlog}} + N_s/|\Ga| + \Adv_{\Adversary}^{\mathsf{pseu}} + N_s \cdot \Adv_{\Adversary}^{\mathsf{xdh}} + \Adv_{\Adversary}^{\mathsf{col-res}}$, where $N_u$ is the number of users and $N_s$ is the number of serial numbers. The discrete logarithm assumption are implied by the DDHI assumption, which is used to prove that the function in~\S\ref{subsec:pseudorandomfunction} is pseudorandom. This concludes the proof of Theorem~\ref{th:all}.
