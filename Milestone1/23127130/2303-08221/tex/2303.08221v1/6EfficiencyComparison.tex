
\section{Efficiency Analysis and Comparison}
\label{sec:efficiencycomparison}

For years research has focused almost exclusively on divisible e-cash because 
of the constant cost of the spending phase. However, this is achieved at the expense of much more expensive deposit and identification phases. In this section, we compare the efficiency of our compact and divisible $\CEC$ schemes. To this end, in \S\ref{sec:compactECashRangeProof}, we describe an instantiation of our compact $\CEC$ scheme with a concrete set membership proof, and in \S\ref{sec:divisibleEcashSpend}, we describe how the NIZK arguments of our divisible $\CEC$ scheme are instantiated. 
Our comparison shows that our compact EC with multiple denominations, an idea mentioned but never explored, keeps efficient deposit and identification phases, while dramatically reducing the spending phase cost as opposed to using one denomination. In fact, when the price range is not large, the concrete (as opposed to asymptotic) cost of compact EC with multiple denominations is smaller than that of divisible EC also in the spending phase. Such a comparison was not done before and can guide the choice of an EC scheme for a practical payment system. 

% We later show in Section \S\ref{sec:efficiencycomparison}, that compact EC with multiple denominations, an idea mentioned but never explored,  keeps efficient deposit and identification phases, while dramatically reducing the spending phase cost as opposed to using one denomination.  


% Because the cost of the spending protocol of compact e-cash grows linearly with the number of coins spent, in our comparison we consider compact $\CEC$ with several denominations, which allows us to reduce dramatically the number of coins that need to be spent. 
In~\S\ref{sec:multipledenominations}, we analyze the average number of coins that need to be spent depending on the choice of denominations. In~\S\ref{sec:performancemeasurements}, we describe the implementation of our schemes and compare their performance. 
% Our results show that our compact e-cash scheme is more practical than our divisible e-cash scheme in certain settings.

\begin{table}
    \centering
    \caption{Average number of spent coins given $D$ and $P_{max}$}
    {\small
    \begin{tabular}{|r|r|r|} \hline
        \multicolumn{1}{|c|}{$P_{max}$} & \multicolumn{1}{|c|}{$D$} & \multicolumn{1}{|c|}{Avg.\ Num.\ Coins} \\ \hline
        10 & $[1,2,5]$ &  1.9 \\
        100 & $[1,2,5,10,20,50]$ &  3.4 \\
        1000 & $[1,2,5,\ldots,100,200,500]$ &  5.1 \\
        10000 & $[1,2,5,\ldots,1000,2000,5000]$ &  6.8 \\
        100000 & $[1,2,5,\ldots,10000,20000,50000]$ & 8.5 \\
        1000000 & $[1,2,5,\ldots,10000,20000,50000]$ & 17.5 \\ \hline
    \end{tabular}
    \label{tab:denominations}
}
\vspace{-5mm}
\end{table}

\subsection{Choice of Multiple Denominations}
\label{sec:multipledenominations}

The spending phase is arguably the phase in which time constraints are more demanding. Spending one coin is more efficient in our compact e-cash scheme than in our divisible e-cash scheme. However, for any real-world payment, multiple coins need to be spent, and consequently, the compact e-cash scheme is not practical. 
To counter this problem, a solution that has often been suggested in the e-cash literature, but not studied in depth, is to use multiple denominations. 
% I.e., several instances of the e-cash scheme are run in parallel, and coins in each of the instances have a different value.
A question that arises when using multiple denominations is how to choose those denominations optimally, i.e., to minimize the average number of coins that need to be spent. This \emph{optimal denomination problem} has been studied in the context of Fiat currencies~\cite{shallit2003country}. Assuming that all the prices within a range $[1, \allowbreak P_{max}]$ are equally likely, and fixing the number $D$ of denominations, the problem is to find the set of denominations that minimizes the average number of spent coins. 
As calculated in~\cite{shallit2003country}, for a price range of $[1, \allowbreak 100]$ cents, and the denominations $[1,\allowbreak 5,\allowbreak 10,\allowbreak 25]$, the average number of coins spent is $4.7$. However, using the optimal sets, which are $[1, \allowbreak 5, \allowbreak 18, \allowbreak 25]$ and $[1, \allowbreak 5, \allowbreak 18, \allowbreak 29]$, the average is $3.89$.

In general, the optimal denomination problem is NP-hard. Given a naive approach of choosing $1$ as the smallest denomination (to be able to pay for the lowest price), we must calculate the number of all possible sets of $D-1$ denominations in the range $[1, \allowbreak P_{max}]$, which is given by the number of combinations without repetition $C_{D-1}(P_{max})$, and 
the average number of coins needed to pay for prices in $[1, \allowbreak P_{max}]$
for each set of those $D$ denominations. This computation is too expensive for practical values of $D$ and $P_{max}$ (e.g.\ $D=15$ and $P_{max}=1000000$ cents), although it can be optimized by restricting the set of denominations to those that fulfil certain properties.

A problem with using multiple denominations in e-cash is that a user may not be able to pay a price even given enough funds. For example, a user left with two coins of 10 cents is not able to pay for a price of 11 cents. The obvious solution to this problem would be to allow the user to exchange one coin of 10 cents for 10 coins of 1 cent, but this would require interaction with authorities, turning the scheme into an online one. For the scheme to remain offline, the only solution would be for the user to withdraw coins of 1 cent denomination.
Therefore, for practical use of the compact e-cash scheme, we need an easy-to-use set of denominations. 
% it is better to have a set of denominations that users are familiar with, because users would need to understand that they need to have enough coins for each denomination to be able to pay for any possible price. 
Taking the denominations of the euro (i.e.\ $[1, \allowbreak 2,\allowbreak 5, \allowbreak 10, \allowbreak 20, \allowbreak 50, \allowbreak 100, \allowbreak 200, \allowbreak 500, \allowbreak 1000, \allowbreak 2000, \allowbreak 5000, \allowbreak 10000, \allowbreak 20000, \allowbreak 50000]$ cents) as an example, in Table~\ref{tab:denominations} we calculate the average number of coins that need to be spent for different values of $P_{max}$ and $D$. Although these denominations are not optimal, 
the results in~\cite{shallit2003country} suggest that the improvement derived from using an optimal denomination set for the same values of $D$ is not dramatic.
Furthermore, these denominations allow us to compute the optimal representation for a given price (i.e.\ the optimal number of coins of each denomination that are needed to pay), by running the simple \emph{greedy algorithm}~\cite{shallit2003country}, whereas the optimal denomination set may not allow that. Therefore, we use those denominations to compare the efficiency of our compact e-cash with that of the divisible e-cash scheme. 

\subsection{Implementation and Comparison}
\label{sec:performancemeasurements}

\paragraph{Implementation} We implement the protocols presented in~\S\ref{sec:compactecash} and~\S\ref{sec:divisibleecash} in $\mathsf{Rust 1.56.0}$. Our implementation is open source.\footnote{\url{https://github.com/nymtech/nym/tree/research/ecash}}%\footnote{\url{https://anonymous.4open.science/r/TI-OfflineEcash-1F2C/}}
For the implementation of the elliptic curve we use a fork of \texttt{bls12\_381} library and further extend it to facilitate operations in $\Gt$.\footnote{\url{https://github.com/jstuczyn/bls12_381}} All benchmarks were run on a dedicated 16 GB Linode machine, with a $2.2$ GHz AMD CPU. To minimize accuracy errors, we execute each measurement 300 times and compute its average. 
With this specification, a single exponentiation in $\Ga$ takes approximately $531.24$ us, in $\Gb$ approximately $2.13$ ms, while in $\Gt$ approximately $3.85$ ms. A single pairing operation takes $2.59$ ms.

\paragraph{Evaluation} 
For our benchmarks, we set the number of authorities to $n = 100$ with a threshold of $t = 70$. The maximum number of coins in a wallet is set to $L=100$. We also set the number of users to $100$, which determines the size of the set of public keys used as input to algorithm $\cecIdentify$. We always place the target public key as the last one $PK$ list.

The withdrawal protocol is the same in both our compact and divisible $\CEC$ schemes. Algorithm $\cecRequest$ takes on average $9.16$ ms. The algorithms run by the authorities, i.e. $\cecRequestVf$ and $\cecWithdraw$, take in total $8.64$ ms on average. Algorithm $\cecWithdrawVf$ takes $8.47$ ms. We remark that to withdraw a wallet, a user needs to run $\cecRequest$ only once because the same request is sent to at least $t$ authorities. However, algorithm $\cecWithdrawVf$ needs to be run at least $t$ times to verify each of the responses. Finally, algorithm $\cecCreateWallet$, which is run just once after $t$ valid responses have been received from different authorities, takes $65.28$ ms. We consider that those timings are practical, and we stress that they do not depend on the number of coins in a full wallet.

% The key difference between the compact and divisible e-cash is the spend and identify phase, as  In both protocols, the $\cecRequest$ takes on average $9.16$ ms. Function $\cecWithdraw$, which includes the $\cecRequestVf$, takes , while $\cecWithdrawVf$ endures $8.47$ ms. Aggregating $100$ partial wallets takes $65.28$ ms. 


% In our implementation, the $ \cecRequestVf$ function is implemented within the $ \cecWithdraw$ function. 
% The key difference between the compact and divisible e-cash is the spend and identify phase, as the withdrawal protocol is the same. In both protocols, the $\cecRequest$ takes on average $9.16$ ms. Function $\cecWithdraw$, which includes the $\cecRequestVf$, takes on average $8.64$ ms, while $\cecWithdrawVf$ endures $8.47$ ms. Aggregating partial wallets takes $9.05$ ms.  


\setlength{\tabcolsep}{10pt}
\begin{table}
% \captionsetup{width=0.3\textwidth}
\centering
    \caption{Performance benchmarks of Compact and Divisible $\CEC$. For Compact $\CEC$ we measure for $V=1$.}
    \begin{tabular}{@{}lll@{}}
        \hline
         & \thead{Compact $\CEC$} & 
            \thead{Divisible $\CEC$}\\\hline
        %  $ \cecRequest$ & 13.057 ms & 9.589 ms \\
        %  $ \cecWithdraw$ & 11.973 ms & 9.047 ms \\
        %  $ \cecWithdrawVf$ &  11.704 ms &  \\
        %  $ \cecCreateWallet$ & 11.759 ms & 9.463 ms  \\ \hline
         $ \cecSpend$ & 34.75 ms & 124.49 ms\\
         $ \cecSpendVf$ & 34.15 ms & 129.81 ms\\ \hline
         $ \cecIdentify$ & 1.61 ms & 133.81 ms\\
         \hline 
    \end{tabular}
    \label{tab:benchmarks}
\end{table}

Table~\ref{tab:benchmarks} presents a comparison between spending a single coin in our compact $\CEC$ scheme vs spending $V$ coins in our divisible $\CEC$ scheme. Algorithms $\cecSpend$ and $\cecSpendVf$ are almost four times faster in the compact than in the divisible $\CEC$ scheme. However, as we noted earlier, the cost of the spending phase in the divisible $\CEC$ scheme is independent of the number of coins spent, while in the compact $\CEC$ scheme, it grows linearly. As an example, let $1267$ be the price to be paid. The total execution time to settle a payment using the compact $\CEC$ scheme would take $44.03$ seconds, thus significantly more than in the divisible $\CEC$ scheme. 

However, the spending phase of our compact e-cash scheme can be optimized as follows. First, algorithm $\cecSpend$ allows us to spend $V$ coins with cost smaller than  the cost of running $V$ times $\cecSpend$ to spend one coin. Our benchmarks show that spending $V = 2$ takes on average $53.43$ ms, which is almost $25\%$ faster than executing the spend protocol twice sequentially to spend one coin. Second, as discussed in~\S\ref{sec:multipledenominations}, we can run several instances of the scheme in parallel and assign to each of them a different denomination. For example, let's consider a set of denominations $[1000, 500, 100, 50, 20, 10, 5, 2, 1]$. Given our price of $1267$, the spender now executes the pay function five times with value $V = 1$ for coins $[1000, 50, 10, 5, 2]$ and once with value $V = 2$ for coins with denomination $100$. 
% Monetary value:  1267
% Denominations:  [1000, 100, 100, 50, 10, 5, 2]
% Total distribution of coins used:
% {1000: 1, 100: 2, 50: 1, 10: 1, 5: 1, 2: 1}
Thus, the total execution time is $261.93$ ms, which is significantly faster. However, in case of large payments and a limited number of denominations, the compact e-cash is still significantly inefficient. For example, given denominations $[100, 50, 20, 10, 5, 2, 1]$ we need $425.34$ ms to complete a  payment of $1267$. A similar dependency can be observed in the case of payment verification. 

We use our analysis from~\S\ref{sec:multipledenominations} to estimate the average time required to complete a payment using our compact $\CEC$ scheme given different price ranges $[1, \allowbreak P_{max}]$ and sets of denominations. The results are summarised in Table~\ref{tab:avg_spend_time}. We observe that our compact $\CEC$ scheme is more efficient than our divisible $\CEC$ scheme for small price ranges and small sets of denominations. 

The major advantage of the compact $\CEC$ scheme over the divisible $\CEC$ scheme is a fast \emph{identification} phase. In the compact $\CEC$ scheme, to detect double-spending, an authority simply needs to compare serial numbers. In a practical setting, it is likely that double spending happens infrequently, and so the computation cost for the authority is negligible. However, in the divisible $\CEC$ scheme, the authority needs to compute the serial numbers of a payment by running $\cecIdentify$ before the authority can compare them with the serial numbers of other payments. The computation of a serial number involves two pairings. 

Once double spending is detected, the compact $\CEC$ scheme can identify the user guilty of double spending in $1.61$ ms, independently of the number of users in the system. However, in the divisible $\CEC$ scheme, the computation is more expensive and it grows linearly with the number of users in the system. We remark that the timings given in Table~\ref{tab:benchmarks} are calculated for 100 users, but in practice this number could be orders of magnitude bigger, which makes identification in compact e-cash much more efficient than in divisible e-cash.

% As we noted in Section~\ref{sec:multipledenominations}, this has a significant impact when the number of denomiations is limited.  


% Exaplain how the change of the security tag computation allowed to speed up the withdrawal of compact e cash with numbers 

\begin{table}
    \centering
    \caption{Average time required to complete a payment in Compact $\CEC$ for different values of $D$ and $P_{max}$}
    \begin{tabular}{|r|r|c|} \hline
        \multicolumn{1}{|c|}{$P_{max}$} & \multicolumn{1}{|c|}{$D$} & 
        \thead{Spend [ms]} \\ \hline
        10 & $[1,2,5]$ &  50.84 \\
        100 & $[1,2,5,10,20,50]$ &  90.98 \\
        1000 & $[1,2,5,\ldots,100,200,500]$ &  136.46 \\
        10000 & $[1,2,5,\ldots,1000,2000,5000]$ &  181.95 \\
        100000 & $[1,2,5,\ldots,10000,20000,50000]$ & 227.43 \\
        1000000 & $[1,2,5,\ldots,10000,20000,50000]$ & 468.26 \\ \hline
    \end{tabular}
    \label{tab:avg_spend_time}
\vspace{-5mm}    
\end{table}