
\section{Definitions of Ideal Functionalities}
\label{sec:functionalitiesFULL}




\subsection{Secure Message Transmission}
\label{sec:IdealFunctionalitySMT}

Our e-cash schemes use the functionality $\Functionality_{\SMT}$ for secure message transmission described in~\cite{DBLP:conf/focs/Canetti01}. $\Functionality_{\SMT}$ interacts with a sender $\Sender$ and a receiver $\Receiver$, and consists of one interface $\fsmtsend$. $\Sender$ uses the $\fsmtsend$ interface to send a message $\SMTmessage$ to $\Functionality_{\SMT}$. $\Functionality_{\SMT}$ leaks $\SMTfleakage(\SMTmessage)$, where $\SMTfleakage: \fsmtmessagespace \rightarrow \mathbb{N}$ is a function that leaks the message length, to the simulator $\Simulator$. After receiving a response from $\Simulator$, $\Functionality_{\SMT}$ sends $\SMTmessage$ to  $\Receiver$. $\Simulator$ cannot modify $\SMTmessage$. The session identifier $\sid$ contains the identities of $\Sender$ and $\Receiver$. %$\Functionality_{\SMT}$ is depicted in Figure~\ref{fig:functionalitySMT}.

% \begin{figure}
% \begin{framed}

% \begin{center}
% 	  \textbf{Functionality $\Functionality_{\SMT}$}
% \end{center}

\noindent \textbf{Ideal Functionality $\Functionality_{\SMT}$.} $\Functionality_{\SMT}$ is parameterized by a message space $\fsmtmessagespace$ and by a leakage function $\SMTfleakage: \fsmtmessagespace \rightarrow \mathbb{N}$, which leaks the message length.
\begin{enumerate}[leftmargin=*]

\item On input $(\fsmtsendini, \allowbreak \sid, \allowbreak \SMTmessage)$ from a party $\Sender$:%, execute the following program:

\begin{itemize}

\item Abort if $\sid \neq ( \Sender, \Receiver, \sid')$ or if $\SMTmessage \notin \fsmtmessagespace$.

\item Create a fresh $\ssid$ and store $(\ssid, \Receiver, \SMTmessage)$.

\item Send $(\fsmtsendsim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \SMTfleakage(\SMTmessage))$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fsmtsendrep, \allowbreak \sid, \allowbreak \ssid)$ from $\Simulator$:%, execute the following program:

\begin{itemize}

\item Abort if $(\ssid, \Receiver, \SMTmessage)$ is not stored.

\item Delete the record $(\ssid, \Receiver, \SMTmessage)$.

\item Send $(\fsmtsendend, \allowbreak \sid, \allowbreak \SMTmessage)$ to $\Receiver$.

\end{itemize}

\end{enumerate}
% \end{framed}
%   \caption{Description of functionality $\Functionality_{\SMT}$}
%   \label{fig:functionalitySMT}
% \end{figure}

% \subsection{Ideal Functionality $\Functionality_{\RO}$}
% \label{sec:funcRO}

% $\Functionality_{\RO}$ (Figure~\ref{fig:functionalityRO}) models an idealized hash function. $\Functionality_{\RO}$ interacts with parties $\froParty$ and is parameterized by an output space $\frolength$ and a message space $\fromesspace$. $\Functionality_{\RO}$ consists of an interface $\froquery$. A party $\froParty$ uses the $\froquery$ interface on input a message $\fromessage$. $\Functionality_{\RO}$ checks whether $\fromessage$ has been received before. If that is not the case, $\Functionality_{\RO}$ generates a random response $\froresponse$, records $(\fromessage, \allowbreak \froresponse)$ and sends $\froresponse$ to $\froParty$. Otherwise $\Functionality_{\RO}$ sends the recorded $\froresponse$ to $\froParty$.

% \begin{figure}[t!]
%   \begin{framed}
%   \begin{center}
%     Functionality $\Functionality_{\RO}$
%   \end{center}

% \noindent $\Functionality_{\RO}$ is parameterized by an output space $\frolength$ and a message space $\fromesspace$.
% \begin{enumerate}

% \item On input $(\froqueryini, \allowbreak \sid, \allowbreak \fromessage)$ from $\froParty$:

% \begin{itemize}

%     \item Abort if $\fromessage \allowbreak \notin \allowbreak \fromesspace$.

%     \item If a tuple $(\sid, \allowbreak \fromessage', \allowbreak \froresponse)$ such that $\fromessage' = \fromessage$ is not stored, pick random $\froresponse \gets \frolength$ such that there is no stored tuple $(\sid, \allowbreak \fromessage, \allowbreak \froresponse')$ with $\froresponse = \froresponse'$ and store $(\sid, \allowbreak \fromessage, \allowbreak \froresponse)$.

%     \item Take the stored tuple $(\sid, \allowbreak \fromessage', \allowbreak \froresponse)$ such that $\fromessage' = \fromessage$ and send the message $(\froqueryend, \allowbreak \sid, \allowbreak \froresponse)$ to $\froParty$.

% \end{itemize}

% \end{enumerate}

% \end{framed}
%   \caption{Description of functionality $\Functionality_{\RO}$}
%   \label{fig:functionalityRO}
% \end{figure}


\subsection{Key Genearation}
\label{sec:funcKG}

In our e-cash constructions, the setup phase generates the parameters $\cecparams$ through algorithm $\cecSetup(1^{\securityparameter}, \allowbreak L)$. Moreover, algorithm  $\cecKeyGenA(\cecparams, \allowbreak t, \allowbreak n)$ generates a key pair for the Pointcheval-Sanders signature scheme in such a way that the shares of the secret key are given to $n$ authorities, so that $t \allowbreak \leq \allowbreak n$ authorities are needed to produce a signature.

To simplify our security analysis, in a manner similar to~\cite{cryptoeprint:2022:011}, we define an ideal functionality $\Functionality_{\KG}$ that runs both algorithms. In our construction in~\S\ref{sec:constructionCEC}, $\Functionality_{\KG}$ gives $\cecparams$ and the public keys $\spk$ and $(\spk_{\fcecAuthority_i})_{i\in[1,n]}$ to any party running the protocol, while each authority $\fcecAuthority_i$ also receives his secret key $\ssk_{\fcecAuthority_i}$.

$\Functionality_{\KG}$ could be replaced by an ideal functionality for distributed key generation (DKG)~\cite{DBLP:journals/iacr/KateHG12,cryptoeprint:2021:339}. DKG would avoid the need of a trusted party to generate the keys. With that replacement, our constructions would realize a modified version of our functionality in~\S\ref{sec:idealfunctionalityCEC}, where authorities cannot finalize the execution of the setup interface without involvement of other authorities. The security analysis of the remaining phases of our e-cash schemes is not affected by the fact that the authorities keys are generated by a trusted party or through a DKG protocol.

$\Functionality_{\KG}$ interacts with $n$ authorities $(\fkgAuthority_1, \ldots, \fkgAuthority_n)$. $\Functionality_{\KG}$ consists of two interfaces $\fkggetkey$ and $\fkgretrieve$. The interface $\fkggetkey$ is used by $\fkgAuthority_i$ to obtain its public key  $\spk_{\fcecAuthority_i}$ and secret key $\ssk_{\fcecAuthority_i}$, as well as the public key $\spk$ and the parameters $\cecparams$. The interface $\fkgretrieve$ is used by any party $\Party$ to obtain $\spk$, $\cecparams$ and the public keys $\langle \spk_{\fcecAuthority_i} \rangle_{i=1}^{n}$ of each of the authorities.

% \begin{figure}
%   \begin{framed}
%   \begin{center}
%     Functionality $\Functionality_{\KG}$
%   \end{center}


\noindent \textbf{Ideal Functionality $\Functionality_{\KG}$.}   $\Functionality_{\KG}$ is parameterized by probabilistic algorithms $\cecSetup$ and $\cecKeyGenA$, a security parameter $1^\securityparameter$, a threshold $t$ and a number $L$ of coins in a wallet.
\begin{enumerate}[leftmargin=*]

\item On input $(\fkggetkeyini, \sid)$ from an authority $\fkgAuthority_i$:

\begin{itemize}

\item Abort if $\sid \neq (\fkgAuthority_1, \ldots, \fkgAuthority_n, \sid')$, or if $n < t$.

\item If $(\sid, \cecparams, \allowbreak \spk, \allowbreak \langle \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$ is not stored, run  $\cecparams \allowbreak \gets \allowbreak \cecSetup(1^{\securityparameter}, \allowbreak \allowbreak L)$ and $(\spk, \allowbreak \langle \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]}) \allowbreak \gets \allowbreak \cecKeyGenA(\cecparams, \allowbreak t, \allowbreak n)$  and store $(\sid, \cecparams, \allowbreak \spk, \allowbreak \langle \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$.

\item Create a fresh $\ssid$ and store $(\qid, \allowbreak \fkgAuthority_i)$.

\item Send $(\fkggetkeysim, \allowbreak \sid, \allowbreak \qid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fkggetkeyrep, \allowbreak \sid, \allowbreak \qid)$ from the simulator $\Simulator$: %, execute the following program:

\begin{itemize}

\item Abort if $(\qid, \allowbreak \fkgAuthority_i)$ such that $\qid \allowbreak \neq \allowbreak \qid'$ is not stored.

\item Delete $(\qid, \allowbreak \fkgAuthority_i)$.

\item Send $(\fkggetkeyend, \allowbreak \sid, \allowbreak \cecparams, \allowbreak \spk, \allowbreak \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i})$ to $\fkgAuthority_i$.

\end{itemize}


\item On input $(\fkgretrieveini, \allowbreak \sid)$ from any party $\Party$:%, execute the following program:

\begin{itemize}

\item Abort if $\sid \neq (\fkgAuthority_1, \ldots, \fkgAuthority_n, \sid')$.

\item If $(\sid, \cecparams, \allowbreak \spk, \allowbreak \langle \ssk_{\fcecAuthority_i}, \allowbreak \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$ is stored, set $\fkgvalue \gets  (\cecparams, \allowbreak \spk, \allowbreak \langle  \spk_{\fcecAuthority_i} \rangle_{i\in[1,n]})$, else set $\fkgvalue \gets \bot$.

\item Create a fresh $\ssid$ and store $(\ssid, \Party, \fkgvalue)$.

\item Send $(\fkgretrievesim, \allowbreak \sid, \allowbreak \ssid, \allowbreak \fkgvalue)$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fkgretrieverep, \allowbreak \sid, \allowbreak \ssid)$ from  $\Simulator$:%, execute the following program:

\begin{itemize}

\item Abort if $(\ssid', \Party, \fkgvalue)$ such that $\ssid' \neq \ssid$ is not stored.

\item Delete the record $(\ssid, \Party, \fkgvalue)$.

\item Send $(\fkgretrieveend, \allowbreak \sid, \allowbreak \fkgvalue)$ to $\Party$.

\end{itemize}

\end{enumerate}

% \end{framed}
%   \caption{Description of functionality $\Functionality_{\KG}$}
%   \label{fig:functionalityKG}
% \end{figure}

\subsection{Registration}
\label{sec:funcREG}


Our protocol uses the functionality $\Functionality_{\Freg}$ for key registration by Canetti~\cite{DBLP:conf/focs/Canetti01}. $\Functionality_{\Freg}$ interacts with any party $\FregT$ that registers a message $\fregvalue$ and with any party $\Party$ that retrieves the registered message. $\Functionality_{\Freg}$ consists of two interfaces $\fregregister$ and $\fregretrieve$. The interface $\fregregister$ is used by $\FregT$ to register a message $\fregvalue$ with $\Functionality_{\Freg}$. A party $\Party$ uses $\fregretrieve$ to retrieve $\fregvalue$ from $\Functionality_{\Freg}$.% $\Functionality_{\Freg}$ is depicted in Figure~\ref{fig:functionalityREG}.

% \begin{figure}
%   \begin{framed}
%   \begin{center}
%     Functionality $\Functionality_{\Freg}$
%   \end{center}

\noindent \textbf{Ideal Functionality $\Functionality_{\Freg}$.} $\Functionality_{\Freg}$ is parameterized by a message space $\fregmessagespace$.
\begin{enumerate}[leftmargin=*]
%\footnotesize
\item On input $(\fregregisterini, \allowbreak \sid, \allowbreak \fregvalue)$ from a party $\FregT$: %, execute the following program:

\begin{itemize}

\item Abort if $\sid \neq (\FregT, \sid')$, or if $\fregvalue \notin \fregmessagespace$ or if there is a tuple $(\sid,\fregvalue',0)$ stored.

\item Store $(\sid,\fregvalue,0)$.

\item Send $(\fregregistersim, \allowbreak \sid, \allowbreak \fregvalue)$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fregregisterrep, \allowbreak \sid)$ from the simulator $\Simulator$: %, execute the following program:

\begin{itemize}

\item Abort if $(\sid, \fregvalue, 0)$ is not stored or if $(\sid, \fregvalue, 1)$ is already stored.

\item Store $(\sid,\fregvalue,1)$ and parse $\sid$ as $(\FregT, \sid')$.

\item Send $(\fregregisterend, \allowbreak \sid)$ to $\FregT$.

\end{itemize}

\item On input $(\fregretrieveini, \allowbreak \sid)$ from any party $\Party$:%, execute the following program:

\begin{itemize}

\item If $(\sid,\fregvalue,1)$ is stored, set $\fregvalue' \gets \fregvalue$; else set $\fregvalue' \gets \bot$.

\item Create a fresh $\ssid$ and store $(\ssid, \Party, \fregvalue')$.

\item Send $(\fregretrievesim, \sid, \ssid, \fregvalue')$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fregretrieverep, \sid, \ssid)$ from  $\Simulator$:%, execute the following program:

\begin{itemize}

\item Abort if $(\ssid, \Party, \fregvalue')$ is not stored.

\item Delete the record $(\ssid, \Party, \fregvalue')$.

\item Send $(\fregretrieveend, \sid, \fregvalue')$ to $\Party$.

\end{itemize}

\end{enumerate}
% \end{framed}
%   \caption{Description of functionality $\Functionality_{\Freg}$}
%   \label{fig:functionalityREG}
% \end{figure}


\subsection{Pseudonymous Channel}
\label{sec:funcNYM}

Our e-cash schemes use the functionality $\Functionality_{\NYM}$ for a secure idealized pseudonymous channel. We use $\Functionality_{\NYM}$ to describe our e-cash schemes for simplicity, in order to hide the details of real-world pseudonymous channels. $\Functionality_{\NYM}$ is similar to the functionality for anonymous secure message transmission in~\cite{DBLP:conf/esorics/CamenischLNR14}. $\Functionality_{\NYM}$ interacts with senders $\fnymSender$ and receivers $\fnymReceiver$.  $\Functionality_{\NYM}$ is parameterized by a message space $\fnymmessagespace$, a security parameter $\securityparameter$, a universe of pseudonyms $\fnymunivnym$, and a leakage function $\fnymleakage$, which leaks the message length. $\Functionality_{\NYM}$ consists of one interfaces $\fnymsend$. $\fnymSender$ uses the $\fnymsend$ interface to send a message $\fnymmessage \in \fnymmessagespace$, a pseudonym $\fnymnym \in \fnymunivnym$ and a receiver identifier $\fnymReceiver$ to $\Functionality_{\NYM}$. $\Functionality_{\NYM}$ sends $\fnymleakage(\fnymmessage)$ to the simulator $\Simulator$. After receiving a response from $\Simulator$, $\Functionality_{\NYM}$ sends $\fnymmessage$ and $\fnymnym$ to $\fnymReceiver$.

% \item $\fnymReceiver$ uses the $\fnymreply$ interface to send a message $\fnymmessage \in \fnymmessagespace$ and a send identifier $\fnymsendid$ to $\Functionality_{\NYM}$. $\Functionality_{\NYM}$ checks if there is a reply pending for send identifier $\fnymsendid$. In that case, $\Functionality_{\NYM}$ sends $\fnymleakage(\fnymmessage)$ to  $\Simulator$.  After receiving a response from $\Simulator$, $\Functionality_{\NYM}$ sends $\fnymmessage$ and $\fnymnym$ to $\fnymSender$.


$\fnymReceiver$ does not learn the identifier $\fnymSender$. Instead $\fnymReceiver$ learns a pseudonym $\fnymnym$ chosen by $\fnymSender$. $\fnymSender$ can choose different pseudonyms to make the messages sent unlinkable towards $\fnymReceiver$.

% \begin{figure}[t!]
%   \begin{framed}
%   \begin{center}
%     Functionality $\Functionality_{\NYM}$
%   \end{center}

\noindent \textbf{Ideal Functionality $\Functionality_{\NYM}$.} $\Functionality_{\NYM}$ is parameterized by a message space $\fnymmessagespace$, a security parameter $\securityparameter$, a universe of pseudonyms $\fnymunivnym$, and a leakage function $\fnymleakage$, which leaks the message length.
\begin{enumerate}[leftmargin=*]
%\footnotesize
\item On input $(\fnymsendini, \allowbreak \sid, \allowbreak \fnymmessage, \allowbreak \fnymnym, \allowbreak \fnymReceiver)$ from $\fnymSender$:

\begin{itemize}

\item Abort if $\fnymmessage \allowbreak \notin \allowbreak \fnymmessagespace$, or if $\fnymnym \allowbreak \notin \allowbreak \fnymunivnym$.

\item Create a fresh $\qid$ and store $(\qid, \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage, \allowbreak \fnymReceiver)$.

\item Send $(\fnymsendsim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fnymleakage(\fnymmessage))$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fnymsendrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:

\begin{itemize}

\item Abort if $(\qid',  \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage, \allowbreak \fnymReceiver)$ such that $\qid = \qid'$ is not stored.

% \item Create random fresh $\fnymsendid \gets [0,1]^\securityparameter$ and store $(\sid, \allowbreak \fnymSender, \allowbreak \fnymnym, \allowbreak \fnymsendid)$.

\item Delete the record $(\qid, \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage, \allowbreak \fnymReceiver)$.

\item Send $(\fnymsendend, \allowbreak \sid, \allowbreak \fnymmessage, \allowbreak \fnymnym)$ to $\fnymReceiver$.

\end{itemize}

% \item On input $(\fnymreplyini, \allowbreak \sid, \allowbreak \fnymmessage, \allowbreak \fnymsendid)$ from $\fnymReceiver$:

% \begin{itemize}

% \item Abort if $\fnymmessage \allowbreak \notin \allowbreak \fnymmessagespace$.

% \item Abort if there is not a tuple $(\sid,  \allowbreak \fnymSender, \allowbreak \fnymnym,  \allowbreak \fnymsendid')$ stored such that $\fnymsendid = \fnymsendid'$.

% \item Create a fresh $\qid$ and store $(\qid, \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage)$.

% \item Delete the tuple $(\sid,  \allowbreak \fnymSender, \allowbreak \fnymnym,  \allowbreak \fnymsendid)$.

% \item Send $(\fnymreplysim, \allowbreak \sid, \allowbreak \qid, \allowbreak \fnymleakage(\fnymmessage))$ to $\Simulator$.

% \end{itemize}

% \item[S.] On input $(\fnymreplyrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:

% \begin{itemize}

% \item Abort if $(\qid', \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage)$ such that $\qid = \qid'$ is not stored.

% \item Delete the record $(\qid, \allowbreak \fnymnym, \allowbreak \fnymSender, \allowbreak \fnymmessage)$.

% \item Send $(\fnymreplyend, \allowbreak \sid, \allowbreak \fnymmessage, \allowbreak \fnymnym)$ to $\fnymSender$.

% \end{itemize}

\end{enumerate}

% \end{framed}
%   \caption{Description of functionality $\Functionality_{\NYM}$}
%   \label{fig:functionalityNYM}
% \end{figure}


\subsection{Authenticated Bulletin Board}
\label{sec:funcBB}

Our e-cash schemes use the functionality $\Functionality_{\BB}$ for an authenticated bulletin board $\fbbbb$~\cite{DBLP:conf/tcc/Wikstrom04}. A $\fbbbb$ is used to store the payments deposited by providers, and to verify that there are not double spendings or double deposits. $\Functionality_{\BB}$ interacts with writers $\fbbWriter_j$ and readers $\fbbReader_k$. $\fbbWriter_j$ uses the $\fbbwrite$ interface to send a message $\fbbmessage$ to $\Functionality_{\BB}$. $\Functionality_{\BB}$ increments a counter $\fbbcounter$ of the number of messages stored in $\fbbbb$ and appends $[\fbbcounter, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage]$ to $\fbbbb$. $\fbbReader_k$ uses the $\fbbgetbb$ interface on input an index $\fbbindex$. If $\fbbindex \allowbreak \in \allowbreak [1, \allowbreak \fbbcounter]$, $\Functionality_{\BB}$ takes the tuple $[\fbbindex, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage]$ in $\fbbbb$ and sends $(\fbbWriter_j, \allowbreak \fbbmessage)$ to $\fbbReader_k$.

% \begin{figure}
%   \begin{framed}
%   \begin{center}
%     Functionality $\Functionality_{\BB}$
%   \end{center}

\noindent \textbf{Ideal Functionality $\Functionality_{\BB}$.} $\Functionality_{\BB}$ is parameterized by a universe of messages $\fbbunivmes$.  $\Functionality_{\BB}$ interacts with writers $\fbbWriter_j$ and readers $\fbbReader_k$.
\begin{enumerate}[leftmargin=*]

\item On input $(\fbbwriteini, \allowbreak \sid, \allowbreak \fbbmessage)$ from $\fbbWriter_j$:

\begin{itemize}

%\item Abort if $\sid \notin (\fbbWriter, \allowbreak \sid')$.

\item Abort if $\fbbmessage \allowbreak \notin \allowbreak \fbbunivmes$.

\item Create a fresh $\qid$ and store $(\qid, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage)$.

\item Send $(\fbbwritesim, \allowbreak \sid, \allowbreak \qid)$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fbbwriterep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:

\begin{itemize}

\item Abort if $(\qid', \allowbreak \fbbWriter_j, \allowbreak \fbbmessage)$ such that $\qid' \allowbreak = \allowbreak \qid$  is not stored.

\item If $(\sid, \allowbreak \fbbbb, \allowbreak \fbbcounter)$ is not stored, set $\fbbbb \gets \bot$ and $\fbbcounter \gets 0$.

\item Increment $\fbbcounter$, append $[\fbbcounter, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage]$ to $\fbbbb$ and update $\fbbcounter$ and $\fbbbb$ in $(\sid, \allowbreak \fbbbb, \allowbreak \fbbcounter)$.

\item Delete $(\qid, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage)$.

\item Send $(\fbbwriteend, \allowbreak \sid)$ to $\fbbWriter_j$.

\end{itemize}


\item On input $(\fbbgetbbini, \allowbreak \sid, \allowbreak \fbbindex)$ from $\fbbReader_k$:

\begin{itemize}

\item Create a fresh $\qid$ and store $(\qid, \allowbreak \fbbReader_k, \allowbreak \fbbindex)$.

\item Send $(\fbbgetbbsim, \allowbreak \sid, \allowbreak \qid)$ to $\Simulator$.

\end{itemize}

\item[S.] On input $(\fbbgetbbrep, \allowbreak \sid, \allowbreak \qid)$ from $\Simulator$:

\begin{itemize}

\item Abort if $(\qid', \fbbReader_k, \allowbreak \fbbindex)$ such that $\qid' = \qid$ is not stored.

\item If $(\sid, \allowbreak \fbbbb, \allowbreak \fbbcounter)$ is stored and $\fbbindex \in [1, \fbbcounter]$, take $[\fbbindex, \allowbreak \fbbWriter_j, \allowbreak \fbbmessage]$ from $\fbbbb$ and set $\fbbmessage' \gets (\fbbWriter_j, \allowbreak \fbbmessage)$, else set $\fbbmessage' \allowbreak \gets \allowbreak \bot$.

\item Send $(\fbbgetbbend, \allowbreak \sid, \allowbreak \fbbmessage')$ to $\fbbReader_k$.

\end{itemize}

\end{enumerate}

% \end{framed}
%   \caption{Description of functionality $\Functionality_{\BB}$}
%   \label{fig:functionalityBB}
% \end{figure}
