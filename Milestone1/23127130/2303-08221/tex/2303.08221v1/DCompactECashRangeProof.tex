
\section{Compact E-Cash with Range Proof Instantiation}
\label{sec:compactECashRangeProof}

The zero-knowledge argument of knowledge in algorithm $\cecSpend$ involves a statement $l \allowbreak \in \allowbreak [0, L-1]$ to prove the validity of the index of the spent coin. To implement it, one option is to use the set membership proof described in~\cite{DBLP:conf/asiacrypt/CamenischCS08}. This proof consists in proving possession of a signature that signs the index $l$. We use the Pointcheval-Sanders signature scheme to instantiate it. Algorithm $\cecSetup$ is extended to compute a signing key pair and signatures on all the values in the range $[0, \allowbreak L-1]$. Algorithm $\cecSpend$ is extended to include a zero-knowledge argument of knowledge of the signature that signs $l$, and algorithm $\cecSpendVf$ is extended to verify it. The modified algorithms work as follows:
\begin{description}[leftmargin=*]

\item[$\cecSetup(1^{\securityparameter}, L)$.] Execute the following steps:

\begin{itemize}

    \item Run $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb) \gets \BilinearSetup(1^\securityparameter)$.

    \item Pick $3$ random generators $(\gamma_1, \gamma_2, \delta) \gets \Ga$.

    \item Run $(\ssk,\spk) \allowbreak \gets \allowbreak \SKeygen(1^\securityparameter, \allowbreak 1)$, i.e., pick random secret key $(x, \allowbreak y) \gets \mathbb{Z}_p^{2}$ and output the secret key $\ssk = (x, \allowbreak y)$ and the public key $\spk = (\tilde{\alpha}_{sm}, \tilde{\beta}_{sm}) \gets (\gb^x, \allowbreak \gb^{y})$.

    \item For all $l \allowbreak \in \allowbreak [0, L-1]$, compute $\ssig_l \gets \SSign(\ssk, \allowbreak l)$, i.e., pick random $r_l \gets \Zp$, set $h_l \gets \ga^{r_l}$ and output the signature $\ssig_l = (h_l, s_l) \gets (h_l, h_l^{x+yl})$.

    \item Set the parameters $\cecparams \gets (\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gamma_1, \gamma_2, \allowbreak \delta, \allowbreak \tilde{\alpha}_{sm}, \allowbreak \tilde{\beta}_{sm}, \allowbreak \ssig_0, \allowbreak \ldots, \allowbreak \ssig_{L-1}, \allowbreak L)$.

    \item Output $\cecparams$.

\end{itemize}

\item[$\cecSpend(\spk, \ssk_{\fcecUser_j}, \cecwallet, \cecpaymentinfo, V)$.] Execute the following steps:

\begin{itemize}

    \item Parse $\cecwallet$ as $(\sigma, \allowbreak \cecsn, \allowbreak l)$. If $l + V -1 \geq L$, output $0$.

    \item Parse $\sigma$ as $(\h, \allowbreak s)$.

    \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Pick random $r \gets \Zp$ and $r' \gets \Zp$.

    \item Compute $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$.

    \item Compute $\kappa \gets \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$.

    \item Pick random $o_c \gets \Zp$ and compute the commitment $C \gets \ga^{o_c} \gamma_1^{\cecsn}$.

    \item For $k \in [0,V-1]$, compute $R_k \gets H'(\cecpaymentinfo,k)$, where $\cecpaymentinfo$ must contain the identifier of the merchant, and $H'$ is a collision-resistant hash function.

    \item For $k \in [0,V-1]$, set $l_k \gets l+k$, pick random $o_{a_k}$ and compute $A_k = \ga^{o_{a_k}} \gamma_1^{l_k}$.

    \item For $k \in [0,V-1]$, evaluate the pseudorandom functions $S_{k} \gets f_{\delta,\cecsn}(l_k) = \delta^{1/(\cecsn+l_k+1)}$ and $T_k \gets \ga^{\ssk_{\fcecUser_j}} (f_{\ga,\cecsn}(l_k))^{R_{k}} = \ga^{\ssk_{\fcecUser_j} + R_{k}/(\cecsn+l_k+1)}$.

    \item For $k \in [0,V-1]$, compute the values $\mu_k \gets 1/(\cecsn+l_k+1)$ and $o_{\mu_k} \gets -(o_{a_k} + o_c) \mu_k$.

    \item Parse $\cecparams$ as the tuple $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak \tilde{\alpha}_{sm}, \allowbreak  \tilde{\beta}_{sm}, \allowbreak \ssig_0, \allowbreak \ldots, \allowbreak \ssig_{L-1}, \allowbreak L)$.

    \item For $k \in [0,V-1]$, pick random $r_{k} \gets \Zp$ and $r'_{k} \gets \Zp$.

    \item For $k \in [0,V-1]$, parse $\ssig_{l_k}$ as $(\h_{l_k}, \allowbreak s_{l_k})$. Compute $\sigma'_{l_k} = (\h'_{l_k},s'_{l_k}) \allowbreak \gets \allowbreak (\h_{l_k}^{r'_{k}}, s_{l_k}^{r'_{k}}(\h'_{l_k})^{r_{k}})$.

    \item For $k \in [0,V-1]$, compute $\kappa_{k} \gets \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l_k} \gb^{r_{k}}$.



    \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
    \begin{align*}
        \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, o_c, \langle l_k, r_{k}, o_{a_k}, \mu_k, o_{\mu_k} \rangle_{k=0}^{V-1}): \\
        &\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\ C = \ga^{o_c} \gamma_1^{\cecsn}\ \land\  \\&
        \langle A_k = \ga^{o_{a_k}} \gamma_1^{l_k}\ \land\ \kappa_{k} = \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l_k} \gb^{r_{k}} \land\ \\&
        S_k=\delta^{\mu_k}\ \land\ \gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}\ \land\ \\&
        T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}\  \rangle_{k\in[0,V-1]}
        \}
    \end{align*}
    The equation $\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$ proves that $\kappa$ commits to the signed messages. ($\kappa$ is used as part of the proof of signature possession.) The equation $C = \ga^{o_c} \gamma_1^{\cecsn}$ proves that $C$ commits to the same value $\cecsn$ committed in $\kappa$. The equations $A_k = \ga^{o_{a_k}} \gamma_1^{l_k}$ and $\kappa_{k} = \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l_k} \gb^{r_{k}}$ prove that the value $l_k$ committed in $A_k$ is in the valid range $[0,L-1]$ for a wallet with $L$ coins. The equations $S_k=\delta^{\mu_k}$, $\gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}$ and $T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}$ prove that the serial numbers $S_k$ and the security tags $T_k$ are correctly computed. This non-interactive argument signs the payment information $\cecpaymentinfo$.


    % \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
    % \begin{align*}
    %     \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, \cect, r, o_c, o_d, \langle l+k, r_{k}, o_{a_k}, \mu_k, \lambda_k, o_{\mu_k}, o_{\lambda_k}\rangle_{k=0}^{V-1}): \\ &
    %     \kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \tilde{\beta}_3^{\cect} \gb^{r}\ \land\ \\&
    %     C = \ga^{o_c} \gamma_1^{\cecsn}\ \land\ D = \ga^{o_d} \gamma_1^{\cect}\ \land\ \\&
    %     \langle A_k = \ga^{o_{a_k}} \gamma_1^{l+k}\ \land\
    %     S_k=\ga^{\mu_k}\ \land\ \gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}\ \land\ \\&
    %     T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\lambda_k}\ \land\ \gamma_1 = (A_k D\gamma_1)^{\lambda_k} \ga^{o_{\lambda_k}} \rangle_{k\in[0,V-1]}
    %     \}
    % \end{align*}
    % The equation $\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \tilde{\beta}_3^{\cect} \gb^{r}$ proves that $\kappa$ commits to the signed messages. ($\kappa$ is used as part of the proof of signature possession.) The equations $C = \ga^{o_c} \gamma_1^{\cecsn}$ and $D = \ga^{o_d} \gamma_1^{\cect}$ prove that $C$ and $D$ commit to the same values $\cecsn$ and $\cect$ committed in $\kappa$. The equations $A_k = \ga^{o_{a_k}} \gamma_1^{l+k}$ and $\kappa_{k} = \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l+k} \gb^{r_{k}}$ are part of the proof that the value $l+k$ committed in $A_k$ is in the valid range $[0, \allowbreak L-1]$ for a wallet with $L$ coins. The equations $S_k=\ga^{\mu_k}$ and $\gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}$ prove that the serial numbers $S_k$ are correctly computed. The equations $T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\lambda_k}$ and $\gamma_1 = (A_k D\gamma_1)^{\lambda_k} \ga^{o_{\lambda_k}}$ prove that the security tags are correctly computed.
    % This non-interactive argument signs the payment information $\cecpaymentinfo$.
    % % Note for implementation: The $\cecpaymentinfo$ has to be included in the hash inside the proof

    \item Output $\cecpayment \gets (\kappa, \sigma', \langle S_k, T_k, A_k, \kappa_{k}, \sigma'_{l+k}  \rangle_{k\in[0,V-1]}, V, C, \allowbreak \pi_v)$    and an updated wallet $\cecwallet' \gets (\sigma, \allowbreak \cecsn, \allowbreak l+V)$.

\end{itemize}

% \begin{itemize}

%     \item Parse $\cecwallet$ as $(\sigma, \allowbreak \cecsn, \allowbreak \cect, \allowbreak l)$. If $l \geq L$, output $0$.

%     \item Parse $\sigma$ as $(\h, \allowbreak s)$.

%     \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \ldots, \beta_{3}, \tilde{\beta}_{3})$.

%     \item Pick random $r \gets \Zp$ and $r' \gets \Zp$.

%     \item Compute $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$.

%     \item Compute $\kappa \gets \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \tilde{\beta}_3^{\cect} \gb^{r}$.

%     \item Pick random $o_a,o_c,o_d \gets \Zp$ and compute the commitments $A = \ga^{o_a} \gamma_1^{l}$, $C = \ga^{o_c} \gamma_1^{\cecsn}$ and $D = \ga^{o_d} \gamma_1^{\cect}$.

%     \item Compute $R \gets H(\cecpaymentinfo)$, where $\cecpaymentinfo$ must contain the identifier of the merchant, and $H$ is a collision-resistant hash function.

%     \item Evaluate the pseudorandom functions $S \gets f_{\ga,\cecsn}(l) = g^{1/(\cecsn+l+1)}$ and $T \gets \ga^{\ssk_{\fcecUser_j}} (f_{\ga,\cect}(l))^{R} = \ga^{\ssk_{\fcecUser_j} + R/(\cect+l+1)}$.

%     \item Compute the values $\mu \gets 1/(\cecsn+l+1)$, $o_{\mu} \gets -(o_a + o_c) \mu$, $\lambda \gets 1/(\cect+l+1)$ and $o_{\lambda} \gets -(o_a + o_d) \lambda$.

%     \item Parse $\cecparams$ as $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb,\gamma_1, \ldots, \gamma_3, \tilde{\alpha}_{sm}, \tilde{\beta}_{sm}, \ssig_0, \ldots, \allowbreak \ssig_{L-1}, \allowbreak L)$.

%     \item Pick random $r_l \gets \Zp$ and $r'_l \gets \Zp$.

%     \item Parse $\ssig_{l}$ as $(\h_l, \allowbreak s_l)$. Compute $\sigma'_l = (\h'_l,s'_l) \gets (\h_l^{r'_l}, s_l^{r'_l}(\h'_l)^{r_l})$.

%     \item Compute $\kappa_l \gets \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l} \gb^{r_l}$.

%     \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
%     \begin{align*}
%         \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, \cect, r, r_l, l, o_a, o_c, o_d, \mu, \lambda, o_\mu, o_\lambda): \\ &
%         \kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \tilde{\beta}_3^{\cect} \gb^{r}\ \land\ \\&
%         A = \ga^{o_a} \gamma_1^{l}\ \land\ C = \ga^{o_c} \gamma_1^{\cecsn}\ \land\ D = \ga^{o_d} \gamma_1^{\cect}\ \land\ \\&
%         S=\ga^{\mu}\ \land\ \gamma_1 = (AC\gamma_1)^{\mu} \ga^{o_\mu}\ \land\ \\&
%         T=\ga^{\ssk_{\fcecUser_j}} (\ga^{R})^{\lambda}\ \land\ \gamma_1 = (AD\gamma_1)^{\lambda} \ga^{o_\lambda}\ \land\ \\&
%         \kappa_l = \tilde{\alpha}_{sm} \tilde{\beta}_{sm}^{l} \gb^{r_l}\}
%     \end{align*}
%     This non-interactive proof signs the payment information $\cecpaymentinfo$.
%     % Note for implementation: The $\cecpaymentinfo$ has to be included in the hash inside the proof

%     \item Output a payment $\cecpayment \gets (\kappa, \sigma', \kappa_l, \sigma'_l, S, T, A, C, D, R, \pi_v)$ and an updated wallet $\cecwallet' \gets (\sigma, \allowbreak \cecsn, \allowbreak \cect, \allowbreak l+1)$.

% \end{itemize}

\item[$\cecSpendVf(\spk, \cecpayment, \cecpaymentinfo)$.] Execute the following steps:

\begin{itemize}

    \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Parse $\cecpayment$ as $(\kappa, \sigma', \langle S_k, T_k, A_k, \kappa_{k}, \sigma'_{l_k} \rangle_{k\in[0,V-1]}, V, C,  \pi_v)$.

    \item Parse $\sigma'$ as $(\h', \allowbreak s')$ and output $0$ if $\h' = 1$ or if $\e(\h', \kappa) \allowbreak = \allowbreak \e(s',\gb)$ does not hold.

    \item For $k \in [0,V-1]$, parse $\sigma'_{l_k}$ as $(\h'_{l_k}, \allowbreak s'_{l_k})$ and output $0$ if $\h'_{l_k} = 1$ or if $\e(\h'_{l_k}, \kappa_{k}) \allowbreak = \allowbreak \e(s'_{l_k},\gb)$ does not hold.

    \item Output $0$ if not all the serial numbers $\langle S_k \rangle_{k\in[0,V-1]}$ are different from each other.

    \item For $k \in [0,V-1]$, compute $R_k \gets H'(\cecpaymentinfo,k)$.

    \item Verify $\pi_v$ by using $\cecpaymentinfo$, $\spk$, $\langle S_k, T_k, A_k, R_{k}, \kappa_{k} \rangle_{k\in[0,V-1]}$, $C$ and $\kappa$. Output $0$ if the proof is not correct, else output $V$.


    % \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \ldots, \beta_{3}, \tilde{\beta}_{3})$.

    % \item Parse $\cecpayment$ as $(\kappa, \allowbreak \sigma', \allowbreak \kappa_l, \allowbreak \sigma'_l, \allowbreak S, \allowbreak T, \allowbreak A, \allowbreak C, \allowbreak D, \allowbreak R, \allowbreak \pi_v)$.

    % \item Parse $\sigma'$ as $(\h', \allowbreak s')$ and output $0$ if $\h' = 1$ or if $\e(\h', \kappa) \allowbreak = \allowbreak \e(s',\gb)$ does not hold.

    % \item Parse $\sigma'_l$ as $(\h'_l, \allowbreak s'_l)$ and output $0$ if $\h'_l = 1$ or if $\e(\h'_l, \kappa_l) \allowbreak = \allowbreak \e(s'_l,\gb)$ does not hold.

    % \item Output $0$ if $R \neq H(\cecpaymentinfo)$ or if $\cecpaymentinfo$ does not contain the identifier of the merchant.

    % \item Verify $\pi_v$ by using $\cecpaymentinfo$, $\spk$, $S$, $T$, $A$, $C$, $D$, $R$, $\kappa$ and $\kappa_l$. Output $0$ if the proof is not correct, else output $1$.

\end{itemize}

\paragraph{Cost reduction by using one secret in the wallet.} We quantify the reduction of costs attained by having a wallet that signs one secret instead of two (as done in the compact e-cash scheme in~\cite{DBLP:conf/eurocrypt/CamenischHL05}),  in addition to the user secret key. First, we analyze the communication and storage costs. Let $|\Ga|$, $|\Gb|$ and $|\Zp|$ denote the bit size of elements in $\Ga$, $\Gb$ and $\Zp$ respectively. The size of the public parameters does not change. The size of public keys of authorities is $2|\Ga|+3|\Gb|$ with one secret and $3|\Ga|+4|\Gb|$ with two secrets. The size of the secret key of authorities is $3|\Zp|$ with one secret and $4|\Zp|$ with two secrets. In the withdrawal phase, the size of a response does not change, but the size of a request is $8|\Ga|+6|\Zp|$ with one secret and $10|\Ga|+8|\Zp|$ with two secrets. The wallet size is $2|\Ga|+1|\Zp|$ with one secret and $2|\Ga|+2|\Zp|$ with two secrets. The size of a payment of $V$ coins is $(2+5V+1)|\Ga|+(1+V)|\Gb|+(5+5V)|\Zp|$ with one secret and $(2+5V+2)|\Ga|+(1+V)|\Gb|+(7+7V)|\Zp|$ with two secrets. 

Second, we analyze the computation cost. We remark that the number of bilinear map computations does not change. Let $|M|$ and $|E|$ denote the cost of a multi-exponentiation and of a exponentiation respectively. In a withdrawal phase in which the user contacts $t$ authorities, the total cost is $9|M|+(4+7t)|E|$ with one secret and $12|M|+(5+10t)|E|$ with two secrets. In a spending phase in which $V$ coins are spent, the total cost is $(6+11V)|M|+(4+5V)|E|$ with one secret and $(9+13V)|M|+(5+5V)|E|$ with two secrets. The cost of the deposit phase does not change.
\end{description}
