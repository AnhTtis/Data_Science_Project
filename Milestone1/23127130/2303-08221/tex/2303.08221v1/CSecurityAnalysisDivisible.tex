
\section{Security Proof for Our Divisible E-Cash Scheme}
\label{sec:securityProofDivisible}

In~\S\ref{sec:securityProofCompact}, we provide a detailed security proof for our compact $\CEC$ scheme. In this section, we analyze the security of our divisible $\CEC$ scheme, but we omit a full proof. Instead, we discuss the points where the security analysis of our divisible $\CEC$ scheme differs from the analysis of our compact $\CEC$ scheme.

For the interfaces $\fcecsetup$, $\fcecregister$, $\fcecrequest$, and $\fcecissue$, the simulator for the divisible $\CEC$ scheme is equal to that of our compact $\CEC$ scheme. We recall that both schemes use the same algorithms for the $\fcecregister$, $\fcecrequest$ and $\fcecissue$ interfaces. For the $\fcecsetup$ interface, although algorithm $\cecSetup$ is different in our schemes, the algorithm is run in both cases by $\Functionality_{\KG}$, as specified in our simulation. 

In the spending phase, the simulator for the divisible $\CEC$ scheme, like in the compact $\CEC$ scheme, outputs failure when the adversary submits a payment such that the simulator fails to extract a valid PS signature, or when the adversary did not receive signatures from $t - \tilde{t}$ authorities on the signed messages. Additionally, the simulator for the divisible $\CEC$ scheme outputs failure if it is unable to extract a SPS signature on $(\varsigma_{l+V-1}, \allowbreak \theta_{l+V-1})$, where $(\varsigma_{l+V-1}, \allowbreak \theta_{l+V-1})$ are part of the public parameters. It also outputs failure if the extracted $(\varsigma_{l}, \allowbreak \theta_{l})$ are not part of the public parameters. In the security proof, the probability that extraction fails is negligible thanks to the weak simulation extractability property of the ZK argument $\pi_v$, the existential unforgeability of the SPS signature scheme, and the BDHI assumption. All these arguments ensure that $\phi_{V,l}$ and $\varphi_{V,l}$ are computed correctly.

In the spending phase, to simulate a payment $(\kappa, \allowbreak \sigma', \allowbreak \phi_{V,l}, \allowbreak \varphi_{V,l}, \allowbreak R, \allowbreak \pi_v, \allowbreak  V)$, the values $\kappa$ and $\sigma'$ for the proof of possession of a PS signature are simulated like in the simulator for our compact $\CEC$ scheme (see Figure~\ref{fig:proc2}). The proof $\pi_v$ is also simulated by using the simulator $S_v$. The values $\phi_{V,l}$ and $\varphi_{V,l}$ are set to random. In the security proof, it can be shown that a simulated payment is indistinguishable from an honestly computed payment under the $N$-MXDH' assumption. The proof is similar to one given in~\cite{DBLP:conf/pkc/PointchevalST17}. We remark that, in the proof in~\cite{DBLP:conf/pkc/PointchevalST17}, an element of the $N$-MXDH' instance is needed to simulate the request message because the element $U_2 = u_2^\cecsn$ is revealed to the bank, whereas in our case that is not needed thanks to the hiding property of the commitment scheme.

In the deposit phase, the behavior of both simulators is similar, taking into account that the serial numbers and double spending tags are computed differently. The simulator also outputs failure if double spending happened but the identification algorithm does not identify the double spender. In the security proof, after it is ensured, as described above, that the ElGamal encryptions $\phi_{V,l}$ and $\varphi_{V,l}$ sent by the adversary are computed correctly, we know that serial numbers and double spending tags can be retrieved. Then we can prove, as in the case of the compact $\CEC$ scheme, that the user guilty of double spending can be identified under the collision resistance property of the hash function $H'$.

The simulator also outputs failure when there is not double spending, but an honest user is found guilty. In the security proof, like in our $\CEC$ scheme, we can show that the simulator fails with negligible probability under the hardness of the discrete logarithm problem.

% To prove that construction $\mathrm{\Pi}_\CEC$, instantiated with the algorithms of the divisible e-cash scheme in~\S\ref{sec:divisibleecash}, securely realizes the ideal functionality $\Functionality_{\CEC}$, we have to show that for any environment $\Environment$ and any adversary $\Adversary$ there exists a simulator $\Simulator$ such that $\Environment$ cannot distinguish between whether it is interacting with $\Adversary$ and the protocol in the real world or with $\Simulator$ and $\Functionality_{\CEC}$. The simulator thereby plays the role of all honest parties in the real world and interacts with $\Functionality_{\CEC}$ for all corrupt parties in the ideal world. 

% $\Simulator$ runs a copy of any adversary $\Adversary$, which is used to provide to $\Environment$ a view that is indistinguishable from the view given by $\Adversary$ in the real world. To achieve that, $\Simulator$ must simulate the real-world protocol towards the copy of $\Adversary$, in such a way that $\Adversary$ cannot distinguish an interaction with $\Simulator$ from an interaction with the real-world protocol. $\Simulator$ uses the information provided by $\Functionality_{\CEC}$ to provide a simulation of the real-world protocol.

% Our simulator $\Simulator$ runs copies of the functionalities $\Functionality_{\SMT}$, $\Functionality_{\NYM}$, $\Functionality_{\KG}$, $\Functionality_{\Freg}$ and $\Functionality_{\BB}$. When any of the copies of these functionalities aborts, $\Simulator$ implicitly forwards the abortion message to the adversary if the functionality sends the abortion message to a corrupt party.

% $\Simulator$ also runs copies of the extractors $\mathcal{E}_{s}$ and $\mathcal{E}_{v}$ and simulators  $\mathcal{S}_{s}$ and $\mathcal{S}_{v}$ for the non-interactive zero-knowledge arguments of knowledge $\pi_s$ and $\pi_v$, which are computed through the Fiat-Shamir transform. We remark that they involve calls to the random oracle and rewinding of the adversary. For simplicity, we omit those details.

% \paragraph{Simulator.} We describe the simulator $\Simulator$ for the case in which a subset of users $\fcecUser_j$, a subset of providers $\fcecProvider_k$ and up to $t-1$ authorities are corrupt. $\Simulator$ simulates the honest parties in the protocol $\mathrm{\Pi_{\CEC}}$ and runs copies of the ideal functionalities involved.

% For the $\fcecsetup$, $\fcecregister$, $\fcecrequest$ and $\fcecissue$ interfaces, $\Simulator$ is very similar to the simulator for the security analysis of the compact e-cash scheme in Appendix~\ref{sec:securityProofCompact}. The only differences are derived from the fact that, in the compact e-cash scheme, signatures sign three messages $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak \cect)$, whereas in the divisible e-cash scheme they sign two messages $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. The simulator in Appendix~\ref{sec:securityProofCompact} should therefore be adapted to handle this change, but we omit the details. Below we describe how $\Simulator$ works for the $\fcecspend$, $\fcecdeposit$ and $\fcecdepvf$ phases.