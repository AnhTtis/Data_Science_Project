\section{Instantiation of $\mathrm{\Pi}_{\CEC}$}\label{sec:instantiation} 

\subsection{Threshold Issuance Compact Ecash}\label{sec:compactecash}

Our compact $\CEC$ scheme is based on the scheme proposed in~\cite{DBLP:conf/eurocrypt/CamenischHL05}.
In order to provide threshold issuance, we use the Coconut protocol~\cite{DBLP:conf/ndss/SonninoABMD19} with the modifications in~\cite{cryptoeprint:2022:011}. We also make some changes in the scheme in~\cite{DBLP:conf/eurocrypt/CamenischHL05} to improve efficiency (see~\ref{sec:exts}).

\subsubsection{High-level Overview}

% \subsection{Compact E-Cash by Camenisch et al.}
% \label{sec:cecoverview}

In~\cite{DBLP:conf/eurocrypt/CamenischHL05}, a central bank plays the role of the authority. In the setup phase, the bank generates a key pair for a signature scheme, and each of the users generates a key pair.


\begin{description}[leftmargin=0pt]

\item[Withdrawal Phase.] A wallet of $L$ coins is a signature under the bank's public key on a user secret key $\ssk_{\fcecUser_j}$ and two random values $\cecsn$ and $\cect$. The user $\fcecUser_j$ obtains the signature from the bank on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak \cect)$ through a blind signature protocol. The bank does not learn any of the signed values, but learns the user public key $\spk_{\fcecUser_j}$ associated with $\ssk_{\fcecUser_j}$.

\item[Spending Phase.] In order to spend coin $l \in [0,L-1]$, $\fcecUser_j$ proves in zero-knowledge (ZK) possession of a signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn, \allowbreak \cect)$.  Additionally, $\fcecUser_j$ generates a serial number $S$ and a double-spending tag $T$, which are used to detect and identify double-spenders. $S$ and $T$ are computed by evaluating the pseudorandom function (PF) in \S\ref{subsec:pseudorandomfunction} on input $l$. Concretely, $S$ is the output of the PF $f_{\ga,\cecsn}$ on input $l$.
% i.e., $S \gets f_{\ga,\cecsn}(l) = \ga^{1/(\cecsn+l+1)}$.
$T$ is computed on input $\ssk_{\fcecUser_j}$, the output of the PF $f_{\ga,\cect}$ on input $l$, and $R \allowbreak \gets \allowbreak H(\cecpaymentinfo)$. $\cecpaymentinfo$ is given by the provider and should be unique for each payment.
% Additionally, the user generates the serial number $S \gets f_{\ga,\cecsn}(l) = \ga^{1/(\cecsn+l+1)}$, i.e. the serial number of the coin $l$ is the output of the pseudorandom function $f_{\ga,\cecsn}$  (described in~\S\ref{subsec:pseudorandomfunction}) on input $l$. Moreover, the user computes a security tag $T \gets \ga^{\ssk_{\fcecUser_j}} (f_{\ga,\cect}(l))^{R} = \ga^{\ssk_{\fcecUser_j} + R/(\cect+l+1)}$ on input $\ssk_{\fcecUser_j}$, $l$, $\cect$ and $R \allowbreak \gets \allowbreak H(\cecpaymentinfo)$.
$\fcecUser_j$ also proves in ZK that $S$ and $T$ are correctly computed. %This ZK proof also signs the payment information $\cecpaymentinfo$.

\item[Deposit phase.] The provider sends to the bank the payment received from the user. To check whether the coin has been double-spent, the bank compares the serial number $S$ with the serial numbers of previously received coins. If there is a match, but the payment information $\cecpaymentinfo$ is the same in both coins, then the bank finds that the provider has deposited the coin twice. Else, the bank identifies the user that double-spent the coin by using the double-spending tags of both coins.

\end{description}

% \subsection{Our Construction of Compact E-Cash}
% \label{sec:cec:construction}

%In our scheme, the bank is replaced by $n$ authorities  $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n)$.
\subsubsection{Our extensions}\label{sec:exts} 
In our compact $\CEC$ scheme, the signature scheme is instantiated with PS signatures, which are described in \S\ref{subsec:signatureSchemes}. In the setup phase, the secret keys $\ssk_{\fcecAuthority_i}$ for each of the authorities $(\fcecAuthority_1, \allowbreak \ldots, \allowbreak \fcecAuthority_n)$ are generated by evaluating random polynomials of degree $t-1$ on input $[1,n]$, while the verification key $\spk$ used to verify wallets corresponds to a secret key that would be given by the evaluation of those polynomials on input $0$. In the withdrawal phase, the user runs a blind signature protocol with at least $t$ authorities. After obtaining at least $t$ valid signatures, the user uses Lagrange interpolation to obtain a signature verifiable with $\spk$.

A wallet is a signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. In comparison to~\cite{DBLP:conf/eurocrypt/CamenischHL05}, we remove the secret $\cect$. Thanks to this change, the size of the wallet is smaller, and the ZK proofs used in both the withdrawal and spending phase are more efficient in comparison to~\cite{DBLP:conf/eurocrypt/CamenischHL05}. To make this change possible, we modify the way the serial number $S$ and double spending tag $T$ are computed. Concretely, $S$ is the output of the PF $f_{\delta,\cecsn}$ on input $l$, and the computation of $T$ uses the evaluation of the PF $f_{\ga,\cecsn}$ on input $l$, i.e., we use a new generator $\delta$ for the computation of the serial numbers. This change allows us to use the same secret $\cecsn$ as the index of both PFs without compromising the security of our scheme. In \S\ref{sec:compactECashRangeProof}, we quantify the cost reduction attained by removing $\cect$.
We further improve the efficiency of the withdrawal phase, by removing the need for the bank to contribute randomness to create $\cecsn$ in the blind signature protocol in~\cite{DBLP:conf/eurocrypt/CamenischHL05}. In our protocol, the user picks $\cecsn$ and as discussed in \S\ref{sec:securityCompact}, this change does not compromise the security of our scheme. We also improve efficiency by using one ZK proof $\pi_v$ to spend $V$ coins, instead of repeating $V$ times the spending protocol for one coin. 

% In the blind signature protocol in~\cite{DBLP:conf/eurocrypt/CamenischHL05}, both the user and the bank contribute randomness to create $\cecsn$. To improve efficiency, in our protocol, the user picks $\cecsn$. As discussed in \S\ref{sec:securityCompact}, this change does not compromise the security of our scheme.


\subsubsection{Construction}\label{sec:cec:construction} 
 The algorithms of our compact $\CEC$ scheme are defined below. In~\S\ref{sec:securitydefinitionsbuildingblocks}, we describe the cryptographic primitives used by the algorithms.
\begin{description}[leftmargin=10pt,topsep=0pt]

\item[$\cecSetup(1^{\securityparameter}, L)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Run $(\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb) \gets \BilinearSetup(1^\securityparameter)$.

    \item Pick $3$ random generators $(\gamma_1, \gamma_2, \delta) \gets \Ga$.

    \item Output $\cecparams \allowbreak \gets \allowbreak (\p, \allowbreak \Ga, \allowbreak \Gb, \allowbreak \Gt, \allowbreak \e, \allowbreak \ga, \allowbreak \gb, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \delta, \allowbreak L)$.

\end{itemize}

\item[$\cecKeyGenA(\cecparams, t, n)$.] Execute the following steps:
\begin{itemize}[leftmargin=*]

    \item Choose $(1 + 2)$ polynomials $(v, w_1, w_2)$ of degree $(t - 1)$ with random coefficients in $\Zp$.

    \item Set $(x, y_1, y_2) \gets (v(0), w_1(0), w_2(0))$.

    \item For $i = 1$ to $n$, set the secret key $\ssk_{\fcecAuthority_i}$ of each authority $\fcecAuthority_i$ as $\ssk_{\fcecAuthority_i} \allowbreak = \allowbreak (x_i, \allowbreak y_{i,1}, \allowbreak y_{i,2}) \allowbreak \gets \allowbreak (v(i),\allowbreak w_1(i), \allowbreak w_2(i))$.

    \item For $i = 1$ to $n$, set the verification key $\spk_{\fcecAuthority_i}$ of each authority $\fcecAuthority_i$ as $\spk_{\fcecAuthority_i} \allowbreak = \allowbreak (\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1},  \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2}) \allowbreak \gets \allowbreak (\gb^{x_i}, \allowbreak \ga^{y_{i,1}}, \allowbreak \gb^{y_{i,1}},  \allowbreak \ga^{y_{i,2}}, \allowbreak \gb^{y_{i,2}})$.

    \item Set the verification key $\spk = (\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \allowbreak \beta_{2}, \tilde{\beta}_{2}) \gets \allowbreak (\cecparams, \allowbreak \gb^{x}, \allowbreak \ga^{y_{1}}, \allowbreak \gb^{y_{1}}, \allowbreak \ga^{y_{2}}, \allowbreak \gb^{y_{2}})$.

    \item Output $(\spk, \langle \spk_{\fcecAuthority_i}, \ssk_{\fcecAuthority_i} \rangle_{i =1}^{n})$.

\end{itemize}

\item[$\cecKeyGenU(\cecparams)$.] Execute the following steps:
\begin{itemize}[leftmargin=*]

    \item Pick random $\ssk_{\fcecUser_j} \gets \Zp$ and compute $\spk_{\fcecUser_j} \gets \ga^{\ssk_{\fcecUser_j}}$.

    \item Output $(\ssk_{\fcecUser_j}, \allowbreak \spk_{\fcecUser_j})$.

\end{itemize}

\item[$\cecRequest(\cecparams, \ssk_{\fcecUser_j})$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Pick random $\cecsn \gets \Zp$ and set $(\cecmes_{1}, \allowbreak \cecmes_{2}) \allowbreak = (\ssk_{\fcecUser_j}, \allowbreak \cecsn)$.

    \item Pick random $o \gets \Zp$ and compute  $\com = \ga^{o} \prod_{j=1}^{2} \gamma_j^{\cecmes_{j}}$.

    \item Compute $\h \gets H(\com)$, where $H$ is a hash function modeled as a random oracle.

    \item Compute commitments to each of the messages. For $j = 1$ to $2$, pick random $o_{j} \gets \Zp$ and set $\com_{j} = \ga^{o_{j}} \h^{\cecmes_{j}}$.

    \item Compute a ZK argument of knowledge $\pi_s$ via the Fiat-Shamir heuristic for the following relation:
    \vspace{-3mm}
    {\small
    \begin{align*}
        \pi_s =  & \NIZK\{(\cecmes_{1}, \cecmes_{2}, o, o_{1}, o_{2}):
        \com = \ga^{o} \prod_{j=1}^{2} \gamma_j^{\cecmes_{j}}\ \land\ \\ & \spk_{\fcecUser_j} \gets \ga^{\cecmes_{1}} \land\
        \{\com_{j}= \ga^{o_{j}} \h^{\cecmes_{j}} \}_{\forall j \in [1,2]}  \}
    \end{align*}
    }
    \item Set $\cecrequestinfo \allowbreak \gets \allowbreak (\h, \allowbreak o_{1}, \allowbreak o_{2}, \allowbreak \cecsn)$ and $\cecrequest \allowbreak \gets \allowbreak (\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$.

    \item Output $\cecrequest$ and $\cecrequestinfo$.

\end{itemize}

\item[$\cecRequestVf(\cecparams, \cecrequest, \spk_{\fcecUser_j})$.] Execute the following steps:
\begin{itemize}[leftmargin=*]

    \item Parse $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$.

    \item Compute $\h' \gets H(\com)$ and output $0$ if $\h \neq \h'$.

    \item Verify the ZK argument $\pi_s$ by using the tuple $(\cecparams, \allowbreak \h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \spk_{\fcecUser_j})$. Output $0$ if the proof $\pi_s$ is not correct, else output $1$.

\end{itemize}

\item[$\cecWithdraw(\cecparams, \ssk_{\fcecAuthority_i}, \cecrequest)$.] Execute the following steps:
\begin{itemize}[leftmargin=*]

    \item Parse $\cecrequest$ as $(\h, \allowbreak \com, \allowbreak \com_{1}, \allowbreak \com_{2}, \allowbreak \pi_s)$ and $\ssk_{\fcecAuthority_i}$ as $(x_i, \allowbreak y_{i,1}, \allowbreak y_{i,2})$.

    \item Compute $c = \h^{x_i} \prod_{j=1}^{2} \com_j^{y_{i,j}}$.

    \item Set the blinded signature share $\hat{\sigma}_{i} \allowbreak \gets \allowbreak (\h, \allowbreak c)$.

    \item Output $\cecresponse \gets \hat{\sigma}_{i}$.

\end{itemize}

\item[$\cecWithdrawVf(\cecparams, \spk_{\fcecAuthority_i}, \ssk_{\fcecUser_j}, \cecresponse, \cecrequestinfo)$.] Do the following:

\begin{itemize}[leftmargin=*]

    \item Parse $\cecrequestinfo$ as $(\h', \allowbreak o_{1},  \allowbreak o_{2}, \allowbreak \cecsn)$, $\cecresponse$ as $\hat{\sigma}_{i} \allowbreak = \allowbreak (\h, \allowbreak c)$, and $\spk_{\fcecAuthority_i}$ as $(\tilde{\alpha}_i, \allowbreak \beta_{i,1}, \allowbreak \tilde{\beta}_{i,1}, \allowbreak \beta_{i,2}, \allowbreak \tilde{\beta}_{i,2})$. Output $0$ if $\h \allowbreak \neq \allowbreak \h'$.

    \item Compute $\sigma_{i} \allowbreak = \allowbreak (\h, \allowbreak s) \allowbreak \gets \allowbreak (\h, \allowbreak c \prod_{j=1}^{2} \beta_{i,j}^{-o_{j}})$.

    \item Set $(\cecmes_{1}, \cecmes_{2}) \gets (\ssk_{\fcecUser_j}, \cecsn)$. Output $0$ if $\e(\h, \tilde{\alpha}_i \prod_{j=1}^{2} \tilde{\beta}_{i,j}^{\cecmes_{j}}) \allowbreak = \allowbreak \e(s, \gb)$ does not hold.

    \item Output $\cecwallet_i \gets (i,\sigma_{i},\cecsn)$.

\end{itemize}


\item[$\cecCreateWallet(\spk, \ssk_{\fcecUser_j}, \cecset, \langle \cecwallet_i \rangle_{i \in \cecset})$.] Execute the following steps:
\begin{itemize}[leftmargin=*]

    \item If $|\cecset| \neq t$, output $0$.

    \item For all $i \in \cecset$, evaluate at 0 the Lagrange basis polynomials $l_i = [\prod_{j \in \cecset,j\neq i} (0-j)] [\prod_{j\in\cecset,j\neq i} (i-j)]^{-1}\ \mathrm{mod}\ \p $
    % \begin{align*}
    %     l_i = [\prod_{j \in \cecset,j\neq i} (0-j)] [\prod_{j\in\cecset,j\neq i} (i-j)]^{-1}\ \mathrm{mod}\ \p
    % \end{align*}

    \item For all $i \in \cecset$, parse $\cecwallet_{i}$ as  $(i,\sigma_{i},\cecsn)$ and $\sigma_{i}$ as $(\h, \allowbreak s_i)$.

    \item Compute the signature $\sigma = (\h, s) \gets (\h, \allowbreak \prod_{i \in \cecset} s_{i}^{l_i})$.

    \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Set $(\cecmes_{1}, \allowbreak \cecmes_{2}) \allowbreak = \allowbreak (\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ and output $0$ if $\e(\h, \tilde{\alpha} \prod_{j=1}^{2} \tilde{\beta}_j^{\cecmes_{j}}) = \e(s, \gb)$ does not hold, else output $\cecwallet \allowbreak \gets \allowbreak (\sigma, \allowbreak \cecsn, l)$, where $l$ is a counter from $0$ to $L-1$ initialized to $0$.

\end{itemize}


\item[$\cecSpend(\spk, \ssk_{\fcecUser_j}, \cecwallet, \cecpaymentinfo, V)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Parse $\cecwallet$ as $(\sigma, \allowbreak \cecsn, \allowbreak l)$. If $l + V -1 \geq L$, output $0$.

    \item Parse $\sigma$ as $(\h, \allowbreak s)$ and $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Pick random $r \gets \Zp$ and $r' \gets \Zp$.

    \item Compute $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$ and $\kappa \gets \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$.

    \item Pick random $o_c \gets \Zp$ and compute the commitment $C \gets \ga^{o_c} \gamma_1^{\cecsn}$.

    \item For $k \in [0,V-1]$, compute $R_k \gets H'(\cecpaymentinfo,k)$, where $\cecpaymentinfo$ must contain the identifier of the merchant, and $H'$ is a collision-resistant hash function.

    \item For $k \in [0,V-1]$, set $l_k \gets l+k$, pick random $o_{a_k}$ and compute $A_k = \ga^{o_{a_k}} \gamma_1^{l_k}$.

    \item For $k \in [0,V-1]$, compute the serial numbers $S_{k} \gets f_{\delta,\cecsn}(l_k) = \delta^{1/(\cecsn+l_k+1)}$ and also compute the double spending tags $T_k \gets \ga^{\ssk_{\fcecUser_j}} (f_{\ga,\cecsn}(l_k))^{R_{k}} = \ga^{\ssk_{\fcecUser_j} + R_{k}/(\cecsn+l_k+1)}$.

    \item For $k \in [0,V-1]$, compute the values $\mu_k \gets 1/(\cecsn+l_k+1)$ and $o_{\mu_k} \gets -(o_{a_k} + o_c) \mu_k$.

    \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
    \vspace{-3mm}
    {\small
    \begin{align*}
        \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, o_c, \langle l_k, o_{a_k}, \mu_k, o_{\mu_k} \rangle_{k=0}^{V-1}): \\
        &\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\ C = \ga^{o_c} \gamma_1^{\cecsn}\ \land\  \\&
        \langle A_k = \ga^{o_{a_k}} \gamma_1^{l_k}\ \land\ l_k \in [0,L-1]\ \land\ \\&
        S_k=\delta^{\mu_k}\ \land\ \gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}\ \land\ \\&
        T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}\  \rangle_{k\in[0,V-1]}
        \}
    \end{align*}
    }
    In \S\ref{sec:compactECashRangeProof}, we explain this ZK proof and show how to prove the statement $l_k \in [0,L-1]$.
    % The equation $\kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}$ proves that $\kappa$ commits to the signed messages. ($\kappa$ is used as part of the proof of signature possession.) The equation $C = \ga^{o_c} \gamma_1^{\cecsn}$ proves that $C$ commits to the same value $\cecsn$ committed in $\kappa$. The equations $A_k = \ga^{o_{a_k}} \gamma_1^{l_k}$ and $l_k \in [0,L-1]$ prove that the value $l_k$ committed in $A_k$ is in the valid range $[0,L-1]$ for a wallet with $L$ coins. The equations $S_k=\delta^{\mu_k}$, $\gamma_1 = (A_k C\gamma_1)^{\mu_k} \ga^{o_{\mu_k}}$ and $T_k=\ga^{\ssk_{\fcecUser_j}} (\ga^{R_{k}})^{\mu_k}$ prove that the serial numbers $S_k$ and the security tags $T_k$ are correctly computed. Non-interactive ZK arguments computed via the Fiat-Shamir heuristic are signatures of knowledge, i.e.\ they can be used to sign messages. This non-interactive argument signs the payment information $\cecpaymentinfo$.
    % Note for implementation: The $\cecpaymentinfo$ has to be included in the hash inside the proof

    \item Output a payment $\cecpayment \gets (\kappa, \sigma', \langle S_k, T_k, A_k \rangle_{k\in[0,V-1]}, V, C, \allowbreak \pi_v)$ and an updated wallet $\cecwallet' \gets (\sigma, \allowbreak \cecsn, \allowbreak l+V)$.

\end{itemize}

\item[$\cecSpendVf(\spk, \cecpayment, \cecpaymentinfo)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Parse $\spk$ as $(\cecparams, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Parse $\cecpayment$ as $(\kappa, \sigma', \langle S_k, T_k, A_k \rangle_{k\in[0,V-1]}, V, C, \pi_v)$.

    \item Parse $\sigma'$ as $(\h', \allowbreak s')$ and output $0$ if $\h' = 1$ or if $\e(\h', \kappa) \allowbreak = \allowbreak \e(s',\gb)$ does not hold.

    \item Output $0$ if not all the serial numbers $\langle S_k \rangle_{k\in[0,V-1]}$ are different from each other.

    \item For $k \in [0,V-1]$, compute $R_k \gets H'(\cecpaymentinfo,k)$.

    \item Verify $\pi_v$ by using $\cecpaymentinfo$, $\spk$, $\langle S_k, T_k, A_k, R_{k} \rangle_{k\in[0,V-1]}$, $C$ and $\kappa$. Output $0$ if the proof is not correct, else output $V$.

\end{itemize}

\item[$\cecIdentify(\cecparams, \cecPK, \cecpayment_1, \cecpayment_2, \cecpaymentinfo_1, \cecpaymentinfo_2)$.] Do:
\begin{itemize}[leftmargin=*]

    \item Parse $\cecpayment_1$ as $(\kappa_1, \sigma'_1, \langle S_{k,1}, T_{k,1}, A_{k,1} \rangle_{k\in[0,V_1-1]}, V_1, C_1, \pi_{v,1})$ and $\cecpayment_2$ as $(\kappa_2, \sigma'_2, \langle S_{k,2}, T_{k,2}, A_{k,2} \rangle_{k\in[0,V_2-1]}, V_2, C_2, \pi_{v,2})$.

    \item For $k\in[0,V_1-1]$, for $j\in[0,V_2-1]$, check whether $S_{k,1} \allowbreak = \allowbreak S_{j,2}$. If the equality never holds, output $1$.

    \item Else, output $\cecpaymentinfo_1$ if $\cecpaymentinfo_1 = \cecpaymentinfo_2$.

    \item Else, for $k\in[0,V_1-1]$ and $j\in[0,V_2-1]$ such that $S_{k,1} = S_{j,2}$, compute
    $
    \spk_{\fcecUser_j} \gets (T_{j,2}^{R_{k,1}}/T_{k,1}^{R_{j,2}})^{(R_{k,1}-R_{j,2})^{-1}}
    $
    If $\spk_{\fcecUser_j} \in \cecPK$ output $\spk_{\fcecUser_j}$, else output $\bot$.

\end{itemize}

\end{description}


\subsubsection{Security Analysis of Compact E-Cash}
\label{sec:securityCompact}
In \S\ref{sec:securityProofCompact}, we prove formally that $\mathrm{\Pi}_{\CEC}$, when instantiated with the algorithms of our compact $\CEC$ scheme, realizes $\Functionality_{\CEC}$. In this section, we give intuition on why our scheme is secure. 
\begin{description}[leftmargin=0pt, topsep=2pt]
\item[Unlinkability.] In the withdrawal phase, a corrupt authority does not learn the user secrets $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ thanks to the hiding property of the Pedersen commitment scheme and to the ZK property of the argument $\pi_s$. In the spend phase, a corrupt provider does not learn anything from a payment beyond the number of coins spent. To prove that, several properties are used. First, we use the ZK property of the argument $\pi_v$. Second, to prove that $C$ and $A_k$ do not reveal any information about $\cecsn$ or $l_k$, we use the hiding property of the Pedersen commitment scheme. Third, to prove that $S_k$ and $T_k$ do not reveal any information about $\spk_{\fcecUser_j}$, $\cecsn$ or $l_k$, we use the pseudorandomness property of the PF, along with the XDH assumption.\footnote{In contrast to~\cite{DBLP:conf/eurocrypt/CamenischHL05}, the XDH assumption is needed in our scheme because we use the same coin secret $\cecsn$ to compute $S_k$ and $T_k$.} Finally, as in the modified version of Coconut in~\cite{cryptoeprint:2022:011}, the PS signature is ``randomized'' in a way that enables us to prove signature possession without revealing any information about the original signature or the signed messages.

\item[Traceability, Exculpability and Clearance.] To prove that a user cannot spend coins that she has not withdrawn before, we use several properties of our building blocks. The weak simulation extractability property allows us to extract the witnesses from the ZK arguments $\pi_s$. Thanks to that extraction, we can use the binding property of the commitment scheme $\com$ included in a request message to ensure that different commitments $\com$ and $\com'$ commit to different tuples $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. This is required for the unforgeability of PS signatures in the RO model. We remark that $\com$ is the input to the random oracle and that it is necessary to ensure that a different generator $\h$ is created to sign different message tuples. The binding property of $\com$ guarantees that. Second, we use the weak simulation extractability property of arguments $\pi_v$ to extract the witnesses. Thanks to that, in the spending phase, we can extract a signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ from a payment message and show that, if a user did not withdraw at least $t$ signatures from $t$ different authorities, then the user can be used to break the existential unforgeability property of PS signatures in the RO model.

Therefore, we know that, if more coins are deposited than those being withdrawn, it is the case that a user has double-spent coins or that a provider has double-deposited coins. In the deposit phase, an authority checks that payments that are deposited have different serial numbers. We show that the extractability of $\pi_v$, along with the discrete logarithm assumption, guarantees that the serial numbers and double spending tags are correctly computed. Therefore, if two payments have at least one common serial number, there are three possibilities:
\begin{enumerate*}
    \item Double depositing, 
    \item double spending, 
    \item none of the former.
\end{enumerate*}
Double depositing can be punished by checking whether two payments are associated with the same payment information $\cecpaymentinfo$, which contains the identifier of the provider. We recall that $\cecpaymentinfo$ is signed in $\pi_v$. Moreover, our construction $\mathrm{\Pi}_{\CEC}$ uses an authenticated bulletin board. Thus, an authority can check that the provider that deposits a payment is the same whose identity is in $\cecpaymentinfo$. The latter guarantees the clearance property. If double depositing did not happen because the payment information $\cecpaymentinfo$ and $\cecpaymentinfo'$ is different in those payments, the authority can retrieve the public key of the user who double spent a coin through the computation described in the algorithm $\cecIdentify$. This computation requires that  $R_k \gets H'(\cecpaymentinfo,k)$ is different from  $R'_{k'} \gets H'(\cecpaymentinfo',k')$. We show that, if the hash function $H'$ is collision-resistant, the double spender can always be identified. In our scheme, a corrupt user is able to compute two payments where there is no double spending, yet two serial numbers are equal. The reason is that, unlike in the scheme in~\cite{DBLP:conf/eurocrypt/CamenischHL05}, the user picks the coin secret $\cecsn$ on its own. When a corrupt user does that, our security analysis guarantees that, under the hardness of the discrete logarithm assumption, algorithm $\cecIdentify$ will never identify an honest user as the double spender. This guarantees the exculpability property. Moreover, we also show that, under the discrete logarithm assumption, a corrupt user cannot compute a payment with a serial number that is equal to a serial number in a payment computed by an honest user. Consequently, when $\cecIdentify$ detects that two serial numbers are equal, but is unable to find the public key of the user who double spent (i.e. $\cecIdentify$ outputs $\bot$), we are in a case in which in fact there is no double-spending.
% \item[Double depositing.] Double depositing can be punished by checking whether two payments are associated with the same payment information $\cecpaymentinfo$, which contains the identifier of the provider. We recall that $\cecpaymentinfo$ is signed in $\pi_v$. Moreover, our construction $\mathrm{\Pi}_{\CEC}$ uses an authenticated bulletin board. Thus an authority can check that the provider that deposits a payment is the same whose identity is in $\cecpaymentinfo$. The latter guarantees the clearance of the property.

% \item[Double spending.] If double depositing did not happen because the payment information $\cecpaymentinfo$ and $\cecpaymentinfo'$ is different in those two payments, the authority can retrieve the public key of the user who double spent a coin through the computation described in the algorithm $\cecIdentify$. This computation requires that  $R_k \gets H'(\cecpaymentinfo,k)$ is different from  $R'_{k'} \gets H'(\cecpaymentinfo',k')$. We show that, if the hash function $H'$ is collision-resistant, the double spender can always be identified.

% \item[None of the above]. In our scheme, a corrupt user is able to compute two payments where there is no double spending, yet two serial numbers are equal. The reason is that, unlike in the scheme in~\cite{DBLP:conf/eurocrypt/CamenischHL05}, the user picks the coin secret $\cecsn$ on its own. When a corrupt user does that, our security analysis guarantees that, under the hardness of the discrete logarithm assumption, algorithm $\cecIdentify$ will never identify an honest user as the double spender. This guarantees the exculpability property. Moreover, we also show that, under the discrete logarithm assumption, a corrupt user cannot compute a payment with a serial number that is equal to a serial number in a payment computed by an honest user. Consequently, when $\cecIdentify$ detects that two serial numbers are equal, but later is unable to find the public key of the user who double spent (i.e. $\cecIdentify$ outputs $\bot$), we are in a case in which in fact there is not double-spending.

\end{description}

\subsection{Threshold Issuance Divisible E-Cash}\label{sec:divisibleecash}

In our compact $\CEC$ scheme in~\S\ref{sec:compactecash}, the cost of the spending phase grows linearly with the number of coins spent. In divisible e-cash, the cost of the spending phase is independent of the number of coins spent. To make that possible, the main change in comparison to compact e-cash is that the serial numbers of coins are generated during the deposit phase, rather than the spending phase.

Our divisible $\CEC$ scheme is based on the work by Pointcheval et al.~\cite{DBLP:conf/pkc/PointchevalST17}, which 
proposes a scheme in the standard model with  Groth-Sahai proofs~\cite{DBLP:conf/eurocrypt/GrothS08}. We modify that scheme as follows. In~\cite{DBLP:conf/pkc/PointchevalST17}, a wallet is a signature on two group elements $(U_1,U_2) = (u_1^{\ssk_{\fcecUser_j}}, \allowbreak u_2^\cecsn)$ We replace the signature scheme used in~\cite{DBLP:conf/pkc/PointchevalST17} by the PS signature scheme, and we sign $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Thus, the wallet in our divisible $\CEC$ scheme has the same form as in our compact $\CEC$ scheme. Thanks to that, in the withdrawal phase we use the same algorithms $\cecRequest$, $\cecRequestVf$, $\cecWithdraw$, $\cecWithdrawVf$ and $\cecCreateWallet$ (see ~\S\ref{sec:cec:construction}) to provide a threshold issuance protocol. At setup, algorithms $\cecKeyGenA$ and $\cecKeyGenU$  also work as in~\S\ref{sec:cec:construction}.

In the spending phase in~\cite{DBLP:conf/pkc/PointchevalST17}, a Groth-Sahai non-interactive ZK proof and a Groth-Sahai non-interactive witness-indistinguishable proof are computed. The latter involves proof of possession of the signature on $(U_1, \allowbreak U_2)$. In our scheme, we use a NIZK argument computed via the Fiat-Shamir heuristic, which involves all the statements proven in both the Groth-Sahai ZK proof and witness-indistinguishable proof. To prove possession of a PS signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$, we use the method depicted in algorithm $\cecSpend$ in~\S\ref{sec:cec:construction}.

Because Groth-Sahai proofs are randomizable, in~\cite{DBLP:conf/pkc/PointchevalST17}, the user needs to compute a one-time signature on the payment. A statement is added to the Groth-Sahai proof to certify the public key used for the one-time signature. In our scheme, this is not needed, because non-interactive ZK arguments computed via the Fiat-Shamir heuristic are signatures of knowledge.

The remaining values computed in the spending phase, and the statements proven about them, are the same in~\cite{DBLP:conf/pkc/PointchevalST17} and in our scheme. We note that our non-interactive ZK argument involves proving knowledge of group elements in addition to discrete logarithm representations. We show how this is done in~\S\ref{subsec:zkpk}.

\subsubsection{High-level Overview}

A wallet of $L$ coins is a signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$, where $\ssk_{\fcecUser_j}$ is the secret key of user $\fcecUser_j$ and $\cecsn$ is a coin secret. The $L$ serial numbers of the coins in a wallet are given by
$
 \mathrm{SN}_l \allowbreak = \allowbreak \e(\varsigma,\gb)^{\cecsn y^l},\ l \in [1,L]
$
where values $y$ and $\varsigma$ are part of the parameters of the scheme.

\begin{description}[leftmargin=0pt]
    \item[Withdrawal Phase.] The withdrawal phase is the same as in our compact $\CEC$ scheme in~\S\ref{sec:cec:construction}.

    \item[Spending Phase.] In the spending phase, to spend $V$ coins, the user needs to give information that allows the authorities to compute the $V$ serial numbers of the spent coins, but no more than that. To this end, to spend $V$ coins with indices $[l,l+V-1]$, the user computes an ElGamal encryption $\phi_{V,l}$ of $\varsigma_l^\cecsn$ under the public key $\eta_V$.
    % as
    % \begin{align*}
    %     \phi_{V,l} = (\phi_{V,l}[1],\phi_{V,l}[2]) \gets (\ga^{r_1}, \varsigma_l^\cecsn \eta_{V}^{r_1})
    % \end{align*}
    The values $\varsigma_l$ (for $l \allowbreak \in \allowbreak [1,L]$) and $\eta_V$ (for $V \allowbreak \in \allowbreak [1,L]$) are part of the public parameters of the scheme.
    % The values $\varsigma_l = \varsigma^{y^l}$ (for $l \allowbreak \in \allowbreak [1,L]$) and $\eta_V = \ga^{a_V}$ (for $V \allowbreak \in \allowbreak [1,L]$) are part of the public parameters of the scheme.
    $\phi_{V,l}$ is used in the deposit phase by the authorities to generate the serial numbers $(\mathrm{SN}_l,\ldots,\mathrm{SN}_{l+V-1})$. This ELGamal encryption with public key $\eta_V$ restricts the authorities to generate only those $V$ serial numbers.

    To enable identification of double spenders, the user computes the double spending tag $\varphi_{V,l}$ as an ElGamal encryption of  $(\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn}$ under public key $\eta_{V}$, where $R$ is a hash of the payment information $\cecpaymentinfo$ given by the provider. % $R \gets H(\cecpaymentinfo)$
    % \begin{align*}
    %     \varphi_{V,l} = (\varphi_{V,l}[1],\varphi_{V,l}[2]) \gets (\ga^{r_2}, (\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn} \eta_{V}^{r_2}),
    % \end{align*} where $R \gets H(\cecpaymentinfo)$.
    % This security tag is an ElGamal encryption of  $(\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn}$ under public key $\eta_{V}$.
    The values $\theta_l$, for $l \allowbreak \in \allowbreak [1,L]$,
    % $\theta_l \allowbreak \gets \allowbreak \theta^{y^l}$ (for $l \allowbreak \in \allowbreak [1,L]$)
    are part of the parameters of the scheme.

    The user also needs to prove in zero-knowledge that $\phi_{V,l}$ and $\varphi_{V,l}$ are correctly computed. To this end, the user proves possession of a signature on $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$ and proves that those values were used to compute $\phi_{V,l}$ and $\varphi_{V,l}$. Additionally, the user needs to prove that the correct values $\varsigma_l$ and $\theta_l$ in the public parameters have been used, and that $l \allowbreak \leq \allowbreak L-V+1$. To allow the user to prove those statements, the public parameters of the scheme contain signatures on the pairs $(\varsigma_l, \allowbreak \theta_l)$ (for $l \allowbreak \in \allowbreak [1,L]$). The user proves possession of the signature on the pair $(\varsigma_{l+V-1}, \allowbreak \theta_{l+V-1})$ and proves that $(\varsigma_l, \allowbreak \theta_l)$ are correctly chosen through the equations $\e(\varsigma_l, \tilde{\delta}_{V-1}) = \e(\varsigma_{l+V-1},\tilde{g})$ and $\e(\theta_l, \tilde{\delta}_{V-1}) = \e(\theta_{l+V-1},\tilde{g})$. The values  $\tilde{\delta}_k \gets \gb^{y^k}$ (for $k \in [0,L-1]$) are part of the parameters of the scheme. Although this proof does not prove that $l \geq 1$, in the security analysis it is shown that the user is unable to generate $(\varsigma_l, \allowbreak \theta_l)$ such that $l \allowbreak \notin \allowbreak [1,L]$.

    \item[Deposit Phase.] In the deposit phase, an authority checks whether a coin has been double spent. For this purpose, the authority computes the serial numbers of the spent coins by doing $\mathrm{SN}_{k} \allowbreak \gets \allowbreak \e(\phi_{V,l}[2], \tilde{\delta}_k) \allowbreak \e(\phi_{V,l}[1], \tilde{\eta}_{V,k})$ for $k \in [0,V-1]$.
    Here, the values $\tilde{\eta}_{l,k}$
    % \allowbreak \gets \allowbreak \gb^{-a_l \cdot y^k}$
    for $l \allowbreak \in \allowbreak [1,L]$ and $k \allowbreak \in \allowbreak [0, \allowbreak l-1]$
    are part of the parameters of the scheme. Because of those values, the size of the parameters is quadratic in the number $L$ of coins in a wallet, but this is only the case for the parameters that the authorities need, i.e., the size of parameters for users is linear in $L$.

    When a collision between serial numbers of two payments is detected, the authority uses the security tags of both payments for identification of the user who double spent. The mechanism used is similar to the one of our compact $\CEC$ scheme in~\S\ref{sec:compactecash}. However, in the divisible $\CEC$ scheme, the authority, rather than computing the user key, checks whether an equality holds for each of the public keys of the users one by one, which is a disadvantage.
\end{description}

\subsubsection{Construction}
Our divisible e-cash scheme works as follows:
% We depict algorithms $\cecKeyGenA$, $\cecKeyGenU$, $\cecRequest$, $\cecRequestVf$, $\cecWithdraw$, $\cecWithdrawVf$ and $\cecCreateWallet$ in Appendix~\ref{sec:divisibleEcashSpend} because they are similar to the ones of the compact e-cash scheme in~\S\ref{sec:compactecash}.
\begin{description}[leftmargin=10pt]
\item[$\cecSetup(1^{\securityparameter}, L)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Run $\grp = (\p,\Ga,\Gb,\allowbreak \Gt,\e,\ga,\gb) \gets \BilinearSetup(1^\securityparameter)$.

    \item Pick random generators $\eta, \gamma_1, \gamma_2 \allowbreak \gets \allowbreak \Ga$.

    % \item Pick the random generators $(\eta, \omega) \gets \Ga$.\ania{This seems to be the same as the previous step. Was it suppose to be $\Gb$? If yes, should we maybe name those elements as $(\tilde{\gamma}_1, \allowbreak \tilde{\gamma}_2)$?}

    \item Generate random scalars $(z,y) \allowbreak \gets \allowbreak \Zp$ and compute $(\varsigma, \theta) \gets (\ga^z, \eta^z)$. Generate for $l \allowbreak \in \allowbreak [1,L]$, $a_l \gets \Zp$.


    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $(\varsigma_l, \theta_l) \allowbreak \gets \allowbreak (\varsigma^{y^l}, \allowbreak \theta^{y^l})$.

    \item For $k \in [0,L-1]$, compute $\tilde{\delta}_k \gets \gb^{y^k}$.

    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $\eta_l \gets \ga^{a_l}$.

    \item For $l \allowbreak \in \allowbreak [1,L]$, for $k \allowbreak \in \allowbreak [0, \allowbreak l-1]$, compute $\tilde{\eta}_{l,k} \allowbreak \gets \allowbreak \gb^{-a_l \cdot y^k}$.

    \item Run algorithm $(\spk_{sps}, \allowbreak \ssk_{sps}) \gets \SKeygen(\grp,2,0)$ of the SPS scheme in~\S\ref{subsec:signatureSchemes}.

    \item For $l \allowbreak \in \allowbreak [1,L]$, compute $\tau_l \gets \SSign(\ssk_{sps},\langle \varsigma_l, \theta_l \rangle)$.

    \item Set the parameters for users $\cecparams_u \gets (\p, \allowbreak \Ga, \allowbreak \Gb,\allowbreak \Gt, \allowbreak \e,\allowbreak \ga,\allowbreak \gb, \allowbreak \eta, \allowbreak \gamma_1, \allowbreak \gamma_2, \allowbreak \{\eta_l, \allowbreak \varsigma_l, \allowbreak \theta_l, \allowbreak \tau_l\}_{l=1}^L, \allowbreak \{\tilde{\delta}_k\}_{k=0}^{L-1}, \allowbreak \spk_{sps})$. Set the additional parameters for authorities $\cecparams_a \allowbreak \gets \allowbreak (\{\langle \tilde{\eta}_{l,k} \rangle_{k=0}^{l-1}\}_{l=1}^{L-1})$.

    \item Output $\cecparams \gets (\cecparams_u, \cecparams_a)$.

\end{itemize}

\item[$\cecSpend(\spk, \ssk_{\fcecUser_j}, \cecwallet, \cecpaymentinfo, V)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Parse $\cecwallet$ as $(\sigma, \allowbreak \cecsn, \allowbreak l)$ and $\sigma$ as $(\h, \allowbreak s)$. If $l+V-1 > L$, output $0$.


    \item Parse $\spk$ as $(\cecparams_u, \allowbreak \tilde{\alpha}, \allowbreak \beta_{1}, \allowbreak \tilde{\beta}_{1}, \beta_{2}, \tilde{\beta}_{2})$.

    \item Pick random scalars $r \gets \Zp$ and $r' \gets \Zp$ and compute $\sigma' = (\h',s') \gets (\h^{r'}, s^{r'}(\h')^{r})$.

    \item Compute $\kappa \gets \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn}  \gb^{r}$.

    \item Pick random $r_1,r_2 \gets \Zp$ and set $\phi_{V,l} = (\phi_{V,l}[1],\phi_{V,l}[2]) \gets (\ga^{r_1}, \varsigma_l^\cecsn \eta_{V}^{r_1})$.

    \item Set $R \gets H'(\cecpaymentinfo)$, where $H'$ is a collision-resistant hash function, and compute $$\varphi_{V,l} = (\varphi_{V,l}[1],\varphi_{V,l}[2]) \gets (\ga^{r_2}, (\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn} \eta_{V}^{r_2})$$

    \item Take $\cecparams_u$ from $\spk$. Take the public key $\spk_{sps} \allowbreak = \allowbreak (Y, \allowbreak W_1, \allowbreak W_2, \allowbreak Z)$ and the signature $\tau_{l+V-1} \allowbreak = \allowbreak (R_{l+V-1}, \allowbreak S_{l+V-1}, \allowbreak T_{l+V-1})$.

    \item Compute a ZK argument of knowledge $\pi_v$ via the Fiat-Shamir heuristic for the following relation:
    {\small
    \begin{align*}
        \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, r_1, r_2, \varsigma_l, \theta_l, \varsigma_{l+V-1}, \theta_{l+V-1}, R_{l+V-1}, S_{l+V-1}, T_{l+V-1}): \nonumber \\ &
        \kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\  %\\&
        \phi_{V,l}[1] = \ga^{r_1}\ \land\ \phi_{V,l}[2] = \varsigma_l^{\cecsn} \eta_{V}^{r_1}\ \land\  \\&
        \varphi_{V,l}[1] = \ga^{r_2}\ \land\ \varphi_{V,l}[2] = (\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn} \eta_{V}^{r_2}\ \land\  \\&
        \e(\varsigma_l, \tilde{\delta}_{V-1}) = \e(\varsigma_{l+V-1},\tilde{g})\ \land\  \\ & \e(\theta_l, \tilde{\delta}_{V-1}) = \e(\theta_{l+V-1},\tilde{g})\ \land\ \e(R_{l+V-1},T_{l+V-1})  \e(\ga, \gb)^{-1} =1  \\&
        \e(R_{l+V-1},Y) \e(S_{l+V-1},\gb)  e(\varsigma_{l+V-1}, W_1) e(\theta_{l+V-1}, W_2) \cdot\  \e(g, Z)^{-1} =1\
     \end{align*}
     }
    %     \begin{align}
    %     \pi_v =  & \NIZK\{(\ssk_{\fcecUser_j}, \cecsn, r, r_1, r_2, \varsigma_l, \theta_l, \varsigma_{l+V-1}, \theta_{l+V-1}, R_{l+V-1}, S_{l+V-1}, \nonumber \\ & T_{l+V-1}): \nonumber \\ &
    %     \kappa = \tilde{\alpha} \tilde{\beta}_1^{\ssk_{\fcecUser_j}} \tilde{\beta}_2^{\cecsn} \gb^{r}\ \land\ \label{eq1} \\&
    %     \phi_{V,l}[1] = \ga^{r_1}\ \land\ \phi_{V,l}[2] = \varsigma_l^{\cecsn} \eta_{V}^{r_1}\ \land\ \label{eq2} \\&
    %     \varphi_{V,l}[1] = \ga^{r_2}\ \land\ \varphi_{V,l}[2] = (\ga^R)^{\ssk_{\fcecUser_j}} \theta_l^{\cecsn} \eta_{V}^{r_2}\ \land\ \label{eq3} \\&
    %     \e(\varsigma_l, \tilde{\delta}_{V-1}) = \e(\varsigma_{l+V-1},\tilde{g})\ \land\ \label{eq7} \\ & \e(\theta_l, \tilde{\delta}_{V-1}) = \e(\theta_{l+V-1},\tilde{g})\ \land\ \label{eq4} \\&
    %     \e(R_{l+V-1},Y) \e(S_{l+V-1},\gb)  e(\varsigma_{l+V-1}, W_1) e(\theta_{l+V-1}, W_2) \cdot\ \label{eq5} \\& \e(g, Z)^{-1} =1\ \land
    %     \e(R_{l+V-1},T_{l+V-1})  \e(\ga, \gb)^{-1} =1 \label{eq6}
    % \end{align}
    % Equation~\ref{eq1} is part of the proof of possession of the wallet signature that signs $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Equations~\ref{eq2} and \ref{eq3} prove that $\phi_{V,l}$ and the security tag $\varphi_{V,l}$ are well-formed and are computed on input $(\ssk_{\fcecUser_j}, \allowbreak \cecsn)$. Equation~\ref{eq7}, \ref{eq4}, \ref{eq5} and \ref{eq6}  prove that the values $\varsigma_l$ and $\theta_l$, which were used to compute  $\phi_{V,l}$ and $\varphi_{V,l}$ respectively, are part of the public parameters and fulfill $l \leq L-V+1$. This is accomplished by proving possession of a signature on $\varsigma_{l+V-1}$ and $\theta_{l+V-1}$ in equations~\ref{eq5} and \ref{eq6}, and proving that the indices of $\varsigma_{l+V-1}$ and $\theta_{l+V-1}$ and $\varsigma_l$ and $\theta_l$ are related by a difference of $V-1$ is equation~\ref{eq4}.

     Non-interactive ZK arguments computed via the Fiat-Shamir heuristic are signatures of knowledge, i.e.\ they can be used to sign messages. This non-interactive argument signs the payment information $\cecpaymentinfo$. Since there are group elements in the witness, the transformation described in~\S\ref{subsec:zkpk} is needed. We depict the argument after applying the transformation in Appendix~\ref{sec:divisibleEcashSpend}.

    \item Output a payment $\cecpayment \gets (\kappa, \sigma', \phi_{V,l}, \varphi_{V,l}, R, \pi_v, V)$ and an updated wallet $\cecwallet' \gets (\sigma, \allowbreak \cecsn, \allowbreak l+V)$.

\end{itemize}

\item[$\cecSpendVf(\spk, \cecpayment, \cecpaymentinfo)$.] Execute the following steps:

\begin{itemize}[leftmargin=*]

    \item Parse $\cecpayment$ as $(\kappa, \sigma', \phi_{V,l}, \varphi_{V,l}, R, \pi_v, V)$ and $\sigma'$ as $(\h', \allowbreak s')$. Output $0$ if $\h' = 1$ or if $\e(\h', \kappa) \allowbreak = \allowbreak \e(s',\gb)$ does not hold.

    \item Output $0$ if $R \neq H'(\cecpaymentinfo)$.% or if $\cecpaymentinfo$ does not contain the identifier of the merchant.

    \item Verify $\pi_v$ by using $\cecpaymentinfo$, $\spk$,  $\phi_{V,l}$, $\varphi_{V,l}$, $V$, $R$ and $\kappa$. Output $0$ if the proof is not correct, else output $V$.

\end{itemize}

\item[$\cecIdentify(\cecparams, \cecPK, \cecpayment_1, \cecpayment_2, \cecpaymentinfo_1, \cecpaymentinfo_2)$.] Compute:
\begin{itemize}[leftmargin=*]

    \item Parse $\cecpayment_1$ as $(\kappa_1, \allowbreak \sigma'_1, \allowbreak \phi_{V_1,l_1,1}, \allowbreak \varphi_{V_1,l_1,1}, \allowbreak R_1, \allowbreak \pi_{v,1}, \allowbreak V_1)$ and $\cecpayment_2$ as $(\kappa_2, \allowbreak \sigma'_2, \allowbreak \phi_{V_2,l_2,2}, \allowbreak \varphi_{V_2,l_2,2}, \allowbreak R_2, \allowbreak \pi_{v,2}, \allowbreak V_2)$.

    \item For $k \in [0,V_1-1]$, compute the serial numbers
    \begin{align*}
        \mathrm{SN}_{k,1} \allowbreak \gets \allowbreak \e(\phi_{V_1,l_1,1}[2], \tilde{\delta}_k) \allowbreak \e(\phi_{V_1,l_1,1}[1], \tilde{\eta}_{V_1,k}).
    \end{align*}
    For $k \in [0,V_2-1]$, compute the serial numbers
    \begin{align*}
        \mathrm{SN}_{k,2} \allowbreak \gets \allowbreak \e(\phi_{V_2,l_2,2}[2], \tilde{\delta}_k) \allowbreak \e(\phi_{V_2,l_2,2}[1], \tilde{\eta}_{V_2,k}).
    \end{align*}

    \item Output $1$ if none of the serial numbers $\mathrm{SN}_{k_1,1}$, for $k_1 \in [0,V_1-1]$, is equal to $\mathrm{SN}_{k_2,2}$, for $k_2 \in [0,V_2-1]$.

    \item Else, output $\cecpaymentinfo_1$ if $\cecpaymentinfo_1 = \cecpaymentinfo_2$.

    \item Else, let $k_1 \in [0,V_1-1]$ and $k_2 \in [0,V_2-1]$ be two indices such that $\mathrm{SN}_{k_1,1}=\mathrm{SN}_{k_2,2}$. Compute
    \begin{align*}
        T_1 \gets \e(\varphi_{V_1,l_1,1}[2],\tilde{\delta}_{k_1}) \e(\varphi_{V_1,l_1,1}[1],\tilde{\eta}_{V_1,k_1})
    \end{align*}
    and
    \begin{align*}
        T_2 \gets \e(\varphi_{V_2,l_2,2}[2],\tilde{\delta}_{k_2}) \e(\varphi_{V_2,l_2,2}[1],\tilde{\eta}_{V_2,k_2}).
    \end{align*}
    For each $\spk_{\fcecUser_j} \in \mathrm{PK}$, check whether $T_1T_2^{-1} = \e(\spk_{\fcecUser_j},\tilde{\delta}_{k_1}^{R_1}\tilde{\delta}_{k_2}^{-R_2})$ and output $\spk_{\fcecUser_j}$ if the equality holds. Output $\bot$ if the equality does not hold for any $\spk_{\fcecUser_j} \in \mathrm{PK}$.
\end{itemize}


\end{description}


\subsubsection{Security Analysis of Divisible E-Cash}
\label{sec:securityDivisible}
In \S\ref{sec:securityProofDivisible}, we prove formally that $\mathrm{\Pi}_{\CEC}$, when instantiated with the algorithms of our divisible $\CEC$ scheme, realizes $\Functionality_{\CEC}$. In this section, we give intuition on why our scheme is secure. The security analysis of our divisible $\CEC$ scheme is based on the security analysis given for our compact $\CEC$ scheme regarding the withdrawal phase and the non-interactive ZK argument of possession of PS signatures used in the spending phase. As in our compact $\CEC$ scheme, the anonymity property also relies on the hiding property of Pedersen commitments and the ZK property of the proof system, as well as on the method to ``randomize'' signatures in the spend phase. The traceability property relies on the weak simulation extractability property of the non-interactive ZK arguments of knowledge, the binding property of the commitment scheme and the existential unforgeability property of PS signatures in the RO model.

The remaining part of our analysis follows the security proof given in~\cite{DBLP:conf/pkc/PointchevalST17} for the divisible e-cash scheme. The anonymity property holds under the $N$-MXDH' assumption (see~\S\ref{subsec:bilinearMaps}). In~\cite{DBLP:conf/pkc/PointchevalST17}, it is shown that this assumption holds in the generic bilinear group model. 

% In~\cite{DBLP:conf/pkc/PointchevalST17}, another divisible e-cash scheme that is anonymous under a more standard assumption is proposed, but it is less efficient.\ania{@alfredo This sentence about the other scheme seems unnecessary, should we remove it?}

The traceability property relies on the existential unforgeability of the SPS scheme in~\cite{DBLP:conf/crypto/AbeGHO11}, which guarantees that the values $(\varsigma_{l+V-1}, \allowbreak \theta_{l+V-1})$ used as a witness in the ZK argument $\pi_v$ are correct. It also relies on the $BDHI$ assumption, which guarantees that the adversary cannot generate values $(\varsigma_{l}, \allowbreak \theta_{l})$ such that $l < 1$. Those two properties, along with the above-mentioned binding property of the commitment scheme and the existential unforgeability property of PS signatures in the RO model, guarantee that the ElGamal encryptions $\phi_{V,l}$ and $\varphi_{V,l}$ in payment are computed correctly. This ensures that, if there is double-spending, an authority can identify the user that double-spent a coin.

As noted in~\cite{DBLP:conf/asiacrypt/BoursePS19}, in an RO model version of the scheme in~\cite{DBLP:conf/pkc/PointchevalST17}, like our scheme, we can extract the user's secret key from the ZK argument $\pi_v$. Thus, we can show that an honest user cannot be found guilty of double spending under the discrete logarithm assumption. In our scheme, unlike in~\cite{DBLP:conf/pkc/PointchevalST17}, the authority does not contribute randomness to the generation of the coin secret $\cecsn$. This means that, as in our compact $\CEC$ scheme, the adversary is able to generate two payments where there is no double spending, and yet there is a match between serial numbers. In that case, it is guaranteed that an honest user will not be found guilty.

As for clearance, like in our compact $\CEC$ scheme, our construction in~\S\ref{sec:constructionCEC} guarantees that only the provider that receives a payment can deposit it. This is done by using an authenticated bulletin board and checking that the provider's identity is contained in the payment information $\cecpaymentinfo$.
