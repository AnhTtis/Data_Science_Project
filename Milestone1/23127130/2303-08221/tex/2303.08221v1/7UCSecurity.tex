
\section{Ideal-World/Real-World Paradigm}
\label{sec:securitymodel}

% \ania{To integrate}
The security of a protocol $\varphi$ is analyzed by comparing the view of an environment $\Environment$ in a real execution of $\varphi$ against that of $\Environment$ in the ideal protocol defined in $\Functionality_{\varphi}$. $\Environment$ chooses the inputs of the parties and collects their outputs. In the real world, $\Environment$ can communicate freely with an adversary $\Adversary$ who controls both the network and any corrupt parties.
In the ideal world, $\Environment$ interacts with dummy parties, who simply relay inputs and outputs between $\Environment$ and $\Functionality_{\varphi}$, and a simulator $\Simulator$.
We say that a protocol $\varphi$ securely realizes $\Functionality_{\varphi}$ if $\Environment$ cannot distinguish the real world from the ideal world, i.e., $\Environment$ cannot distinguish whether it is interacting with $\Adversary$ and parties running protocol $\varphi$ or with $\Simulator$ and dummy parties relaying to $\Functionality_{\varphi}$

A protocol $\varphi^{\FunctionalityG}$ securely realizes $\Functionality$ in the $\FunctionalityG$-hybrid model when $\varphi$ is allowed to invoke the ideal functionality $\FunctionalityG$. Therefore, for any protocol $\psi$ that securely realizes $\FunctionalityG$, the composed protocol $\varphi^{\psi}$, which is obtained by replacing each invocation of an instance of $\FunctionalityG$ with an invocation of an instance of $\psi$, securely realizes $\Functionality$.

In the ideal functionalities described in this paper, we consider static corruptions. When describing ideal functionalities, we use the conventions introduced in~\cite{DBLP:conf/crypto/CamenischDR16}, which are summarised
in~\ref{sec:securitymodel}.


% We prove that our e-cash schemes with threshold issuance are secure in the ideal-world/real-world paradigm~\cite{DBLP:conf/focs/Canetti01}. This paradigm allows one to define and analyze the security of cryptographic protocols so that security is retained under arbitrary composition with other protocols. The security of a protocol is defined by means of an ideal protocol that carries out the desired task. In the ideal protocol, all parties send their inputs to an ideal functionality  $\Functionality$  for the task. $\Functionality$ locally computes  the outputs of the parties and provides each party with its prescribed output.
%
% The security of a protocol $\varphi$ is analyzed by comparing the view of an environment $\Environment$ in a real execution of $\varphi$ against that of $\Environment$ in the ideal protocol defined in $\Functionality_{\varphi}$. $\Environment$ chooses the inputs of the parties and collects their outputs. In the real world, $\Environment$ can communicate freely with an adversary $\Adversary$ who controls both the network and any corrupt parties.
% In the ideal world, $\Environment$ interacts with dummy parties, who simply relay inputs and outputs between $\Environment$ and $\Functionality_{\varphi}$, and a simulator $\Simulator$.
% We say that a protocol $\varphi$ securely realizes $\Functionality_{\varphi}$ if $\Environment$ cannot distinguish the real world from the ideal world, i.e., $\Environment$ cannot distinguish whether it is interacting with $\Adversary$ and parties running protocol $\varphi$ or with $\Simulator$ and dummy parties relaying to $\Functionality_{\varphi}$.
%
% A protocol $\varphi^{\FunctionalityG}$ securely realizes $\Functionality$ in the $\FunctionalityG$-hybrid model when $\varphi$ is allowed to invoke the ideal functionality $\FunctionalityG$. Therefore, for any protocol $\psi$ that securely realizes $\FunctionalityG$, the composed protocol $\varphi^{\psi}$, which is obtained by replacing each invocation of an instance of $\FunctionalityG$ with an invocation of an instance of $\psi$, securely realizes $\Functionality$.
%
% In the ideal functionalities described in this paper, we consider static corruptions.
% When describing ideal functionalities, we use the following conventions as in~\cite{DBLP:conf/crypto/CamenischDR16}.
\begin{description}[leftmargin=0pt]

\item[Interface Naming Convention.]
An ideal functionality can be invoked by using one or more interfaces. The name of a message in an interface consists of three fields separated by dots, e.g., $\fcecsetupini$ in $\Functionality_{\CEC}$ in~\S\ref{sec:idealfun}.
The first field indicates the name of the functionality and is the same in all interfaces of the functionality.
This field is useful for distinguishing between invocations of different functionalities in a hybrid protocol that uses two or more different functionalities.
The second field indicates the kind of action performed by the functionality and is the same in all messages that the functionality exchanges within the same interface.
The third field distinguishes between the messages that belong to the same interface, and can take the following different values.
 A message $\fcecsetupini$ is the incoming message received by the functionality, i.e., the message through which the interface is invoked.
 A message $\fcecsetupend$ is the outgoing message sent by the functionality, i.e., the message that ends the execution of the interface.
 The message $\fcecsetupsim$ is used by the functionality to send a message to $\Simulator$, and the message $\fcecsetuprep$ is used to receive a message from $\Simulator$.
% \ifnum\fullversion=1
% The message $\fuuhdreadreq$ is used by the functionality to send a message to $\Simulator$ to request the description of algorithms from $\Simulator$, and the message $\fuuhdreadalg$ is used by $\Simulator$ to send the description of those algorithms to the functionality.
%\fi

\item[Network vs local communication.] The identity of an interactive Turing machine instance (ITI) consists of a party identifier $\pid$ and a session identifier $\sid$. A set of parties in an execution of a system of interactive Turing machines is a protocol instance if they have the same session identifier $\sid$.
    ITIs can pass direct inputs to and outputs from ``local'' ITIs that have the same $\pid$.
    An ideal functionality $\Functionality$ has $\pid=\bot$ and is considered local to all parties.     An instance of $\Functionality$ with the session identifier $\sid$ only accepts inputs from and passes outputs to machines with the same session identifier $\sid$. Some functionalities require the session identifier to have some structure. Those functionalities check whether the session identifier possesses the required structure in the first message that invokes the functionality. For the subsequent messages, the functionality implicitly checks that the session identifier equals the session identifier used in the first message.
    Communication between ITIs with different party identifiers must take place over the network.
    The network is controlled by $\Adversary$, meaning that he can arbitrarily delay, modify, drop, or insert messages.

\item[Query identifiers.] Some interfaces in a functionality can be invoked more than once. When the functionality sends a message $\fcecsetupsim$ to $\Simulator$ in such an interface, a query identifier $\qid$ is included in the message. The query identifier must also be included in the response $\fcecsetuprep$ sent by $\Simulator$. The query identifier is used to identify the message $\fcecsetupsim$ to which $\Simulator$ replies with a message $\fcecsetuprep$. We note that, typically, $\Simulator$ in the security proof may not be able to provide an immediate answer to the functionality after receiving a message $\fcecsetupsim$. The reason is that $\Simulator$ typically needs to interact with the copy of $\Adversary$ it runs in order to produce the message $\fcecsetuprep$, but $\Adversary$ may not provide the desired answer or may provide a delayed answer. In such cases, when the functionality sends more than one message $\fcecsetupsim$ to $\Simulator$, $\Simulator$ may provide delayed replies, and the order of those replies may not follow the order of the messages received.

\item[Aborts.]  When an ideal functionality $\Functionality$ aborts after being activated with a message sent by a party, we mean that $\Functionality$ halts the execution of its program and sends a special abortion message to the party that invoked the functionality. When an ideal functionality $\Functionality$ aborts after being activated with a message sent by $\Simulator$, we mean that $\Functionality$ halts the execution of its program and sends a special abortion message to the party that receives the outgoing message from $\Functionality$ after $\Functionality$ is activated by $\Simulator$.


%\item[Delayed outputs.] We say that an ideal functionality $\Functionality$ \emph{sends a public delayed output} $v$ to a party $\Party$ if it engages in the following interaction.
%    $\Functionality$ sends to $\Simulator$ a note that it is ready to generate an output to $\Party$.
%    The note includes the value $v$, the identity $\Party$, and a unique identifier for this output.
%    When $\Simulator$ replies to the note by echoing the unique identifier, $\Functionality$ outputs the value $v$ to $\Party$.
%    A \emph{private delayed output} is similar, but the value $v$ is not included in the note.
\end{description}
