\section{Background} \label{sec:background}
We start by giving a brief introduction of Rust, in particular its ownership system and the use of pointers, as they
are core to memory safely. 


\subsection{Rust ownership model} \label{sec:rustownership}







Ownership in Rust denotes a set of rules that govern how a Rust program manages memory~\cite{matsakis2014rust}.
The idea is to associate each value with a \emph{unique} owner. This feature is useful for memory management. 
For example, when the owner goes out of scope, the memory
allocated for the value can be automatically recycled. 
\begin{lstlisting}
let mut v = ...
let mut u = v;         // ownership is transferred to u
\end{lstlisting}
In the above snippet, the assignment of \lstinline{v} to \lstinline{u} also transfers ownership, after which
\lstinline{v} is dropped from the scope and cannot be used again. 


This permanent transfer of ownership gives strong guarantees but can be cumbersome to manage in programming. 
For temporal transfer of ownership (known as \emph{borrowing}), one can use 
a \emph{reference} (marked by an ampersand). For example, in \lstinline{f(&mut x)}, 
the ownership of \lstinline{x}'s value is temporally borrowed by to the function call until its return.

This concept of time creates another dimension of ownership management known as \emph{lifetime}. 
For mutable references (as marked by \lstinline{mut} in the above examples), the rule is relatively simple:
only one mutable reference is allowed at anytime. But for immutable references (the ones without the \lstinline{mut} marking),
multiple of them can coexist as long as there isn't any mutable reference at the same time. 
As one can expect, this interaction of mutable and immutable references, and their lifetimes is highly
non-trivial. In this paper, we focus on analysing mutable references as they are far more common than immutable ones. 








\subsection{Pointer types in Rust} \label{sec:backgroud-pointers}
Rust has a richer pointer system than C.
The primitive C-style pointers (written as \lstinline{*const T} or \lstinline{*mut T}) are known as \emph{raw pointers}, which 
are ignored by the Rust compiler for ownership and lifetime checks. Raw pointers are a major
source of unsafe Rust (more below). Idiomatic Rust instead advocates \emph{box pointers} (written as \lstinline{Box<T>}) as owning pointers that uniquely own heap allocations, as well as \emph{references} (written as \lstinline{&mut T} or \lstinline{& T} as discussed in the 
previous subsection) as non-owning pointers that are used to access values owned by others.

C-style array pointers are represented in Rust as references to arrays and slice references, with array bounds
known at compile time and runtime, respectively. The creation of meta-data such as array bounds is  
beyond the scope of ownership analysis. In this work, we keep array pointers as raw pointers in the translated code. 










\subsection{Unsafe Rust}  
As a pragmatic design, Rust allows programs to contain features that cannot be verified 
by the compiler as memory safe. This includes dereferencing raw pointers, calling low level
 functions, and so on. Such uses must to marked by the \lstinline{unsafe} keyword and form
fragments of \emph{unsafe Rust}. It is worth noting that \lstinline{unsafe}
does not turn off compiler checks; safe pointers are still checked. 

The main purpose of unsafe Rust is to support low-level systems programming. But it can 
also be used for other reasons. 
For example, \crust~\cite{c2rust} directly translates C pointers into raw pointers. Without
unsafe Rust, the generated code would not compile.



