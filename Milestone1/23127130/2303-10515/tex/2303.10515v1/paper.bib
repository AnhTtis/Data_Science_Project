@inproceedings{DBLP:conf/pldi/HeineL03,
  author    = {David L. Heine and
               Monica S. Lam},
  editor    = {Ron Cytron and
               Rajiv Gupta},
  title     = {A practical flow-sensitive and context-sensitive {C} and {C++} memory
               leak detector},
  booktitle = {Proceedings of the {ACM} {SIGPLAN} 2003 Conference on Programming
               Language Design and Implementation 2003, San Diego, California, USA,
               June 9-11, 2003},
  pages     = {168--181},
  publisher = {{ACM}},
  year      = {2003},
  url       = {https://doi.org/10.1145/781131.781150},
  doi       = {10.1145/781131.781150},
  timestamp = {Fri, 25 Jun 2021 17:17:37 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/HeineL03.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{pldi09,
  author    = {Tristan Ravitch and
               Steve Jackson and
               Eric Aderhold and
               Ben Liblit},
  editor    = {Michael Hind and
               Amer Diwan},
  title     = {Automatic generation of library bindings using static analysis},
  booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, {PLDI} 2009, Dublin, Ireland,
               June 15-21, 2009},
  pages     = {352--362},
  publisher = {{ACM}},
  year      = {2009},
  url       = {https://doi.org/10.1145/1542476.1542516},
  doi       = {10.1145/1542476.1542516},
  timestamp = {Fri, 25 Jun 2021 14:48:54 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/RavitchJAL09.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1145/2464157.2464162,
author = {Ravitch, Tristan and Liblit, Ben},
title = {Analyzing Memory Ownership Patterns in C Libraries},
year = {2018},
isbn = {9781450321006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2464157.2464162},
doi = {10.1145/2464157.2464162},
abstract = {Programs written in multiple languages are known as polyglot programs. In part due to the proliferation of new and productive high-level programming languages, these programs are becoming more common in environments that must interoperate with existing systems. Polyglot programs must manage resource lifetimes across language boundaries. Resource lifetime management bugs can lead to leaks and crashes, which are more difficult to debug in polyglot programs than monoglot programs.We present analyses to automatically infer the ownership semantics of C libraries. The results of these analyses can be used to generate bindings to C libraries that intelligently manage resources, to check the correctness of polyglot programs, and to document the interfaces of C libraries. While these analyses are unsound and incomplete, we demonstrate that they significantly reduce the manual annotation burden for a suite of fifteen open source libraries.},
booktitle = {Proceedings of the 2013 International Symposium on Memory Management},
pages = {97–108},
numpages = {12},
keywords = {sharing, bindings, ownership transfer, interprocedural static program analysis, reference counting, libraries, polyglot programming, interoperability, resource lifetime management, memory allocation, dataflow analysis, finalizers, foreign function interfaces (ffis), allocators, escape analysis},
location = {Seattle, Washington, USA},
series = {ISMM '13}
}

@inproceedings{DBLP:conf/sas/Boyland03,
  author    = {John Boyland},
  editor    = {Radhia Cousot},
  title     = {Checking Interference with Fractional Permissions},
  booktitle = {Static Analysis, 10th International Symposium, {SAS} 2003, San Diego,
               CA, USA, June 11-13, 2003, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {2694},
  pages     = {55--72},
  publisher = {Springer},
  year      = {2003},
  url       = {https://doi.org/10.1007/3-540-44898-5\_4},
  doi       = {10.1007/3-540-44898-5\_4},
  timestamp = {Tue, 14 May 2019 10:00:52 +0200},
  biburl    = {https://dblp.org/rec/conf/sas/Boyland03.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{matsakis2014rust,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The Rust Language},
year = {2014},
isbn = {9781450332170},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2663171.2663188},
doi = {10.1145/2663171.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
booktitle = {Proceedings of the 2014 ACM SIGAda Annual Conference on High Integrity Language Technology},
pages = {103–104},
numpages = {2},
keywords = {systems programming, memory management, rust, affine type systems},
location = {Portland, Oregon, USA},
series = {HILT '14}
}


@article{DBLP:journals/pacmpl/EmreSDH21,
  author    = {Mehmet Emre and
               Ryan Schroeder and
               Kyle Dewey and
               Ben Hardekopf},
  title     = {Translating {C} to safer Rust},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {5},
  number    = {{OOPSLA}},
  pages     = {1--29},
  year      = {2021},
  url       = {https://doi.org/10.1145/3485498},
  doi       = {10.1145/3485498},
  timestamp = {Sat, 08 Jan 2022 02:21:37 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/EmreSDH21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@software{emre_mehmet_2021_5442253,
  author       = {Emre, Mehmet and
                  Schroeder, Ryan},
  title        = {Artifact for "Translating C to Safer Rust"},
  month        = sep,
  year         = 2021,
  publisher    = {Zenodo},
  doi          = {10.5281/zenodo.5442253},
  url          = {https://doi.org/10.5281/zenodo.5442253}
}

@misc{c2rust,
  author = {Immunant inc.},
  title = {c2rust},
  howpublished= {\url{https://github.com/immunant/c2rust}}
}

@misc{z3,
  author = {Nick Fitzgerald and Graydon Hoare and Bruce Mitchener and Sameer Puri},
  title = {Rust bindings to the Z3 SMT solver},
  howpublished= {\url{https://crates.io/crates/z3}}
}


@inproceedings{10.1145/512529.512531,
author = {Foster, Jeffrey S. and Terauchi, Tachio and Aiken, Alex},
title = {Flow-Sensitive Type Qualifiers},
year = {2002},
isbn = {1581134630},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/512529.512531},
doi = {10.1145/512529.512531},
abstract = {We present a system for extending standard type systems with flow-sensitive type qualifiers. Users annotate their programs with type qualifiers, and inference checks that the annotations are correct. In our system only the type qualifiers are modeled flow-sensitively---the underlying standard types are unchanged, which allows us to obtain an efficient constraint-based inference algorithm that integrates flow-insensitive alias analysis, effect inference, and ideas from linear type systems to support strong updates. We demonstrate the usefulness of flow-sensitive type qualifiers by finding a number of new locking bugs in the Linux kernel.},
booktitle = {Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation},
pages = {1–12},
numpages = {12},
keywords = {constraints, type qualifiers, effect inference, alias analysis, locking, flow-sensitivity, restrict, linux kernel, types},
location = {Berlin, Germany},
series = {PLDI '02}
}


@article{10.1145/543552.512531,
author = {Foster, Jeffrey S. and Terauchi, Tachio and Aiken, Alex},
title = {Flow-Sensitive Type Qualifiers},
year = {2002},
issue_date = {May 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {37},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/543552.512531},
doi = {10.1145/543552.512531},
abstract = {We present a system for extending standard type systems with flow-sensitive type qualifiers. Users annotate their programs with type qualifiers, and inference checks that the annotations are correct. In our system only the type qualifiers are modeled flow-sensitively---the underlying standard types are unchanged, which allows us to obtain an efficient constraint-based inference algorithm that integrates flow-insensitive alias analysis, effect inference, and ideas from linear type systems to support strong updates. We demonstrate the usefulness of flow-sensitive type qualifiers by finding a number of new locking bugs in the Linux kernel.},
journal = {SIGPLAN Not.},
month = {may},
pages = {1–12},
numpages = {12},
keywords = {effect inference, types, linux kernel, constraints, type qualifiers, flow-sensitivity, restrict, alias analysis, locking}
}

@article{10.1145/1186632.1186635,
author = {Foster, Jeffrey S. and Johnson, Robert and Kodumal, John and Aiken, Alex},
title = {Flow-Insensitive Type Qualifiers},
year = {2006},
issue_date = {November 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {6},
issn = {0164-0925},
url = {https://doi.org/10.1145/1186632.1186635},
doi = {10.1145/1186632.1186635},
abstract = {We describe flow-insensitive type qualifiers, a lightweight, practical mechanism for specifying and checking properties not captured by traditional type systems. We present a framework for adding new, user-specified type qualifiers to programming languages with static type systems, such as C and Java. In our system, programmers add a few type qualifier annotations to their program, and automatic type qualifier inference determines the remaining qualifiers and checks the annotations for consistency. We describe a tool CQual for adding type qualifiers to the C programming language. Our tool CQual includes a visualization component for displaying browsable inference results to the programmer. Finally, we present several experiments using our tool, including inferring const qualifiers, finding security vulnerabilities in several popular C programs, and checking initialization data usage in the Linux kernel. Our results suggest that inference and visualization make type qualifiers lightweight, that type qualifier inference scales to large programs, and that type qualifiers are applicable to a wide variety of problems.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {nov},
pages = {1035–1087},
numpages = {53},
keywords = {types, taint, Type qualifiers, const, constraints, static analysis, security}
}

@article{10.1145/2398857.2384680,
author = {Huang, Wei and Milanova, Ana and Dietl, Werner and Ernst, Michael D.},
title = {Reim \& ReImInfer: Checking and Inference of Reference Immutability and Method Purity},
year = {2012},
issue_date = {October 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/2398857.2384680},
doi = {10.1145/2398857.2384680},
abstract = {Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference.To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference result. Empirical results on Java applications and libraries of up to 348kLOC show that our approach achieves both scalability and precision.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {879–896},
numpages = {18},
keywords = {type system, inference, method purity, reference immutability}
}


@inproceedings{10.1145/2384616.2384680,
author = {Huang, Wei and Milanova, Ana and Dietl, Werner and Ernst, Michael D.},
title = {Reim \& ReImInfer: Checking and Inference of Reference Immutability and Method Purity},
year = {2012},
isbn = {9781450315616},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384616.2384680},
doi = {10.1145/2384616.2384680},
abstract = {Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference.To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference result. Empirical results on Java applications and libraries of up to 348kLOC show that our approach achieves both scalability and precision.},
booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {879–896},
numpages = {18},
keywords = {type system, inference, method purity, reference immutability},
location = {Tucson, Arizona, USA},
series = {OOPSLA '12}
}

@article{10.1145/1297105.1297051,
author = {Greenfieldboyce, David and Foster, Jeffrey S.},
title = {Type Qualifier Inference for Java},
year = {2007},
issue_date = {October 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1297105.1297051},
doi = {10.1145/1297105.1297051},
abstract = {Java's type system provides programmers with strong guarantees of type and memory safety, but there are many important properties not captured by standard Java types. We describe JQual, a tool that adds user-defined type qualifiers to Java, allowing programmers to quickly and easily incorporateextra lightweight, application-specific type checking into their programs. JQual provides type qualifier inference, so that programmers need only add a few key qualifier annotations to their program, and then JQual infers any remaining qualifiers and checks their consistency. We explore two applications of JQual. First, we introduce opaque and enumqualifiers to track C pointers and enumerations that flow through Java code via the JNI. In our benchmarks we found that these C values are treated correctly, but there are some places where a client could potentially violate safety. Second,we introduce a read only qualifier for annotating references that cannot be used to modify the objects they refer to. We found that JQual is able to automatically infer read only in many places on method signatures. These results suggest that type qualifiers and type qualifier inference are a useful addition to Java.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {321–336},
numpages = {16},
keywords = {mutable, context-sensitivity, tracked, JQual, field-sensitivity, opaque, transparent, type qualifiers, context-free language reachability, java, readonly}
}


@inproceedings{10.1145/1297027.1297051,
author = {Greenfieldboyce, David and Foster, Jeffrey S.},
title = {Type Qualifier Inference for Java},
year = {2007},
isbn = {9781595937865},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1297027.1297051},
doi = {10.1145/1297027.1297051},
abstract = {Java's type system provides programmers with strong guarantees of type and memory safety, but there are many important properties not captured by standard Java types. We describe JQual, a tool that adds user-defined type qualifiers to Java, allowing programmers to quickly and easily incorporateextra lightweight, application-specific type checking into their programs. JQual provides type qualifier inference, so that programmers need only add a few key qualifier annotations to their program, and then JQual infers any remaining qualifiers and checks their consistency. We explore two applications of JQual. First, we introduce opaque and enumqualifiers to track C pointers and enumerations that flow through Java code via the JNI. In our benchmarks we found that these C values are treated correctly, but there are some places where a client could potentially violate safety. Second,we introduce a read only qualifier for annotating references that cannot be used to modify the objects they refer to. We found that JQual is able to automatically infer read only in many places on method signatures. These results suggest that type qualifiers and type qualifier inference are a useful addition to Java.},
booktitle = {Proceedings of the 22nd Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications},
pages = {321–336},
numpages = {16},
keywords = {context-free language reachability, java, context-sensitivity, field-sensitivity, mutable, opaque, transparent, readonly, type qualifiers, tracked, JQual},
location = {Montreal, Quebec, Canada},
series = {OOPSLA '07}
}


@article{10.1145/3527322,
author = {Machiry, Aravind and Kastner, John and McCutchen, Matt and Eline, Aaron and Headley, Kyle and Hicks, Michael},
title = {C to Checked C by 3c},
year = {2022},
issue_date = {April 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3527322},
doi = {10.1145/3527322},
abstract = {Owing to the continued use of C (and C++), spatial safety violations (e.g., buffer overflows) still constitute one of today's most dangerous and prevalent security vulnerabilities. To combat these violations, Checked C extends C with bounds-enforced checked pointer types. Checked C is essentially a gradually typed spatially safe C - checked pointers are backwards-binary compatible with legacy pointers, and the language allows them to be added piecemeal, rather than necessarily all at once, so that safety retrofitting can be incremental. This paper presents a semi-automated process for porting a legacy C program to Checked C. The process centers on 3C, a static analysis-based annotation tool. 3C employs two novel static analysis algorithms - typ3c and boun3c - to annotate legacy pointers as checked pointers, and to infer array bounds annotations for pointers that need them. 3C performs a root cause analysis to direct a human developer to code that should be refactored; once done, 3C can be re-run to infer further annotations (and updated root causes). Experiments on 11 programs totaling 319KLoC show 3C to be effective at inferring checked pointer types, and experience with previously and newly ported code finds 3C works well when combined with human-driven refactoring.},
journal = {Proc. ACM Program. Lang.},
month = {apr},
articleno = {78},
numpages = {29},
keywords = {Source Rewriter, Spatial Safety Prevention, Checked C}
}


@inproceedings{10.1145/3385412.3386036,
author = {Qin, Boqin and Chen, Yilun and Yu, Zeming and Song, Linhai and Zhang, Yiying},
title = {Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3386036},
doi = {10.1145/3385412.3386036},
abstract = {Rust is a young programming language designed for systems software development. It aims to provide safety guarantees like high-level languages and performance efficiency like low-level languages. The core design of Rust is a set of strict safety rules enforced by compile-time checking. To support more low-level controls, Rust allows programmers to bypass these compiler checks to write unsafe code. It is important to understand what safety issues exist in real Rust programs and how Rust safety mechanisms impact programming practices. We performed the first empirical study of Rust by close, manual inspection of 850 unsafe code usages and 170 bugs in five open-source Rust projects, five widely-used Rust libraries, two online security databases, and the Rust standard library. Our study answers three important questions: how and why do programmers write unsafe code, what memory-safety issues real Rust programs have, and what concurrency bugs Rust programmers make. Our study reveals interesting real-world Rust program behaviors and new issues Rust programmers make. Based on our study results, we propose several directions of building Rust bug detectors and built two static bug detectors, both of which revealed previously unknown bugs.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {763–779},
numpages = {17},
keywords = {Concurrency Bug, Bug Study, Memory Bug, Rust},
location = {London, UK},
series = {PLDI 2020}
}


@InProceedings{10.1007/978-3-642-31057-7_29,
author="De, Arnab
and D'Souza, Deepak",
editor="Noble, James",
title="Scalable Flow-Sensitive Pointer Analysis for Java with Strong Updates",
booktitle="ECOOP 2012 -- Object-Oriented Programming",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="665--687",
abstract="The ability to perform strong updates is the main contributor to the precision of flow-sensitive pointer analysis algorithms. Traditional flow-sensitive pointer analyses cannot strongly update pointers residing in the heap. This is a severe restriction for Java programs. In this paper, we propose a new flow-sensitive pointer analysis algorithm for Java that can perform strong updates on heap-based pointers effectively. Instead of points-to graphs, we represent our points-to information as maps from access paths to sets of abstract objects. We have implemented our analysis and run it on several large Java benchmarks. The results show considerable improvement in precision over the points-to graph based flow-insensitive and flow-sensitive analyses, with reasonable running time.",
isbn="978-3-642-31057-7"
}


@inproceedings{10.1145/349299.349311,
author = {Cheng, Ben-Chung and Hwu, Wen-Mei W.},
title = {Modular Interprocedural Pointer Analysis Using Access Paths: Design, Implementation, and Evaluation},
year = {2000},
isbn = {1581131992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/349299.349311},
doi = {10.1145/349299.349311},
abstract = {In this paper we present a modular interprocedural pointer analysis algorithm based on access-paths for C programs. We argue that access paths can reduce the overhead of representing context-sensitive transfer functions and effectively distinguish non-recursive heap objects. And when the modular analysis paradigm is used together with other techniques to handle type casts and function pointers, we are able to handle significant programs like those in the SPECcint92 and SPECcint95 suites. We have implemented the algorithm and tested it on a Pentium II 450 PC running Linux. The observed resource consumption and performance improvement are very encouraging.},
booktitle = {Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation},
pages = {57–69},
numpages = {13},
location = {Vancouver, British Columbia, Canada},
series = {PLDI '00}
}


@article{10.1145/358438.349311,
author = {Cheng, Ben-Chung and Hwu, Wen-Mei W.},
title = {Modular Interprocedural Pointer Analysis Using Access Paths: Design, Implementation, and Evaluation},
year = {2000},
issue_date = {May 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/358438.349311},
doi = {10.1145/358438.349311},
abstract = {In this paper we present a modular interprocedural pointer analysis algorithm based on access-paths for C programs. We argue that access paths can reduce the overhead of representing context-sensitive transfer functions and effectively distinguish non-recursive heap objects. And when the modular analysis paradigm is used together with other techniques to handle type casts and function pointers, we are able to handle significant programs like those in the SPECcint92 and SPECcint95 suites. We have implemented the algorithm and tested it on a Pentium II 450 PC running Linux. The observed resource consumption and performance improvement are very encouraging.},
journal = {SIGPLAN Not.},
month = {may},
pages = {57–69},
numpages = {13}
}


@INPROCEEDINGS{7372049,
  author={Lerch, Johannes and Späth, Johannes and Bodden, Eric and Mezini, Mira},
  booktitle={2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)}, 
  title={Access-Path Abstraction: Scaling Field-Sensitive Data-Flow Analysis with Unbounded Access Paths (T)}, 
  year={2015},
  volume={},
  number={},
  pages={619-629},
  doi={10.1109/ASE.2015.9}
}

@article{10.5555/295545.295551,
author = {Briggs, Preston and Cooper, Keith D. and Harvey, Timothy J. and Simpson, L. Taylor},
title = {Practical Improvements to the Construction and Destruction of Static Single Assignment Form},
year = {1998},
issue_date = {July 10, 1998},
publisher = {John Wiley & Sons, Inc.},
address = {USA},
volume = {28},
number = {8},
issn = {0038-0644},
journal = {Softw. Pract. Exper.},
month = {jul},
pages = {859–881},
numpages = {23},
keywords = {code optimization, lost-copy problem, swap problem, data-flow analysis, compilers, static single assignment form}
}

@inproceedings{CRustS,
  author    = {Michael Ling and
               Yijun Yu and
               Haitao Wu and
               Yuan Wang and
               James R. Cordy and
               Ahmed E. Hassan},
  title     = {In Rust We Trust - {A} Transpiler from Unsafe {C} to Safer Rust},
  booktitle = {44th {IEEE/ACM} International Conference on Software Engineering:
               Companion Proceedings, {ICSE} Companion 2022, Pittsburgh, PA, USA,
               May 22-24, 2022},
  pages     = {354--355},
  publisher = {{ACM/IEEE}},
  year      = {2022},
  url       = {https://doi.org/10.1145/3510454.3528640},
  doi       = {10.1145/3510454.3528640},
  timestamp = {Wed, 07 Dec 2022 23:10:19 +0100},
  biburl    = {https://dblp.org/rec/conf/icse/LingYWWCH22.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1145/349299.349309,
author = {Das, Manuvir},
title = {Unification-Based Pointer Analysis with Directional Assignments},
year = {2000},
isbn = {1581131992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/349299.349309},
doi = {10.1145/349299.349309},
abstract = {This paper describes a new algorithm for flow and context insensitive pointer analysis of C programs. Our studies show that the most common use of pointers in C programs is in passing the addresses of composite objects or updateable values as arguments to procedures. Therefore, we have designed a low-cost algorithm that handles this common case accurately. In terms of both precision and running time, this algorithm lies between Steensgaard's algorithm, which treats assignments bi-directionally using unification, and Andersen's algorithm, which treats assignments directionally using subtyping. Our “one level flow” algorithm uses a restricted form of subtyping to avoid unification of symbols at the top levels of pointer chains in the points-to graph, while using unification elsewhere in the graph. The method scales easily to large programs. For instance, we are able to analyze a 1.4 MLOC (million lines of code) program in two minutes, using less than 200MB of memory. At the same time, the precision of our algorithm is very close to that of Andersen's algorithm. On all of the integer benchmark programs from SPEC95, the one level flow algorithm and Andersen's algorithm produce either identical or essentially identical points-to information. Therefore, we claim that our algorithm provides a method for obtaining precise flow-insensitive points-to information for large C programs.},
booktitle = {Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation},
pages = {35–46},
numpages = {12},
location = {Vancouver, British Columbia, Canada},
series = {PLDI '00}
}


@article{10.1145/358438.349309,
author = {Das, Manuvir},
title = {Unification-Based Pointer Analysis with Directional Assignments},
year = {2000},
issue_date = {May 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/358438.349309},
doi = {10.1145/358438.349309},
abstract = {This paper describes a new algorithm for flow and context insensitive pointer analysis of C programs. Our studies show that the most common use of pointers in C programs is in passing the addresses of composite objects or updateable values as arguments to procedures. Therefore, we have designed a low-cost algorithm that handles this common case accurately. In terms of both precision and running time, this algorithm lies between Steensgaard's algorithm, which treats assignments bi-directionally using unification, and Andersen's algorithm, which treats assignments directionally using subtyping. Our “one level flow” algorithm uses a restricted form of subtyping to avoid unification of symbols at the top levels of pointer chains in the points-to graph, while using unification elsewhere in the graph. The method scales easily to large programs. For instance, we are able to analyze a 1.4 MLOC (million lines of code) program in two minutes, using less than 200MB of memory. At the same time, the precision of our algorithm is very close to that of Andersen's algorithm. On all of the integer benchmark programs from SPEC95, the one level flow algorithm and Andersen's algorithm produce either identical or essentially identical points-to information. Therefore, we claim that our algorithm provides a method for obtaining precise flow-insensitive points-to information for large C programs.},
journal = {SIGPLAN Not.},
month = {may},
pages = {35–46},
numpages = {12}
}


@incollection{KULeuven-2-1630873,
author = {Clarke, Dave and {\"O}stlund, Johan and Sergey, Ilya and Wrigstad, Tobias},
editor = {Clarke, Dave and Noble, James and Wrigstad, Tobias},
title = {Ownership types: a survey},
year = {2013},
url = {https://lirias.kuleuven.be/1630873},
isbn = {978-3-642-36945-2},
issn = {0302-9743},
doi = {https://doi.org/10.1007/978-3-642-36946-9-3},
publisher = {Springer},
volume = {7850},
pages = {15--58},
}


@inproceedings{10.1145/781131.781168,
author = {Boyapati, Chandrasekhar and Salcianu, Alexandru and Beebee, William and Rinard, Martin},
title = {Ownership Types for Safe Region-Based Memory Management in Real-Time Java},
year = {2003},
isbn = {1581136625},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/781131.781168},
doi = {10.1145/781131.781168},
abstract = {The Real Time Specification for Java (RTSJ) allows a program to create real-time threads with hard real-time constraints. Real-time threads use region-based memory management to avoid unbounded pauses caused by interference from the garbage collector. The RTSJ uses runtime checks to ensure that deleting a region does not create dangling references and that real-time threads do not access references to objects allocated in the garbage-collected heap. This paper presents a static type system that guarantees that these runtime checks will never fail for well-typed programs. Our type system therefore 1) provides an important safety guarantee for real-time programs and 2) makes it possible to eliminate the runtime checks and their associated overhead.Our system also makes several contributions over previous work on region types. For object-oriented programs, it combines the benefits of region types and ownership types in a unified type system framework. For multithreaded programs, it allows long-lived threads to share objects without using the heap and without memory leaks. For real-time programs, it ensures that real-time threads do not interfere with the garbage collector. Our experience indicates that our type system is sufficiently expressive and requires little programming overhead, and that eliminating the RTSJ runtime checks using a static type system can significantly decrease the execution time of real-time programs.},
booktitle = {Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation},
pages = {324–337},
numpages = {14},
keywords = {real-time, encapsulation, regions, ownership types},
location = {San Diego, California, USA},
series = {PLDI '03}
}

@inproceedings{10.1145/286936.286947,
author = {Clarke, David G. and Potter, John M. and Noble, James},
title = {Ownership Types for Flexible Alias Protection},
year = {1998},
isbn = {1581130058},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/286936.286947},
doi = {10.1145/286936.286947},
abstract = {Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any aliasing.Ownership types form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.},
booktitle = {Proceedings of the 13th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {48–64},
numpages = {17},
keywords = {containment, ownership, programming language design, representation exposure, sharing, alias protection},
location = {Vancouver, British Columbia, Canada},
series = {OOPSLA '98}
}

@inproceedings{10.1145/582419.582448,
author = {Aldrich, Jonathan and Kostadinov, Valentin and Chambers, Craig},
title = {Alias Annotations for Program Understanding},
year = {2002},
isbn = {1581134711},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/582419.582448},
doi = {10.1145/582419.582448},
abstract = {One of the primary challenges in building and evolving large object-oriented systems is understanding aliasing between objects. Unexpected aliasing can lead to broken invariants, mistaken assumptions, security holes, and surprising side effects, all of which may lead to software defects and complicate software evolution.This paper presents AliasJava, a capability-based alias annotation system for Java that makes alias patterns explicit in the source code, enabling developers to reason more effectively about the interactions in a complex system. We describe our implementation, prove the soundness of the annotation system, and give an algorithm for automatically inferring alias annotations. Our experience suggests that the annotation system is practical, that annotation inference is efficient and yields appropriate annotations, and that the annotations can express important invariants of data structures and of software architectures.},
booktitle = {Proceedings of the 17th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {311–330},
numpages = {20},
keywords = {encapsulation, uniqueness, ownership types, aliasjava, type inference, java, aliasing},
location = {Seattle, Washington, USA},
series = {OOPSLA '02}
}

@article{10.1145/3485522,
author = {Wolff, Fabian and B\'{\i}l\'{y}, Aurel and Matheja, Christoph and M\"{u}ller, Peter and Summers, Alexander J.},
title = {Modular Specification and Verification of Closures in Rust},
year = {2021},
issue_date = {October 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {OOPSLA},
url = {https://doi.org/10.1145/3485522},
doi = {10.1145/3485522},
abstract = {Closures are a language feature supported by many mainstream languages, combining the ability to package up references to code blocks with the possibility of capturing state from the environment of the closure's declaration. Closures are powerful, but complicate understanding and formal reasoning, especially when closure invocations may mutate objects reachable from the captured state or from closure arguments. This paper presents a novel technique for the modular specification and verification of closure-manipulating code in Rust. Our technique combines Rust's type system guarantees and novel specification features to enable formal verification of rich functional properties. It encodes higher-order concerns into a first-order logic, which enables automation via SMT solvers. Our technique is implemented as an extension of the deductive verifier Prusti, with which we have successfully verified many common idioms of closure usage.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {closures, Rust, higher-order functions, software verification}
}

@inproceedings{10.1145/604131.604156,
author = {Boyapati, Chandrasekhar and Liskov, Barbara and Shrira, Liuba},
title = {Ownership Types for Object Encapsulation},
year = {2003},
isbn = {1581136285},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/604131.604156},
doi = {10.1145/604131.604156},
abstract = {Ownership types provide a statically enforceable way of specifying object encapsulation and enable local reasoning about program correctness in object-oriented languages. However, a type system that enforces strict object encapsulation is too constraining: it does not allow efficient implementation of important constructs like iterators. This paper argues that the right way to solve the problem is to allow objects of classes defined in the same module to have privileged access to each other's representations; we show how to do this for inner classes. This approach allows programmers to express constructs like iterators and yet supports local reasoning about the correctness of the classes, because a class and its inner classes together can be reasoned about as a module. The paper also sketches how we use our variant of ownership types to enable efficient software upgrades in persistent object stores.},
booktitle = {Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {213–223},
numpages = {11},
keywords = {ownership types, software upgrades, object encapsulation},
location = {New Orleans, Louisiana, USA},
series = {POPL '03}
}

@article{ZHAO2008213,
title = {Implicit ownership types for memory management},
journal = {Science of Computer Programming},
volume = {71},
number = {3},
pages = {213-241},
year = {2008},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2008.04.001},
url = {https://www.sciencedirect.com/science/article/pii/S0167642308000300},
author = {Tian Zhao and Jason Baker and James Hunt and James Noble and Jan Vitek},
keywords = {Real-time Java, RTSJ, Type systems, Memory management, Ownership types},
abstract = {The Real-time Specification for Java (RTSJ) introduced a range of language features for explicit memory management. While the RTSJ gives programmers fine control over memory use and allows linear allocation and constant-time deallocation, the RTSJ relies upon dynamic runtime checks for safety, making it unsuitable for safety critical applications. We introduce ScopeJ, a statically-typed, multi-threaded, object calculus in which scopes are first class constructs. Scopes reify allocation contexts and provide a safe alternative to automatic memory management. Safety follows from the use of an ownership type system that enforces a topology on run-time patterns of references. ScopeJ’s type system is novel in that ownership annotations are implicit. This substantially reduces the burden for developers and increases the likelihood of adoption. The notion of implicit ownership is particularly appealing when combined with pluggable type systems, as one can apply different type constraints to different components of an application depending on the requirements without changing the source language. In related work we have demonstrated the usefulness of our approach in the context of highly-responsive systems and stream processing.}
}


@article{10.1016/j.tcs.2006.12.034,
author = {Brookes, Stephen},
title = {A Semantics for Concurrent Separation Logic},
year = {2007},
issue_date = {April, 2007},
publisher = {Elsevier Science Publishers Ltd.},
address = {GBR},
volume = {375},
number = {1–3},
issn = {0304-3975},
url = {https://doi.org/10.1016/j.tcs.2006.12.034},
doi = {10.1016/j.tcs.2006.12.034},
abstract = {We present a trace semantics for a language of parallel programs which share access to mutable data. We introduce a resource-sensitive logic for partial correctness, based on a recent proposal of O'Hearn, adapting separation logic to the concurrent setting. The logic allows proofs of parallel programs in which ''ownership'' of critical data, such as the right to access, update or deallocate a pointer, is transferred dynamically between concurrent processes. We prove soundness of the logic, using a novel ''local'' interpretation of traces which allows accurate reasoning about ownership. We show that every provable program is race-free.},
journal = {Theor. Comput. Sci.},
month = {apr},
pages = {227–270},
numpages = {44},
keywords = {Pointers, Semantics, Logic, Race condition, Concurrency}
}

@article{10.1016/j.entcs.2006.04.008,
author = {Brookes, Stephen},
title = {Variables as Resource for Shared-Memory Programs: Semantics and Soundness},
year = {2006},
issue_date = {May, 2006},
publisher = {Elsevier Science Publishers B. V.},
address = {NLD},
volume = {158},
issn = {1571-0661},
url = {https://doi.org/10.1016/j.entcs.2006.04.008},
doi = {10.1016/j.entcs.2006.04.008},
abstract = {Parkinson, Bornat, and Calcagno recently introduced a logic for partial correctness in which program variables are treated as resource, generalizing earlier work based on separation logic and permissions. An advantage of their approach is that it yields a logic devoid of complex side conditions: there is no need to pepper the inference rules with ''modifies'' clauses. They used a simple operational semantics to prove soundness of the sequential fragment of their logic, and they showed that the inference rules of concurrent separation logic can be translated directly into their framework. Their concurrency rules are strictly more powerful than those of concurrent separation logic, since the new logic allows proofs of programs that perform concurrent reads. We provide a denotational semantics and a soundness proof for the concurrent fragment of their logic, extending our earlier work on concurrent separation logic to incorporate permissions in a natural manner.},
journal = {Electron. Notes Theor. Comput. Sci.},
month = {may},
pages = {123–150},
numpages = {28},
keywords = {race condition, partial correctness, permission, concurrency, shared memory, separation logic}
}

@inproceedings{10.1109/LICS.2007.30,
author = {Calcagno, Cristiano and O'Hearn, Peter W. and Yang, Hongseok},
title = {Local Action and Abstract Separation Logic},
year = {2007},
isbn = {0769529089},
publisher = {IEEE Computer Society},
address = {USA},
url = {https://doi.org/10.1109/LICS.2007.30},
doi = {10.1109/LICS.2007.30},
abstract = {Separation logic is an extension of Hoare's logic which supports a local way of reasoning about programs that mutate memory. We present a study of the semantic structures lying behind the logic. The core idea is of a local action, a state transformer that mutates the state in a local way. We formulate local actions for a class of models called separation algebras, abstracting from the RAM and other specific concrete models used in work on separation logic. Local actions provide a semantics for a generalized form of (sequential) separation logic. We also show that our conditions on local actions allow a general soundness proof for a separation logic for concurrency, interpreted over arbitrary separation algebras.},
booktitle = {Proceedings of the 22nd Annual IEEE Symposium on Logic in Computer Science},
pages = {366–378},
numpages = {13},
series = {LICS '07}
}

@inproceedings{10.1145/1480881.1480922,
author = {Feng, Xinyu},
title = {Local Rely-Guarantee Reasoning},
year = {2009},
isbn = {9781605583792},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1480881.1480922},
doi = {10.1145/1480881.1480922},
abstract = {Rely-Guarantee reasoning is a well-known method for verification of shared-variable concurrent programs. However, it is difficult for users to define rely/guarantee conditions, which specify threads' behaviors over the whole program state. Recent efforts to combine Separation Logic with Rely-Guarantee reasoning have made it possible to hide thread-local resources, but the shared resources still need to be globally known and specified. This greatly limits the reuse of verified program modules.In this paper, we propose LRG, a new Rely-Guarantee-based logic that brings local reasoning and information hiding to concurrency verification. Our logic, for the first time, supports a frame rule over rely/guarantee conditions so that specifications of program modules only need to talk about the resources used locally, and the verified modules can be reused in different threads without redoing the proof. Moreover, we introduce a new hiding rule to hide the resources shared by a subset of threads from the rest in the system. The support of information hiding not only improves the modularity of Rely-Guarantee reasoning, but also enables the sharing of dynamically allocated resources, which requires adjustment of rely/guarantee conditions.},
booktitle = {Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {315–327},
numpages = {13},
keywords = {information hiding, separation logic, rely-guarantee reasoning, concurrency, local reasoning},
location = {Savannah, GA, USA},
series = {POPL '09}
}


@inproceedings{10.1145/1122971.1122992,
author = {Vafeiadis, Viktor and Herlihy, Maurice and Hoare, Tony and Shapiro, Marc},
title = {Proving Correctness of Highly-Concurrent Linearisable Objects},
year = {2006},
isbn = {1595931899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1122971.1122992},
doi = {10.1145/1122971.1122992},
abstract = {We study a family of implementations for linked lists using fine-grain synchronisation. This approach enables greater concurrency, but correctness is a greater challenge than for classical, coarse-grain synchronisation. Our examples are demonstrative of common design patterns such as lock coupling, optimistic, and lazy synchronisation. Although they are are highly concurrent, we prove that they are linearisable, safe, and they correctly implement a high-level abstraction. Our proofs illustrate the power and applicability of rely-guarantee reasoning, as well of some of its limitations. The examples of the paper establish a benchmark challenge for other reasoning techniques.},
booktitle = {Proceedings of the Eleventh ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {129–136},
numpages = {8},
keywords = {rely-guarantee reasoning, linearisability, concurrent programming, shared-memory concurrency, formal verification},
location = {New York, New York, USA},
series = {PPoPP '06}
}

@article{jung:hal-01945446,
  TITLE = {{Iris from the ground up: A modular foundation for higher-order concurrent separation logic}},
  AUTHOR = {Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Ale{\v s} and Birkedal, Lars and Dreyer, Derek},
  URL = {https://hal.science/hal-01945446},
  JOURNAL = {{Journal of Functional Programming}},
  PUBLISHER = {{Cambridge University Press (CUP)}},
  VOLUME = {28},
  NUMBER = {e20},
  YEAR = {2018},
  DOI = {10.1017/S0956796818000151},
  PDF = {https://hal.science/hal-01945446/file/jung2018iris.pdf},
  HAL_ID = {hal-01945446},
  HAL_VERSION = {v1},
}

@inproceedings{10.1145/1926385.1926389,
author = {Lhot\'{a}k, Ondrej and Chung, Kwok-Chiang Andrew},
title = {Points-to Analysis with Efficient Strong Updates},
year = {2011},
isbn = {9781450304900},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1926385.1926389},
doi = {10.1145/1926385.1926389},
abstract = {This paper explores a sweet spot between flow-insensitive and flow-sensitive subset-based points-to analysis. Flow-insensitive analysis is efficient: it has been applied to million-line programs and even its worst-case requirements are quadratic space and cubic time. Flow-sensitive analysis is precise because it allows strong updates, so that points-to relationships holding in one program location can be removed from the analysis when they no longer hold in other locations. We propose a "Strong Update" analysis combining both features: it is efficient like flow-insensitive analysis, with the same worst-case bounds, yet its precision benefits from strong updates like flow-sensitive analysis. The key enabling insight is that strong updates are applicable when the dereferenced points-to set is a singleton, and a singleton set is cheap to analyze. The analysis therefore focuses flow sensitivity on singleton sets. Larger sets, which will not lead to strong updates, are modelled flow insensitively to maintain efficiency. We have implemented and evaluated the analysis as an extension of the standard flow-insensitive points-to analysis in the LLVM compiler infrastructure.},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {3–16},
numpages = {14},
keywords = {strong updates, andersen's analysis, flow sensitivity, points-to analysis, llvm},
location = {Austin, Texas, USA},
series = {POPL '11}
}

@article{10.1145/3158154,
author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
title = {RustBelt: Securing the Foundations of the Rust Programming Language},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158154},
doi = {10.1145/3158154},
abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {66},
numpages = {34},
keywords = {type systems, logical relations, concurrency, Rust, separation logic}
}

@inproceedings{10.1145/3519939.3523704,
author = {Matsushita, Yusuke and Denis, Xavier and Jourdan, Jacques-Henri and Dreyer, Derek},
title = {RustHornBelt: A Semantic Foundation for Functional Verification of Rust Programs with Unsafe Code},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523704},
doi = {10.1145/3519939.3523704},
abstract = {Rust is a systems programming language that offers both low-level memory operations and high-level safety guarantees, via a strong ownership type system that prohibits mutation of aliased state. In prior work, Matsushita et al. developed RustHorn, a promising technique for functional verification of Rust code: it leverages the strong invariants of Rust types to express the behavior of stateful Rust code with first-order logic (FOL) formulas, whose verification is amenable to off-the-shelf automated techniques. RustHorn’s key idea is to use prophecies to describe the behavior of mutable borrows. However, the soundness of RustHorn was only established for a safe subset of Rust, and it has remained unclear how to extend it to support various safe APIs that encapsulate unsafe code (i.e., code where Rust’s aliasing discipline is relaxed). In this paper, we present RustHornBelt, the first machine-checked proof of soundness for RustHorn-style verification which supports giving FOL specs to safe APIs implemented with unsafe code. RustHornBelt employs the approach of semantic typing used in Jung et al.’s RustBelt framework, but it extends RustBelt’s model to reason not only about safety but also functional correctness. The key challenge in RustHornBelt is to develop a semantic model of RustHorn-style prophecies, which we achieve via a new separation-logic mechanism we call parametric prophecies.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {841–856},
numpages = {16},
keywords = {prophecy variables, separation logic, Iris, Rust, type systems, verification},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

