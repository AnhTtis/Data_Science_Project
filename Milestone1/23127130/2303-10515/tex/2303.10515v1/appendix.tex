\section{Ownership constraints} \label{appendix:ownership}
The rules for the ownership monotonicity property, function body and function call, as well as
selected rules for modelling C library functions can be found in
\autoref{fig:selected-ownership-rules}.

{\bf MONOTONE.} When a new ownership variable is generated, \name generates a set of constraints meant to enforce the ownership monotonicity property as depicted by rule MONOTONE
in~\autoref{fig:selected-ownership-rules}.
In the rule, $V$ stands for the set of constraint variables, $C$ stands for the set of constraints, and $\Sigma$ stands for function signatures in terms of associated ownership variables.
According to the rule, if $p$ and $q$ are both access paths with base variable $v$ such that $p$ is a prefix of $q$, then the ownership of $p$ is
higher or equal to the ownership of $q$. For instance, \name generates the following for~\autoref{fig:llist-constr-rust}:
$\mathbb{O}_{\text{\lstinline{new_node}}}\ge\mathbb{O}_\text{\lstinline{(*new_node).next}}$.

For simpilicity, we only make $V$ or $\Sigma$ explicit in the rules if they are used. Also,
we assume that whenever a pointer is used, new variables are generated and MONOTONE
rule is applied. %

{\bf FREE.} When a pointer is passed to \lstinline{free}, we generate constraints that
assert that this pointer is owning prior to the call and non-owning after the call~\autoref{fig:selected-ownership-rules}.

{\bf FN-DECL.} The rule of generating constraints for function declarations is given as FN-DECL, where we consider a function ${\bf f}$
with output parameters ${\bf \vec{x}}$, normal parameters ${\bf \vec{y}}$, and function return ${\bf z}$.
This rule states that given current ownership variables $V$, constraints $C$ and function signature
$\Sigma$, the inference of the function declaration proceeds to generate ownership constraints
for statements in the function body with $V'$, $C'$, $\Sigma'$ updated accordingly.
For output parameter, we need to generate two sets of ownership variables, one on entry and one
on exit to represent its input/output ownership status, which we then constrain to be one.

{\bf FN-CALL.} The rule of calling a function is given as FN-CALL. As discussed in \autoref{sec:ownership-monotonicity},
we explicitly convert pointers \lstinline{p} to \lstinline{&mut (*p)} at output parameter positions.
Here we assume that all calling arguments of output parameters are in the form \lstinline{&mut p}.
The rule states that, for normal parameters, the ownership of arguments optionally may \emph{transfer}
to the parameters, as illustrated by the 3-variable constraints; for output parameter, the ownership 
of arguments gets \emph{borrowed} to the parameters: the entry/exit states of parameters are 
equated with pre/post states of arguments.

\begin{figure}
  \begin{mathpar}
    $\inferrule[MONOTONE]
    {p,q \in ap(v, 1, k)\\ \textit{is\_prefix}(p,q)\\ a = \textit{base\_var}(v)\\
    C'=C\cup\{\mathbb{O}_p {\geq} \mathbb{O}_{q}\}\\
    V'=V\cup\left\{\mathbb{O}_p\text{ new}\middle|p\in\textit{ap}\left(a, 1, k\right)\right\}
    }
    {V,C\vdash {\bf v}~\text{monotone}\Rightarrow V',C' }
    ~~~\inferrule[FREE]
    {
    C'=C\cup\{\mathbb{O}_v = 1\land \mathbb{O}_{v'} = 0\}}
    {C\vdash {\bf free(v)}\Rightarrow C'}
    \inferrule[FN-DECL]
      {\vec{v}\in\text{localVars}\left(\vec{\text{stmt}}\right)\\
      V' = V\cup\left\{\mathbb{O}_l\middle|l\in ap\left(\vec{x}_\text{entry}, 1, k\right)\cup ap\left(\vec{x}_\text{exit}, 1, k\right)\cup ap\left(\vec{y}, 1, k\right)\cup ap\left(z, 1, k\right)\right\}\\
      C' = C\cup\left\{\mathbb{O}_{\vec{x}}^\text{entry} = 1, \mathbb{O}_{\vec{x}}^\text{exit} = 1\right\}\cup\left\{\mathbb{O}_r = 0\middle| r\in ap\left(\vec{v}_\text{exit}, 1, k\right)\right\}\\
      \Sigma' = \Sigma\cup\{{\bf f}\left(\vec{{\bf x}};\vec{{\bf y}}\right):{\bf z}\}\\
      V',C',\Sigma'\vdash {\bf stmts} \Rightarrow V'',C''
      }
      {V,C,\Sigma\vdash{\bf f}\left(\vec{{\bf x}};\vec{{\bf y}}\right):{\bf z} \left\{\vec{\text{stmt}}\right\}\Rightarrow V'', C'',\Sigma'}
  \inferrule[FN-CALL]
    {
    f\left(\vec{x};\vec{y}\right):z \in \Sigma\\
    C' = C \cup \left\{\mathbb{O}_{r'} + \mathbb{O}_l = \mathbb{O}_r\middle| r \in ap\left(q, 1, k\right), l\in ap\left(y, 1, k\right), |r| - |q| = |l| - |y|\right\}\\
    \cup \left\{\mathbb{O}_{s} = \mathbb{O}_{n}, \mathbb{O}_{s'} = \mathbb{O}_{n'}\middle|s \in ap\left(p, 1, k\right), n\in ap\left(x, 2, k\right), |s| - |p| = |n| - |x| - 1\right\}\\
    \cup \left\{\mathbb{O}_t = 0 \land \mathbb{O}_{t'} = \mathbb{O}_m\middle|t\in ap\left(r, 1, k\right), m\in ap\left(z, 1, k\right), |t| - |r| = |m| - |z|\right\}}
    {C,\Sigma\vdash \text{\lstinline!let!}\ {\bf r}\ =\ {\bf f}\left(\text{\lstinline!&mut!}\ \vec{{\bf p}};\vec{{\bf q}}\right)\Rightarrow C'}
    $
  \end{mathpar}
  \caption{Selected ownership rules}
  \label{fig:selected-ownership-rules}
\end{figure}




\section{Proof of~\autoref{thm:monotonicity}}
\label{sec:proof-of-monotonicity}

  Let's consider a pointer assignment between $p$ and $q$.

  \noindent (i) If there is no ownership transfer, then the conclusion follows from the hypothesis.

  \noindent (ii) If ownership is transferred from $q$ to $p$, then $p'$ owns a new object after the assignment. For another pointer $l$ to own the same memory object after the assignment,
  $l$ must have been an alias of $p$ before the assignment. Let's now consider all possible access paths for $p$ and $l$:
 \begin{itemize}
 \item Both are accessed directly: $p = q$; $l$. In this case, $p'$ and $l'$ are no longer aliases after the assignment, meaning that they can't own the same object. 
 \item $p$ is accessed indirectly and $l$ directly: $*p=q$; $l$. If $*p$ aliases $l$, then, again, $*p'$ and $l'$ are no longer aliases after the assignment.
 \item Both are accessed indirectly: $*p=*q$; $*l$. In this case, we also need to consider the potential aliasing between $p$ and $l$.
   \begin{itemize}
   \item If $*p$ aliases $*l$, but $p$ does not alias $l$, then, again, $*p'$ and $*l'$ are no longer aliases after the assignment.  
   \item If $*p$ aliases $*l$ and $p$ aliases $l$, then, $*p'$ and $*l'$ are aliases after the assignment. Now,
   in order to check whether they can both be owning, let's look
   at the ownership constraints. We know that $*p'$ is owning, meaning that $\mathbb{O}_{*p'}=1$.
   By ownership monotonicity, we have that $\mathbb{O}_{p'}=1$. Given that $p'$ aliases $l'$, we know from the hypothesis that $l'$ can't own the same object, hence $\mathbb{O}_{l'}=0$.
   From ownership monotonicity we have $\mathbb{O}_{*l'} = 0$. Hence, $*l'$ can't be owning
   \end{itemize}
\item  Longer access paths follow the same proof as when $p$ is accessed indirectly above as it is sufficient to only look at the last indirection on the access path.
 \end{itemize}  






\section{Proof of~\autoref{thm:transfer}}
\label{sec:proof-of-transfer}
\begin{proof}
  Let $a = \textit{base\_var}(v)$, $b = \textit{base\_var}(w)$.
  Suppose that $p\in\textit{ap}\left(a, |v|, k\right)$, $q\in\textit{ap}\left(b, |w|, k\right)$
  and additionally $|p| - |v| = |q| - |w|$. By rule ASSIGN, we have
  $\mathbb{O}_p = 0\land \mathbb{O}_{p'} + \mathbb{O}_{q'} = \mathbb{O}_{q}$. By rule MONOTONICITY,
  we have $\mathbb{O}_{w'} \ge \mathbb{O}_{q'}$. By the hypothesis, ownership transfers from
  $w$ to $v$, hence $\mathbb{O}_{w'} = 0$, which implies $\mathbb{O}_{q'} = 0$ and that
  $\mathbb{O}_{p'} = \mathbb{O}_q$. This means that if $q$ has ownership before the assignment, it will then be transferred to $p$.
  
\end{proof}




\section{Proof of \autoref{thm:ownership}} \label{appendix:thm-proof}
\begin{proof}

    Our proof consists of two parts:
    
    (1) The constraint solving is in NP. We show this by reducing it to SAT in polynomial time. In particular, each equality can be translated as follows:
    \begin{itemize}
    \item $x + y = z$ is translated to $(z \wedge x \wedge \neg y) \vee (z \wedge \neg x \wedge y) \vee (\neg z \wedge \neg x \wedge \neg y)$, whose CNF is
        $(z \vee y \vee \neg x) \wedge (x \vee  \neg y) \wedge (z \vee x \vee \neg y) \wedge (\neg y \vee \neg z) \wedge (x \vee \neg z) \wedge (x \vee y \vee \neg z)$.
    \item $x = 1$ is translated to $x$.
    \item $x = 0$ is translated to $\neg x$.      
    \item $x {\leq} y$ is translated to $(\neg x \wedge \neg y) \vee (x \wedge \neg y) \vee (x \wedge y)$  
    \end{itemize}
    
    
    (2) The constraint solving is NP-hard. We show this by reducing the EXACT-1-3-SAT problem to ownership constraint solving in polynomial time.
    EXACT-1-3-SAT is the problem of determining if there exists an interpretation that satisfies a given Boolean formula consisting of conjunctions of 3-literal clauses,
    with the extra restriction that exactly one literal is true per clause.
    
    We next describe how we construct the ownership constraint system.
    For each clause $l_1 \vee l_2 \vee l_3$, we generate three equalities in our constraint system: $l_1 + l_2 = not\_l_3$, $l_3 + not\_l_3 = l_4$ and $l_4 = 1$,
    where $not\_l_3$ and $l_4$ are fresh variables.
    Then, the original problem is satisfiable iff the ownership constraint system has a solution.
    Note that the only satisfiable configurations for a clause $l_1 \vee l_2 \vee l_3$ are (1, 0, 0), (0, 1, 0), (0, 0, 1), which are exactly the same as for $l_1 + l_2 = not\_l_3$, $l_3 + not\_l_3 = l_4$ and $l_4 = 1$, where, additionally, $not\_l_3 = \neg l_3$ and $l_4 = 1$. 
    Also, we know that each ownership variable has either value 0 or 1.
    \end{proof}
