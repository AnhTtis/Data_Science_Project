\section{Introduction} \label{sec:intro}




Rust~\cite{matsakis2014rust} is a modern programming language which features an exciting combination of
memory safety and low-level control. 
In particular, Rust takes inspiration from ownership and substructural (mostly affine and linear) types and 
 restricts certain memory accesses to their \emph{owners}. This means  that 
 although multiple pointers to the resource can co-exist (through a mechanism known as \emph{borrowing}), 
 certain operations can only be performed by the owner.
The Rust compiler is able to statically verify the ownership constraints and consequently guarantee memory and thread safety.
This distinctive advantage of provable safety makes Rust a very popular language, and the prospect of migrating 
legacy codebases in C to Rust is very appealing. 


In response to this demand, automated tools translating C code to Rust emerge from 
both industry and academia~\cite{c2rust,DBLP:journals/pacmpl/EmreSDH21,CRustS}.
Among them, the industrial strength translator C2Rust~\cite{c2rust} rewrites C code into the Rust syntax 
while preserving the original semantics. The translation does not synthesise an ownership model and 
thus is not able to do more than replicating the unsafe use of pointers in C. And consequently, the Rust code must be labelled 
with the \lstinline{unsafe} keyword which allows certain actions that are not checked by the compiler. %
More recent work focuses on reducing this unsafe labelling. In particular, the tool Laertes~\cite{DBLP:journals/pacmpl/EmreSDH21} aims to 
rewrite the (unsafe) code produced by C2Rust by searching the solution space guided by the type error messages from the Rust compiler. 
This is ground breaking, as for the first time proper Rust code beyond a line-by-line direct 
conversion from the original C source may be synthesised. 
On the other hand, the limit of the trial-and-error approach is also clear: the system does not
support the reasoning of the generation process, nor create any new understanding of the target code (other than the obvious fact that it
compiles successfully). 



In this paper, we take a more principled approach by developing a novel ownership analysis of pointers that is efficient (scaling to large programs (half a million LOC in less than 10 seconds)),
sophisticated (handling nested pointers and inductively-defined data structures), and precise (being field and flow sensitive).
Our ownership analysis is both scalable and precise owing to a strengthening assumption we make about the Rust ownership model, which obviates
the need for an aliasing analysis.

The primary goal of this analysis is of course to facilitate C to Rust translation. Indeed, as we will see 
in the rest of the paper, an automated translation system is built to encode the ownership models in the generated Rust code which is then proven safe by the Rust compiler. 
But there is more. In contrast to trying the Rust compiler as common in existing approaches~\cite{DBLP:journals/pacmpl/EmreSDH21,CRustS}, this analysis approach 
actually extracts new knowledge of ownership from code, which may lead to a range of utilities including preventing memory leaks, identifying 
inherently unsafe code fragments, detecting memory bugs, and so on. Specifically, in this paper we 
\begin{itemize}
\item design a scalable and precise ownership analysis 
  that is able to handle complex inductively-defined data structures and nested pointers. (Section~\ref{sec:ownership})
\item develop a refactoring mechanism for Rust leveraging ownership analyses to enhance code safety. (Section~\ref{sec:translation})
\item implement a prototype tool (\name, standing for C to Rust OWNership guided translation) that translates C code into Rust with enhanced safety. (Section~\ref{sec:discussion})
\item evaluate \name with a benchmark suite including commonly used data structure libraries and real-world projects (ranging from 150 to half a million LOC) and compare the result with the state-of-the-art. (Section~\ref{sec:experiments})
\end{itemize}












