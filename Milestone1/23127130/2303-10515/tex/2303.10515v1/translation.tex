\section{C to Rust Translation} \label{sec:translation}
\name uses the results of the ownership, mutability and fatness analyses
to perform the actual translation, which consists of retyping pointers (section~\ref{sec:pointer-retype})
and rewriting pointer uses (section~\ref{sec:pointer-rewrite}).



\subsection{Retyping pointers} \label{sec:pointer-retype}

As mentioned in section~\ref{sec:backgroud-pointers}, we do not attempt to translate array pointers to safe pointers.
In the rest of the section, we focus on mutable, non-array pointers.

The translation requires a global view of pointers' ownership, whereas
information inferred by the ownership analysis refers to individual program locations.
For the purpose of translation, given that we refactor owning pointers into box pointers,
a pointer is considered (globally) owning if it owns a memory object at any program location within its scope.
Otherwise, it is (globally) non-owning.
When retyping pointer fields of structs, we must consider the scope of the struct declaration, which
generally transcends the whole program. Within this scope, each field is usually accessed
from several base variables, which must all be taken into consideration. For instance, given the
\lstinline{List} declaration in figure~\ref{fig:llist-constr-rust} and two variables \lstinline{l1}
and \lstinline{l2} of type \lstinline{*mut List}.
Then, in order to determine the ownership status of field \lstinline{next}, we have to consider all the access paths to \lstinline{next} originating from both base variables
\lstinline{l1} and \lstinline{l2}.


The next table shows the retyping rules for mutable, non-array pointers, where we wrap safe pointer types into \lstinline{Option} to account for null pointer values:
\begin{center}
    \begin{tabular}{ |c|c| } 
    \hline
     & Non-array pointers \\
    \hline
    Owning & \optionboxptr{T} \\
    \hline
    Non-owning &  \rawmut{T} or \optionmutref{T} \\ %
    \hline
    \end{tabular}
\end{center}



The non-owning pointers that are kept as raw pointers \rawmut{T} correspond to 
mutable local borrows. For \name to soundly translate to mutable local borrows, it would have to reason about lifetime information.
Given that in Rust there can't be two mutable references to a value, \name would have to check
that there is no overlap between the lifetimes of different mutable references to the same object. 
In this work, we chose not to do this and instead leave it as a future work (as also mentioned under limitations in section~\ref{sec:discussion}).
Notably, this restriction does not apply to output parameters, for which we translate to mutable references.
This already covers the majority of mutable references -- Das observed that, in C code, most references arise because the address of a variable is passed as a
parameter~\cite{10.1145/349299.349309}. Notably, the lack of a lifetime analysis means that we also can't handle immutable local borrows, hence our translation's focus on
mutable pointers.


\subsection{Rewriting pointer uses}\label{sec:pointer-rewrite}

The rewrite of a pointer expression depends on its new type and the context in which it is used.
For example, when rewriting \lstinline{q} in \lstinline{p = q}, the context will depend on the new
type of \lstinline{p}. Based on this new type, we can have four contexts: $\textsf{BoxCtxt}$ which requires \boxptr pointers, 
	$\textsf{MutCtxt}$ which requires \mutref references, $\textsf{ConstCtxt}$ which requires \constref references, and
    $\textsf{RawCtxt}$ which requires raw pointers.
For example, if \lstinline{p} above is a \boxptr pointer, then we rewrite \lstinline{q} in a $\textsf{BoxCtxt}$.

Then, the rewrite takes place according to the following table, where columns correspond to the new type of the pointer to be rewritten, and rows represent possible contexts
\footnote{The cell marked as $\bot$ is not applicable due to our treatment of output parameter.}.

\begin{centering}
  \begin{tabular}{ |c|c|c|c| } 
    \hline
     & \optionboxptr{T} & \optionmutref{T} & \rawmut{T} \\
    \hline
    \textsf{BoxCtxt} & \lstinline[]$p.take()$ & $\bot$ & \lstinline[]$Some(Box::from_raw(p))$ \\
    \hline
    \textsf{MutCtxt} & \lstinline[]$p.as_deref_mut()$ & \lstinline[]$p.as_deref_mut()$ &  \lstinline[]$p.as_mut()$ \\
    \hline
    \textsf{ConstCtxt} & \lstinline[]$p.as_deref()$ & \lstinline[]$p.as_deref()$ &  \lstinline[]$p.as_ref()$ \\
    \hline
    \textsf{RawCtxt} & \lstinline[]$to_raw(&mut p)$ & \lstinline[]$to_raw(&mut p)$ &  \lstinline[]$p$ \\
    \hline
  \end{tabular}
\end{centering}





Our translation uses functions from the Rust standard library, as follows:
\begin{enumerate}
    \item When \lstinline{Option<Box<T>>} is passed to a $\textsf{BoxCtxt}$, we expect a move, and consequently we use 
    \lstinline{take} to replace the value inside the option with None;
    \item We use \lstinline{as_deref} and \lstinline{as_deref_mut} in order to not 
    consume the original option, and we create new options with references to the original ones;
    \item \lstinline{as_mut} and \lstinline{as_ref} converts raw pointers to references;
    \item \lstinline{Box::from_raw} converts raw pointers into \boxptr pointers.
\end{enumerate}

We also define the helper function \lstinline{to_raw} that transform safe pointers into raw pointers:
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
    fn to_raw<T>(b: &mut Option<Box<T>>) -> *mut T {
        b.as_deref_mut().map(|b| b as *mut T).unwrap_or(null_mut())
    }
\end{lstlisting}
Here, we explain \lstinline{to_raw} for a \boxptr argument (the explanation for \mutref is the
same because of the polymorphic nature of \lstinline{as_deref_mut}): 
\begin{enumerate}
    \item To convert \lstinline{Option<Box<T>>}, we first mutably borrow the entire option as denoted 
    by the mutable borrow argument of the helper function. This is needed because \lstinline{Option} is
    not copyable, and it would be otherwise consumed;
    \item \lstinline{as_deref_mut} converts \lstinline{&mut Option<Box<T>>} to \lstinline{Option<&mut T>};
    \item \lstinline{map} converts the optional part of the reference
    into an option of raw pointers;
    \item Finally, \lstinline{unwrap_or} returns the \lstinline{Some} value of
    the option, or a null pointer \lstinline{std::ptr::null_mut()} if the value is \lstinline{None}.
\end{enumerate}





\emph{Dereferences:} When a pointer \lstinline{p} is dereferenced as part of a larger expression (e.g. \lstinline{(*p).next}),
we need an additional \lstinline{unwrap()}.

\emph{Box pointers check:} Rust disallows the use of \lstinline{Box} pointers after they lost their ownership.
As this rule cannot be captured by the ownership analysis, such situations are detected at translation stage,
and the culpable \lstinline{Box} pointers are reverted back to raw pointers.

For brevity, we omitted the slightly different treatment of struct fields that are not of pointer type. 

























