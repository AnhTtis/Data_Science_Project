\section{Ownership Analysis} \label{sec:ownership}





The goal of our ownership analysis %
is to compute an ownership scheme for a given program that obeys the Rust ownership model, if such a scheme exists.
The ownership scheme contains information about whether pointers in the program are owning or non-owning at particular program locations.
At a high-level, our analysis works by generating a set of ownership constraints (section~\ref{sec:constraint-generation}),
which are then solved by a SAT solver (section~\ref{sec:constraint-solving}). A satisfying assignment for the
ownership constraints is an ownership scheme that obeys the Rust semantics.


Our ownership analysis is flow and field sensitive, where the latter enables inferring ownership information for pointer struct fields.
To satisfy field sensitivity, we track ownership information for \emph{access paths}~\cite{10.1007/978-3-642-31057-7_29,
10.1145/349299.349311,7372049}. 
Access paths represent a memory location by the way it is accessed from an initial, base variable,
and comprise of the base variable and a sequence of
field selection operators. %
For the program~\autoref{fig:llist-constr-rust}, some example access paths are \lstinline{new_node} (consists only of the base variable),
\lstinline{(*new_node).next}, and \lstinline{(*list).head}.
Our analysis associates an ownership variable with each access path, e.g. \lstinline{p} has associated ownership variable $\mathbb{O}_{p}$,
and  \lstinline{(*p).next} has associated ownership variable $\mathbb{O}_{(*p).next}$.
Each ownership variable can take value 1 if the corresponding access path is owning, or 0 if it is non-owning.
By ownership of an access path we mean the ownership of the field (or, more generally, pointer) accessed last through the access path,
e.g. the ownership of \lstinline{(*new_node).next} refers to the ownership of field \lstinline{next}.



\subsection{Ownership and aliasing} \label{sec:ownership-challenges}
One of the main challenges of designing an ownership analysis is the interaction between ownership and aliasing. To understand the problem, let us consider the pointer assignment at line 3 in the code listing below. We assume that the lines before the assignment allow inferring that \lstinline{q}, \lstinline{(*q).next} and \lstinline{r} are owning, whereas \lstinline{p} and \lstinline{(*p).next} are non-owning. Additionally, we assume that the lines after the assignment require \lstinline{(*p).next} to be owning (e.g. \lstinline{(*p).next} is being explicitly freed). From this, an ownership analysis
could reasonably conclude that ownership transfer happens at line 3 (such that \lstinline{(*p).next} becomes owning), and the inferred ownership scheme obeys the Rust semantics.
\begin{lstlisting}[language=rust, mathescape=true]
  let p, r, q : *mut Node;
  // p and (*p).next non-owning; q, (*q).next and r owning
  (*p).next = r; 
  // (*p).next must have ownership
\end{lstlisting}
Let's now also consider aliasing. A possible assumption is that, just before line 3,  \lstinline{p} and \lstinline{q} alias, meaning that \lstinline{(*p).next} and \lstinline{(*q).next} also alias.
Then, after line 3, \lstinline{(*p).next} and \lstinline{(*q).next} will still alias (pointing to the same memory object). However, according to the ownership scheme
above, both \lstinline{(*p).next} and \lstinline{(*q).next} are owning, which is not allowed in Rust, where a memory object must have a unique owner. This discrepancy was not detected by the ownership analysis mimicked above.
The issue is that the ownership analysis ignored aliasing. Indeed, ownership should not be transferred to \lstinline{(*p).next} if there exists an owning alias that, after the ownership transfer,
continues to point to the same memory object as \lstinline{(*p).next}. 




Precise aliasing information is very difficult to compute, especially in the presence of inductively defined data structures.
In the current paper, we alleviate the need to check aliasing by making a strengthening assumption about the Rust ownership model: we restrict the way in which pointers can acquire ownership along an access path, thus limiting the interaction between ownership and aliasing.
In particular, we introduce a novel concept of \emph{ownership monotonicity}.
This property states that, along an access path, the ownership values of pointers can only decrease (see definition~\ref{def:monotonicity}, where $is\_prefix(p, q)$ returns true if access path $p$ is a prefix of $q$, and false otherwise -- e.g. $is\_prefix(p, (*p).next) = true$).
Going back to our example, the ownership monotonicity implies that, for access path \lstinline{(*p).next} we have $\mathbb{O}_{p} \ge \mathbb{O}_{(*p).next}$,
and for access path \lstinline{(*q).next} we have $\mathbb{O}_{q} \ge \mathbb{O}_{(*q).next}$.
This means that, if \lstinline{(*p).next} is allowed to take ownership, then \lstinline{p} must already be owning. Consequently, all aliases
of \lstinline{p} must be non-owning, which means that all aliases of \lstinline{(*p).next}, including \lstinline{(*q).next}, are non-owning.
\begin{definition}[Ownership monotonicity] \label{def:monotonicity}
  Given two access paths $p$ and $q$, if $is\_prefix(p, q)$, then $\mathbb{O}_{p} \geq \mathbb{O}_q$.
\end{definition}  
Ownership monotonicity is stricter than the Rust semantics, causing our analysis to potentially reject some ownership schemes that would otherwise be accepted by the
Rust compiler. We will come back to this point later in the section.
















\subsection{Generation of ownership constraints} \label{sec:constraint-generation}

During constraint generation, we assume a given $k$ denoting the length of the longest access path used in the code.
This enables us to capture the ownership of all the access paths exposed in the code. Later in this section, we will discuss the handling of loops, which may expose longer access paths.


Next, we denote by $\mathcal{P}$ the set of all access paths in a program, $base\_var(p)$ returns the base variable of access path $p$,
and $|p|$ computes the length of the access path $p$ in terms of applied field selection operators from the base variable.
For illustration, $base\_var((*p).next) = p$, $base\_var(p) = p$, %
$|p| = 1$ and $|(*p).next| = 2$.
Then, we define $ap(v,lb, ub)$ to return the set of access paths with base variable $v$ and length in between lower bound $lb$ and upper bound $ub$:
  $ap(v, lb, ub) =  \left\{p \in \mathcal{P} \middle| base\_var(p) = v\land lb \le |p| \le ub\right\}$.
For illustration, we have 
$ap(new\_node, 1, 2) =  \left\{new\_node, (*new\_node).next\right\}$.


\vspace{-.5cm}
\begin{figure}
\begin{mathpar}
$
\inferrule[ASSIGN]
  {a = base\_var(v), ~~b=base\_var(w),\\
  p \in ap(a, |v|, k),~~ q \in ap(b,|w|, k), ~~r\in ap(a, 1, |v|{-}1), ~~s \in ap(b, 1, |w|{-}1)\\
  |p|-|v|=|q|-|w|, |r|=|s|\\
  C' = C \cup \{\mathbb{O}_{p}=0 \land \mathbb{O}_{p'}+\mathbb{O}_{q'}=\mathbb{O}_{q~} \land  \mathbb{O}_{r'}=\mathbb{O}_{r} \land \mathbb{O}_{s'}=\mathbb{O}_{s} \}}
  {C\vdash {\bf v = w;}\Rightarrow C'} 
$
\end{mathpar}
\vspace{-.5cm}
\caption{Ownership constraint generation for assignment}
\label{fig:ownership-rules}
\end{figure}
\vspace{-.5cm}



{\bf Ownership transfer.}
The program instructions where ownership transfer can happen are (pointer) assignment and function call. Here we discuss assignment and, due to space constraints, we leave the rules for interprocedural ownership analysis in Appendix~\ref{appendix:ownership}.
Our rule for ownership transfer at assignment site follows Rust's \boxptr semantics: when a \boxptr pointer is moved, the object it points to is moved as well.
For instance, in the following Rust pseudocode snippet:
\begin{lstlisting}
let p,q: Box<Box<i32>>;
let p = q; // ownership transfer occurs
// the use of q and *q is disallowed
\end{lstlisting}
when ownership is transferred from \lstinline{q} to \lstinline{p}, \lstinline{*q} also loses ownership.
Except for reassignment, the use of a \lstinline{Box} pointer after it lost its ownership is disallowed, hence the use of \lstinline{q} or \lstinline{*q} is forbidden at line 3.

Consequently, we enforce the following \emph{ownership transfer rule}: if ownership transfer happens for a pointer variable (e.g. \lstinline{p} and \lstinline{q} in the example), then it must happen for all pointers reachable   from that pointer (e.g. \lstinline{*p} and \lstinline{*q}). %
The ownership of pointer variables from which the pointer under discussion is reachable remains the same (e.g. if ownership transfer happens for some assignment \lstinline{*p = *q} in the code, then \lstinline{q} and
\lstinline{p} retain their respective previous ownership values).







\emph{Possible ownership transfer at pointer assignment:} The ownership transfer rule at pointer assignment site is captured by rule ASSIGN in~\autoref{fig:ownership-rules}.
The judgement $C\vdash {\bf v = w;}\Rightarrow C'$ denotes the fact that the assignment is analysed under the set of constraints $C$, and generates $C'$.
We use prime notation to denote variables after the assignment.
Given pointer assignment $v=w$, $p$ and $q$ represent all the access paths respectively starting from $v$ and $w$, whereas
$r$ and $s$ denote the access paths from the base variables of $v$ and $w$ that reach $v$ and $w$, respectively.
Then, equality $\mathbb{O}_{p'} + \mathbb{O}_{q'}=\mathbb{O}_{q}$ captures the possibility of ownership transfer for all access paths originating at $v$ and $w$:
(i) If transfer happens then the ownership of $q$ transfers to $p'$ ($\mathbb{O}_{p'}=\mathbb{O}_{q}$ and $\mathbb{O}_{q'}=0$).
(ii) Otherwise, the ownership values are left unchanged ($\mathbb{O}_{p'}=\mathbb{O}_{p}$ and $\mathbb{O}_{q'}=\mathbb{O}_{q}$).
The last two equalities, $ \mathbb{O}_{r'}=\mathbb{O}_{r} \land \mathbb{O}_{s'}=\mathbb{O}_{s}$, denote the fact that, for both (i) and (ii),
pointers on access paths $r$ and $s$ retain their previous ownership.

\emph{C memory leaks:} In the ASSIGN rule, we add constraint $\mathbb{O}_{p}=0$ to $C'$ in order to force $p$ to be non-owning before the assignment. Conversely, having $p$ owning before being reassigned via the assignment under analysis
signals a memory leak in the original C program. Given that in Rust memory is automatically returned, allowing the translation to happen would change the semantics of the original  
program by fixing the memory leak. Instead, our design choice is to disallow the ownership analysis from generating such a solution.

\emph{Simultaneous ownership transfer along an access path:} One may observe that the constraints generated by ASSIGN do not fully capture the stated ownership transfer rule. In particular,
they do not ensure that, whenever ownership transfer occurs from $w$ to $v$, it also transfers for all pointers on all access paths $p$ and $q$. Instead, this is implicitly guaranteed by the
ownership monotonicity rule, as stated in theorem~\ref{thm:transfer}.

\begin{theorem}[Ownership transfer]
  \label{thm:transfer}
  If ownership is transferred from $w$ to $v$, then, by the ASSIGN rule and ownership monotonicity,
  ownership also transfers between corresponding pointers on all access paths $p$ and $q$: $\mathbb{O}_{p'} =\mathbb{O}_{q}$ and $\mathbb{O}_{q'}=0$.  (proof in Appendix~\ref{sec:proof-of-transfer})
\end{theorem}


\emph{Ownership and aliasing:} We saw in section~\ref{sec:ownership-challenges} that aliasing may cause situations in which, after ownership transfer, the same memory object
has more than one owner. Theorem~\ref{thm:monotonicity} states that this is not possible under ownership monotonicity.

\begin{theorem}[Soundness of ASSIGN under ownership monotonicity] \label{thm:monotonicity}
  Under ownership monotonicity, if all allocated memory objects have a unique owner before the application of ASSIGN, then they will also have a unique owner after ASSIGN. (proof in Appendix~\ref{sec:proof-of-monotonicity})
\end{theorem}

Intuitively, theorem~\ref{thm:monotonicity} enables a pointer to acquire ownership without having to consider aliases: after ownership transfer, this pointer will be the unique owner.
The idea resembles that of strong updatess~\cite{10.1145/1926385.1926389}.

\emph{Additional access paths:} As a remark, it is possible for $v$ and $w$ to be accessible from other base variables in the program. 
In such cases, given that those access paths are not explicitly mentioned at the location of the ownership transfer, we do not generate new ownership variables for them.
Consequently, their current ownership variables are left unchanged by default.


{\bf Ownership transfer example.} To illustrate the ASSIGN rule, we use the singly-linked list example below, where we assume that \lstinline{p}, \lstinline{q} are both of
type \lstinline{*mut Node}. Therefore, we will have to consider the following four access path
\lstinline{p, q, (*p).next, (*q).next}.
In SSA-style, at each line in the example, we generate new ownership variables (by incrementing their subscript) for the access paths mentioned at that line.
For the first assignment, ownership transfer can happen between $p$ and $q$, and $(*p).next$ and $(*q).next$, respectively.
For the second assignment, ownership can be transferred between $(*p).next$ and $(*q).next$, while
$p$ and $q$ must retain their previous ownership.


\begin{lstlisting}[language=rust, mathescape=true]
p = q;    // $\mathbb{O}_{p_1} = 0 \land \mathbb{O}_{p_2} + \mathbb{O}_{q_2} = \mathbb{O}_{q_1}~\land$
          // $\mathbb{O}_{(*p_1).next} = 0 \land \mathbb{O}_{(*p_2).next} + \mathbb{O}_{(*q_2).next} = \mathbb{O}_{(*q_1).next}$
(*p).next = (*q).next;
          // $\mathbb{O}_{p_3} = \mathbb{O}_{p_2} \land \mathbb{O}_{q_3} = \mathbb{O}_{q_2}~\land$
          // $\mathbb{O}_{(*p_2).next} = 0 \land \mathbb{O}_{(*p_3).next} + \mathbb{O}_{(*q_3).next} = \mathbb{O}_{(*q_2).next}$

          
\end{lstlisting}


         


Besides generating ownership constraints for assignments, we must model
the ownership information for commonly used C standard function like \lstinline{malloc},
\lstinline{calloc}, \lstinline{realloc}, \lstinline{free}, \lstinline{strcmp}, \lstinline{memset}, etc..
Due to space constraints, more details about these, as well as the rules for ownership monotonicity and interprocedural ownership analysis are provided in Appendix~\ref{appendix:ownership}.




{\bf Handling conditionals and loops.}
As mentioned in section~\ref{sec:overview-loop}, we only analyse the body of loops once as it is sufficient to expose  all the required ownership variables.
For inductively defined data structures, while further unrolling of loop bodies increases the length of access paths, it does not expose
any new struct fields (struct fields do not change ownership between loop iterations).

To handle join points of control paths, we apply a variant of the SSA  construction algorithm~\cite{10.5555/295545.295551},
where different paths are merged via $\phi$ nodes. The value of each ownership variable must be the same
on all joined paths, or otherwise the analysis fails. %




\subsection{Solving ownership constraints} \label{sec:constraint-solving}

The ownership constraint system consists of a set of 3-variable linear constraints of the form $O_v = O_w + O_u$, and
1-variable equality constraints $O_v=0$ and $O_v=1$. %

\begin{definition}[Ownership constraint system]
An \emph{ownership constraint system} $(P, \Delta, \Sigma, \Sigma_{\neg})$ consists of a set of ownership 
variables $P$ that can have either value 0 or 1, %
a set of 3-variable equality constraints $\Delta \subseteq P \times P \times P$, and two sets of 1-variable equality 
constraints, $\Sigma, \Sigma_{\neg} \subseteq P$.
The equalities in $\Sigma$ are of the form $x=1$, whereas the equalities in $\Sigma_{\neg}$ are of the form $x=0$.%
\end{definition}



\begin{theorem}[Complexity of the ownership constraint solving]\label{thm:ownership}
The ownership constraint solving is NP-complete.  (proof in Appendix~\ref{appendix:thm-proof})
\end{theorem}


We solve the ownership constraints by calling a SAT solver. 
The ownership constraints may have no solution. This happens when there is no ownership scheme that obeys the Rust ownership model and the ownership monotonicity property (which is stricter than the Rust model for some cases), or the original C program has a memory leak.

Due to the complex Rust semantics, we do not formally prove that a satisfying assignment obeys the Rust ownership model. Instead, this check is performed
after the translation by running the Rust compiler.




\subsection{Discussion on ownership monotonicity} \label{sec:ownership-monotonicity}

As mentioned earlier in section~\ref{sec:ownership-monotonicity}, ownership monotonicity is stricter than the Rust semantics, causing our analysis to potentially reject some ownership schemes that would otherwise be accepted by the Rust compiler. The most significant such scenario that we identified is that of \emph{reference output parameter}. This denotes a function
parameter passed as a reference, which acts as an output as it can be accessed from outside the function (e.g. \lstinline{list} in figure~\ref{fig:llist-constr-c}).
For such parameters, the base variable is non-owning (as it is a reference) and mutable, whereas 
the pointers reachable from it may be owning (see example in figure~\ref{fig:llist-constr-crown}, where \lstinline{(*node).head}
gets assigned a pointer to a  newly allocated node). 
We detect such situations and explicitly enable them. In particular, we explicitly convert owning pointers \lstinline{p} to \lstinline{&mut(*p)} at the translation stage.

