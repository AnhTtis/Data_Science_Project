\section{Related Works}
{\bf Ownership analysis.} The concept of ownership itself is not new. 
In OO programming, ownership type systems are used to enable controlled aliasing by
restricting object graphs 
underlying the runtime heap of object-oriented programs~\cite{KULeuven-2-1630873, 10.1145/286936.286947}.
Efforts have been made in the automatic inference of ownership types~\cite{10.1145/582419.582448,10.1145/3485522,10.1145/604131.604156},
and applications of ownership types for memory management
~\cite{10.1145/781131.781168,ZHAO2008213}. Similarly, the concept of ownership has also been applied to analyse \texttt{C/C++} programs. 
Heine et al.~\cite{DBLP:conf/pldi/HeineL03} inferred pointer ownership type for memory leak
detection. Their encoding of ownership transfer constraints greatly influenced us.
Ravitch et al. \cite{pldi09} apply static analysis to infer ownership for automatic library
binding generation. Our notion of output parameter is inspired by this work.
Giving the different application domains, each of these work makes different
assumptions. 
Heine et al.~\cite{DBLP:conf/pldi/HeineL03} assumes that indirectly-accessed pointers cannot acquire ownership, whereas 
Ravitch et al. \cite{pldi09} assumes that all struct fields are owning unless
explicitly annotated. Our analysis is free from these assumptions, which 
leads to a more precise analysis necessary for synthesising correct Rust code.   
Lastly, the idea of ownership is also broadly applied in concurrent separation logic~\cite{10.1016/j.tcs.2006.12.034,10.1016/j.entcs.2006.04.008,
10.1109/LICS.2007.30,10.1145/1480881.1480922,10.1145/1122971.1122992}.
The Iris framework~\cite{jung:hal-01945446} is also applied to formalise the Rust type 
system~\cite{10.1145/3158154} and verifying Rust programs~\cite{10.1145/3519939.3523704}.



{\bf Type qualifiers.} Type qualifiers are a lightweight, practical mechanism for 
specifying and checking properties not captured by traditional type systems. A general
flow-insensitive type qualifier framework has been proposed \cite{10.1145/1186632.1186635},
with subsequent applications analysing \texttt{Java} reference 
mutability~\cite{10.1145/1297027.1297051,10.1145/2384616.2384680} and \texttt{C} array bounds~\cite{10.1145/3527322}. 
Our mutability and fatness analyses of \name are greatly influenced by these work.

{\bf C to Rust Translation.} 
We have already discussed \crust~\cite{c2rust}, which is an industrial strength tool that converts C to Rust syntax. \crust does not attempt to fix unsafe features such as raw pointers and the programs it generates are always annotated as unsafe. Nevertheless it forms the bases of other translation efforts. CRustS~\cite{CRustS} applies AST-based code transformations
to remove superfluous unsafe labelling generated by \crust. But it does not 
fix the unsafe features either. Laertes~\cite{DBLP:journals/pacmpl/EmreSDH21}
is the first tool that is actually able to automatically reduce the presence of unsafe code. 
It uses the Rust compiler as a blackbox oracle and search for code changes that 
remove raw pointers, which is very different from \name in approach (see Section~\ref{sec:experiments} for an experimental comparison).
















