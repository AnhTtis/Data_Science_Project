\section{Challenges of Handling Real-World Code} \label{sec:discussion}
We designed \name to be able to analyse and translate real-world code,
which poses significant challenges. In this section, we discuss some of the engineering challenges of \name and its current limitations. 

\subsection{Preprocessing}
During the transpilation of  C libraries,  \crust treats each file as a separate compilation
unit, which gets translated into a separate Rust module. Consequently, struct
definitions are duplicated, and available function definitions are put in \lstinline{extern} blocks~\cite{DBLP:journals/pacmpl/EmreSDH21}. 
We apply a preprocessing step similar to the resolve-imports tool of Laertes~\cite{DBLP:journals/pacmpl/EmreSDH21} that links
those definitions across files.


\subsection{Limitations of the ownership analysis}
There are a few C constructs and idioms that are not fully supported by our implementation, for which \name generates partial ownership constraints.
\name's translation will attempt to rewrite a variable as long as there exists a constraint involving it. 
As a result, the translation is in theory neither \emph{sound} nor \emph{complete}: it may generate code that does not compile (though we have not observed this in practice~(see Section \ref{sec:experiments})) and it may leave some pointers as raw pointers resulting in a less than optimal translation. 
We list below the cases when such a scenario may happen. \vspace{-0.2cm}

\paragraph{Certain unsafe C constructs.} %
  For type casts, we only generate ownership transfer constraints for head pointers;
for unions we assume that they contain no pointer fields and consequently, we generate no constraints; similarly, we generate no constraints for variadic arguments.
We noticed that unions and variadic arguments may 
cause our tool to crash (e.g. three of the benchmarks in \cite{DBLP:journals/pacmpl/EmreSDH21},
as mentioned in Section \ref{sec:experiments}). Those crashes happen when analysing access paths
that contain dereferences of union fields (where we assumed no pointer fields), and when analysing calls to functions with variadic arguments where a pointer is passed as argument.\vspace{-0.2cm}
\paragraph{Function pointers.} \name does not generate any constraints for them. \vspace{-0.2cm}

\paragraph{Non-standard memory management in C libraries.} Certain C libraries %
wrap \lstinline{malloc} and \lstinline{free}, often with static function pointers (pointers to allocator/deallocator are stored in static variables),
or function pointers in structs. \name does not generate any constraints in such scenarios. %
In C, it is also possible to use \lstinline{malloc} to allocate a large
piece of memory, and then split it into several sub-regions assigned to different pointers.
In our ownership analysis, only one pointer can gain ownership of the memory allocated by a call to \lstinline{malloc}.
Another C idiom that we don't fully support %
occurs when certain pointers can 
point to either heap allocated objects, or statically allocated stack arrays.
\name generates ownership constraints only for the heap and, consequently, those variables will be left under-constrained. %


\subsection{Other limitations of \name}

\paragraph{Array pointers.} For array pointers, although \name infers the correct ownership information, it does not generate the meta data required to synthesise Rust code.\vspace{-0.2cm}

\paragraph {Mutable local borrows.} As explained in the last paragraph of Section~\ref{sec:pointer-retype},
\name does not translate mutable non-owning pointers to local mutable references as this requires dedicated analysis of lifetimes. 
Note that \name does however generate mutable references for output parameters.\vspace{-0.2cm}

\paragraph{Access paths that break ownership monotonicity.}
As discussed in section~\ref{sec:ownership-monotonicity}, ownership monotonicity may be stricter in certain cases than Rust's semantics.








