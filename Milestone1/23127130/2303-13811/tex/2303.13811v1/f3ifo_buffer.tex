%\pagebreak
\section[title]{Experiment With FIFO Buffers\footnote{\input{f4ootnote}}}
\label{sec:fifo_exper}

\input{b4uffer.fig}

In this section, we give an example of bug detection by invariant
generation for a FIFO buffer. Our objective here is twofold. First, we
want to substantiate the intuition of Subsection~\ref{ssec:des_cov}
that property generation by PQE (in our case, invariant generation by
PQE) has the same reasons to be effective as testing. In particular,
by taking out different clauses one generates invariants relating to
different parts of the design. So, taking out a clause of the buggy
part is likely to produce an unwanted invariant.  Second, we want to
give an example of an invariant that can be easily identified as
unwanted.

%
%  subsection
%
%\vspace{2pt}
%\noindent\tb{Buffer description.}
\subsection{Buffer description}
Consider a FIFO buffer that we will
refer to as \fifo.  Let $n$ be the number of elements of \fifo and
\data denote the data buffer of \fifo.  Let each
$\data[i],i=1,\dots,n$ have $p$ bits and be an integer where $0 \leq
\data[i] < 2^p$.  A fragment of the Verilog code describing \fifo is
shown in Fig~\ref{fig:bug}. This fragment has a buggy line marked with
an asterisk. In the correct version without the marked line, a new
element $\mi{dataIn}$ is added to \data if the \ti{write} flag is on
and \fifo has less than $n$ elements.  Since \data can have any
combination of numbers, all \data states are supposed to be reachable.
%
However, due to the bug, the number $\mi{Val}$ cannot appear in \data.
(Here $\mi{Val}$ is some constant \mbox{$0\!<\!\mi{Val}\!<\!
  2^p$}. We assume that the buffer elements are initialized to 0.) So,
\fifo has an \ti{op-state reachability bug} since it cannot reach
operative states where an element of \data equals $\mi{Val}$.  This
bug is hard to detect by random testing because it is exposed only if
one tries to add \ti{Val} to \fifo.  Similarly, it is virtually
impossible to guess an unwanted invariant of \fifo exposing this bug
unless one knows exactly what this bug is.


%
% subsection
%
%\vspace{-1pt}
\subsection{Bug detection by invariant generation}
%\vspace{2pt}
%\noindent{\tb{Bug detection by invariant generation.}
Let $N$ be a circuit implementing \fifo. Let $S$ be the set of state
variables of $N$ and \bm{\Sub{S}{data} \subset S} be the subset
corresponding to the data buffer \data.  We used \dpqe, \Eg and \egp
to generate invariants of $N$ as described in
Section~\ref{sec:inv_gen}.  Note that an invariant $Q$ depending only
on \Sub{S}{data} is an \tb{unwanted} one.  If $Q$ holds for $N$, some
states of \data are unreachable. Then \fifo has an op-state
reachability bug since every state of \data is supposed to be
reachable. To generate invariants, we used the formula $F_k = I(S_0)
\wedge T(S_0,V_0,S_1) \wedge \dots \wedge T(S_{k-1},V_{k-1},S_k)$
introduced in Subsection~\ref{ssec:check_unreach}. Here $I$ and $T$
describe the initial state and the transition relation of $N$
respectively and $S_j$ and $V_j$ denote state variables and
combinational input variables of $j$-th time frame respectively.
First, we used a PQE solver to generate a local invariant $H(S_k)$
obtained by taking a clause $C$ out of \prob{\Abs{k}}{F_k} where
$\Abs{k} = S_0 \cup V_0 \cup \dots \cup S_{k-1} \cup V_{k-1}$.  So,
\prob{\Abs{k}}{F_k} $\equiv H \wedge$ \prob{\Abs{k}}{F_k \setminus
  \s{C}}. (Since $F_k \imp H$, no state falsifying $H$ is reachable in
$k$ transitions.)  In the experiment, we took out only clauses of
$F_k$ containing an \ti{unquantified variable} i.e. a variable of
$S_k$. Such a choice was limited but still guaranteed that we
\tb{cover} the entire design in terms of \tb{state variables}. The
time limit for solving the PQE problem of taking out a clause was set
to 10 sec.

For each clause $Q$ of every local invariant $H$ generated by PQE, we
checked if $Q$ was a global invariant. Namely, we used a public
version of \ict~\cite{ic3,ic3_impl} to verify if the property $Q$ held
(by showing that no reachable state of $N$ falsified $Q$).  If so, and
$Q$ depended only on variables of \Sub{S}{data}, $N$ had an
\ti{unwanted invariant}. Then we stopped invariant generation. The
results of the experiment are given in Table~\ref{tbl:buff}.  In the
experiment, we considered buffers with 32-bit elements.  When picking
a clause to take out, i.e. a clause with a variable of $S_k$, one
could make a good choice by pure luck.  To address this issue, we
picked clauses to take out \ti{randomly} and performed 10 different
runs of invariant generation and then computed the average value. So,
the columns four to twelve of Table~\ref{tbl:buff} actually give the
average value of 10 runs.

\input{b5uffer.tbl}

Let us use the first line of Table~\ref{tbl:buff} to explain its
structure. The first two columns show the number of elements in \fifo
implemented by $N$ and the number of latches in $N$ (8 and 300).  The
third column gives the number $k$ of time frames (i.e. 5). The next
three columns show the total number of PQE problems solved by a PQE
solver before an unwanted invariant was generated e.g. 8 problems for
\egp. On the other hand, \dpqe failed to find an unwanted invariant
and had to solve \ti{all} 1,236 PQE problems of taking out a clause of
$F_k$ with an unquantified variable. The following three columns show
the share of PQE problems \ti{finished} in the time limit of 10 sec.
For instance, \Eg finished 37\% of 311 problems.  The next three
columns show if an unwanted invariant was generated by a PQE
solver. \dpqe did not find one for the first instance of \fifo whereas
\Eg and \egp found it. The last three columns give the total run time.
Table~\ref{tbl:buff} shows that only \egp managed to generate an
unwanted invariant for all four instances of \fifo. This invariant
asserted that \fifo cannot reach a state where an element of \data
equals $\mi{Val}$.



%\clearpage
