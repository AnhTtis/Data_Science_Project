%\clearpage
%\vspace{-10pt}
\section{Experiments With HWMCC-13 Benchmarks}
\label{app:exper2}
In Section~\ref{sec:inv_gen_exper}, we described experiments with
multi-property benchmarks of the HWMCC-13 set~\cite{hwmcc13}. In this
appendix, we provide some additional information. Each benchmark
consists of a sequential circuit $N$ and invariants $P_0,\dots,P_m$
that are supposed to hold for $N$. We will refer to the invariant
\Sub{P}{agg} equal to $P_0 \wedge \dots \wedge P_m$ as the
\ti{aggregate invariant}.  We applied PQE to the generation of
invariants of $N$ that may be \ti{unwanted}.  Since every invariant
$P$ implied by \Sub{P}{agg} \ti{must} hold, the necessary condition
for $P$ to be unwanted is $\Sub{P}{agg} \not\imp P$.

Similarly to the experiment of Section~\ref{sec:fifo_exper}, we used the
formula $F_k = I(S_0) \wedge T(S_0,V_0,S_1)$ $\wedge \dots \wedge
T(S_{k-1},V_{k-1},S_k)$ to generate invariants. The number $k$ of time
frames was in the range of \mbox{$2\!\leq\!k\!
  \leq\!10$}. Specifically, we set $k$ to the largest value in this
range where $|F_k|$ did not exceed 500,000 clauses. We discarded the
benchmarks with $|F_2|\!>\!500,000$. We also dropped the smallest
benchmarks. So, in the experiments, we used 98 out of the 178
benchmarks of the set.

We describe three experiments. In every experiment, we generated
properties $H(S_k)$ by taking out a clause of \prob{\Abs{k}}{F_k}
where $\Abs{k}\!=\!S_0 \cup V_0 \cup \dots \cup S_{k-1} \cup
V_{k-\!1}$. Property\ $H$ is a \ti{local invariant} claiming that no
state falsifying $H$ can be reached in $k$ transitions. As in the
experiment of Section~\ref{sec:fifo_exper}, we took out only clauses
containing an unquantified variable (i.e a variable of $S_k$). In all
experiments, the \tb{time limit} for solving a PQE problem was set to
10 sec.

%
%  Experiment 1
%
%\vspace{-10pt}
%\clearpage
\subsection{Experiment 1}
%\vspace{-9pt}
\label{ssec:exper1}

%\tb{Experiment 1.}

The objective of the \ti{first experiment} was to demonstrate that
\egp could compute $H$ for realistic designs. We also showed in this
experiment that PQE could be much easier than QE (see
Section~\ref{sec:inv_gen_exper}) and that \egp outperforms \dpqe and
\Eg.  In this experiment, for each benchmark out of 98 mentioned above
we generated PQE problems of taking a clause out of
\prob{\Abs{k}}{F_k}. Some of them were trivially solved by
preprocessing. The latter eliminated the blocked clauses of $F_k$ that
were easy to identify and ran BCP launched due to the unit clauses
specifying the initial state. In all experiments, we \ti{discarded}
problems solved by preprocessing i.e. we considered only
\tb{non-trivial} PQE problems.

%
\input{o0nly_rmvbl_pnts.tbl}
%

Let $C$ be a clause taken out of \prob{\Abs{k}}{F_k}. We used \Eg to
partition the PQE problems we tried into two groups. \ti{The first
  group} consisted of problems for which we ran \Eg with the time
limit of 10 sec. and it never encountered a subspace \pnt{s_k} where
$F_k$ was satisfiable. Here \pnt{s_k} is a full assignment to
$S_k$. (Recall that the variables of $S_k$ are the only unquantified
variables of \prob{\Abs{k}}{F_k}.) So, in every subspace \pnt{s_k}
tried by \Eg, formula $F_k$ was either unsatisfiable or
$(F_k\!\setminus\!\s{C})\!  \imp\!C$.  \ti{The second group} consisted
of problems where \Eg encountered subspaces where $F_k$ was
satisfiable.  For either group we generated up to 40 problems per
benchmark. For some benchmarks, the total number of non-trivial
problems generated for the first or second group was under 40.  Many
PQE problems of either group had hundreds of thousands of variables.


%
\input{unrmvbl_pnts.tbl}
%


The results for the first group are shown in
Table~\ref{tbl:only_rbp}. The first column gives the name of a PQE
solver. The second column shows the number of PQE problems in the
first group. The last two columns give the number and percentage of
problems finished in the time limit of 10 sec.
Table~\ref{tbl:only_rbp} shows that \Eg and \egp performed quite well
finishing a very high percentage of problems.  The results of \dpqe
are much poorer because it does not check if $(F_k \setminus \s{C})
\imp C$ in the current subspace i.e. if $C$ is trivially redundant.



The results for the second group are shown in Table~\ref{tbl:ubp} that
has the same structure as Table~\ref{tbl:only_rbp}. In particular, the
second column gives the number of PQE problems in the second
group. Table~\ref{tbl:ubp} shows that \Eg and \egp finished 2\% and
27\% of the problems respectively. So, \egp significantly outperformed
\Eg. The reason is that \Eg uses a satisfying assignment as a proof of
redundancy of the clause $C$ in subspace \ppnt{s}{k}.
%\clearpage



%
%  Experiment 2
\subsection{Experiment 2}
\label{ssec:exper2}
%\tb{Experiment 2.}
The second experiment was an extension of the first one. Its goal was
to show that PQE can generate invariants for realistic designs. For
each clause $Q$ of a local invariant $H$ generated by PQE we used \ict
to verify if $Q$ was a global invariant.  If so, we checked if
$\Sub{P}{agg} \not\imp Q$ held. To make the experiment less time
consuming, in addition to the time limit of 10 sec.  per PQE problem,
we imposed the following constraints.  First, we stopped a PQE-solver
even before the time limit if it generated more than 5 free
clauses. Second, the time limit for \ict was set to 30 sec.  Third,
instead of constraining the number of PQE problems per benchmark
(i.e. the number of single clauses taken out of \prob{\Abs{k}}{F_k})
like in the first experiment, we imposed the following two
constraints.  First, we stopped processing a benchmark as soon as the
total of 100 free clauses was generated (for all the PQE problems
generated for this benchmark). Second, we stopped processing a
benchmark even earlier if the summary run time for all PQE problems
generated for this benchmark exceeded 2,000 sec.




A sample of 9 benchmarks out of the 98 we used in the experiment with
\egp is shown in Table~\ref{tbl:sample}. Let us explain the structure
of this table by the benchmark 6s306 (the first line of the
table). The name of this benchmark is shown in the first column. The
second column gives the number of latches (7,986). The number of
invariants that should hold for 6s306 is provided in the third column
(25). So, the aggregate invariant \Sub{P}{\!agg} of 6s306 is the
conjunction of those 25 invariants. The fourth column shows that the
number $k$ of time frames for 6s306 was set to 2 (since
$|F_3|\!>\!500,000$).  The value 182 shown in the fifth column is the
total number of single clauses taken out of \prob{\Abs{k}}{F_k}
i.e. the number of PQE problems (where $k=2$ for 6s306).

%
\input{multi_props.tbl}
%

Every free clause $Q$ generated by \egp when taking a clause out of
\prob{\Abs{k}}{F_k} was stored as a local single-clause invariant.
The sixth column shows that taking clauses out of the scope of
quantifiers was terminated when 100 free clauses (specifying 100 local
single-clause invariants) were generated.  Each of these 100 local
invariants held in $k$-th time frame. The following three columns show
how many of those 100 local invariants were true globally. \ict
finished every problem out of 100 in the time limit of 30 sec. So, the
number of undecided invariants was 0. The number of invariants \ict
proved false or true globally was 94 and 6 respectively. The last
column gives the number of global invariants \ti{not} implied by
\Sub{P}{\!agg} i.e. invariants that may be unwanted. For 6s306, this
number is 6.

%\input{a0ll_inv_gen.tbl}

%\vspace{-5pt}

%\input{e2xper}
%\input{e3xper}
\input{extra_exper}
