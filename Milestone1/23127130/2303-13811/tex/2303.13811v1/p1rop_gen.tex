\section{Property Generation By PQE}
\label{sec:prop_gen}
Many known problems can be formulated in terms of PQE thus
facilitating the design of new efficient algorithms. In
Appendix~\ref{app:using_pqe}, we recall some results on solving SAT,
equivalence checking and model checking by PQE presented in
~\cite{hvc-14,south_korea,fmcad16,mc_no_inv2}. In this section, we
describe application of PQE to \ti{property generation} for a
combinational circuit.  The objective of property generation is to
expose a bug via producing an \ti{unwanted} property.

Let $M(X,V,W)$ be a combinational circuit where $X,V,W$ specify the
sets of the internal, input, and output variables of $M$
respectively. Let $F(X,V,W)$ denote a formula specifying $M$. As
usual, this formula is obtained by Tseitin's
transformations~\cite{tseitin}. Namely, $F$ equals $F_{G_1} \wedge
\dots \wedge F_{G_k}$ where $G_1,\dots,G_k$ are the gates of $M$ and
$F_{G_i}$ specifies the functionality of gate $G_i$.
%
% example
%
%\vspace{-3pt}
\begin{example}
\label{exmp:gate_cnf}
Let $G$ be a 2-input AND gate defined as $x_3 = x_1 \wedge x_2$ where
$x_3$ denotes the output value and $x_1,x_2$ denote the input values
of $G$. Then $G$ is specified by the formula $F_G\!=\!(\overline{x}_1
\vee \overline{x}_2\vee x_3) \wedge (x_1 \vee \overline{x}_3) \wedge
(x_2 \vee \overline{x}_3)$. Every clause of $F_G$ is falsified by an
inconsistent assignment (where the output value of $G$ is not implied
by its input values). For instance, $x_1\!\vee \overline{x}_3$ is
falsified by the inconsistent assignment $x_1\!=\!0, x_3\!=\!1$. So,
every assignment \ti{satisfying} $F_G$ corresponds to a
\ti{consistent} assignment to $G$ and vice versa. Similarly, every
assignment satisfying the formula $F$ above is a consistent assignment
to the gates of $M$ and vice versa.
\end{example}

%
% subsection
%
\subsection{Property generation as generalization of testing}
Let $w_i \in W$ be an output variable of $M$ and \pnt{v} be a test
i.e. a full assignment to the input variables $V$ of $M$. Let
\Cof{B}{v} denote the longest clause falsified by \pnt{v} i.e.
$\V{\Cof{B}{v}} = V$. Let $l(w_i)$ be the literal satisfied by the
value of $w_i$ produced by $M$ under input \pnt{v}. Then the clause
$\Cof{B}{v} \vee l(w_i)$ is satisfied by every assignment satisfying
$F$ i.e. $\Cof{B}{v} \vee l(w_i)$ is a property of $M$.  We will refer
to it as a \tb{single-test property} (since it describes the behavior
of $M$ for a single test). If the input \pnt{v} is supposed to produce
the opposite value of $w_i$ (i.e. the one \ti{falsifying} $l(w_i)$),
then \pnt{v} exposes a bug in $M$.  In this case, the single-test
property above is an \tb{unwanted} property of $M$ exposing the same
bug as the test \pnt{v}.



A single-test property can be viewed as a weakest property of $M$ as
opposed to the strongest property specified by \prob{X}{F}.  The
latter is the truth table of $M$ that can be explicitly computed by
performing QE on \prob{X}{F}.  One can use PQE to generate properties
of $M$ that, in terms of strength, range from the weakest ones to the
strongest property inclusively. (By combining clause splitting with
PQE one can generate single-test properties, see the next subsection.)
Consider the PQE problem of taking a clause $C$ out of \prob{X}{F}.
Let $H(V,W) $ be a solution to this problem i.e. $\prob{X}{F} \equiv H
\wedge \prob{X}{F \setminus \s{C}}$.  Since $H$ is implied by $F$, it
can be viewed as a \tb{property} of $M$. If $H$ is an \tb{unwanted}
property, $M$ has a bug. (Here we consider the case where a property
of $M$ is obtained by taking a clause out of formula \prob{X}{F} where
only the \ti{internal} variables of $M$ are quantified. Later we
consider cases where some external variables of $M$ are quantified
too.)

The benefit of property generation by PQE is fourfold.  First, by
property generation one can identify bugs that are hard or simply
impossible to find by testing. Second, using PQE makes property
generation efficient.  Third, by taking out different clauses one can
generate properties covering different parts of design. This increases
the probability of discovering a bug. Fourth, every property generated
by PQE specifies a large set of high-quality tests.

We will assume that the property $H$ generated by PQE has no redundant
clauses (see Remark~\ref{rem:noise}). That is if $D \in H$, then $F
\setminus \s{C} \not\imp D$. Then one can view $H$ as a property
that holds due to the presence of the clause $C$ in $F$.




%
% subsection
%
%\subsection{Undestanding properties generated by PQE}
\subsection{Computing properties efficiently}
\label{ssec:eff_comp}
If a property $H$ is obtained by taking only one clause out of
\prob{X}{F}, its computation is much easier than performing QE on
\prob{X}{F}. If computing $H$ still remains too time-consuming, one
can use the two methods below that achieve better performance at the
expense of generating weaker properties. The first method applies when
a PQE solver forms a solution \ti{incrementally}, clause by clause
(like the algorithms described in Sections~\ref{sec:eg_pqe}
and~\ref{sec:eg_pqe+}). Then one can simply stop computing $H$ as soon
as the number of clauses in $H$ exceeds a threshold.  Since an
``incomplete'' formula $H$ is implied by $F$, it specifies a property
of $M$.

The second method employs \ti{clause splitting}.  Here we consider
clause splitting on input variables $v_1,\dots,v_p$ i.e. those of $V$
(but one can split a clause on any subset of variables from
\V{F}). Let $F'$ denote the formula $F$ where a clause $C$ is replaced
with $p+1$ clauses: $C_1 = C \vee \overline{l(v_1)}$,\dots, $C_p = C
\vee \overline{l(v_p)}$, $C_{p+1} = C \vee l(v_0) \vee \dots \vee
l(v_p)$, where $l(v_i)$ is a literal of $v_i$. The idea is to obtain a
property $H$ by taking the clause $C_{p+1}$ out of \prob{X}{F'} rather
than $C$ out of \prob{X}{F}. The former PQE problem is simpler than
the latter since it produces a weaker property $H$. One can show that
if $\s{v_1,\dots,v_p}\!  =\!V$, then a) the complexity of PQE reduces
to \tb{linear}; b) taking out $C_{p+1}$ actually produces a
\tb{single-test property}. The latter specifies the input/output
behavior of $M$ for the test \pnt{v} falsifying the literals
$l(v_1),\dots, l(v_p)$. (See Appendix~\ref{app:cls_split} for more
details.)

%
% subsection
%
\subsection{Using design coverage for generation of unwanted properties}
\label{ssec:des_cov}
Arguably, testing is so effective in practice because one verifies a
\ti{particular design}. Namely, one probes different parts of this
design using some coverage metric rather than samples the truth table
(which would mean verifying \ti{every possible design}). The same idea
works for property generation by PQE for the following two
reasons. First, by taking out a clause, PQE generates a property
inherent to the \ti{specific} circuit $M$. (If one replaces $M$ with
an equivalent but structurally different circuit, PQE will generate
different properties.)  Second, by taking out different clauses of $F$
one generates properties corresponding to different parts of $M$ thus
``covering'' the design. This increases the chance to take out a
clause corresponding to the buggy part of $M$ and generate an unwanted
property.


%\subsection{High-quality tests specified by a property}
%\subsection{Semantics of properties generated by PQE}
\vspace{-3pt}
\subsection{High-quality tests specified by a property generated by PQE}
\label{ssec:tests_props}
In this subsection, we show that a property $H$ generated by PQE, in
general, specifies a large set of high-quality tests. Let $H(V,W)$ be
obtained by taking $C$ out of \prob{X}{F(X,V,W)}. Let $Q(V,W)$ be a
clause of $H$. As mentioned above, we assume that $F \setminus \s{C}
\not\imp Q$. Then there is an \smallskip assignment
(\pnt{x},\pnt{v},\pnt{w}) satisfying formula $(F \setminus \s{C})
\wedge \overline{Q}$ where \pnt{x},\pnt{v},\pnt{w} are assignments to
$X,V,W$ respectively. (Note that by definition, (\pnt{v},\pnt{w})
falsifies $Q$.) Let $(\pnt{x}^*,\pnt{v},\pnt{w}^*)$ be the execution
trace of $M$ under the input \pnt{v}. So,
$(\pnt{x}^*,\pnt{v},\pnt{w}^*)$ satisfies $F$. Note that the output
assignments \pnt{w} and $\pnt{w}^*$ must be different because
$(\pnt{v},\pnt{w}^*)$ has to satisfy $Q$. (Otherwise,
$(\pnt{x}^*,\pnt{v},\pnt{w}^*)$ satisfies $F \wedge \overline{Q}$ and
so $F \not\imp Q$ and hence $F \not\imp H$.)  So, one can view \pnt{v}
as a test ``detecting'' disappearance of the clause $C$ from $F$.
Note that different assignments satisfying $(F \setminus \s{C}) \wedge
\overline{Q}$ correspond to different tests \pnt{v}. So, the clause
$Q$ of $H$, in general, specifies a very large number of tests. One
can show that these tests are similar to those detecting stuck-at
faults and so have very high quality (see
Appendix~\ref{app:tests_props} for more details).

\vspace{-5pt}
\subsection{Identifying unwanted properties}
In some cases, e.g. those mentioned in Sections~\ref{sec:fifo_exper}
and~\ref{sec:comb_exper}, it is easy to decide if a property $H$
obtained by PQE is unwanted. Otherwise, this can be done by analyzing
tests detecting the disappearance of a clause from $F$ (see
Subsection~\ref{ssec:tests_props}).  A more detailed discussion of
this topic is beyond the scope of this paper.

