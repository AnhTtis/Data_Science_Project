\vspace{-10pt}
\section{Introduction}
\label{sec:intro}
In this paper, we consider the following problem. Let $F(X,Y)$ be a
propositional formula in conjunctive normal form
(CNF)\footnote{\input{f1ootnote}} where $X,Y$ are sets of
variables. Let $G$ be a subset of clauses of $F$.  Given a
formula \prob{X}{F}, find a quantifier-free formula $H(Y)$ such that
$\prob{X}{F}\equiv H\wedge\prob{X}{F \setminus G}$.  In contrast
to \ti{full} quantifier elimination (QE), only the clauses of $G$ are
taken out of the scope of quantifiers here. So, this problem is
called \ti{partial} QE (PQE)~\cite{hvc-14}.  (In this paper, we
consider PQE only for formulas with \ti{existential} quantifiers.) We
will refer to $H$ as a \ti{solution} to PQE.  Like SAT, PQE is a way
to cope with the complexity of QE. But in contrast to SAT that is a
\ti{special} case of QE (where all variables are quantified), PQE
\ti{generalizes} QE. The latter is just a special case of PQE where $G = F$
and the entire formula is
unquantified. Interpolation~\cite{craig,ken03} is a special case of
PQE as well~\cite{tech_rep_pc_lor} (see also
Appendix~\ref{app:interp}).

The appeal of PQE is threefold. First, it can be much more efficient
than QE if $G$ is a \ti{small} subset of $F$. Second, many
verification problems like SAT, equivalence checking, model checking
can be solved in terms of
PQE~\cite{hvc-14,south_korea,fmcad16,mc_no_inv2}. So, PQE can be used
to design new efficient methods for solving known problems. Third, one
can apply PQE to solving \ti{new} problems like property generation
considered in this paper. In practice, to perform PQE, it suffices to
have an algorithm that takes a single clause out of the scope of
quantifiers. Namely, given a formula \prob{X}{F(X,Y)} and a clause
$C \in F$, this algorithm finds a formula $H(Y)$ such that
$\prob{X}{F} \equiv H \wedge \prob{X}{F \setminus \s{C}}$. To take out
$k$ clauses, one needs to apply this algorithm $k$ times.  Since
$H \wedge \prob{X}{F} \equiv H\wedge \prob{X}{ F \setminus \s{C}}$,
solving the PQE above reduces to finding $H(Y)$ that makes
$C$ \ti{redundant} in $H \wedge \prob{X}{F}$. So, the PQE algorithms
we present here are based on \ti{redundancy based reasoning}.

We describe two PQE algorithms called \Eg and \egp where ``\ti{EG}''
stands for ``Enumerate and Generalize''. \Eg is a very simple
SAT-based algorithm that can sometimes solve very large problems. \egp
is a modification of \Eg that makes the algorithm more powerful and
robust\footnote{\input{f2ootnote}}.  To show the practicality of PQE
we apply it to property generation.  Our motivation here is as
follows. In practice, the set of properties a design must meet is
incomplete. (That is, this design can be buggy even if all properties
of this set hold.) This problem is usually addressed by massive
testing. The input/output behavior of the design under a single test
can be cast as a (simple) design property. So, a test exposing a bug
can be viewed as identifying an \ti{unwanted} design property. In
terms of property generation, the flaw of testing is that it considers
only very simple properties.

In this paper, we show that one can use PQE to generate more complex
design properties. The goal of property generation is to produce an
unwanted property thus exposing a bug that may have been overlooked or
simply \ti{cannot} be detected by testing. The benefits of property
generation by PQE are as follows.  First, by using PQE one can make
property generation efficient. Second, PQE facilitates generation of
properties covering different parts of the design, which increases the
probability of discovering a bug.  Third, every property generated by
PQE specifies a large set of high-quality tests.  We show how PQE can
be used to generate properties for a combinational circuit. We also
continue the work on \ti{invariant generation} for a sequential
circuit we started in~\cite{cert_tech_rep}.  One can use invariant
generation to identify a bug that makes a state of a sequential
circuit \ti{unreachable} (whereas in a correct design this state
should be reachable). Such bugs can be easily missed.

The main body of this paper is structured as follows. (A full version
with all appendices will be published as a technical report.)  In
Section~\ref{sec:basic}, we give basic
definitions. Section~\ref{sec:prop_gen} presents property generation
for a combinational circuit. In Section~\ref{sec:inv_gen}, we describe
invariant generation for a sequential
circuit. Sections~\ref{sec:eg_pqe} and~\ref{sec:eg_pqe+} present \Eg
and \egp respectively.  Section~\ref{sec:rel} makes some remarks about
experiments and relates our previous PQE-solver
called \Apqe~\cite{cert_tech_rep} to \egp. In
Section~\ref{sec:fifo_exper}, invariant generation is used to find a
hard bug in a FIFO buffer.  Experiments with invariant generation for
HWMCC benchmarks are described in Section~\ref{sec:inv_gen_exper}.
Section~\ref{sec:comb_exper} presents an experiment with property
generation for combinational circuits.  In Sections~\ref{sec:bg}
and~\ref{sec:concl}, we give some background and make conclusions.


