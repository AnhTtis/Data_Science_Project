%\pagebreak
\section{Experiment With FIFO Buffers}
\label{sec:fifo_exper}

%% %
%% % subsection
%% %
%% \vspace{-5pt}
%% \subsection{Buffer description}
%% \vspace{-5pt}
In this and the next two sections we describe some experiments
with\linebreak \dpqe, \Eg and \egp (their sources are available
at~\cite{ds_pqe},~\cite{eg_pqe} and ~\cite{eg_pqe_plus}
respectively). We used Minisat2.0~\cite{minisat} as an internal
SAT-solver.  The experiments were run on a computer with Intel Core
i5-8265U CPU of 1.6\,GHz.

\input{b4uffer.fig} In this section, we give an example of bug
detection by invariant generation for a FIFO buffer. Our objective
here is threefold.  First, we want to give an example of a bug that
can be overlooked by testing and guessing the unwanted properties to
check (see Subsection~\ref{ssec:hard_bug}). Second, we want to
substantiate the intuition of Subsection~\ref{ssec:des_cov} that
property generation by PQE (in our case, invariant generation by PQE)
has the same reasons to be effective as testing. In particular, by
taking out different clauses one generates invariants relating to
different parts of the design. So, taking out a clause of the buggy
part is likely to produce an unwanted invariant.  Third, we want to
give an example of an invariant that can be easily identified as
unwanted\footnote{\input{f2ootnote}}.
%
% Subsection: buffer description
%
\subsection{Buffer description}
\label{ssec:buff_descr}
Consider a FIFO buffer that we will
refer to as \fifo.  Let $n$ be the number of elements of \fifo and
\data denote the data buffer of \fifo.  Let each
$\data[i],i=1,\dots,n$ have $p$ bits and be an integer where $0 \leq
\data[i] < 2^p$.  A fragment of the Verilog code describing \fifo is
shown in Fig~\ref{fig:bug}. This fragment has a buggy line marked with
an asterisk. In the correct version without the marked line, a new
element $\mi{dataIn}$ is added to \data if the \ti{write} flag is on
and \fifo has less than $n$ elements.  Since \data can have any
combination of numbers, all \data states are supposed to be reachable.
%
However, due to the bug, the number $\mi{Val}$ cannot appear in \data.
(Here $\mi{Val}$ is some constant \mbox{$0\!<\!\mi{Val}\!<\!
  2^p$}. We assume that the buffer elements are initialized to 0.) So,
\fifo has an \ti{op-state reachability bug} since it cannot reach
operative states where an element of \data equals $\mi{Val}$.




%
% Subsection: bug detection by invariant generation
%
\subsection{Bug detection by invariant generation}
Let $N$ be a circuit implementing \fifo. Let $S$ be the set of state
variables of $N$ and \bm{\Sub{S}{data} \subset S} be the subset
corresponding to the data buffer \data.  We used \dpqe, \Eg and \egp
to generate invariants of $N$ as described in
Section~\ref{sec:inv_gen}.  Note that an invariant $Q$ depending only
on \Sub{S}{data} is an \tb{unwanted} one.  If $Q$ holds for $N$, some
states of \data are unreachable. Then \fifo has an op-state
reachability bug since every state of \data is supposed to be
reachable. To generate invariants, we used the formula $F_k = I(S_0)
\wedge T(S_0,V_0,S_1) \wedge \dots \wedge T(S_{k-1},V_{k-1},S_k)$
introduced in Subsection~\ref{ssec:check_unreach}. Here $I$ and $T$
describe the initial state and the transition relation of $N$
respectively and $S_j$ and $V_j$ denote state variables and
combinational input variables of $j$-th time frame respectively.
First, we used a PQE solver to generate a local invariant $H(S_k)$
obtained by taking a clause $C$ out of \prob{\Abs{k}}{F_k} where
$\Abs{k} = S_0 \cup V_0 \cup \dots \cup S_{k-1} \cup V_{k-1}$.  So,
\mbox{$\prob{\Abs{k}}{F_k}\equiv$} $H \wedge$ \prob{\Abs{k}}{F_k
  \setminus \s{C}}. (Since $F_k \imp H$, no state falsifying $H$ can
be reached in $k$ transitions.)  In the experiment, we took out only
clauses of $F_k$ containing an \ti{unquantified variable}, \ie a state
variable of the $k$-th time frame. The time limit for solving the PQE
problem of taking out a clause was set to 10 sec.

\input{b5uffer.tbl}

For each clause $Q$ of every local invariant $H$ generated by PQE, we
checked if $Q$ was a global invariant. Namely, we used a public
version of \ict~\cite{ic3,ic3_impl} to verify if the property $Q$ held
(by showing that no reachable state of $N$ falsified $Q$).  If so, and
$Q$ depended only on variables of \Sub{S}{data}, $N$ had an
\ti{unwanted invariant}. Then we stopped invariant generation. The
results of the experiment for buffers with 32-bit elements are given
in Table~\ref{tbl:buff}.  When picking a clause to take out, \ie a
clause with a state variable of $k$-th time frame, one could make a
good choice by pure luck.  To address this issue, we picked clauses to
take out \ti{randomly} and performed 10 different runs of invariant
generation and then computed the average value. So, the columns four
to twelve of Table~\ref{tbl:buff} actually give the average value of
10 runs.


Let us use the first line of Table~\ref{tbl:buff} to explain its
structure. The first two columns show the number of elements in \fifo
implemented by $N$ and the number of latches in $N$ (8 and 300).  The
third column gives the number $k$ of time frames (\ie 5). The next
three columns show the total number of PQE problems solved by a PQE
solver before an unwanted invariant was generated, \eg 8 problems for
\egp. On the other hand, \dpqe failed to find an unwanted invariant
and had to solve \ti{all} 1,236 PQE problems of taking out a clause of
$F_k$ with an unquantified variable. The following three columns show
the share of PQE problems \ti{finished} in the time limit of 10 sec.
For instance, \Eg finished 36\% of 311 problems.  The next three
columns show if an unwanted invariant was generated by a PQE solver.
(\Eg and \egp found one whereas \dpqe did not.) The last three columns
give the total run time.  Table~\ref{tbl:buff} shows that only \egp
managed to generate an unwanted invariant for all four instances of
\fifo. This invariant asserted that \fifo cannot reach a state where
an element of \data equals $\mi{Val}$.
%\clearpage
%
% Subsection: finding the bug by conventional methods is hard
%
%\subsection{Finding the bug in question  by conventional methods}
%\vspace{-20pt}
\subsection{Detection of the bug by conventional methods}
\label{ssec:hard_bug}
The bug above (or its modified version) can be overlooked by
conventional methods.  Consider, for instance, testing.  It is hard to
detect this bug by \ti{random} tests because it is exposed only if one
tries to add \ti{Val} to \fifo.  The same applies to testing using the
\ti{line coverage} metric~\cite{coverage}. On the other hand, a test
set with 100\% \ti{branch} coverage~\cite{coverage} will find this
bug. (To invoke the \ti{else} branch of the \ti{if} statement marked
with '*' in Fig.~\ref{fig:bug}, one must set $\mi{dataIn}$ to
$\mi{Val}$.)  However, such a test set is not hard to beat. Consider a
slightly modified bug. Namely, assume that the buggy line
is~~\ti{if}\,(($\mi{dataIn}~!\!\!= \mi{Val})~ \&\&
~(\mi{dataIn}~!\!\!= \mi{Val}')$) and in the \ti{else} branch of this
\ti{if} statement, the element $\mi{Val}'$ is pushed to \fifo. So,
instead of just ignoring the element $\mi{Val}$, the modified bug
\ti{replaces} it with $\mi{Val}'$ in \fifo.  Similarly to the bug of
Subsection~\ref{ssec:buff_descr}, $\mi{Val}$ does not appear in
\fifo. So, the modified bug can also be detected by generating an
unwanted invariant. On the other hand, it can be overlooked by tests
with 100\% branch coverage because either branch of the modified
\ti{if} statement can be activated \ti{without} assigning
$\mi{dataIn}$ to $\mi{Val}$.

Now consider the ``manual'' generation of unwanted properties. It is
virtually impossible to guess an unwanted \ti{invariant} of \fifo
exposing the bug of Subsection~\ref{ssec:buff_descr} unless one knows
exactly what this bug is.  However, one can detect this bug by
checking a property asserting that the element $\mi{dataIn}$ must
appear in the buffer if \fifo is ready to accept it, \ie  $(\mi{write}
== 1) \&\& (\mi{currSize} < n)$ holds. Note that this is a
\ti{non-invariant} property involving states of different time
frames. The more time frames are used in such a property, the more
guesswork is required to pick it.
%
Consider, for instance, the following bug. Suppose \fifo does not
reject the element $\mi{Val}$.  So, the non-invariant property above
holds.  However, if $\mi{dataIn} == \mi{Val}$, then \fifo changes the
\ti{previous} accepted element if that element was $\mi{Val}$ too. So,
\fifo cannot have two consecutive elements $\mi{Val}$.  Our method
will detect this bug via generating an unwanted invariant falsified by
states with consecutive elements $\mi{Val}$. One can also identify
this bug by checking a property involving two consecutive elements of
\fifo. But picking it requires a lot of guesswork and so the modified
bug can be easily overlooked.
%\clearpage
