\vspace{-10pt}
\section{Introduction}
\label{sec:intro}
In this paper, we consider the following problem. Let $F(X,Y)$ be a
propositional formula in conjunctive normal form
(CNF)\footnote{\input{f1ootnote}} where $X,Y$ are sets of
variables. Let $G$ be a subset of clauses of $F$.  Given a
formula \prob{X}{F}, find a quantifier-free formula $H(Y)$ such that
$\prob{X}{F}\equiv H\wedge\prob{X}{F \setminus G}$.  In contrast
to \ti{full} quantifier elimination (QE), only the clauses of $G$ are
taken out of the scope of quantifiers here. So, we call this problem 
\ti{partial} QE (PQE)~\cite{hvc-14}.  (In this paper, we
consider PQE only for formulas with \ti{existential} quantifiers.) We
will refer to $H$ as a \ti{solution} to PQE.  Like SAT, PQE is a way
to cope with the complexity of QE. But in contrast to SAT that is a
\ti{special} case of QE (where all variables are quantified), PQE
\ti{generalizes} QE. The latter is just a special case of PQE where $G = F$
and the entire formula is
unquantified. Interpolation~\cite{craig,ken03} is a special case of
PQE as well~\cite{tech_rep_pc_lor} (see also
Appendix~\ref{app:interp}).


The appeal of PQE is threefold. First, it can be much more efficient
than QE if $G$ is a \ti{small} subset of $F$. Second, many
verification problems like SAT, equivalence checking, model checking
can be solved in terms of
PQE~\cite{hvc-14,south_korea,fmcad16,mc_no_inv2}. So, PQE can be used
to design new efficient methods for solving known problems. Third, one
can apply PQE to solving \ti{new} problems like property generation
considered in this paper. In practice, to perform PQE, it suffices to
have an algorithm that takes a single clause out of the scope of
quantifiers. Namely, given a formula \prob{X}{F(X,Y)} and a clause
$C \in F$, this algorithm finds a formula $H(Y)$ such that
$\prob{X}{F} \equiv H \wedge \prob{X}{F \setminus \s{C}}$. To take out
$k$ clauses, one can apply this algorithm $k$ times.  Since
$H \wedge \prob{X}{F} \equiv H\wedge \prob{X}{ F \setminus \s{C}}$,
solving the PQE above reduces to finding $H(Y)$ that makes
$C$ \ti{redundant} in $H \wedge \prob{X}{F}$. So, the PQE algorithms
we present here employ \ti{redundancy based reasoning}.  Namely, we
describe two PQE algorithms called \Eg and \egp where ``\ti{EG}''
stands for ``Enumerate and Generalize''. \Eg is a very simple
SAT-based algorithm that can sometimes solve very large problems. \egp
is a modification of \Eg that makes the algorithm more powerful and
robust.

In~\cite{fmcad16}, we showed the viability of an equivalence checker
based on PQE.  In particular, we presented instances for which this
equivalence checker outperformed ABC~\cite{abc}, a high quality
tool. In this paper, we describe and check experimentally one more
important application of PQE called property generation.  Our
motivation here is as follows. Suppose a design
implementation \ti{Imp} meets the set of specification properties
$P_1,\dots,P_m$.  Typically, this set is incomplete. So, \ti{Imp} can
still be buggy even if every $P_i,i=1,\dots,m$ holds.  Let
$P^*_{m+1},\dots,P^*_n$ be \ti{desired} properties adding which makes
the specification complete. If \ti{Imp} meets the properties
$P_1,\dots,P_m$ but is still buggy, a missed property $P^*_i$ above
fails. That is, \ti{Imp} has the \ti{unwanted} property
$\overline{P^*_i}$. So, one can detect bugs by generating unspecified
properties of \ti{Imp} and checking if there is an unwanted one.

Currently, identification of unwanted properties is mostly done by
massive testing. (As we show later, the input/output behavior
specified by a single test can be cast as a simple property
of \ti{Imp}.) Another technique employed in practice is \ti{guessing}
a list of unwanted properties that may hold and formally checking if
this is the case.  The problem with these techniques is that they can
miss an unwanted property. In this paper, we describe property
generation by PQE.  The benefit of PQE is that it can produce much
more complex properties than those corresponding to single tests. So,
using PQE one can detect bugs that testing overlooks or cannot find in
principle. Importantly, PQE generates properties covering different
parts of \ti{Imp}. This makes the search for unwanted properties more
systematic and facilitates discovering bugs that can be missed if one
simply guesses unwanted properties that may hold.

In this paper, we experimentally study generation of invariants of a
sequential circuit $N$. An invariant of $N$ is unwanted if a state
that is supposed to be reachable in $N$ falsifies this invariant and
hence is unreachable. Note that finding a formal proof that $N$ has no
unwanted invariants is impractical. (It is hard to efficiently prove a
large set of states reachable because different states are reached by
different execution traces.)  So developing practical methods for
finding unwanted invariants if very important. We also study
generation of properties mimicking symbolic simulation for a
combinational circuit obtained by unrolling a sequential circuit. An
unwanted property here exposes a wrong execution trace.



The main body of this paper is structured as follows. (Some additional
information can be found in appendices.) In Section~\ref{sec:basic},
we give basic definitions. Section~\ref{sec:prop_gen} presents
property generation for a combinational circuit. In
Section~\ref{sec:inv_gen}, we describe invariant generation for a
sequential circuit. Sections~\ref{sec:eg_pqe} and~\ref{sec:eg_pqe+}
present \Eg and \egp respectively.  In Section~\ref{sec:fifo_exper},
invariant generation is used to find a bug in a FIFO buffer.
Experiments with invariant generation for HWMCC benchmarks are
described in Section~\ref{sec:inv_gen_exper}.
Section~\ref{sec:comb_exper} presents an experiment with property
generation for combinational circuits.  In Section~\ref{sec:bg} we
give some background. Finally, in Section~\ref{sec:concl}, we make
conclusions and discuss directions for future research.
%\clearpage

