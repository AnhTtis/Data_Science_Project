%\section{Invariant Generation For Bug Detection}
\section{Invariant Generation By PQE}
\label{sec:inv_gen}
In this section, we extend property generation for combinational
circuits to sequential ones. Namely, we generate \ti{invariants}. Note
that generation of \ti{desired} auxiliary invariants is routinely used
in practice to facilitate verification of a predefined property. The
problem we consider here is different in that our goal is to produce
an \ti{unwanted} invariant. We picked generation of invariants (over
that of weaker properties just claiming that a state cannot be reached
in $k$ transitions or less) because identification of an unwanted
invariant is, arguably, easier. This simplifies bug detection by
property generation.

%
% Subsection
%
\subsection{Bugs making states unreachable}
\label{ssec:unr_bugs}
Let $N$ be a sequential circuit and $S$ denote the state variables of
$N$. Let $I(S)$ specify the initial state \pqnt{s}{ini} (\ie
$I(\pqnt{s}{ini})\!=\!1$). Let $T(S',V,S'')$ denote the transition
relation of $N$ where $S',S''$ are the present and next state
variables and $V$ specifies the (combinational) input variables. We
will say that a state \pnt{s} of $N$ is reachable if there is an
execution trace leading to \pnt{s}. That is, there is a sequence of
states $\pnt{s_0},\dots,\pnt{s_k}$ where $\pnt{s_0} = \pqnt{s}{ini}$,
$\pent{s}{k}\!=\!\pnt{s}$ and there exist \pent{v}{i}
$i=0,\dots,k\!-\!1$ for which $T(\pent{s}{i},\pent{v}{i},
\pent{s}{i+1}) = 1$.  Let $N$ have to satisfy a set of \tb{invariants}
$P_0(S),\dots,P_m(S)$. That is, $P_i$ holds iff $P_i(\pnt{s}) = 1$ for
every reachable state \pnt{s} of $N$. We will denote the \tb{aggregate
  invariant} $P_0 \wedge \dots \wedge P_m$ as \bm{\Sub{P}{agg}}. We
will call \pnt{s} a \tb{bad state} of $N$ if
$\Sub{P}{agg}(\pnt{s})=0$. If \Sub{P}{agg} holds, no bad state is
reachable. We will call \pnt{s} a \tb{good state} of $N$ if
$\Sub{P}{agg}(\pnt{s}) = 1$.

Typically, the set of invariants $P_0,\dots,P_m$ is incomplete in the
sense that it does not specify all states that must be
\ti{unreachable}. So, a good state can well be unreachable. We will
call a good state \tb{operative} (or \tb{op-state} for short) if it is
supposed to be used by $N$ and so should be \ti{reachable}. We
introduce the term \ti{an operative state} just to factor out
``useless'' good states. We will say that $N$ has an \tb{op-state
  reachability bug} if an op-state is unreachable in $N$. In
Section~\ref{sec:fifo_exper}, we consider such a bug in a FIFO
buffer. The fact that \Sub{P}{agg} holds says \ti{nothing} about
reachability of op-states. Consider, for instance, a trivial circuit
\Sub{N}{triv} that simply stays in the initial state \pqnt{s}{ini} and
$\Sub{P}{agg}(\pqnt{s}{ini})=1$. Then \Sub{P}{agg} holds for
\Sub{N}{triv} but the latter has op-state reachability bugs (assuming
that the correct circuit must reach states other than \pqnt{s}{ini}).

Let $R_{\vv{s}}(S)$ be the predicate satisfied only by a state
\pnt{s}. In terms of CTL, identifying an op-state reachability bug
means finding \pnt{s} for which the property $EF.R_{\vv{s}}$ must hold
but it does not.  The reason for assuming \pnt{s} to be \ti{unknown}
is that the set of op-states is typically too large to \ti{explicitly}
specify every property $ET.R_{\vv{s}}$ to hold. This makes finding
op-state reachability bugs very hard. The problem is exacerbated by
the fact that reachability of different states is established by
\ti{different traces}. So, in general, one cannot efficiently prove
many properties $EF.R_{\vv{s}}$ (for different states) \ti{at once}.


%
% Subsection
%
%\subsection{Finding valid-state unreachability bugs by invariant generation}
\subsection{Proving op-state unreachability  by invariant generation}
\label{ssec:check_unreach}
In practice, there are two methods to check reachability of operative
states for large circuits.  The first method is testing. Of course,
testing cannot prove a state unreachable, however, the examination of
execution traces may point to a potential problem. (For instance,
after examining execution traces of the circuit \Sub{N}{triv} above
one realizes that many operative states look unreachable.) The other
method is to check \tb{unwanted invariants}, \ie those that are
supposed to fail. If an unwanted invariant holds for a circuit, the
latter has an op-state reachability bug. For instance, one can check
if a state variable $s_i \in S$ of a circuit never changes its initial
value. To break this unwanted invariant, one needs to find an
operative state where the initial value of $s_i$ is flipped. (For the
circuit \Sub{N}{triv} above this unwanted invariant holds for every
state variable.) The potential unwanted invariants are formed
manually, \ie simply \ti{guessed}.

The two methods above can easily overlook an op-state reachability
bug.  Testing cannot prove that an op-state is unreachable. To
correctly guess an unwanted invariant that holds, one essentially has
to know the underlying bug. Below, we describe a method for invariant
generation by PQE that is based on property generation for
combinational circuits.  The appeal of this method is twofold.  First,
PQE generates invariants ``inherent'' to the implementation at hand,
which drastically reduces the set of invariants to explore. Second,
PQE is able to generate invariants related to different parts of the
circuit (including the buggy one).  This increases the probability of
generating an unwanted invariant. We substantiate this intuition in
Section~\ref{sec:fifo_exper}.


Let formula \bm{F_k} specify the combinational circuit obtained by
unfolding a sequential circuit $N$ for $k$ time frames and adding the
initial state constraint $I(S_0)$. That is, $F_k = I(S_0) \wedge
T(S_0,V_0,S_1) \wedge \dots \wedge T(S_{k-1},V_{k-1},S_k)$ where $S_j,
V_j$ denote the state and input variables of $j$-th time frame
respectively. Let $H(S_k)$ be a solution to the PQE problem of taking
a clause $C$ out of \prob{\Abs{k}}{F_k} where $\Abs{k} = S_0 \cup V_0
\cup \dots \cup S_{k-1} \cup V_{k-1}$.  That is, \prob{\Abs{k}}{F_k}
$\equiv H \wedge$ \prob{\Abs{k}}{F_k \setminus \s{C}}. Note that in
contrast to Section~\ref{sec:prop_gen}, here some external variables
of the combinational circuit (namely, the input variables
$V_0,\dots,V_{k-1}$) are quantified too. So, $H$ depends only on state
variables of the last time frame. $H$ can be viewed as a \tb{local
  invariant} asserting that no state falsifying $H$ can be reached in
$k$ transitions.

One can use $H$ to find global invariants (holding for \ti{every} time
frame) as follows.  Even if $H$ is only a local invariant, a clause
$Q$ of $H$ can be a \ti{global} invariant.  The experiments of
Section~\ref{sec:inv_gen_exper} show that, in general, this is true
for many clauses of $H$. (To find out if $Q$ is a global invariant,
one can simply run a model checker to see if the property $Q$ holds.)
Note that by taking out different clauses of $F_k$ one can produce
global single-clause invariants $Q$ relating to different parts of
$N$. From now on, when we say ``an invariant'' without a qualifier we
mean a \tb{global invariant}.
