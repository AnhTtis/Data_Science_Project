\section{Experiments With HWMCC Benchmarks}
\label{sec:inv_gen_exper}

In this section, we describe three experiments with 98 multi-property
benchmarks of the HWMCC-13 set~\cite{hwmcc13}.  (We use this set
because it has a multi-property track, see the explanation below.)
The number of latches in those benchmarks range from 111 to 8,000.
More details about the choice of benchmarks and the experiments can be
found in Appendix~\ref{app:exper2}. Each benchmark consists of a
sequential circuit $N$ and invariants $P_0,\dots,P_m$ to prove. Like
in Section~\ref{sec:inv_gen}, we call $\Sub{P}{agg}=P_0 \wedge \dots
\wedge P_m$ the \ti{aggregate invariant}.  In experiments 2 and 3 we
used PQE to generate new invariants of $N$. Since every invariant $P$
implied by \Sub{P}{agg} is a desired one, the necessary condition for
$P$ to be \ti{unwanted} is $\Sub{P}{agg} \not\imp P$. The conjunction
of many invariants $P_i$ produces a stronger invariant \Sub{P}{agg},
which makes it \ti{harder} to generate $P$ not implied by
\Sub{P}{agg}. (This is the reason for using multi-property benchmarks
in our experiments.)  The circuits of the HWMCC-13 set are
\ti{anonymous}, so, we could not know if an unreachable state is
supposed to be reachable.  For that reason, we just generated
invariants not implied by \Sub{P}{agg} without deciding if some of
them were unwanted.

Similarly to the experiment of Section~\ref{sec:fifo_exper}, we used
the formula $F_k = I(S_0) \wedge T(S_0,V_0,S_1)$ $\wedge \dots \wedge
T(S_{k-1},V_{k-1},S_k)$ to generate invariants. The number $k$ of time
frames was in the range of \mbox{$2\!\leq\!k\!  \leq\!10$}.  As in the
experiment of Section~\ref{sec:fifo_exper}, we took out only clauses
containing a state variable of the $k$-th time frame. In all
experiments, the \tb{time limit} for solving a PQE problem was set to
10 sec.

%
% Subsection: Experiment 1
%
\subsection{Experiment 1}
In the first experiment, we generated a \ti{local invariant} $H$ by
taking out a clause $C$ of \prob{\Abs{k}}{F_k} where $\Abs{k}=S_0 \cup
V_0 \cup \dots \cup S_{k-\!1}\cup V_{k-\!1}$.  The formula $H$ asserts
that no state falsifying $H$ can be reached in $k$ transitions. Our
goal was to show that PQE can find $H$ for large formulas $F_k$ that
have hundreds of thousands of clauses.  We used \Eg to partition the
PQE problems we tried into two groups.  \ti{The first group} consisted
of 3,736 problems for which we ran \Eg with the time limit of 10
sec. and it never encountered a subspace \pnt{s_k} where $F_k$ was
satisfiable.  Here \pnt{s_k} is a full assignment to $S_k$. Recall
that only the variables $S_k$ are unquantified in
\prob{\Abs{k}}{F_k}. So, in every subspace \pnt{s_k}, formula $F_k$
was either unsatisfiable or $(F_k \setminus \s{C}) \imp C$. (The fact
that so many problems meet the condition of the first group came as a
big surprise.) \ti{The second group} consisted of 3,094 problems where
\Eg encountered subspaces where $F_k$ was satisfiable.

For the first group, \dpqe finished only 30\% of the problems within
10 sec. whereas \Eg and \egp finished 88\% and 89\% respectively. The
poor performance of \dpqe is due to not checking if $(F_k \setminus
\s{C}) \imp C$ in the current subspace. For the second group, \dpqe,
\Eg and \egp finished 15\%, 2\% and 27\% of the problems respectively
within 10 sec. \Eg finished far fewer problems because it used a
satisfying assignment as a proof of redundancy of $C$ (see
Subsection~\ref{ssec:disc2}).


To contrast PQE and QE, we employed a high-quality tool
\cad~\cite{cadet_qe,cadet_imp} to perform QE on the 98 formulas
\prob{\Abs{k}}{F_k} (one formula per benchmark).  That is, instead of
taking a clause out of \prob{\Abs{k}}{F_k} by PQE, we applied \cad to
perform full QE on this formula. (Performing QE on \prob{\Abs{k}}{F_k}
produces a formula $H(S_k)$ specifying \ti{all} states unreachable in
$k$ transitions.)  \cad finished only 25\% of the 98 QE problems with
the time limit of 600 sec. On the other hand, \egp finished 60\% of
the 6,830 problems of both groups (generated off \prob{\Abs{k}}{F_k})
within 10 sec. So, PQE can be much easier than QE if only a small part
of the formula gets unquantified.



%
% Subsection: Experiment 2
%
\subsection{Experiment 2}
The second experiment was an extension of the first one. Its goal was
to show that PQE can generate invariants for realistic designs.  For
each clause $Q$ of a local invariant $H$ generated by PQE we used \ict
to verify if $Q$ was a global invariant.  If so, we checked if
$\Sub{P}{agg} \not\imp Q$ held. To make the experiment less time
consuming, in addition to the time limit of 10 sec. per PQE problem we
imposed a few more constraints.  The PQE problem of taking a clause
out of \prob{\Abs{k}}{F_k} terminated as soon as $H$ accumulated 5
clauses or more. Besides, processing a benchmark aborted when the
summary number of clauses of all formulas $H$ generated for this
benchmark reached 100 or the total run time of all PQE problems
generated off \prob{\Abs{k}}{F_k} exceeded 2,000 sec.

\input{a0ll_inv_gen.tbl}

Table~\ref{tbl:all_inv_gen} shows the results of the experiment. The
third column gives the number of local single-clause invariants (\ie
the total number of clauses in all $H$ over all benchmarks). The
fourth column shows how many local single-clause invariants turned out
to be global. (Since global invariants were extracted from $H$ and the
summary size of all $H$ could not exceed 100, the number of global
invariants per benchmark could not exceed 100.) The last column gives
the number of global invariants not implied by \spe. So, these
invariants are candidates for checking if they are
unwanted. Table~\ref{tbl:all_inv_gen} shows that \Eg and \egp
performed much better than \dpqe.


%
% Subsection: Experiment 3
%
\subsection{Experiment 3}
\label{ssec:ic3_invars}
To prove an invariant $P$ true, \ict conjoins it with clauses
$Q_1\!,\dots,\!Q_n$ to make $P\!\wedge Q_1\!\wedge \dots \wedge Q_n$
inductive.  If \ict succeeds, every $Q_i$ is an invariant. Moreover,
$Q_i$ may be an \ti{unwanted} invariant. The goal of the third
experiment was to demonstrate that PQE and \ict, in general, produce
different invariant clauses. The intuition here is twofold. First,
\ict generates clauses $Q_i$ to prove a \ti{predefined} invariant
rather than find an unwanted one. Second, the closer $P$ to being
inductive, the fewer new invariant clauses are generated by
\ict. Consider the circuit \Sub{N}{triv} that simply stays in the
initial state \pqnt{s}{ini} (Section~\ref{sec:inv_gen}). Any invariant
satisfied by \pqnt{s}{ini} is already \ti{inductive} for
\Sub{N}{triv}. So, IC3 will not generate \ti{a single new invariant}
clause. On the other hand, if the correct circuit is supposed to leave
the initial state, \Sub{N}{triv} has unwanted invariants that our
method will find.

In this experiment, we used \ict to generate $P^*_{\mi{agg}}$, an
\ti{inductive} version of \Sub{P}{agg}. The experiment showed that in
88\% cases, an invariant clause generated by \egp and not implied by
\Sub{P}{agg} was not implied by $P^*_{\mi{agg}}$ either.  (See
Appendix~\ref{ssec:exper3} for more detail.) 
%\clearpage
