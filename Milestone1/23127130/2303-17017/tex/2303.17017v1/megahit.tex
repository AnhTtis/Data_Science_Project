\caption{}
\label{alg:open}

\begin{algorithmic}[1]

\Function{\texttt{$\mathtt{MergingAlgorithm}$}}{$\mathbf{A}$, $R$}\Comment{$\mathbf{A}$ is an algebra and \texttt{$R$} is a relation
over $A$}

	\State{$\mathtt{targets}=(R_{1},\ldots,R_{l})$ $R_{j}$'s
are all the distinct relations of the form $\left\lfloor R_{\pat\bar{a}}\right\rfloor $
for $\bar{a}\in R$.}

	\State{$\mathtt{spec}=\mathtt{sorted}(\spec(R))$}\Comment{sorted
increasingly}

	\For{$k\in\mathtt{spec}$}

		\State{$\mathtt{orbits}_{k}=\{(\{\bar{a}\},\text{relType}(\bar{a},\mathtt{targets}),\unk,\unk):\bar{a}\in A^{(k)}\}$}\Comment{initialization}

	\EndFor

	\State{$\mathtt{orbits}=\{\mathtt{orbits}_{k}:k\in\mathtt{spec}\}$}

	\State{$\mathtt{tuples\_to\_process}=\mathtt{sorted}(\bigcup_{k\in\mathtt{spec}}A^{(k)})$}\Comment{sorted
decreasingly by arity}

	\State{$\mathtt{stack}=[(A,\mathtt{tuples\_to\_process},\emptyset)]$}\Comment{initialization
of the stack}

	\While{$\mathtt{stack}$ is not empty}

		\State{Let $(\text{\texttt{current\_sub}},\text{\texttt{tuples\_to\_process}},\text{\texttt{generators}})$ reference the top of \texttt{stack}}

		\While{$\text{\texttt{tuples\_to\_process}}\neq[\ ]$}

			\State{$\bar{a}=\text{pop first element of }\mathtt{tuples\_to\_process}$}

			\If{$\type(\bar{a})=\unk$}\Comment{$\bar{a}$'s type is unknown}

				\State{$(\mathtt{type\_a},\mathtt{universe\_a})=\mathtt{IsoType}(\boldsymbol{A},\bar{a})$}

				\If{$|\mathtt{universe\_a}|=|\mathtt{current\_sub}|$}\Comment{$\sg(\bar{a})$
is not smaller}

					\If{$\exists$ $(\mathtt{B},\mathtt{RT},\mathtt{T},\mathtt{U})\in\{\text{orbits in }\mathtt{generators}\}$
such that $\mathtt{type\_a}=\mathtt{T}$ }

						\State{$\gamma=$ the isomorphism from $\mathtt{universe\_a}$
to $\mathtt{U}$}

						\If{\texttt{not }$\mathtt{try\_merge\_orbits}(\gamma,\mathtt{orbits})$}\Comment{see
Algorithm \ref{alg:propagar}}

							\State{\Return $\false$}
						\EndIf

					\Else\Comment{$\bar{a}$'s type is new}

						\State{$\mathtt{tag\_orbit}(\bar{a},\mathtt{type\_a},\mathtt{universe\_a})$}\label{tag_orbit no achica}

						\State{$\text{add }\bar{a}\text{ to }\mathtt{generators}$}

					\EndIf

				\Else\Comment{$\sg(\bar{a})$ is smaller}

					\If{there is $(\mathtt{B},\mathtt{RT},\mathtt{T},\mathtt{U})\in\mathtt{orbits}_{|\bar{a}|}$
such that $\mathtt{type\_a}=\mathtt{T}$}\Comment{not new}

						\State{$\gamma=$ the isomorphism from $\mathtt{universe\_a}$
to $\mathtt{U}$}

						\If{\texttt{not }$\mathtt{try\_merge\_orbits}(\gamma,\mathtt{orbits})$}\Comment{see
Algorithm \ref{alg:propagar}}

							\State{\Return $\false$}

						\EndIf

					\Else\Comment{$\bar{a}$'s type is new}

						\State{$\mathtt{tag\_orbit}(\bar{a},\mathtt{type\_a},\mathtt{universe\_a})$}\Comment{then push new node on \texttt{stack}}

						

						\State{push $(\mathtt{universe\_a},\mathtt{sorted}(\bigcup_{k\in\mathtt{spec}}\mathtt{universe\_a}^{(k)}),\{\bar{a}\})$ %onto \texttt{stack}
}
						\State{$\mathtt{tag\_orbit}(\bar{a},\mathtt{type},\mathtt{universe})$}\label{tag_orbit achica}

						\State{$\breakk$}

					\EndIf

				\EndIf

			\EndIf

		\EndWhile

		\If{$\mathtt{tuples\_to\_process}=[\ ]$}

			\State{delete top of the \texttt{stack}}

		\EndIf

	\EndWhile

\State{\Return $\true$}

\EndFunction

\end{algorithmic}