\section{The Cosmos Ecosystem}

Cosmos is a network (also referred to as an ecosystem) of independent application-specific blockchains, called zones, interconnected through blockchains named hubs. Cosmos zones are powered by Tendermint BFT, a deterministic, partially synchronous consensus engine~\cite{buchman2018latest}. Hubs represent points of connection between zones, allowing the transfer of information. Different zones can communicate via the Inter-Blockchain Communication (IBC) protocol~\cite{goes2020interblockchain}.

Cosmos provides a modular open-source framework, the Cosmos SDK, for the development of both permissioned and permissionless blockchains and applications. 
The Cosmos SDK enables developers to build on top of the Tendermint platform and aims to shorten development time by providing access to open-source composable modules that implement common blockchain functionalities such as token minting, token transfers, staking and punishment for misbehaviour.

\subsection{Tendermint}

Tendermint is a blockchain platform that provides a consensus engine called Tendermint Core and an interface called Application BlockChain Interface (ABCI). Tendermint Core consists of a Byzantine Fault Tolerant, deterministic and partially synchronous consensus engine. It also provides a peer-to-peer networking protocol which enables blockchain nodes to communicate. Tendermint's ABCI provides a generic interface that allows blockchain applications to interact with the consensus engine provided by Tendermint Core.


Tendermint's consensus engine provides a protocol through which network participants called validators can cooperate to append information to the blockchain and update its state. The protocol can tolerate arbitrary behavior from up to one third of the network's validators while still guaranteeing consistency of state among honest nodes. 

The protocol to achieve consensus is executed in rounds.
In each round one participant from the validator set is elected as a proposer and gets to suggest a block of transactions for the current blockchain height. The remaining validators take part in two stages of voting, named pre-voting and pre-commiting, to decide whether to accept the proposed block or not. 
As soon as 2/3 of the validators cast their pre-vote for the same block, the protocol can receive pre-commits.
If a block receives pre-commits from 2/3 of the validators before the end of the round, it is appended to the blockchain and the state of the ledger is updated based on its contents. If timeout is reached during a round and validators do not agree on a new block, the protocol advances to the next round and a new validator has the chance to propose a block. 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.99\columnwidth]{figures/tendermint_block_structure.pdf}
  \caption{Structure of a Tendermint block.}
  \label{fig:tendermint_block}
\end{figure}


We show the structure of a Tendermint block in Figure \ref{fig:tendermint_block}. A block is divided into four main fields, the \textit{Header}, the \textit{Data} field, the \textit{Evidence} field and the \textit{LastCommit} field. Except for the \textit{Data} field, Tendermint performs validation on all the fields that compose a block. Transaction data is application-specific and unknown to Tendermint, hence it is a responsibility of the blockchain application to perform the validation of this data.

The \textit{Header} contains information regarding the block and its position on the chain, as well as metadata related to consensus, validator set and the blockchain application. The \textit{Data} field contains the set of transactions chosen by the block proposer and agreed upon by the consensus validators. Proofs of malicious activity carried out by members of the validator set are included in the \textit{Evidence} field. Those proofs can be used by the blockchain application to punish actors who deviate from the protocol. This field is empty in the absence of misbehavior.

Lastly, the \textit{LastCommit} field contains the votes from the participants of the validator set. It contains data regarding block height, consensus round information, a \textit{BlockID} of the corresponding block and an array of validator signatures. The signatures include the \textit{BlockIDFlag}, indicating whether the validator voted for the block accepted by the majority of validators, \textit{nil}, for a different block or did not cast a vote. Together with a vote, a validator's address, timestamp and commitment signature are included.


\subsection{IBC Protocol}


The Inter-Blockchain Communication protocol is an open-source, end-to-end, payload agnostic protocol that provides reliable and authenticated message passing between IBC modules residing in distinct blockchains~\cite{goes2020interblockchain}. Aside from a set of functions described in the interchain standard that describes host requirements (ICS 24)\footnote{https://github.com/cosmos/ibc/tree/master/spec/core/ics-024-host-requirements}, no other prerequisites are imposed on the host blockchains.

Data transported across blockchain modules is opaque to the IBC protocol and only needs to be readable by the sending and receiving applications. This makes the protocol flexible and enables it to be applied for a variety of use cases such as fungible token transfers, deployment of multi-chain contracts, multi-chain account management and cross-chain data sharing.

The IBC protocol handles authentication, ordering and transport of data, but it does not have access to a transport layer to deliver data to other blockchains. Hence, in order to communicate using IBC, blockchains require access to external applications, called relayers, with access to network infrastructure and communication protocols such as TCP/IP.

Relayers are off-chain processes responsible for scanning blockchain data to identify messages that need to be delivered to another blockchain.
When pending messages are found, the relayer retrieves them from the blockchain, transforms them into IBC datagrams and delivers them to their destination.

\subsubsection{IBC Channel Setup}

Blockchains can only communicate via IBC once a channel is established between them. Channels function as routes between communicating blockchain modules and, as per the IBC protocol's definitions, are responsible for providing ordering, exactly-once delivery and controlling the permissions that determine which modules are able to send and receive packets.


To open an IBC channel, a \textit{connection} between the pair of communicating blockchains is required. Connections are established through a handshaking process and require both blockchains to run a light client of the counterparty chain. Light clients keep track of the consensus information of the blockchain they are monitoring and enable the verification of state updates. 
Once the light clients are running, the blockchains can open a \textit{connection} enabling access to authorised communication.

After going through the handshaking process and establishing a \textit{connection}, a pair of communicating blockchains can open a \textit{channel} through which they can send and receive IBC packets. Channels can be either ordered, delivering packets in the order they are sent, or unordered, where packets are delivered in any order. Two blockchains can open multiple \textit{channels} using a single \textit{connection}. 

\subsubsection{The IBC packet life cycle}

IBC messages must be included in the blockchain before being sent through a cross-chain channel. The relayer application scans new blocks appended to the blockchain looking for transactions with IBC messages addressed to the channels it relays for. Upon finding pending messages, the relayer extracts their information from the blockchain, builds IBC packets and delivers them to the destination blockchain. A cross-chain transfer requires the inclusion of 3 messages in the communicating blockchains to be completed, namely, the transfer message (\textit{MsgTransfer}), the receive message (\textit{MsgRecvPacket}) and the acknowledgement message (\textit{MsgAcknowledgement}). The transfer message requests a fungible token transfer and stores a proof of commitment to the packet data and packet timeout in the sending blockchain. Upon receiving a packet with a transfer request, the blockchain to which it is addressed verifies the packet commitment proof in the state of the sending chain and includes a transaction containing a receive message to accept it. Based on the receive message, an acknowledgement is sent back to the blockchain that initiated the transfer. Upon receiving the acknowledgement, the blockchain verifies that a proof of acknowledgement was stored in the receiving chain and includes a transaction with an acknowledgement message. It is worth emphasizing that relayers must be connected to full nodes of both blockchains to execute queries for transaction data and relay packets.

We show the flow of a packet sent via the IBC protocol in Figure \ref{fig:ibc_packet_flow}. Let blockchain$_{A}$ and blockchain$_{B}$ be a pair of blockchains. Blockchain$_{A}$ runs application$_{A}$ and implements a module that handles inter-blockchain communication, called IBC module$_{A}$. Similarly, blockchain$_{B}$ runs application$_{B}$  and implements IBC module$_{B}$.

\begin{figure}[!htb]
  \center
  \hspace*{.3cm}
  \includegraphics[scale=0.38]{figures/ibc_packet_flow.pdf}
  \caption{IBC protocol packet flow (sucessful).}
  \label{fig:ibc_packet_flow}
\end{figure}

Firstly, a user requests application$_{A}$ to send a packet to application$_{B}$. Application$_{A}$ then calls the \textit{SendPacket} function implemented by IBC module$_{A}$ on the same blockchain. IBC module$_{A}$ stores a commitment to the outgoing packet and its timeout. This commitment is added to the state of the blockchain. 
Secondly, the relayer application queries the blockchain for pending messages and retrieves the information it needs to construct the corresponding IBC packet. Once the relayer has a packet ready for delivery, the receiving module on the destination blockchain, IBC module$_{B}$, triggers the \textit{RecvPacket} function. 
Thirdly, the receiving module verifies the packet's timeout and the commitment in the source chain. If the data is successfully validated, the module routes the packet to application$_{B}$. Fourthly, application$_{B}$ processes the operations contained in the packet's data and sends an acknowledgement back to IBC module$_{B}$. Fifthly, this module stores a commitment acknowledging that application$_{B}$ has received the packet from application$_{A}$. This commitment is stored in the state of the blockchain and is then queried by the relayer application. Next, the relayer builds an \textit{AcknowledgePacket} and delivers it to IBC module$_{A}$ in the source blockchain. At this point, packet commitments stored by the module can be deleted since the packet has been successfully delivered.

\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.38]{figures/ibc_packet_flow_timeout.pdf}
  \caption{IBC Protocol packet flow (timeout).}
  \label{fig:ibc_packet_flow_timeout}
\end{figure}

Due to the nature of network asynchrony, packets may not be delivered before timing out. Timeouts can also be triggered when the receiving blockchain module does not accept the incoming packet. We illustrate the IBC packet with expired timeout in Figure \ref{fig:ibc_packet_flow_timeout}. 
Application$_{A}$ calls the \textit{SendPacket} function and IBC module$_{A}$ stores the packet commitment and timeout. However, it fails to be delivered to the destination module on blockchain$_{B}$ before it reaches the specified timeout. The relayer application identifies that the packet can no longer be accepted by the destination and sends a query to IBC module$_{B}$ asking for a proof that it has not been received. This information is sent back to IBC module$_{A}$ in the source blockchain and used to trigger the \textit{OnPacketTimeout} function. This function implements the logic for undoing operations executed before packet commitment, such as unlocking assets that were previously held locked while the transfer request was pending.


\subsection{Hermes Relayer}

The Hermes Relayer\footnote{https://github.com/informalsystems/hermes} is an open-source implementation of an IBC relayer written using the Rust programming language. It is one of the two IBC relayers that are currently under active development, the other being the Golang Relayer\footnote{https://github.com/cosmos/ibc-go}.
We chose to use the Hermes Relayer in our analysis of cross-chain communication for three reasons. First, it offers comprehensive documentation. Second, it provides extensive event logging capabilities, a feature that is essential for performance analysis. Lastly, at the time of writing, this relayer offers more features and is updated more often than the Golang Relayer. 

In Figure \ref{fig:hermes_architecture}
we present an overview of the  Hermes Relayer's architecture. The Supervisor subscribes to events generated by blockchain full nodes. Each event is forwarded to the Packet Command Worker associated with its cross-chain channel. The Packet Command Worker schedules relayer tasks and assigns them to Packet Workers. Upon completing the assigned tasks, Packet Workers forward the resulting data to the Chain Endpoint, which interfaces directly with the destination blockchain through a full node. We refer the reader to the developer's overview~\cite{hermesv1architecture} for an in-depth discussion of the Hermes Relayer's architecture.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.98\linewidth]{figures/hermes_architecture.pdf}
  \caption{Architectural overview of the Hermes Relayer.}
  \label{fig:hermes_architecture}
\end{figure}


