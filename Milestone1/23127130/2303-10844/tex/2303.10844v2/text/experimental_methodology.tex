\section{Experimental Methodology}\label{sec:experimental_methodology}


We first introduce a novel framework for evaluating cross-chain communication protocols. 
We provide a first instantiation of our framework as a tool for evaluating the performance of the IBC protocol when used for cross-chain communication between two Cosmos Gaia blockchains.
Our tool provides assistance in experiment setup, execution, data collection and data analysis. For our experiments we set up a private testnet environment and use it to measure the performance of the IBC protocol under different scenarios.

\subsection{Cross-chain Performance Evaluation Framework}

We present our framework for evaluating the performance of cross-chain communication protocols in Figure \ref{fig:cc_framework}. To the best of our knowledge, this is the first framework to guide empirical evaluation of cross-chain communication performance.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.98\linewidth]{figures/cc_evaluation_framework.pdf}
  \caption{Cross-chain performance evaluation framework.}
  \label{fig:cc_framework}
\end{figure}

Our framework introduces four new key components, namely the \textit{ Cross-chain Communicator}, \textit{Cross-chain Data Connector}, \textit{Cross-chain Event Connector} and the \textit{Cross-chain Event Processor}. The \textit{Cross-chain Communicator} enables data transfer between blockchains; the \textit{Cross-chain Data Connector} is required to retrieve data from different communicating blockchains concurrently; the \textit{Cross-chain Event Connector} monitors and collects events associated with cross-chain communication, both from the communicating blockchains and from the \textit{Cross-chain Communicator} component; and the \textit{Cross-chain Event Processor} aggregates and interprets cross-chain communication events and their corresponding steps.

Our framework has three main modules, namely \textit{Setup}, \textit{Benchmark} and \textit{Analysis}. The \textit{Setup} module provides flexibility and automation for deploying blockchains with user-chosen parameters. This module is also responsible for configuring and deploying the \textit{Cross-chain Communicator} (e.g, relayers for IBC). If evaluating cross-chain communications in an already deployed environment, the \textit{Setup} can be skipped. 

The \textit{Benchmark} module allows users to evaluate cross-chain communication by executing workloads of different cross-chain operations (e.g, fungible and non-fungible token transfers and cross-chain data queries). It provides the \textit{Cross-chain Workload Connector} component, which uses different resources (e.g., APIs, CLIs) to submit cross-chain operations directly to a blockchain or to an external application (e.g, the Hermes Relayer) that submits it to a blockchain. 

The \textit{Analysis} module processes blockchain and cross-chain communication data to generate performance metrics. This module provides the \textit{Cross-chain Data Connector}, \textit{Cross-chain Event Connector} and \textit{Cross-chain Event Processor}. While in cross-chain communication protocols such as IBC a relayer fulfils the role of the \textit{Cross-chain Communicator}, in Atomic Cross-chain Swaps this role is played by the users participating in the protocol. In the second case the \textit{Cross-chain Event Connector} will retrieve events from the blockchain (e.g, transactions to claim assets from a contract) rather than from the relayer, using the \textit{Cross-chain Data Connector} component.

\subsection{Performance Analysis Tool}\label{sec:tool_design}

As a first instantiation of our framework, we implement a performance analysis tool to evaluate the IBC protocol. Our tool assists with the configuration and automated deployment of the test environment, workload execution and generation of performance metrics.

We implement our \textit{Setup} module to deploy two Cosmos Gaia blockchains and connect them via a cross-chain channel established using the Hermes Relayer. The \textit{Benchmark} module uses cross-chain fungible token transfers and instantiates a \textit{Cross-chain Workload Connector} that binds the workload submission to the Hermes Relayer CLI. For the \textit{Analysis} module, we implement an instance of the \textit{Cross-chain Data Connector} which provides an interface to Tendermint RPC endpoints served by full nodes, allowing us to query data from the communicating blockchains.
We further implement instances of the \textit{Cross-chain Event Connector} and the \textit{Cross-chain Event Processor} to collect and parse logs generated by the Hermes Relayer.

\subsection{Deployment Configuration} 

We set up a private testnet environment composed of two Cosmos Gaia v7.0.3 blockchains, each maintained by five validator nodes. As we show later in Section \ref{sec:performance_evaluation}, the number of consensus nodes has a negligible impact in our analysis as the performance bottlenecks lie in the relayer application and the blockchain's RPC server implementation. The Gaia blockchain natively supports the IBC protocol and was developed to serve as the Cosmos Hub in the Cosmos Network. 

We use Hermes Relayer 1.0.0 to connect the blockchains via an unordered cross-chain channel. The IBC protocol is implemented by application layer modules of the Gaia blockchains and by the Hermes Relayer.
We employ five machines equipped with Intel i7-9700 3GHz processors, 16GB of 2666 MT/s RAM, and 7200RPM HDDs, running the Debian 11 ``bullseye'' operating system and connected to a local area network to run our experiments. We simulate wide area network conditions by enforcing a round-trip latency of 200 milliseconds between any pair of machines, similar to previous works~\cite{yu2019repucoin, kogias2016enhancing, neiheiser2021kauri}. Each machine hosts two full nodes, one validator of the source blockchain and one validator of the destination blockchain. The relayer application is executed in a machine together with two validator nodes, but no more than one instance of the relayer application is executed in each machine. This setup allows the relayer to interact with the blockchain nodes via local endpoints and is recommended for use in production.

While our relayer setup is the same as that of a real application, the number of validators differs, i.e., 5 in our experiments and up to 128 in some blockchains. For a payload of 1024 bytes, consensus latency is approximately 25ms for 5 validators and 110ms for 128 validators~\cite{yin2018hotstuff}. However, we argue that this higher latency has an insignificant impact (approx. 1\%) on the performance of cross-chain communications. For example, completing a single cross-chain transfer (requiring 3 blockchain transactions) takes 21 seconds on average in our experiment. When considering a real application with 128 validators, the added latency for each complete cross-chain transfer is approximately 255ms.

\subsection{Experiment Settings}

We configure the blockchains so that the time interval between the creation of two consecutive blocks is of at least 5 seconds. Blocks containing large amounts of transactions may increase the block interval beyond 5 seconds to allow time for the transactions to be processed. 

We call \textit{source} the blockchain that receives requests to initiate the transfer of tokens (\textit{MsgTransfer}) to another blockchain (referred to as \textit{destination} blockchain). 
Every transaction we submit to the source blockchain contains batches of 100 cross-chain transfer messages. This is the maximum number of messages per transaction allowed by the relayer application. We chose this number of messages for two reasons. First, this facilitates the submission of large amounts of transfers while reducing blockchain transaction processing overhead. Only one transaction has to be validated in order for all the messages within it to be processed. This allows us to include cross-chain transfer requests in the source blockchain at a faster rate, putting  more stress on the relayer application. Second, it helps us in overcoming a limitation\footnote{https://github.com/cosmos/cosmos-sdk/blob/274f389111c323c850c981c\\0de1b7b57eeb23912/x/auth/ante/sigverify.go\#L219-L230} caused by Cosmos blockchains, which restricts the number of transactions each user account (public key) can submit per block to 1. Cosmos' blockchains enforce transaction ordering through the use of account sequence numbers to prevent transaction replay attacks. In its current implementation, this mechanism causes users to have to wait for the confirmation of a submitted transaction before submitting another one with the next sequence number. This prevents us from using multiple transactions from the same user account to increase the number of cross-chain transfer requests within a single block. We use multiple user accounts to submit transactions containing 100 cross-chain transfer messages each to mitigate this problem.


When presenting our experiments, we refer to input rates in terms of requests per second and to throughput in terms of transfers per second. Those input rates correspond to the number of cross-chain transfers we submit per second to the source blockchain in the best case scenario, i.e., when one new block is produced each 5 seconds. If the interval is longer than that, the input rate will be affected. For instance, when the blockchain takes 10 seconds to produce a block, the number of transfers submitted per second is reduced by half. This happens due to the aforementioned limitation on transaction submission, causing the relayer to submit one transaction for each user and wait for its confirmation before submitting the next one. Therefore, a request rate of 1,000 transfers per second corresponds to a batch of 5,000 transfers being submitted every 5 seconds. 
To avoid ambiguity with the widespread abbreviation of transactions per second (TPS), for the remainder of this work we refer to TransFers Per Second as TFPS. 


\subsection{Evaluation Metrics}

In this work we use the following performance metrics to evaluate cross-chain communications:

\begin{itemize}
    \item \textbf{Throughput}: measures how many cross-chain transfers are completed per second. A transfer is considered completed only when all three required steps (\textit{transfer, receive, acknowledge}) are correctly recorded in the blockchain.
    
    \item \textbf{Latency}: measures the amount of time required for an operation to be completed. 
    As cross-chain operations usually require several seconds to be completed because of block intervals, we measure latency in seconds.

    \item \textbf{Relayer scalability:} measures the change in throughput and latency taking into account the number of concurrent relayers working for a cross-chain channel.

    
\end{itemize}