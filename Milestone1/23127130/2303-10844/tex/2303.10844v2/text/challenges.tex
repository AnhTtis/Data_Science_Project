\section{Deployment Challenges}\label{sec:challenges}

In this section we summarize technical challenges faced throughout this work with two goals in mind. First, to further give grounds for some of our design choices and elaborate on the impact they had on our benchmarks. Second, to bring attention to those issues and contribute to the improvement of the affected systems.

\begin{itemize}
    \item \textit{Timestamp mismatch}: Analysis of experimental data revealed a difference between the timestamp of events registered by the Tendermint blockchain and those registered by the relayer application. We observed that events logged by the blockchain are a few seconds behind, e.g, the timestamp for a transaction broadcast recorded by the relayer is set after the same transaction has already been included in the blockchain according to the block timestamp.
    This mismatch in the timestamps recorded by both applications may lead to incorrect metrics if both sources of information are utilized together. For this reason we chose to rely on the timestamps recorded by Hermes for our cross-chain performance analysis.


    \item \textit{Account sequence mismatch}:
    When attempting to create transactions that contain cross-chain messages through the relayer command line interface (CLI), we were unable to submit more than one transaction per block for each user account (public key). Attempting to submit a new transaction from the same account while a previously submitted transaction has not yet been confirmed yields the \textit{``Account sequence mismatch''} error.
    This can be circumvented by issuing multiple transfer messages in the same transaction, allowing a user to perform multiple payments without having to wait for each transaction to be confirmed. In practice, however, this workaround has the downside of requiring the payer to accumulate outgoing transfers in order to include them all in the same transaction. Furthermore, users may be still unable to issue new transactions if a previous one remains awaiting confirmation. To overcome this limitation we chose to use multiple user accounts to submit transactions, allowing us to control the volume of messages submitted per block by changing the number of concurrent users issuing transactions containing transfer messages.
    
    \item \textit{Transaction data collection}:
    During the development of our tool we explored the options provided by the available data endpoints in order to choose the queries that best suited our needs. 
    Retrieving the list of the transaction hashes associated with the transactions included in a block allows us to query the blockchain for those specific transactions and their cross-chain message contents.
    Given the large amount of transactions we generate (e.g., 2250) during benchmark execution, one of our main goals was to minimize the number of queries required for data collection to reduce execution time.
    Upon a careful examination of the queries supported by the Tendermint RPC and the Gaia blockchain we were unable to find an option that returned the list of transaction hashes in a specific block without returning a substantial amount of additional transaction  data. Both the {\tt tx\_search} query parameter from Tendermint RPC and the {\tt query txs --events tx.height=X} from the Gaiad CLI return a large amount of information. For instance, querying a local node for the content of a block that includes 20 transactions with 100 \textit{MsgTransfer} each returned 331,706 lines of output and took an average time of 2.9 seconds to complete using our setup. Querying a block with 20 transactions containing 100 \textit{MsgRecvPacket} each returned 579,919 lines of output and took an average time of 5.7 seconds. 
    It is essential for us to collect the hashes of the transactions contained within a block to perform the our analysis, therefore we chose to use the aforementioned queries despite their negative impact on performance. As such queries may return a substantial amount of data, we had to deal with pagination as some blocks can be too large to fit in a single request. 

    \item \textit{WebSocket space limit}:
    When blocks are minted, the relayer application queries the blockchain to retrieve their contents and identify transactions containing pending IBC messages. If the amount of data to retrieve exceeds the Tendermint Websocket maximum message size (16MB), the relayer emits the \textit{``Failed to collect events''} error. 
    This issue happens every time a block contains a large amount of IBC events, such as transfers, that need to be processed. We observed that when this error is raised, if the relayer packet clear interval is set to 0, pending IBC transfers neither get completed nor fail even when their timeout is exceeded. 
    To analyze the impact this has on packet relaying, we ran an experiment and adjusted the parameters with the intent to trigger this error. 
    We generated a block containing 1,000 cross-chain transactions with 100 IBC transfers each, causing the \textit{``Failed to collect events''} error. From the transactions in this block, 2.5\% were completed successfully, 15.7\% timed out and 81.8\% got stuck, meaning they were committed on the source chain but neither were relayed successfully or timed out, even after four times the number of blocks required for timeout were appended to the chain.
    Shortly after, we submitted multiple transactions containing a single IBC transfer. All single message transfers submitted after the error were committed to the source blockchain, but were not delivered by the relayer, causing them to time out. This indicates that the WebSocket error not only prevents transactions that failed to be collected from being completed, but also impacts future transactions.

    \item \textit{Incomplete logging for blockchain data retrieval}:
    
    By analyzing the execution logs generated by the Hermes Relayer we were able to collect data regarding the operations performed by the application and their timestamps. However, only a fraction of the operations that query the blockchain RPC endpoints for IBC message data are recorded in the logs. This is the operation we are most interested in, given that it is the main bottleneck in the process of cross-chain communication. We observed that the retrieval of data from the first block of transactions in our experiments is correctly logged, but not that of transactions included in subsequent blocks. Upon verification we confirmed that transactions included in subsequent blocks are queried for their data, as their packets get built and delivered by the relayer, despite the data pull operation not being recorded in the logs. We suspect this is caused by an implementation issue. 

    
\end{itemize}