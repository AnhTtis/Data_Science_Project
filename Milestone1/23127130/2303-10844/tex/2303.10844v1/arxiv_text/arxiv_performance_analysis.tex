\section{Performance Evaluation}\label{sec:performance_evaluation}

In this section we assess the performance of the IBC protocol using the tool and metrics presented in Section \ref{sec:experimental_methodology}. We analyze 158GB of data generated through 460 hours of experimentation. Based on our findings, we provide observations on how to improve performance for cross-chain communication. In particular, we show that the main bottleneck lies in the blockchain RPC server's implementation. We also observe that two relayers cannot relay concurrently for the same channel in a coordinated manner due to their inability to communicate with each other. As a consequence, this reduces throughput and hinders scalability in the presence of multiple relayers. Such discoveries are fundamental for the evolution of IBC as well as other cross-chain communication protocols.


\subsection{Throughput}

We analyze the throughput of the different components used to achieve cross-chain communication, namely the Tendermint-based Cosmos Gaia blockchains and the Hermes Relayer. This allows us to identify performance bottlenecks and show how the peak throughput achieved by those components differ.
Specifically, we show that including cross-chain transfer requests in the blockchain can be done at a rate over 10 times faster than the relayer application is able to complete them. This demonstrates that our experiments are stressing the relayer application rather than the blockchains.

\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.76]{arxiv_figures/tendermint_throughput_200ms.pdf}
  \caption{Throughput achieved by the Tendermint blockchain with 5 validator nodes and a network latency of 200ms. Each violin represents the distribution of measurements obtained from 20 executions.}
  \label{fig:tendermint_throughput}
\end{figure}


\textit{\textbf{Tendermint blockchain.}}
We evaluate the throughput of the Tendermint blockchain by using the Hermes Relayer to submit cross-chain transfers at input rates ranging from 250 to 14,000 requests per second (RPS) for 15 consecutive blocks. In this setup we test only the blockchain's capacity to initiate a cross-chain operation by including transfer messages in a block. 
It is worth noting that at 14,000 RPS more than 90\% of the requests fail to be submitted to the blockchain, as we show in Table \ref{table:throughput_errors}.

Figure \ref{fig:tendermint_throughput} shows the throughput achieved by the blockchain with input rates ranging from 250 to 13,000 RPS. We omit results for 14,000 RPS as none of those experiments generated more than 5 consecutive blocks, leading to highly inconsistent results, e.g., throughput of 10,373 TFPS, 605 TFPS and 0 TFPS. Violins in the plot represent the distribution of the measurements obtained from 20 executions using the same input rate. Inside each violin, the continuous line represents the median throughput and the dotted lines above and below it represent the upper and lower quartiles respectively. We begin by measuring the throughput achieved with 250 RPS, which yields roughly 200 TFPS. Throughput rises as we increase the input rate from 500 RPS (350 TFPS) to 3,000 RPS (961 TFPS), peaking at 961 transfers included in the blockchain per second. From 1,000 RPS to 2,000 RPS we observe a slight drop in throughput due to empty blocks, which appear in all experiments with input rates above 2,000 RPS. This is caused by an increase in the amount of processing required by the relayer as the number of requests grows. Increased processing time causes the relayer to miss the transaction submission window, leading consensus validators to agree on an empty block.

\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.76]{arxiv_figures/tendermint_blocktime_200ms.pdf}
  \caption{Average time interval between two consecutive blocks according to cross-chain transfer input rates ranging from 250 to 13,000 RPS.}
  \label{fig:tendermint_block_interval}
\end{figure}


For 3,000 RPS and beyond, the variance in measurements is more than twice that of smaller input rates. We also noticed an increase in block intervals as we continue increasing the rate of requests. This increase is shown in Figure \ref{fig:tendermint_block_interval}. At this point, throughput becomes less consistent across each execution and decreases from 830 TFPS at 4,000 RPS to 499 TFPS at 9,000 RPS. From 10,000 RPS to 13,000 RPS measures become even less consistent due to the high amount of errors raised by the relayer application, such as \textit{account sequence mismatch} and \textit{failed tx: no confirmation}. The \textit{account sequence mismatch} errors are caused by the high volume of transactions being submitted. 

High transaction submission rates stresses the blockchain's RPC endpoint, which is also used to query for confirmed transactions. As a consequence, the relayer cannot reliably confirm submitted transactions and increment sequence numbers, leading transaction submission to fail.

We present the rate of failed transfers for each input rate in Table \ref{table:throughput_errors}. From 250 to 10,000 RPS the relayer is able to submit the majority of our requests (99\%) to the blockchain. At 10,000 RPS, 80.17\% of our cross-chain transfer requests reach the blockchain's transaction pool. From those, 98.3\% are included in the chain. Higher request rates greatly decrease the number of transfers submitted and confirmed. At 14,000 RPS, only 8.5\% of our requests make it through to the blockchain, and only 29.2\% of those are committed by the validators.


\begin{table}[!htb]
\renewcommand{\arraystretch}{1.3}
\setlength\tabcolsep{0.5em}
\resizebox{.99\columnwidth}{!}{
\begin{tabular}{cccc}
\textit{\begin{tabular}[c]{@{}c@{}}Input rate \\[-0.4ex] (requests/sec) \end{tabular}} & 
\textit{\begin{tabular}[c]{@{}c@{}}Requests made \\[-0.4ex] to Hermes \end{tabular}} & 
\textit{\begin{tabular}[c]{@{}c@{}}Submitted to\\[-0.4ex] blockchain \end{tabular}} & 
\textit{\begin{tabular}[c]{@{}c@{}}Committed \\[-0.4ex] (from submitted)\end{tabular}} \\ \hline
250 to 9,000 & 18,750 to 675,000 & \textgreater 99\% & \textgreater 99\% \\ \hline
10,000 & 750,000 & 601,300 (80.17\%)  & 591,450 (98.3\%) \\ \hline
11,000 & 825,000 & 319,152 (38.6\%) & 292,424 (91.6\%) \\ \hline
12,000 & 900,000 & 160,343 (17.8\%) & 119,733 (74.6\%) \\ \hline
13,000 & 975,000 & 100,688 (10.3\%) & 51,436 (51\%) \\ \hline
14,000 & 1,050,000 & 90,000 (8.5\%) & 26,360 (29.2\%) \\ \hline
\end{tabular}}
\caption{Execution summary for Tendermint throughput experiments.}
\label{table:throughput_errors}
\end{table}

\textit{\textbf{Hermes Relayer.}} We measure cross-chain throughput by observing the number of cross-chain transfers that Hermes can send from the source to the destination blockchain (\textit{transfer, receive and acknowledge}) within 50 consecutive blocks. We use input rates ranging from 20 RPS to 300 RPS and execute experiments using both one and two instances of the relayer to evaluate its ability to scale. In addition to executing experiments with 200ms network latency, we also performed measurements in a local area network with negligible latency ($<$0.5ms) to demonstrate how it impacts performance. 

\revision{The 100 messages used in our transactions consume an average of 3,669,161 gas for transfers, 7,238,699 gas for receives and 3,107,462 gas for acknowledgements. Those requirements vary by at most 1\%, 4.1\% and 7.6\% for transfer, receive and acknowledgement transactions across all of our experiments, respectively. In the Hermes Relayer's configuration, we set the gas price to 0.01 tokens per unit of gas. }



\begin{figure}[!htb]
\centering
\includegraphics[width=.99\linewidth]{arxiv_figures/cross_chain_throughput_1relayer.pdf}
\caption{\revision{Cross-chain transfer throughput achieved by running one instance of the Hermes Relayer. Data points represent the average measurement obtained through 20 executions.}}
\label{fig:throughput_1relayer}
\end{figure}


Our results are shown in Figure \ref{fig:throughput_1relayer}. 
Circles indicate measurements with 0ms and squares with 200ms. The error bands surrounding the data points represent the standard deviation of the measurements. Each point represents the average of measurements obtained from 20 executions using the same input rate. With 200ms latency, throughput is consistent across executions from 20 RPS (14 TFPS) to 120 RPS (72 TFPS). Relayer performance peaks at 140 RPS, being able to complete 90 cross-chain transfers per second, and drops with further increase in input rate. 

Our findings show a consistency between the rate of requests and throughput for input rates 20, 40, 60, 80 and 100 TPS, with little variance between the executions within the same scenario. However, as we increase the input rate and approach the maximum throughput of the relayer application, the difference between measurements increases. Peak throughput is observed with an input rate of 140 TPS, reaching 90 TFPS with 0ms and 80 TFPS with 200ms latency, a difference of 11\%. Above 140 TPS, throughput gradually decreases as we increase input rate, dropping to 50 TFPS (200ms) and 56 TFPS (0ms) at 300 RPS.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=.99\linewidth]{arxiv_figures/cross_chain_throughput_2relayers.pdf}
  \caption{Cross-chain transfer throughput achieved by running two relayers for a single channel. Data points represent the average measurement obtained through 20 executions.}
  \label{fig:throughput_2relayer}
\end{figure}


\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.99\linewidth]{arxiv_figures/completion_1relayer_200ms.pdf}
  \caption{Average number of messages included in the source and destination blockchain within a 50 blocks interval using one relayer.}
  \label{fig:messages_1relayer}
\end{figure}


\begin{figure}[!htb]
  \centering
  \includegraphics[width=.99\linewidth]{arxiv_figures/completion_2relayers_200ms.pdf}
  \caption{Average number of messages included in the source and destination blockchain within a 50 blocks interval using two relayers.}
  \label{fig:messages_2relayer}
\end{figure}


We also repeated our experiments using two instances of Hermes instead of one. Our goal was to measure the system's throughput with multiple relayers for a single cross-chain channel. Surprisingly, we got a maximum throughput of just 77 TFPS with 200ms and 53 TFPS with 0ms at an input rate of 160 RPS. 
Comparing these results with our setup using a single relayer, we got a peak performance 14\% and 33\% lower for network latencies of 0ms and 200ms respectively. Upon investigating the logs generated by Hermes, we observed several \textit{packet messages are redundant} errors, e.g., 23,020 times for 100 RPS. This happens when both relayers attempt to deliver the same messages to the blockchain, causing the first to succeed and the second to fail. This issue happens due to design choices of the relayer application, such as the inability of relayers to communicate and coordinate packet delivery. \revision{The Interchain Standard that defines Relayer Algorithms (ICS 18)~\cite{ics18} does not discuss scalability, a decision which can be detrimental to engineering and implementation. For instance, the standard neither considers nor discusses the use of multiple cross-chain channels for scalability. It also lacks a discussion on how to scale relayers within a single channel. We believe that basic scaling specifications would benefit the protocol if included in the standards.} In short, this problem impairs throughput in setups with multiple relayers. Additionally, it also leads relayer operators to spend tokens paying transaction fees for transfers that have already been delivered.

An alternative to increase cross-chain throughput would be to establish separate cross-chain channels for each relayer to relay on, however, there are downsides to this approach. Tokens sent from a source to a destination blockchain through different channels are represented in the blockchain using different denominations and are not fungible. Additionally, while multiple uncoordinated relayers have a negative impact on throughput, they may maintain network liveness if a subset of them stops working.

Besides throughput, we have collected data regarding transfer completion status during experiments with 200ms latency. We measured the number of transfers that were completed (\textit{transfer}, \textit{receive}, \textit{acknowledge}), partially completed (\textit{transfer},\textit{ receive}), only initiated (\textit{transfer}) and those that were not committed to the source blockchain. We present the average message completion status for experiments with one relayer in Figure \ref{fig:messages_1relayer} and two relayers in Figure \ref{fig:messages_2relayer}.

At the lowest input rate of 20 RPS we have submitted 5,000 transfers over a time frame of 50 blocks. At 300 RPS we have submitted 75,000 transfers over the same time frame. Up to 160 RPS, the majority of our transfer requests ($>$99.9\%) were committed to the blockchain with both one and two relayers. With two relayers, however, a portion of the committed transfers are initiated, but fail to be delivered before the end of the experiment due to lower throughput caused by the previously discussed message redundancy errors. For 180 RPS and above, the percentage of completed transfers decreases with both one and two relayers. As we show in our latency analysis later in this section, messages contained within a block are processed sequentially, leading to longer confirmation times as we increase the number of transfers in a block. This leads to two observations in experiments with inputs rates of 180 RPS and above. First, transfers start getting completed, i.e, having the acknowledgement message included in the chain, only after several blocks have been generated. Second, transfers that are submitted several blocks after the start of the experiment do not have enough time to be completed before the blockchain generates the 50th block and end up either partially completed or only initiated. It is worth emphasizing that we measure the performance achieved by the relayer within a bounded time frame. If given sufficiently large timeouts and enough time after submission all valid transfers can be completed.

\begin{figure*}[!htb]
  \centering
  \includegraphics[width=0.70\textwidth]{arxiv_figures/operations_latency_5k_1block_200ms_readable.pdf}
  \caption{Breakdown of the operations executed to process of 5,000 cross-chain transfers submitted within 1 block.}
  \label{fig:completion_latency}
\end{figure*}


\subsection{Latency}

To measure the latency of cross-chain communication, we break down cross-chain transfers into 13 steps, as shown in Figure~\ref{fig:completion_latency}. A transfer operation starts with broadcast of the \textit{transfer} message and ends with the confirmation of the \textit{acknowledgement} message. Our goal here is to observe the time required by the Hermes Relayer to complete each step of a cross-chain transfer operation. 

We submitted 5,000 cross-chain transfer requests within one block and analyzed the logs generated by Hermes. We show a detailed breakdown of the execution of the 5,000 transfers in Figure \ref{fig:completion_latency}. We divide each of the three steps of a complete successful cross-chain transfer ({\tt transfer}, {\tt receive}, {\tt acknowledge}) further into \textit{build}, \textit{broadcast}, \textit{message extraction}, \textit{message confirmation} and \textit{data pull}. Steps are numbered according to the order in which they are executed by the relayer. 

A step starts being processed when the area marked by its number first appears in the figure. As operations get completed, the area moves towards the top. When a step succeeds another, the area of the step that is currently being processed is drawn on top of the previous one. For example, step 4 (\textit{Transfer data pull}) starts being processed at 16 seconds, is 50\% completed (2,500 out of 5,000) at 75 seconds and finishes when 126 seconds have elapsed. Steps such as \textit{message extraction} and \textit{message confirmation} are completed near instantly for all the requested transfers, leading to a vertical line in the figure. Others, such as \textit{build} require more processing and have their completion percentage increase gradually.

We start measuring the latency of operations from the moment \textit{transfer} messages are broadcast. After a message is broadcast, the relayer extracts status information from the blockchain (\textit{message extraction}), confirms that it has been committed (\textit{confirmation}) and requests the data contained in it to the blockchain (\textit{data pull}) to build the next message required by the protocol.
Overall, steps required to process the \textit{transfer} message consume 126 seconds or 27.6\% of the total processing time, steps related to the \textit{receive} message require 261 seconds (57.3\%) and steps related to \textit{acknowledgement} message are processed in 68 seconds (14.9\%). The first transfer operation to be completed out of the 5,000 we submitted required 455 seconds from \textit{transfer broadcast} to\textit{ acknowledgement confirmation}. 


Blocks are handled sequentially by the relayer, leading it to process the first step for every \textit{transfer} message within the block before moving on to the next.
We observe that the main bottleneck in the process of cross-chain communication is caused by the operations that retrieve data from the \textit{transfer} and \textit{receive} messages included in the blockchain, namely \textit{transfer data pull} and \textit{recv data pull}. The former corresponds to 24\% (110 seconds) of the time spent processing the 5,000 cross-chain transfers. The latter corresponds to 45\% (207 seconds). Together, those operations require 317 seconds to be completed, which is roughly 69\% of the total processing time. For the duration of those operations, Hermes is using RPC to query blockchain nodes for data. The reason why the \textit{transfer data pull} and \textit{recv data pull} operations correspond to over two thirds of the the time required for cross-chain communication lies in Tendermint's RPC implementation. Tendermint is unable to process queries in parallel, requiring the relayer to wait while its requests for data are processed one by one. This leads to completion latencies in the order of several minutes.

\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.79]{arxiv_figures/completion_time_5k.pdf}
  \caption{Completion of 5,000 cross-chain transfers over time based on seven distinct transaction submission strategies.}
  \label{fig:completion_times_5k}
\end{figure}


We conducted experiments using different transaction submission strategies in an attempt to reduce the completion latency of cross-chain transfers. For this purpose, we evenly divided the total number of cross-chain transfer requests into different intervals of blocks, ranging from 1 to 64.
Figure \ref{fig:completion_times_5k} shows how different submission strategies affect completion latency. Submitting 5,000 transfers within 1 block, as also shown in detail in Figure \ref{fig:completion_latency}, leads to a 455 seconds completion latency for all 5,000 transfers. Dividing transfer submission into 2 blocks yields a 286 seconds completion latency, a 37\% reduction. As we double the interval over which we submit transfers, completion latency is further reduced to 219 seconds (4 blocks), 143 seconds (8 blocks) and 138 seconds (16 blocks). We observe that spreading submissions further beyond this point increases completion latency, rather than reducing it further, to 240 seconds (32 blocks) and 441 seconds (64 blocks). 
We conclude that submitting cross-chain transfers in large batches, while easier to carry out, as one does not have to coordinate submissions over multiple blocks, severely increases completion latency. Increasing the submission window from 1 to 16 blocks provides a 70\% reduction in completion latency. We note however, that spreading transfer submission over larger block intervals has an inverse effect, increasing completion latency from 138 seconds to 441 seconds, a 320\% increase. \revision{Additionally, splitting the submission into multiple blocks causes transfers to start being completed sooner, in increments proportional to the number of transfer requests inside each block. }

