\pdfoutput=1
\documentclass[preprint,12pt]{elsarticle}
%\documentclass[review]{elsarticle}

%\usepackage{lineno,hyperref}
%\modulolinenumbers[5]

\journal{Computer-Aided Design}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%
\input{packages.tex}
\input{definitions.tex}
\graphicspath{{figures/}}
\usepackage{xargs}
\begin{document}

\begin{frontmatter}
\title{Combining high-order metric interpolation and geometry implicitization for curved $r$-adaption}
%\title{High-order metric interpolation for curved $r$-adaption by distortion minimization}
%\tnotetext[mytitlenote]{Fully documented templates are available in the elsarticle package on \href{http://www.ctan.org/tex-archive/macros/latex/contrib/elsarticle}{CTAN}.}

%% Group authors per affiliation:
%\author{Elsevier\fnref{myfootnote}}
%\address{Radarweg 29, Amsterdam}
%\fntext[myfootnote]{Since 1880.}

%% or include affiliations in footnotes:
%\ead[url]{www.elsevier.com}

\author{Guillermo Aparicio-Estrems}
\ead{guillermo.aparicio@bsc.es}
\author{Abel Gargallo-Peir\'{o}}
\ead{abel.gargallo@bsc.es}
\author{Xevi Roca\corref{mycorrespondingauthor}}
\cortext[mycorrespondingauthor]{Corresponding author}
\ead{xevi.roca@bsc.es}
\address{Barcelona Supercomputing Center, 08034 Barcelona, Spain}
% Carrer de Jordi Girona 31

%\adress{organization={Barcelona Supercomputing Center},
%	addressline={},
%	city={Barcelona},
%	postcode={08034},
%	state={},
%	country={Spain}}
%\author[mymainaddress,mysecondaryaddress]{Elsevier Inc}
%\ead[url]{www.elsevier.com}

%\author[mysecondaryaddress]{Global Customer Service\corref{mycorrespondingauthor}}
%\cortext[mycorrespondingauthor]{Corresponding author}
%\ead{support@elsevier.com}

%\address[mymainaddress]{1600 John F Kennedy Boulevard, Philadelphia}
%\address[mysecondaryaddress]{360 Park Avenue South, New York}

\begin{abstract}
We detail how to use Newton's method for distortion-based curved $r$-adaption to a discrete high-order metric field while matching a target geometry. Specifically, we combine two terms: a distortion measuring the deviation from the target metric; and a penalty term measuring the deviation from the target boundary. For this combination, we consider four ingredients. First, to represent the metric field, we detail a log-Euclidean high-order metric interpolation on a curved (straight-edged) mesh. Second, for this metric interpolation, we detail the first and second derivatives in physical coordinates. Third, to represent the domain boundaries, we propose an implicit representation for 2D and 3D NURBS models. Fourth, for this implicit representation, we obtain the first and second derivatives. The derivatives of the metric interpolation and the implicit representation allow minimizing the objective function with Newton's method. For this second-order minimization, the resulting meshes simultaneously match the curved features of the target metric and boundary. Matching the metric and the geometry using second-order optimization is an unprecedented capability in curved (straight-edged) $r$-adaption. This capability will be critical in global and cavity-based curved (straight-edged) high-order mesh adaption.
\end{abstract}

\begin{keyword}
%\texttt{elsarticle.cls}\sep \LaTeX\sep Elsevier \sep template
%\MSC[2010] 00-01\sep  99-00
$r$-adaption, mesh optimization, curved high-order meshes
\end{keyword}

\end{frontmatter}

%\linenumbers

\section{Introduction}
\label{sec:intro}

The capability to relocate mesh nodes without changing the mesh topology, referred to as $r$-adaptivity, is a key ingredient in many adaptive PDE-based applications \cite{yano2012,loseille2011continuous,coupez2015implicit}. In these applications, to improve the solution accuracy, an error indicator or estimator determines the target stretching and alignment of the mesh. Then, to match these target features, an $r$-adaption procedure modifies the whole mesh (global) \cite{huang:AdaptMovingMesh, knupp:algebraicQuality} or a previously re-meshed cavity (local) \cite{alauzet:AnisotropicMeshAdaptation,gruau20053d,frey2005anisotropic}.

In either case, $r$-adaptivity contributes to increasing the solution accuracy for a fixed number of degrees of freedom supported on a straight-edged mesh \cite{coupez2015implicit,huang:AdaptMovingMesh,alauzet:AnisotropicMeshAdaptation,hecht1998bamg,coupez2011metric}. However, straight-edged meshes might not be an efficient support in many applications. Especially in applications where additional straight-edged mesh elements are artificially required to match highly curved solution features \cite{fidkowski2011review}.

To efficiently match curved solution features, many practitioners have recently started to exploit curved high-order meshes. These meshes can be stretched and aligned in a pointwise varying fashion through anisotropic procedures \cite{coupez:BasisFrameworkHighOrderAnisotropicMeshAdaptation}, geodesic approaches for curved edges \cite{johnen2021quality,zhang2018curvilinear}, shock-tracking methods \cite{zahr2018optimization,zahr2020implicit,zahr2020r}, and deformation analogies \cite{marcona2017variational,marcon2020rp}. Alternatively, the curved $r$-adaption can be driven, as for straight-edged elements \cite{huang:AdaptMovingMesh, knupp:algebraicQuality}, by distortion measures. These measures are defined point-wise and are aware of either a target deformation matrix \cite{dobrev2019target} or a target metric \cite{aparicio2018defining}.

In adaptivity applications, the target deformations and metrics are not known a priori. These target fields are reconstructed a posteriori from the solution on the last mesh. Specifically, this mesh supports the resulting discrete representation of the target field. This discrete representation is key to interpolate the required field values in the adaptive procedure. However, to also preserve the geometric accuracy, the mesh adaption procedures have to be devised to simultaneously match the target curved boundaries. Hence, to enable high-order adaptivity, we need the capability to interpolate target fields on a high-order mesh while matching a target boundary.

Considering the previous issues, we aim to use Newton's optimization for distortion-based curved $r$-adaption to a discrete high-order metric field and a geometry model. This work extends our previous work \cite{aparicio2022metricinterpolation}. In this extension, we also detail how to compatibly combine an optimization based $r$-adaption with a valid-to-valid mesh curving approach. To this end, our contribution is to propose an implicit model representation that measures the deviations of the mesh to the target geometry.

For the optimization based $r$-adaption, we need three existent ingredients. First, to minimize the distortion, we use the specific-purpose solver in \cite{aparicio2019imr,aparicio2021icosahom}. Second, we represent the metric field as a log-Euclidean high-order metric interpolation \cite{rochery2021p2} on a curved high-order mesh. Third, we locate physical points in the curved background mesh similar to the approach in \cite{dobrev2018towards}. We also need to extend to discrete metric fields a distortion-based curved $r$-adaption framework \cite{aparicio2018defining}.

To match the curved boundaries, we also need three existing ingredients. First, a non-interpolative approach to match the target curved geometry \cite{ruiz2016generation,ruiz2017augmented}. Second, an implicit CAD geometry representation method for 2D NURBS curves and a 3D NURBS surfaces \cite{upreti2014algebraic} or for embedded NURBS entities \cite{laurent2014implicit} such as 3D curves. Third, a series of conjuction and trimming operations to assemble the implicit representations of the individual entities \cite{upreti2014algebraic,biswas2004approximate}.

To compatibly combine the optimization based $r$-adaption with the mesh curving, the main novelty is twofold. First, for the non-interpolative mesh curving approach, we propose a model implicitization \cite{upreti2014algebraic,laurent2014implicit,biswas2004approximate}. Second, we also provide the first and second-order derivatives of the implicit representation of the model. As in \cite{aparicio2022metricinterpolation}, we also provide the first and second derivatives in physical coordinates for the log-Euclidean high-order metric interpolation. The model implicitation derivatives and the metric interpolation derivatives are critical to use Newton's method for distortion minimization while targeting a curved geometry. This minimization leads to unprecedented second-order optimization results for curved $r$-adaption for a discrete high-order metric representation on a curved (straight-edged) mesh while targeting a curved (straight-edged) geometry.

This paper focuses on enabling Newton's method for $r$-adaption, but it is focused neither on $r$-adaption nor $h$-adaption cycles.
Specifically, we detail how to optimize the high-order mesh coordinates to match a target metric and a curved boundary.
Then, to verify the methodology and the corresponding derivatives, we optimize initial isotropic and anisotropic straight-edged meshes.
These results do not consider any adaptivity cycles because we want to demonstrate if Newton’s method can be used.

The rest of the paper is organized as follows.
In Section \ref{sec:relatedwork}, we overview the related work.
In Section \ref{sec:preliminaries}, we introduce the preliminaries on metric-aware measures for high-order elements.
In Section \ref{sec:interpolation}, we detail the high-order metric interpolation and its derivatives.
In Section \ref{sec:implicit}, we propose an implicit representation for NURBS models, and we obtain the first and second derivatives of this representation.
Moreover, we detail the objective function that accounts for the metric and geometry deviations.
In Section \ref{sec:results}, we show Newton's method results for different geometries, meshes, and metrics.
Finally, we present the concluding remarks. 

\section{Related work}\label{sec:relatedwork}
Next, we overview the work related to matching a target discrete field and a target geometry model. Regarding matching discrete fields, we overview works on target deformations, target metrics, and discrete field representations. For matching geometry models, the related work is about non-interpolative mesh curving, surface fitting methods, and implicit geometry representations.

To match a deformation matrix, distortion optimization for curved $r$-adaption to a discrete target field is detailed in \cite{dobrev2019target}. The method is really well-suited for simulation-driven $r$-adaption \cite{dobrev2018towards,dobrev2020simulation}. It evaluates the distortion in a physical point by interpolating the target matrix on a discrete field.
Although the derivatives of the target matrices are not zero, the method assumes they are zero. Moreover, the second derivatives are also assumed to be zero. Since non-null derivatives are assumed to be zero although the approach implements Newton's method, the curved $r$-adaption minimization corresponds to a quasi-Newton method.

To match a metric, distortion-based curved $r$-adaption to an analytic field can be performed with Newton's minimization \cite{aparicio2018defining,aparicio2019imr,aparicio2021icosahom}. The formulation for an analytic metric is derived in \cite{aparicio2018defining}, while a specific-purpose globalization and a pre-conditioned Netwon-CG method are proposed in \cite{aparicio2019imr,aparicio2021icosahom} to minimize the mesh distortion. Since the method deals with an analytic metric, it does not specify the derivatives for a metric represented by a discrete high-order field.

Regarding a discrete field representation, a convenient approach is to use a log-Euclidean \cite{arsigny:Log-EuclideanMetrics} high-order metric interpolation \cite{rochery2021p2}. This metric interpolation drives a cavity-based adaption approach, where the remeshed cavities are improved by locally smoothing the curved quadratic edges. To smooth these edges, the method optimizes the mid-node position. The optimization only uses the first derivatives of the log-Euclidean metric interpolation in terms of the curved edge coordinates. Accordingly, the method does not provide the first and second derivatives of the discrete metric field in physical coordinates.

High-order mesh curving methods that approximate the target geometry in a non-interpolative manner are presented in \cite{ruiz2016generation,ruiz2017augmented}. Specifically, a new methodology to optimize a curved high-order mesh in terms of both element quality and a distance-based geometric approximation is developed. For this, a penalty method is proposed to solve the constrained minimization problem.

Previous surface fitting methods based in field interpolation are presented in \cite{knupp2021adaptive}.
They are specially designed for dynamically changing geometry according to a solution.
For this, a background mesh is required to interpolate the solution.
Moreover, the resolution of the background mesh determines the precision of the dynamic geometry. Hence, for CAD models, the background mesh resolution controls the geometry accuracy.

In contrast to previous methods, implicit CAD geometry representation methods provide a field for geometric approximation without using a background mesh \cite{upreti2014algebraic,laurent2014implicit,biswas2004approximate}. Specifically, one first computes the implicit representation of each NURBS entity. This is the case of a 2D NURBS curve and 3D NURBS surface \cite{upreti2014algebraic} or a generally embedded NURBS entity \cite{laurent2014implicit}. Then, one applies convex-hull conjunction and normalization, convex-hull trimming, and NURBS conjunction to assemble the representations of the individual entities \cite{upreti2014algebraic,biswas2004approximate}. Even if they are not a full representation of the model they provide a useful tool for representing the model in a entity-wise fashion.

\section{Preliminaries: metric-aware measures for high-order elements}\label{sec:preliminaries}

In this section, we review the definition of the Jacobian-based quality measure for high-order elements equipped with a metric, presented in \cite{aparicio2018defining}.
To define and compute a Jacobian-based measure for simplices \cite{knupp:algebraicQuality}, three elements are required: the master, the ideal, and the physical, see Figure \ref{fig:mappingRefIdealPhysical} for the linear triangle case. The master $(\zmaster)$ is the element from which the iso-parametric mapping is defined. The equilateral element $\left(\zequilater\right)$ represents the target configuration in the isotropic case. The physical $(\zphysical)$ is the element to be measured.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.7\textwidth]{diagram1.png}
	\caption{Mappings between the master, the ideal, and the physical elements in the linear case.}
	\label{fig:mappingRefIdealPhysical}
\end{figure}

To summarize the results in \cite{aparicio2018defining}, we present the expression of the metric distortion measure in terms of the equilateral element $\zequilater$.
First, we need to compute a mapping from the master to the equilateral and physical elements, denoted as $\zequilatermap$ and $\zphysicalmap$, respectively.
By means of these mappings, we determine a mapping between the equilateral and physical elements by the composition
\begin{equation*}
\zequilaterphysicalmap :\zequilater\xrightarrow{\zequilatermap^{-1}} \zmaster \xrightarrow{\zphysicalmap} \zphysical.
\end{equation*}

As detailed in \cite{aparicio2018defining}, we define the point-wise distortion measure for a high-order element $\zphysical$ equipped with a point-wise metric $\zmetric$, at a point $\zy\in\zequilater$ as
\begin{equation}\label{eq:distortionoperator}
\altmathcal{N}\zequilaterphysicalmap(\zy) = \frac{\ztr\left( {\zJacobianequilaterphysical(\zy)}^{\text{T}}\cdot \zmetric\left(\zequilaterphysicalmap(\zy)\right) \cdot\zJacobianequilaterphysical(\zy) \right)}{\zdim\left(\det\left({\zJacobianequilaterphysical(\zy)}^{\text{T}}\cdot \zmetric\left(\zequilaterphysicalmap(\zy)\right) \cdot\zJacobianequilaterphysical(\zy)\right)\right)^{1/\zdim}},
\end{equation}
where the Jacobian of the map $\zequilaterphysicalmap$ is given by
\begin{equation*}
	\zJacobianequilaterphysical(\zy) := \zJacobianphysical(\zequilatermap^{-1}\left(\zy\right))\cdot \zJacobianequilater^{-1}(\zy).
\end{equation*}
Herein, $\zJacobianphysical$ and $\zJacobianequilater$ denote the Jacobian of the physical and equilateral transformation, respectively.
Specifically, the physical mapping can be expressed in terms of the $d$-simplex shape functions $N_i$, that is
\begin{equation*}
	\zphysicalmap\left(\zxi\right) = \sum_{i=1}^n N_i(\zxi)\zx_i,
\end{equation*}
where $n = \binom{d+p}{p}$ is the number of nodes, $\zxi$ are the master coordinates, and $\zx_i$ denotes the physical coordinates of the high-order nodes. 
In addition, the equilateral mapping can be expressed in terms of the linear shape functions $N_i$, that is
\begin{equation*}
	\zequilatermap\left(\zxi\right) = \sum_{i=1}^{d+1} N_i(\zxi)\zy_i,
\end{equation*}
where $\zy_i$ are the coordinates of an equilateral $d$-simplex.

Note that $\altmathcal{N}$ is a non-linear operator that transforms a mapping between the equilateral and physical elements to a mapping from an point to a scalar.
In this work, for operators, we use the standard notation without parentheses.

Note that the distortion measure is independent of the computation of the metric $\zmetric\left(\zequilaterphysicalmap(\zy)\right)$, either using an analytical or a discretized representation.

We regularize the determinant in the denominator of Equation \eqref{eq:distortionoperator} in order to detect inverted elements \cite{garanzha:regularization, storti:globalSmoothUntangl,escobar:untanglingSmoothing,gargallo:generation3Doptimization}. In particular, we define
\begin{equation*}
\sigma_0 = \frac{1}{2}(\sigma + |\sigma|),
\end{equation*}
where
\begin{equation*}
\sigma = \det\left({\zJacobianequilaterphysical(\zy)}\right)\sqrt{\det\left(\zmetric\left(\zequilaterphysicalmap(\zy)\right)\right)}.
\end{equation*}
Then, we define the point-wise regularized distortion measure of a physical element $\zphysical$ at a point $\zy\in\zequilater$ as
\begin{equation}\label{eq:distortion}
\altmathcal{N}_0\zequilaterphysicalmap(\zy) := \frac{\ztr(\zJacobianequilaterphysical(\zy)^\mathrm{T}\cdot \zmetric\left(\zequilaterphysicalmap(\zy)\right)\cdot \zJacobianequilaterphysical(\zy))}{d\sigma_0^{2/d}},
\end{equation}
where we introduce the sub-script 0 to distinguish the regularized operator from the non-regularized one.
In addition, we define the corresponding point-wise quality measure
\begin{equation}\label{eq:pointwisequality}
\altmathcal{Q}\zequilaterphysicalmap(\zy) = \frac{1}{\altmathcal{N}_0\zequilaterphysicalmap(\zy)}.
\end{equation}
Finally, we define the regularized elemental distortion by
\begin{equation*}\label{eq:distortionReg}
\eta_{\left(\zphysical, \zmetric \right)} := \frac{\int_{\zequilater}\altmathcal{N}_0\zequilaterphysicalmap(\zy)\ d\zy}{\int_{\zequilater} 1\ d\zy},
\end{equation*}
and its corresponding quality
\begin{equation}\label{eq:qualityreg}
\text{q}_{\left(\zphysical, \zmetric \right)} = \frac{1}{\eta_{\left(\zphysical, \zmetric \right)}}.
\end{equation}

We can improve the mesh configuration by means of relocating the nodes of the mesh according to a given distortion measure \cite{aparicio2018defining,aparicio2019imr,aparicio2021icosahom,gargallo:PhDdissertation}.
In \cite{aparicio2018defining} it is proposed an optimization of the distortion (quality) of a mesh $\zmesh$ equipped with a target metric $\zmetric$ that describes the desired alignment and stretching of the mesh elements. 
To optimize a given mesh $\zmesh$, first it is defined the mesh distortion by
\begin{equation}\label{eq:minfun}
\altmathcal{F}\left(\zmesh \right) := \sum_{\zphysical\in\zmesh} \int_{\zequilater} \left(\altmathcal{N}_0\zequilaterphysicalmap(\zy)\right)^2\ d\zy,
\end{equation}
which allows to pose the following global minimization problem
\begin{equation}\label{eq:argmin}
\zmesh^* := \argmin_{\zmesh} \altmathcal{F}\left(\zmesh\right),
\end{equation}
to improve the mesh configuration according to $\altmathcal{F}$.
In particular, herein, the degrees of freedom of the minimization problem in Equation \eqref{eq:argmin} correspond to the spatial coordinates of the mesh nodes.

To evaluate the distortion minimization formulation presented in Equation \eqref{eq:argmin}, an input metric is required.
The reviewed $r$-adaption procedure has been applied for analytic metrics in \cite{aparicio2018defining}. 
In the following section, we detail the interpolation process that is required to extend the presented framework to dicrete metrics.
\section{Log-Euclidean metric interpolation}\label{sec:interpolation}
In this section, we formulate a metric interpolation process that allows both the distortion evaluation, Equation \eqref{eq:distortion}, and its optimization, Equation \eqref{eq:argmin}.
In Section \ref{sec:meshInterp} we detail the log-Euclidean metric interpolation for  linear and high-order elements first presented in \cite{arsigny:Log-EuclideanMetrics} and \cite{rochery2021p2,ekelschot2019parallel}, respectively. 
Then, in Section \ref{sec:interpDeriv} we present, as a contribution of this work, the gradient and the Hessian of the log-Euclidean interpolation. Their computation will be used for the distortion minimization problem.

\subsection{Metric Interpolation}\label{sec:meshInterp}
\begin{figure*}[t]
	\centering
	\begin{tabular}{ccc}
		\subfloat[]{\label{fig:physicalmesh}
			\includegraphics[width=0.25\textwidth]{/physicalmesh}}
		&
		\subfloat[]{\label{fig:backgroundmesh}
			\includegraphics[width=0.25\textwidth]{/bmesh}}
		&
		\subfloat[]{\label{fig:intersection}
			\includegraphics[width=0.25\textwidth]{/intersection4}}
		\\
	\end{tabular}
	\caption{Point localization: (a) physical mesh, (b) background mesh, and (c) a point $\textbf{p}$ in the corresponding physical and background element (bold edges).}
	\label{fig:backgroundintersection}
\end{figure*}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.6\textwidth]{geogebra5b22.png}
	\caption{Mappings between the master and the physical elements (below) and their background analogs (above).}
	\label{fig:diagrambackground}
\end{figure}
In this section, we introduce the definition of the log-Euclidean metric interpolation at the background mesh. First, we introduce the required notation of the mappings and their parameters with the corresponding diagram. Secondly, we detail the interpolation procedure. 

To evaluate the metric-aware distortion measure in Equation \eqref{eq:distortion} featuring discrete metrics, two meshes are required. 
%The \textit{physical} mesh, where the distortion measure is evaluated, and the \textit{background} mesh, where the point-wise metric values are interpolated, see Equations \eqref{eq:distortionoperator} and \eqref{eq:distortion}. 
On the one hand, the \textit{physical} mesh $\zmesh$, Figure \ref{fig:backgroundintersection}\subref{fig:physicalmesh}, is the domain where the elements are deformed in order to solve the problem presented in Equation \eqref{eq:argmin}. 
%
%To evaluate the metric distortion measure presented in Section \ref{sec:preliminaries}, two meshes are required. The \textit{physical} mesh, denoted by $\zmesh$, where the distortion measure is evaluated, and the \textit{background} mesh, denoted by $\zbmesh$, where the point-wise metric values are interpolated, see Equations \eqref{eq:distortionoperator} and \eqref{eq:distortion}. On the one hand, the physical mesh $\zmesh$ is the domain where the elements are deformed in order to solve the problem presented in Equation \eqref{eq:argmin}. In the physical mesh we have the master element $\zmaster$ with coordinates $\zxi = (\zxi^1,\zxi^2)$ and the physical element $\zphysical$ with coordinates $\zp = (\zp^1,\zp^2)$.
%
On the other hand, the background mesh $\zbmesh$, Figure \ref{fig:backgroundintersection}\subref{fig:backgroundmesh}, is a mesh that stores discrete metric values as a nodal field.
%the discrete metric is defined over the so-called background mesh $\zbmesh$. 
%
%In the physical mesh we have the master element $\zmaster$ with coordinates $\zxi$ and the physical element $\zphysical$ with coordinates $\zp$.
%
%Analogously to the physical mesh, in the background mesh we have a master element $\zbmaster$ with coordinates $\zbxi$ and a physical element $\zbphysical$ with coordinates $\zbp$. Finally, to differentiate the metric interpolation, the gradient with respect to the variables $\zbxi$ and $\zp$ are required, they are by denoted $\nabla_{\zbxi},\ \nabla_{}$ respectively.
%
%In this work the physical mesh $\zmesh$ is imposed to have the same polynomial degree as the metric interpolation degree, denoted by $\hat{p}$. In addition, for the presented formulation, the background meshes are supposed to be curved. In particular, for the results presented in Section \ref{sec:results}, the background meshes are set to be straight-sided.
% however, the method proposed to interpolate the metric are presented for curved background meshes.

%Aqui sha de posar lalt nivell: per calcular la distortio dun element, hem de calcular el valor pointiwse de la distorsio, i en particular el de la metrica. 
%Per fer-ho hem de trobar el punt fisic a la malla background i interpolar el valor de lametrica alla.
%Per la resta de las eccio, sigui tal lemenet fisic on volem evaluar la metrica, i tal lelement de la background on la volem evaluar.
%To evaluate the point-wise metric-aware distortion measure, the interpolation of the point-wise metric values needs to be computed.
To evaluate the point-wise metric-aware distortion measure, we need to compute the interpolation of the point-wise metric values. For this, the localization between both meshes is required \cite{dobrev2018towards,mittal2019nonconforming,sitaraman2010parallel}.
In particular, a physical point $\zp\in\zmesh$ is located at the background mesh $\zbmesh$ where the metric is interpolated, see Figure \ref{fig:backgroundintersection}\subref{fig:intersection}. In what follows, we introduce the elements and the mappings required for this localization procedure.
%In what follows, let $\zphysical$ be the physical element where the metric needs to be evaluated and $\zbphysical$ the background element where.
%

%Herein, the coordinates of the elements $\zphysical$ of the physical mesh are $\zp$, and their coordinates of the master element, $\zmaster$,  are denoted by $\zxi$.
%Similarly, for the background mesh, the master element $\zbmaster$ is assigned coordinates $\zbxi$ and the coordinates of the physical element $\zbphysical$ are denoted by $\zbp$. In addition, the shape functions of the master element $\zbmaster$ will be denoted by $\zbpsi$.

%%header: \textbf{Recorregut}\\
%In the computational point of view, the integrals are computed in the master element and the metric is interpolated in the master element of the background mesh, where the values of the metric at the vertices are pulled-back from the physical element of the background mesh.
%The distortion measure, presented in Equation \eqref{eq:distortion}, is integrated over the equilateral element via the master element $\zmaster$.
We integrate the distortion measure presented in Equation \eqref{eq:distortion} over the equilateral element via the master element $\zmaster$.
%In particular, for the metric evaluation, each integration point $\zxi\in\zmaster$ is mapped to a point $\zp$ of the physical element $\zphysical$ via $\zphysicalmap$, see Figure \ref{fig:diagrambackground}. 
In particular, for the metric evaluation, we map via $\zphysicalmap$, each integration point $\zxi\in\zmaster$ to a point $\zp$ of the physical element $\zphysical$, see Figure \ref{fig:diagrambackground}.
%To compute the metric at $\zp$ it is necessary to locate $\zp$ in the background mesh, where the values of the metric are stored, see the intersection between $\zphysical$ and the background element $\zbphysical$ in Figure \ref{fig:diagrambackground} and the analogous case for meshes in Figure \ref{fig:backgroundintersection}.
To compute the metric at $\zp$ we need to locate $\zp$ in the background mesh, where the values of the metric are stored, see the intersection between $\zphysical$ and the background element $\zbphysical$ in Figure \ref{fig:diagrambackground}.
%Let $\zbphysical$ be the element of the background mesh such that $\zp \in \zbphysical$, and let $\zbxi\in\zbmaster$ be the master coordinate such that $\zbphysicalmap(\zbxi)=\zp$.
%In addition, in Figure \ref{fig:diagrambackground} it is presented the procedure to obtain the coordinate to interpolate the metric from the quadrature points. In particular, a master point $\zxi\in\zmaster$ is mapped to a physical point $\zp = \zphysicalmap\left(\zxi\right)\in\zphysical$, which is identified with a point $\zbp\in\zbphysical$ of the background mesh and its preimage is the background master point $\zbxi = {\zbphysicalmap}^{-1}\left(\zbp\right)\in\zbmaster$.
In addition, Figure \ref{fig:diagrambackground} shows the procedure to obtain the coordinate to interpolate the metric from the quadrature points. In particular, we map a reference point $\zxi\in\zmaster$ to a physical point $\zp = \zphysicalmap\left(\zxi\right)\in\zphysical$, which we identify it with a point $\zbp\in\zbphysical$ of the background mesh and its preimage is the background reference point $\zbxi = {\zbphysicalmap}^{-1}\left(\zbp\right)\in\zbmaster$.
%However, the metric interpolation is performed in the master element of the background mesh, $\zbmaster$. For this, we map each point $\zp \in \zphysical$ to a point $\zbxi\in\zbmaster$ by checking first at which element of the background mesh, $\zbphysical$ it belongs $\left( \text{that is, } \zp \in \zbphysical\right)$ and then by mapping it to $\zbmaster$ with ${\zbphysicalmap}^{-1}$.
%\todo{aqui mhas danar fent connexions amb la figura \ref{fig:diagrambackground}}

%Aquest procediment és resumeix pel mapping loc: MP -> E^Mhat  (és a dir en tot el domini físic) com el mapping que et dóna les coordenades en el màster de qualsevol punt de la malla. I que la expressió restringida a la intersecció de un element físic EP i un element de la background mesh EPhat que content un punt físic p és justament loc_|_EP_inter_EPhat : EP inter EPhat ----> EMhat p |——> phi^-1_Phat (p)

%Given a point $\zp\in\zphysical$ and a candidate element $\zbphysical$ in the background mesh $\zbmesh$, this procedure can be summarized by the map $\loc_{\zbphysical}: \zbphysical \rightarrow\zbmaster$ that provides the coordinates in the master element $\zbmaster$.

Given a physical point $\zp$, we find it convenient to denote by $\psi$ any mapping from a background element containing $\zp$ that provides the coordinates in the background master element $\zbmaster$. Using this notation, we understand that any projection of a physical point $\zp$ onto a point $\zbxi$ of the background master element $\zbmaster$ corresponds to the evaluation of the non-linear function $\zbxi = \loc(\zp)$.

To evaluate this non-linear function, we exploit that the expression of $\psi|_{\zphysical}$, defined in the intersection of a physical element $\zphysical$ and a fixed background element $\zbphysical$, is given by
%\begin{equation}\label{eq:phim}
%loc|_{\zphysical \cap \zbphysical} = \zbphysicalmap^{-1}
%\end{equation}
\begin{equation}\label{eq:loc}
%\phi|_{\zphysical \cap \zbphysical} := \zbphysicalmap^{-1},
\begin{array}{cccc}
\loc|_{\zphysical} : & \zphysical \cap \zbphysical& \rightarrow & \zbmaster \\
&\zp &\mapsto &	\zbphysicalmap^{-1}\left(\zp\right).
\end{array}
\end{equation}
Specifically, we solve the non-linear inverse expression in the image term, Equation \eqref{eq:loc}, by applying Newton's minimization to the squared distance.
That is, as in Section 2.3 of \cite{mittal2019nonconforming}, we solve
%That is, we solve
\begin{equation*}
\zbxi = \argmin\lim_{\hat{\zeta}} \bigg|\bigg|\zbphysicalmap\left(\hat{\zeta}\right) - \zp\bigg|\bigg|^2.
\end{equation*}
The result is a numerical approximation of the point coordinates in the background master element. An alternative approach \cite{dobrev2018towards} is to seek the zeros of the vector equation
\begin{equation*}
\zbphysicalmap\left(\zbxi\right) - \zp = \textbf{0}.
\end{equation*}

%This procedure can be summarized by the map $\phi: \zphysical \cap \zbphysical\rightarrow\zbmaster$, which is defined on the intersection patches between the physical element $\zphysical$ and the background physical elements $\zbphysical$ as
%\begin{equation}\label{eq:phi}
%%\phi|_{\zphysical \cap \zbphysical} := \zbphysicalmap^{-1},
%\begin{array}{cccc}
%	\phi : & \zphysical \cap \zbphysical& \rightarrow & \zbmaster \\
%	&\zp &\mapsto &	\zbphysicalmap^{-1}\left(\zp\right)
%\end{array}
%\end{equation}
%for all $\zbphysical:\ \zphysical\cap \zbphysical \neq \emptyset$.
%Hence, the projection of a physical point $\zp$ onto a point $\zbxi$ of the master element $\zbmaster$ is given by the piece-wise continuous non-linear function $\zbxi = \phi(\zp)$. For this, the Newton method is applied to the squared distance function that is, $\zbxi = \argmin\limits_{\zeta} \|\zbphysicalmap\left(\zeta\right) - \zp\|^2$ to obtain a numerical approximation of the background master element coordinate \cite{dobrev2018towards}.

%%header: \textbf{Diagrama}\\
%In Figure \ref{fig:diagrambackground} it is shown the diagram between the element domains and their mappings for the 2D case. The physical map $\zphysicalmap:\zmaster \rightarrow \zphysical$ is determined by the nodes of the physical triangle, $\zp_0,\ \zp_1,\ \zp_2$ and similarly for the physical map corresponding the element of the background mesh $\zbphysicalmap:\zbmaster \rightarrow \zbphysical$, which is determined by the nodes of the background physical triangle, $\zbp_0,\ \zbp_1,\ \zbp_2$.



%Note that the map $\phi$ is not well defined at the interfaces of the background mesh elements being discontinuous between the different patches $\zphysical \cap \zbphysical$, and continuous inside the patches.

%%header: \textbf{Characterization}\\
%In our case Linear interpolation = Linear mesh = Straight-sided mesh, HO interpolation = HO mesh = Curved mesh.

%%header: \textbf{Linear case first, then HO}\\

%%header: \textbf{Interpolation definition}\\
%Consider a point-wise metric tensor $\zmetric$ defined in a domain $\Omega\subset \zR^n$.
%Consider the values of a metric tensor $\zmetric$, $\textbf{M}_i,\ i = 1,...,d+1$ at the vertices of the reference simplex. In the two-dimensional case, we consider three values of the metric $\textbf{M}_1,\ \textbf{M}_2,\ \textbf{M}_3$.

%\textcolor{red}{AQUI HAS DE SITUAR AL LECTOR PERQUE NO SIGUI UN RECULL DE COSES DISCONNEXES.}
Once the background master coordinates associated to a given physical point have been computed, it is necessary to interpolate the metric supported by the background mesh at the corresponding master coordinate.
To do so, we use the log-Euclidean interpolation proposed in \cite{arsigny:Log-EuclideanMetrics,rochery2021p2}:
% is defined at the master element $\zbmaster$.
% In particular, it is given by
\begin{equation}\label{eq:metricInterpolationHO}
\zmetric\left(\zallbpsi\right) := \exp\left(\textbf{L}(\zallbpsi)\right),\ \ \textbf{L}(\zallbpsi) := \sum_{j=1}^{\hat{n}} \zbpsi_j \log \hat{\zmetric}_j,
\end{equation}
where for the $j$-th node of the master element $\zbmaster$, $\hat{\zmetric}_j$, and $\zbpsi_j$ are the corresponding metric value and shape function, respectively. In addition, $\zallbpsi$ denotes all the shape functions, $\hat{n} = \binom{d+\hat{p}}{\hat{p}}$ is the number of nodes, and where $\hat{p}$ is the interpolation degree which corresponds to the polynomial degree of the master element $\zbmaster$. Finally, $\textbf{M}(\zallbpsi)$ is characterized by the \textit{eigenvalue-based} matrix exponential function
%\frac{(\hat{p}+1)(\hat{p}+2)}{2}
\begin{equation}\label{eq:exponential}
\zmetric\left(\zallbpsi\right) = \zvep \cdot \exp \zvap \cdot \zvepT,
\end{equation}
where $\zvap,\ \zvep$ are given from the eigenvalue decomposition of the matrix $\textbf{L}(\zallbpsi) =: \zvep \cdot \zvap \cdot \zvepT$. Finally, for each physical point $\zp$ the metric interpolation is given by $\zmetric\left(\zallbpsi\left(\loc\left(\zp\right)\right)\right)$.

%For the linear interpolation we consider three values of the metric $\textbf{M}_1,\ \textbf{M}_2,\ \textbf{M}_3$ at the vertices of the reference triangle (simplex) $\zbmaster$. The linear log-Euclidean interpolation \cite{arsigny:Log-EuclideanMetrics} of the metric tensor at the interior of the triangle is defined as 
%\begin{eqnarray}\label{eq:metricInterpolation}
%\zmetric\left(\zbpsi\right) &:=& \exp\left(\textbf{L}(\zbpsi)\right),\\
%\textbf{L}(\zbpsi) &:=& \zbpsi_1 \log \zmetric_1 + \zbpsi_2 \log \zmetric_2 +\zbpsi_3 \log \zmetric_3,
%\end{eqnarray}
%where the variables $\zbpsi$ correspond to the Lagrange shape functions of the reference triangle $E^{\hat{M}}$. In our case, where the vertices of the reference triangle are $(0,0),\ (1,0),\ (0,1)$, these are given by
%\begin{equation*}
%\zbpsi_1\left(\zbxi\right) := 1 - \left(\zbxi^1 + \zbxi^2\right),\ \zbpsi_2\left(\zbxi\right) := \zbxi^1,\ \zbpsi_3\left(\zbxi\right) := \zbxi^2,
%\end{equation*}
%for $\zbxi = \left(\zbxi_1,\zbxi_2\right)\in\zbmaster$.

%%header: \textbf{Background mesh}\\

%The log-Euclidean interpolation is defined in a master element and it can be extended over a mesh, the background mesh $\zbmesh$. For this, it is required to obtain the intersection between background mesh and points, where the metric interpolation is evaluated. That is, to identify at which element belongs each point. Once the element is determined for a given point we make use of the corresponding element mapping to project the background mesh point to the one belonging to the master element $\zmaster$.

%\textcolor{red}{EL SEGUENT PARAGRAF CREC QUE NO CAL}
%The log-Euclidean interpolation has been defined at the master element $\zbmaster$ and it can be extended over the background mesh $\zbmesh$. Given this background mesh, one can define the map $\phi$ (see Figure \ref{fig:diagrambackground}) which provides the projection of a physical point $\zp$ to a point of the background master element $\zbmaster$, $\zbxi = \phi(\zp)$ where the metric is interpolated. Hence, for each point of the physical mesh, $\zp$ the metric interpolation is given by $\zmetric\left(\zbpsi\left(\phi\left(\zp\right)\right)\right)$, where $\zmetric$ is defined in Equation \eqref{eq:metricInterpolationHO}.

%First, if the background mesh is linear, the map $\zbphysicalmap$ can be written as $\zbphysicalmap(\zbxi) = \nabla_{\zbxi} \zbphysicalmap\cdot \zbxi + \zbp_0$. Hence, for a point of the physical mesh belonging to a patch element of the background mesh, $\zbphysical$, that is, $\zp\in\zphysical\cap\zbphysical$, its projection onto the master element of the background mesh, $\zbxi\in\zbmaster$ is given by
%\begin{equation*}
%\zbxi = \phi(\zp) = \zbphysicalmap^{-1}\left( \zp \right) = \nabla_{} \zbphysicalmap^{-1}\left( \zp - \zbp_0 \right),
%\end{equation*}
%where $\nabla_{} \zbphysicalmap^{-1} = \left(\nabla_{\zbxi} \zbphysicalmap\right)^{-1}$.

%\textbf{Linear}\\

%Intersection between physical mesh and background mesh\\

%For each point of the physical mesh we choose an element of the background mesh that contains it. This choice is not differentiable.\\
%$\zp := \zp\left(\zxi;\zx \right) = \zx \cdot \zbpsi\left(\zxi\right)$
%The points of the physical mesh and the background physical mesh are identified, that is $\zbp = \zp$. In particular, let $\zp := \zphysicalmap\left(\zxi\right)$ be a point of the physical mesh and $\zbp := \zbphysicalmap\left(\zbxi\right)$ a point of the background physical mesh. Then, the metric is interpolated at the coordinates $\zbxi\in\zbmaster$ satisfying $\zbphysicalmap\left(\zbxi\right) = \zbp = \zp$, that is $\zbxi = \zbphysicalmap^{-1}\left( \zp \right)$.

%Then, this allows obtaining the corresponding values and derivatives of the projection map, that is, the value and derivative of the shape functions in terms of the point position $\nabla_{} \zbpsi = \nabla_{\zbxi} \zbpsi\cdot \nabla_{} \zbphysicalmap^{-1}$. Furthermore, in the linear case we have
%%$\left(\nabla_{\zxi}\zphysicalmap\right)^{-1} = \nabla_{} \zphysicalmap^{-1}$
%\begin{equation*}
%\nabla_{} \zbpsi_{1} = -\nabla_{} \zbphysicalmap^{-1}\cdot(\textbf{e}_{1} + \textbf{e}_{2}),\ \ \nabla_{} \zbpsi_{j+1} = \nabla_{} \zbphysicalmap^{-1}\cdot \textbf{e}_{j},
%\end{equation*}
%where the vectors $\textbf{e}_{j},\ j = 1,2,3$ correspond to the vectors of the canonical basis.
%Note that the presented derivatives are constant which implies that the second-order derivatives are zero at the interior of each patch $\zphysical\cap\zbphysical$.

%\textbf{High-order}\\
%%header: \textbf{High-order interpolation}\\
%%header: \textbf{HO background mesh}\\
\subsection{Gradient and Hessian}
\label{sec:interpDeriv}
%%header: \textbf{Section}

%In this section, we present, in terms of the physical coordinates, the gradient and Hessian of the metric interpolation over a background mesh.
This section provides the expressions for the gradient and Hessian of the metric interpolation over a background mesh in terms of the physical coordinates.
For this, we detail first the case for the metric interpolation at a single element and then for the background mesh. In particular, our approach uses the gradient and Hessian of the eigenvalue decomposition presented in \cite{andrew1993derivatives}.
%\textbf{Intro: present the differentiation approach of Loseille, contrast with our approach}\\

%%header: \textbf{Chain rule used}
To compute the derivatives of the metric $\zmetric$ we first differentiate the eigenvalue-based exponential matrix function presented in Equation \eqref{eq:exponential} and then we differentiate the $\textbf{L}$ function presented in Equation \eqref{eq:metricInterpolationHO}.
%
By denoting $x_j$ the coordinates of $\zp$ and $\partial_j := \frac{\partial}{\partial x_j}$, $\partial_{jk} := \partial_j \partial_k = \frac{\partial}{\partial x_j}\frac{\partial}{\partial x_k}$ the partial derivatives in terms of the physical coordinates of $\zp$, we can compute the spatial derivatives of the metric interpolation of Equation \eqref{eq:metricInterpolationHO}. In particular, the first-order derivatives are given by
\begin{eqnarray*}\label{eq:gradient}
\partial_{j} \zmetric(\zallbpsi) = \partial_j \exp \textbf{L}(\zallbpsi) = \partial_j \left(\zvep \cdot \exp \zvap \cdot \zvepT \right) =\\
\left(\partial_j \zvep\right) \cdot \exp \zvap \cdot \zvepT + \zvep \cdot \left(\partial_j \exp \zvap\right) \cdot \zvepT + \zvep \cdot \exp \zvap \cdot \left(\partial_j\zvepT\right),
\end{eqnarray*}
and the second-order derivatives are given by
\begin{eqnarray*}\label{eq:hessian}
	\partial_{jk} \zmetric(\zallbpsi) = \partial_{jk} \exp \textbf{L}(\zallbpsi) = \partial_{jk} \left(\zvep \cdot \exp \zvap \cdot \zvepT \right) =\\
	\left(\partial_{jk} \zvep\right) \cdot \exp \zvap \cdot \zvepT + \partial_k \zvep \cdot \left(\partial_j \exp \zvap\right) \cdot \zvepT + \partial_k \zvep \cdot \exp \zvap \cdot \left(\partial_j\zvepT\right) +\\
	\left(\partial_j \zvep\right) \cdot \partial_k \exp \zvap \cdot \zvepT + \zvep \cdot \left(\partial_{jk} \exp \zvap\right) \cdot \zvepT + \zvep \cdot \partial_k \exp \zvap \cdot \left(\partial_j\zvepT\right) + \\
	\left(\partial_j \zvep\right) \cdot \exp \zvap \cdot \partial_k \zvepT + \zvep \cdot \left(\partial_j \exp \zvap\right) \cdot \partial_k \zvepT + \zvep \cdot \exp \zvap \cdot \left(\partial_{jk}\zvepT\right).
\end{eqnarray*}

Note that, since the matrix $\zvap$ is diagonal, we have
\begin{eqnarray*}
	\partial_j \exp \zvap &=& \exp\left(\zvap\right)\cdot \partial_j\zvap,\\
	\partial_{jk} \exp \zvap &=&  \exp\left(\zvap\right) \cdot \left( \partial_k \zvap \cdot \partial_j\zvap + \partial_{jk}\zvap\right).
\end{eqnarray*}

%\textbf{Remark: several differentiation approaches taking into account chain rule. None one is preferred, which we explain?
%	There is one approach that shows the discontinuity of the derivatives}\\

The presented first and second-order derivatives of the metric require the first and second-order spatial derivatives of the eigenvalue decomposition (eigenvalues and eigenvectors), respectively. 
%Their computation, detailed in \cite{andrew1993derivatives}, has been appended in Section \ref{sec:appendix} with the presented notation.
Their computation is appended in Section \ref{sec:appendix}.

In addition, the derivatives of the eigenvalues and eigenvectors depend on the derivatives of the $\textbf{L}$ function presented in Equation \eqref{eq:metricInterpolationHO}. In particular, they are given by
\begin{equation*}
\nabla_{} \textbf{L} = \sum_{j} \left(\log{\hat{\zmetric}_j}\right) \nabla_{}\zbpsi_j,\ \ \nabla_{}^2 \textbf{L} = \sum_{j} \left(\log{\hat{\zmetric}_j}\right) \nabla_{}^2\zbpsi_j,
\end{equation*}
where $\nabla_{}$ is the gradient with respect to physical coordinates.
%This equation shows the dependence of the derivatives of the metric interpolation in terms of the background mesh.
Therefore, to differentiate the metric interpolation $\zmetric\left(\zallbpsi\left(\loc\left(\zp\right)\right)\right)$ at a physical point $\zp$, the derivatives of the map $\loc$ presented in Equation \eqref{eq:loc} and of the shape functions $\zallbpsi$ are required.
%From Equation [] at each patch $\zphysical\cap\zbphysical$ we obtain the corresponding derivatives of the shape functions $\zbpsi$ in terms of the point position

The derivatives of $\loc|_{\zphysical}$ are given, at each patch $\zphysical\cap\zbphysical$, by the ones of the inverse of the physical map $\zbphysicalmap^{-1}$ corresponding to the background mesh. To obtain the derivatives of the shape functions $\zallbpsi$ in terms of the physical coordinates $\zp$, we consider the chain rule for the composition $\zallbpsi\circ\loc|_{\zphysical}$ and the restriction of the map $\loc|_{\zphysical}$ at each patch $\zphysical\cap\zbphysical$. We finally obtain the gradient
%$\zp = \phi|_{\zphysical\cap\zbphysical}^{-1}(\zbxi) = \zbphysicalmap(\zbxi)$
\begin{equation}\label{eq:derpsi}
\nabla \zallbpsi = \nabla_{\zbxi} \zallbpsi \cdot \nabla \zbphysicalmap^{-1},
\end{equation}
where $\nabla_{\zbxi}$ is the gradient with respect to $\zbxi$ coordinates, and the Hessian
\begin{equation}\label{eq:derpsi2}
\nabla^2 \zbpsi_j = \left(\nabla \zbphysicalmap^{-1}\right)^{\text{T}} \cdot \nabla_{\zbxi}^2 \zbpsi_j \cdot \nabla_{} \zbphysicalmap^{-1} + \nabla_{\zbxi} \zbpsi_j \cdot \nabla_{}^2 \zbphysicalmap^{-1},
\end{equation}
where
\begin{eqnarray*}\label{eq:derinvphis}
	\nabla_{} \zbphysicalmap^{-1} &=& \left(\nabla_{\zbxi} \zbphysicalmap\right)^{-1},
	\\
	\nabla_{}^2 \zbphysicalmap^{-1} = \nabla_{} \left(\left(\nabla_{\zbxi} \zbphysicalmap\right)^{-1}\right) &=& -\nabla_{} \zbphysicalmap^{-1} \cdot \nabla_{\zbxi}^2 \zbphysicalmap \cdot \nabla_{}\zbphysicalmap^{-1}.
\end{eqnarray*}
%It is important to remark that, in general, the derivatives of the metric interpolation at the background mesh are discontinuous at the element boundaries. This is because, in our case, the mesh is composed of Lagrange elements which only impose $\altmathcal{C}^0$-continuity to the corresponding global interpolation operator.
%Additional differentiability could be obtained by adding degrees of freedom to the master element $\zbmaster$ where derivatives of the metric are provided instead of only requiring the metric values at the vertices.

%We are interested in the derivatives of the metric $\zmetric \left( \zbpsi \left( \phi(\zp) \right) \right)$ in terms of the point positions $\zp$, that is $\nabla_{}\zmetric$. In particular, from the derivatives of the shape functions in terms of the point positions presented in Equations \eqref{eq:derpsi} and \eqref{eq:derpsi2} we can compute the derivatives of the $\textbf{L}$ function
%\begin{equation*}
%\nabla_{} \textbf{L} = \sum_{j} \left(\log{\zmetric_j}\right) \nabla_{}\zbpsi_j,\ \ \nabla_{}^2 \textbf{L} = \sum_{j} \left(\log{\zmetric_j}\right) \nabla_{}^2\zbpsi_j.
%\end{equation*}

%High-order mesh curving via entity-wise implicit CAD representation
\section{Implicit CAD representation: metric and geometry aware optimization}\label{sec:implicit}
%header: \textbf{Eloi, Roca: Weak boundary}\\
%\cite{ruiz2021measuring,ruiz2022automatic}
%High-order mesh curving methods that approximate the target geometry in a non-interpolative manner are presented in \cite{ruiz2016generation,ruiz2017augmented}.
%Specifically, a new methodology to optimize a curved high-order mesh in terms of both element quality and a distance-based
%geometric approximation is developed.
%For this, a penalty method is proposed to solve the constrained minimization problem.
%Specifically, they use a novel technique in which the boundary elements of the high-order mesh are able to span and slide between different geometric entities of the target model by using a virtual geometry kernel.

%header: \textbf{MFEM: field interpolation}\\
%geometric kernel-free
%Previous surface fitting methods based in field interpolation are presented in \cite{knupp2021adaptive}.
%They are specially designed for dynamically changing geometry according to a solution.
%For this, a background mesh is required to interpolate the solution.
%Moreover, the resolution of the background mesh determines the precision of the dynamic geometry.
%Hence, for CAD models, the background mesh resolution controls the geometry accuracy.
%This is because a higher geometric accuracy requires a higher resolution of the background mesh.

%header: \textbf{Implicit CAD}\\
%In contrast to previous methods, implicit CAD geometry representation methods do not require a geometric kernel nor a background mesh \cite{upreti2017signed,liao2020algebraic,laurent2014implicit,biswas2004approximate}.
%In contrast to previous methods, implicit CAD geometry representation methods provide a field for geometric approximation without using a background mesh \cite{biswas2004approximate,upreti2014algebraic,laurent2014implicit}.
%Specifically, one first computes the implicit representation NURBS entity.
%This is the case of a 2D NURBS curve and 3D NURBS surface \cite{upreti2014algebraic} or a generally embedded NURBS entity \cite{laurent2014implicit}.
%Then, one applies convex-hull conjunction and normalization, convex-hull trimming, and NURBS conjunction to assemble the representations of the individual entities \cite{biswas2004approximate,upreti2014algebraic}.
%Even if they are not a full representation of the model they provide a useful tool for representing the model in a entity-wise fashion.

%header: \textbf{Section overview}\\
%For this, the NURBS fundamental geometric algorithms have been implemented \cite{piegl1996NURBS}.
%Our contribution is to
Herein, we propose a high-order mesh curving method by an implicitization that measures the geometric deviation.
First, in Section \ref{sec:cadimplicit}, we present a model implicitization for the mesh curving process.
Then, in Section \ref{sec:implicitders}, we detail the first and second-order derivatives for the implicit representation.
Finally, in Section \ref{sec:penalty}, we consider the penalty method to solve the corresponding constrained second-order minimization process for the curving problem.

\subsection{Implicit CAD representation}\label{sec:cadimplicit}
%The ﬁrst contribution of this paper is to adapt the construction of these matrices to the context of Bézier patches (usually obtained from the decomposition of a NURBS).
%	Our objective is to obtain a entity-wise implicit representation of the CAD model. This representation ca
%	convex-hull disjunction and normalization, convex-hull trimming, disjunction of NURBS entities, knot reinsertion, remove auto-intersections for curves of degree $>3$ .
In this section, we present an entity-wise CAD representation for curves in 2D, and for curves, and surfaces in 3D.
For this, we consider the implicit representation of embedded NURBS \cite{laurent2014implicit}, and the Boolean algebraic operations for implicit representations \cite{upreti2014algebraic,biswas2004approximate}.
Then, we assemble these representations to obtain an implicit representation of a CAD model.
%In particular we apply algebraic conjunction and trimming operations between the convex-hull entities and the NURBS entities.
Finally, we detail the algorithm of the considered methodology.
%	\subsubsection{NURBS implicitization and normalization}

%header: \textbf{Notation}\\
We consider a CAD model $\zmodel$ composed of a sequence of NURBS entities.
These NURBS entities can be decomposed into a sequence of B\'{e}zier patches $\znurbs_i,\ i=1,...,n$.
%To simplify, we first consider those entities that are of the same dimension $d$.
In particular, we describe a $d$-dimensional B\'{e}zier patch $\znurbs\subset\zR^D$ embedded in a $D$-dimensional space in terms of a parameterization
\begin{equation*}\label{eq:param}
\varphi^{}_\znurbs:[0,1]^d\rightarrow\zR^D,\ \ \varphi^{}_\znurbs\left( u \right) \in \znurbs,\ u\in[0,1]^d.
\end{equation*}
In addition, the implicit representation of $\znurbs$ can be obtained as in \cite{laurent2014implicit}
\begin{equation*}\label{eq:implicitfun}
\gamma^{}_\znurbs:\zR^{D}\rightarrow\zR,\ \ \gamma^{}_\znurbs\left( x \right) = 0 \text{ if and only if } x \in \znurbs.
\end{equation*}
Our objective is to obtain a representation $\gamma^{}_\zmodel$ of the model $\zmodel$ that is expressed in terms of the representations $\gamma^{}_{\znurbs_i}$ of the patches $\znurbs_i$.
To combine these implicit representations we use algebraic Boolean operations between real-valued functions \cite{biswas2004approximate}.

%header: \textbf{Figure}\\
\begin{figure*}[t!]
	\centering
	\begin{tabular}{ccc}
		\includegraphics[width=0.20\textwidth]{./geo_hole.png}&
		\includegraphics[width=0.20\textwidth]{./geo_hole_igslin.jpeg}&
		\includegraphics[width=0.20\textwidth]{./geo_hole_igslog.jpeg}
		\\
		\includegraphics[width=0.20\textwidth]{./sphereCilBoxSurf.jpeg}&			
		\includegraphics[width=0.26\textwidth]{./sphereCilBoxSurf_igslin.jpeg}&
		\includegraphics[width=0.26\textwidth]{./sphereCilBoxSurf_igslog.jpeg}
		\\
	\end{tabular}
	\caption{Implicit representation of (first row) a 2D CAD geometry, and (second row) a 3D CAD geometry. CAD model, and implicit representation in linear, and logarithmic scale in columns.}
%	Implicit representation of a 2D and 3D CAD geometry in rows
	\label{fig:model}
\end{figure*}
In Figure \ref{fig:model}, we show a 2D and a 3D model.
They are mapped via the B\'{e}zier parameterizations $\varphi^{}_{\znurbs_i}$ and their level-sets are represented via the implicit function $\gamma^{}_{\zmodel}$.
The level-sets are illustrated in linear and logarithmic scaling.
As we observe, the functions are numerically zero at the model.
In addition, they smoothly increase far from the model region.

%header: \textbf{Preprocessing: Bezier patches and autointersections}\\
The implicit representation of a CAD model requires a knot preprocessing of the NURBS entities.
Specifically, two knot insertion procedures are required \cite{upreti2014algebraic}.
The first knot insertion, is used to decompose the NURBS entity into B\'{e}zier patches.
The second one, is used to avoid auto-intersections for curves of degree $p \geq 3$.
In this case, we perform an auto-intersection detection process.
Note that the auto-intersection points are given by the equation $\|\nabla\gamma^{}_{\znurbs}\| = 0$.
Then, we detect the auto-intersections by minimizing the quantity $\|\nabla\gamma^{}_{\znurbs}\|^2$ via a one-dimensional search bisection over the parametric line.

%header: \textbf{Convex-hull computation}\\
To trim the implicit representation in its corresponding domain, we consider the convex-hull of the B\'{e}zier patch control points.
Specifically, for degenerate cases we extrude the set of control points.
To compute the extrusion directions we perform a null space computation via the singular value decomposition.
This defines a valid convex-hull.
We apply this procedure to the degenerate cases given by 2D segments, 3D planes, 3D curves, and 3D cylinders.
Furthermore, we also apply this procedure to approximately degenerate cases such as almost flat curves and surfaces.
% \subsection{NURBS implicitization}

%	Technicalities: inherent degree flexibility particular of \cite{laurent2014implicit}, stability parameter $\varepsilon$.

% In this section we detail the technicalities about NURBS implicitization. Specifically, they are knot reinsertion and knot auto-intersection \cite{upreti2017signed,liao2020algebraic}, and a numerically stable normalization. In addition, we detail the observed advantages of using a quadratic-based implicit representation \cite{laurent2014implicit} in contrast to a linear-based one \cite{upreti2017signed,liao2020algebraic}.

% Once the knots are inserted we can implicitize the NURBS entity in terms of its control points only. There exist two methods for implicitizing a NURBS entity $\znurbs$: linear-based \cite{upreti2017signed,liao2020algebraic} and quadratic-based \cite{laurent2014implicit}. The linear based is cheaper and simpler to differentiate. However, it has several difficulties for extending it when spatial curves are considered. Furthermore, it does not consider entities where its inherent degree is less than the input one, for example quadratic lines. For this reason, we prefer to consider the quadratic-based implicitization method. Its main advantage is that it can deal with entities where its inherent degree is not necessarily equal to the input one, present in practical CAD geometries.

% \subsection{Implicit function assembly}

% When assembling implicit functions it is standard to normalize them \cite{biswas2004approximate,upreti2017signed}.
% In our case, when normalizing a quadratic-based implicit representation several singularities may arise.
% This is because of the gradient norm of the implicit function $\|\nabla \gamma_{\znurbs}\|$ may be null at several points out of the entity $\znurbs$.
% To avoid instability issues due to singularities we numerically stabilize the norm factor by adding a tolerance $\varepsilon^2 = 10^{-12}$.
% This quantity has been chosen experimentally in order to stabilize the implicit representation without modifying considerably its local behavior.

%header: \textbf{Implicit NURBS}\\
For each B\'{e}zier patch $\znurbs$, we consider its implicit representation $\gfun$ defined in the projective space $\mathbb{P}\left(\zR^D\right)$.
In particular, the patch control points determine a vector of matrices that is, $\mathbb{M} = \left(\mathbb{M}_x,\mathbb{M}_y,\mathbb{M}_z,\mathbb{M}_w\right)$ in 3D, corresponding to the projective coordinates $x, y, z,$ and $w$.
Then, we define the implicit representation at a point $\zx\in\mathbb{P}\left(\zR^D\right)$ as in \cite{laurent2014implicit}
\begin{equation}\label{eq:implicit}
\gfun\left(\zx\right) := \det\left(\mathbb{M}\left(\zx\right)\cdot \mathbb{M}\left(\zx\right)^{\text{T}}\right),\ \ \mathbb{M}\left(\zx\right) := \mathbb{M}\ \zx.
\end{equation}
For example, in 3D we set $\zx = (x,y,z,1)$ and hence, $\mathbb{M}\ \zx = \mathbb{M}_x x + \mathbb{M}_y y + \mathbb{M}_z z + \mathbb{M}_w$.
Finally, we normalize the functions $\gfun\left(\zx\right)$ to ensure that they match during the assembly procedure \cite{upreti2014algebraic}.
Specifically, we define the normalized function $\gnfun$ by
\begin{equation}\label{eq:normalized}
\gnfun :=\frac{\gfun}{\|\nabla\gfun\|}.
\end{equation}

%header: \textbf{Convex-hull trimming}\\
The implicit function of a B\'{e}zier patch described in Equation \eqref{eq:normalized} extends over an infinite parametric space.
For this reason, it is standard to trim the patch via a convex hull operation to ensure that the function does not extend beyond the patch limits \cite{upreti2014algebraic,biswas2004approximate}.
Specifically, we  first compute $\zchull\left(\znurbs\right)$, the implicit representation of the convex hull of the B\'{e}zier patch $\znurbs$.
Then, to obtain an implicit representation of $\znurbs$ trimmed by $\zchull\left(\znurbs\right)$, we use a trimming function, denoted by $\text{trim}$, proposed in \cite{biswas2004approximate}
%Then, we use a specific differentiable trimming operation, denoted by $\text{trim}$, between the implicit representation of $\znurbs$ in terms of $\zchull\left(\znurbs\right)$ to obtain a function \cite{biswas2004approximate}
%$\gamma_{\overline{\znurbs}} := \gamma_{\zchull\left(\znurbs\right)}\text{ trim } \gamma_{\znurbs}$

\begin{equation}\label{eq:trim}
\gamma^{}_{\overline{\znurbs}} := \hat{\gamma}^{}_{\zchull\left(\znurbs\right)}\text{ trim }
\hat{\gamma}^{}_{\znurbs} = \sqrt{\hat{\gamma}_{\znurbs}^2 +
\left(
\frac{
\sqrt{\hat{\gamma}_{\znurbs}^4 + \hat{\gamma}_{\zchull\left(\znurbs\right)}^2
}
-
\hat{\gamma}_{\zchull\left(\znurbs\right)}
}{2}
\right)^2},
\end{equation}

%\begin{equation}\label{eq:trim}
%\gamma^{}_{\overline{\znurbs}} := \hat{\gamma}^{}_{\zchull\left(\znurbs\right)}\text{ trim } \hat{\gamma}^{}_{\znurbs} = \sqrt{\hat{\gamma}^{}_{\znurbs}}^2 + \left(\frac{\sqrt{\hat{\gamma}^{}_{\znurbs}^4 + \hat{\gamma}^{}_{\zchull\left(\znurbs\right)}^2} - \hat{\gamma}^{}_{\zchull\left(\znurbs\right)}}{2} \right)^2},
%\end{equation}

where $\gfun^{}_{\Gamma}$ denotes the representation of the B\'{e}zier patch $\Gamma$, see Equation \eqref{eq:implicit}.
The trimming operation of Equation \eqref{eq:trim} is twice differentiable at all points where $\hat{\gamma}^{}_{\znurbs} \neq 0$.
%excepting those which $\hat{\gamma}^{}_{\znurbs} = 0$.
Here, the function $\gamma^{}_{\overline{\znurbs}}$ is an implicit representation of the B\'{e}zier patch $\znurbs$ in its parametric domain $\text{Dom}\ \znurbs$ determined by the NURBS convex-hull $\zchull\left(\znurbs\right)$.

%header: \textbf{$r$-conjunction}\\
For a given model $\zmodel = \{ \znurbs_1,\znurbs_2,...,\znurbs_n\}$, its implicitization $\gamma^{}_{\zmodel}$ is obtained via the $r$-conjunction $\wedge$ of the implicitizations $\gamma^{}_{\overline{\znurbs_i}}$ of the B\'{e}zier patches $\znurbs_i$ \cite{upreti2014algebraic}.
In particular, for each B\'{e}zier patch $\znurbs_i$, we recursively update the model representation as follows
\begin{equation}\label{eq:rconj}
\gamma^{}_{\zmodel} \leftarrow \gamma^{}_{\zmodel} \wedge \gamma^{}_{\overline{\znurbs}_i} := \gamma^{}_{\zmodel} + \gamma^{}_{\overline{\znurbs}} -  \sqrt{{\gamma^{}_{\zmodel}}^2 + {\gamma^{}_{\overline{\znurbs}}}^2}.
\end{equation}

%header: \textbf{Convex hull representation}\\
To obtain the convex-hull representation of a B\'{e}zier patch $\znurbs$, $\zchull\left(\znurbs\right)$, we apply $r$-conjunction to the hyperplane functions of the convex hull entities. Specifically, for each hyperplane entity $\text{H}$ of the convex hull $\zchull\left(\znurbs\right)$ we consider its unit normal component $\textbf{n}$ and its affine term $b$. Then, the implicit representation of $\text{H}$ is given by
\begin{equation}\label{eq:hyperplane}
\gamma^{}_{\text{H}}\left(\zx\right) := \textbf{n}\cdot \zx + b.
\end{equation}
In our case, the sign of the representation $\gamma^{}_{\text{H}}$ is chosen such that $\gamma^{}_{\text{H}} < 0$ outside the convex region enclosed by $\zchull\left(\znurbs\right)$ and $\gamma^{}_{\text{H}} \geq 0$ otherwise. Following, we apply the $r$-conjunction operation for each hyperplane $\text{H}$ to obtain the convex-hull representation $\gamma^{}_{\zchull\left(\znurbs\right)}$, see Equation \eqref{eq:rconj}. Finally, we obtain its normalized version $\hat{\gamma}^{}_{\zchull\left(\znurbs\right)}$ by applying Equation \eqref{eq:normalized}.

%header: \textbf{Algorithm: model implicitization}\\
\begin{algorithm}[t!]
	\caption{Implicitization}\label{alg:implicit}
	\textbf{Input:} $\zmodel:= \{\znurbs_1,\ \znurbs_2,\ ...,\ \znurbs_n\}$\\
	\textbf{Output:} $\gamma^{}_{\zmodel}$
	% \textbf{Set:} $\varepsilon \leq 10^{-6}$
	\begin{algorithmic}[1]
%		\Procedure{Implicitization}{}
		\For{$i = 1,...,n$}
		\State $\hat{\gamma}^{}_{\znurbs_i} = $ normalized implicitization of $\znurbs_i$\label{line:implicit}
%		Equation \eqref{eq:implicit}\\
%		\cite{laurent2014implicit}\\
%		\State $\hat{\gamma}_{\znurbs_i} \gets \gamma_{\znurbs_i}/\|\nabla \gamma_{\znurbs_i}\|$ normalization\\
%		Equation \eqref{eq:normalized}\\
%		\cite{upreti2014algebraic}\\
		\State $\hat{\gamma}^{}_{\zchull\left(\znurbs_i\right)} = $ normalized implicitization of the convex hull of $\znurbs_i$, $\zchull\left(\znurbs_i\right)$\label{line:chull}
%		\cite{upreti2014algebraic}\\
		\State $\gamma^{}_{\ztrimmednurbs_i} = $ trimming of $\hat{\gamma}^{}_{\znurbs_i}$ with $\hat{\gamma}^{}_{\zchull\left(\znurbs_i\right)}$\label{line:trim}
%		\cite{biswas2004approximate}\\
		\If{$i = 1$}\label{line:rconj0}
		\State $\gamma^{}_{\zmodel} \gets \gamma^{}_{\overline{\znurbs}_1}$
		\Else
		\State $\gamma^{}_{\zmodel} \gets \gamma^{}_{\zmodel} \wedge \gamma^{}_{\overline{\znurbs}_i}$ $r$-conjunction
%		\cite{biswas2004approximate}\\
		\EndIf\label{line:rconj1}
		\EndFor
%		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%referenciar equacions, autors ja estan referenciats en els paragrafs corresponents
In Algorithm \ref{alg:implicit}, we describe how to obtain the implicit representation $\gamma^{}_{\zmodel}$ of a model $\zmodel$.
In Line \ref{line:implicit}, we compute for each B\'{e}zier patch $\znurbs_i$ of $\zmodel$ its implicit function $\gamma^{}_{\znurbs_i}$ and we normalize it, see Equations \eqref{eq:implicit} and \eqref{eq:normalized}.
Then, in Line \ref{line:chull}, we consider the convex hull property of the B\'{e}zier control points for trimming \cite{upreti2014algebraic}.
We first obtain an implicit representation of the convex hull $\gamma^{}_{\zchull\left(\znurbs_i\right)}$ by applying a pair-wise $r$-conjunction to the hyperplane functions, see Equation \eqref{eq:hyperplane}.
Then, we compute its normalized representation $\hat{\gamma}^{}_{\zchull\left(\znurbs_i\right)}$, see Equation \eqref{eq:normalized}.
In Line \ref{line:trim}, we trim the B\'{e}zier patch representation $\hat{\gamma}^{}_{\znurbs_i}$ in terms of $\hat{\gamma}^{}_{\zchull\left(\znurbs_i\right)}$, see Equation \eqref{eq:trim}.
The obtained representation is denoted by $\gamma^{}_{\ztrimmednurbs_i}$.
Finally, in Lines \ref{line:rconj0}-\ref{line:rconj1}, we obtain the implicit representation of the model $\zmodel$ by pair-wise $r$-conjunction of $\gamma^{}_{\ztrimmednurbs_i}$, see Equation \eqref{eq:rconj}.
%Anisotropic Convex hull tolerance.
\subsection{Gradient and Hessian}\label{sec:implicitders}
%$r$-conjunction
%differentiable trimming
%normalization
%normalized implicitization chull
%	implicitization

%fer cadena:
%dir f i g.
%
Next, we present the gradient and Hessian of the geometry implicitization.
In Section \ref{sec:cadimplicit}, we describe the geometry implicitization in terms of the trimming and $r$-conjunction operations of the convex-hull and B\'{e}zier patch normalized representations.
Accordingly, we describe in this section the derivatives of the trimming and $r$-conjunction operations.
For completeness, we detail in \ref{sec:appendix2} the derivatives of the convex-hull and B\'{e}zier patch normalized representations.
%the geometry implicitization
%In this section, we present the derivatives of the geometry implicitization described in Section \ref{sec:cadimplicit}.
%Note that, we describe the geometry representation .
%the B\'{e}zier patches are trimmed according to their convex-hull, and assembled.

% In addition, we detail their first and second derivatives in \ref{sec:appendix2}.
%In this section, we describe the first steps for the gradient and Hessian computation of the CAD implicitization.
%For this, we detail the derivatives for the $r$-conjunction and trimming operations.
%In addition, we present the remaining derivatives in \ref{sec:appendix2}.
%They are given by the gradient and Hessian of the normalized implicit convex-hull representation, and of the normalized implicit B\'{e}zier representation.
%we first detail the case for the untrimmed normalized B\'{e}zier representation.
%Then, we detail the case for the trimming and $r$-conjunction operations, and the case of the convex-hull representation.
%Note that \ref{sec:appendix2} provides several formulas needed to compute the derivatives in this section.
%Finally, we provide in \ref{sec:appendix2} several formulas involved in the derivatives computation.

%%header: \textbf{Derivatives of Bezier patch trimmed, $r$-conjunction and convex-hull}\\
%As detailed in Section \ref{sec:cadimplicit}, the model representation is obtained by applying $r$-conjunction and trimming operations.
%The derivatives of these operations can be computed in a straight-forward manner, see \ref{sec:appendix2}.

%header: \textbf{$r$-conjunction}\\
As detailed in Section \ref{sec:cadimplicit}, we perform an $r$-conjunction operation to obtain the model representation.
We compute the derivatives in a straight-forward manner.
Lets denote by $\nabla f * \nabla g$ the matrix with coefficients $\partial_{j} f \partial_{k}g$ for $j,\ k = 1,...,d$.
Then, the derivatives of the $r$-conjunction, presented in Equation \eqref{eq:rconj}, are given by
\begin{equation}\label{eq:gradrconj}
\nabla\ f\wedge g = \nabla f + \nabla g - \nabla\ \sqrt{f^2 + g^2},
\end{equation}
and
\begin{equation}\label{eq:Hessrconj}
\nabla^2\ f\wedge g = \nabla^2 f + \nabla^2 g - \nabla^2\ \sqrt{f^2 + g^2},
\end{equation}
where
\begin{equation}\label{eq:dersqrt}
\nabla\ \sqrt{f^2 + g^2} = \frac{f\nabla f + g\nabla g}{\sqrt{f^2 + g^2}},
\end{equation}
and
%\begin{equation}\label{eq:der2sqrt}
%\begin{array}{r}
%\nabla^2\ \sqrt{f^2 + g^2} = \frac{\nabla f * \nabla f + f\nabla^2 f + \nabla g * \nabla g + g\nabla^2 g}{\sqrt{f^2 + g^2}} - \\
%\frac{\nabla \sqrt{f^2 + g^2} * \nabla \sqrt{f^2 + g^2}}{\sqrt{f^2 + g^2}}.
%\end{array}
%\end{equation}
%\begin{equation*}
%	\nabla^2\ \sqrt{f^2 + g^2} = \frac{\nabla f * \nabla f + f\nabla^2 f + \nabla g * \nabla g + g\nabla^2 g}{\sqrt{f^2 + g^2}} -
%\end{equation*}
%\begin{equation}\label{eq:der2sqrt}
%\frac{\nabla \sqrt{f^2 + g^2} * \nabla \sqrt{f^2 + g^2}}{\sqrt{f^2 + g^2}}.
%\end{equation}
\begin{equation}
\begin{split}
\nabla^2\ \sqrt{f^2 + g^2} = \frac{\nabla f * \nabla f + f\nabla^2 f + \nabla g * \nabla g + g\nabla^2 g}{\sqrt{f^2 + g^2}} - \\
\frac{\nabla \sqrt{f^2 + g^2} * \nabla \sqrt{f^2 + g^2}}{\sqrt{f^2 + g^2}}.
\end{split}
\label{eq:der2sqrt}
\end{equation}
%\begin{align}\label{eq:der2sqrt}
%\nabla^2\ \sqrt{f^2 + g^2} = \frac{\nabla f * \nabla f + f\nabla^2 f + \nabla g * \nabla g + g\nabla^2 g}{\sqrt{f^2 + g^2}} - \\
%\frac{\nabla \sqrt{f^2 + g^2} * \nabla \sqrt{f^2 + g^2}}{\sqrt{f^2 + g^2}}.
%\end{align}
Following Equation \eqref{eq:rconj}, we consider that $f := \gfun_{\zmodel}$ and $g := \gfun_{\overline{\znurbs}}$.

%header: \textbf{Trimming}\\
Similarly to the $r$-conjunction, we compute the derivatives of the trimming operation, presented in Equation \eqref{eq:trim}.
We simplify the computations by noticing that
\begin{equation*}
\tilde{h} := f\text{ trim } h = \sqrt{f^2 + g^2}\ \ \ \text{for}\ \ g := \frac{\sqrt{h^4 + f^2} - f}{2},
\end{equation*}
where, following Equation \eqref{eq:trim}, we consider $f := \gnfun_{\zchull\left(\znurbs\right)}$, $h := \gnfun_{\znurbs}$, and $\tilde{h} := \gfun_{\overline{\znurbs}}$.
Then, to obtain the derivatives of the trimming operation, we differentiate the term $\sqrt{f^2 + g^2}$, see Equations \eqref{eq:dersqrt} and \eqref{eq:der2sqrt}.
In this case, the derivatives of $g$ can be computed as follows
\begin{equation}\label{eq:dertrim}
\nabla g = \frac{1}{2}\left(\frac{2h^3\nabla h + f\nabla f}{\sqrt{h^4 + f^2}} - \nabla f\right),
\end{equation}
and
\begin{eqnarray*}\label{eq:der2trim}
\nabla^2 g = \frac{1}{2}\left(\frac{2h^2\left(h\nabla^2 h + 3\nabla h * \nabla h\right) + f\nabla^2 f + \nabla f * \nabla f}{\sqrt{h^4 + f^2}} - \right.\\
\left. \frac{\nabla \sqrt{h^4 + f^2} * \nabla \sqrt{h^4 + f^2}}{\sqrt{h^4 + f^2}} - \nabla^2 f\right),
\end{eqnarray*}
where the term $\nabla \sqrt{h^4 + f^2}$ can be computed from Equation \eqref{eq:dersqrt} for the functions $f$ and $h^2$.
%Finally, by coupling the derivatives of $g$ and the derivatives of $\sqrt{f^2 + g^2}$ presented in Equations \eqref{eq:dersqrt} and \eqref{eq:der2sqrt} we obtain the derivatives of the trimming operation.
%Herein, we pay special attention to the term $g\nabla g$, see Section \ref{sec:implicitders}.
%\begin{equation*}
%f\text{ trim } g := \sqrt{f^2 + \left(\frac{\sqrt{g^4 + f^2} - f}{2}\right)^2}
%\end{equation*}
%\begin{equation*}
%\nabla \sqrt{g^4 + f^2} = \frac{2g^3\nabla g + f\nabla f}{\sqrt{g^4 + f^2}},
%\end{equation*}
%and
%\begin{equation*}
%\nabla^2 \sqrt{g^4 + f^2} = \frac{2g^2\left(g\nabla^2 g + 3\nabla g * \nabla g\right) + f\nabla^2 f + \nabla f * \nabla f - \nabla \sqrt{g^4 + f^2} * \nabla \sqrt{g^4 + f^2}}{\sqrt{g^4 + f^2}}.
%\end{equation*}

As we observe, the derivatives of both the $r$-conjunction and the trimming operation require the derivatives of the convex-hull and B\'{e}zier patch normalized representations. For completeness, we detail these last derivatives in \ref{sec:appendix2}.

%%header: \textbf{Convex-hull}\\
%Next, we compute the derivatives of the convex-hull representation $\gnfun_{\zchull\left(\znurbs\right)}$.
%and the derivatives of the non-trimmed B\'{e}zier representation $\gnfun_{\znurbs}$.
%In particular, note that the derivatives of the convex-hull representation $\gfun_{\zchull\left(\znurbs\right)}$ are trivial, since the representation of each hyperplane entity is linear.
%In particular, note that these derivatives are trivial since the representation of each hyperplane entity is linear.
%Then, we differentiate the $r$-conjunction between the hyperplane representations $\gfun_{\zchull\left(\znurbs\right)}$, and the normalization of the convex-hull representation $\gnfun_{\zchull\left(\znurbs\right)}$.
%Similarly compute the derivatives of the non-trimmed B\'{e}zier representation $\gnfun_{\znurbs}$.
%In what follows we  the gradient and Hessian of the model representation
%To compute the derivatives of the B\'{e}zier representation $\gnfun_{\overline{\znurbs}}$.
%Now, the derivatives of the B\'{e}zier representation are straightforward, see \ref{sec:appendix2}.
%In particular, we compute the gradient and Hessian of $\gnfun$ in terms of first, second, and third derivatives of $\gfun$.
%For this, we consider the terms $\nabla\gfun,\ \gfun\nabla^2\gfun,\ \gfun^2\nabla^3\gfun$.

%%header: \textbf{Derivatives of Normalized representation}\\
%Now, the remaining derivatives are the ones of the non-trimmed B\'{e}zier representation $\gnfun_{\znurbs}$.
%We compute them by first differentiating the normalized representation $\hat{\gamma}$, presented in Equation \eqref{eq:normalized} and then, the implicit representation $\gamma$ presented in Equation \eqref{eq:implicit}.
%We compute the gradient and Hessian of the normalized representation $\hat{\gamma}$, presented in Equation \eqref{eq:normalized}.
%Specifically, we consider the first, second, and third derivatives of $\gfun$.

%Herein, we compute the derivatives of $\gfun$, presented in Equation \eqref{eq:implicit}.
%When applying the chain rule to the derivatives of the trimming operation of Equation \eqref{eq:trim}, we observe that the required terms are $\nabla\gnfun$ and $\gnfun\nabla^2\gnfun$.
%Moreover, they involve the terms $\nabla\gfun$, $\gfun\nabla^2\gfun$, and $\gfun^2\nabla^3\gfun$.
%As we will see, this observation is advantageous because a straight-forward computation of the second and third derivatives $\nabla^2\gfun, \nabla^3\gfun$ induces a singularity at the corresponding zero level-set of $\gfun$.
%For this reason, instead of computing directly the derivatives we consider them multiplied by the representation $\gfun$.
%The presented equations are used for the gradient and Hessian of $\gnfun$ which involves the second and third derivatives terms $\gfun\nabla^2\gfun$, $\gfun^2\nabla^3\gfun$.
%The higher-order derivatives of the determinant, $\gfun\nabla^2\gfun$ and $\gfun^2\nabla^3\gfun$, can be written in terms of the derivatives of the adjugate matrix, presented in Equation \eqref{eq:adjder}.

%For this, we consider the terms $\nabla\gfun,\ \gfun\nabla^2\gfun,\ \gfun^2\nabla^3\gfun$.

%%header: \textbf{Derivatives of adjugate}\\
%Herein, we compute the derivatives of $\gfun$, presented in Equation \eqref{eq:implicit}.
%For this, we proceed first with the derivatives matrix terms.
%These are determined by the expression of the gradient of the determinant.
%We differentiate the determinant by using the Jacobi's formula
%\begin{equation*}
%%\det\left(\mathbb{N}\left(\zx\right)\right)
%\nabla \gfun\left( \zx \right) = \tr\left(\zadj\cdot \nabla\mathbb{N}\left(\zx\right)\right),
%\end{equation*}
%where $\mathbb{N}\left(\zx \right) := \mathbb{M}\left(\zx\right)\cdot \mathbb{M}\left(\zx\right)^{\text{T}}$.
%Instead of considering the inverse matrix, we consider
%By considering the adjugate matrix we avoid the singularity issues at the patch $\znurbs$.
%Specifically, we consider the adjugate matrix of $\mathbb{N}\left(\zx \right)$, defined by the transposed cofactor matrix, and satisfying the relation $\zadj = \gfun\left(\zx\right)\mathbb{N}\left(\zx\right)^{-1}$ \cite{upreti2014algebraic}.
%This is because, the matrix $\mathbb{M}\left(\zx\right)$ is singular at the patch $\znurbs$ and hence, it is not invertible.
%Then, we differentiate the adjugate matrix in terms of the derivatives of the inverse matrix multiplied by the determinant.
%Then, to rewrite the obtained expression in terms of the adjugate matrix we multiply both expressions by the determinant $\gfun$.
%We summarize it as
%\begin{equation}\label{eq:adjder}
%\gfun\left(\zx\right)\nabla\zadj = \gfun\left(\zx\right)\nabla\left(\gfun\left(\zx\right)\mathbb{N}\left(\zx\right)^{-1}\right) = \zadj\nabla\gfun\left(\zx\right) - \mathbb{N}\left(\zx\right)\cdot\zadj\cdot\mathbb{N}\left(\zx\right).
%\end{equation}
%We apply the same reasoning for the Hessian by computing
%\begin{equation*}
%\gfun\left(\zx\right)^2\nabla^2\zadj = \gfun\left(\zx\right)^2 \nabla\left(\frac{1}{\gfun\left(\zx\right)}\gfun\left(\zx\right)\nabla\zadj\right).
%\end{equation*}
%In particular, using the same notation as in Section \ref{sec:interpDeriv}, for each $j$ and $k$ we have
%\begin{eqnarray*}
%	\gfun\left(\zx\right)^2\partial_{jk}\zadj = \left(\gfun \partial_{jk}\gfun\right)\zadj - \gfun \partial_k\zadj \cdot \partial_j\zmat \cdot\zadj - \\
%	\zadj \cdot \partial_j\zmat\cdot\gfun \partial_k\zadj - \gfun\zadj\cdot\partial_{jk}\zmat\cdot\zadj.
%\end{eqnarray*}
%\begin{equation*}
%\gfun\left(\zx\right)^2\nabla^2\mathbb{N}\left(\zx\right)^* = \left(\gfun \nabla^2\gfun\right)\zadj - \gfun \nabla\zadj \cdot \nabla\zmat \cdot\zadj - 
%\zadj \cdot \nabla\zmat\cdot\gfun \nabla\zadj - \gfun\zadj\cdot\nabla^2\zmat\cdot\zadj
%\end{equation*}
%The presented equations are used for the gradient and Hessian of $\gnfun$ which involves the second and third derivatives terms $\gfun\nabla^2\gfun$, $\gfun^2\nabla^3\gfun$.

%The higher-order derivatives of the determinant, $\gfun\nabla^2\gfun$ and $\gfun^2\nabla^3\gfun$, can be written in terms of the derivatives of the adjugate matrix, presented in Equation \eqref{eq:adjder}.
%In addition, they are computed by differentiating the terms inside the trace function.
%In particular, using the same notation as in Section \ref{sec:interpDeriv}, for each $j$ and $k$ the second derivatives are given by
%\begin{equation*}
%\gfun\left(\zx\right)\partial_{jk} \gfun\left( \zx \right) = \tr\left(\gfun\left(\zx\right)\partial_{k}\zadj\cdot \partial_{j}\mathbb{N}\left(\zx\right) + \gfun\left(\zx\right)\zadj\cdot \partial_{jk}\mathbb{N}\left(\zx\right)\right).
%\end{equation*}
%In addition, the third derivatives are given by
%\begin{equation*}
%\gfun\left(\zx\right)^2\partial_{j k \ell}\gfun\left( \zx \right) = \tr\left(\gfun\left(\zx\right)^2\partial_{k \ell}\zadj \cdot \partial_j \mathbb{N}\left(\zx\right) + \gfun\left(\zx\right)^2\partial_k\zadj \cdot \partial_{j \ell} \mathbb{N}\left(\zx\right) + \gfun\left(\zx\right)^2\partial_\ell\zadj \cdot \partial_{jk} \mathbb{N}\left(\zx\right)  \right),
%\end{equation*}
%for each $j$, $k$, and $\ell$.
\subsection{Minimizing metric and geometry deviations}\label{sec:penalty}
%header: \textbf{Overview}\\
In this section, we consider a modification of the methodology to generate curved high-order meshes featuring optimal mesh quality and geometric accuracy presented in \cite{ruiz2016generation,ruiz2022automatic}.
This technique combines a distortion measure and a geometric $L^2$-disparity measure into a single objective function.
While the element distortion term takes into account the mesh quality, the $L^2$-disparity term takes into account the geometric error introduced by the mesh approximation to the target geometry. Herein, the target geometry is an implicit representation.

%header: \textbf{Input data}\\
Our input data is a CAD model, $\zmodel$, composed of several geometric entities in such manner that
\begin{equation*}
\zmodel = \bigcup_{k = 1}^n \zmodel_k,
\end{equation*}
where each geometric entity is composed of sub-entities.
These sub-entities are curves in 2D, and curves and surfaces in 3D.
In 3D, we consider that the curves are embedded directly in the containing space.
%We do not consider the 3D curves as embedded sub-entities of a 3D surface.

%header: \textbf{Surfaces trimmed by curves}\\
%In 2D, the curve entities are usually trimmed in the parametric domain.
%That is, their real domain matches the input one.
%However, in 3D, the real domain of the surface entities that is, the one that makes the model consistent, may not match the input one.
%This is because the curves that trim the surface are not considered when determining the parametric domain of the surface.
%That is, they are imposed to trim the surface in the embedded domain but not in the parametric one.
%Hence, the implicit representations may not be faithful.
%For the 3D cases, we consider the unit square as the parametric domain.
%Hence, we do not trim the surfaces.
%In addition, we consider the implicit representation of the embedded curves.
%As we will see, these curve representations are used to avoid an overlapping between the surface entities.
In our representation, we consider that the curves are the image of a segment.
Moreover, we consider that the surfaces are the image of a rectangular region.
For the 3D cases, we consider the implicitization of the curves and surfaces.
In this manner, we can allow the inner curve (surface) nodes to target the implicitization of the corresponding curve (surface).

%header: \textbf{entity-wise representation: marking}\\
In what follows, we propose an entity-wise implicit representation of the CAD model $\zmodel$.
We use it to measure the geometric deviation between the mesh and the model.
In particular, for each geometric entity $\zmodel_k$ we consider the implicit representation, see Section \ref{sec:implicit}.
This geometric entity is approximated by a set of boundary mesh entities, denoted by $\partial\zmesh\left( \zmodel_k \right)$.
Instead of measuring the geometric error, herein we account from the geometric deviation through the average of the square of the level set value.
This term is zero when on top of the target CAD entity, and the square ensures deriviability at the zero-level set.
%To measure the geometric error we consider an $L^2$-disparity based in the implicit representation of $\zmodel_k$, $\gamma_{\zmodel_k}$.
Specifically, this deviation measure is integrated over the candidate boundary mesh entities as follows
\begin{equation}\label{eq:geoapprox}
\altmathcal{G}\left(\partial\zmesh\left( \zmodel_k \right)\right) := \int_{\partial\zmesh\left( \zmodel_k \right)} \gfun^2.
\end{equation}
Note that, the model representation $\gfun^{}_{\zmodel_k}$ is not differentiable at the zero level-set.
By considering the squared function ${\gfun^{}_{\zmodel_k}}^2$ we avoid the derivative singularity.

%header: \textbf{Coupled Functional}\\
%Els vertexos impediran que les arestes vagin on no toca, les arestes impediran que les cares vagin on no toca.
Our objective is to determine an optimal physical mesh, $\zmesh$, in terms of mesh quality and
geometric deviation.
First, the mesh quality deviation term, distortion, is presented in Section \ref{sec:preliminaries}.
Second, we consider Equation \eqref{eq:geoapprox} to take into account the geometric deviation.
Finally, we define the functional for the mesh quality and the geometric deviation
\begin{equation}\label{eq:curving}
\altmathcal{H}\left(\zmesh; \lambda\right) := \altmathcal{F}\left(\zmesh\right) + \lambda \altmathcal{G}\left(\partial\zmesh\right),
%	\zmesh^* := \argmin_{\zmesh}
\end{equation}
where
\begin{equation*}\label{eq:curvingterm}
\altmathcal{G}\left(\partial\zmesh\right) := \sum_{k = 1}^{n} \altmathcal{G}\left(\partial\zmesh\left( \zmodel_k \right)\right),
%\int_{\partial\zmesh} \gfun^2
\end{equation*}
and where $\lambda$ corresponds to the penalty parameter. This parameter $\lambda$ can be chosen heuristically or with an automatic procedure \cite{ruiz2022automatic}.

To deal with corners and geometric edges, we distinguish between nodes targeting points or curves of the geometry. For points, we associate the corresponding node with the incident curves. Moreover, for this node, the objective function accounts for the measure of the distance to all the incident curves. Thus, the optimal node is close to the target point because it is close to all the incident curves. For curves, we associate the corresponding nodes with the curve and the incident surfaces. Moreover, for these nodes, the objective function accounts for the measure of the distance to the curve and the two incident surfaces. Thus, the optimal nodes are close to the target curve and the two incident surfaces.

%Using this approach it is easy to embed points, curves, and surfaces inside a volume mesh if we consider the embedded entities as boundary entities.


%\begin{figure*}[t!]
%	\centering
%	\begin{tabular}{cc}
%		\subfloat[]{\label{fig:cad}\includegraphics[width=0.30\textwidth]{./naca0024_curve.png}}&
%		\subfloat[]{\label{fig:implicit}\includegraphics[width=0.30\textwidth]{./naca0024_lin.png}}\\
%%	\end{tabular}\\
%%	\label{fig:naca}
%%	\centering
%%	\begin{tabular}{cc}
%		\subfloat[]{\label{fig:initialmesh}\includegraphics[width=0.30\textwidth]{./naca0024_0.png}}&
%		\subfloat[]{\label{fig:adaptedmesh}\includegraphics[width=0.30\textwidth]{./naca0024_1.png}}\\
%	\end{tabular}
%	\\
%	\includegraphics[width=0.30\textwidth]{./colorbar.png}
%	\caption{Implicit representation of the CAD geometry for NACA0024.}
%%	\caption{Meshes}
%	\label{fig:nacamesh}
%\end{figure*}
%%header: \textbf{Figure mesh}\\
%In Figure \ref{fig:nacamesh}, we illustrate the presented methodology for a NACA0024 CAD model.
%The model is given by two curves $\zmodel = \zmodel_1 \cup \zmodel_2$.
%Specifically, $\zmodel_1$ corresponds to the curve of the bounding box.
%In addition, $\zmodel_2$ corresponds to the curve of the airfoil section.
%First we show the curves of the CAD model, see Figure \ref{fig:nacamesh}\subref{fig:cad}.
%Then, we compute the implicit representation of the whole model $\zmodel$, see Figure \ref{fig:nacamesh}\subref{fig:implicit}.
%In Figure \ref{fig:nacamesh}\subref{fig:initialmesh}, we show an initial straight-sided quadratic mesh.
%We observe that the boundary elements cannot approximate the curves of the CAD model.
%We adapt this mesh by minimizing the functional presented in Equation \eqref{eq:curving}, see Figure \ref{fig:nacamesh}\subref{fig:adaptedmesh}.
%Now, we observe that the curved mesh approximates the curves of the CAD model.
%\begin{algorithm}[t!]
%	\caption{Distortion optimization}\label{alg:adaption0}
%	\textbf{Input:} $\Lambda,\ \altmathcal{M},\ \left( \hat{\altmathcal{M}},\ \hat{\textbf{M}}\right)$\\
%	\textbf{Output:} $\altmathcal{M}^*$
%	\begin{algorithmic}[1]
%%		\Procedure{DistortionOptimization}{}
%		\State $\textbf{X} :=$ mesh coordinates
%		\State $d\textbf{X} :=$ boundary mesh coordinates
%		\State $\textbf{M} = \textrm{LogEuclidean}\left( \hat{\textbf{M}} \right)$
%		\State $\nabla\textbf{M} = \nabla\textrm{LogEuclidean}\left( \hat{\textbf{M}} \right)$
%		\State $\nabla^2\textbf{M} = \nabla^2\textrm{LogEuclidean}\left( \hat{\textbf{M}} \right)$
%		\State $\altmathcal{F}:=\altmathcal{F}\left(\textbf{X},\textbf{M}\right)$
%		\State $\nabla\altmathcal{F}:=\nabla\altmathcal{F}\left(\textbf{X},\textbf{M}\right)$
%		\State $\nabla^2\altmathcal{F}:=\nabla^2\altmathcal{F}\left(\textbf{X},\textbf{M}\right)$
%		\State $\gamma := \gamma\left(d\textbf{X},\Lambda \right)$
%		\State $\altmathcal{G} := \altmathcal{G}\left(d\textbf{X},\gamma \right)$
%		\State $\nabla \altmathcal{G} := \nabla \altmathcal{G}\left(d\textbf{X},\gamma \right)$
%		\State $\nabla^2 \altmathcal{G} := \nabla^2 \altmathcal{G}\left(d\textbf{X},\gamma \right)$
%		\State $\altmathcal{H} := \altmathcal{F} + \lambda \altmathcal{G}$
%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F} + \lambda \nabla\altmathcal{G}$
%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F} + \lambda \nabla^2\altmathcal{G}$
%		\State $\textbf{X}^* = \textrm{NewtonMethod}\left(\altmathcal{H},\nabla \altmathcal{H},\nabla^2 \altmathcal{H},\textbf{X},\varepsilon\right)$
%%		\State \RETURN $\altmathcal{M}^*$
%%		\EndProcedure
%	\end{algorithmic}
%\end{algorithm}
%\begin{algorithm}[t!]
%	\caption{Distortion optimization}\label{alg:adaption}
%	\textbf{Input:} $\zmodel,\ \altmathcal{M},\ \left( \hat{\altmathcal{M}},\ \hat{\textbf{M}}\right),\ \varepsilon,\ \lambda$\\
%%	\textbf{Declarations} $ $ \\
%	\textbf{Output:} $\altmathcal{M}^*$
%	\begin{algorithmic}[1]
%		%		\Procedure{DistortionOptimization}{}
%		\State $\textbf{X} :=$ mesh coordinates
%		\State $d\textbf{X} :=$ boundary mesh coordinates
%		\State $\hat{\zxi},\ \nabla \hat{\zxi},\ \nabla^2 \hat{\zxi} = \textrm{Localize}(\hat{\altmathcal{M}},\textbf{X})$
%		\State $\textbf{M},\ \nabla \textbf{M},\ \nabla^2 \textbf{M} = \textrm{LogEuclideanInterpolation}\left(\hat{\textbf{M}}, \hat{\zxi},\nabla \hat{\zxi},\nabla^2 \hat{\zxi} \right)$
%		\State $\gamma,\ \nabla \gamma,\ \nabla^2 \gamma = \textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$
%		\State $\altmathcal{H} := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right) + \lambda \altmathcal{G}\left(d\textbf{X},\gamma \right)$
%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M}\right) + \lambda \nabla\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma\right)$
%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M},\nabla^2 \textbf{M}\right) + \lambda \nabla^2\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma,\nabla^2 \gamma \right)$
%		\State $\textbf{X}^* = \textrm{NewtonMethod}\left(\altmathcal{H},\nabla \altmathcal{H},\nabla^2 \altmathcal{H},\textbf{X},\varepsilon\right)$
%	\end{algorithmic}
%\end{algorithm}
%\begin{algorithm}[t!]
%	\caption{Distortion optimization}\label{alg:adaption}
%	\textbf{Input:} $\zmodel,\ \altmathcal{M},\ \left( \hat{\altmathcal{M}},\ \hat{\textbf{M}}\right),\ \varepsilon,\ \lambda$\\
%	%	\textbf{Declarations} $ $ \\
%	\textbf{Output:} $\altmathcal{M}^*$
%	\begin{algorithmic}[1]
%		%		\Procedure{DistortionOptimization}{}
%		\State $\textbf{X} :=$ mesh coordinates
%		\State $d\textbf{X} :=$ boundary mesh coordinates
%%		\State $\hat{\zxi},\ \nabla \hat{\zxi},\ \nabla^2 \hat{\zxi} = \textrm{Localize}(\hat{\altmathcal{M}},\textbf{X})$
%		\State $\textbf{M} := \textrm{LogEuclideanInterpolation}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$, Section \ref{sec:meshInterp}
%%		Equation \eqref{eq:exponential}
%		\State $\nabla \textbf{M} := \nabla\textrm{LogEuclideanInterpolation}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$, Section \ref{sec:interpDeriv}
%		\State $\nabla^2 \textbf{M} := \nabla^2\textrm{LogEuclideanInterpolation}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$, Section \ref{sec:interpDeriv}
%%		\State $\gamma,\ \nabla \gamma,\ \nabla^2 \gamma = \textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$
%		\State $\gamma := \textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$, Section \ref{sec:cadimplicit}
%%		Algorithm \ref{alg:implicit}
%		\State $\nabla\gamma := \nabla\textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$, Section \ref{sec:implicitders}
%		\State $\nabla^2\gamma := \nabla^2\textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$, Section \ref{sec:implicitders}
%		\State $\altmathcal{F} := \altmathcal{F}\left(\textbf{X}, \textbf{M},\gamma\right)$
%		\State $\altmathcal{H} := \altmathcal{H}\left(\textbf{X}, \textbf{M},\gamma\right) := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right) + \lambda \altmathcal{G}\left(d\textbf{X},\gamma \right)$, Equation \eqref{eq:curving}
%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M}\right) + \lambda \nabla\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma\right)$
%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M},\nabla^2 \textbf{M}\right) + \lambda \nabla^2\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma,\nabla^2 \gamma \right)$
%		\State $\textbf{X}^* = \textrm{Non-linearSolver}\left(\altmathcal{H},\nabla \altmathcal{H},\nabla^2 \altmathcal{H},\textbf{X},\varepsilon\right)$
%	\end{algorithmic}
%\end{algorithm}

\begin{algorithm}[t!]
	\caption{Distortion minimization}\label{alg:adaption}
	\textbf{Input:} $\zmodel,\ \altmathcal{M},\ \hat{\altmathcal{M}},\ \hat{\textbf{M}},\ \varepsilon,\ \lambda$\\
	%	\textbf{Declarations} $ $ \\
	\textbf{Output:} $\altmathcal{M}^*$
	\begin{algorithmic}[1]
		%		\Procedure{DistortionOptimization}{}
%		\State 
		\State $\textbf{X} \gets \textrm{coordinates}(\altmathcal{M})$
		\State $\partial\textbf{X} \gets \textrm{coordinates}(\partial \altmathcal{M})$
%		\Statex\Comment{See Section \ref{sec:interpolation}}
		%		\State $\hat{\zxi},\ \nabla \hat{\zxi},\ \nabla^2 \hat{\zxi} = \textrm{Localize}(\hat{\altmathcal{M}},\textbf{X})$
		\State $\textbf{M} := \textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$ \Comment{Section \ref{sec:meshInterp}}
		%		Equation \eqref{eq:exponential}
		\State $\nabla \textbf{M} := \nabla\textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$; 
%		\Comment{Section \ref{sec:interpDeriv}}
		$\nabla^2 \textbf{M} := \nabla^2\textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$ \Comment{Section \ref{sec:interpDeriv}}
		%		\State $\gamma,\ \nabla \gamma,\ \nabla^2 \gamma = \textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$
%		\Statex \Comment{See Section \ref{sec:implicit}}
		\State $\gamma := \gamma\left( \zmodel, \partial\textbf{X} \right)$ \Comment{Section \ref{sec:cadimplicit}}
		%		Algorithm \ref{alg:implicit}
		\State $\nabla\gamma := \nabla\gamma\left( \zmodel, \partial\textbf{X} \right)$;
%		\Comment{Section \ref{sec:implicitders}}
		$\nabla^2\gamma := \nabla^2\gamma\left( \zmodel, \partial\textbf{X} \right)$ \Comment{Section \ref{sec:implicitders}}
%		\Statex \Comment{See Section \ref{sec:preliminaries}, Equation \eqref{eq:minfun}}
		\State $\altmathcal{F} := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right)$; \Comment{Section \ref{sec:preliminaries}, Equation \eqref{eq:minfun}}
		\State $\nabla\altmathcal{F} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla\textbf{M}\right)$; $\nabla^2\altmathcal{F} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla\textbf{M},\nabla^2\textbf{M}\right)$
%		\Statex \Comment{See Section \ref{sec:implicit}, Equation \eqref{eq:geoapprox}}
		\State $\altmathcal{G} := \altmathcal{G}\left(\partial\textbf{X},\gamma\right)$; \Comment{Section \ref{sec:implicit}, Equation \eqref{eq:geoapprox}}
		\State $\nabla\altmathcal{G} := \nabla\altmathcal{G}\left(\partial\textbf{X},\gamma,\nabla\gamma\right)$; $\nabla^2\altmathcal{G} := \nabla^2\altmathcal{G}\left(\partial\textbf{X},\gamma,\nabla\gamma,\nabla^2\gamma\right)$
%		and \eqref{eq:curvingterm}
		\State $\altmathcal{H} \gets \altmathcal{F} + \lambda \altmathcal{G}$ \Comment{Section \ref{sec:implicit}, Equation \eqref{eq:curving}}
%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F} + \lambda \nabla\altmathcal{G}$
%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F} + \lambda \nabla^2\altmathcal{G}$
%		\State $\altmathcal{H} := \altmathcal{H}\left(\textbf{X}, \textbf{M},\gamma\right) := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right) + \lambda \altmathcal{G}\left(d\textbf{X},\gamma \right)$, Equation \eqref{eq:curving}
%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M}\right) + \lambda \nabla\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma\right)$
%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M},\nabla^2 \textbf{M}\right) + \lambda \nabla^2\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma,\nabla^2 \gamma \right)$
		\State $\textbf{X}^* \gets \textrm{Non-linearSolver}\left(\altmathcal{H},\nabla \altmathcal{H},\nabla^2 \altmathcal{H},\textbf{X},\varepsilon\right)$ \Comment{Section \ref{sec:preliminaries}, Equation \eqref{eq:argmin}}
		\State $\altmathcal{M}^*\gets$ update coordinates of $\altmathcal{M}$ with $\textbf{X}^*$
%		\State $\altmathcal{M}^*\gets$ setcoordinates$(\altmathcal{M},\textbf{X}^*)$
%		M* := update coordinates of M with X*
	\end{algorithmic}
\end{algorithm}
In Algorithm \ref{alg:adaption}, we outline the structure of the distortion minimization. The algorithm inputs are: a CAD model $\zmodel$, a physical mesh $\altmathcal{M}$, a background mesh $\hat{\altmathcal{M}}$ equipped with a discrete metric $\hat{\textbf{M}}$, a residual tolerance $\varepsilon$, and a penalty parameter $\lambda$. The output is an optimized physical mesh $\altmathcal{M}^*$ with the same connectivity of $\altmathcal{M}$ and matching the metric $\hat{\textbf{M}}$ and the curved boundary $\zmodel$.
To outline the algorithm, we assign variables, and we declare the corresponding functions and their derivatives in terms of previously defined functions and derivatives.  We recall that, the implementation details of the values and derivatives of the log-Euclidean interpolation $\textbf{M}$ and the implicitation $\gamma$ are detailed in Section \ref{sec:interpolation} and Section \ref{sec:implicit}, respectively. Note that the derivatives of $\altmathcal{F}$ and $\altmathcal{G}$ depend on the corresponding derivatives of $\textbf{M}$ and $\gamma$, respectively.

Algorithm \ref{alg:adaption} proceeds as follows.
First, we assign the volume and boundary mesh coordinates to $\textbf{X}$ and $d\textbf{X}$, respectively.
From these coordinates, we declare the Log-Euclidean interpolation of the discrete metric $\hat{\textbf{M}}$ and its derivatives, $\nabla \hat{\textbf{M}}$ and $\nabla^2 \hat{\textbf{M}}$, see Section \ref{sec:interpolation}.
In addition, from the CAD model $\zmodel$, we declare the implicitization $\gamma$ and its derivatives, $\nabla\gamma$ and $\nabla^2\gamma$, in terms of $d\textbf{X}$, see Section \ref{sec:implicit}.
Then, we declare the distortion functional $\altmathcal{F}$ and the boundary functional  $\altmathcal{G}$.
For these functionals, we also declare the dependency of their derivatives in terms of the values and derivatives of the metric $\textbf{M}$ interpolation and the geometry implicitation $\gamma$. These declarations allow assigning the objective function $\altmathcal{H}$ according to the functionals, $\altmathcal{F}$ and $\altmathcal{G}$, and the penalty parameter $\lambda$, see Equation \eqref{eq:curving}.
Finally, we call a second-order non-linear solver to minimize the objective function up to a residual tolerance $\varepsilon$. This results in an adapted mesh $\altmathcal{M}^*$ with coordinates $\textbf{X}^*$ and with the same connectivity as $\altmathcal{M}$.

%Then, we couple the distortion term $\altmathcal{F}$ with the boundary one $\altmathcal{G}$ in the function $\altmathcal{H}$ according to the penalty parameter $\lambda$, see Equation \eqref{eq:curving}.
%Finally, we call a second-order non-linear solver for the minimization of the objective function up to a residual tolerance $\varepsilon$.
%This results in an adapted mesh configuration $\altmathcal{M}^*$ with coordinates $\textbf{X}^*$ and with the same connectivity as $\altmathcal{M}$.

%In Algorithm \ref{alg:adaption}, to call the non-linear solver, we declare the dependencies of the objective function $\altmathcal{H}$ and its derivatives in terms of other functions and their derivatives.
%We recall that, the implementation details of the values and derivatives of the log-Euclidean interpolation $\textbf{M}$ and the implicitation $\gamma$ are respectively detailed in Section \ref{sec:interpolation} and Section \ref{sec:implicit}.
%Note that the derivatives of $\altmathcal{F}$ and $\altmathcal{G}$ depend on the corresponding derivatives of $\textbf{M}$ and $\gamma$, respectively.
%
%The algorithm inputs are: a CAD model $\zmodel$, a physical mesh $\altmathcal{M}$, a background mesh $\hat{\altmathcal{M}}$ equipped with a discrete metric $\hat{\textbf{M}}$, a residual tolerance $\varepsilon$, and a penalty parameter $\lambda$.
%The output is an adapted physical mesh $\altmathcal{M}^*$.
%First, we define the volume and boundary mesh coordinates as $\textbf{X}$ and $d\textbf{X}$, respectively.
%From these coordinates, we declare the Log-Euclidean interpolation of the discrete metric $\hat{\textbf{M}}$ and its derivatives $\nabla \hat{\textbf{M}},\ \nabla^2 \hat{\textbf{M}}$, see Section \ref{sec:interpolation}.
%In addition, from the CAD model $\zmodel$, we declare the implicitization $\gamma$ and its derivatives $\nabla\gamma,\ \nabla^2\gamma$ at the boundary mesh coordinates $d\textbf{X}$, see Section \ref{sec:implicit}.
%Then, we couple the distortion term $\altmathcal{F}$ with the boundary one $\altmathcal{G}$ in the function $\altmathcal{H}$ according to the penalty parameter $\lambda$, see Equation \eqref{eq:curving}.
%%Similarly, we define the derivatives of the objective function.
%Finally, we call a non-linear solver for the minimization of the objective function up to a residual tolerance $\varepsilon$.
%This results in an adapted mesh configuration $\altmathcal{M}^*$ with coordinates $\textbf{X}^*$ and with the same connectivity as $\altmathcal{M}$. 

%\begin{algorithm}[t!]
%	\caption{Distortion optimization}\label{alg:adaption}
%	\textbf{Input:} $\zmodel,\ \altmathcal{M},\ \left( \hat{\altmathcal{M}},\ \hat{\textbf{M}}\right),\ \varepsilon,\ \lambda$\\
%	%	\textbf{Declarations} $ $ \\
%	\textbf{Output:} $\altmathcal{M}^*$
%	\begin{multicols}{2}
%		\begin{algorithmic}[1]
%			%		\Procedure{DistortionOptimization}{}
%			%		\State 
%			\State $\textbf{X} :=$ mesh coordinates
%			\State $d\textbf{X} :=$ boundary mesh coordinates
%			\State // See Section \ref{sec:interpolation}
%			%		\State $\hat{\zxi},\ \nabla \hat{\zxi},\ \nabla^2 \hat{\zxi} = \textrm{Localize}(\hat{\altmathcal{M}},\textbf{X})$
%			\State $\textbf{M} := \textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$
%			%		Equation \eqref{eq:exponential}
%			\State $\nabla \textbf{M} := \nabla\textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$
%			\State $\nabla^2 \textbf{M} := \nabla^2\textbf{M}\left(\hat{\altmathcal{M}},\hat{\textbf{M}},\textbf{X}\right)$
%			%		\State $\gamma,\ \nabla \gamma,\ \nabla^2 \gamma = \textrm{Implicitization}\left( \zmodel, d\textbf{X} \right)$
%			\State // See Section \ref{sec:implicit}
%			\State $\gamma := \gamma\left( \zmodel, d\textbf{X} \right)$
%			%		Algorithm \ref{alg:implicit}
%			\State $\nabla\gamma := \nabla\gamma\left( \zmodel, d\textbf{X} \right)$
%			\State $\nabla^2\gamma := \nabla^2\gamma\left( \zmodel, d\textbf{X} \right)$
%			\State // See Section \ref{sec:preliminaries}
%			\State $\altmathcal{F} := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right)$
%			\State $\nabla\altmathcal{F} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla\textbf{M}\right)$
%			\State $\nabla^2\altmathcal{F} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla\textbf{M},\nabla^2\textbf{M}\right)$
%			\State // This section
%			\State $\altmathcal{G} := \altmathcal{G}\left(d\textbf{X},\gamma\right)$
%			%		and \eqref{eq:curvingterm}
%			\State $\nabla\altmathcal{G} := \nabla\altmathcal{G}\left(d\textbf{X},\gamma,\nabla\gamma\right)$
%			\State $\nabla^2\altmathcal{G} := \nabla^2\altmathcal{G}\left(d\textbf{X},\gamma,\nabla\gamma,\nabla^2\gamma\right)$
%			\State $\altmathcal{H} := \altmathcal{F} + \lambda \altmathcal{G}$
%			\State $\nabla\altmathcal{H} := \nabla\altmathcal{F} + \lambda \nabla\altmathcal{G}$
%			\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F} + \lambda \nabla^2\altmathcal{G}$
%			%		\State $\altmathcal{H} := \altmathcal{H}\left(\textbf{X}, \textbf{M},\gamma\right) := \altmathcal{F}\left(\textbf{X}, \textbf{M}\right) + \lambda \altmathcal{G}\left(d\textbf{X},\gamma \right)$, Equation \eqref{eq:curving}
%			%		\State $\nabla\altmathcal{H} := \nabla\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M}\right) + \lambda \nabla\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma\right)$
%			%		\State $\nabla^2\altmathcal{H} := \nabla^2\altmathcal{F}\left(\textbf{X}, \textbf{M},\nabla \textbf{M},\nabla^2 \textbf{M}\right) + \lambda \nabla^2\altmathcal{G}\left(d\textbf{X},\gamma,\nabla \gamma,\nabla^2 \gamma \right)$
%			\State $\textbf{X}^* = \textrm{Non-linearSolver}\left(\altmathcal{H},\nabla \altmathcal{H},\right.$\\
%			$\left.\nabla^2 \altmathcal{H},\textbf{X},\varepsilon\right)$
%			\State $\altmathcal{M}^*:=$ update coordinates of $\altmathcal{M}$ with $\textbf{X}^*$
%			%		M* := update coordinates of M with X*
%		\end{algorithmic}
%	\end{multicols}
%\end{algorithm}

%In Algorithm XX, to call the non-linear solver, we declare the dependencies of the objective function H and its derivatives in terms of other functions and derivatives. Recall in this work the implementation details of the values and derivatives of the log-Euclidean interpolation M and the implicitation gamma are detailed in Section 4 and Section 5. Note that the derivatives of F and G depend on the corresponding derivatives of M and gamma, respectively.
%
%gamma is a function from a point to the reals that depends on Lambda and dX. The details of these function are in Section 5.1. Grad_gamma and hess_gamma are the gradient and the hessian in terms of the physical coordinates and their expressions are detailed in Section xx and Section yy, respectively.
\section{Results}
\label{sec:results}

%\textbf{Test examples that show second-order convergence?: metric interpolation over high-order square domain}\\

In this section, we present a 2D and a 3D example to illustrate the applicability of our distortion minimization framework for curved $r$-adaption to a high-order metric interpolation while preserving the implicit representation of the boundary.
First, we generate a background mesh $\zbmesh$ and we evaluate the analytical metric $\zmetric$ at the background mesh nodes.
Second, we generate an initial physical mesh $\zmesh$ and we measure its distortion (quality) by interpolating the metric.
Then, by relocating the nodes, we minimize the mesh distortion problem presented in Equation \eqref{eq:argmin} using the framework presented in this work.
Moreover, in the last examples, we consider a boundary term that takes into account the geometric deviation.
We relocate the nodes to minimize the distortion measure while preserving the curved features of the boundary.

To summarize the results, we present a statistics table for the element quality of Equation \eqref{eq:qualityreg}, and the figures for the initial and optimized meshes.
Specifically, we show the minimum quality, the maximum quality, the mean quality, and the standard deviation of the initial and optimized meshes.
We highlight that in all cases, the optimized mesh increases the minimum element quality and it does not include any inverted element.
In addition, the meshes resulting after the optimization are composed of elements aligned and stretched to match the target metric tensor.
In all figures, the meshes are colored according to the point-wise quality presented in Equation \eqref{eq:pointwisequality}.

Because our goal is to optimize the mesh distortion using the detailed derivatives, instead of including mathematical proofs of mesh validity, we detail how we numerically enforce the positiveness of the element Jacobians.
Specifically, we use a numerical valid-to-valid approach that uses four ingredients.
First, because we want numerically valid results, we enforce mesh validity on the integration points.
Second, to initialize the optimization, we start from a numerically valid mesh. Third, to penalize inverted elements, we modify the point-wise distortion, Equation \eqref{eq:pointwisequality}, to be infinity for non-positive Jacobians.
Specifically, we regularize the element Jacobians to be zero for non-positive Jacobians, so their reciprocals are infinite.
Note that these reciprocals appear in the distortion expression, and thus, they determine the infinite distortion value.
Fourth, to enforce numerically valid mesh displacements, we equip Newton's method with a backtracking line-search.
Specifically, if the mesh optimization update is invalid in any integration point, the objective function, Equation \eqref{eq:argmin}, is infinite.
In that case, the step is divided by two until it leads to a valid mesh update.

As a proof of concept, a mesh optimizer has been developed in Julia 1.6.2 \cite{bezanson2017julia}.
For this, we use the following external packages: Arpack v0.5.0, ILUZero v0.1.0, and TensorOperations v3.1.0.
In addition, we use the MATLAB PDE Toolbox \cite{MATLAB:2017} to generate the initial isotropic linear unstructured 2D and 3D meshes (the structured meshes are generated by subdivision), and the MMG algorithm \cite{dobrzynski2012mmg3d} to generate the initial anisotropic linear unstructured 2D and 3D meshes.
To construct the geometric models, we use the FreeCAD software \cite{riegel2016freecad}.
Finally, we use the Quickhull (Qhull) algorithm \cite{barber1996quickhull} for the convex-hull computations required in the geometric model's implicitization, see Section \ref{sec:implicit}.

%	serial (one execution thread) for the nonlinear optimization method and, multithreaded for the evaluation of the objective function, its gradient and, its Hessian presented in \cite{aparicio2018defining}.
The Julia prototyping code is sequential, it corresponds to the implementation of the method presented in this work and the one presented in \cite{aparicio2018defining,aparicio2019imr,aparicio2021icosahom}.
In all the examples, the optimization corresponds to finding a minimum of a nonlinear unconstrained multi-variable function.
In particular, the mesh optimizer uses an unconstrained line-search globalization with an iterative preconditioned conjugate gradients linear solver.
The stopping condition is set to reach an absolute root mean square residual, defined as $\frac{\| \nabla f(x)\|_{\ell^2}}{\sqrt{n}}$ for $x\in\zR^n$, smaller than $10^{-4}$ or a length-step smaller than $10^{-4}$. 
Each optimization process has been performed in a node featuring two Intel Xeon Platinum 8160 CPU with 24 cores, each at 2.10 GHz, and 96 GB of RAM memory.

%Each optimization process has been performed in a single node of the MareNostrum4 super-computer located at the Barcelona Supercomputing Center. Each node contains two Intel Xeon Platinum 8160 CPU with 24 cores, each at 2.10 GHz, and 96 GB of RAM memory.
%We should explain the infinite value
%We should explain valid-to-valid
%We should say we use backtracking globalization

%Because our goal is to illustrate a practical optimization using the detailed derivatives, instead of including mathematical proofs of mesh validity, we detail how we numerically enforce during the optimization the positiveness of the element Jacobians.

%We regularize the objective function to ensure infinite values for inverted configurations.
%In particular, the regularized shape distortion of Equation \eqref{eq:distortionReg} approximates to infinity as the point-wise Jacobian of the element mapping becomes singular.
%Moreover, it takes infinite values for invalid elements.
%Consequently, the objective function of Equation \eqref{eq:minfun} becomes infinite whenever the mesh contains an invalid element.

%To globalize the minimization, we equip Newton's method with a backtracking line-search.
%Whenever the Newton's update provides an inverted configuration at the quadrature points, the objective function becomes infinity and thus, the backtracking line-search shortens by one half the update until a valid configuration is reached.
%Furthermore, as the point-wise Jacobian of the element mapping becomes singular, the
%Furthermore,

%\subsection{Analytic examples}
%How do we compare meshes?
%Background mesh fixed:\\
%%Analytic residual of optimal mesh in terms of background mesh size?, adapted background mesh?:\\
%Test with one square element?\\
%Run example with: analytic metric and interpolated metric\\
%Isoresolution straight-sided background meshes p1, p2, p4, p8?\\
%
%Use standard examples 2D and 3D:\\
%hyperplane\\
%hypersurface: priority\\
%hypersurfaces\\
%
%If the examples are too large consider only hypersurface metric. Better to consider interpolation examples than test ones.\\
%Parameters:\\
%%hmin = 1e-2\\
%%hb = hmin/2\\
%h = 0.0625\\
%p = 1, 2, 4, 8\\
%hb = h, pb = p\\
%hmin = h\\
%
%
%Todo:\\
%evaluate residual with analytic metric to the optimized meshes, print and plot:\\

Following, we first present the target domains to be meshed, and the considered metrics on the domain, Section \ref{sec:examples}.
In Section \ref{sec:meshes} we present the optimization results for a quadrilateral and a hexahedral domain.
In Section \ref{sec:avsd} we compare the proposed discrete based-interpolation procedure with the analytical one from \cite{aparicio2018defining,aparicio2019imr,aparicio2021icosahom}.
Finally, in Sections \ref{sec:iniAnisotropic} and \ref{sec:curvedboundaries}, we show the application of the discrete metric approach to optimize an anisotropic mesh adapted to a given metric generated by the MMG algorithm.
In particular, in Section \ref{sec:curvedboundaries}, we illustrate that our mesh adaption method based in the metric interpolation approach is compatible with curved boundaries.
\subsection{Domains and metrics}\label{sec:examples}
%\textbf{Missatge per Guillermo: vigilar diferencia anisotropic ratio i anisotropic quotient, posar referencia Loseille-Alauzet \cite{loseille2009optimal}}\\
We consider the quadrilateral domain $\Omega=[-0.5,0.5]^2$ for the two-dimensional examples and the hexahedral domain $\Omega=[-0.5,0.5]^3$ for the three-dimensional ones. Each domain is equipped with a metric matching a boundary layer. %, and meshed with isotropic straight-sided simplicial meshes of different polynomial degree but with the same resolution. 
In particular, our target metric $\textbf{M}$ is characterized by a boundary layer metric with a diagonal matrix $\textbf{D}$ and a deformation map $\varphi$ by the following expression
\begin{equation}\label{eq:metricDeformation}
\textbf{M} = \nabla \varphi^{\text{T}}\cdot \textbf{D} \cdot \nabla \varphi.
\end{equation}
In what follows, we first detail the boundary layer metric $\textbf{D}$ and then the deformation map $\varphi$.

%On the one hand, t
The boundary layer aligns with the $x$-axis ($xy$-plane) in the 2D case (3D case).
It determines a constant unit element size along the $x$-direction ($xy$-directions), and a non-constant element size along the $y$-direction ($z$-direction).
This vertical element size grows linearly with the distance to the $x$-axis ($xy$-plane), with a factor $\alpha = 2$, and starts with the minimal value $h_{\min}=0.01$ ($h_{\min}=0.02$).
Thus, the stretching ratio blends from $1:100$ to $1:1$ (from $1:50$ to $1:1$) between $y=-0.5$ and $y=0.5$ (between $z=-0.5$ and $z=0.5$). 
%To match the boundary layer, 
We define the metric for the 2D case as:
%Thus, for the 2D example between $y=-0.5$ and $y=0.5$ the stretching ratio blends from $1:10$ to $1:1$. For the 3D case, between $z=-0.5$ and $z=0.5$ the stretching ratio blends from $1:10$ to $1:1$. To match the boundary layer, we define the metric as:
\begin{equation}\label{eq:test2D}
\textbf{D} := \left(
\begin{array}{cc}
1 & 0\\
0 & 1/h(y)^2
\end{array}
\right)
\end{equation}
where the function $h$ is defined by
\begin{equation*}
h(x):= h_{\min} + \alpha |x|.
\end{equation*}
Similarly, the metric for the 3D case is
\begin{equation}\label{eq:test3D}
\textbf{D} := \left(
\begin{array}{ccc}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1/h(z)^2
\end{array}
\right).
\end{equation}
%The metric of Equation \eqref{eq:test} is the metric induced by the following deformation
%\begin{equation*}
%\zmapline(x,y) = \left( x,H(y)\right),\ \zmapline(x,y,z) = \left( x,y,H(z)\right),
%\end{equation*}
%that is $\textbf{D} = \nabla \zmapline^\mathrm{T} \cdot \nabla \zmapline$ and being $H$ the function given by
%\begin{equation*}
%H(x):= \frac{1}{\gamma}\log\left(1 + \frac{\gamma}{h_{\min}}|x| \right).
%\end{equation*}

%The target metric $\textbf{M}$ is obtained from a boundary layer metric $\textbf{D}$ presented in Equations \eqref{eq:test}.
%On the other hand, 
The deformation map $\varphi$ in Equation \eqref{eq:metricDeformation} aligns the stretching of $\textbf{D}$ according to a given curve in the 2D examples and at a given surface in the 3D examples.
In the 2D case, we define the map $\varphi$ by
%\begin{equation*}
%	\begin{array}{cc}
%	\varphi(x,y) = \left(x,\frac{10y - \cos(2\pi x)}{\sqrt{100 + 4\pi^2}} \right),\\
%	{\varphi}(x,y,z) = \left(x,y,\frac{10z - \cos(2\pi x)\cos(2\pi y)}{\sqrt{100 + 8\pi^2}}\right).
%	\end{array}
%\end{equation*}
\begin{equation*}
\varphi(x,y) = \left(x,\frac{10y - \cos(2\pi x)}{\sqrt{100 + 4\pi^2}} \right),
\end{equation*}
and, in the 3D case by
\begin{equation*}
{\varphi}(x,y,z) = \left(x,y,\frac{10z - \cos(2\pi x)\cos(2\pi y)}{\sqrt{100 + 8\pi^2}}\right).
\end{equation*}

\begin{figure}[t!]
	\centering
	\subfloat{\includegraphics[width=0.3\textwidth]{/new/2_hypersurface_ratio.jpeg}}
	 \\
	 \includegraphics[width=0.35\textwidth]{/new/bar1_100} 
	 \\
	 \begin{tabular}{cc}
%	 	\label{fig:3Dstretching1}
	 	\subfloat{\includegraphics[width=0.35\textwidth]{/new/3_hypersurface_ratio}}
	 	&
	 	\subfloat{\includegraphics[width=0.35\textwidth]{/new/3_hypersurface_ratio_clip_axes}}
	 \end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/new/bar1_50}
%	\caption{Anisotropic quotient values in logarithmic scale of the target metrics.}
	\caption{Anisotropic quotient values in logarithmic scale of the target metrics: (top) 2D case; (bottom left) boundaries of the 3D case; and (bottom right) solid slice of the 3D case.}
	\label{fig:stretching}	
\end{figure}
Figure \ref{fig:stretching} shows the anisotropic quotient \cite{loseille:AnisotropicAdaptiveSimulations} of the metric presented in Equations \eqref{eq:test2D} and \eqref{eq:test3D}.
Specifically, the anisotropic quotient of a metric tensor $\zmetric\in\zR^{d\times d}$ is given by
\begin{equation*}
\text{quo} = \max_{i = 1,...,d} \sqrt{\frac{\det\left(\zmetric\right)}{\lambda_i^d}}
\end{equation*}
where $\lambda_i, \ i = 1,...,d$ are the eigenvalues of $\zmetric$.
The considered metric $\textbf{M}$ attains the highest level of anisotropy, close to the curve described by the points $(x,y)\in\Omega$ such that $\varphi(x,y)=(x,0)$ in 2D, and close the surface described by the points $(x,y,z)\in\Omega$ such that $\varphi(x,y,z)=(x,y,0)$ in 3D. %Note that the metric $\textbf{M}$ is induced by the map $\zmapline\circ {\varphi}$.
\subsection{Distortion minimization: initial isotropic straight-edged meshes}\label{sec:meshes}
In this example, we present the optimization results for initially isotropic meshes on the domain equipped with the metrics presented in Section \ref{sec:examples}. 
We describe first the initial meshes $\zmesh$ together with the background meshes $\zbmesh$ where the metric is interpolated. Next, we present the optimized meshes $\zmesh^*$ and to conclude, we present the results obtained from the optimization process. Herein, both the background and physical meshes are meshes of the same polynomial degree.

\begin{figure}[t!]
	\centering
	\setlength{\tabcolsep}{10pt}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{ccc}
		\subfloat[]{\label{fig:p1_0}
			\includegraphics[width=0.25\textwidth]{/new/1/mesh_0}}
		&
		\subfloat[]{\label{fig:p2_0}
			\includegraphics[width=0.25\textwidth]{/new/2/mesh_0}}
		&
		\subfloat[]{\label{fig:p4_0}
			\includegraphics[width=0.25\textwidth]{/new/4/mesh_0}}
		\\
		\subfloat[]{\label{fig:p1_1}
			\includegraphics[width=0.25\textwidth]{/new/1/mesh_1}}
		&
		\subfloat[]{\label{fig:p2_1}
			\includegraphics[width=0.25\textwidth]{/new/2/mesh_1}}
		&
		\subfloat[]{\label{fig:p4_1}
			\includegraphics[width=0.25\textwidth]{/new/4/mesh_1}}
		\\
		\subfloat[]{\label{fig:p1_1_a}
			\includegraphics[width=0.25\textwidth]{/new/analytic/1/mesh_1}}
		&
		\subfloat[]{\label{fig:p2_1_a}
			\includegraphics[width=0.25\textwidth]{/new/analytic/2/mesh_1}}
		&
		\subfloat[]{\label{fig:p4_1_a}
			\includegraphics[width=0.25\textwidth]{/new/analytic/4/mesh_1}}
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color}
	\caption{Point-wise distortion for triangular meshes of polynomial degree 1, 2, and 4 in columns. Initial straight-sided isotropic meshes, optimized meshes with discrete metric, and optimized meshes with analytic metric in rows.}
	\label{fig:ex}
\end{figure}
\begin{figure}[t!]
	\centering
	\begin{tabular}{ccc}
		\subfloat[]{\label{fig:p1_0_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/1/mesh_0}}
		&
		\subfloat[]{\label{fig:p2_0_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/2/mesh_0}}
		&
		\subfloat[]{\label{fig:p4_0_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/4/mesh_0}}
		\\
		\subfloat[]{\label{fig:p1_1_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/1/mesh_1}}
		&
		\subfloat[]{\label{fig:p2_1_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/2/mesh_1}}
		&
		\subfloat[]{\label{fig:p4_1_3}
			\includegraphics[width=0.3\textwidth]{/new/3D/4/mesh_1}}
		\\
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color} 
	\caption{Clipped tetrahedral meshes of polynomial degree 1, 2, and 4 in columns. Initial straight-sided isotropic meshes and optimized meshes from initial meshes in rows.}
	\label{fig:ex3D}
\end{figure}
\begin{figure}[t!]
	\centering
	\begin{tabular}{ccc}
		\subfloat[]{\label{fig:p1_0_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/1/box_0}}
		&
		\subfloat[]{\label{fig:p2_0_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/2/box_0}}
		&
		\subfloat[]{\label{fig:p4_0_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/4/box_0}}
		\\
		\subfloat[]{\label{fig:p1_1_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/1/box_1}}
		&
		\subfloat[]{\label{fig:p2_1_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/2/box_1}}
		&
		\subfloat[]{\label{fig:p4_1_3b}
			\includegraphics[width=0.3\textwidth]{/new/3D/4/box_1}}
		\\
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color} 
	\caption{Boundary of tetrahedral meshes of polynomial degree 1, 2, and 4 in columns. Initial straight-sided isotropic meshes and optimized meshes from initial meshes in rows.}
	\label{fig:3D}
\end{figure}
The initial meshes $\zmesh$ are of polynomial degree 1, 2, and 4.
The three meshes feature approximately the same number of nodes and they have approximately the same resolution over the domain.
In particular, in 2D the three initial meshes are respectively composed of 312, 321, and 337 nodes and 558, 144, and 38 triangles, see Figures \ref{fig:ex}\subref{fig:p1_0}, \ref{fig:ex}\subref{fig:p2_0}, and \ref{fig:ex}\subref{fig:p4_0}.
%see Figure \ref{fig:ex}.
In 3D, they are respectively composed of $2\,356$, $2\,362$, and $2\,373$ nodes and $11\,699$, $1\,464$, and 184 tetrahedra.
%Figures \ref{fig:ex3D} and \ref{fig:3D} show the clipped 3D meshes and the mesh boundary, respectively.
Figures \ref{fig:ex3D}\subref{fig:p1_0_3}, \ref{fig:ex3D}\subref{fig:p2_0_3}, \ref{fig:ex3D}\subref{fig:p4_0_3}, and \ref{fig:3D}\subref{fig:p1_0_3b}, \ref{fig:3D}\subref{fig:p2_0_3b}, \ref{fig:3D}\subref{fig:p4_0_3b} show the clipped 3D meshes and the mesh boundary, respectively.
The meshes are colored according to the point-wise stretching and alignment quality measure, presented in Equation \eqref{eq:pointwisequality}.
Points in blue color have low quality and points with red color have high quality.
As we observe, the elements lying in the region of highest stretching ratio have less quality than the elements lying in the isotropic region.

%The initial meshes $\zmesh$ are of polynomial degree 1, 2 and 4, with the same resolution and hence with the same number of nodes, 481 nodes in 2D and 1577 nodes in 3D, but a different number of elements, 224, 56, and 14 elements in 2D and 7296, 912, and 114 elements in 3D, respectively.
We equip each mesh with the metric presented in Equation \eqref{eq:metricDeformation}.
We obtain the metric values from the log-Euclidean interpolation method presented in Section \ref{sec:interpolation}.
In particular, we interpolate the metrics from a background mesh $\zbmesh$.
The background meshes are of polynomial degree 1, 2, and 4 according to the polynomial degree of the initial meshes $\zmesh$. 
%The three meshes feature almost the same number of nodes, and thus, they have almost the same resolution.
We impose the three background meshes to feature almost the same number of nodes and to have almost the same resolution over the domain, $h_{\min}/2$.
In particular, the resolution of the 2D background meshes is $h_{\min}/2 = 0.005$.
They are composed of $65\,170$, $64\,329$, and $62\,761$ nodes and $129\,318$, $31\,910$, and $7\,782$ triangles.
The resolution of the 3D background meshes is $h_{\min}/2 = 0.01$.
They are composed of $1\,773\,415$, $1\,798\,531$, and $1\,837\,851$ nodes and $10\,438\,221$, $1\,319\,008$, and $168\,441$ tetrahedra.

%In particular, the metrics have been interpolated from a background mesh $\zbmesh$ of polynomial degree 1, 2 and 4 according to the polynomial degree of the initial meshes $\zmesh$. The background meshes have the same resolution that is, with the same number of nodes, 521 nodes in 2D and 11411 nodes in 3D, but a different number of elements, 960, 240 and 60 elements in 2D and 59456, 7432 and 929 elements in 3D. The meshes from Figures \ref{fig:background} correspond to the 2D background meshes.
To obtain an optimal configuration $\zmesh^*$, we minimize the mesh distortion by relocating the mesh nodes while preserving their connectivity, as detailed in Section \ref{sec:preliminaries}.
The coordinates of the inner nodes, and the coordinates tangent to the boundary, are the design variables.
Thus, the inner nodes are free to move, the vertex nodes are fixed, while the rest of boundary nodes are enforced to slide along the boundary facets of the domain $\Omega$.
%The total amount of degrees of freedom for the 2D and 3D meshes is 222 and 3957, respectively.
%The optimized 2D and 3D meshes are illustrated in Figures \ref{fig:ex} and \ref{fig:ex3D} respectively. 
%In Figure \ref{fig:ex} we illustrate the optimized 2D meshes.
In Figures \ref{fig:ex}\subref{fig:p1_1}, \ref{fig:ex}\subref{fig:p2_1}, \ref{fig:ex}\subref{fig:p4_1} we illustrate the optimized 2D meshes.
%In the 3D case, Figure \ref{fig:ex3D} shows the interior and exterior of the meshes.
In the 3D case, Figure \ref{fig:ex3D}\subref{fig:p1_1_3}, \ref{fig:ex3D}\subref{fig:p2_1_3}, \ref{fig:ex3D}\subref{fig:p4_1_3}, and \ref{fig:3D}\subref{fig:p1_1_3b}, \ref{fig:3D}\subref{fig:p2_1_3b}, \ref{fig:3D}\subref{fig:p4_1_3b} show the clipped 3D meshes and the mesh boundary, respectively.
We align the axes according to the ones of Figure \ref{fig:stretching}.
We observe that %the elements away from the anisotropic region are enlarged vertically whereas
the elements lying in the anisotropic region are compressed to attain the stretching and alignment prescribed by the metric.

\begin{table*}[t!]
	\small
	\caption{Quality statistics for the initial and optimized meshes with interpolated 2D metric.}
	\label{table:interpolative}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c c c c c}
		\hline\noalign{\smallskip}
		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		1 & 0.0299 & 0.1724 & 0.9957 & 0.9551 & 0.6100 & 0.4462 & 0.2769 & 0.1039 \\
		2 & 0.0554 & 0.2878 & 0.9921 & 0.6268 & 0.5918 & 0.4545 & 0.2835 & 0.0638 \\
		4 & 0.0803 & 0.3072 & 0.9835 & 0.5806 & 0.5339 & 0.4439 & 0.2922 & 0.0760 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
\end{table*}
\begin{table*}[t!]
	\small
	\caption{Quality statistics for the initial and optimized meshes with interpolated 3D metric.}
	\label{table:interpolative3D}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c c c c c}
		\hline\noalign{\smallskip}
		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		1 & 0.0175 & 0.1222 & 0.9905 & 0.9334 & 0.5550 & 0.4236 & 0.2660 & 0.1241 \\
		2 & 0.0320 & 0.2987 & 0.9695 & 0.7467 & 0.5194 & 0.4576 & 0.2735 & 0.0691\\
		4 & 0.0409 & 0.3231 & 0.8931 & 0.6737 &	0.4490 & 0.4702 & 0.2711 & 0.0749 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
\end{table*}
Tables \ref{table:interpolative} and \ref{table:interpolative3D} show the quality statistics of both the initial and optimized meshes for the 2D and 3D cases, respectively.
%The quality statistics of both the initial and optimized meshes are shown in Tables  for the 2D and 3D cases, respectively.
In all the optimized meshes the minimum is improved and the standard deviation of the element qualities is reduced when compared with the initial configuration.
In addition, when comparing the curved meshes with the straight-edged ones, we observe that the curved meshes are more flexible.
That is, the curved meshes achieve a higher improvement of the minimum quality and the standard deviation.
This is because the curved elements can approximate the curved stretching of the metric in the point-wise sense and hence, more accurately.

\subsection{Validation: analytic versus discrete}\label{sec:avsd}
To validate the proposed method, we compare 2D curved $r$-adaption results for the high-order metric interpolation with the results corresponding to an analytic metric evaluation.
Considering the initial meshes presented in the previous section, we optimize the distortion measure by evaluating the analytical metric expression, instead of interpolating it in the background mesh.
In Figure \ref{fig:ex} we show the initial and optimized meshes.
They are colored according to the point-wise quality measure of Equation \eqref{eq:pointwisequality} using the analytical metric expression.
%To compare quantitatively both results, we have computed the relative distance between the nodes for each element. 
%For all cases, the relative distance  of the node coordinates of the optimized configurations is around $1\cdot 10^{-2}$.

\begin{table*}[t!]
	\small
	\caption{Quality statistics for the initial and optimized meshes with analytic 2D metric.}
	\label{table:analytic}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c c c c c}
		\hline\noalign{\smallskip}
		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		1 & 0.0279 & 0.1684 & 0.9957 & 0.9581 & 0.6100 & 0.4484 & 0.2770 & 0.1088 \\
		2 & 0.0563 & 0.3358 & 0.9921 & 0.6432 & 0.5919 & 0.4569 & 0.2835 & 0.0623 \\
		4 & 0.0799 & 0.3096 & 0.9835 & 0.6318 & 0.5339 & 0.4473 & 0.2923 & 0.0634 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
\end{table*}
To compare quantitatively both results, we compute the maximum distance of the node coordinates of the optimized configurations.
The maximum distances are around $2.2\cdot10^{-2}$, $7.6\cdot10^{-2}$, and $8.2\cdot10^{-2}$ for the linear, quadratic, and quartic cases, obtaining comparable nodal configurations, as it can be observed when comparing Figures \ref{fig:ex}\subref{fig:p1_1}, \ref{fig:ex}\subref{fig:p2_1}, and \ref{fig:ex}\subref{fig:p4_1} with Figures \ref{fig:ex}\subref{fig:p1_1_a}, \ref{fig:ex}\subref{fig:p2_1_a}, and \ref{fig:ex}\subref{fig:p4_1_a}, respectively.
%The relative distance is around $2.0\cdot10^{-2}$, $3.2\cdot10^{-2}$, and $6.3\cdot10^{-2}$ for all the tested cases, obtaining comparable nodal configurations, as it can be observed when comparing Figures \ref{fig:ex} and \ref{fig:exa}.
%In addition, the quality statistics of both the initial and optimized meshes are shown in Table \ref{table:analytic}. 
%We can observe that the difference between the quality statistics of the obtained configurations is below $10^{-2}$. 
%Analyzing the quality statistics of the interpolated, Table \ref{table:interpolative}, and analytical, Table \ref{table:analytic}, metric evaluation,  the difference for all the statistics between the optimized configurations is below $10^{-2}$.
In Table \ref{table:analytic}, we present the quality statistics of the initial and optimized meshes using the analytical metric evaluation.
To compare the quality improvement of both approaches, we compute the difference between the mean of the analyzed quality statistics, obtaining a value below $10^{-2}$.
%Thus, both the obtained configuration are close, and alidating the quality improvement obtained using the discrete metric framework.
%Thus, the obtained configurations are close regarding the obtained nodal configuraitons, but also the quality of the obtained configuraitons is similar
Thus, the quality improvement driven by the optimization using the proposed metric interpolation procedure is analogous to the one given by the analytical metric, obtaining in all cases high-quality configurations with a minimum quality over 0.1.

%p2,pb2,hb0.1
%p2,pb4,hb0.1 1.9 1e-2
%mmg p2,pb4,hb0.1 1.9 1e-2
%p2,pb8,hb0.1

%quotient
%p1 4.92 1e-2
%p2 3.22 1e-2
%p4 0.920 1e-2

%Elemental difference with analytic $\frac{\|\zp_i - \zp_a\|}{\sqrt{n}} = 7.18\cdot 10^{-3},\ 3.15\cdot 10^{-3},\ 1.20\cdot 10^{-2}$.
%%header: \textbf{comparison with optimization with analytic metric?}\\

%We have generated an isotropic linear triangular mesh of input size $0.0625$ with MATLAB \cite{MATLAB:2017}. We couple such mesh with the target metric evaluated at the mesh vertices and we use the MMG algorithm presented in \citep{dobrzynski2012mmg3d} to obtain an anisotropic mesh.

\subsection{Distortion minimization: initial anisotropic straight-edged meshes}
\label{sec:iniAnisotropic}

The results presented in Section \ref{sec:meshes} show the application of the metric interpolation procedure to optimize isotropic meshes in a domain equipped with a metric.
However, in practice, anisotropic meshes are generated combining topological mesh operations that modify the mesh connectivity and mesh $r$-adaption procedures \cite{alauzet:AnisotropicMeshAdaptation}.
To illustrate a practical example, we consider an initial anisotropic straight-sided mesh.
%by the MMG algorithm presented in \cite{dobrzynski2012mmg3d}.
Then, we apply the anisotropic $r$-adaption method presented in this work.

%\textbf{Remark: not comparing with MMG}
Although we generate meshes adapted to a target metric with MMG \cite{dobrzynski2012mmg3d}, our goal is not to compare the distortion minimization with the MMG package. Actually, we acknowledge MMG because it generates an initial straight-edged mesh that matches the stretching and alignment of the target metric.
%We generate each anisotropic initial mesh with the MMG algorithm presented in \cite{dobrzynski2012mmg3d}.
%It is not our purpose to compare our $r$-adaption method with the MMG algorithm.
%Instead, our objective is to start from an improved initial approximation of the target metric.
%Finally, we aim to illustrate our method by comparing between initial and optimized meshes.
%\\ \\ \\

\begin{figure}[t!]
	\centering
	\setlength{\tabcolsep}{10pt}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{ccc}
		\subfloat[]{\label{fig:p1_0mmg}
			\includegraphics[width=0.25\textwidth]{/2_1_0_mmg}}
		&
		\subfloat[]{\label{fig:p2_0mmg}
			\includegraphics[width=0.25\textwidth]{/2_2_0_mmg}}
		&
		\subfloat[]{\label{fig:p4_0mmg}
			\includegraphics[width=0.25\textwidth]{/2_4_0_mmg}}
		\\
		\subfloat[]{\label{fig:p1_1mmg}
			\includegraphics[width=0.25\textwidth]{/2_1_1_mmg}}
		&
		\subfloat[]{\label{fig:p2_1mmg}
			\includegraphics[width=0.25\textwidth]{/2_2_1_mmg}}
		&
		\subfloat[]{\label{fig:p4_1mmg}
			\includegraphics[width=0.25\textwidth]{/2_4_1_mmg}}
		\\
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color} 
	\caption{Point-wise distortion for triangular meshes of polynomial degree 1, 2, and 4 in columns. Initial straight-sided anisotropic meshes and optimized meshes from initial meshes in rows.}
	\label{fig:exmmg}
\end{figure}
First, we consider the target metric presented in Equation \eqref{eq:metricDeformation} with $h_{\min} = 0.01$.
Second, we generate a linear isotropic triangular background mesh $\hat{\zmesh}$ of input size $h_{\min}/2 = 0.005$ with MATLAB.
We normalize the target metric according to the size of the physical meshes $\zmesh$ namely, $0.0625,\ 0.125, \text{ and } 0.25$ for the linear, quadratic, and quartic case, respectively.
These sizes are chosen in order to obtain a comparable mesh resolution according to the mesh polynomial degree.
Then, we couple each background mesh with the target metric evaluated at the background mesh vertices.
We apply the MMG algorithm to obtain an initial straight-sided anisotropic physical mesh $\zmesh$ of polynomial degree 1, 2, and 4,
see Figures \ref{fig:exmmg}\subref{fig:p1_0mmg}, \ref{fig:exmmg}\subref{fig:p2_0mmg}, and \ref{fig:exmmg}\subref{fig:p4_0mmg}.
% see Figure \ref{fig:exmmg}.
In particular, the physical meshes are composed by $1\,161$ nodes and $2\,137$ triangles, $1\,333$ nodes and 624 triangles and, $1\,525$ nodes and 180 triangles, respectively.

The physical meshes $\zmesh$ are then optimized using the metric interpolation approach presented in this work.
%In Figure \ref{fig:exmmg}, we illustrate the optimized meshes $\zmesh^*$.
In Figures \ref{fig:exmmg}\subref{fig:p1_1mmg}, \ref{fig:exmmg}\subref{fig:p2_1mmg}, and \ref{fig:exmmg}\subref{fig:p4_1mmg}, we illustrate the optimized meshes $\zmesh^*$.
We observe that the elements lying in the anisotropic region are compressed to attain the stretching and alignment prescribed by the metric.

\begin{table*}[t!]
	\small
	\caption{Quality statistics for the initial MMG and optimized meshes with interpolated 2D metric.}
	\label{table:interpolativemmg}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c c c c c}
		\hline\noalign{\smallskip}
		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		1 & 0.0365 & 0.1794 & 0.9988 & 0.9989 & 0.7806 & 0.7961 & 0.2273 & 0.2040 \\
		2 & 0.0624 & 0.6300 & 0.9982 & 0.9913 & 0.6966 & 0.8692 & 0.2558 & 0.0788 \\
		4 & 0.0424 & 0.6063 & 0.9774 & 0.9965 & 0.5677 & 0.9137 & 0.2681 & 0.0886 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
\end{table*}
In Table \ref{table:interpolativemmg}, we show the quality statistics of both the initial and optimized meshes.
In all the optimized meshes the minimum is improved and the standard deviation of the element qualities is reduced when compared with the initial configuration.
We conclude that, with the same metric data and hence, the same inputs, the $r$-adaption mesh post-processing improves the quality of the meshes generated with the MMG algorithm.
In addition, for the straight-edged case, we have presented a global method to improve the stretching and alignment prescribed by the metric after applying an $h$-adaption approach.

For a fixed metric, usually the better the initial straight-edged mesh is, the better the optimized mesh is.
For instance, for different degrees, the mean quality statistics for the initial anisotropic meshes, Table \ref{table:interpolativemmg}, are better than for the isotropic meshes, Table \ref{table:interpolative}.
The anisotropic meshes have this advantage because their topology and geometry are adapted to match the corresponding scaling of the target metric.
This prior metric matching facilitates that the curved optimization reaches a better final quality.

As in the examples presented in Section \ref{sec:meshes}, when comparing the curved meshes with the straight-edged ones, we observe that the curved meshes are more flexible.
That is, the curved meshes achieve a higher improvement of the minimum quality and the standard deviation.
This is because the curved elements can approximate the curved stretching of the metric in the point-wise sense and hence, more accurately.
%dofs: 2135, 2494, 2878.

%\textbf{Initial isotropic vs initial anisotropic}

%For a fixed metric, the quality of an optimized mesh is usually greater for an initial straight-edged mesh that better matches the target metric.
%For instance, for different degrees, the mean quality statistics for the initial anisotropic meshes, Table 4, are better than the ones for the isotropic meshes, Table 1.
%This advantage of the anisotropic meshes is because their topology and geometry are adapted to match the corresponding scaling of the target metric.
%This prior matching facilitates that the curved optimization reaches a better final quality.

%We compare the initial isotropic meshes with the initial anisotropic ones, see the corresponding Tables \ref{table:interpolative} and \ref{table:interpolativemmg}.
%On the one hand, we observe that the quality statistics are usually improved for the initial anisotropic meshes.
%This is because, the initial anisotropic meshes are adapted to approximate the metric.
%On the other hand, we observe that the minimum, maximum, and mean qualities are improved for the optimized meshes with initial anisotropic guess.
%This is because, the initial adapted mesh features elements localized and topologically modified according to the stretching and alignment of the metric.
%This facilitates curving and stretching the elements for the optimized mesh.

%In particular, we observe that the mean and the standard deviation are improved for the initial
%	 when comparing the curved meshes with the straight-edged ones, we observe that the curved meshes are more flexible.
%initial: mean, and standard deviation improved for aniso than for iso.
%optimized: minimum, maximum, and mean are improved more for aniso than for iso.

%\begin{table*}[t!]
%	\small
%	\caption{Quality statistics for the initial and optimized meshes with interpolated 2D metric.}
%	\label{table:interpolative}
%	\centering
%	\par\medskip
%	\begin{tabular}{ c c c c c c c c c}
%		\hline\noalign{\smallskip}
%		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
%		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%		1 & 0.0299 & 0.1724 & 0.9957 & 0.9551 & 0.6100 & 0.4462 & 0.2769 & 0.1039 \\
%		1 & 0.0365 & 0.1794 & 0.9988 & 0.9989 & 0.7806 & 0.7961 & 0.2273 & 0.2040 \\
%		2 & 0.0554 & 0.2878 & 0.9921 & 0.6268 & 0.5918 & 0.4545 & 0.2835 & 0.0638 \\
%		2 & 0.0624 & 0.6300 & 0.9982 & 0.9913 & 0.6966 & 0.8692 & 0.2558 & 0.0788 \\
%		4 & 0.0803 & 0.3072 & 0.9835 & 0.5806 & 0.5339 & 0.4439 & 0.2922 & 0.0760 \\
%		4 & 0.0424 & 0.6063 & 0.9774 & 0.9965 & 0.5677 & 0.9137 & 0.2681 & 0.0886 \\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%	\end{tabular}
%\end{table*}

\subsection{Distortion minimization: curved boundaries}\label{sec:curvedboundaries}
We following illustrate that our approach is compatible with curved boundaries.
We consider a 2D example, in Section \ref{sec:curvedboundaries2D}, and a 3D example, in Section \ref{sec:curvedboundaries3D}.
To this end, we first construct the geometric model with FreeCAD \cite{riegel2016freecad}.
Next, we consider their implicit representation, see Section \ref{sec:implicit}.
Then, we generate the background and initial physical meshes coupled with a discrete metric, see Section \ref{sec:interpolation}.
Finally, we apply our $r$-adaption method, presented in Section \ref{sec:preliminaries}, by taking into account both the discrete metric and the implicit representation of the geometry.
This enables an optimized physical mesh that approximates the stretching and alignment of the metric while preserving the curvature of the boundary.

\begin{figure}[t!]
	\centering
	\begin{tabular}{cc}
		\subfloat[]{\label{fig:circleparam}
			\includegraphics[width=0.3\textwidth]{/new/2D/paramcircle_box}}
		&
		\subfloat[]{\label{fig:circle}
			\includegraphics[width=0.3\textwidth]{/new/2D/circle_boxlin}}
		\\
	\end{tabular}
	\caption{Parametric CAD and global implicit representation for the 2D model of a square with a circular hole.}
	\label{fig:2Dmodels}
\end{figure}
\begin{figure}[p!]
	\centering
	\vskip -50pt
	\setlength{\tabcolsep}{20pt}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{cc}
		\subfloat[]{\label{fig:p2_0mmg2}
			\includegraphics[width=0.35\textwidth]{/new/2D/mesh_0}}
		&
		\subfloat[]{\label{fig:p2_1mmg2}
			\includegraphics[width=0.35\textwidth]{/new/2D/mesh_1}}
		\\
		\subfloat[]{\label{fig:p2_0mmg2zoom}
			\includegraphics[width=0.35\textwidth]{/new/2D/zoom_0}}
		&
		\subfloat[]{\label{fig:p2_1mmg2zoom}
			\includegraphics[width=0.35\textwidth]{/new/2D/zoom_1}}
		\\
		\subfloat[]{\label{fig:p4_0mmg2}
			\includegraphics[width=0.35\textwidth]{/new/2D/p4/mesh_0}}
		&
		\subfloat[]{\label{fig:p4_1mmg2}
			\includegraphics[width=0.35\textwidth]{/new/2D/p4/mesh_1}}
		\\
		\subfloat[]{\label{fig:p4_0mmg2zoom}
			\includegraphics[width=0.35\textwidth]{/new/2D/p4/zoom_0}}
		&
		\subfloat[]{\label{fig:p4_1mmg2zoom}
			\includegraphics[width=0.35\textwidth]{/new/2D/p4/zoom_1}}
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color} 
	\caption{Point-wise distortion for triangular meshes of polynomial degree 2 in first and second (zoom) rows, and 4 in third and fourth (zoom) rows. Initial straight-sided anisotropic mesh and optimized mesh in columns.}
	\label{fig:exmmg2}
\end{figure}
To accommodate the curved boundaries we include, to the presented functional, a boundary term that takes into account the mesh deviation to the boundaries of the domain, see Section \ref{sec:penalty}.
Specifically, we set the penalty parameter $\lambda := 10^4$ in all examples, see Equation \eqref{eq:curving}.
In addition, to approximate the metric stretching, we optimize the mesh using the metric interpolation approach presented in this work.
Finally, when optimizing the mesh functional all mesh nodes coordinates are free that is, each mesh node moves in $\zR^2$, in the 2D case, and in $\zR^3$, in the 3D case.
\subsubsection{2D curved model: square with a circular hole}\label{sec:curvedboundaries2D}
For the 2D model $\zmodel_1$, we consider a square with a circular hole.
Specifically, the domain is denoted by $\Omega_1 = K_1 \backslash C_1$, where $K_1 = [-0.5,0.5]^2$ is a square, and where $C_1$ is the circle with radius equal to $0.18$ and centered at the origin, see Figure \ref{fig:2Dmodels}\subref{fig:circleparam}.
The domain $\Omega_1$ has two boundaries, the one of the square $K_1$ and the one of the circle $C_1$.
We illustrate in Figure \ref{fig:2Dmodels}\subref{fig:circle} a global implicit representation of the boundary $\zmodel_1:=\partial\Omega_1$, using the method presented in Section \ref{sec:cadimplicit}.
Although the inner boundary is smooth, the outer boundary contains sharp features such as corners.

We equip the domain $\Omega_1$ with the target metric presented in Equation \eqref{eq:metricDeformation} with $h_{\min} = 0.01$.
Then, we generate with MATLAB two isotropic triangular background meshes $\hat{\zmesh}$ of polynomial degree 2 and 4.
They have an input resolution $h_{\min}/2 = 0.005$ over $\Omega_1$ that is, of input size $0.01$ and $0.02$, respectively.
%background mesh, nodes: 40935, elements: 20211
We normalize the target metric according to size $h = 0.25$ in the quadratic case, and according to size $h = 0.5$ in the quartic case.
Then, we couple each background mesh with the target metric evaluated at the background mesh vertices.
From each background mesh $\hat{\zmesh}$, we obtain an initial straight-sided anisotropic physical mesh $\zmesh$ by applying the MMG algorithm, see Figures \ref{fig:exmmg2}\subref{fig:p2_0mmg2}, and \ref{fig:exmmg2}\subref{fig:p4_0mmg2}.
The quadratic and quartic physical meshes are respectively composed by 518 nodes and 220 triangles, and 944 nodes and 106 triangles.
Note that, since the MMG algorithm requires a linear background mesh, we subdivide the background meshes in order to preserve their resolution.
Specifically, our linear background meshes for the MMG algorithm are obtained by subdividing the quadratic background mesh once, and the quartic background mesh twice.

\begin{table*}[t!]
	\small
	\caption{Quality statistics for the initial MMG and optimized mesh with interpolated 2D metric at the square with a circular hole.}
	\label{table:interpolativemmg2}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c c c c c}
		\hline\noalign{\smallskip}
		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		2 & 0.0823 & 0.4140 & 0.9914 & 0.9943 & 0.5764 & 0.8224 & 0.2508 & 0.1281 \\
		4 & 0.0590 & 0.4045 & 0.9646 & 0.9850 & 0.4177 & 0.7321 & 0.2292 & 0.1461 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
\end{table*}
In Figures \ref{fig:exmmg2}\subref{fig:p2_1mmg2}, and \ref{fig:exmmg2}\subref{fig:p4_1mmg2}, we illustrate the optimized meshes $\zmesh^*$.
We observe that the elements lying in the anisotropic region are compressed to attain the stretching and alignment prescribed by the metric.
Note that the boundary elements are curved to match both the metric and the curved domain boundaries.
In Table \ref{table:interpolativemmg2}, we show the quality statistics of both the initial and optimized mesh.
In the optimized mesh the minimum, the mean, and the standard deviation of the element qualities are improved when compared with the initial configuration.
%In addition, in Table \ref{table:distance2D}, we show the point-wise distance statistics of the circular entity for both the initial and optimized mesh.
%In the optimized mesh all quantities of the point-wise distances are improved when compared with the initial configuration.
%\begin{table*}[t!]
%	\small
%	\caption{Point-wise distance statistics of the circular entity for the initial MMG and optimized mesh with interpolated 2D metric at the square holed by a circle.}
%	\label{table:distance2D}
%	\centering
%	\par\medskip
%	\begin{tabular}{ c c c c c c c c c}
%		\hline\noalign{\smallskip}
%		Mesh & \multicolumn{2}{c}{Minimum}&\multicolumn{2}{c}{Maximum}&\multicolumn{2}{c}{Mean}&\multicolumn{2}{c}{Std dev.}\\
%		deg. & Initial & Final & Initial & Final & Initial & Final & Initial & Final\\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%		2 & 0.0050 & 9.18e-5 & 0.0447 & 0.0051 & 0.0163 & 0.0017 & 0.0010 & 0.0008\\
%		4 & 0.0056 & 0.0001 & 0.0597 & 0.0027 & 0.0217 & 0.0013 & 0.0105 & 0.0004 \\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%	\end{tabular}
%%(0.005027527843356271, 0.04469362163923852, 0.01626352811342356, 0.009964862518540396)
%%(9.176274783179534e-5, 0.005062475946453733, 0.0016833902290683848, 0.0008164156729899332)
%%(0.005583258905155967, 0.05968947786951883, 0.021679510183896442, 0.010479371067808942)
%%(0.0001312636377578081, 0.002691433835868349, 0.0013337746833034809, 0.00038516997141883246)
%\end{table*}

%Paragraf 2D mesh: stretching aligned with geometry tangent
%higher flexibility to match the boundary -> more elements to represent sharp stretching transition.
%From the 2D examples, we observe that the higher flexibility to match the boundary enabled by curved elements allow an improved resolution of the regions.
From the results, we observe that, when compared with straight-sided elements, curved elements approximate more faithfully the metric while preserving the curved features of the boundary.
In this case, the stretching direction is almost aligned according to the tangent of the geometry.
When considering straight-edged elements, in Figures \ref{fig:exmmg2}\subref{fig:p2_0mmg2zoom} and \ref{fig:exmmg2}\subref{fig:p4_0mmg2zoom}, accumulating more degrees of freedom in the stretched regions may worsen the boundary representation at non-stretched regions.
In contrast, when considering curved elements, in Figures \ref{fig:exmmg2}\subref{fig:p2_1mmg2zoom} and \ref{fig:exmmg2}\subref{fig:p4_1mmg2zoom}, we observe that a single curved element represents the boundary more faithfully than several straight-sided elements.
This flexibility of curved elements allows the degrees of freedom to slide and accumulate, from non-stretched regions to the stretched regions, featuring high-quality elements.
For that reason, we observe how the elements are stretched, aligned, and curved according to the stretching and alignment of the metric.
Hence, curved elements allow an improved representation of the metric while preserving the curved features of the boundary.

We use a non-optimized prototype to demonstrate that the detailed derivatives enable Newton's method.
Nevertheless, to illustrate the computational cost, we next report the wall-clock time and the most expensive parts when matching a target metric and curved boundary.
The report is an initial reference for future improvements because the prototype is unoptimized.

For this two-dimensional example, the total wall-clock time is $2\ 194$ seconds for degree two and $17\ 911$ seconds for degree four. The wall-clock time is higher for the second case because of two main reasons: the number of mesh points and the polynomial degree.

First, the mesh features more points for degree four (944 points) than for degree two (518 points). Note that both cases are initialized with a straight-edged mesh adapted to the corresponding scaling of the metric. This scaling accounts for the difference of points between an element of degree two and an element of degree four. Unfortunately, the resulting adapted straight-edged mesh features 220 and 106 elements for degrees two and four, respectively. Thus, the initial meshes do not feature a comparable number of points, a difference that computationally benefits the example of degree two.

Second, the higher the order, the higher the computational cost is. For higher orders, the Hessians of the objective function densify, and the initial approximations worsen. Regarding density, note that the elemental contributions to the Hessian have around six times more non-zero entries for degree four than for degree two. In this example, computing each elemental contribution to the Hessian needs 0.15 seconds for degree four and 0.03 seconds for degree two. Regarding initial approximations, they are worse because the initial straight-edged mesh is of degree one, and thus, the difference of degrees is higher for degree four. In this example, the non-linear problem needs 693 iterations for degree four and 229 iterations for degree two.

Finally, for both degrees, the most expensive part is to compute the elemental contributions to the gradient and the Hessian, a computation that needs the derivatives of the metric interpolation and the geometry implicitation. For the metric interpolation, the percentage of the total wall-clock time computing the derivatives is 45% for degree two and 50% for degree four. For the geometry implicitation, the percentage of time for the derivatives is 10% for degree two and 5% for degree four.

\subsubsection{3D curved model: a cube trimmed by a cylinder}\label{sec:curvedboundaries3D}
\begin{figure}[t!]
	\centering
	\setlength{\tabcolsep}{-40pt}
	\begin{tabular}{cc}
		\subfloat[]{\label{fig:cylinderparam}
			\includegraphics[width=0.6\textwidth]{/new/3D/curving/cylinder/paramcylinder_noaxes}}
		&
		\subfloat[]{\label{fig:cylinderimplicit}
			\includegraphics[width=0.6\textwidth]{/new/3D/curving/cylinder/cylinder_nobar}}
		\\
	\end{tabular}
	\caption{Parametric CAD and sliced global implicit representation for the 3D model of a cube trimmed by a cylinder.}
	\label{fig:3Dmodels}
\end{figure}
For the 3D model $\zmodel_2$, we consider a cube trimmed by a cylinder.
Specifically, our domain is denoted by $\Omega_2 = K_2 \backslash C_2$ where $K_2 = [-0.5,0]^2\times[-0.25,0.25]$ is a box, and where $C_2$ is the cylinder with radius equal to $0.25$, height equal to $1/2$, and centered at the origin, see Figure \ref{fig:3Dmodels}\subref{fig:cylinderparam}.
The boundary of the domain $\Omega_2$ is composed of seven curves and seven surfaces.
Six surfaces correspond to the cube $K_2$ and one correspond to the cylinder $C_2$.
Six curves correspond to the boundary curves of each surface boundary of the cube, and one curve correspond to the intersection of the surface boundary of the cylinder $C_2$ with the cube.
%Using the method presented in Section \ref{sec:implicit}, we compute an implicit representation of the boundary $\zmodel_2:=\partial\Omega_2$, see Figure \ref{fig:models}\subref{fig:cylinderimplicit}.
We illustrate in Figure \ref{fig:3Dmodels}\subref{fig:cylinderimplicit} a global implicit representation of the boundary $\zmodel_2:=\partial\Omega_2$, using the method presented in Section \ref{sec:cadimplicit}.
Although the inner boundary is smooth, the outer boundary contains sharp features such as corners and sharp edges.

\begin{figure}[p!]
	\centering
	\vskip-70pt
	\setlength{\tabcolsep}{-30pt}
	\begin{tabular}{ c c c }
		\subfloat[]{\label{fig:cylinder0_0}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh_0}}
		&
		\subfloat[]{\label{fig:cylinder0_1}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh_1}}
		\\
		\subfloat[]{\label{fig:cylinder1_0}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh1_0}}
		&
		\subfloat[]{\label{fig:cylinder1_1}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh1_1}}
		\\
		\subfloat[]{\label{fig:cylinder2_0}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh3_0}}
		&
		\subfloat[]{\label{fig:cylinder2_1}
			\includegraphics[width=0.7\textwidth]{/new/3D/curving/cylinder/mesh3_1}}
		\\
	\end{tabular}
	\\
	\includegraphics[width=0.35\textwidth]{/qualBarParaview_color} 
	\caption{Point-wise distortion for quadratic tetrahedral meshes. Initial straight-sided anisotropic mesh and optimized mesh in columns.}
	\label{fig:cylinder}
\end{figure}
We equip the domain $\Omega_2$ with the target metric presented in Equation \eqref{eq:metricDeformation} with $h_{\min} = 0.02$.
Then, we generate with MATLAB a quadratic isotropic tetrahedral background mesh $\hat{\zmesh}$ of input resolution $h_{\min} = 0.02$ over $\Omega_2$ that is, of input size $0.04$.
We normalize the target metric according to size $h = 0.5$.
Then, we couple each background mesh with the target metric evaluated at the background mesh vertices.
From this background mesh $\hat{\zmesh}$, we obtain an initial quadratic straight-sided anisotropic physical mesh $\zmesh$ by applying the MMG algorithm, see Figures \ref{fig:cylinder}\subref{fig:cylinder0_0}, \ref{fig:cylinder}\subref{fig:cylinder1_0}, and \ref{fig:cylinder}\subref{fig:cylinder2_0}.
The physical mesh is composed by $1\,261$ nodes and 695 tetrahedra.
Note that, since the MMG algorithm requires a linear background mesh, we subdivide once our quadratic background mesh in order to preserve its resolution.

\begin{table*}[t!]
	\caption{Quality statistics for the initial MMG and optimized mesh with interpolated 3D metric at the cube trimmed by a cylinder.}
	\label{table:cylinder}
	\centering
	\par\medskip
	\begin{tabular}{ c c c c c }
		\hline\noalign{\smallskip}
		Mesh&Minimum&Maximum&Mean&Standard deviation\\
		\noalign{\smallskip}\hline\noalign{\smallskip}
		Initial & 0.0506 & 0.9489 & 0.3519 & 0.1874 \\
		Optimized & 0.3315 & 0.9198 & 0.6661 & 0.1144 \\
		\noalign{\smallskip}\hline\noalign{\smallskip}
	\end{tabular}
	%(0.0506, 0.9489, 0.3519, 0.1874)
	%(0.3315, 0.9198, 0.6661, 0.1144)
\end{table*}
In Figures \ref{fig:cylinder}\subref{fig:cylinder0_1}, \ref{fig:cylinder}\subref{fig:cylinder1_1}, and \ref{fig:cylinder}\subref{fig:cylinder2_1}, we illustrate the optimized meshes $\zmesh^*$.
We observe that the elements lying in the anisotropic region are compressed to attain the stretching and alignment prescribed by the metric.
Note that the boundary elements are curved to match both the metric and the curved domain boundaries.
In Table \ref{table:cylinder}, we show the quality statistics of both the initial and optimized mesh.
In the optimized mesh the minimum, the mean, and the standard deviation of the element qualities are improved when compared with the initial configuration.
%In addition, in Table \ref{table:cylinderdist}, we show the point-wise distance statistics of the cylindrical entity for both the initial and optimized mesh.
%In the optimized mesh the maximum, the mean, and the standard deviation of the point-wise distances are improved when compared with the initial configuration.
%\begin{table*}[t!]
%	\caption{Point-wise distance statistics of the cylindrical entity for the initial MMG and optimized mesh with interpolated 3D metric at the cube trimmed by a cylinder.}
%	\label{table:cylinderdist}
%	\centering
%	\par\medskip
%	\begin{tabular}{ c c c c c }
%		\hline\noalign{\smallskip}
%		Mesh&Minimum&Maximum&Mean&Standard deviation\\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%		Initial   & 0.0000 & 0.0299 & 0.0299 & 0.0113 \\
%		Optimized & 1.76e-5 & 0.0112 & 0.0034 & 0.0020 \\
%		\noalign{\smallskip}\hline\noalign{\smallskip}
%	\end{tabular}
%%(0.0, 0.060254437693418095, 0.029911817966916176, 0.01134547750724729)
%%(1.7566376211839927e-5, 0.011170988391552915, 0.0034042785245570503, 0.0019920138539057794)
%\end{table*}

%Paragraf 3D mesh: stretching orthogonal to tangent and normal
From the results, we observe that, when compared with straight-sided elements, curved elements approximate more faithfully the metric while preserving the curved features of the boundary.
%In Figure \ref{fig:cylinder},
In this case, the stretching direction and the curvature of the geometry are independent.
%the stretching direction is almost orthogonal to the tangent and normal of the geometry.
Accordingly, when considering straight-edged elements, in Figure \ref{fig:cylinder}\subref{fig:cylinder2_0}, more stretched elements may enable a lower resolution of the boundary.
%Moreover, increasing the resolution of the boundary worsens the stretching features of the metric.
%This is because, the principal directions required for approximating the metric stretching and the boundary curvature are independent.
That is, the achieved resolution of the boundary limits the achieved stretching, and vice-versa.
%an equal amount of degrees of freedom at both the stretching and boundary curvature directions, considered to compensate the lower resolution of the boundary, enable isotropic elements at the boundary, worsening the approximation of the metric stretching.
In contrast, when considering curved elements, in Figure \ref{fig:cylinder}\subref{fig:cylinder2_1}, we observe that more degrees of freedom can be accumulated at the stretched directions while preserving the curved features of the boundary.
%the elements are stretched according to the metric while being curved to match curved features of the boundary.
As before, we conclude that curved elements allow an improved representation of the metric while preserving the curved features of the boundary.

\section{Concluding remarks}
\label{sec:conclusions}

In conclusion, we have obtained unprecedented second-order optimization results in curved $r$-adaption to a metric and geometry targets. We have represented the discrete metric in a curved background mesh as a high-order log-Euclidean metric interpolation. For this metric interpolation, we have detailed the first and second derivatives in terms of the physical coordinates. Moreover, we have  considered the geometry model as an implicit representation of the NURBS entities. For this implicit representation, we have detailed the first and second derivatives.

The derivatives of the metric interpolation and the implicit representation have allowed minimizing the objective function with Newton's method, an objective function that accounts for the metric and geometry deviations. The discrete metric results compare well with the analytic metric results. In all the results, the method exploits the non-constant Jacobian of curved high-order elements. This mechanism allows the technique to simultaneously match curved features of the metric and the geometry.

To meet our goal, we have enabled Newton's method for curved $r$-adaption.
Nevertheless, we have planned new directions and improvements for the near future.
First, to demonstrate the applications of our method and the advantages of adapted curved meshes, we have planned to $r$-adapt the curved meshes to the steady state of inviscid flows.
At this point, we cannot obtain the required discrete metrics because we need to implement existing goal-oriented error estimators for high-order methods \cite{yano2012,COULAUD2016353}.
Second, we have demonstrated a key ingredient for curved $r$-adaption.
Nevertheless, combining curved $r$-adaption with curved $h$-adaption might be more efficient.
To illustrate this combination, we have used an external straight-edged adaptive mesher.
However, to properly match the requirements of high-order methods in $h$-adaption, it is mandatory to use local cavity operators for curved meshes.
Regarding these curved operators, we have planned to combine existing approaches \cite{zhang2018curvilinear,zahr2020implicit,rochery2021p2,FEUILLET2020102846} with our approaches.
Specifically, our distortion minimization for high-order metric and curved boundaries can also optimize a local cavity.
To this end, we will match the cavity interior to the target high-order metric while the old cavity boundaries represent the target geometry.

In perspective, this capability to match metric and geometry features might be an attractive ingredient for curved high-order adaption. Specifically, in goal-oriented or indicator-based adaptive processes, one would have a target high-order metric field in a current mesh approximating a target geometry. The combined approach would drive the curved $r$-adaption to globally (locally) relocate the current curved mesh (re-meshed cavity) according to the curved features of the solution and the geometry (cavity) boundary.
%--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


\section{Acknowledgements}
This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme under grant agreement No 715546. This work has also received funding from the Generalitat de Catalunya under grant number 2017 SGR 1731. The work of X. Roca has been partially supported by the Spanish Ministerio de Econom\'ia y Competitividad under the personal grant agreement RYC-2015-01633.


%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}
\appendix
\section{Derivatives of the eigenvalue decomposition}\label{sec:appendix}
%%header: \textbf{Eigenvalue derivatives}

In this Appendix, we detail the first and second-order spatial derivatives of the eigenvalue decomposition (eigenvalues and eigenvectors), first presented in \cite{andrew1993derivatives} and rewritten herein using our notation.

Let us consider, for $\ell = 1,...,d$, the eigenvalue equation for the eigenvector $\zu_{\ell}$ with eigenvalue $\lambda_\ell$
\begin{equation*}
\textbf{L}_{\ell}\zu_{\ell} := \left(\textbf{L} - \lambda_{\ell}\textbf{I}\right)\zu_{\ell} = 0,
\end{equation*}
where $\textbf{L}$ is a symmetric matrix and $\textbf{I}$ is the identity matrix.
%$\textbf{L}_{\ell} := \textbf{L} - \lambda_{\ell}\textbf{I}, \ \lambda_\ell := \zvap_{\ell \ell}$
Then, by taking its first-order and second-order derivatives we respectively obtain
\begin{equation}\label{eq:eigendiff1}
0 = \partial_{j}\left(\textbf{L}_{\ell}\zu_{\ell}\right) = \left(\partial_{j}\textbf{L}_{\ell}\right)\cdot \zu_{\ell} + \textbf{L}_{\ell}\cdot \partial_{j}\zu_{\ell},
\end{equation}
\begin{eqnarray}\label{eq:eigendiff2}
0 = \partial_{jk}\left(\textbf{L}_{\ell}\zu_{\ell}\right) = \left(\partial_{jk}\textbf{L}_{\ell}\right)\cdot \zu_{\ell}  + \textbf{L}_{\ell}\cdot \partial_{jk}\zu_{\ell} + \\
\notag \left(\partial_{j}\textbf{L}_{\ell}\right)\cdot \partial_{k}\zu_{\ell} + \left(\partial_{k}\textbf{L}_{\ell}\right)\cdot \partial_{j}\zu_{\ell}.
\end{eqnarray}

For each $\ell$ one first computes the first-order derivative of the eigenvalue $\lambda_{\ell}$ by left-multiplying by $\zu_{\ell}$ to Equation \eqref{eq:eigendiff1}. Then, by solving the remaining unknown term of Equation \eqref{eq:eigendiff1} one obtains the first-order derivatives of the eigenvector $\zu_{\ell}$. In particular, the first-order derivatives of the eigenvalues and the eigenvectors are given by
\begin{equation*}
\partial_j \lambda_{\ell} = \zu_{\ell}^{\text{T}} \cdot \partial_j \textbf{L} \cdot \zu_{\ell},\ \ \partial_j \zu_\ell = -\textbf{L}_{\ell}^+ \cdot \partial_j \textbf{L}_{\ell} \cdot \zu_{\ell},
\end{equation*}
where the operation $\textbf{L}_{\ell}^+$ is the Moore-Penrose pseudo-inverse matrix for the matrix $\textbf{L}_{\ell}$. We use the Moore-Penrose pseudo-inverse matrix instead of the inverse matrix because the matrix $\textbf{L}_{\ell}$ is singular. In addition, the redundant equations are satisfied automatically.

The second-order derivatives are obtained by applying a similar procedure. For each $\ell$ one first computes the second-order derivative of the eigenvalue $\lambda_{\ell}$ by left-multiplying by $\zu_{\ell}$ to Equation \eqref{eq:eigendiff2}. Then, by solving the remaining unknown term of Equation \eqref{eq:eigendiff2} one obtains the second-order derivatives of the eigenvector $\zu_{\ell}$. In particular, the second-order derivatives of the eigenvalues are given by
\begin{equation*}
\partial_{jk} \lambda_{\ell} = \zu_{\ell}^{\text{T}} \cdot \left(\partial_k \textbf{L}_{\ell} \cdot \partial_j\zu_{\ell} + \partial_j \textbf{L}_{\ell} \cdot \partial_k\zu_{\ell} + \partial_{jk}\textbf{L} \cdot \zu_{\ell}\right),
\end{equation*}
\begin{equation*}
\partial_{jk} \zu_\ell = -\textbf{L}_{\ell}^+ \cdot \left(\partial_k\textbf{L}_{\ell}\cdot \partial_{j}\zu_{\ell} + \partial_j\textbf{L}_{\ell}\cdot \partial_{k}\zu_{\ell} + \partial_{jk} \textbf{L}_{\ell} \cdot \zu_{\ell} \right) - \left(\partial_j \zu_{\ell}\cdot\partial_k \zu_{\ell}\right) \zu_{\ell},
\end{equation*}
where the last term of the second-order derivative of the eigenvector is obtained by imposing the second-order derivative of the imposed normalization condition $\zu_{\ell}^{\text{T}}\cdot \zu_{\ell} = 1$
\begin{equation*}
0 = \partial_{jk}\left(\zu_{\ell}^{\text{T}}\cdot \zu_{\ell}\right) = 2\partial_{jk}\zu_{\ell}^{\text{T}} \cdot \zu_{\ell} + 2\partial_{j}\zu_{\ell}^{\text{T}} \cdot \partial_{k}\zu_{\ell}.
\end{equation*}

\section{Derivatives of the implicit representation}\label{sec:appendix2}
In this Appendix, we detail the first and second-order derivatives of the normalized representation, the convex-hull representation, and the implicit representation of a B\'{e}zier patch.
They are used in the computation of the gradient and Hessian for the implicit representation, see Section \ref{sec:implicitders}.
%, see Section \ref{sec:cadimplicit}.

%%header: \textbf{Further derivatives}\\
%header: \textbf{Normalized representation}\\
%Now, the remaining derivatives are the ones of the non-trimmed B\'{e}zier representation $\gnfun_{\znurbs}$.
Herein, we consider the gradient and Hessian of the normalized representation $\gnfun$, presented in Equation \eqref{eq:normalized}.
As before, we denote by $\nabla f * \nabla g$ the matrix with coefficients $\partial_{j} f \partial_{k}g$ for $j,\ k = 1,...,d$.
In addition, we consider the symmetric term $\nabla f \otimes \nabla g := \nabla f * \nabla g + \nabla g * \nabla f$ given by the matrix with coefficients $\partial_{j} f \partial_{k}g + \partial_{k} f \partial_{j}g$ for $j,\ k = 1,...,d$.
%Specifically, they are are given by
Then, the derivatives of the normalized representation are given by
%\begin{equation*}
%\gnfun := \frac{\gfun}{\|\nabla\gfun\|}
%\end{equation*}
\begin{equation}\label{eq:gradnormalization}
\nabla\gnfun = \frac{\nabla\gfun - \gnfun\nabla\|\nabla\gfun\|}{\|\nabla\gfun\|},
\end{equation}
and
%\begin{equation*}
%\gnfun\nabla^2\gnfun = \frac{\gfun\nabla^2\gfun - \left( \frac{\nabla\gfun\nabla\|\nabla\gfun\| + \nabla\|\nabla\gfun\|\nabla\gfun + \gfun^2\nabla^2\|\nabla\gfun\|}{\|\nabla\gfun\|} + 2\frac{\gfun\nabla\|\nabla\gfun\|* \gfun\nabla\|\nabla\gfun\|}{\|\nabla\gfun\|^2}\right)}{\|\nabla\gfun\|^2},
%\end{equation*}
%\begin{equation}\label{eq:Hessnormalization}
%\gnfun\nabla^2\gnfun = \frac{\gnfun\nabla^2\gfun - \gnfun^2\nabla^2\|\nabla\gfun\| - \nabla\gnfun \otimes \gnfun\nabla \| \nabla\gfun\| + \left(\gnfun \nabla \|\nabla\gfun\| \right)*\left(\gnfun \nabla \|\nabla\gfun\| \right)/\|\nabla\gfun\|}{\|\nabla\gfun\|},
%\end{equation}
\begin{equation}\label{eq:Hessnormalization}
\gnfun\nabla^2\gnfun = \frac{\gnfun\nabla^2\gfun - \gnfun^2\nabla^2\|\nabla\gfun\| - \nabla\gnfun \otimes \gnfun\nabla \| \nabla\gfun\|}{\|\nabla\gfun\|},
\end{equation}
where
\begin{equation*}
%\gnfun\nabla\|\nabla\gfun\| = \frac{\gfun\nabla^2\gfun\cdot\nabla\gfun}{\|\nabla\gfun\|^2},
\gnfun\nabla\|\nabla\gfun\| = \frac{\gnfun\nabla^2\gfun\cdot\nabla\gfun}{\|\nabla\gfun\|},
\end{equation*}
\begin{equation*}
%\gnfun^2\nabla^2\|\nabla\gfun\| = \frac{\gfun^2\nabla^3\gfun\cdot\nabla\gfun + \gfun\nabla^2\gfun\cdot\gfun\nabla^2\gfun - \gfun\nabla\|\nabla\gfun\|* \gfun\nabla\|\nabla\gfun\|}{\|\nabla\gfun\|^3}.
\gnfun^2\nabla^2\|\nabla\gfun\| = \frac{\gnfun^2\nabla^3\gfun\cdot\nabla\gfun + \gnfun\nabla^2\gfun\cdot\gnfun\nabla^2\gfun - \gnfun\nabla\|\nabla\gfun\|* \gnfun\nabla\|\nabla\gfun\|}{\|\nabla\gfun\|}.
\end{equation*}
% and then, the implicit representation $\gamma$ presented in Equation \eqref{eq:implicit}.
%We compute the gradient and Hessian of the normalized representation $\hat{\gamma}$, presented in Equation \eqref{eq:normalized}.
%The first and second derivatives of $\gnfun$ are detailed in \ref{sec:appendix2}.
We observe that they require the first, second, and third derivatives of $\gfun$.
In addition, we consider these terms when differentiating the trimming operation, see Equations \eqref{eq:dertrim} and \eqref{eq:der2trim} for $h = \gnfun$.
In particular, the chain rule involves the terms $\nabla\gnfun$ and $\gnfun\nabla^2\gnfun$, and the terms $\nabla\gfun$, $\gfun\nabla^2\gfun$, and $\gfun^2\nabla^3\gfun$.
%When applying the chain rule to the derivatives of the trimming operation, of Equation \eqref{eq:trim}, we observe that the required terms are $\nabla\gnfun$ and $\gnfun\nabla^2\gnfun$.
%Moreover, they involve the terms $\nabla\gfun$, $\gfun\nabla^2\gfun$, and $\gfun^2\nabla^3\gfun$.
As we can see, this observation is advantageous because a straight-forward computation of the second and third derivatives, $\nabla^2\gfun$, and $\nabla^3\gfun$, involves a singularity at the corresponding zero level-set of $\gfun$.
For this reason, instead of computing directly the derivatives we consider them multiplied by the representation $\gfun$.
%For this, we consider the terms $\nabla\gfun,\ \gfun\nabla^2\gfun,\ \gfun^2\nabla^3\gfun$.

%header: \textbf{Convex-Hull}\\
Next, we compute the derivatives of the convex-hull representation $\gnfun_{\zchull\left(\znurbs\right)}$.
In particular, note that these derivatives are trivial since the representation of each hyperplane entity is linear.
Then, we differentiate the $r$-conjunction between the hyperplane representations $\gfun_{\zchull\left(\znurbs\right)}$, see Equations \eqref{eq:gradrconj} and \eqref{eq:Hessrconj}.
Finally, we differentiate the normalization of the convex-hull representation $\gnfun_{\zchull\left(\znurbs\right)}$, see Equations \eqref{eq:gradnormalization} and \eqref{eq:Hessnormalization}.

%header: \textbf{Derivatives of determinant}\\
Now, we compute the derivatives for the determinant $\gfun$ of Equation \eqref{eq:implicit}.
That is, $\nabla\gfun$, $\gfun\nabla^2\gfun$, and $\gfun^2\nabla^3\gfun$.
%, presented in Equation \eqref{eq:adjder}.
%For this, we proceed first with the derivatives matrix terms.
%These are determined by the expression of the gradient of the determinant.
First, compute the gradient of the determinant by using the Jacobi's formula
\begin{equation}\label{eq:jacobi}
%\det\left(\mathbb{N}\left(\zx\right)\right)
\nabla \gfun\left( \zx \right) = \tr\left(\zadj\cdot \nabla\mathbb{N}\left(\zx\right)\right),
\end{equation}
where $\mathbb{N}\left(\zx \right) := \mathbb{M}\left(\zx\right)\cdot \mathbb{M}\left(\zx\right)^{\text{T}}$.
We consider the adjugate matrix $\zadj$, instead of the inverse matrix, to avoid the singularity issues at the patch $\znurbs$.
In particular, the adjugate matrix of $\mathbb{N}\left(\zx \right)$ is defined by the transposed cofactor matrix, and satisfying the relation $\zadj = \gfun\left(\zx\right)\mathbb{N}\left(\zx\right)^{-1}$ \cite{upreti2014algebraic}.
%, can be written in terms of the derivatives of the adjugate matrix $\nabla\zadj,\ \nabla^2\zadj$.
%In addition, they are computed by differentiating the terms inside the trace function.
Secondly, we compute the higher-order derivatives $\gfun\nabla^2\gfun$, and $\gfun^2\nabla^3\gfun$ by differentiating the terms inside the trace function $\nabla \gfun$, see Equation \eqref{eq:jacobi}.
In particular, using the same notation as in Section \ref{sec:interpDeriv}, we compute the second derivatives for each $j$ and $k$ as
\begin{equation*}
\gfun\left(\zx\right)\partial_{jk} \gfun\left( \zx \right) = \tr\left(\gfun\left(\zx\right)\partial_{k}\zadj\cdot \partial_{j}\mathbb{N}\left(\zx\right) + \gfun\left(\zx\right)\zadj\cdot \partial_{jk}\mathbb{N}\left(\zx\right)\right).
\end{equation*}
In addition, the third derivatives are given by
\begin{eqnarray*}
\gfun\left(\zx\right)^2\partial_{j k \ell}\gfun\left( \zx \right) = \tr\left(\gfun\left(\zx\right)^2\partial_{k \ell}\zadj \cdot \partial_j \mathbb{N}\left(\zx\right) +\right.\\
\left(\gfun\left(\zx\right)^2\partial_k\zadj \cdot \partial_{j \ell} \mathbb{N}\left(\zx\right) + \gfun\left(\zx\right)^2\partial_\ell\zadj \cdot \partial_{jk} \mathbb{N}\left(\zx\right)  \right),
\end{eqnarray*}
for each $j$, $k$, and $\ell$. Note that, there is no third order term $\partial_{jk\ell} \mathbb{N}\left(\zx\right)$ because $\mathbb{N}\left(\zx\right)$ is a quadratic function on $\zx$, see Equation \eqref{eq:implicit}.

Finally, we provide the derivatives of the adjugate matrix $\zadj$.
In particular, we present them in terms of the derivatives of the inverse matrix multiplied by the determinant.
Then, to rewrite the obtained expression in terms of the adjugate matrix, we multiply both expressions by the determinant $\gfun$.
Specifically, the gradient is given by
%\label{eq:adjder}
\begin{eqnarray*}
\gfun\left(\zx\right)\nabla\zadj = \gfun\left(\zx\right)\nabla\left(\gfun\left(\zx\right)\mathbb{N}\left(\zx\right)^{-1}\right) =\\
\zadj\nabla\gfun\left(\zx\right) - \mathbb{N}\left(\zx\right)\cdot\zadj\cdot\mathbb{N}\left(\zx\right).
\end{eqnarray*}
We apply the same reasoning for the Hessian by computing
\begin{equation*}
\gfun\left(\zx\right)^2\nabla^2\zadj = \gfun\left(\zx\right)^2 \nabla\left(\frac{1}{\gfun\left(\zx\right)}\gfun\left(\zx\right)\nabla\zadj\right).
\end{equation*}
In particular, using the same notation as in Section \ref{sec:interpDeriv}, for each $j$ and $k$ we have
\begin{eqnarray*}
%	= -\gfun\partial_{j}\zadjj\partial_k\gfun + \gfun \partial_k \left(\gfun\partial_j\zadjj\right)=\\
	\gfun^2\partial_{jk}\zadjj = \left(\gfun \partial_{jk}\gfun\right)\zadjj + 
	\left(\partial_{j}\gfun\right)\gfun\partial_k\zadjj - \left(\partial_{k}\gfun\right)\gfun\partial_j\zadjj-\\
	\gfun\zadjj\cdot\partial_{jk}\zmat\cdot\zadjj -
	\gfun \partial_k\zadjj \cdot \partial_j\zmat \cdot\zadjj -
	\zadjj \cdot \partial_j\zmat\cdot\gfun \partial_k\zadjj,
\end{eqnarray*}
where, for the sake of brevity, we omit the dependence on the $\zx$ variable of the functions $\gfun$ and $\zmatrix$.

\bibliography{globalreferences}

\end{document}