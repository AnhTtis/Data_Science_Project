\iffalse \section{Preliminaries and PROBLEM Settings}
\label{sec:problem}
%In this section, we review some basic concepts and formally introduce the setting of a cost estimator.
% \noindent \textbf{DBMS} Database Management Systems (DBMS) are software systems used to store, retrieve, and run queries on data. For several past years, the most prevalent baseline and tool in the area of cost and cardinality estimation among database options has been PostgreSQL~\cite{sun13end,yang2020neurocard,zhu2020flat,yang2019deep,hilprecht2022zero,han2021cardinality,wang2021we,wu2021unified,marcus2019plan}. It is an advanced open-source object-relational system which applies SQL language. So we also use the analysis tool in PostgreSQL to generate the training and test plans, and use it as one of the baselines.

%\vspace{1mm}
\noindent The execution plan is an instruction that describes how the received query is performed. %Execution plans are devised by the database system, and choosing the optimal plan is critical for good query performance. 
The structure of an execution plan is a tree of sub-plan nodes (as shown in Figure~\ref{fig:modeldesign}(a) (Left)) with three types defined by their operations. Scan nodes are always the leaves of the tree, which return the result by scanning the data on the disk or memory. The binary nodes with two children are responsible for merging the results of its scan leaves together. A unary node is a node that has a single child node, which processes the data of its child for subsequent use, such as Sort and Hash. 
% \noindent \underline{Execution Plan.} The execution plan is an instruction that describes how the received query is performed. Execution plans are devised by the database system, and choosing the optimal plan is critical for good query performance. The structure of an execution plan is a tree of sub-plan nodes (as shown in Figure~\ref{fig:modeldesign}(a) (Left)). Leaf nodes of the tree are scan nodes: they return rows from a raw table. Nodes with two child nodes are {\it merge nodes}, which are responsible for joining the results of its scan leaves together.
%  We say a merge node as a {\it low-level merge node}, if its two child nodes are leaf nodes.
% A {\it materialization node} is a node that has a single child node. %If we follow the detailed operations based on a post-order traversal of the plan tree, a correct result of the SQL statement can be obtained. When execution plans are used for training, each node in the execution plan should have both plan (designed by the analysis tools in database systems) and actual information including cardinality, execution time, the source of data (raw table or the result of previous nodes) of each sub-plan. When the plan is used for testing, each node only contains planned information without actual ground-truth information.

% \noindent \textbf{Predicate.} A predicate in a query is a condition expression which evaluates and results in a boolean value either true or false which enables decision making in retrieving and manipulating a record. For example, in the example query in Figure~\ref{fig:modeldesign}, ``t.production\_year BETWEEN 1980 AND 2010'' is a filtering predicate and ``ci.movie\_id = t.id'' is a join predicate. We can also easily get the count of the filters in a filtering predicate. For example, ``t.production\_year BETWEEN 1980 AND 2010'' will be divided into two filters, ``t.production\_year >= 1980'' and ``t.production\_year <= 2010''. 

% \vspace{1mm}
% \noindent \underline{Predicate.} A predicate in a query is a condition that evaluates and results in a boolean value that indicates whether a record meets the condition in the filter, or whether two records should be joined. In the example query in Figure~\ref{fig:modeldesign}, ``t.production\_year BETWEEN 1980 AND 2010'' is a filtering predicate, while ``ci.movie\_id = t.id'' is a join predicate. We can also easily get the count of the filters in a filtering predicate. For example, ``t.production\_year BETWEEN 1980 AND 2010'' will be divided into two filters, ``t.production\_year >= 1980'' and ``t.production\_year <= 2010''. 

% \vspace{1mm}
% \noindent \underline{Execution Cost.} The execution cost (or {\it cost} when the context is clear) of a plan refers specifically to the CPU execution time. We use the default setting in PostgreSQL, millisecond, as the unit of measurement.

% \vspace{1mm}
% \noindent Physical operators  describe how the database implement the sub-plans and also define the types of the sub-plans. Common operators include three types: scan operators, merge operators, and materialization operators. Their execution ways and performance vary widely, so there is a big gap between their costs. Scan operators return raw rows matching the predicate from a table. Scan operators can be further divided into Sequential Scan (Seq Scan for short) and operators by index (e.g. Index Scan and Bitmap Scan). Seq Scan scans the entire table as stored on disk, while operators by index need to perform an index (e.g. B-tree) traversal to fetch the corresponding data. Merge nodes merge two sets of tuples based on the specified columns. Materialization operators manipulate (e.g. Sort and Hash) and cache the data generated in a SQL query in physical memory. 
% \noindent \underline{Physical Operator.} Physical operators implement what the database system does according to the description by the queries. Common operators include three types: scan operators, merge operators, and materialization operators. Their execution ways and performance vary widely, so there is a big gap between their costs. Scan operators return raw rows matching the predicate from a table. Scan operators can be further divided into Sequential Scan (Seq Scan for short) and operators by index (e.g. Index Scan and Bitmap Scan). Seq Scan scans the entire table as stored on disk, while operators by index need to perform an index (e.g. B-tree) traversal to fetch the corresponding data. Merge nodes merge two sets of tuples based on the specified columns. Materialization operators manipulate (e.g. Sort and Hash) and cache the data generated in a SQL query in physical memory. 


% Therefore, there is a big gap between their costs. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. 
% \noindent \textbf{Join Key}

% \vspace{1mm}
% \noindent \underline{Cardinality.} The cardinality of a SQL query is the row count of the tuples satisfying all the predicates in the query. Cardinality is an important factor in determining the actual execution cost of a node in the execution plan. Generally speaking, the cardinalities of the input and output of a query will both affect the actual reflected cost due to the overhead of storing and transferring data.

\vspace{1mm}
\noindent \textbf{Our problem:} \underline{Building a cost estimator.} The objective of the work is to build a model that leverages the execution plans generated by the database system and the underlying data to estimate the execution time (cost) of the plans. 
% For formalization, our goal is to train a model parameterized by $\theta$ (i.e. weights and biases in MLPs). The input is the execution plan $\mathcal{P}$ and the underlying data $\mathcal{D}$. and the output is the cost estimate $\mathcal{C}$, which is expected to be as close as possible to the actual cost
% %\begin{displaymath}
%   $\mathcal{C} = Model(\mathcal{P},\mathcal{D};\theta)$.
% %\end{displaymath}


%The model is commonly applied in the following scenarios in database systems. The user uses DBMS to collect the information (such as operators, costs, and cardinalities) in some execution plans. The information is then processed to train our model, and the target is to minimize the actual execution costs by selecting the plans that have the shortest predicted execution time. %After training process, our model will be evaluated on defined benchmarks. Furthermore, when the database updates, the model keeps the accuracy by re-sampling the data in a short time rather than retraining.
%{\color{red} explain what are static/dynamic settings.}
\fi