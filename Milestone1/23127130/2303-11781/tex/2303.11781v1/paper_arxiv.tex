\documentclass[aps,prb,amsmath,amssymb,citeautoscript,reprint]{revtex4-2}
\usepackage{graphicx, float, xcolor, pgf}
\usepackage{physics, siunitx}
\usepackage{textgreek}
\usepackage{enumitem}
\usepackage[frozencache,cachedir=.]{minted}
\usepackage[caption=false, justification=centerlast]{subfig}

\usepackage{hyperref}
\hypersetup{
    pdfauthor={Amartya Bose},
    pdftitle={QuantumDynamics.jl: A modular approach to simulations of dynamics of open-quantum systems},
    colorlinks=true,
    %allcolors=.
}

\begin{document}
\title{QuantumDynamics.jl: A modular approach to simulations of dynamics of open quantum systems}
\author{Amartya Bose}
\affiliation{Department of Chemical Sciences, Tata Institute of Fundamental Research, Mumbai 400005, India}
\email{amartya.bose@tifr.res.in}
\begin{abstract}
    Simulation of non-adiabatic dynamics of a quantum system coupled to
    dissipative environments poses significant challenges. New sophisticated
    methods are regularly being developed with an eye towards moving to larger
    systems and more complicated description of solvents. Many of these methods,
    however, are quite difficult to implement and debug. Furthermore, trying to
    make the individual algorithms work together through a modular application
    programming interface (API) can be quite difficult. We present a new,
    open-source software framework, QuantumDynamics.jl, designed to address
    these challenges. It provides implementations of a variety of perturbative
    and non-perturbative methods for simulating the dynamics of these sytems.
    Most prominently, QuantumDynamics.jl supports hierarchical equations of
    motion and the family of methods based on path integrals. Effort has been
    made to ensure maximum compatibility of interface between the various
    methods. Additionally, QuantumDynamics.jl, being built on a high-level
    programming language, brings a host of modern features to explorations of
    systems such as usage of Jupyter notebooks and high level plotting, possibility
    of leveraging high-performance machine learning libraries for further
    development. Thus, while the built-in methods can be used as end-points in
    themselves, the package provides an integrated platform for experimentation,
    exploration, and method development.
\end{abstract}
\maketitle

\section{Introduction}
Understanding the evolution of a system over time is at the heart of chemistry
and physics. While many systems can indeed be treated classically, there are
several important problems where the quantum mechanical mechanism of tunneling
becomes inescapable. Some of the most ubiquitous of these are charge transfer
problems, excitation energy transfer processes and spin dynamics. Additionally,
in all these cases the dynamics may be severely modulated by the existence of
solvent degrees of freedom which exist at a given temperature. The necessity of
simulating the systems quantum mechanically while accounting for the environment
and solvents accurately prove to be significantly challenging.

Various approaches exist to tackle this problem. On the end of approximate
approaches there is the perturbative Bloch-Redfield Master
Equations~\cite{blochGeneralizedTheoryRelaxation1957,
    redfieldTheoryRelaxationProcesses1957} (BRME) and methods based on empirical
Lindbladians. However, these are uncontrolled approximations with no good error
bounds. Therefore it becomes important to be able to obtain the exact dynamics
for these systems. Various path integral-based techniques like the
quasi-adiabatic propagator path
integral~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995, makriNumericalPathIntegral1995} (QuAPI)
family of methods and hierarchy equations of
motion~\cite{tanimuraTimeEvolutionQuantum1989,
    ishizakiQuantumDynamicsSystem2005, tanimuraStochasticLiouvilleLangevin2006}
(HEOM) family of methods exist which at greater costs can simulate the full
non-Markovian dynamics of a quantum system coupled with dissipative media using
the Feynman-Vernon influence functional~\cite{feynmanTheoryGeneralQuantum1963}.
Over the years, methods of unparallelled sophistication have been built on both
these frameworks which reduce the computational costs of
simulations~\cite{makriBlipDecompositionPath2014,
    makriIterativeBlipsummedPath2017, bosePairwiseConnectedTensor2022,
    boseMultisiteDecompositionTensor2022, makriModularPathIntegral2018,
    boseTensorNetworkRepresentation2021, jorgensenExploitingCausalTensor2019,
    makriSmallMatrixDisentanglement2020, makriSmallMatrixPath2020,
    makriSmallMatrixModular2021, makriSmallMatrixPath2021a,
    strathearnEfficientNonMarkovianQuantum2018, huPadeSpectrumDecompositions2011,
    shiEfficientHierarchicalLiouville2009, shiEfficientPropagationHierarchical2018,
    yanEfficientPropagationHierarchical2021,
    ikedaGeneralizationHierarchicalEquations2020}.

Despite the existence of a multitude of rigorous methods, software support for
quantum dynamics is relatively sparse. The situation becomes especially stark
when put in comparison to the plethora of alternatives, both open-source and
proprietary, that exist for electronic structure
theory~\cite{apraNWChemPresentFuture2020, frischGaussian16Rev2016,
    smithPSI4OpensourceSoftware2020, sunPySCFPythonbasedSimulations2018,
    balasubramaniTURBOMOLEModularProgram2020, kuhneCP2KElectronicStructure2020,
    giannozziQUANTUMESPRESSOModular2009,
    giannozziAdvancedCapabilitiesMaterials2017}. The lack of easily available
implementation of the latest methods prevent their widespread adoption. In
addition to preventing people from both being able to apply these novel ideas to
a variety of problems, this has the inadvertent disadvantage of preventing
critical comparison and evaluation of the different methods. In terms of
providing access to multiple state-of-the-art algorithms for dynamics in a
single package, i-PI~\cite{kapilIPIUniversalForce2019} is exemplary, providing
flexible implementations of various methods based on imaginary time path
integral and approximate quantum dynamics using ring-polymer. However, it does
not support approaches for simulating non-adiabatic processes.

Amongst exact methods for simulating processes that can be decomposed in terms
of a quantum system interacting with a thermal bath, HEOM has a fair number of
implementations~\cite{kreisbeckExcitonDynamicsLab,
    strumpferOpenQuantumDynamics2012, tsuchimotoSpinsDynamicsDissipative2015,
    temenHierarchicalEquationsMotion2020}.
QuTiP~\cite{johanssonQuTiPPythonFramework2013}, which supports a plethora of
approximate methods for simulating open quantum systems, has an implementation
of HEOM. A C++/Python software called
Libra~\cite{akimovLibraOpensourceMethodology2016} and a new Julia package called
NQCDynamics.jl~\cite{gardnerNQCDynamicsJlJulia2022} have been developed
primarily for using classical trajectory-based methods for simulating
non-adiabatic quantum dynamics. However, when it comes to numerically ``exact''
simulation of these systems and supporting the variety of state-of-the-art real
time path integral-based methods in a modular fashion, there is a severe dearth
of software. This has been a significant impediment in the approachability,
adoption and further development of these powerful methods.

Most computational codes have been historically written in C or C++ or Fortran.
While performant, these languages are low-level and their use significantly adds
to the code complexity and raises the bar for others contributing to the
frameworks. Of late, Python is being used for writing scientific code, with the
most performance intensive parts written in C or C++.  Prime examples of
programs and packages using this ``two-language'' infrastructure are
PySCF~\cite{sunPySCFPythonbasedSimulations2018},
Psi4~\cite{smithPSI4OpensourceSoftware2020},
i-PI~\cite{kapilIPIUniversalForce2019}, etc. A relatively new language called
Julia~\cite{bezansonJuliaFreshApproach2017}, with promise in terms of balancing
performance with ease of use, has been gaining popularity in the scientific
community. It features a just-in-time compilation scheme that solves the
two-language problem, where the API exposes features to a high-level language
but the performance-critical parts are coded in a different low-level language.
It consequently becomes easy to have scientific packages written completely in
Julia without sacrificing performance. There has been an explosion of packages
for computational chemistry in Julia in the recent
past~\cite{aroeiraFermiJlModern2022, gardnerNQCDynamicsJlJulia2022,
    herbstDFTKJulianApproach2021, kramerQuantumOpticsJlJulia2018,
    pooleNewKidBlock2020, pooleTaskBasedApproachParallel2022}.

We introduce a new open-source software package for the Julia language called
\href{https://github.com/amartyabose/QuantumDynamics.jl}{QuantumDynamics.jl} for
providing easy access to the state-of-the-art tools for rigorous simulation of
non-adiabatic systems to the community. An implementation in a high-performance,
high-level language is convenient for widespread adoption and easy development
in the future. Though it supports some approximate methods, the primary focus of
QuantumDynamics.jl is methods for numerically exact simulations of non-adiabatic
problems. The design aims at providing atomic concepts that help maximize reuse
of code between a diverse set of path integral-based methods. The paper is
organized as follows.
\href{https://amartyabose.github.io/QuantumDynamics.jl/dev/}{Online
    documentation} has already been provided. It will continue to be maintained,
updated, and improved upon as the package changes. In
Sec.~\ref{sec:methods_structure}, we discuss the methods supported in
QuantumDynamics.jl and the structure of the package. We demonstrate the usage of
the package through representative examples of the methods. While code snippets
have been provided in this paper, the full examples are there in the
\href{https://github.com/amartyabose/QuantumDynamics.jl/tree/main/examples}{examples
    folder of the repository}. Some concluding remarks are provided in
Sec.~\ref{sec:conclusions}.

\section{Methods Supported and Structure of the Code}\label{sec:methods_structure}
\subsection{Methods Supported}
The main focus of QuantumDynamics.jl is the simulation of dynamics of open
quantum systems with non-adiabatic processes. These are characterized a
relatively small dimensional quantum system, described by a Hamiltonian,
$\hat{H}_0$, interacting with $N_\text{env}$ large thermal environments.
\begin{align}
    \hat{H}                  & = \hat{H}_0 + \sum_b^{N_\text{env}}\hat{H}^{(b)}_\text{env}\label{eq:sys_bath}                                                                                  \\
    \hat{H}^{(b)}_\text{env} & = \sum_j \frac{p_{jb}^2}{2m_{jb}} + \frac{1}{2}m_{jb}\omega_{jb}^2\left( x_{jb} - \frac{c_{jb} \hat{s}_b}{m_{jb}\omega_{jb}^2} \right)^2, \label{eq:quapi_bath}
\end{align}
where $\omega_{jb}$ and $c_{jb}$ are the frequency and coupling of the $j$th
mode of the $b$th environment. The interaction between the system and the $b$th
environment is described by $\hat{H}^{(b)}_\text{env}$ and happens through the
system operator $\hat{s}_b$. In general the environments are atomistically
defined. However, under Gaussian response limit, it is possible to map the
effects of the atomistic environment onto a bath of harmonic
oscillators~\cite{makriLinearResponseApproximation1999,
    allenDirectComputationInfluence2016, waltersDirectDeterminationDiscrete2017,
    boseZerocostCorrectionsInfluence2022} through the energy gap
auto-correlation function and its spectral density,
\begin{align}
    J_b(\omega) & = \frac{\pi}{2}\sum_j \frac{c_{jb}^2}{m_{jb}\omega_{jb}}\delta(\omega-\omega_{jb}).
\end{align}
The famous spin-boson model is a specialization of Eq.~\ref{eq:sys_bath} for the
case of $\hat{H}_0 = \epsilon\sigma_z - \hbar\Omega\sigma_x$, where $\epsilon$
is the asymmetry between the two states and $\Omega$ is the coupling strength.
Spin-boson models typically have a single harmonic bath as an environment.
Two of the most common model spectral densities are
\begin{align}
    J_\text{ExpCutoff}(\omega, n)             & = \frac{2 \pi}{\Delta s^2}\hbar\xi\frac{\omega^n}{\omega_c^{n-1}}\exp\left(-\frac{\omega}{\omega_c}\right),\label{eq:expcutoff} \\
    \text{and } J_\text{DrudeLorentz}(\omega) & = \frac{2 \lambda}{\Delta s^2} \frac{\gamma \omega}{\omega^2 + \gamma^2}.\label{eq:drudelorentz}
\end{align}
Here $\Delta s$ is the separation between the system states. Depending on the
value of $n$, $J_\text{ExpCutoff}$ represents an Ohmic spectral density ($n=1$),
super-Ohmic spectral density ($n>1$) or sub-Ohmic spectral density ($n<1$). This
family of spectral densities is specified in terms of the dimensionless Kondo
parameter, $\xi$, and the cutoff frequency, $\omega_c$. The Drude-Lorentz
spectral density is another Ohmic spectral density but with a Lorentzian cutoff.
It is typically specified using a reorganization energy, $\lambda$, and the
characteristic bath time scale, $\gamma$.

There are a variety of approaches for simulating the dynamics of these systems
ranging from completely empirical to numerically exact. The implementations are
often challenging and hard to bring to a common interface. Because of the
typically strong system-environment couplings, perturbative methods of
calculation of dynamics are often not very accurate. However, they still might
provide useful starting points for understanding the dynamics. A broad set of
these exact and approximate methods are supported in QuantumDynamics.jl. They
can be roughly categorized as
\begin{enumerate}[noitemsep,topsep=0.25em]
    \item Empirical approaches
    \item Hierarchical Equations of Motion
    \item Path integral approaches
\end{enumerate}
It is often difficult to maintain consistency of the interface across these
different classes of approaches. However, within every category, the consistency
has been ensured. QuantumDynamics.jl does not support the rich gamut of
classical trajectory-based methods. Consequently, notable in its omission is the
ubiquitous surface hopping method~\cite{tullyMolecularDynamicsElectronic1990,
    tullyPerspectiveNonadiabaticDynamics2012, wangRecentProgressSurface2016}.
The NQCDynamics.jl package~\cite{gardnerNQCDynamicsJlJulia2022} implements
surface hopping both in its fewest switching form and in connection to
ring-polymer molecular dynamics. It also implements various other classical
trajectory-based approaches in a modular manner.

Within the group of empirical approaches, QuantumDynamics.jl
supports propagation of both Hermitian and non-Hermitian systems. It also
supports more rigorous approaches based on master equations such as BRME and
Lindblad master equation. HEOM~\cite{tanimuraTimeEvolutionQuantum1989,
    ishizakiQuantumDynamicsSystem2005, tanimuraReducedHierarchicalEquations2014,
    tanimuraNumericallyExactApproach2020} is implemented in its ``scaled''
form~\cite{shiEfficientHierarchicalLiouville2009}. While many other improvements
and extensions of HEOM exist in the literature, they have not yet been
implemented in QuantumDynamics.jl. These will be incorporated in future versions
as and when required.

The largest class of methods supported by QuantumDynamics.jl is in the path
integral approaches. In addition to the original
QuAPI~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995, makriNumericalPathIntegral1995}, blip
decomposition of path integrals~\cite{makriBlipDecompositionPath2014,
    makriIterativeBlipsummedPath2017} (BSPI), the tensor network path
integral~\cite{boseTensorNetworkRepresentation2021} implementation of
time-evolving matrix product
operator~\cite{strathearnEfficientNonMarkovianQuantum2018} (TEMPO) approach and
the pairwise-connected tensor network path
integral~\cite{bosePairwiseConnectedTensor2022} (PC-TNPI) method are supported.
Quantum-classical path integral~\cite{lambertQuantumclassicalPathIntegralI2012,
    lambertQuantumclassicalPathIntegralII2012} (QCPI) using solvent-driven
references~\cite{banerjeeQuantumClassicalPathIntegral2013} in the harmonic
backreaction~\cite{wangQuantumclassicalPathIntegral2019} framework has been
implemented using the same interface. As elaborated in Sec.~\ref{sec:structure},
the code has been designed in a way that QCPI could be used with different
``backends'' corresponding to QuAPI or TEMPO.

Ideas of dynamical maps have been shown to be effective in understanding
non-Markovian evolution of systems~\cite{cerrilloNonMarkovianDynamicalMaps2014}.
The transfer tensor method~\cite{cerrilloNonMarkovianDynamicalMaps2014} (TTM)
allows construction of transfer tensors from dynamical maps, which for open
quantum systems are the forward-backward propagators augmented by the bath
influence, $\mathcal{E}(t) =
    \Tr_\text{bath}\left(\exp\left(-i\mathcal{L}t/\hbar\right)\right)$, where
$\mathcal{L}$ is the Liouvillean corresponding to the system-bath. These
transfer tensors can be further used to propagate the reduced density matrix of
the system beyond the memory length. This reduces the complexity of simulating
the time-evolution beyond memory length to multiplying matrices of the size of
the system and removes all storage requirements. TTM in QuantumDynamics.jl can
take advantage of the forward-backward augmented propagators obtained from other
path integral methods like QuAPI, TEMPO, PC-TNPI, and blips.

The small matrix decomposition of path
integral~\cite{makriSmallMatrixDisentanglement2020, makriSmallMatrixPath2020}
(SMatPI) is a rigorous QuAPI-based method which achieves a similar objective but
with more efficient implementations for extended memory
length~\cite{makriSmallMatrixPath2021a} and support for simulation of dynamics
under the influence of external fields~\cite{makriSmallMatrixPath2021}. It has
been noted by~\citet{makriSmallMatrixPath2020} that while TTM employs
time-translational invariance leading to generation of spurious memory, SMatPI
through a rigorous derivation based on QuAPI lifts this limitation.
QuantumDynamics.jl enables the use of tensor network-based methods like TEMPO
with TTM which allows inclusion of the possible spurious memory generated
without a significant increase in computational complexity.

% The recent development of the small matrix decomposition of path
% integral~\cite{makriSmallMatrixPath2020, makriSmallMatrixPath2021,
%     makriSmallMatrixPath2021a, makriSmallMatrixDisentanglement2020} (SMatPI) has
% increased the allure of doing path integral simulations for large systems
% manifold~\cite{kunduB800toB850RelaxationExcitation2022, kunduTightInnerRing2022,
%     kunduIntramolecularVibrationsExcitation2022}. SMatPI is able to reduce the
% storage requirements to matrices of the size of the reduced density matrix,
% thereby also reducing the computational complexity of path integral simulations.
% However, this method has not yet been implemented in QuantumDynamics.jl.  SMatPI
% is closely related to the tensor transfer
% matrix~\cite{cerrilloNonMarkovianDynamicalMaps2014} (TTM) technique, which has
% been used in conjunction with other
% methods~\cite{gelzinisApplicabilityTransferTensor2017,
%     kananenkaAccurateLongTimeMixed2016,
%     rosenbachEfficientSimulationNonMarkovian2016}. While the two methods are very
% similar in terms of their ability to reduce the computational costs, TTM
% utilizes translational invariance which leads to spurious
% memory~\cite{makriSmallMatrixPath2020}. QuantumDynamics.jl implements TTM in a
% manner that makes it possible to use it in conjunction with  exact path integral
% calculations with the TTM scheme to minimize the spurious memory generated. We
% feel that the capabilities of TEMPO in accessing large memories will make it
% relatively simple to account for any spurious increase in memory, thereby
% increasing the utility of TTM. 

All these methods with the exception of TTM have been implemented in a manner so
that they can simulate the dynamics of these systems in presence of external
time-dependent fields. One of the potential applications of such time-dependent
fields is simulation of dynamics in the presence of light described in a
semiclassical manner.

\subsection{Code Structure}\label{sec:structure}
QuantumDynamics.jl, being a Julia package, can be used on any operating system
and platform supported by the programming language. It has recently been
registered with the Julia package registry. Thus, the installation procedure is
relatively simple. After Julia has been setup, there are two ways of installing
QuantumDynamics.jl. The first way involves Julia's package manager
read-eval-print loop (REPL) interface:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
julia> ]
pkg> add QuantumDynamics
\end{minted}
The alternate is to use the \verb|Pkg| module in Julia:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
import Pkg
Pkg.add("QuantumDynamics")
\end{minted}
All the dependencies will automatically be installed. Julia comes with
implementations of OpenBlas built-in by default. However, depending on the
architecture, it may be preferable to install and use Intel's Math Kernel
Library (MKL), which can be installed as an additional package MKL.jl. If MKL is
used, it should be loaded before QuantumDynamics.jl in the source code.

In QuantumDynamics.jl, an attempt has been made to provide as flexible and
consistent an application programming interface (API) as possible across the
gamut of supported methods. This consistency is crucial in ensuring a successful
mix-and-match of various approaches. However, this is an extremely challenging
task given the different requirements and restrictions of various methods. In
this section, we discuss some of the crucial design choices present in this
package.

Each method has its own module. The empirical methods are completely grouped in
the \verb|Bare| module. Bloch-Redfield Master
Equation~\cite{redfieldTheoryRelaxationProcesses1957,
    blochGeneralizedTheoryRelaxation1957} and
HEOM~\cite{tanimuraNumericallyExactApproach2020} are supported in the
\verb|BlochRedfield| and \verb|HEOM| modules respectively.  The path
integral methods are more varied and have been afforded their individual
modules viz. \verb|QuAPI|~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995},
\verb|Blip|~\cite{makriBlipDecompositionPath2014},
\verb|TEMPO|~\cite{strathearnEfficientNonMarkovianQuantum2018},
\verb|PCTNPI|~\cite{bosePairwiseConnectedTensor2022}, etc. All the path
integral methods, with the exception of quantum-classical path
integral~\cite{lambertQuantumclassicalPathIntegralI2012,
    lambertQuantumclassicalPathIntegralII2012}, builds on top of a time-series of
forward-backward propagators corresponding to the bare or isolated system.
Because of this decision, it becomes possible for QCPI to use any of the base
path integral methods as the engine to simulate the dynamics. For every sampled
phase space point of the solvent, the QCPI routine provides the underlying path
integral routine a sequence of solvent-driven reference
propagators~\cite{banerjeeQuantumClassicalPathIntegral2013}, and obtains as an
output the reduced density matrices after incorporation of the backreaction in
the harmonic approximation~\cite{wangQuantumclassicalPathIntegral2019}. The
toggle of whether the full memory needs to be incorporated or just the quantum
memory from the back reaction is necessary, is determined by the boolean
parameter, \verb|reference_propagator|. If \verb|reference_propagator| is false,
which is the default behavior, then the full influence functional is
incorporated, else only the quantum memory is incorporated. For any method, the
function for simulating the dynamics of an reduced density matrix is called
\verb|propagate|. Individual methods often have convergence parameters that
differ wildly from each other. All such parameters are grouped in
method-specific argument types all derived from \verb|Utilities.ExtraArgs|.

QCPI requires definition of a solvent, which is treated by classical
trajectories. This facility is provided by the abstract struct
\verb|Solvents.Solvent|, which can be inheritted from for different types of
solvents. Currently only a discrete harmonic bath is provided. There is scope
for providing wrappers around emerging Julia libraries for doing molecular
dynamics as more detailed solvents. Associated with each solvent is a
description of the corresponding phase space, and an iterator which generates
phase space points that are distributed according to the thermal Boltzmann
distribution.

Many of the empirical methods and HEOM require solution of differential
equations, which is done numerically using the
DifferentialEquations.jl~\cite{rackauckasDifferentialequationsJlPerformant2017}
package. It implements a variety of methods for solving differential equations.
The details that control differential equation solver like the method of
simulation, relative error and absolute error, are controlled through the
structure, \verb|Utilities.DiffEqArgs|. In QuantumDynamics.jl, the default
method of solution is an adaptive Runge-Kutta approach of orders 5
(4)~\cite{tsitourasRungeKuttaPairs2011}, though other methods can be easily used
by suitably changing the \verb|Utilities.DiffEqArgs| passed to the method. The
methods based on tensor network are built on the open-source
\textsc{ITensor}~\cite{fishmanITensorSoftwareLibrary2022,
    fishmanCodebaseReleaseITensor2022} library.

For the specification of the bath spectral densities, QuantumDynamics.jl
provides a SpectralDensities module. Currently we support
\verb|ExponentialCutoff| for Eq.~\ref{eq:expcutoff} and \verb|DrudeLorentz| for
Eq.~\ref{eq:drudelorentz}. Facilities are provided for reading in tabulated
spectral densities obtained as Fourier transforms of numerically simulated bath
response functions is also provided through \verb|SpectralDensityTable|. Utility
functions are provided for reading the tabulated data for both $J(\omega)$ and
$J(\omega)/\omega$.

Finally, TTM~\cite{cerrilloNonMarkovianDynamicalMaps2014} builds on propagators
from initial time, $t=0$, to final time. Thus, in addition to providing routines
for propagating a reduced density matrix, the various sub-modules for path
integral also provide \verb|build_augmented_propagator| functions that calculate
the time-series of propagators including the solvent effects using the
corresponding full path methods. As detailed in the numerical examples,
Sec.~\ref{sec:num_example}, these functions make it possible to use TTM to
propagate a system whose augmented propagators have been calculated using some
path integral method.

The full
\href{https://amartyabose.github.io/QuantumDynamics.jl/dev/}{documentation} of
the package also shows other examples along with detailed description of the
various arguments and parameters supported by these methods. It will remain
updated as the package continues to evolve and implement other methods.

\section{Numerical Examples}\label{sec:num_example}
\subsection{Empirical Approaches to Open Quantum Systems}\label{sec:empirical}
\subsubsection{Isolated Hermitian \& Non-Hermitian Systems}
The simplest case of propagation happens to be for an isolated system. The
dynamics is Markovian. QuantumDynamics.jl provides interface for simulating this
dynamics both for Hermitian and non-Hermitian systems defined by a Hamiltonian,
$\hat{H}$. The equation of motion for the density matrix,
\begin{align}
    i\hbar\partial_t\rho(t) = \hat{H}\rho(t) - \rho(t)\hat{H}^\dag,
\end{align}
works for both types of systems.

Consider two degenerate states that are described by the Hamiltonian,
\begin{align}
    \hat{H} = \begin{pmatrix}
                  0.0  & -1.0 \\
                  -1.0 & 0.0
              \end{pmatrix}
\end{align}
This is a Hermitian Hamiltonian. In addition, also consider a non-Hermitian
Hamiltonian where the two states are lossy with different rates:
\begin{align}
    \hat{H}_\text{nh} = \begin{pmatrix}
                            -0.1i & -1.0  \\
                            -1.0  & -0.5i
                        \end{pmatrix}
\end{align}

\begin{figure}
    \subfloat[Hermitian system, $\hat{H}$]{\includegraphics{data_runs/bare_system.pdf}}
    ~\subfloat[Non-Hermitian system, $\hat{H}_\text{nh}$]{\includegraphics{data_runs/nonhermitian_system.pdf}}

    \subfloat[Hermitian system, $\hat{H} + V(t)$]{\includegraphics{data_runs/bare_system_field.pdf}}
    ~\subfloat[Non-Hermitian system, $\hat{H}_\text{nh} + V(t)$]{\includegraphics{data_runs/nonhermitian_system_field.pdf}}
    \caption{Dynamics of the different elements of the density matrix.}\label{fig:isolated_dynamics}
\end{figure}
The Hamiltonian in either case can be defined as a $2\times 2$ complex matrix or
by using the convenience function \verb|Utilities.create_tls_hamiltonian|.
Currently, QuantumDynamics.jl also provides another convenience function for
creating a periodic or aperiodic nearest-neighbor Hamiltonian,
\verb|Utilities.create_nn_hamiltonian|.

The dynamics of a system under these two Hamiltonians starting with a density
matrix of
\begin{align}
    \rho(0) = \begin{pmatrix}
                  1.0 & 0.0 \\
                  0.0 & 0.0
              \end{pmatrix}.
\end{align}
is shown in Figs.~\ref{fig:isolated_dynamics}~(a) and (b). When a time-dependent
external field, $V(t) = 12\cos(10t)$, is coupled with the operator
$\hat\sigma_z$, the dynamics changes substantially. The dynamics under the
external field for the Hermitian and non-Hermitian systems are shown in
Fig.~\ref{fig:isolated_dynamics}~(c) and (d) respectively.

The code snippet for simulating the dynamics of the non-Hermitian system in
presence of the external field is as follows:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
using QuantumDynamics

# define the Hamiltonian
H = [-0.1im -1.0; -1.0 -0.5im]
V(t) = 12 * cos(10.0 * t)
EF = Utilities.ExternalField(V, [1.0+0.0im 0.0; 0.0 -1.0])

# define the initial condition, the time step and the number of steps of simulation
ρ0 = [1.0+0.0im 0.0; 0.0 0.0]
dt = 0.125
ntimes = 100

# simulate the dynamics using the propagate method
times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes, external_fields=[EF])
\end{minted}
The other cases are also similar. Notice that the Hamiltonian is defined as a
simple $2\times2$ matrix. The design moves away from defining classes
hierarchies for these fundamental objects because that creates barriers when
using different hardwares. For example, with the current design, implementing
the same algorithm on a graphics processing unit (GPU) should be as simple as
using the array abstractions in a Julia library like
CUDA.jl~\cite{besardEffectiveExtensibleProgramming2018}. The external field,
\verb|Utilities.ExternalField|, is a \verb|struct| with a simple function of
time and the system operator that couples to the field. The same
\verb|Bare.propagate| function works for Hermitian or non-Hermitian systems with
or without external fields.

\subsubsection{Lindblad Master Equation}\label{sec:lindblad}
Consider a system interacting with a variety of environment degrees of freedom
as in Eq.~\ref{eq:sys_bath}. An empirical approach of incorporating effects of
these environments on the dynamics of the reduced density matrix (RDM) of the
quantum systems is through the use of the Lindblad Master Equation,
\begin{align}
    \dv{\rho(t)}{t} & = -\frac{i}{\hbar}\commutator{\hat{H}_0}{\rho(t)} + \sum_j \left( L_j\rho(t)L_j^\dag - \frac{1}{2}\anticommutator{L_j^\dag L_j}{\rho(t)} \right),
\end{align}
where $\hat{H}_0$ is the Hamiltonian of the system, $\rho(t)$ is the
time-evolved system RDM. The impact of the environment is empirically modeled
through the so-called Lindblad ``jump'' operators, $L_j$. Different processes
require different types of jump operators. A couple of examples are demonstrated
here.

\begin{figure}
    \centering
    \includegraphics{data_runs/lindblad.pdf}
    \caption{Simulation of dynamics corresponding to a typical spin-boson parameter.}\label{fig:lindblad_spin_boson}
\end{figure}

For mapping a spin-boson problem onto a system described with the Lindblad
master equation, we obtain a jump operator proportional to $\sigma_z$. The
strength of the system-bath coupling in a spin-boson parameter is related to
this proportionality constant. Consider a system Hamiltonian given by
$\hat{H}_0=-\sigma_x$, and a localized initial condition. The code to simulate
the dynamics using QuantumDynamics.jl is:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
using QuantumDynamics

# define the Hamiltonian, the initial RDM, and the simulation details
H = Matrix{ComplexF64}([
    0.0 -1.0
    -1.0 0.0
])
ρ0 = [1.0+0.0im 0.0; 0.0 0.0]
dt = 0.125
ntimes = 100

# define the Lindbladian jump operator
L = [1.0+0.0im 0.0; 0.0 -1.0]

# call propagate with a list of jump operators to be applied
times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes, L=[L])
\end{minted}
The resultant dynamics is shown in Fig.~\ref{fig:lindblad_spin_boson}. One can
notice the features reminiscent of a typical spin-boson
parameters~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995}. Also note that the only change from
the simulations of the isolated Hermitian and non-Hermitian systems is the
new argument, \verb|L|, containing a vector of jump operators $L_j$ that is
being passed in.

Now, consider a more involved example. We want to model an excitation transport
between a dimer of molecules while accounting for possibility of spontaneous
emission which will bring one molecule to the ground state without exciting the
other. This possibility does not allow for modeling the problem in the so-called
first excitation subspace. In the full Hilbert space, the system Hamiltonian is
taken to be
\begin{align}
    \hat{H}_0 & = 20.0\dyad{ee} + 10.0\dyad{ge} + 10.0\dyad{eg}\nonumber \\
              & - 1.0\dyad{eg}{ge} - 1.0\dyad{ge}{eg}.
\end{align}
The simulation is started from an initial condition of $\dyad{ge}$. For the
effects of the molecular vibrations moving the energies of the excited and the
ground states, we use jump operators proportional to $\sigma_z\otimes\mathbb{I}$
and $\mathbb{I}\otimes\sigma_z$. For capturing the spontaneous decay process, we
introduce jump operators proportional to $\sigma_m\otimes\mathbb{I}$ and
$\mathbb{I}\otimes\sigma_m$. The code for simulating this system is as follows:
\begin{figure}
    \centering
    \subfloat[Dynamics for \texttt{bo}=0.7071 and \texttt{se}=0.0.]{\includegraphics{data_runs/lindblad_spontaneous_emission_0.7071_0.0.pdf}}

    \subfloat[Dynamics for \texttt{bo}=0.7071 and \texttt{se}=0.25.]{\includegraphics{data_runs/lindblad_spontaneous_emission_0.7071_0.25.pdf}}
    \caption{Simulation of dynamics corresponding to an excitation transfer in a dimer with and without spontaneous emission.}\label{fig:excitation_lindblad}
\end{figure}

\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
using QuantumDynamics

# define Hamiltonian, initial RDM and simulation parameters
H = Matrix{ComplexF64}([
    20.0 0.0 0.0 0.0
    0.0 10.0 -1.0 0.0
    0.0 -1.0 10.0 0.0
    0.0 0.0 0.0 0.0
])
ρ0 = Matrix{ComplexF64}([
    0.0 0.0 0.0 0.0
    0.0 1.0 0.0 0.0
    0.0 0.0 0.0 0.0
    0.0 0.0 0.0 0.0
])
dt = 0.125
ntimes = 100

# define the jump operators corresponding to the decohering effects of the individual Born-Oppenheimer surfaces.
# bo is the coupling strength
σz = bo * Matrix{ComplexF64}([
    1.0 0.0
    0.0 -1.0
])
id = Matrix{ComplexF64}([
    1.0 0.0
    0.0 1.0
])
L1 = kron(σz, id)
L2 = kron(id, σz)

# define the jump operators corresponding to spontaneous emission
# se is the coupling strength
σm = se * Matrix{ComplexF64}([
    0.0 0.0
    1.0 0.0
])
L3 = kron(σm, id)
L4 = kron(id, σm)

times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes, L=[L1, L2, L3, L4])
\end{minted}
where the proportionality constants have been given as \verb|bo| and \verb|se|
for the molecular vibrations and the spontaneous emission processes
respectively. Figure~\ref{fig:excitation_lindblad} demonstrates the dynamics
obtained using this code when spontaneous emission is switched off and on. We
see the expected conservation of the number of excitation when spontaneous
emission is turned off, and a gradual build up of population in the ground state
in presence of spontaneous emission.

\subsection{Perturbative \& Non-Perturbative Dynamics of Open Quantum Systems}
While QuantumDynamics.jl supports empirical methods as described in
Sec.~\ref{sec:empirical}, the primary focus is rigorous methods of simulation of
open quantum systems. Now, we turn our attention to the more numerical involved
methods. For these examples, we will specify the detailed characteristics of the
harmonic bath using spectral densities.

\subsubsection{Bloch-Redfield Master Equation}
The Bloch-Redfield master equation~\cite{blochGeneralizedTheoryRelaxation1957,
    redfieldTheoryRelaxationProcesses1957} (BRME) is one of the simplest and most
versatile approaches to perturbatively simulate the dynamics of open quantum
systems. It includes a perturbative description of the system-environment
interaction with the environment being described under the Born approximation.
Finally, an additional approximation of Markovian dynamics is invoked to obtain
BRME. While the combination of approximations involved often makes the method
unsuitable for strongly coupled solvents, it is still useful for understanding
the very rough timescales of dynamics. Combining BRME with ideas of polaron
transform is successful in extending its applicability to strongly coupled
non-perturbative solvents~\cite{silbeyVariationalCalculationDynamics1984,
    xuNoncanonicalDistributionNonequilibrium2016,
    xuPolaronEffectsPerformance2016, jangPartiallyPolarontransformedQuantum2022,
    leeAccuracySecondOrder2012}.

For the system-solvent Hamiltonian, Eq.~\ref{eq:sys_bath}, under the Born
approximation and Markovian limit of the environment, BRME can be expressed as
an equation of motion for the reduced density matrix in the eigen-basis of the
system Hamiltonian, $\hat{H}_0$:
\begin{align}
    \dv{\rho_{ab}}{t} & = -i\omega_{ab}\rho_{ab}(t) + \sum_{cd} R_{abcd}\rho_{cd}(t),
\end{align}
where $R_{abcd}$ is the Redfield tensor that captures the impact of the solvent
on the system in a perturbative manner:
\begin{align}
    R_{abcd} = -\frac{1}{2}\sum_{k=1}^{N_\text{env}} & \left(\delta_{bd}\sum_n \bra{a}\hat{s}_k\dyad{n}\hat{s}_k\ket{c} J_k(\omega_c - \omega_n)\right.\nonumber              \\
                                                     & - \mel{a}{\hat{s}_k}{c}\mel{d}{\hat{s}_k}{b} J_k(\omega_c - \omega_a)\nonumber                                         \\
                                                     & + \delta_{ac}\sum_n \bra{d}\hat{s}_k\dyad{n}\hat{s}_k\ket{b} J_k(\omega_d - \omega_n)\nonumber                         \\
                                                     & - \left.\vphantom{\sum_{k=1}^{N_\text{env}}}\mel{a}{\hat{s}_k}{c}\mel{d}{\hat{s}_k}{b} J_k(\omega_d - \omega_b)\right)
\end{align}

\begin{figure}
    \includegraphics{data_runs/brme_example.pdf}
    \caption{Comparison between BRME simulation and numerically exact QuAPI calculations. Discussion of QuAPI is given later in Sec.~\ref{sec:pi_methods}.}\label{fig:brme}
\end{figure}

A particular example of the results of BRME for a spin-boson system and its
comparison with exact quantum dynamical calculations using QuAPI is shown in
Fig.~\ref{fig:brme}. The code for simulating the BRME equations using
QuantumDynamics.jl for this particular case is as follows:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
using QuantumDynamics

# define the system Hamiltonian
H = Matrix{ComplexF64}([
    0.0 -1.0
    -1.0 0.0
])

# specify the spectral density describing the bath and the inverse temperature
Jw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)
β = 5.0

ρ0 = Matrix{ComplexF64}([
    1.0 0.0
    0.0 0.0
])
dt = 0.25
ntimes = 100
time, ρs = BlochRedfield.propagate(; Hamiltonian=H, Jw=[Jw], β, ρ0, dt, ntimes, sys_ops=[[1.0+0.0im 0.0; 0.0 -1.0]])
\end{minted}

\subsubsection{Hierarchical Equations of Motion}
The hierarchical equations of motion
(HEOM)~\cite{tanimuraTimeEvolutionQuantum1989,
    tanimuraQuantumClassicalFokkerPlanck1991,
    tanimuraReducedHierarchicalEquations2014, tanimuraNumericallyExactApproach2020}
is one of the two foundational numerically exact, non-perturbative methods for
simulating the dynamics of an open quantum system interacting with a harmonic
bath. While originally formulated primarily for the Drude-Lorentz spectral
density, recent work has made it possible to use this method with more general
spectral densities~\cite{duanStudyExtendedHierarchy2017,
    popescuUsingChebychevExpansion2015, tianApplicationHierarchicalEquations2013,
    liuReducedQuantumDynamics2014}. Other developments have improved the numerical
stability of HEOM at lower
temperatures~\cite{dunnRemovingInstabilitiesHierarchical2019}.
QuantumDynamics.jl supports the scaled version of
HEOM~\cite{shiEfficientHierarchicalLiouville2009} for the Drude-Lorentz spectral
density. The more advanced approaches required to handle other spectral
densities will be incorporated in later versions of the package.

The general problem that HEOM solves is Eq.~\ref{eq:sys_bath}. However, for
HEOM, the system-environment interaction Hamiltonian is not exactly
Eq.~\ref{eq:quapi_bath}. It is given by
\begin{align}
    \hat{H}^{(b)}_\text{env} & = \sum_j \frac{p_{jb}^2}{2m_{jb}} + \frac{1}{2}m_{jb}\omega_{jb}^2 x_{jb}^2 - c_{jb} \hat{s}_b x_{jb}
\end{align}
Notice that the difference with Eq.~\ref{eq:quapi_bath} is that here, the square
is not completed. For the implementation of HEOM in QuantumDynamics.jl, the
baths need to be characterized by spectral densities having the Drude-Lorentz
form:
\begin{align}
    J_b(\omega) & = \frac{2 \lambda_b}{\Delta s_b^2} \frac{\gamma_b \omega}{\omega^2 + \gamma_b^2}.
\end{align}
The separation between the system states is $\Delta s_b$. For problems involving
exciton transport, the spectral density is specified using $\Delta s_b = 1$. For
application of HEOM, the correlation functions corresponding to the spectral
densities are written in a sum over poles
form~\cite{shiEfficientHierarchicalLiouville2009},
\begin{align}
    C_b(t) & = \sum_{m=0}^\infty c_{bm} \exp(-\nu_{bm}t),
\end{align}
where $\nu_{b0} = \gamma_b$ is the Drude decay constant and $\nu_{bm\ge 1} =
    2m\pi/\beta$ are the Matsubara frequencies. The coefficients $c_{bm}$ are given
by
\begin{align}
    c_{b0}      & = \gamma_b \frac{\lambda_b}{\Delta s_b^2} \left(\cot\left(\frac{\beta\hbar\gamma_b}{2}\right)-i\right), \\
    c_{bm\ge 1} & = \frac{4\lambda_b\gamma_b}{\beta\hbar\Delta s_b^2}\left(\frac{\nu_{bm}}{\nu_{bm}^2-\gamma_b^2}\right).
\end{align}

For such a system, the primary expression for HEOM is given as:
\begin{align}
    \dv{\rho_\mathbf{n}}{t} & = -\frac{i}{\hbar}\commutator{\hat{H}_0}{\rho_\mathbf{n}} + \sum_{b=1}^{N_\text{env}}\sum_{m=0}^M n_{bm}\nu_{bm}\rho_\mathbf{n}\nonumber                                                              \\
                            & - \sum_{b=1}^{N_\text{env}} \left( \frac{2\lambda_b}{\beta\hbar^2\gamma_b} - \sum_{m=0}^M\frac{c_{bm}}{\hbar\nu_{bm}} \right)\commutator{\hat{s}_b}{\commutator{\hat{s}_b}{\rho_\mathbf{n}}}\nonumber \\
                            & - i\sum_{b=1}^{N_\text{env}} \commutator{\hat{s}_b}{\sum_{m=0}^M \rho_{\mathbf{n}_{bm}^+}}\nonumber                                                                                                   \\
                            & - \frac{i}{\hbar}\sum_{b=1}^{N_\text{env}}\sum_{m=0}^M n_{bm}\left(c_{bm}\hat{s}_b\rho_{\mathbf{n}_{bm}^-} - c_{bm}^* \rho_{\mathbf{n}_{bm}^-}\hat{s}_b\right),\label{eq:heom}
\end{align}
where $\rho_\mathbf{n}$ represents the generalized density operators ---
when $\mathbf{n}=0,0,0,\ldots$, it is the reduced density operator, for all other
$\mathbf{n}$, it is an auxiliary density operator. The subscript vectors,
$\mathbf{n}$ are of length $N_\text{env} K (M+1)$, where $K$ is the depth of the
hierarchy. Each density matrix is assigned a depth of $L =
    \sum_{b=1}^{N_\text{env}}\sum_{m=0}^M n_{bm}$. The term in the second line
of Eq.~\ref{eq:heom} is the correction term is the Ishizaki-Tanimura scheme
of truncating the truncating the Matsubara terms by treating $m>M$ using a
Markovian approximation~\cite{ishizakiQuantumDynamicsSystem2005,
    tanimuraStochasticLiouvilleLangevin2006}.

The scaled version of HEOM~\cite{shiEfficientHierarchicalLiouville2009} rescales
the auxiliary density operators in a manner that allows truncation of the
hierarchy at a lower value of $K$.
\begin{align}
    \tilde\rho_\mathbf{n} & = \left(\prod_b\prod_m n_{bm}! |c_{bm}|^{n_{bm}}\right)^{-\frac{1}{2}}\rho_\mathbf{n},
\end{align}
which changes Eq.~\ref{eq:heom} to:
\begin{align}
    \dv{\tilde\rho_\mathbf{n}}{t} & = -\frac{i}{\hbar}\commutator{\hat{H}_0}{\tilde\rho_\mathbf{n}} + \sum_{b=1}^{N_\text{env}}\sum_{m=0}^M n_{bm}\nu_{bm}\tilde\rho_\mathbf{n}\nonumber                                                                      \\
                                  & - \sum_{b=1}^{N_\text{env}} \left( \frac{2\lambda_b}{\beta\hbar^2\gamma_b} - \sum_{m=0}^M\frac{c_{bm}}{\hbar\nu_{bm}} \right)\commutator{\hat{s}_b}{\commutator{\hat{s}_b}{\tilde\rho_\mathbf{n}}}\nonumber               \\
                                  & - i\sum_{b=1}^{N_\text{env}} \commutator{\hat{s}_b}{\sum_{m=0}^M \sqrt{(n_{bm}+1)|c_{bm}|}\tilde\rho_{\mathbf{n}_{bm}^+}}\nonumber                                                                                        \\
                                  & - \frac{i}{\hbar}\sum_{b=1}^{N_\text{env}}\sum_{m=0}^M \sqrt{\frac{n_{bm}}{|c_{bm}|}}\left(c_{bm}\hat{s}_b\tilde\rho_{\mathbf{n}_{bm}^-} - c_{bm}^* \tilde\rho_{\mathbf{n}_{bm}^-}\hat{s}_b\right).\label{eq:scaled_heom}
\end{align}
In this new version, Eq.~\ref{eq:scaled_heom}, the number of levels of hierarchy
required for convergence decreases significantly in comparison to the original
unscaled HEOM, Eq.~\ref{eq:heom}. This is the version that is used by default in
QuantumDynamics.jl. To use the unscaled version of HEOM, one needs to set
\verb|scaled| to \verb|false| while calling the \verb|HEOM.propagate| function.

\begin{figure}
    \centering
    \subfloat[$T=\SI{77}{\kelvin}$]{\includegraphics{data_runs/heom_fmo_4100.95_2_3.pdf}}

    \subfloat[$T=\SI{300}{\kelvin}$]{\includegraphics{data_runs/heom_fmo_1052.58_2_3.pdf}}
    \caption{Excitation population dynamics in the 7-state FMO model introduced by~\citet{ishizakiTheoreticalExaminationQuantum2009}.}\label{fig:ishizaki_fleming_heom}
\end{figure}

As a demonstration of the HEOM module in the code, we simulate the dynamics of
the chromophoric excitation in the famous 7-state model for the
Fenna-Matthews-Olson (FMO) complex~\cite{adolphsHowProteinsTrigger2006,
    ishizakiTheoreticalExaminationQuantum2009} at $T=\SIlist{77; 300}{\kelvin}$.
The code snippet for this part is quite self-explanatory:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
using QuantumDynamics

# unit conversion
invcm2au = 4.55633e-6
au2fs = 0.02418884254

function FMO(num_modes, Lmax, β)
    # set up the system Hamiltonian
    H = Matrix{ComplexF64}([
        12410 -87.7   5.5  -5.9   6.7 -13.7  -9.9
        -87.7 12530  30.8   8.2   0.7  11.8   4.3
            5.5  30.8 12210 -53.5  -2.2  -9.6   6.0
            -5.9   8.2 -53.5 12320 -70.7 -17.0 -63.3
            6.7   0.7  -2.2 -70.7 12480  81.1  -1.3
        -13.7  11.8  -9.6 -17.0  81.1 12630  39.7
        -9.9    4.3   6.0 -63.3  -1.3  39.7 12440
    ]) * invcm2au
    nsteps = 500                  # number of steps of simulations
    dt = 1000 / au2fs / nsteps    # dt for simulation

    # initial density matrix with excitation localized on BChl unit 1
    ρ0 = Matrix{ComplexF64}(zeros(7, 7))
    ρ0[1, 1] = 1

    # create spectral densities on each of the BChl sites
    λs = [35.0, 35.0, 35.0, 35.0, 35.0, 35.0, 35.0] * invcm2au
    γs = 1 ./ ([50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0] / au2fs)
    Jw = Vector{SpectralDensities.DrudeLorentz}()
    sys_ops = Vector{Matrix{ComplexF64}}()
    for (j, (λ, γ)) in enumerate(zip(λs, γs))
        push!(Jw, SpectralDensities.DrudeLorentz(; λ, γ, Δs=1.0))
        op = zeros(7, 7)
        op[j, j] = 1.0
        push!(sys_ops, op)
    end

    # simulate the time evolution of ρ0 using HEOM
    t, ρ = HEOM.propagate(; Hamiltonian=H, ρ0=ρ0, Jw, β, ntimes=nsteps, dt, sys_ops, num_modes, Lmax)
    t .*= au2fs
    t, ρ
end
\end{minted}
Here, we use the \verb|propagate| function under the \verb|HEOM| submodule. It
takes a list of spectral densities, \verb|Jw|, along with the corresponding
system operators that couple to a particular bath, \verb|sys_ops|. The number
of Matsubara modes that are required to converge the results is \verb|num_modes|
and \verb|Lmax| is the number of auxiliary density operators considered in the
calculation. At both temperatures, well converged results were obtained with
\verb|num_modes| $=2$ and \verb|Lmax| $=3$. The dynamics obtained using this
code is shown in Fig.~\ref{fig:ishizaki_fleming_heom} which matches the original
results reported by~\citet{ishizakiTheoreticalExaminationQuantum2009}.

As a final example of HEOM, let us consider the case of spontaneous emission
that was modelled empirically using Lindblad Master Equation,
Fig.~\ref{fig:excitation_lindblad}, in Sec.~\ref{sec:lindblad}. Spontaneous
emission happens because of the presence of an environment or bath that is able
to couple the molecular excited state to the molecular ground state, thereby
reducing the excited state lifetime to some finite value. Once again, the ground
and excited states will include the corresponding vibrations and the changes in
energy that they bring about. The resultant dynamics is shown in
Fig.~\ref{fig:spontaneous_emission_HEOM}. The bath which enables a spontaneous
excitation or relaxation of the molecular eigenstate is acts through the system
$\hat\sigma_x$ operator, whereas the baths representing the vibrational motion
on the Born-Oppenheimer surfaces act through $\hat\sigma_z$. HEOM is able to
handle both a ``diagonal'' and an ``off-diagonal'' bath on the same footing
without an increase in computational complexity.
\begin{figure}
    \includegraphics{data_runs/heom_0.25_0.1_0.5_3_2.pdf}
    \caption{Dynamics of an excitonic dimer with multiple non-commuting baths.}\label{fig:spontaneous_emission_HEOM}
\end{figure}

\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
# define Hamiltonian, initial RDM and simulation parameters
H = Matrix{ComplexF64}([
    20.0 0.0 0.0 0.0
    0.0 10.0 -1.0 0.0
    0.0 -1.0 10.0 0.0
    0.0 0.0 0.0 0.0
])
ρ0 = Matrix{ComplexF64}([
    0.0 0.0 0.0 0.0
    0.0 1.0 0.0 0.0
    0.0 0.0 0.0 0.0
    0.0 0.0 0.0 0.0
])
dt = 0.125
ntimes = 100

# define the spectral density for the vibrational bath
Jw = Vector{SpectralDensities.DrudeLorentz}()
svec = Vector{Matrix{ComplexF64}}()
σz = Matrix{ComplexF64}([
    1.0 0.0
    0.0 -1.0
])
id = Matrix{ComplexF64}([
    1.0 0.0
    0.0 1.0
])
jw1 = SpectralDensities.DrudeLorentz(; λ=bo, γ=5.0, Δs=1.0)
bo1 = kron(σz, id)
bo2 = kron(id, σz)

# define the bath that cause a change in the excitation state of a monomer
σx = Matrix{ComplexF64}([
    0.0 1.0
    1.0 0.0
])
jw3 = SpectralDensities.DrudeLorentz(; λ=se, γ=5.0, Δs=1.0)
se3 = kron(σx, id) + kron(id, σx)

times, ρs = HEOM.propagate(; Hamiltonian=H, ρ0=ρ0, Jw=[jw1, jw1, jw3], β, ntimes, dt, sys_ops=[bo1, bo2, se3], num_modes, Lmax)
\end{minted}

\subsubsection{Path Integral Methods}\label{sec:pi_methods}
Path integral approaches form the other numerically exact family of
computational methods for simulating the dynamics of open quantum systems as
described by Eqs.~\ref{eq:sys_bath} and~\ref{eq:quapi_bath}. Since the original
papers~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995, makriNumericalPathIntegral1995}
significant developments~\cite{makriBlipDecompositionPath2014,
    makriIterativeBlipsummedPath2017, strathearnEfficientNonMarkovianQuantum2018,
    makriSmallMatrixPath2020, makriSmallMatrixDisentanglement2020,
    makriSmallMatrixModular2021, makriSmallMatrixPath2021,
    makriSmallMatrixPath2021a, boseTensorNetworkRepresentation2021,
    boseMultisiteDecompositionTensor2022, bosePairwiseConnectedTensor2022} have
led to the proliferation of methods based on the foundations of path
integrals with Feynman-Vernon influence
functional~\cite{feynmanTheoryGeneralQuantum1963}.

Starting from an initial state given as a direct product of the system reduced
density matrix and the thermal distribution of the environment, the dynamics of
the system after $N$ time-steps can be expressed as a path integral,
\begin{widetext}
    \begin{align}
        \mel{s_N^+}{\rho(N\Delta t)}{s_N^-} & = \sum_{s_0^\pm}\sum_{s_1^\pm}\ldots\sum_{s_{N-1}^\pm} \bra{s_N^+}\hat{U}\dyad{s_{N-1}^+}\hat{U}\ket{s_{N-2}^+}\ldots\nonumber                     \\
                                            & \times\bra{s_1^+}\hat{U}\dyad{s_0^+}\rho(0)\dyad{s_0^-}\hat{U}^\dag\ket{s_1^-}\ldots\bra{s_{N-1}^-}\hat{U}\ket{s_N^-} F[\{s^\pm_j\}] \label{eq:pi} \\
        \text{where }F[\{s^\pm_j\}]         & = \exp\left(-\frac{1}{\hbar}\sum_{k=0}^{N}(s_k^+-s_k^-)\sum_{k'=0}^{k}(\eta_{kk'}s_{k'}^+ - \eta^*_{kk'}s_{k'}^-)\right).\label{eq:fvif}
    \end{align}
\end{widetext}
Here, $\hat{U}$ is the bare system propagator, and $F$ is the Feynman-Vernon
influence functional corresponding to the forward-backward path $s^\pm_j$. The
influence functional for a system coupled to multiple environments is given as a
product of the influence functionals corresponding to the individual
environments. The cost of simulations do not increase as long as all the
operators that the environments couple to commute with each other. The bath
response function is discretized into
$\eta$-coefficients~\cite{makriTensorPropagatorIterativeI1995}. The
non-Markovian nature of the dynamics is brought in by the dependence of the
influence functional on the full path of the system. However, in condensed
phases, the memory decays away with the time difference of the interacting
points. Thus, after a full-memory simulation of $L$ time steps, which is a
convergence parameter, one can use an iterative algorithm to propagate the
reduced density matrix further out in time. The summand of the right-hand side
of Eq.~\ref{eq:pi} can be thought of as a tensor indexed by the forward-backward
system paths called the path amplitude tensor.

Various approaches have been used to reduce the computational complexity of the
problem which na\"ively grows as $\mathcal{O}(d^{2L})$ where $d$ is the system
dimensionality and $L$ is the memory length. This is the original QuAPI algorithm.
Other approaches attempt to decrease this exponentially growing computational
and storage requirements. The blip
decomposition~\cite{makriBlipDecompositionPath2014,
    makriIterativeBlipsummedPath2017} of path integral uses the fact that the
influence functional, Eq.~\ref{eq:fvif}, depends on the value of $\Delta s = s^+
    - s^-$ for the latter point. That means that for all the paths with no
time-point where $\Delta s = 0$ the influence functional is one.  Thus this set
of paths can be summed up in a Markovian manner. In fact, any segment of path
that consists solely of points with $\Delta s = 0$, or ``sojourns'', can be
summed up through iterative matrix-vector multiplications thereby reducing the
effective number of paths that need to be considered.

Recently tensor networks have been used in a variety of ways to reduce the
complexity of these path integral calculations. Most prominent of these is the
time-evolved matrix product operators
approach~\cite{strathearnEfficientNonMarkovianQuantum2018} (TEMPO) which uses a
matrix product state to give a compact represent the path amplitude tensor
utilizing the decaying correlation between indices with large separation. Under
the tensor network path integral~\cite{boseTensorNetworkRepresentation2021}
(TNPI) implementation of the TEMPO algorithm, it has been shown that the
influence functional for multiple baths can be analytically represented in the
form of an optimal matrix product operator. Additionally, PC-TNPI is a new
tensor network that has been designed to manifestly capture the symmetries
present in the influence functional~\cite{bosePairwiseConnectedTensor2022}.

There are four basic modules of path integral simulations that are supported ---
\verb|QuAPI| implementing ideas in
Refs.~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995}, \verb|Blip| implementing
Ref.~\cite{makriBlipDecompositionPath2014}, \verb|TEMPO| implemeting
Ref.~\cite{strathearnEfficientNonMarkovianQuantum2018}, and \verb|PCTNPI|
implementing Ref.~\cite{bosePairwiseConnectedTensor2022}. In principle iterative
propagation of reduced density matrices beyond the memory time is possible in
all of these methods, however based on our experience, of these methods TEMPO
gives the greatest ability to access long memory lengths and large systems. Thus
iterative propagation is implemented only in \verb|TEMPO| and in base
\verb|QuAPI|. All the modules support creation of augmented propagators which
are the effective propagators of the system in presence of the solvent.

First, we demonstrate the QuantumDynamics.jl code both for the most fundamental
path integral method, QuAPI~\cite{makriTensorPropagatorIterativeI1995,
    makriTensorPropagatorIterativeII1995} and for
TEMPO~\cite{strathearnEfficientNonMarkovianQuantum2018}. Consider the symmetric
system, $\hat{H}_0=-\hbar\Omega\sigma_x$ coupled with a bath of harmonic
oscillators characterized by an Ohmic spectral density where $\xi$ is the
dimensionless Kondo parameter and $\omega_c$ is the cutoff frequency. The
simulation with any of the methods will have the following outline:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
# define the system Hamiltonian
H = Matrix{ComplexF64}([
    0.0 -1.0
    -1.0 0.0
])

# calculate the sequence of bare propagators with a given time-step
barefbU = Propagators.calculate_bare_propagators(; Hamiltonian=H, dt, ntimes)

# define the initial condition and the spectral density
ρ0 = [1.0+0.0im 0.0; 0.0 0.0]
Jw = SpectralDensities.ExponentialCutoff(; ξ, ωc)

# use a given method to propagate the initial state in presence of the environment at an inverse temperature, β.
# method is one of QuAPI.propagate or TEMPO.propagate
t, ρs = method(; fbU=barefbU, Jw=[Jw], β, ρ0, dt, ntimes, L, svec)
\end{minted}
\verb|method| is currently one of \verb|QuAPI.propagate| or
\verb|TEMPO.propagate|. These propagate methods take custom extra arguments
which specify how to tune the algorithms in specific ways to improve the
performance.

\begin{figure}
    \subfloat[$\xi=0.1$, $\omega_c=7.5\Omega$, $\hbar\Omega\beta=5$, $L=6$, $\Delta t=0.25$. Parameters from Ref.~\cite{makriTensorPropagatorIterativeI1995}. Run with \texttt{method}=\texttt{QuAPI.propagate}.]{\includegraphics{data_runs/quapi_5_0.1_7.5_0.25_6.pdf}}\label{fig:quapi_eg}

    \subfloat[$\xi=2.0$, $\omega_c=\Omega$, $\hbar\Omega\beta=1$, $L=150$, $\Delta t = 0.125$. Parameters from Ref.~\cite{makriSmallMatrixPath2021, waltersIterativeQuantumclassicalPath2016}. Run with \texttt{method}=\texttt{TEMPO.propagate}.]{\includegraphics{data_runs/tempo_1_2.0_1.0_0.125_150.pdf}}\label{fig:tempo_eg}
    \caption{Example of dynamics using QuAPI-related methods simulated using QuantumDynamics.jl.}\label{fig:pi_eg1}
\end{figure}
As an illustration, we demonstrate two different parameters using base QuAPI
(Fig.~\ref{fig:pi_eg1}~(a)) and using TEMPO (Fig.~\ref{fig:pi_eg1}~(b)). For the
example simulated using QuAPI, we use a parameter that was introduced in
Ref.~\cite{makriTensorPropagatorIterativeI1995}. For the example that we
simulated using TEMPO, we chose a parameter that was originally simulated using
quantum-classical path integral up to a short
time~\cite{waltersIterativeQuantumclassicalPath2016} and more recently using
SMatPI till equilibration~\cite{makriSmallMatrixPath2021}. For this case, the
bath is localized around the initial system state.

\begin{figure}
    \hspace{-1.2cm}
    \subfloat[$\lambda=\SI{20}{\per\cm}$]{\includegraphics{data_runs/ishizaki_fleming_dimer_20_1052.0_200.0_75.pdf}}
    ~\subfloat[$\lambda=\SI{100}{\per\cm}$]{\includegraphics{data_runs/ishizaki_fleming_dimer_100_1052.0_200.0_75.pdf}}
    \caption{Simulation of a excitation energy transfer dimer with parameters obtained from Ref.~\cite{ishizakiUnifiedTreatmentQuantum2009}. $\epsilon=\SI{100}{\per\cm}$, $\Omega=\SI{-100}{\per\cm}$.}\label{fig:ishizaki_fleming_dimer}
\end{figure}

For problems where the iterative portion of the dynamics is significantly longer
than the full-memory portion, the cost of the iteration, which is proportional
to the number of paths, adds up. One way of solving this is to use
TTM~\cite{cerrilloNonMarkovianDynamicalMaps2014} to reduce the cost to a
``convolution'' of these transfer tensors and the augmented propagators. TTM
uses the other base path integral methods to generate the propagators for some
number of time-steps and then uses them calculate the propagators further out in
time. We demonstrate the use of TTM using the strongly excitation energy
transfer (EET) dimer from Ref.~\cite{ishizakiUnifiedTreatmentQuantum2009}. The
structure of a code using TTM is shown below:
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
# define the EET dimer Hamiltonian
H = Matrix{ComplexF64}([
    50 100.0
    100.0 -50
] .* invcm2au)
# using a time-step, dt, calculate the bare forward-backward propagators for ntimes time-steps
fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H, ntimes, dt)

# define the spectral densities acting on the different monomers
J1 = SpectralDensities.DrudeLorentz(; λ=λ * invcm2au, γ=γ * invcm2au, Δs=1.0)
J2 = SpectralDensities.DrudeLorentz(; λ=λ * invcm2au, γ=γ * invcm2au, Δs=1.0)
svec = [1.0 0.0; 0.0 1.0]
β = 1052.0

ρ0 = [1.0+0.0im 0.0; 0.0 0.0]
# TTM.propagate takes a particular path_integral_routine and the corresponding extraargs.
times, ρs = TTM.propagate(; fbU=fbU, ρ0=ρ0, Jw=[J1, J2], β, ntimes, dt, svec, rmax=rmax, extraargs=TEMPO.TEMPOArgs(; cutoff=1e-13, maxdim=10000), path_integral_routine = TEMPO.build_augmented_propagator, verbose=true)
\end{minted}
These calculations were done with full memory simulations of 75 steps with a
time-step of $\Delta t=\SI{4.84}{\fs}$. The spectral density used is the
Drude-Lorentz spectral density, Eq.~\ref{eq:drudelorentz}, with $\gamma =
    \SI{53.08}{\per\cm}$. The results are shown for two different reorganization
energies, $\lambda$, are shown in Fig.~\ref{fig:ishizaki_fleming_dimer}.

Finally, the last major method supported by QuantumDynamics.jl is
QCPI~\cite{lambertQuantumclassicalPathIntegralI2012,
    lambertQuantumclassicalPathIntegralII2012} with reference
propagators~\cite{banerjeeQuantumClassicalPathIntegral2013} and harmonic
backreaction~\cite{wangQuantumclassicalPathIntegral2019}. The incorporation of
classical trajectories not only allows for larger time-steps but also reduces
the effective memory that needs to be accounted for through path integrals by
incorporating the classical part of the memory
completely~\cite{banerjeeQuantumClassicalPathIntegral2013}. A simulation that
only incorporates the classical part of the memory is called the ensemble
average classical path (EACP) simulation. With reference propagators one can do
this simulation in a Markovian manner. Currently the support is only for a
harmonic bath though the infrastructure is built in such a manner that it is
trivial to extend it to include anharmonic solvents in the reference propagators
either by solving the equations of motion using
DifferentialEquations.jl~\cite{rackauckasDifferentialequationsJlPerformant2017},
or couple it with a molecular dynamics frameworks like
\href{https://github.com/JuliaMolSim/Molly.jl}{Molly.jl} and the Atomic
Simulation Engine~\cite{hjorthlarsenAtomicSimulationEnvironment2017} (ASE). Due
to the modular nature of QuantumDynamics.jl, these different classical
trajectory backends will work in a plug-and-play manner.

Below is a code snippet which does both the EACP calculation and a full QCPI
calculation on a sample spin-boson parameter.
\begin{minted}[breaklines, fontsize=\footnotesize, framesep=2mm, frame=lines]{julia}
# specify the system Hamiltonian
H0 = Matrix{ComplexF64}([
    1.0 -1.0
    -1.0 -1.0
])

# specify the spectral density and the inverse temperature
Jw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)
β = 5.0

ρ0 = Matrix{ComplexF64}([
    1.0 0.0
    0.0 0.0
])

dt = 0.25
ntimes = 100

# discretize the spectral density and create a harmonic bath solvent
# for an atomistic solvent, here we would use the actual description based on an appropriate force field or ab initio DFT calculation
ω, c = SpectralDensities.discretize(Jw, 100)
hb = Solvents.HarmonicBath(β, ω, c, [1.0, -1.0], num_points)

# calculate EACP dynamics
EACP_fbU = Propagators.calculate_average_reference_propagators(; Hamiltonian=H0, solvent=hb, classical_dt=dt / 100, dt, ntimes)
times_EACP, ρs_EACP = Utilities.apply_propagator(; propagators=EACP_fbU, ρ0, ntimes, dt)

# simulate QCPI
times_QCPI, ρs_QCPI = QCPI.propagate(; Hamiltonian=H0, Jw, solvent=hb, ρ0, classical_dt=dt / 100, dt, ntimes, kmax=3, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.propagate)
\end{minted}
QuantumDynamics.jl does not enforce any parallelization over the Monte Carlo
runs or binning and calculation of error statistics. That is left to the end
user to implement in a manner suited to the problem being studied. It will be quite
simple to spread \verb|QCPI.propagate| calls over multiple nodes and aggregate
across them using message-passing interface. The dynamics obtained with 10000
initial conditions is demonstrated in Fig.~\ref{fig:qcpi}.
\begin{figure}
    \includegraphics{data_runs/qcpi_10000.pdf}
    \caption{Comparison between QuAPI and QCPI runs for the parameters shown in the code. 10000 initial conditions were used for the EACP and QCPI calculations.}\label{fig:qcpi}
\end{figure}

\section{Conclusion}\label{sec:conclusions}
In this paper, we have introduced a new package called QuantumDynamics.jl for
simulations of non-adiabatic processes using the Feynman-Vernon influence
functional~\cite{feynmanTheoryGeneralQuantum1963}. The Julia programming
language has been emerging as a promising candidate for modern high-level
high-performance scientific computing, with a growing base of packages for
computational chemistry and physics. Being written in Julia, allows
QuantumDynamics.jl to take advantage of packages like DifferentialEquations.jl
for solving differential equations. This also allows us to avoid the
``two-language'' problem where the performance critical parts need to be
implemented in some lower-level high-performance language.

Simulating the dynamics of quantum systems interacting with environments is
often very difficult if done in a numerically exact manner. The exact methods
are quite involved from a theoretical perspective while being challenging to
implement in code. They are built on top of a variety of deep insights into the
structure of dynamics in these systems. Very few open-source packages exist that
aim to make these methods accessible to non-specialists while providing for a
platform to the specialists that encourages explorations and further theoretical
development. Inspired by the objectives behind
PySCF~\cite{sunPySCFPythonbasedSimulations2018}, QuantumDynamics.jl was designed
to address this particular problem. It joins the recently growing ranks of
computational packages for chemistry in the Julia programming
language~\cite{aroeiraFermiJlModern2022, gardnerNQCDynamicsJlJulia2022,
    herbstDFTKJulianApproach2021}.

QuantumDynamics.jl already supports a variety of methods. On the empirical and
perturbative end, methods like propagation of non-Hermitian Hamiltonians,
Lindblad master equation, and the perturbative Bloch-Redfield master equation
are all built on top of the backend provided DifferentialEquations.jl. BRME can
later be extended using polaron and variational polaron transformed approaches
to increase the applicability of the perturbative ideas. In terms of numerically
exact approaches, both HEOM-based and QuAPI-based methods are supported. In
HEOM, we have already implemented the unscaled and scaled version. Use of matrix
product states and other approaches of generalizing it to account for
non-Drude-Lorentz spectral densities will be implemented in the near future.

The largest set of methods implemented in QuantumDynamics.jl fall in the
category of path integral- or QuAPI-based approaches. The base methods of QuAPI,
blip decomposition, TEMPO, and PC-TNPI are all supported. QuAPI and TEMPO
support propagation of density matrices, while blips and PC-TNPI are currently
only capable of producing augmented forward-backward propagators. While this
does not hamper the usability of these methods in conjunction with TTM, this
deficiency will be remedied in a future version. Probably the single most useful
sub-module of the path integral methods is TEMPO. Given its ability to handle
comparatively large systems with long memories makes it exceptionally powerful.
The TNPI-based implementation allows use of multiple baths in an optimal
manner. The compatibility of all of these methods with TTM is a very useful
feature of QuantumDynamics.jl.

The goal is to provide the community with a platform that is fit for exploration
and method development in addition to a repository of methods that can directly
be used for accurate simulations of quantum dynamics. There are many other
developments that are yet to be incorporated in QuantumDynamics.jl. A notable
example is the recently developed multisite decomposition of the tensor network
path integral~\cite{boseMultisiteDecompositionTensor2022} (MS-TNPI), which
combines ideas from time-dependent density matrix renormalization
group~\cite{whiteRealTimeEvolutionUsing2004,
    schollwockDensitymatrixRenormalizationGroup2005,
    schollwockDensitymatrixRenormalizationGroup2011,
    schollwockDensitymatrixRenormalizationGroup2011a,
    paeckelTimeevolutionMethodsMatrixproduct2019} with the Feynman-Vernon influence
functional in order to make simulations of extended open quantum systems
feasible~\cite{boseEffectTemperatureGradient2022, boseTensorNetworkPath2022}.
While we will introduce some methods like
MS-TNPI~\cite{boseMultisiteDecompositionTensor2022} in the near future and
continue to develop into this package, we hope that QuantumDynamics.jl becomes a
toolbox for the community with others actively using and developing it as well.

% \appendix
% \section{A QuAPI-inspired Extension of the Transfer Tensor Method}\label{sec:app_TTM}
% It has recently been shown that dynamical maps can be used to understand
% non-Markovian dynamics~\cite{cerrilloNonMarkovianDynamicalMaps2014}. These
% ideas enable the use of information contained in the initial stages of
% time-evolution of a system to predict the dynamics at a later stage. Starting
% from the $t=0$ to $t=k\Delta t$ forward-backward propagator,
% $\mathcal{E}(k\Delta t, 0)$, \citet{cerrilloNonMarkovianDynamicalMaps2014}
% showed that it is possible to define transfer tensors, $T_{n,m}$, that as
% follows:
% \begin{align}
%     T_{n,0}                      & = \mathcal{E}(n\Delta t, 0) - \sum_{m=1}^{n-1} T_{n,m} \mathcal{E}(m\Delta t, 0)\label{eq:TTM} \\
%     \text{where }\rho(k\Delta t) & = \mathcal{E}(k\Delta t, 0)\rho(0).
% \end{align}
% Using these transfer tensors, $T_{n,m}$, the time-evolved density matrices were
% expressed as
% \begin{align}
%     \rho(n\Delta t) & = \sum_{k=0}^{n-1} T_{n,k} \rho(k\Delta t),
% \end{align}
% and consequently,
% \begin{align}
%     \mathcal{E}(n\Delta t) & = \sum_{k=0}^{n-1} T_{n,k}\mathcal{E}(k\Delta t).
% \end{align}
% While this formulation is general,~\citet{cerrilloNonMarkovianDynamicalMaps2014}
% showed that if one assumes time-translational invariance of the $T$ tensors,
% $T_{n,m} = T_{n-m}$, the algorithm can be significantly simplified. They have
% also demonstrated that when the initial condition is in the form of a direct
% product between the system and the environment, these time-translationally
% invariant transfer tensors are related to the memory kernel used in the
% Nakajima-Zwanzig Master Equation
% framework~\cite{nakajimaQuantumTheoryTransport1958,
%     zwanzigEnsembleMethodTheory1960}. \citet{makriSmallMatrixPath2020} has discussed
% that this assumption of time-translational invariance makes the method
% incompatible with QuAPI leading to a build up of spurious memory.
% SMatPI~\cite{makriSmallMatrixPath2020, makriSmallMatrixPath2021,
%     makriSmallMatrixPath2021a} overcomes this problem through a direct derivation
% based on path integral and the QuAPI influence functionals. QuantumDynamics.jl
% implements this ``standard'' TTM through the use of QuAPI-based augmented
% propagators as $\mathcal{E}(n\Delta t, 0)$. The assumption is that since in this
% implementation the propagators, $\mathcal{E}(n\Delta t, 0)$, are calculated
% using QuAPI and related methods, the build-up of spurious memory is minimized.
% 
% In addition to the standard TTM method that assumes the time-translational
% invariance of the transfer tensors, QuantumDynamics.jl also implements a variant
% based on the more general formulation, Eq.~\ref{eq:TTM}, which is able to
% capture the particular symmetries necessitated by QuAPI. Here, we summarize this
% particular extension. We start by discussing the modified time-translational
% invariance observed in QuAPI. While the bare forward-backward propagators are
% invariant, the influence functionals are determined by the so-called
% $\eta$-coefficients, which come in five different
% forms~\cite{makriTensorPropagatorIterativeI1995,
%     makriTensorPropagatorIterativeII1995, makriNumericalPathIntegral1995}:
% \begin{itemize}[noitemsep, nolistsep]
%     \item Two variants of the diagonal terms which connect a time-point with itself --- one for the terminal points, and one for any intermediate pooint
%     \item Connections between two intermediate points
%     \item Connections between a terminal point and an intermediate point
%     \item Connections between two terminal points
% \end{itemize}
% Consolidating these different types of coefficients, one can classify the
% resultant ``augmented'' forward-backward system propagators depending on the
% types of the end-points that they connect --- a start-to-end propagator,
% $\mathcal{E}_{0e}$, a start-to-mid propagator, $\mathcal{E}_{0m}$, a mid-to-end
% propagator, $\mathcal{E}_{em}$, and a mid-to-mid propagator, $\mathcal{E}_{mn}$.
% Within each type of propagator, there is time-translational invariance. This
% ``modified'' invariance has been discussed in depth
% by~\citet{makriSmallMatrixPath2021}.
% 
% Now, we can revisit the general equation, Eq.~\ref{eq:TTM}, and try to rewrite
% it in terms of these different propagators. Notice that the left hand side of
% Eq.~\ref{eq:TTM} gives the start-to-end transfer tensor. However on the right
% hand side, the transfer tensor is of the mid-to-end type. Putting this insight
% together,
% \begin{align}
%     T_{n-m}^{0e} & = \mathcal{E}_{0e}(n\Delta t, 0) - \sum_{m=1}^{n-1}T_{n-m}^{me} \mathcal{E}_{0m}(m\Delta t, 0).
% \end{align}
% It is dependent on the mid-to-end transfer tensor, whose equation now can be
% derived. Thus, as a closure to the set of equations, we obtain:
% \begin{align}
%     T_{n-m}^{me} & = \mathcal{E}_{me}(n\Delta t, 0) - \sum_{m=1}^{n-1}T_{n-m}^{me} \mathcal{E}_{mn}(m\Delta t, 0),\label{eq:tt_me} \\
%     T_{n-m}^{mn} & = \mathcal{E}_{mn}(n\Delta t, 0) - \sum_{m=1}^{n-1}T_{n-m}^{mn} \mathcal{E}_{mn}(m\Delta t, 0)\label{eq:tt_mn}.
% \end{align}
% Thus, after simulating the full path integral simulations for $r_\text{max}$
% time-steps, the propagator for an arbitrary time-step, $t = N\Delta t$ for
% $N>r_\text{max}$, can be written as
% \begin{align}
%     \mathcal{E}_{0e}(N\Delta t, 0) & = \sum_{j=1}^{r_\text{max}} T^{me}_j \mathcal{E}_{0m}((N-j)\Delta t, 0), \\
%     \mathcal{E}_{0m}(N\Delta t, 0) & = \sum_{j=1}^{r_\text{max}} T^{mn}_j \mathcal{E}_{0m}((N-j)\Delta t, 0),
% \end{align}
% where the transfer tensors, Eqs.~\ref{eq:tt_me} and~\ref{eq:tt_mn}, have been
% computed for the $r_\text{max}$ steps.
% 
% Both this extended and the standard TTM are implemented in the TTM package. The
% standard version assuming time-translational invariance of the transfer tensors
% is the default. The extended version can be switched on by passing the keyword
% argument \verb|QuAPI=true| to the \verb|TTM.propagate| function. The other path
% integral submodules, viz. \verb|QuAPI|, \verb|Blip|, \verb|TEMPO|,
% \verb|PCTNPI|, etc. are responsible for generating the augmented
% forward-backward propagators. The relevant function is
% \verb|build_augmented_propagator|. Currently, only the \verb|QuAPI| and
% \verb|Blip| modules are able to generate all the varieties of augmented
% propagators required for the extended TTM by calling the function
% \verb|build_augmented_propagator_QuAPI_TTM|. In the present version of the code,
% \verb|TEMPO| and \verb|PCTNPI| can only be used with standard TTM.
% 
% For a very limited test set that was used to try to differentiate between the
% standard and this ``extended'' TTM, it seems that the difference is not larger
% than a single extra step in $r_\text{max}$. This is because though the transfer
% tensors in the standard TTM had time-translational symmetry, the propagators are
% still calculated using the QuAPI. So, the only problem is in the points where
% the transfer tensors ``interact'' with the forward-backward propagators
% augmented by the solvent effects. This is easily accounted for by one extra step
% of path integral simulation. While it is not entirely obvious if this trivially
% extended TTM makes it identical to SMatPI, we do believe that it might be
% exceedingly similar. At this stage, the biggest benefits of SMatPI seem to be
% the incorporation of extended memory~\cite{makriSmallMatrixPath2021} that it can
% easily capture the effect of time-dependent external
% fields~\cite{makriSmallMatrixPath2021a}, which the extended TTM implemented in
% QuantumDynamics.jl is currently unable to.


\bibliography{library}
\end{document}