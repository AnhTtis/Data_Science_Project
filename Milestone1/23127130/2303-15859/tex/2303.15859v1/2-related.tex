\subsection{Geometry Cues as Objectness}
\textbf{Learning-based geometry cues.}
Learning-based geometry objectness cues are utilized to evaluate the quality of the proposals and segments generated by a detector. These cues come in three popular forms: box intersection over union (IoU), mask intersection over union, and centerness. They have been integrated into dense proposal-based detectors serving as a learning objective as well as a ranking and filtering indicator.
IoU-Net~\cite{iounet} recognizes that classification scores can be unreliable in determining the quality of proposals. For example, proposals that only cover a partial but discriminative part of an object can still receive high classification scores. To address this issue, IoU-Net implements a box-IoU branch to estimate the IoU score of proposals and their corresponding ground-truth boxes. Similarly, Mask Scoring R-CNN~\cite{msrcnn} implements a mask-IoU branch to estimate the IoU score of predicted masks and their corresponding ground-truth masks. FCOS~\cite{fcos}, on the other hand, implements a centerness branch to estimate the centerness of the predicted boxes. Boxes with low centerness scores tend to be of low quality, and vice versa.
OLN~\cite{oln} takes this concept one step further by using geometry cues, such as IoU and centerness, solely as objectness supervision and proposals ranking indicators, thus improving the performance of the vanilla Faster R-CNN for open-world proposals. Similarly, GGN~\cite{ggn} leverages geometry objectness cues for learning-based ranking and pseudo-label generation. The use of pseudo labels with these cues has proven to be effective in improving performance in GGN.
OpenInst, on the other hand, uses geometry objectness cues for a different purpose - to solely serve as a learning objective and aid the box regression branch in localizing general objects, achieving both simplicity and high-performance.

\textbf{Learning-free geometry cues.}
Learning-free and heuristic geometry objectness cues have been the primary approaches used to determine the objectness of a proposal box. \citet{measuringobj} have used a combination of low-level geometry cues, such as salience, color contrast, and edge density, to estimate the objectness of a proposal. Selective Search (SS)~\cite{ss} has utilized up to 80 hierarchy grouping strategies to generate region candidates, with the objectness of each region being determined by the accumulation of positions within each hierarchy grouping strategy. EdgeBox~\cite{edgebox} has also utilized a simple approach, observing that the number of closed contours within a proposal box could represent its objectness.


\subsection{Query-based Detectors}
Dense proposal-based detectors~\cite{rcnn,fast-rcnn,faster-rcnn,fcos} often face difficulties in handling a large number of proposals during both the pre-processing and post-processing phases. To address this issue, DETR~\cite{detr} presents an end-to-end training framework that utilizes sparse queries. The DETR framework leverages the powerful transformer encoder-decoder architecture to encode global information and employs a set of queries to decode corresponding predictions, with the number of predictions being equal to the number of queries, typically set to 100 or 300. To further enhance the performance of DETR, the Deformable-DETR~\cite{deformdetr} introduces a multi-scale deformable attention module.

Sparse R-CNN~\cite{sparsercnn} and subsequent QueryInst~\cite{queryinst} are a hybrid of query-based detectors and two-stage detectors, offering the best of both worlds. It replaces the dense proposals of Faster R-CNN~\cite{fast-rcnn} or Mask R-CNN~\cite{mask-rcnn} with learnable query boxes and query features. The RoI features, obtained through query boxes, interact with corresponding query features in a cascade style, allowing for the final predictions to be decoded. The implementation of Sparse R-CNN not only accelerates the convergence speed but also improves the performance of query-based detectors.

Therefore, due to its better efficiency and performance, we choose QueryInst as our baseline model for our subsequent experiments. Meanwhile, we believe that other query-based detectors are capable as well.