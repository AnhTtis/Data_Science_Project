\section{\system Framework Design}
\label{sec:system}
We now explain how \system helps author widgets that support transparent, reusable, and customizable user actions. 

% \danc{here do we want to emphasize a) we revise conventional widget design to a statefule design or b) megneton can convert your existing widgets to improve it with our proposed characteristics? It sounds more like b) to me but not sure if that's the intention. } \saj{it's actually a}
%In this section, we discuss the key components that provide the foundation for \system widgets, which instruments the design goals outlined in Section~\ref{sec:design_goal}. 
%We then explain the system architecture of \system.

\subsection{Widget Frameworks: Design and Limitations}
Widgets are interactive elements, \eg sliders, text boxes, buttons, that have representations both in the kernel, \ie where code is executed, and the front-end, \ie the notebook web interface. However, recent frameworks for authoring widgets~\cite{idomjp} also enable integration of interactive dashboards in the front-end~\cite{wu2020b2,bauerle2022symphony, zhang2023meganno}.  

 \begin{figure}[!htb] 
 \centering
  \includegraphics[width=0.8\linewidth]{figures/stateful-widget-redesign-basic.png}
  \caption{Design of basic, \ie traditional widgets.}
  \label{fig:base_widget} 
  \Description{The basic widget design.}
\end{figure}

 
 As shown in Figure~\ref{fig:base_widget}, Widgets (\eg \emph{ipywidgets}~\cite{IPyWidgets}) maintain their state both at the back-end kernel (called \emph{Widget Base}) and the front-end (called \emph{Widget Model}.) The Widget Base and Widget Model remain in-sync via the communication API called \emph{Comm}. 
 %\danc{The previous statement is bit hard to follow. Break down into defining what are widget base and model, and then explain how they work together?} 
However, only the most recent state is maintained, making the widgets essentially \emph{memoryless}. The \emph{Widget Manager} coordinates the display of the widget in the front-end \emph{Widget View}. The Widget View is a container for rendering interactive components using front-end libraries and web frameworks. The Widget View only registers low-level event listeners corresponding to user interactions on the components. %For example, a \emph{drag} interaction that updates position of slider is registered as an \emph{onChange} listener. 
 For example, a \emph{selection} interaction on the graph node in Figure~\ref{fig:teaser}B that updates the bar charts is registered as an \emph{onClick} listener.
 Therefore, these widgets are \emph{agnostic} of the user's high-level interaction types and additional context, such as where the interaction happened and which components were updated. The \emph{memoryless} and \emph{interaction agnostic} nature of widgets prevent tracking of the user's interaction history and the corresponding widget states.
Moreover, such a design primarily serves to parameterize data operations in the kernel using front-end events --- a widget state variable (\eg current node identifier) impacted by a low-level event (\eg \emph{onClick}) serves as an input parameter to a data operation (\eg distribution computation). Any change in the widget variable triggers a recomputation of the data operation. In the notebook, the users can programmatically access and update the parameters of the data operations. However, the data operations in the kernel, designed by widget developers, are neither accessible nor customizable from the front-end. The lack of affordances to override data operations limit 
the end-user's capability to customize the widgets designed by the developers. We describe enhancement of existing widgets with such features next.

\subsection{Towards Persistent, Interaction-Aware, and Customizable Widgets}

%We augment existing widgets to introduce new features such as interaction history, reusable sates, and on-demand customization of data operations. 
We create a persistent and interaction-aware widget called \emph{stateful widget} by extending the Widget Base with state and interaction history management capabilities (see Figure~\ref{fig:stateful_widget}.) Within a stateful widget, the state manager maintains each state updates corresponding to user interactions within a list called \emph{Data States}. The state manager registers the following in the \emph{action history}: (a) context of each event (\eg the front-end interaction type and the component and element where interaction occurred) and (b) the corresponding state identifier in Data States. Since the default Widget View only registers low-level events, we create a Widget View Wrapper that records each event's context as an action via an Action Wrapper. The action wrapper dispatches an action consisting of the event context mentioned earlier via the Comm API. Users can view the interaction history in a separate notebook cell which shows the details of an interaction and the corresponding data state as shown in Figure~\ref{fig:history}, thereby ensuring transparency. The history view is synchronized with the corresponding widget. Therefore, users can leverage the history to load previous states in the Widget View using the \emph{Restore} button. Moreover, users can also access the widget state as a \code{JSON} object using a declarative command as shown in Figure~\ref{fig:teaser}E, thereby ensuring reusability. Such a design also enables users to employ visualizations as a medium for capturing 
and exporting ``actions interactively
performed in the component''~\cite{batch2017interactive} --- 
the outcomes of these interactions are often utilized in 
subsequent steps of a data science workflow~\cite{rahman2022ie}.

 \begin{figure}[!htb] 
  \centering
  \includegraphics[width=\linewidth]{figures/stateful-widget-redesign-mag.png}
  \caption{Design of \system widgets. The dashed (``- -'') elements, \ie the stateful widget and widget view wrappers, are introduced by \system.}
  \label{fig:stateful_widget} 
  \Description{The stateful widget design.}
\end{figure}

% Therefore, interaction-aware state management \todo{via stateful widget} ensures transparency and reusability of user actions. \todo{elaborate}

\begin{figure*}[!htb] 
  \centering
  \includegraphics[width=\linewidth]{figures/history.png}
  \caption{The history view of a widget (\code{widget.history.show()}). Clicking the \emph{Restore} button loads previous state visualizations. }
  \label{fig:history} 
  \Description{The history view of a widget. Clicking the Restore button loads the previous states and their visualizations.}
\end{figure*}

%\hkc{why is it called 'shared'? also which opreations are customizable and which are not?} all data operations are customizable if they are defined as shared
Since data operations in the kernel correspond to user interactions in the front-end component, we introduce the concept of \emph{shared actions}.
Shared actions are data operations that end-users can override from the notebook. The operation definitions are essentially shared between the kernel and front-end. In the \system framework, developers can define a data operation to be shared. 
 For example, a shared data operation may return a distribution sorted by descending order of frequency. However, the user may prefer viewing the distribution in the alphabetic order of labels. As shown in Figure~\ref{fig:teaser}C and~\ref{fig:teaser}D, a user-defined function (UDF) written in the notebook --- which reflects the updated sort order --- is mapped to these the actions during widget instantiation time. 
In the kernel, the state manager parses the UDFs using custom serializers and overrides the data operation corresponding to the shared action. 
Such a design expands the ``events parameterizing code'' paradigm of widgets to ``operations parameterizing code'' and offers more flexible customization capabilities --- users can keep updating the shared actions to explore different objectives by modifying the function defined in the notebook.
Note that developers may implement data operations such as schema generation and distributions computation using standalone libraries or from scratch. In the case studies described in Section~\ref{sec:study}, we used an in-house graph query library, which was published as a Python package. 
% , among others. The operations are part of an in-house graph query library, which is published as a Python package for internal usage.
%We provide examples of these features in the supplementary material. 


%\todo{ADD CODE BLOCK}
\stitle{Components in \system Widget View.} 
%\danc{this paragraph renamed to technical/implementation details? Or is component a special term in megneton? } 
We use the React web framework~\cite{react} to develop the front-end components and the IDOM-Jupyter package~\cite{idomjp} for component rendering in the Widget View. 
The components are TypeScript~\cite{typescript} modules that enable the rendering of a wide range web-based visualization libraries. For example, we used a custom graph visualization library to render the schema graph~\cite{franz2016cytoscape}, Vega-lite~\cite{satyanarayan2016vega} to render the bar charts, and a JavaScript library to render tables. 
%We provide a detailed list of all the components in the supplementary material.
As TypeScript supports static typing, developers can define application-specific data types and use those across the modules. 
Therefore, using TypeScript ensures a tighter integration between the Widget Base in the kernel and the Widget Model in the front-end. 
Moreover, when customizing data operations defined as shared actions, the pre-defined types provide hints to the user about the expected return type of the customized function. Each of the components rendered in the Widget View is fully interactive. These interactions, derived from existing visualization research~\cite{yi2007toward, amar2005low} are reactively synchronized across \system components, enabling multiple-coordinated visualizations (\eg Figure~\ref{fig:teaser}B.) 