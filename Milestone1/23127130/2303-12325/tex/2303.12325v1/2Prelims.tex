\section{Preliminaries} \label{sec:prelim}


% If the set of critical nodes $\CC$ is empty for an instance $G$ then $G$ is a stable marriage instance with two-sided ties, and computing a \CRWSM\ for $G$ is the same as computing a stable matching in $G$.  It is well-known that different stable matchings in $G$ have different sizes~\cite{irving1994stable}. Thus, it is natural to consider the problem of computing a maximum size \CRWSM. We represent this problem by \MCRWSM.  Next, we show that if $G$ is an instance of a stable marriage problem with strict preference lists and $\CC\subseteq \BB$ then the Definition~\ref{def:rsm11} and Definition~\ref{def:rsmHRLQ} are equivalent.

% \begin{lemma}\label{lem:equvDef1}
% Let $G$ be an instance of a stable marriage problem with strict preference lists and $\CC\subseteq\BB$. Then a matching $M$ is an \RSM\ according to the Definition~\ref{def:rsm11} if and only if $M$ is an \RSM\ according to the Definition~\ref{def:rsmHRLQ}.
% \end{lemma}

% \begin{proof}
% $\Longrightarrow$  Let $M$ be an \RSM\ according to Definition~\ref{def:rsm11}. If there is no blocking pair w.r.t. $M$ in $G$ then we are done. So, assume that $(a,b)$ is a justified blocking pair w.r.t. $M$ according to Definition~\ref{def:rsm11}. Since no $a\in\AA$ is critical, we claim that the blocking pair $(a,b)$ cannot be justified by condition~\ref{itm:2rwsm}. Suppose $(a,b)$ is justified by condition~\ref{itm:2rwsm} of Definition~\ref{def:rsm11}. Then $b$ is matched in $M$. Since $\CC\subseteq \BB$, it is clear that $M(b)=a'$ is not critical, and hence $a'$ is surplus -- a contradiction that $a$ is not surplus.  Thus, $(a,b)$ is justified by the condition~\ref{itm:1rwsm} of the Definition~\ref{def:rsm11}.  This implies $a$ is matched. That is, all residents participating in the blocking pair are matched. Thus, no unmatched resident blocks $M$. Also, note that $M(a)=b'$ is a critical node and hence cannot be surplus. Thus, the blocking pair $(a,b)$ is acceptable by Definition~\ref{def:rsmHRLQ}. 

% $\Longleftarrow$ Let $M$ be an \RSM\ according to the Definition~\ref{def:rsmHRLQ}. If there is no blocking pair w.r.t. $M$ then we are done. So, let $(a,b)$ be a blocking pair w.r.t. $M$.  Since no unmatched resident participates in a blocking pair, $a$ must be matched.  Note that $b'=M(a)$ is matched in $M$ but not surplus which implies that $b'$ is a critical node. This implies that $a$ is matched and $M(a)$ is a critical node. Thus,  $(a,b)$ is an acceptable blocking pair by Definition~\ref{def:rsm11}. 
% \qed\end{proof}

%  Lemma~\ref{lem:equvDef1} immediately implies that Theorem~4~\cite{krishnaa2023envy} holds for our setting and hence we have Claim~\ref{cl:NPHARD}.
 
% \begin{cl}[Theorem~4~\cite{krishnaa2023envy}]\label{cl:NPHARD}
% The \MCRWSM\ problem for an instance of \SMTTLQ\ is NP-hard and cannot be approximated within a factor of $\frac{21}{19}-\epsilon$ for any $\epsilon >0$ unless $P=NP$.
% \end{cl}

%Given that computing a maximum size critical \RWSM\ is NP-Hard and hard to approximate, we focus on computing a matching with a good approximation to the size of a maximum critical \RWSM. We compute a matching which is $\frac{3}{2}$-approximation to the size of a maximum size \CRWSM. 
Our algorithm described in the next section combines the ideas in 
(i) Kir{\'a}ly's algorithm~\cite{Kiraly13} for computing a stable matching in the presence of two-sided ties and (ii) Multi-level algorithm for computing popular critical matching~\cite{nasre2022popular} for strict preferences.
We give an overview of the algorithms and also define terminology useful for our algorithm.
%Our algorithm is a proposal-based multi-phase, multi-level algorithm where vertices in $\AA$ propose and vertices in $\BB$ accept or reject the proposal. The vertices in $\AA$ propose possibly multiple times,  up to a certain level, as long as they remain unmatched or deficient.  A vertex $b$ which receives the proposal always prefers a higher level vertex  $a$ over any lower level vertex $a'$ irrespective of the ranks of $a$ and $a'$ in $\prefb$. \textcolor{blue}{MN: This does not hold at the t* level, but I guess you do not call it a separate level right? Does this cause confusion? --- Keshav: No I think. Because the first thing is -- I am calling $\T^*$ as a sub-level at level $\T$ and when $\T^*$ is being introduced in our description, I have described the preference ordering in relation to $\T^*$. But, do you feel that it can cause confusion?} Our algorithm is inspired by two different algorithms-- (i) Kir{\'a}ly's algorithm~\cite{Kiraly13} for computing $\frac{3}{2}$-approximation of maximum-sized stable matching in the stable marriage problem with two-sided ties without critical nodes and (ii) maximum-sized popular matching amongst critical matching in the many-to-many setting with two-sided lower-quotas but without ties~\cite{nasre2022popular}. 


\noindent{\bf Overview of Kir{\'a}ly's algorithm~\cite{Kiraly13}.}
 Kir{\'a}ly's algorithm~\cite{Kiraly13} is a proposal-based algorithm where vertices in $\AA$ propose and vertices in $\BB$ accept or reject. We need  the term \emph{uncertain proposal} from \cite{Kiraly13} which is defined below.
 
 \begin{definition}[Uncertain Proposal] \label{def:uncertainProp}
   Let $b$ be some $k^{th}$ rank neighbour of $a$ in $\prefa$. During the course of the algorithm, the proposal from $a$ to $b$ is uncertain if there exists another $k^{th}$ rank neighbour $b'$ of $a$ which is unproposed by $a$ and unmatched in the matching. Once a proposal $(a,b)$ is uncertain, it remains uncertain until $b$ rejects $a$.
\end{definition}
 Each time an  $a\in \AA$ proposes to its \emph{favourite} neighbour $b$ (we define it formally in  Definition~\ref{def:favNbr}), the vertex $b$ accepts/rejects as follows: %(see Definition~\ref{def:favNb).
\begin{enumerate}
    \item If $b$ is unmatched then $b$ immediately accepts the proposal. 
    \item If $b$ is matched, say to $a'$, and $(a',b)$ is an uncertain proposal, then $b$ rejects $a'$ and accepts the proposal from $a$, irrespective of the ranks of $a$ and $a'$ in $\prefb$. In this case, $b$ is {\em marked}
    by $a'$.
    \item If $b$ is matched, say to $a'$, and $(a',b)$ is not an uncertain proposal, then\\ (i) if  $a \succ_b a'$ then $b$ rejects $a'$ and accepts the proposal from $a$, or \\ (ii) if $a' \succeq_b a $ then $b$ rejects $a$.
    \end{enumerate}
    
The reason for $a'$ marking the vertex  $b$ in (2) is as follows:
    %It may happen that $a' \succ_b a$ thus, whenever $a'$ gets rejected by $b$ because of the reason that $a'$ was uncertain about that proposal, the vertex $b$ is \emph{marked} by $a'$. 
    In this case, $b$ rejects the uncertain proposal from $a'$ and accepts $a$ {\em irrespective}
    of the preference of $b'$ between $a$ and $a'$. Later, when $a'$ gets its chance to propose, and if none of the neighbours of $a'$ at the rank of $b$ accept the proposal from  $a'$ then
    %, unproposed neighbour by $a'$ remains at the current rank, 
    $a'$ will propose to the marked vertex $b$ before proposing to the next lower-ranked neighbours.
    In contrast in (3)(i) above, when the proposal $(a', b)$ is not uncertain and $a \succ_b a'$ then $a'$ does not mark $b$. 
    %because $M(b)=a$ is strictly better than $a'$ and $a'$ was not uncertain about the proposal to $b$. 
    Note that a vertex $b\in\BB$ can be part of an uncertain proposal at most once. Once a vertex receives it's first proposal it will remain matched and thereafter cannot be part of any uncertain proposal. Thus, any $b\in\BB$ can be marked at most once during the course of the algorithm.
    
    %If $b$ is matched, say to $a'$, and $a'$ is not uncertain about the proposal, and $a \succ_b a'$ then it rejects $a'$ to get matched with $a$. In this case, $a'$ does not mark $b$ because $M(b)=a$ is strictly better than $a'$ and $a'$ was not uncertain about the proposal to $b$.  If $b$ is matched, say to $a'$, and $(a',b)$ is not an uncertain proposal, and $a' \succeq_b a $ then it rejects $a$. 

Now, we define the favourite neighbour of a vertex $a$, which is an adaptation of the definition in~\cite{Kiraly13}. %in Definition~\ref{def:favNbr}, which uses the concept of \emph{marked} vertices. 
\begin{definition}[Favourite neighbour of $a$] \label{def:favNbr}
  Assume that $k$ is the best rank at which some unproposed or marked neighbours of $a$ exist in $\prefa$. Then $b$ is the favourite neighbour of $a$ if one of the following conditions holds:
    \begin{itemize}
       \item[(i)] there exists at least one unmatched neighbour  of $a$ at the $k^{th}$ rank and $b$ has the lowest index among all such unmatched neighbours, or
        \item[(ii)] all the $k^{th}$-ranked neighbours of $a$ are matched and $b$ is the lowest index among all such neighbours which are unproposed by $a$, or
        \item[(iii)] all the $k^{th}$-ranked neighbours are already proposed by $a$ and $b$ has the lowest index among all the vertices which are marked by $a$.
    \end{itemize}
 \end{definition}

    Kir{\'a}ly's algorithm begins with every vertex $a \in \AA$ being active. As long as there exists an active vertex which is unmatched and has not exhausted its preference list, the vertex proposes to its favourite neighbour.
    If $a\in \AA$ remains unmatched after exhausting its preference list, it achieves a `$*$' status and starts proposing to vertices in $\prefa$ with $*$ status.  The $*$ status of a vertex $a$ can be interpreted as improving the rank of $a$ in $\prefb$ by $0.5$ for any neighbour $b$ of $a$. Thus, the $*$ status vertex is used to decide between vertices in a tie, but does not affect strict preferences.  %A vertex $b\in \BB$ prefers any $*$ status vertex $a$ over a non $*$ status vertex $a'$ if $a=_b a'$. If $a\succ_b a'$ then $*$ status of any of the vertices $a$ or $a'$ does not matter, that is, $b$ prefers $a$ over $a'$ even if $a'$ is $*$ status and $a$ is not $*$ status. A vertex $a\in \AA$ becomes inactive if it is matched or it exhausts its preference list as a $*$ status vertex.
    It is shown in~\cite{Kiraly13} that the resulting matching is a $\frac{3}{2}$-approximation of a maximum size stable matching.



\noindent{\bf Overview of the popular critical matching algorithm~\cite{nasre2022popular}.}
Now, we briefly describe the algorithm in~\cite{nasre2022popular} for computing the maximum size popular critical matching in the one-to-one strict list setting.  Let $\S$ and $\T$ denote the number of critical vertices in $\AA$ and $\BB$, respectively. The algorithm in~\cite{nasre2022popular} is a multi-level algorithm which first matches as many critical vertices from $\BB$ as possible by allowing each unmatched $a\in\AA$ to propose only critical vertices on the $\BB$-side at levels $0,\ldots,\T-1$. At the level $\T$ each vertex $a\in\AA$ is allowed to propose \emph{all} its neighbours. If a vertex $a\in\AA$ remains unmatched even after exhausting its preference list at level $\T$, $a$ raises its level to $\T+1$ and proposes to its neighbours until it is matched or it exhausts its preference list at the level $\T+1$.   If a critical vertex $a$ remains unmatched then $a$ raises its level above $\T+1$ and continues proposing to all its neighbours until it is matched or it exhausts its preference list at the highest level $\S+\T+1$. A vertex $b$ which receives the proposal always prefers a higher level vertex  $a$ over any lower level vertex $a'$ irrespective of the ranks of $a$ and $a'$ in $\prefb$. It is shown in~\cite{nasre2022popular} that the resulting matching is a maximum size popular matching among all the critical matchings.

%\clr{The proofs omitted in the interest of space for $\star$-marked Lemmas  are included in Appendix~\ref{append:proof}.}