\begin{figure}[b!]
    \footnotesize
    \centering
    \vspace{-1mm}
    \hrulefill
    \vspace{-1mm}
    % \begin{minted}[fontsize={\fontsize{7.0}{8.0}\selectfont}]{python}
    \begin{lstlisting}[language=Python]

'''
Inputs: P, T, B, delta
    P: array of size (N, 3) with xyz coordinates
    T: array of size (N,) with timesteps
    B: array of size (N,) with beam IDs
Outputs: curves
    curves: list of arrays, array j is size (N_j, 3)
'''
curves = []
for b in unique(B):
    # filter to a single laser beam's measurments
    beam_P, beam_T = P[beams==b], T[beams==b]

    # order points by laser's traversal
    sequential_ordering = argsort(beam_T)
    beam_P = beam_P[sequential_ordering]

    # split laser's traversal into cont. curves
    edge_lens = norm(beam_P[1:] - beam_P[:-1])
    split_locations = edge_lens > delta

    # convert into polylines
    beam_C = split_seq(beam_P, split_locations)
    curves += beam_C
    \end{lstlisting}
    % \end{minted}
    \hrulefill
    % \vspace{2mm}
    \caption{\textit{Point to Curve Cloud Conversion.} Algorithm (in Python) to convert an input point cloud into a set of polylines.}
    \label{fig:curve-cloud-conversion}
\end{figure}

% Outputs: C
%     C: list<array> containing (N', 3) arrays;
%        each array is a variable-length polyline