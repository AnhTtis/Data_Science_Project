
\section{Method}


\label{sec:g2p}


\begin{figure}[t!]
    \centering
    \includegraphics[width=\linewidth]{figures/pipeline_short.pdf}

    \caption{\textbf{Overview of LaneGAP.} }
    % Based on the proposed path-wise modeling, LaneGAP first utilizes the Graph2Path algorithm to translate the graph into a set of paths. Then, an end-to-end network is designed to represent and learn the paths. Finally, a Path2Graph algorithm is used to translate the predicted paths into graph structure with negligible cost. Graph2Path and Path2Graph are deterministic algorithms and don't require backpropagation for optimization.}
    \label{fig:framework}

    \end{figure}

In this section, we first describe how to translate the directed lane graph into a set of directed paths in Sec.~\ref{sec:g2p}. Then we introduce the online path detection framework in Sec.~\ref{sec:lanegap}.  And we describe how to translate  paths back to the lane graph in Sec.~\ref{sec:p2g}. An overview of our method is exhibited in Fig.~\ref{fig:framework}.



\subsection{Graph2Path}
We propose a simple Graph2Path algorithm to translate the directed lane graph into a set of paths according to the direction and connection information encoded in the lane graph. The pseudo-code of Graph2Path is shown in Alg.~\ref{algo:g2p}.

Given the ground truth Lane graph $G$, which is typically a directed graph in the local map around the ego-vehicle, we first extract the root vertices $\Omega_{\text{root}}$ and leaf vertices $\Omega_{\text{leaf}}$. Then we pair the root vertices and leaf vertices and then utilize depth-first-search (DFS) algorithm to find the valid path $V^{\text{path}}$. Finally, we can translate the ground truth directed lane graph $G$ to a set of directed paths $\mathcal{V}_{\rm path} = \{V_i^{\rm path}\}_{i=1}^{M}$, where $M$ is the number of ground truth paths.


\subsection{Path Representation and Learning}
\label{sec:lanegap}
Inspired by  advanced set detection methods~\cite{detr,deformdetr}, we propose an end-to-end network, LaneGAP, to predict all paths simultaneously in a single stage, as illustrated in Fig.~\ref{fig:framework}. Our network consists of an encoder that encodes the features  from the onboard sensor data, and a query-based Transformer decoder that performs set detection by decoding a set of paths $\hat{\mathcal{V}}_{\rm path} = \{ \hat{V}_i^{\rm path}\}_{i=1}^N$ from the encoded features. To parameterize the path, we utilize two widely-used types of representations, Polyline~\cite{vectormapnet,maptr} and Bezier~\cite{stsu,bemapnet}, where Polyline offers high flexibility in describing the path, while Bezier provides a smoother representation.


\boldparagraph{Polyline representation.}
% \boldparagraph{Polyline representation.}
Polyline representation models the arbitrary directed path as an ordered set of $N_{\text{p}}$ points  $V_{\text{poly}}^{\text{path}} = \{p_j \in \mathbb{R}^2 | j = 0,1,2,..., N_{\text{p}}-1\}$. We directly regress polyline points and utilize deformable attention~\cite{deformdetr} to exploit the local information along each Polyline path, where the keys and values are the local features along the Polyline path.

\boldparagraph{Bezier representation.}
% \boldparagraph{Bezier representation.} 
Bezier representation models the directed path as an ordered set of $N_{\text{b}}$ control points $V_{\text{Bezier}}^{\text{path}} = \{b_j \in \mathbb{R}^2 | j = 0,1,2,..., N_{\text{b}}-1\}$.
% which typically lie off the line.
Bezier is a parametric curve, where the point $B$ on the line  can be  calculated by the weighted sum of control points $V_{\text{Bezier}}^{\text{path}}$:
\begin{equation}
\begin{gathered}
B = \sum_{j=0}^{N_{\text{b}}-1} C_{N_{\text{b}}-1}^{j}t^{j}(1-t)^{N_{\text{b}}-1-j} b_j, 0 \leq t \leq 1.
\end{gathered}   
\label{eq:1}
\end{equation}
Given the Bezier control points set $V_{\text{Bezier}}^{\text{path}}$ and the sampled interval set $T=\{ t_k \in \mathbb{R}|0 \leq t_k \leq 1, k=0,1,2,...,K-1 \}$, we can calculate the curve $\mathcal{B} = \{B_{k}\in \mathbb{R}^2|0,1,2,...,K-1 \}$ with matrix multiplication:
\begin{equation}
\begin{gathered}
\mathcal{B} = \Gamma \times V_{\text{Bezier}}^{\text{path}},
\end{gathered}
\label{eq:2}
\end{equation}
where weight matrix $\Gamma$ is a $K\times N_{\text{b}}$ matrix and $\Gamma(k,j) = C_{N_{\text{b}}-1}^j t_{k}^{j} (1-t_k)^{N_{\text{b}}-1-j}$. For Beizer representation, we use the same network as Polyline representation to regress Bezier control points directly. To enable exploiting the local information along the Bezier path with offline control points, we sample the Bezier path to get online points $\mathcal{B}$ based on Eq.~\ref{eq:2} and perform deformable attention, where the keys and values are the local features around the sampled points $\mathcal{B}$ along the Bezier path. We denote this design as Bezier deformable attention, which enables the Transformer decoder to aggregate features along the Bezier path.



\boldparagraph{Learning.}
% \boldparagraph{Learning.}
We use the encoder to transform the input onboard sensor data into unified BEV features $F_{\rm BEV}$~\cite{bevformer,gkt,second}. Then we utilize the Transformer decoder to predict a set of paths based on a set of random initialized learnable path queries~\cite{maptr}.
With the above path representation, we can cast the predicted path into an ordered set of points with a fixed number $N_v$ of points on the path, where $\hat{V}_i^{\text{path}} = \{\hat{v}_j \in \mathbb{R}^2|j=0,1,2,...,N_v-1\}$. We modify the bipartite matching loss used in~\cite{detr} to fit in the path detection setting:
\begin{equation}
\begin{aligned}
\mathcal{L}_{\rm bipartite}(\hat{\mathcal{V}}_{\text{path}},\mathcal{V}_{\text{path}}) =& \sum_{i=1}^{N}[\mathcal{L}_{\rm{Focal}}(\hat{p}_{{\hat{\sigma}}(i)}, c_i) + &\indic{c_i \neq \varnothing}\mathcal{L}_{\rm path}(\hat{V}_{\hat{\sigma}(i)}^{\rm path}, V_i^{\rm path})],\\
\mathcal{L}_{\rm path}(\hat{V}_{\hat{\sigma}(i)}^{\rm path}, V_i^{\rm path}) =& \sum_{j=0}^{N_v-1}L_1(\hat{v}_j,v_j),
\end{aligned}    
\label{eq:3}
\end{equation}
where $\hat{\sigma}$ is the optimal assignment between a set of predicted paths and a set of ground truth paths computed by the Hungarian algorithm, $c_i$ is the target class label, and $\mathcal{L}_{\rm{Focal}}(\hat{p}_{{\hat{\sigma}}(i)}, c_i)$ is the classification loss defined in~\cite{focal}. $L_1$ loss is utilized between the matched predicted path $\hat{V}_{\hat{\sigma}(i)}^{\rm path}$ and sampled ground truth path $V_i^{\rm path}$.
To enhance the BEV features, we introduce an auxiliary BEV segmentation branch $\phi_{\rm seg}$  to predict the BEV segmentation mask, and the auxiliary BEV segmentation loss is defined as:
\begin{equation}
\begin{gathered}
\mathcal{L_{\rm auxseg}} = \mathcal{L_{\rm CE}}(\phi_{\rm seg}(F_{\rm BEV}), M_{\rm BEV}),
\end{gathered}
\label{eq:4}
\end{equation}
where $M_{\rm BEV}$ is the ground truth. The total loss is defined as:
\begin{equation}
\begin{gathered}
\mathcal{L_{\rm total}} = \mathcal{L_{\rm cls}} + \mathcal{L_{\rm path}} + \mathcal{L_{\rm auxseg}},
\end{gathered}
\label{eq:5}
\end{equation}
where $\mathcal{L_{\rm cls}}$ is the path-wise classification loss using Focal loss~\cite{focal}.


\begin{minipage}[t]{0.43\textwidth}
    \begin{algorithm}[H]
    % \tiny
    \SetAlgoLined
    \DontPrintSemicolon
    \SetNoFillComment
    \footnotesize
    \KwIn{directed lane graph $G$}
    \KwOut{directed paths $\mathcal{V}$}
    
    Initialize: $\mathcal{V} \leftarrow \emptyset$, $\text{root vertices set } \Omega_{\text{root}} \leftarrow \emptyset$, $\text{leaf vertices set } \Omega_{\text{leaf}} \leftarrow \emptyset$\;
    \For{v in $G$.vertices}{
        % \tcc{interpolate each path}
        \If{ $\text{v}.\text{in\_degree} == 0$}{
            $\Omega_{\text{root}} \leftarrow \Omega_{\text{root}} \cup \{v\}$\;
        }
        \If{ $\text{v}.\text{out\_degree} == 0$}{
            $\Omega_{\text{leaf}} \leftarrow \Omega_{\text{leaf}} \cup \{v\}$\;
        }
    }
    \For{root v in $\Omega_{\text{root}}$ }{
        \For{leaf v in $\Omega_{\text{leaf}}$}{
            $V^{\text{path}} = \textbf{findpath}(root\ v, leaf\ v, G)$ \;
            \If{ $V^{\text{path}} \text{ is not None}$}{
                $\mathcal{V} \leftarrow \mathcal{V} \cup \{V^{\text{path}}\}$\;
            }
        }
    }
    
    Return: $\mathcal{V}$
    \caption{Pseudo-code of Graph2Path.}
    \label{algo:g2p}
    \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.49\textwidth}
    \begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \SetNoFillComment
    \footnotesize
    \KwIn{a set of paths $\mathcal{V}=\{ V_i^{\text{path}} \} $}
    \KwOut{directed  lane graph $G$}
    
    Initialization: $G=\text{DirGraph}()$\;
    \For{$V^{\text{path}}$ in $\mathcal{V}$}{
        % \tcc{interpolate each path}
        $V=\{v_j\} \leftarrow \textbf{discret\_to\_vert\_seq}(V^{\text{path}})$\;
        \For{ $v_j$ in $V$}{
            \If{ $v_j\ \text{is\ the\ last\ vertice\ of\ }V$}{
                $G.\textbf{add\_vertice}(v_j)$ \;
                \textbf{break}\;
            }
            $G.\textbf{add\_vertice}(v_j)$ \;
            $G.\textbf{add\_edge}(v_j,v_{j+1})$ \;
        }
    
    }
    % $G=\textbf{merge\_path\_graphs\_into\_lane\_graph}(\mathcal{G}_{\text{path}})$ \;
    $G=\textbf{merge\_vertices\_by\_overlap}(G)$
    
    
    Return: $G$
    \caption{Pseudo-code of Path2Graph.}
    \algorithmfootnote{The for loops here can be implemented in a parallel paradigm. $\textbf{merge\_vertices\_by\_overlap}$ merges the overlapped vertices of different paths to reduce the redundancy of $G$ without affecting the accuracy of graph topology.}
    \label{algo:p2g}
    \end{algorithm}
    \end{minipage}

\subsection{Path2Graph}
\label{sec:p2g}

The predicted continuous paths encode sufficient traffic information and can be directly applied to downstream motion planning. 
To further  recover the graph structure of lane topology and extract merging and fork information,
% as well as evaluate the path modeling on graph metric against other modelings, 
we convert the predicted paths $\hat{\mathcal{V}} = \{\hat{V}_i^{\text{path}}\}$ into a directed lane graph $\hat{G}$  with a  designed Path2Graph algorithm in Alg.~\ref{algo:p2g}. 
% where the input is predicted path set $\mathcal{V} = {V_i^{\text{path}}}$ and the output is directed lane graph $G$.


We discretize the path into point sequences $V=\{v_j\}$. The discretized points are regarded as vertices and the adjacent relation
between successive points is regarded as edges of vertices. We add these vertices and edges to the directed graph (line 4 to 11 in Alg.~\ref{algo:p2g}). 
The vertices registered in the directed graph $G$ on one path may have spatial overlapping with vertices on other paths. We merge the overlapped vertices into one vertex if their distance is below a threshold (line 13 in Alg.~\ref{algo:p2g}). The merged vertex inherits the predecessors and successors of the pair of overlapped vertices.


\section{Metrics}
Previous works mainly design a network based on one sort of graph modelings (pixel-wise or piece-wise) and choose a metric (pixel-level IoU or instance-level Chamfer distance mAP) friendly to the modeling. To fairly evaluate and compare across different modelings, we adapt the TOPO metric~\cite{laneextract} to measure the correctness of the overall directed graph construction. The uniqueness of lane graph construction lies in the junction points, without which the lane graph degenerates into a set of disjoint lanes. To emphasize the quality of the subgraph around the junction points, we propose a new metric, Junction TOPO, which specifically evaluates the accuracy of the local directed graph formed by traversing around the junction points on the directed lane graph.


\boldparagraph{TOPO metric.}
% \boldparagraph{TOPO metric.}
Given the predicted directed lane graph $\hat{G}$ and ground truth directed lane graph $G$, we interpolate them so that the distances between any two connected vertices are $0.15m$, and get predicted directed lane graph $\hat{G} = (\hat{V},\hat{E})$ and ground truth directed lane graph $G=(V,E)$ where $\hat{V},V$ are the sets of interpolated vertices and $\hat{E}, E $ are the sets of edges among vertices encoding direction and connection. For $\hat{V}$ and $V$,  a pair of vertices is considered a candidate match if the distance between the two vertices is less than $0.45m$. And  we utilize maximal one-to-one matching among those candidate pairs to find final matched vertices $P_{\text{pair}}=\{(\hat{v}, v)_{i}\}_{i=1}^{N_{\text{pair}}}$, then we traverse the directed graph around the paired vertices $\hat{v}$ and $v$ for less than $7.5m$ to get subgraphs $\hat{S}_{\hat{v}}$ and $S_v$  on $\hat{G}$ and G. We compute the precision $\text{Pre}(\hat{S}_{\hat{v}}, S_v) = \frac{N_{\text{subpair}}}{|\hat{S}_{\hat{v}}|}$and recall $\text{Rec}(\hat{S}_{\hat{v}},S_v) =  \frac{N_{\text{subpair}}}{|S_{v}|}$ between the vertices of predicted subgraph $\hat{S}_{\hat{v}}$ and the vertices of ground truth subgraph $S_{v}$, where the matching part follows the previous procedure with $0.45m$ threshold. Finally, we report the TOPO precision and recall defined as:
\begin{equation}
\begin{gathered}
\text{Precision}_{\text{TOPO}} = \frac{\sum_{i=1}^{N_{\text{pair}}} \text{Pre}(\hat{S}_{\hat{v}}, S_v)}{|\hat{V}|}, \\
\text{Recall}_{\text{TOPO}} = \frac{\sum_{i=1}^{N_{\text{pair}}} \text{Rec}(\hat{S}_{\hat{v}}, S_v)}{|V|}.
\end{gathered}    
% \label{eq:2}
\end{equation}


\boldparagraph{Junction TOPO metric.}
% \boldparagraph{Junction TOPO metric.} 
The TOPO metric focuses on the topology correctness of the overall directed lane graph, it does not highlight the correctness of the subgraph formed by traversing from the junction points, which plays a key role in determining the driving choices across different lanes. To bridge this gap, we propose the Junction TOPO metric, which only reports the precision and recall of the junction subgraph. Given the $N_{\text{junction}}$ junction points of the ground truth lane graph, we get pairs of subgraphs $( \hat{S}_{\text{junction}}, S_{\text{junction}})$ by traversing the directed graphs $\hat{G}$ and $G$ less than $7.5m$ from junction point. For each subgraph pair, we calculate the precision $\text{Pre}(\hat{S}_{\text{junction}}, S_{\text{junction}})$ and recall $ \text{Rec}(\hat{S}_{\text{junction}}, S_{\text{junction}})$.


\boldparagraph{Undirected versions.}
% \boldparagraph{Undirected versions.}
The above metrics calculate the precision and recall by traversing the directed graph $\hat{G}$ and $G$, ignoring the predecessor vertices. To evaluate the complete connections, we turn the directed graphs into undirected graphs and repeat the calculation defined above for two metrics.



