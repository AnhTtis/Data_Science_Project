% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{booktabs}
\usepackage{amsfonts, mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
% \usepackage{amsthm}
\usepackage[lambda ,advantage, operators, sets , adversary, landau, probability, notions, logic, ff , mm, primitives, events, complexity, asymptotics, keys]{cryptocode}
% \usepackage{mathtools}
\usepackage{xurl}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{rotating}
\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}

% \newtheorem{theorem}{Theorem}
% \newtheorem{proof}{Proof}

%% MUST COME AFTER OTHER PACKAGES
\usepackage{cleveref}

\begin{document}
%
\title{HE is all you need: Compressing FHE Ciphertexts using Additive HE}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{
Rasoul Akhavan Mahdavi \and
Abdulrahman Diaa \and
Florian Kerschbaum
}

\authorrunning{Rasoul Akhavan Mahdavi \and Abdulrahman Diaa \and Florian Kerschbaum}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Waterloo, Waterloo, Ontario, Canada}
%
\maketitle
% typeset the header of the contribution
%


\begin{abstract}
    Fully Homomorphic Encryption (FHE) permits the evaluation of an arbitrary function on encrypted data. However, FHE ciphertexts, particularly those based on lattice assumptions such as LWE/RLWE are very large compared to the underlying plaintext. Large ciphertexts are hard to communicate over the network and this is an obstacle to the adoption of FHE, particularly for clients with limited bandwidth.

    In this work, we propose the first technique to compress ciphertexts sent from the server to the client using an additive encryption scheme with smaller ciphertexts. Using the additive scheme, the client sends auxiliary information to the server which is used to compress the ciphertext. Our evaluation shows up to 95\% percent and 97\% compression for LWE and RLWE ciphertexts, respectively.
    \keywords{Homomorphic Encryption \and LWE \and RLWE \and Compression}
\end{abstract}


% \section{Introduction}

\section{Background}
\label{sec:background}
% We provide the necessary background on LWE and RLWE in this section.

\subsection{Homomorphic Encryption}
Homomorphic Encryption is a form of public-key cryptography which permits computation on messages while in encrypted form, without the need to access the secret key. Similar to other public-key cryptosystems, homomorphic ciphertexts are larger than the underlying plaintext. The ratio between the ciphertext and plaintext is denoted as the \textit{expansion factor}.

In a typical protocol using homomorphic encryption, a client encrypts its private input using a homomorphic cryptosystem and sends the resulting ciphertexts to a server. This constitutes the client's \textit{request}. The server computes the desired function over the client's encrypted input. The result is then transmitted back to the client as the \textit{response}. While there are some techniques to reduce the request size, there is no work addressing response size. This work focuses on reducing the response size.

\subsection{LWE ciphertexts}
\label{sec:lwe}
For the purpose of this work, we describe a simple version of an encryption system based on the Learning With Errors (LWE)~\cite{regev} problem which we will denote by $\mathcal{E}_{\text{LWE}}$. Existing schemes such as FHEW~\cite{ducas2015fhew} and CGGI(TFHE)~\cite{chillotti2020tfhe} have ciphertexts of a similar format.

$\mathcal{E}_{\text{LWE}}$ uses the following parameters:
dimension $n$, ciphertext modulus $q$, plaintext modulus $p$, $\Delta=\floor{q/p}$, a discrete error distribution over $\ZZ_q$ called $\chi$. We sample the secret key, $\texttt{sk}$, from $\ZZ_q^{n}$. The encryption and decryption algorithm is shown below. $\lfloor\cdot\rceil$ denotes rounding to the nearest integer.

\begin{minipage}{0.45\textwidth}
\begin{algorithm}[H]
	 \caption[]{LWEEncrypt$_{\texttt{sk}}$}
	 \label{alg:lwe-encrypt}
	 \begin{flushleft}
		 \textbf{Input:} $\mu\in\ZZ_p$
	 \end{flushleft}
	 \begin{algorithmic}[1]
        \vspace{-3mm}
	 	\State Sample $\textbf{a}\xleftarrow{\$} \ZZ_q^{n}$ and $e \leftarrow \chi$
        \vspace{3mm}
        \State $b = \sum_{i=1}^{n} \textbf{a}[i] \cdot \texttt{sk}[i] + \Delta \cdot \mu + e \mod q$
        % \vspace{1mm}
	 \end{algorithmic}
  \vspace{-2mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $c=(\textbf{a},b)$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}
~~~
\begin{minipage}{0.45\textwidth}
\begin{algorithm}[H]
	 \caption[]{LWEDecrypt$_{\texttt{sk}}$}
	 \label{alg:lwe-decrypt}
	 \begin{flushleft}
		 \textbf{Input:} $c = (\textbf{a},b) \in \ZZ_q^{n}\times\ZZ_q$
	 \end{flushleft}
	 \begin{algorithmic}[1]
        % \vspace{-3mm}
        \State $\mu^* = (b - \sum_{i=1}^{n} \textbf{a}[i] \cdot \texttt{sk}[i]) \mod q $
        \vspace{2mm}
        \State $\mu'=\lfloor\mu^* / \Delta\rceil$
        \vspace{-5mm}
	 \end{algorithmic}
  \vspace{3mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $\mu'$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}


% \begin{itemize}
%     \item \texttt{Paremeters}: ciphertext modulus q, plaintext modulus p, $\Delta=q/p$, dimension n, Error distribution $\chi$
%     \item $\texttt{KeyGen}(1^\lambda)$: $\texttt{sk} \xleftarrow{\$} \ZZ_q^{n}$
%     \item Encrypt$_{\texttt{sk}}$($\mu\in\ZZ_p$):
%     \begin{itemize}
%         \item Sample $\textbf{a}\xleftarrow{\$} \ZZ_q^{n}$, $e \leftarrow \chi$
%         \item $b = \sum a[i] \cdot s[i] + \Delta \cdot \mu + e \mod q$
%         \item Output $c=(\textbf{a},b)$
%     \end{itemize}
%     \item Decrypt$_{\texttt{sk}}(c\in \ZZ_q^{n+1})$:
%     \begin{itemize}
%         \item $\mu^* = (b - \sum a[i] \cdot s[i]) \mod q $
%         \item $\mu'=\lfloor\mu^* / \Delta\rceil$
%     \end{itemize}
% \end{itemize}

% \begin{remark}
% Usually $\texttt{sk}$ is sampled from $\{0,1\}^{n}$ but for the sake of generality, we will assume that $\texttt{sk} \in \ZZ_q^{n}$.
% \end{remark}

% Since $\textbf{a}$ is sampled at random, we can send the seed used to generate $\textbf{a}$ instead of the vector itself. This reduces the size of a ciphertext from $n\log_2 q$ bits to $\lambda+\log_2 q$ bits. However, this technique can only be applied to fresh ciphertexts, i.e. ciphertexts sent from the client to the server. \TODO{Expand this.}

\paragraph{Compressing Fresh Ciphertexts.}
Fresh ciphertexts can be compressed to reduce network costs. Since $\textbf{a}$ is sampled at random, we can send the seed used to generate $\textbf{a}$ instead of the vector itself. Concretely, instead of sending $ct=(\textbf{a},b)$, the client can produce $\bar{ct}=(\theta,b)$ where $\theta\leftarrow\{0,1\}^{\lambda}$ is the seed of a cryptographically secure PRG used to generate $\textbf{a}$, i.e., $\textbf{a}\leftarrow \texttt{PRG}(\theta)$. With this technique, ciphertexts are only $\lambda+\log_2 q$ bits instead of $n\log_2 q$.

\subsection{RLWE ciphertexts}
\label{sec:rlwe}
Similar to LWE, we can also construct an encryption scheme based on the Ring Learning with Errors Problem (RLWE)~\cite{rlwe}, which we will denote as $\mathcal{E}_{\text{RLWE}}$. Cryptosystems such as BGV~\cite{bgv}, BFV~\cite{fan2012somewhat}, and CKKS~\cite{ckks} have ciphertexts of a similar format.
RLWE ciphertexts are useful since they can encrypt a polynomial, i.e. a vector of numbers, instead of just one scalar. For RLWE encryption, we select a dimension $N$, ciphertext modulus $q$, plaintext modulus $p$, and $\Delta=\floor{q/p}$. Define $R_q=\ZZ_q[X]/(X^N+1)$ and $R_p$ similarly. Moreover, define a discrete error distribution $\chi$ over $R_q$.
For key generation, sample $S(X)$ uniformly from $R_q$.

{
\centering
~\clap{
\begin{minipage}{0.6\textwidth}
\begin{algorithm}[H]
	 \caption[]{RLWEEncrypt$_{S(X)}$}
	 \label{alg:rlwe-encrypt}
	 \begin{flushleft}
		 \textbf{Input:} $\mu(X)\in R_p$
	 \end{flushleft}
  \vspace{-2mm}
	 \begin{algorithmic}[1]
	 	\State Sample $A(X)\xleftarrow{\$} R_q$ and $E(X) \leftarrow \chi$
        \vspace{2mm}
        \State $B(X) = A(X)\cdot S(X) + \Delta \cdot \mu(X) + E(X) \mod R_q$
	 \end{algorithmic}
  \vspace{-2mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $C=(A(X), B(X))$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}
~~~
\begin{minipage}{0.6\textwidth}
\begin{algorithm}[H]
	 \caption[]{RLWEDecrypt$_{S(X)}$}
	 \label{alg:rlwe-decrypt}
	 \begin{flushleft}
		 \textbf{Input:} $C = (A(X),B(X))\in R_q\times R_q$
	 \end{flushleft}
  \vspace{-2mm}
	 \begin{algorithmic}[1]
        \item $\mu^*(X) = (B(X) - A(X)\cdot S(X)) \mod R_q$
        \vspace{3mm}
        \item $\mu'(X)=\lfloor\mu^*(X)/\Delta\rceil$
        \vspace{-3mm}
	 \end{algorithmic}
  \vspace{1mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $\mu'(X)$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}
}
\par
}

% \begin{itemize}
%     \item \texttt{Paremeters}: dimension N and ciphertext modulus q.
    
%     Define $R_q=\ZZ_q[X]/(X^N+1)$. Operations happen modulo $R_q$. plaintext modulus p,  Error distribution $\chi$ over $R_q$
    
%     \item $\texttt{KeyGen}(1^\lambda)$: $\texttt{sk}(X) \xleftarrow{\$} R_q$
%     \item Encrypt$_{\texttt{sk}(X)}(\mu(x)\in R_p)$:
%     \begin{itemize}
%         \item Sample $A(X)\xleftarrow{\$} \ZZ_{N,q}[X]$, $E(X) \leftarrow \chi$
%         \item $B(X) = A(X)\cdot S(X) + \Delta \cdot \mu(X) + E(X) \mod R_q$
%         \item  Output $C=(A(X), B(X))$
%     \end{itemize}
%     \item Decrypt$_{\texttt{sk}(X)}(C\in R_q^2)$:
%     \begin{itemize}
%         \item $\mu^*(X) = (B(X) - A(X)\cdot S(X)) \mod R_q$
%         \item $\mu'(X)=\lfloor\mu^*(X)/\Delta\rceil_p$
%     \end{itemize}
% \end{itemize}

\paragraph{Compressing Fresh RLWE ciphertexts.}
Similar to LWE, we can also compress fresh RLWE ciphertexts by sending the seed used to generate $A(X)$~\cite{angel2018pir}. Using this technique, the size of a ciphertext can be reduced from $2N\log_2 q$ bits to $\lambda + N\log_2 q$.
% Instead of sending the $A(X)$ term, we can send the seed used to generate it. This cuts the size of the ciphertext roughly in half.    

% \subsection{Compressing Fresh Ciphertexts}
% \label{sec:compress-fresh-ciphertext}
% Fresh LWE/RLWE ciphertexts are constructed by sampling random elements in the ring. Instead of sending 

% \section{Reducing Request Size}
% \begin{itemize}
%     \item We generalize the notion proposed by Beck~\cite{7179388} which works only for additive encryption schemes.
%     \item We generalize this notion to schemes which support bootstrapping, specifically TFHE.
% \end{itemize}

% \subsection{Notation}
% \begin{itemize}
%     \item $\mathbb{T}$ is the torus.
% \end{itemize}

% \paragraph{RNS variant.} \TODO{}

\section{Additive HE for FHE: Reducing Response Size}
\label{sec:main}

Ciphertexts that have been processed by the server can not be compressed using the technique mentioned in \Cref{sec:background}. We propose a technique to compress LWE/RLWE ciphertexts using auxiliary information provided by the client. These techniques apply to cryptosystems that use LWE/RLWE ciphertexts such as TFHE~\cite{chillotti2020tfhe} and BFV~\cite{fan2012somewhat}, and BGV~\cite{bgv}.

The main insight behind our solution is that the first step of LWE/RLWE decryption is linear in the secret key. Hence, if the client sends encryptions of the bits of the secret key to the server, encrypted under an additive encryption scheme, it can compute the first step of decryption homomorphically and send back only an encrypted scalar to the client. If the additive encryption has small ciphertexts, there is an overall size reduction.

\paragraph{The Additive Encryption Scheme.}
For the compression protocol, we require an additive encryption scheme which we denote $\mathcal{E}_A$ such that the plaintext space is $\ZZ_m$, for some $m$. Specifically, $\mathcal{E}_A$ supports addition and plaintext multiplications. We denote addition and plaintext multiplication with $\oplus$ and $\otimes$, respectively. Moreover, denote the secret key generated by $\mathcal{E}_A$ as $s_A$ and the corresponding encryption and decryption algorithms as $\texttt{AEnc}_{s_A}$ and $\texttt{ADec}_{s_A}$.

Paillier~\cite{paillier} and ElGamal~\cite{elgamal1985public} are examples of cryptosystems that can be used for this purpose.

\subsection{Compressing LWE Ciphertexts}

% Let $s$ be a secret key for the Paillier cryptosystem. Plaintexts in this scheme are in $\ZZ_{m}$ for some $m$.
% Let $\texttt{AEnc}_{s}$ and $\texttt{ADec}_{s}$ denote the encryption and decryption algorithm of Paillier.
The ciphertext compression algorithm for LWE and the corresponding modified decryption algorithm is given below.

\begin{minipage}{0.43\textwidth}
\begin{algorithm}[H]
	 \caption[]{LWECompress}
	 \label{alg:compress-response}
	 \begin{flushleft}
		 % \textbf{Parameters:} $\bar{s_i}={\texttt{Enc}_{sk}(s_i)}$
		 \textbf{Input:} 
   
        \hspace{6mm} $\bar{\texttt{sk}}[i]={\texttt{AEnc}_{s_A}
        (\texttt{sk}[i])}$
   
        \hspace{6mm} $c = (\boldsymbol{a}, b)\in \ZZ_{q}^{n}\times\ZZ$
	 \end{flushleft}
	 \begin{algorithmic}[1]
	 	\State $x = b \oplus \sum_{i=1}^{n} (q-\textbf{a}[i]) \otimes \bar{\texttt{sk}}[i]$
	 \end{algorithmic}
	 \begin{flushleft}
    	 \textbf{Output:}  $x$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}
\begin{minipage}{0.50\textwidth}
\begin{algorithm}[H]
	 \caption[]{ModifiedLWEDecrypt$_{s}$}
	 \label{alg:decrypt-compressed-response}
	 \begin{flushleft}
		 \textbf{Input:} Compressed Ciphertext $x$
	 \end{flushleft}
	 \begin{algorithmic}[1]
	 	\State $y = \texttt{ADec}_{s}(x)$
	 	\vspace{2mm}
	 	\State $ \mu' = \lfloor \frac{y \mod q}{\Delta} \rceil$
	 \end{algorithmic}
  \vspace{1mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $\mu' \in \ZZ_{p}$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\end{minipage}

\begin{theorem}[Correctness]
    If $m>q+nq^2$, \Cref{alg:compress-response} produces a compressed ciphertext which decrypts to the correct message using \Cref{alg:decrypt-compressed-response}. More formally, 
\begin{align}\normalfont
    \text{ModifiedLWEDecrypt}_s(\text{LWECompress}(\bar{\texttt{sk}}, c)) = \text{LWEDecrypt}_{\texttt{sk}}(c)
\end{align}

\end{theorem}

\begin{proof}
In line 1 of \Cref{alg:compress-response}, we calculate 
$b + \sum_{i=1}^{n} (q-a[i]) \cdot \texttt{sk}[i]$, encrypted under additive encryption, which is achievable due to linear properties. We know that $\texttt{sk}[i], a[i]$ and $b$ are elements in $\ZZ_q$ so $0 \leq \texttt{sk}[i], a[i], b < q$ and 
\begin{align}
    b + \sum_{i=1}^{n} (q-a[i]) \cdot \texttt{sk}[i] \leq q + \sum_{i=1}^{n} q  \cdot q = q + nq^2 < m .
\end{align}
So there is no overflow in the plaintext space. In the Modified Decryption (\Cref{alg:decrypt-compressed-response}), we have
\begin{align}
    y\mod q &= \texttt{ADec}_{s}(x) \mod q \\
    &= \left((b + \sum_{i=1}^{n} (q-a[i]) \cdot \texttt{sk}[i]) \mod m \right) \mod q \\
    &= \left(b + \sum_{i=1}^{n} (q-a[i]) \cdot \texttt{sk}[i] \right) \mod q \\
    &= b - \sum_{i=1}^{n} a[i] \cdot \texttt{sk}[i] \mod q = \mu^*
\end{align}

This is identical to $\mu^*$ in line 1 of \Cref{alg:lwe-decrypt}, hence, since the subsequent steps of \Cref{alg:lwe-decrypt} and \Cref{alg:decrypt-compressed-response} are similar, they produce the same response, and the theorem is proven.

\end{proof}

\paragraph{Security.}
In Gentry's original construction of a bounded depth encryption scheme, he proposed the idea of using a chain of semantically secure cryptosystems, such that each cryptosystem encrypts the secret key of the next~\cite{homenc}. Gentry proved that if the secret key of each cryptosystem is sampled independently, the composed scheme is also semantically secure.

Let $\mathcal{E}'$ denote the cryptosystem which is the combination of $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_{A}$. The encryption and decryption procedure of $\mathcal{E}'$ is \Cref{alg:lwe-encrypt} and \Cref{alg:decrypt-compressed-response}, respectively. The secret key of $\mathcal{E}'$ is the combination of the secret keys of $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_{A}$. The same holds for the public key as well. Moreover, we also release encryptions of the bits of the secret key of $\mathcal{E}_{\text{LWE}}$ under the secret key of $\mathcal{E}_{A}$. 

\begin{proposition}[Security]
    If $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_A$ are semantically secure, then $\mathcal{E}'$ is also semantically secure.
\end{proposition}

% \paragraph{Analysis.}
% \begin{itemize}
%     \item The compressed response size consists of two elements in $m^2$, so the overall size is $2\log_2 m$, compared to before which was $(n+1)\log_2 q$.
%     \item The size of the key
% \end{itemize}


% \begin{itemize}
%     \item The format of an LWE ciphertext is (\textbf{a},b), where a is a vector.
%     \item The first step in LWE decryption is linear. So if we provide encryptions of the bits of the secret key, we can calculate this linear part and only send back Enc(b-as), which is only ciphertext encrypted under the new encryption scheme.
%     \item This only works if the secondary encryption scheme has semantic security, and offers an improvement in the communication only if the secondary encryption scheme has a lower expansion factor compared to the original scheme.
%     \item Examples of schemes that have these properties are Paillier and ElGamal.
%     % \item There are two disadvantages 1) the server has an additional overhead compared to compute Enc(b-as) 2) The aforementioned schemes are not quantum secure the way that Regev is.
%     \item 
% \end{itemize}

% \begin{itemize}
%     \item We implement a basic version of the scheme in Python consisting of encryption and decryption. We implement the compression and decryption of the compressed ciphertext using Python-Paillier, which implements the Paillier encryption system in Python.
% \end{itemize}

\subsection{Compressing RLWE Ciphertexts}
\label{sec:rlwe-compression}

The expansion factor of RLWE ciphertexts does not depend on $N$ and is much smaller than the expansion factor of LWE ciphertexts.
Hence, the same technique used in the previous section does not yield an improvement. However, our approach is beneficial if the user is only interested in some coefficients of the plaintext polynomial and not all of them.

The main observation is that each coefficient of $\mu'(X)$ in \Cref{alg:rlwe-decrypt} can be calculated separately. Specifically, for $0\leq k \leq N-1$

\begin{align}
    \mu'[k] = \lfloor\frac{\mu^*[k]}{\Delta}\rceil 
    = \left\lfloor \frac{B[k] - \sum_{i=0}^{k} A[k-i] \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]}{\Delta} \right\rceil
    \label{eq:rlwe-extract-general}
\end{align}

Note that the operations in the numerator are happening modulo $q$. The numerator of \Cref{eq:rlwe-extract-general} is a linear combination of the coefficients of the secret key, hence it can be computed given the encrypted coefficients of the secret key.

The complete procedure to compress the $k^{th}$ coefficient of an RLWE ciphertext is shown in \Cref{alg:rlwe-compress-response}. The corresponding decryption function is shown in \Cref{alg:rlwe-decrypt-compressed-response}.

\begin{algorithm}[H]
	 \caption[]{RLWECompress}
	 \label{alg:rlwe-compress-response}
	 \begin{flushleft}
		 \textbf{Input:} 
   
        \hspace{6mm} $\bar{\texttt{sk}}[i]={\texttt{AEnc}_{s_A}
        (S[i])}$
   
        \hspace{7mm} $C = (A(X), B(X)) \in R_q\times R_q$

        \hspace{7mm} $k \in \{0,1,\cdots, N-1\}$
	 \end{flushleft}
	 \begin{algorithmic}[1]
	 	\State $x = B[k] \oplus \left(\sum_{i=0}^{k} (q-A[k-i]) \otimes \bar{\texttt{sk}}[i]\right)
        \oplus \left(\sum_{i=k+1}^{N-1} A[N+k-i] \otimes \bar{\texttt{sk}}[i]\right)$
	 \end{algorithmic}
	 \begin{flushleft}
    	 \textbf{Output:}  $x$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}
\vspace{-15mm}
\begin{algorithm}[H]
	 \caption[]{ModifiedRLWEDecrypt$_{s}$}
	 \label{alg:rlwe-decrypt-compressed-response}
	 \begin{flushleft}
		 \textbf{Input:} Compressed Ciphertext $x$
	 \end{flushleft}
	 \begin{algorithmic}[1]
	 	\State $y = \texttt{ADec}_{s}(x)$
	 	\vspace{2mm}
	 	\State $ \mu'_k= \lfloor \frac{y \mod q}{\Delta} \rceil$
	 \end{algorithmic}
  \vspace{1mm}
	 \begin{flushleft}
    	 \textbf{Output:}  $\mu'_k \in \ZZ_{p}$\\
	 \end{flushleft}
  \vspace{-3mm}
\end{algorithm}


\begin{theorem}[Correctness]
    If $m > q + N q^2$, \Cref{alg:rlwe-compress-response} produces a compressed ciphertext which decrypts to the $k^{th}$ coefficient  of the plaintext using \Cref{alg:rlwe-decrypt-compressed-response}. More formally, 
\begin{align}\normalfont
    \text{ModifiedRLWEDecrypt}_s(\text{RLWECompress}(\bar{\texttt{sk}}, c, k))
\end{align}
is equal to the $k^{th}$ coefficient of 
\begin{align}\normalfont
    \mu'(X) = \text{RLWEDecrypt}_{\texttt{sk}}(c)
\end{align}
\end{theorem}

\begin{proof}

Line 1 of \Cref{alg:rlwe-compress-response} computes 
$$
B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\
$$
encrypted under additive encryption, which is possible due to the linear properties.
We know that all coefficients of $A(X)$, $B(X)$, and $S(X)$ are elements in $\ZZ_q$, hence
\begin{align}
    B[k] + \left(\sum_{i=0}^{k} (q-A[k-i]) \cdot S[i]\right)
    + \left(\sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right)\\
    \leq q + \left(\sum_{i=0}^{k} q \cdot q\right) + \left(\sum_{i=k+1}^{N-1} q \cdot q\right)
    = q + Nq^2 \leq m
\end{align}
so there is no overflow in the plaintext space of the additive cryptosystem.

\begin{align*}
    & y\mod q ~ = ~ \texttt{ADec}_{s}(x) \mod q \\
    & = \left(\left(B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right) \mod m\right) \mod q \\
    & = \left( B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right) \mod q \\
    & = B[k] - \sum_{i=0}^{k} A[k-i] \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i] \mod q
\end{align*}

which is equivalent to the $k^{th}$ coefficient of 
$$
    \mu^*(X) = B(X) - A(X) \cdot S(X) \mod R_q
$$
which can be seen by expanding the equation. Given that line 2 of \Cref{alg:rlwe-decrypt} performs rounding coefficient-wise, it produces the same result as line 1 of \Cref{alg:rlwe-decrypt-compressed-response}.

\end{proof}

\paragraph{Security.} A similar argument can be made about the security of compression over RLWE. Let $\mathcal{E}''$ denote the cryptosystem which is the combination of $\mathcal{E}_{RLWE}$ and $\mathcal{E}_{A}$. The following proposition holds regarding security.

\begin{proposition}[Security]
    If $\mathcal{E}_{RLWE}$ and $\mathcal{E}_A$ are semantically secure, then $\mathcal{E}''$ is also semantically secure.
\end{proposition}

\subsection{Batched Compression}
If the plaintext space of the additive encryption is large, multiple LWE ciphertexts (encrypted using the same secret key) can be compressed within the same additive ciphertext. Each LWE ciphertext takes up $\log_2 (q+nq^2)$ bits of the total bitwidth of the plaintext space. So, if $m$ is the modulus of the plaintext space, then $\floor{\log_2 m / \log_2 (q+nq^2)}$ LWE ciphertexts can be compressed into one ciphertext from the additive cryptosystem.

Similarly, many coefficients of an RLWE ciphertext can be extracted and compressed into one additive ciphertext. Specifically, since each RLWE coefficient takes up to $\log_2 (q+Nq^2)$ of the bitwidth, then $\floor{\log_2 m / \log_2 (q+Nq^2)}$ coefficients can be extracted simultaneously.


\section{Evaluation}

To evaluate our technique, we implement the compression and modified decryption algorithm using the Paillier cryptosystem~\cite{paillier} as the additive encryption system. Paillier is an additive homomorphic cryptosystem with semantic security so it satisfies all the requirements for correctness and security. We demonstrate the compression protocol over a prototype implementation and an existing library, OpenFHE.

\paragraph{Prototype Implementation.}
We implement the two cryptosystems proposed in \Cref{sec:lwe} and \ref{sec:rlwe} in Python and  implement compression using the Python-Paillier\footnote{https://github.com/data61/python-paillier} library~\cite{PythonPaillier}. We use a 3072-bit modulus for Paillier which is the recommended modulus size for 128-bit security. We use two parameter sets for LWE and four parameter sets for RLWE. All parameter sets are chosen to satisfy 128-bit security. In the evaluation of LWE compression, one ciphertext is compressed. In the evaluation of RLWE, one coefficient of the RLWE ciphertext is extracted and compressed. The results for LWE and RLWE are shown in \Cref{tab:evaluation-lwe-compress} and  \Cref{tab:evaluation-rlwe-compress}, respectively.

\paragraph{OpenFHE integration.}
We also integrate this technique into the OpenFHE framework~\footnote{https://github.com/openfheorg/openfhe-development} which implements multiple homomorphic cryptosystems such as BGV, CKKS, and CGGI. We apply compression to CGGI ciphertexts which have ciphertext similar to the format described in \Cref{sec:lwe}. Currently, OpenFHE only offers one parameter set for the CGGI cryptosystem which offers 128-bit security.
We use the Intel Paillier Cryptosystem Library \footnote{https://github.com/intel/pailliercryptolib} as the additive cryptosystem, which implement Paillier encryption. The plaintext modulus of this implementation is 2048 bits.

\begin{table}[!ht]
    \centering
    ~\clap{
    \begin{tabular}{c|c|c|c}
    \toprule
         & \multicolumn{2}{c|}{LWE (Prototype)} & \multicolumn{1}{c}{~CGGI (OpenFHE)~}\\
         & \begin{tabular}{c} $n=630$\\$\log_2 q=64$ \end{tabular}
         & \begin{tabular}{c} $n=750$\\$\log_2 q=64$ \end{tabular}
         & \begin{tabular}{c} $n=1305$\\$\log_2 q=11$ \end{tabular}
         \\
    \midrule
        Encrypt Secret Key (Time)     & 28 s    & 33 s   & 0.15 s\\
        Encrypted Secret Key          & 483 KB  & 575 KB & 669 KB \\
        \midrule
        Ciphertext Compression Time   & 0.67 s  & 0.79 s & 0.31 s \\
        Compressed Ciphertext Size    & 768 B   & 768 B  & 525 B\\
        Uncompressed Ciphertext Size  & 5 KB    & 6 KB   & 10.25 KB \\
        Size Reduction            & \textbf{86 \%} & \textbf{87.2 \%} & \textbf{95.0\%} \\
    \bottomrule
    \end{tabular}
    }
    \vspace{4mm}
    \caption{Evaluation of the ciphertext compression technique for a single LWE ciphertext. Two sample parameter sets are chosen for prototype LWE. We use the STD128 configuration for CGGI in OpenFHE.}
    \label{tab:evaluation-lwe-compress}
\end{table}



\begin{table}[!ht]
    \centering
    ~\clap{
    \begin{tabular}{c|c|c|c|c}
    \toprule
         & \multicolumn{4}{c}{RLWE (Prototype)}\\
         & \begin{tabular}{c} $N=1024$\\$\log_2 q=27$ \end{tabular}
         & \begin{tabular}{c} $N=2048$\\$\log_2 q=54$ \end{tabular}
         & \begin{tabular}{c} $N=4096$\\$\log_2 q=36$ \end{tabular}
         & \begin{tabular}{c} $N=8192$\\$\log_2 q=43$ \end{tabular}
         \\
    \midrule
        Encrypt Secret Key (Time)     & 45 s   & 90 s    & 182 s    & 369 s  \\
        Encrypted Secret Key          & 786 KB & 1572 KB & 3145 KB  & 6290 KB  \\
        \midrule
        Ciphertext Compression Time   & 0.50 s & 1.77 s  & 2.52 s   & 5.97 s  \\
        Compressed Ciphertext Size    & 767 B  & 767 B   & 767 B    & 767 B \\
        Uncompressed Ciphertext Size  & 2.5 KB & 5.6 KB  & 12.3 KB  & 26.6 KB \\
        Size Reduction            & \textbf{70.0\%} & \textbf{86.36\%} & \textbf{93.75\%} & \textbf{97.11\%}  \\
    \bottomrule
    \end{tabular}
    }
    \vspace{4mm}
    \caption{Evaluation of the ciphertext compression technique for a single RLWE coefficient. Four sample parameter sets are chosen for the prototype RLWE implementation.}
    \label{tab:evaluation-rlwe-compress}
\end{table}

\paragraph{Results.}
The evaluation shows significant size reduction for all parameter sets. There is at least 86\% reduction for the evaluated parameter sets for LWE and up to 95\% for CGGI in OpenFHE. Similarly, for RLWE, there is up to 97\% size reduction using the compression technique.

Encryption of the LWE/RLWE secret key using Paillier, which is more expensive, is only performed once. Moreover, the encrypted secret key is still small compared to other keys used in FHE, e.g. public keys, key-switching keys and bootstrapping keys, which can be as large as many megabytes.

% \subsection{RLWE Compression}

% As discussed in \Cref{sec:rlwe-compression}, more coefficients can also be extracted, packed into the additive ciphertext and sent to the client. However, if a large number of coefficients is required, sending the uncompressed ciphertext results in lower communication.

% \begin{figure}
%     \centering
%     ~\clap{
%         \includegraphics[width=2\textwidth]{fig.png}
%     }
%     \caption{Caption}
%     \label{fig:my_label}
% \end{figure}

% In the extended version, we show the point at which the compression algorithm is not beneficial. For example, for $N=4096,8192$, if more than 325 and 600 coefficients are extracted, respectively, the compression algorithm does not reduce the ciphertext size.


\section{Discussion}

\subsection{Related work}
Our work is the first to address large ciphertext sizes with this particular technique. However, there exist relevant concepts in the literature.
Below, we describe these concepts and how they can relate to this work.

\paragraph{Scheme Switching.}
Scheme switching has previously been proposed in the literature but was not used as an approach to reduce the size of ciphertexts.

Gentry et al. use scheme switching as an alternative to squashing the decryption circuit in the bootstrapping process~\cite{squash-scheme-switch}. They switch the scheme to ElGamal which is a multiplicative encryption scheme.

Boura et al. propose scheme switching as a method to benefit from the features of many cryptosystems and not be confined to one~\cite{chimera}. They provide procedures to switch between many lattice-based schemes such as BFV, TFHE, and CKKS. All of the schemes that they switch between are based on the LWE and RLWE hardness assumptions.

\paragraph{Modulus Switching.}
Modulus switching is a technique used for many purposes. First, it can be used as a method to limit noise growth in lattice-based homomorphic schemes. This technique was first proposed by Brakerski and Vaikuntanathan~\cite{bv-mod-switch} and subsequently used by Brakerski et al. to construct the BGV cryptosystem~\cite{bgv}.

In later work, this technique was frequently used as a method to reduce the size of ciphertexts before they are communicated back to the client. Using our notation from \Cref{sec:rlwe}, this technique results in a smaller $q$. However, this technique is limited by the fact that the size of the ciphertext is still linear in $N$, which significantly impacts the size of the ciphertext.

\paragraph{RLWE Coefficient Extraction.}
TFHE~\cite{chillotti2020tfhe} supports coefficient extraction over RLWE ciphertexts. This allows the server to extract one coefficient of the underlying plaintext of an RLWE ciphertext as an LWE ciphertext. This technique is useful for the purpose of bootstrapping. It has not been proposed as a method for size reduction.

Coefficient extraction can be used in combination with our techniques. For example, the desired coefficient in an RLWE ciphertext can be extracted into an LWE ciphertext, and then LWE compression can be used. However, using compression over RLWE ciphertexts, we can directly compress the RLWE coefficient without the need to initially perform coefficient extraction.

\subsection{Applications.}
Large ciphertext sizes are an obstacle in the practical deployment of many applications using FHE. Here we identify two specific use cases of FHE where our compression techniques can be applied.

\paragraph{Filters over Encrypted Images.}

The compression of LWE ciphertexts is suitable for applications where the output is large, such as applying a filter on an encrypted image. For example, Signal offers a tool to blur faces for the privacy and safety of individuals in images~\cite{signal-blur}. Currently, this feature runs locally on the client's device. However, to reduce overhead on small devices, the client can send the encrypted image to the server to process and receive the response. This situation is a suitable fit for FHE since the client device can establish cryptographic keys with the server and reuse them many times.

Applying filters over encrypted images has also been implemented using the Concrete library~\cite{concrete-image}. They encode the image as an array of LWE ciphertexts, which makes it ideal for compression using our proposed algorithm.

\paragraph{Private Data Analysis.}
Circuit-PSI and Private Decision Tree Evaluation are two examples of data analysis over private data.

In Circuit-PSI, the server computes a function of the intersection of the client encrypted set with its own private set. In the protocol proposed by Kacsmar et al.~\cite{dipsi}, the client's set is encrypted as an RLWE ciphertext. The response, however, is small and only occupies one coefficient slot. This is an ideal application of the compression technique over RLWE ciphertexts.

In Private Decision Tree Evaluation, the server evaluates a decision tree over the client's private, encrypted input. Cong et al. \cite{sortinghats} propose a protocol which encrypts the client's input as multiple LWE ciphertexts and returns the result of the classification as an LWE ciphertext. Compression can be applied to this application as well.

\bibliographystyle{alpha}
\bibliography{references}

\end{document}
