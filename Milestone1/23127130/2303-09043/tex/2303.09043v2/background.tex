\section{Background}
\label{sec:background}

In this section and throughout the paper, we index the i$^{th}$ element of the vector $\textbf{a}$ as $\textbf{a}[i]$.
We also define $[n]=\{0,1,\cdots,n-1\}$ and $\lfloor\cdot\rceil$ denotes rounding to the nearest integer.
$x\leftarrow D$ denotes the variable $x$ sampled from a distribution $D$ and $x\sample S$ denotes sampling $x$ uniformly from a set $S$.

\subsection{Homomorphic Encryption}
Homomorphic Encryption (HE) is a form of public-key cryptography which permits computation on messages while in encrypted form, without the need to access the secret key. Similar to other public-key cryptosystems, homomorphic ciphertexts are larger than the underlying plaintext.
The ratio between the ciphertext and plaintext is denoted as the \textit{expansion factor}.

Homomorphic encryption is typically used to construct a one-round protocol between a client and a server.
The client encrypts its private input homomorphically and sends the resulting ciphertexts to a server.
This constitutes the client's \textit{request}. The server computes the desired function over the client's encrypted input. The result is then transmitted back to the client as the \textit{response}. 
This work addresses the large response size and aim to reduce it.

\subsection{LWE \& RLWE ciphertexts}
\label{sec:lwe}

\begin{algorithm}[t]
     \caption{Encryption and Decryption of $\mathcal{E}_{LWE}$}
     \label{alg:lwe-encrypt-decrypt}
     \begin{algorithmic}[1]
        \vspace{1mm}
        \Procedure{LWEEncrypt}{$\texttt{sk}, \mu$}
        \State Sample $\textbf{a}\xleftarrow{\$} \ZZ_q^{n}$ and $e \leftarrow \chi$
        \vspace{1mm}
        \State $b = \sum_{i\in[n]} \textbf{a}[i] \cdot \texttt{sk}[i] + \Delta \cdot \mu + e \mod q$
        \vspace{2mm}
        \State \Return $\ct=(\textbf{a},b)$
        \EndProcedure
        \vspace{3mm}
        \Procedure{LWEDecrypt}{$\texttt{sk}, \ct=(\textbf{a},b)$}
        \State $\mu^* = \left(b - \sum_{i\in[n]} \textbf{a}[i] \cdot \texttt{sk}[i]\right) \mod q $
        \vspace{1mm}
        \State $\mu'=\lfloor\mu^* / \Delta\rceil$
        \vspace{2mm}
        \State \Return $\mu'$
        \EndProcedure
        \vspace{3mm}        
        \Procedure{RLWEEncrypt}{$S(X), \mu(X)$}
        
        \State Sample $A(X)\xleftarrow{\$} R_q$ and $E(X) \leftarrow \chi$
        \vspace{2mm}
        \State $B(X) = A(X)\cdot S(X) + \Delta \cdot \mu(X) + E(X) \mod R_q$
        \State \Return $C=(A(X), B(X))$
        \EndProcedure

        \vspace{3mm}
        
        \Procedure{RLWEDecrypt}{$S(X), C$}
        \State $(A(X), B(X)) \leftarrow C$
        \vspace{1mm}
        \State $\mu^*(X) = (B(X) - A(X)\cdot S(X)) \mod R_q$
        \vspace{2mm}
        \State $\mu'(X)=\lfloor\mu^*(X)/\Delta\rceil$
        \vspace{2mm}
        
        \State \Return $\mu'(X)\in R_p$
        \EndProcedure     
     \end{algorithmic}
\end{algorithm}

For this work, we describe a simple version of an encryption system based on the Learning With Errors (LWE)~\cite{regevLatticesLearningErrors2009} assumption which we will denote by $\mathcal{E}_{\text{LWE}}$. The most prominent encryption schemes that have ciphertext of this format are Regev~\cite{regevLatticesLearningErrors2009}, FHEW~\cite{ducasFHEWBootstrappingHomomorphic2015}, and TFHE(CGGI)~\cite{chillottiTFHEFastFully2020}.

$\mathcal{E}_{\text{LWE}}$ uses the following parameters:
dimension $n$, ciphertext modulus $q$, plaintext modulus $p$, $\Delta=\round{q/p}$, a discrete error distribution over $\ZZ_q$ called $\chi$. We sample the secret key, $\texttt{sk}$, from $\ZZ_q^{n}$. The encryption and decryption procedure for $\mathcal{E}_{LWE}$ is shown in \Cref{alg:lwe-encrypt-decrypt}.

% \paragraph{Compressing Fresh Ciphertexts.}
Fresh ciphertexts can be compressed to reduce network costs. Since $\textbf{a}$ is sampled at random, we can send the seed used to generate $\textbf{a}$ instead of the vector itself. Concretely, instead of sending $c=(\textbf{a},b)$, the client can produce $\bar{c}=(\theta,b)$ where $\theta\leftarrow\{0,1\}^{\lambda}$ is the seed of a cryptographically secure PRG used to generate $\textbf{a}$, i.e., $\textbf{a}\leftarrow \texttt{PRG}(\theta)$. With this technique, fresh ciphertexts are only $\lambda+\log_2 q$ bits instead of $n\log_2 q$.

% \subsection{RLWE ciphertexts}
% \label{sec:rlwe}
Similar to LWE, we can also construct an encryption scheme based on the Ring Learning with Errors (RLWE)~\cite{lyubashevskyIdealLatticesLearning2010} assumption, which we will denote as $\mathcal{E}_{\text{RLWE}}$. Cryptosystems such as BGV~\cite{brakerskiLeveledFullyHomomorphic2012}, BFV~\cite{brakerskiFullyHomomorphicEncryption2012,fan2012somewhat}, and CKKS~\cite{cheonHomomorphicEncryptionArithmetic2017a} have ciphertexts of a similar format.
RLWE ciphertexts are useful since they can encrypt a polynomial, i.e. a vector of numbers, instead of just one scalar. For RLWE encryption, we select a dimension $N$, ciphertext modulus $q$, plaintext modulus $p$, and $\Delta=\round{q/p}$. Define $R_q=\ZZ_q[X]/(X^N+1)$ and $R_p$ similarly. Moreover, define a discrete error distribution $\chi$ over $R_q$.
For key generation, sample $S(X)$ uniformly from $R_q$.

% \paragraph{Compressing Fresh RLWE ciphertexts.}
Similar to LWE, we can also compress fresh RLWE ciphertexts by sending the seed used to generate $A(X)$~\cite{aliCommunicationComputationTradeoffs2021a, MicrosoftSEALRelease2023, albadawiOpenFHEOpenSourceFully2022}. Using this technique, the size of a ciphertext can be reduced from $2N\log_2 q$ bits to $\lambda + N\log_2 q$.

\subsection{Private Information Retrieval}
Private Information Retrieval (PIR) is a protocol where a client retrieves an element from a database such that the query is not revealed.
A specific variant of PIR is PIR-with-preprocessing which consists of four routines.

\begin{itemize}
    \item $\hint \leftarrow \textsc{Setup}(\db)$ : Create database-dependant hint
    \item $(\pirstate, \qu) \leftarrow \textsc{Query}(i)$ : Generates the client query
    \item $\ans \leftarrow \textsc{Response}(\db, \hint, \qu)$ : Computes response
    \item $d \leftarrow \textsc{Extract}(\pirstate, \ans)$ : Extracts result from response
\end{itemize}

PIR-with-preprocessing allows the server to perform most of the preprocessing offline such that the online stage is very fast. 
Note that our definition is slightly relaxed compared to previous definitions ~\cite{henzingerOneServerPrice2023, beimelReducingServersComputation2000} as it does not generate a client-specific hint.

\begin{definition}[Correctness]
    A PIR protocol with preprocessing consisting of the four aforementioned routines is $\delta$-correct, if for a domain $\mathcal{D}$, any database $\db\in \mathcal{D}^{N}$ and any $i\in[N]$, 
    \begin{align}
    \PP\left[\db[i] = f \middle|
        \begin{array}{c}
            \hint \leftarrow \textsc{Setup}(\db) \\
            (\st, \qu) \leftarrow \textsc{Query}(i) \\
            \ans \leftarrow \textsc{Respond}(\db, \hint, \qu) \\
            f \leftarrow \textsc{Extract}(\st, \ans)
        \end{array}
    \right] > 1-\delta
    \end{align}.
\end{definition}

Intuitively, the query should not reveal any information about the record that it is querying. This is formalized in the following definition.
\begin{definition}[Security]
     A PIR protocol is $\epsilon$-secure if for any PPT adversary $\adv$ and any $i,j\in[N]$,
    \begin{align}
        | \PP[\adv&(1^N, \qu) = 1 | (\st, \qu) \leftarrow \textsc{Query}(i) ] \\
        & - \PP[\adv(1^N, \qu) = 1 | (\st, \qu) \leftarrow \textsc{Query}(j) ] | \leq \epsilon
    \end{align}
\end{definition}