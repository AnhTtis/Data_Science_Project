\section{Additive HE for Smaller FHE Responses}
\label{sec:main}

Ciphertexts that have been processed by the server can not be compressed using the technique mentioned in \Cref{sec:background}. We propose a technique to compress LWE/RLWE ciphertexts using auxiliary information provided by the client.
% These techniques apply to cryptosystems that use LWE/RLWE ciphertexts such as TFHE~\cite{chillottiTFHEFastFully2020} and B/FV~\cite{fan2012somewhat,brakerskiFullyHomomorphicEncryption2012}, and BGV~\cite{brakerskiLeveledFullyHomomorphic2012}.

\emph{Exploiting Linear Phase Evaluation.}
In LWE and RLWE decryption, we compute an intermediate value which is commonly referred to as the \textit{phase}, i.e., $\mu^*$ and $\mu^*(X)$ in \Cref{alg:lwe-encrypt-decrypt}.
Phase evaluation is linear in both schemes and the phase is much smaller than the ciphertext itself.
The main insight behind our solution is to homomorphically compute the phase on the server using encrypted values of the secret key, encrypted under an additive encryption scheme.
Since the phase is much smaller than the original ciphertext, this results in a smaller response size.
In general, our technique can be applied to any encryption scheme that has a linear phase evaluation. Examples of encryption schemes with this property are Regev~\cite{regevLatticesLearningErrors2009}, FHEW~\cite{ducasFHEWBootstrappingHomomorphic2015}, TFHE~\cite{chillottiTFHEFastFully2020}, BFV~\cite{fan2012somewhat,brakerskiFullyHomomorphicEncryption2012}, and BGV~\cite{brakerskiLeveledFullyHomomorphic2012}.

% The main insight behind our solution is that the first step of LWE/RLWE decryption is linear in the secret key. Hence, if the client sends encryptions of the bits of the secret key to the server, encrypted under an additive encryption scheme, it can compute the first step of decryption homomorphically and send back only an encrypted scalar to the client. If the additive encryption has small ciphertexts, there is an overall size reduction.

\emph{The Additive Encryption Scheme.}
For the compression protocol, we require an additive encryption scheme which we denote $\mathcal{E}_A$ such that the plaintext space is $\ZZ_m$, for some $m$.
Also, denote the ciphertext space of $\mathcal{E}_A$ as $\mathcal{C}$.
$\mathcal{E}_A$ supports addition and plaintext multiplications.
We denote addition and plaintext multiplication with $\oplus$ and $\otimes$, respectively.
Moreover, denote the secret key generated by $\mathcal{E}_A$ as $\addkey$ and the corresponding encryption and decryption algorithms as $\texttt{AEnc}$ and $\texttt{ADec}$.

Paillier~\cite{paillierPublicKeyCryptosystemsBased1999}, Damgard-Jurik~\cite{damgardGeneralisationSimplificationApplications2001a}, Exponential ElGamal~\cite{elgamalPublicKeyCryptosystem1985}, and Benaloh~\cite{benalohDenseProbabilisticEncryption1994} are examples of cryptosystems that can be used for this purpose.

\subsection{Compressing LWE Ciphertexts}

% Let $s$ be a secret key for the Paillier cryptosystem. Plaintexts in this scheme are in $\ZZ_{m}$ for some $m$.
% Let $\texttt{AEnc}_{s}$ and $\texttt{ADec}_{s}$ denote the encryption and decryption algorithm of Paillier.
The ciphertext compression algorithm for LWE and the corresponding modified decryption algorithm is given in \Cref{alg:lwe-compress}.

\begin{algorithm}[H]
    \caption{LWE compression, performed by the server and the corresponding modified decryption process, performed by the client over a compressed ciphertext. The compression key $\ck\in\mathcal{C}^{n}$ is such that $\ck[i]=\texttt{AEnc}(\addkey, \sk[i])$.}
    \label{alg:lwe-compress}
    \begin{algorithmic}[1]
        \Procedure{LWECompress$_{q}$}{$\ck, \ct=(\textbf{a},b)$}
        \Comment{$\ct\in\ZZ^{n}\times\ZZ$}
        \State $x=b$
        \For{$i \in [n]$} 
            \State $x \leftarrow x \oplus \left( (q-\textbf{a}[i]) \otimes \ck[i] \right)$\label{alg:line-multiply}
        \EndFor
        \State \Return $x$ \Comment{$\mu^*=\texttt{ADec}(\addkey, x)$}
        \EndProcedure
    \vspace{3mm}
    \Procedure{ModifiedLWEDecrypt$_{q, p}$}{$\addkey,x$}
	 	\State $\mu^{**} = \texttt{ADec}(\addkey, x) \mod q$
            \label{alg:lwe-mod-decrypt}
	 	\vspace{1mm}
	 	\State $ \mu'' = \lfloor \mu^{**}/\Delta\rceil$
            \Comment{$\Delta=\round{q/p}$}
            \vspace{2mm}
            \State \Return $\mu'' \in \ZZ_{p}$
   \EndProcedure
   \end{algorithmic}
\end{algorithm}

\begin{theorem}[Correctness]
\label{thm:lwe-compress-correct}
    For an LWE ciphertext $\ct\in\ZZ_q^{n+1}$, if $m>q+nq^2$, then $\textsc{LWECompress}_q$ produces a compressed ciphertext which decrypts to the correct message if decrypted using \textsc{ModifiedLWEDecrypt}. More formally, if 

\begin{align*}
    x\leftarrow\textsc{LWECompress}_{q}(\ck, \ct) \\
    \mu'' \leftarrow \textsc{ModifiedLWEDecrypt}_{q,p}(\addkey, x)
\end{align*}
then
$\mu'' = \textsc{LWEDecrypt}(\sk, \ct)$
\end{theorem}

\begin{proof}
In the \textsc{ModifiedLWEDecrypt}$_{q,p}$ procedure (\Cref{alg:lwe-mod-decrypt} of \Cref{alg:lwe-compress}), we calculate 
$b + \sum_{i\in[n]} (q-\textbf{a}[i]) \cdot \sk[i]$, encrypted under additive encryption, which is achievable due to the linear properties of the additive encryption. We know that $\sk[i], \textbf{a}[i]$ and $b$ are elements in $\ZZ_q$ so $0 \leq \sk[i], \textbf{a}[i], b < q$ and 

{\footnotesize
\begin{align}
    b + \sum_{i\in[n]} (q-\textbf{a}[i]) \cdot \sk[i] \leq q + \sum_{i\in[n]} q  \cdot q = q + nq^2 < m .
\end{align}
}

so there is no overflow in the plaintext space of the additive ciphertext.
In $\textsc{ModifiedLWEDecrypt}_{q,p}$ (\Cref{alg:lwe-compress}), we have

{\footnotesize
\begin{align*}
    \mu^{**}\mod q &= \texttt{ADec}(\addkey, x) \mod q \\
    &= \left((b + \sum_{i\in[n]} (q-\textbf{a}[i]) \cdot \sk[i]) \mod m \right) \mod q \\
    &= \left(b + \sum_{i\in[n]} (q-\textbf{a}[i]) \cdot \sk[i] \right) \mod q \\
    &= b - \sum_{i\in[n]} \textbf{a}[i] \cdot \sk[i] \mod q
\end{align*}
}

This is identical to $\mu^*$ in line 1 of \Cref{alg:lwe-encrypt-decrypt}, hence, since the subsequent steps of \textsc{LWEDecrypt} and \textsc{ModifiedLWEDecrypt} are identical, they produce the same response, and the theorem is proven.
\end{proof}

In cryptosystems such as TFHE~\cite{chillottiTFHEFastFully2020}, the secret key is sampled from a binary distribution.
In such a case, we can tighten the inequality required in \Cref{thm:lwe-compress-correct} for correctness because $0\leq\sk[i]\leq 1$. The following corollary summarizes this fact.

\begin{corollary}
    If the LWE secret key is binary and $m>q+nq$, \textsc{LWECompress} produces a compressed ciphertext which decrypts to the correct message if decrypted using \textsc{ModifiedLWEDecrypt}.
\end{corollary}

% \emph{Security.}
In Gentry's original construction of a bounded depth encryption scheme, he proposed the idea of using a chain of semantically secure cryptosystems, such that each cryptosystem encrypts the secret key of the next~\cite{gentryFullyHomomorphicEncryption2009}. Gentry proved that if the secret key of each cryptosystem is sampled independently, the composed scheme is also semantically secure.

Let $\mathcal{E}'$ denote the cryptosystem which is the chaining of $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_{A}$. The encryption and decryption procedure of $\mathcal{E}'$ is shown in \Cref{alg:lwe-encrypt-decrypt} and \Cref{alg:lwe-compress}, respectively. The secret key of $\mathcal{E}'$ is the combination of the secret keys of $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_{A}$. The same holds for the public key as well. Moreover, we also release encryptions of the bits of the secret key of $\mathcal{E}_{\text{LWE}}$ under the secret key of $\mathcal{E}_{A}$. 

\begin{proposition}[Security]
    If $\mathcal{E}_{\text{LWE}}$ and $\mathcal{E}_A$ are semantically secure, then $\mathcal{E}'$ is also semantically secure.
\end{proposition}

\subsection{Using Smaller Compression Keys}
\label{sec:smaller-compression-key}
In practice, the plaintext space of the additive encryption system could be much larger than is required for the correctness of the compression technique to hold, i.e., $m \gg q + n q^2$.
For example, the plaintext space of Paillier for 128-bit security is 3072 bits, which is much larger than $q + n q^2$ for any common choice of LWE parameters.
We can use this gap to pack multiple bits of the LWE secret key within one additive ciphertext.
Instead of encrypting each bit of the LWE key separately, we encrypt the first $t$ bits of the secret key together into one packed additive ciphertext as $\texttt{pck}_{0-t} = \texttt{AEnc}(\addkey, \sum_{i\in[t]}\sk[i] \cdot \delta^{i})$ for a large enough $\delta$.
Specifically, $\delta$ should be such that $\delta > q + n q^2$ (or $\delta > q + n q$ in the case of binary keys).
On the server side, the server unpacks the secret key by computing $\ck[i] = \delta^{t-1-i} \otimes \texttt{pck}_{0-t}$ for $i\in[t]$.
Compression proceeds as before, with the only difference being that the encrypted phase, calculated by the server in the additive ciphertext, is scaled by a factor of $\delta^{t-1}$.
\appsection{sec:lwe-compress-packed-keys} details the procedures for generating the packed key, unpacking it, and the corresponding modified LWE decryption function.
We use the same function for compressing the ciphertext.

% Hence, \textsc{ModifiedLWEDecrypt} is modified to account for this scale.
% Specifically, line 7 of \Cref{alg:lwe-compress} changes to 
% \begin{align}
%     \mu^{**} = \left(\floor{\frac{\texttt{ADec}(\addkey, x)}{\delta^{t-1}}} \mod \delta\right) \mod q 
% \end{align}

\subsection{Batched Compression}
\label{sec:batched-compression}

To achieve better compression, multiple LWE ciphertexts (encrypted using the same secret key) can be compressed within the same additive ciphertext, which we denote as \textit{batched compression}.
Each LWE ciphertext takes up $\log_2 (q+nq^2)$ bits of the total bitwidth of the plaintext space.
So, if $m$ is the modulus of the plaintext space, then $\floor{\log_2 m / \log_2 (q+nq^2)}$ LWE ciphertexts can be compressed into one ciphertext from the additive cryptosystem.

\Cref{alg:batched-compress} illustrates how to compress $\ell$ LWE ciphertexts within one additive ciphertexts. The corresponding decryption procedure is also shown.
Using \textsc{LWECompress} as a subprocedure allows for better parallelization when compressing many LWE ciphertexts.

\begin{algorithm}[t]
	 \caption{Batch Compression of LWE ciphertexts by the server and the modified decryption procedure, performed by the client. The compression key $\ck$ is such that $\sk[i]={\texttt{ADec}(\addkey, \ck[i])}$ and $cts=\{c_j\}_{j\in [\ell]}$ such that $c_j = (\boldsymbol{\textbf{a}_j}, b_j)\in \ZZ_{q}^{n}\times\ZZ$ and $\gamma = q + n q^2$.}
	 \label{alg:batched-compress}
	 \begin{algorithmic}[1]
    \Procedure{BatchedLWECompress$_{q, \gamma}$}{$\ck, cts=\{c_j\}_{j\in [\ell]}$}
        \For{$j\in{[\ell]}$}
            \State $x_j \leftarrow \textsc{LWECompress}_q(\ck,c_j)$
            \State $x \leftarrow x \oplus \gamma^{j} x_j $
        \EndFor
        \Return $x$
    \EndProcedure
    \vspace{3mm}
    \Procedure{ModifiedBatchedLWEDecrypt$_{q,p, \gamma}$}{$\addkey, x$}
	 	\State $\mu^{**} = \texttt{ADec}(\addkey, x)$
            \For{$j \in [\ell]$}
                \State $\mu_j^{**} =\floor{\mu^{**}/\gamma^j} \mod \gamma$
	       \State $\mu''_j = \lfloor \frac{\mu_j^{**} \mod q}{\Delta} \rceil$\Comment{$\Delta=\round{q/p}$}
            \EndFor
        \Return $\{\mu_j''\in \ZZ_{p}\}_{j\in[\ell]}$
    \EndProcedure
	 \end{algorithmic}
\end{algorithm}


\begin{theorem}[Correctness]
    Let $\ct=\{c_j\}_{j\in [\ell]}$ be a vector of $\ell$ LWE ciphertexts.
    For $\gamma\geq q + n q^2$, if  $m > \gamma^{\ell}$, then \textsc{BatchedLWECompress}$_{q, \gamma}$ produces a compressed ciphertext which, if decrypted using the corresponding modified decryption, decrypts to the vector of $\ell$ plaintexts. More formally, if
    \begin{align*}
        x \leftarrow \textsc{BatchedLWECompress}(\ck, \ct, k) \\
        \{\mu'_j\}_{j\in\ell} \leftarrow \textsc{ModifiedBatchedLWEDecrypt}(
        \addkey, x)
    \end{align*}
    then $\mu'_j = \text{LWEDecrypt}(\sk,c_j)$.
\end{theorem}
\begin{proof}
    By the proof of \Cref{thm:lwe-compress-correct} we know that if $\mu^{**}_j=\texttt{ADec}_{\texttt{s}}(x_j)$, then $0\leq \mu^{**}_j < \gamma = q + nq^2$. Hence, we have
    \begin{align*}
        \mu^{**} = \sum_{j\in[\ell]} \gamma^j \mu^{**}_j \leq \sum_{j\in[\ell]} \gamma^j (\gamma-1) = \gamma^{\ell} - 1 < \gamma^{\ell} < m .
    \end{align*}
    Hence, the plaintext corresponding to $x$, i.e., $\mu^{**}$, does not overflow in the plaintext space of the additive ciphertext.
    If $\mu^*_j$ us equivalent to $\mu^*$ in the \textsc{LWEEncrypt} procedure, then for some value $t$,
    \begin{align*}
        \mu''_j =\floor{\mu^{**}/\gamma^j} \mod \gamma = (\mu^*_j + \gamma \cdot t ) \mod \gamma = \mu^*_j
    \end{align*}
    and the subsequent steps are similar, which proves the theorem.
\end{proof}

\subsubsection{Faster Batched Compression with Expanded Key}
Compression makes use of expensive operations in the additive scheme.
The plaintext multiplication in \Cref{alg:line-multiply} of \Cref{alg:lwe-compress} is the most expensive operation.
In additive schemes such as Paillier and ElGamal, this is equivalent to a modular exponentiation in a large group.

In the batched setting, we can reduce the overhead by precomputing and reusing multiples of the bits of the secret key. If we decompose $(q-\textbf{a}[i])$ as $(b_{t-1}\cdots b_1 b_0)_2 = (q-\textbf{a}[i]) \mod q$ we compute the plaintext multiplication as follows
\begin{align}
    &(q-\textbf{a}[i]) \otimes \ck[i] \\
    &= 2^{t-1} b_{t-1} \ck[i] + \cdots + 2b_{1} \ck[i] + b_{0} \ck[i]
\end{align}
and we can precompute and \textit{extended compression key}, $\eck$, such that $\eck[i][j] = 2^j \ck[i]$ for $j \in [t]$, which can reused for all LWE ciphertexts we want to compress.

\begin{algorithm}[t]
	 \caption{Batch compression of LWE ciphertexts using precomputed powers. The compression key $\ck$ is such that $\sk[i]={\texttt{ADec}(\addkey, \ck[i])}$ and $cts=\{c_j\}_{j\in [\ell]}$ such that $c_j = (\boldsymbol{\textbf{a}_j}, b_j)\in \ZZ_{q}^{n}\times\ZZ$.}
	 \label{alg:batched-compress-precompute}
	 \begin{algorithmic}[1]
    \Procedure{ExpandCompressionKey$_{q}$}{$\ck$}
        \State $\eck[0] = \ck$
        \For {$i \in [t-1]$} \Comment{$t = \ceil{\log_2 q}$}
            \For {$j \in [n]$}
                \State $\eck[i+1][j] = \eck[i][j] \oplus \eck[i][j]$
            \EndFor
        \EndFor
        \Return $\eck$
    \EndProcedure
    \vspace{3mm}
    \Procedure{FastLWECompress$_q$}{$\eck, \ct=(\textbf{a},b)$}
    \State $x=b$
    \For{$i \in [n]$} 
        \State $(b_{t-1}\cdots b_1 b_0)_2 \leftarrow (q-\textbf{a}[i]) \mod q$
        \Comment{$t = \ceil{\log_2 q}$}
        \For {$j \in [t]$}
            \If {$b_j = 1$}
                \State $x \leftarrow x \oplus \eck[j][i]$
            \EndIf
        \EndFor
    \EndFor
    \Return $x$ \Comment{$\mu^*=\texttt{ADec}(\addkey, x)$}
    \EndProcedure
    \vspace{3mm}
    \Procedure{FastBatchedLWECompress$_{q,\gamma}$}{$\ck, cts=\{c_j\}_{j\in [\ell]}$}
        \State $\eck \leftarrow \textsc{ExpandCompressionKey}_{q}(\ck)$
        \State $\gamma = q + n q^2$
        \For{$j\in{[\ell]}$}
            \State $x_j \leftarrow \textsc{FastLWECompress}_q(\eck,c_j)$
            \State $x \leftarrow x \oplus \gamma^{j} x_j $
        \EndFor
        \Return $x$
    \EndProcedure
	 \end{algorithmic}
\end{algorithm}

\begin{corollary}
    Let $\ct=\{c_j\}_{j\in [\ell]}$ be a vector of $\ell$ LWE ciphertexts.
    For $\gamma\geq q + n q^2$, if  $m > \gamma^{\ell}$, if
    \begin{align*}
        x \leftarrow \textsc{FastBatchedLWECompress}(\eck, \ct, k) \\
        \{\mu'_j\}_{j\in\ell} \leftarrow \textsc{ModifiedBatchedLWEDecrypt}(
        \addkey, x)
    \end{align*}
    then $\mu'_j = \text{LWEDecrypt}(\sk,c_j)$.
\end{corollary}


\subsubsection{Rescaling for Compression}

In some instances, it is possible to rescale the elements in the ciphertext to a smaller modulus without altering the underlying message.
This technique, also called modulus switching, is commonly used in the literature to simplify the decryption procedure or control noise growth~\cite{brakerskiFullyHomomorphicEncryption2012}.
However, rescaling is only possible if the noise of the underlying LWE ciphertext is less than a given bound. 
In \appsection{sec:modulus-switching-theorem}, we prove how rescaling is possible for LWE ciphertexts with binary keys, if the noise is less than a certain bound, i.e., less than $\Delta/4$.
Rescaling to a smaller modulus accelerates our compression technique since the scalar multiplication in the additive encryption scheme is done with a smaller scalar.

\subsubsection{Better compression with a smaller scale}
\label{sec:overlapping-noise}

The number of LWE ciphertexts that fit within each additive ciphertext is determined by the scale, i.e., $\gamma=q+nq^2$.
Using a smaller scale would allow us to pack more LWE ciphertexts within each additive ciphertext.
There are two instances where we can use a smaller scale.
First, when the LWE secret key is binary.
In that case, we can use $\gamma=q+nq$ as the scale.
This follows from the fact that in the case of binary keys, $0<\mu_j^{**} \leq \gamma = q+nq^2$.

The second instance where we can reduce the scale is by allowing $\mu_{j}^{**}$ and $\mu_{j+1}^{**}$ to overlap in the additive scheme.
Intuitively, this is possible because the high-order bits of $\mu_{j}^{**}$ are removed when it is modulized by $q$ as part of the modified decryption.
The lower order bits of $\mu_{j+1}^{**}$ are also rounded during the modified decryption so it is possible to add additional error, as long as it does not interfere with the message.
Specifically, if $|e|<\Delta/4$ (instead of the usual condition where $|e|<\Delta/2$ for correct decryption), we can reduce the scale to $\gamma=q^2$ and $\gamma=q$ in the case of non-binary and binary keys, respectively.
Due to space restrictions, we provide proof of the correctness of this technique using a smaller scale under these conditions in the full version of the paper.

% \begin{corollary}
%     If the LWE secret key is binary and $m > (q + n q)^{\ell}$, \textsc{BatchedLWECompress} produces a compressed ciphertext which decrypts to the vector of $\ell$ plaintexts if decrypted using \textsc{ModifiedBatchedLWEDecrypt}. More formally, for a compression key $\ck$, any list of ciphertexts $c=\{c_j\}_{j\in[\ell]}$ and any $k\in[\ell]$, if
%     \begin{align*}
%         x \leftarrow \text{BatchedLWECompress}(\ck, c, k)\\
%         \{\mu'_j\}_{j\in\ell} \leftarrow \text{ModifiedBatchedLWEDecrypt}_s(x)
%     \end{align*}
% then $\mu'_j = \text{LWEDecrypt}_{\sk}(c_j)$
% \end{corollary}

% The second method for reducing the scale is by allowing $\mu_{j}^{**}$ and $\mu_{j+1}^{**}$ to overlap in the additive scheme. Intuitively, this is possible because the high-order bits of $\mu_{j}^{**}$ are removed when it is modulized by $q$ as part of the modified decryption.
% The lower order bits of $\mu_{j+1}^{**}$ are also rounded during the modified decryption so it is possible to add additional error, as long as it does not interfere with the message.
% These are all summarized in the following theorem.

% \begin{theorem}
%     For $\gamma = \frac{q+nq^2}{\Delta/2}$ and $m > \gamma^{\ell}$, \textsc{BatchedLWECompress} (with the given $\gamma$) produces a compressed ciphertext which decrypts to the vector of $\ell$ plaintexts if decrypted using \textsc{ModifiedBatchedLWEDecrypt}. More formally, for a compression key $\ck$, any list of ciphertexts $c=\{c_j\}_{j\in[\ell]}$ and any $k\in[\ell]$, if
%     \begin{align*}
%         x \leftarrow \textsc{BatchedLWECompress}(\ck, c, k) \\
%         \{\mu'_j\}_{j\in\ell} \leftarrow \textsc{ModifiedBatchedLWEDecrypt}_s(x)
%     \end{align*}
%     then $\mu'_j = \textsc{LWEDecrypt}(\sk, c_j)$.
% \end{theorem}

% We provide the full proof of the fact that we can use a smaller scale in the appendix.

\subsection{Compressing RLWE Coefficients}
\label{sec:rlwe-compression}

RLWE ciphertexts also have a linear phase evaluation and hence, can benefit from our compression technique.
However, an RLWE ciphertext is only twice as large as the phase so the compression technique, applied naively, would not yield a significant improvement.
Our approach is beneficial if the user is only interested in some coefficients of the RLWE plaintext and not all of them.

The main observation is that each coefficient of $\mu'(X)$ in the \textsc{RLWEDecrypt} procedure can be calculated separately. Specifically, for $0\leq k \leq N-1$

%changing the equation number to 'normalsize'
\makeatletter
    \def\tagform@#1{\maketag@@@{\normalsize(#1)\@@italiccorr}}
\makeatother

{\tiny
\begin{align}
    \mu'&[k] = \lfloor\frac{\mu^*[k]}{\Delta}\rceil \\
    &= \left\lfloor \frac{B[k] - \sum_{i=0}^{k} A[k-i] \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]}{\Delta} \right\rceil
    \label{eq:rlwe-extract-general}
\end{align}
}%

Note that the operations in the numerator are happening modulo $q$. The numerator of \Cref{eq:rlwe-extract-general} is a linear combination of the coefficients of the secret key, hence it can be computed given the encrypted coefficients of the secret key. The complete procedure to compress the coefficient of $X^k$ in an RLWE plaintext and the corresponding decryption function is shown in \Cref{alg:rlwe-compress-response}. Compression of RLWE coefficients is fully compatible with the compact compression keys of \Cref{sec:smaller-compression-key} and batched compression of \Cref{sec:batched-compression}.

\begin{algorithm}[H]
    \caption{
      Compressing Extracted RLWE Coefficient, performed by the server and the corresponding modified decryption process, for the client.
      The compression key is $\ck$ such that $\ck[i]={\texttt{AEnc}_{\texttt{s}}(S[i])}$ and $C\in R_q\times R_q$
    }
	 \label{alg:rlwe-compress-response}
	 \begin{algorithmic}[1]
    \Procedure{RLWECompressCoefficient}{$\ck, C, k$}
        \State $x=B[k]$
        \For{$i \in \{0,1,\cdots,k\}$}
            \State $x \leftarrow x \oplus \left( (q-A[k-i]) \otimes \ck[i]\right)$
        \EndFor
        \For{$i \in \{k+1,\cdots,N-1\}$}
            \State $x \leftarrow x \oplus \left(A[N+k-i] \otimes \ck[i]\right)$
        \EndFor
        
        \State \Return $x$ %\Comment{$\mu^*(X)=\texttt{ADec}_{\texttt{s}}(x)$}
    \EndProcedure
    \vspace{3mm}
    \Procedure{ModifiedRLWEDecrypt$_{q,p}$}{$\addkey, x$}
        \State $\mu^{**}_k = \texttt{ADec}(\addkey, x) \mod q$
        \vspace{1mm}
        \State $\mu''_k= \lfloor \mu^{**}_k / \Delta \rceil$
        \Comment{$\Delta=\round{q/p}$}
        \vspace{2mm}
        
        \State \Return  $\mu''_k \in \ZZ_{p}$
    \EndProcedure
	 \end{algorithmic}
\end{algorithm}


\begin{theorem}[Correctness]
\label{thm:rlwe-compress-correct}
    If $m > q + N q^2$, \Cref{alg:rlwe-compress-response} produces a compressed ciphertext which decrypts to the coefficient of $X^k$ if decrypted using \textsc{ModifiedRLWEDecrypt}$_{q,p}$. More formally, 
    \begin{align*}\normalfont
        x \leftarrow\textsc{RLWECompressCoefficient}(\ck, c, k) \\
        \mu_k'' \leftarrow\textsc{ModifiedRLWEDecrypt}_{q,p}(\texttt{s}, x)
    \end{align*}
    then $\mu_k''$ is equal to the coefficient of $X^k$ in 
    \begin{align*}
        \mu'(X) = \textsc{RLWEDecrypt}(\sk, c)
    \end{align*}
\end{theorem}

We provide the proof of \Cref{thm:rlwe-compress-correct} in \appsection{sec:prove-rlwe-compress}.
Similar to the case of LWE ciphertexts, if the coefficients of the RLWE secret key are binary, we can tighten the condition on $m$ in \Cref{thm:rlwe-compress-correct} such that $m > q + N q$.
The following corollary summarizes this fact.

\begin{corollary}
    If the coefficients of the secret key are binary and $m > q + N q$, \Cref{alg:rlwe-compress-response} produces a compressed ciphertext which decrypts to the coefficient of $X^k$ if decrypted using \textsc{ModifiedRLWEDecrypt}$_{q,p}$.
\end{corollary}

\emph{Security.} A similar argument can be made about the security of compression over RLWE. Let $\mathcal{E}''$ denote the cryptosystem which is the combination of $\mathcal{E}_{RLWE}$ and $\mathcal{E}_{A}$. The following proposition holds regarding security.

\begin{proposition}[Security]
    If $\mathcal{E}_{RLWE}$ and $\mathcal{E}_A$ are semantically secure, then $\mathcal{E}''$ is also semantically secure.
\end{proposition}
