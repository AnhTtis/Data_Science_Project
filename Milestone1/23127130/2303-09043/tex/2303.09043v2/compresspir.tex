\section{\protocol{} : PIR using Compression}

In this section, we present \textit{\protocol{}}, our new low-communication PIR protocol.
\protocol{} takes advantage of the compression technique in this work, in combination with techniques in the literature such as layered encryption~\cite{angelPIRCompressedQueries2018a, kiayiasOptimalRatePrivate2015, lipmaaObliviousTransferProtocol2005} and PIR using LWE~\cite{henzingerOneServerPrice2023, davidsonFrodoPIRSimpleScalable2023}.
This results in a PIR protocol with the lowest overall communication costs compared to all related work.
We first describe a simple version of \protocol{} and show how to adapt the construction to work with smaller keys and larger payloads.

\subsection{\protocol{} Description}

We restructure the database as a $(k+1)$-dimensional hypercube and perform PIR using LWE on the first dimension and PIR using Paillier on the subsequent dimensions.
Using LWE in the first dimension improves the runtime significantly, but we add some layers of Paillier to reduce the communication costs.


\Cref{alg:compresspir} shows the detailed description of \protocol{}. We follow the framework of PIR with preprocessing~\cite{liReducingCiphertextExpansion2015} and provide four routines.
The high-level steps for \protocol{} are as follows:
\begin{enumerate}
    \item In the setup phase~(\Cref{compresspir:hint-compute}), the server hint is calculated and stored by the server. This hint can be reused for all queries by any client and updated locally as the database changes.
    \item Upon receiving the query from the client, the server first expands the compression key to use throughout the process~(\Cref{compresspir:expand-key}).
    \item Using $\qu_0$, The server performs PIR using LWE on the first dimension, which is assisted by the hint generated in the setup~(\Cref{compresspir:online-lwe}). This step is similar to that of related work~\cite{henzingerOneServerPrice2023,davidsonFrodoPIRSimpleScalable2023}.
    \item The output of this step is rescaled and compressed using the compression functions and the expanded key to get Paillier ciphertexts.
    \item The Paillier ciphertexts, $\qu_1,\cdots, \qu_{k}$, are then used to do PIR using layered encryption, expanding the size by a factor of two in each layer. The result is sent to the client~(\Cref{compresspir:start-paillier-pir}-\ref{compresspir:paillier-pir-1}).
    \item Upon receiving the response, the client decrypts the Paillier ciphertexts and finally performs a modified LWE decryption to retrieve the response~(\Cref{compresspir:start-paillier-decrypt}-\ref{compresspir:paillier-merge}).
\end{enumerate}

\begin{algorithm}[]
% \scriptsize  % Make the font smaller
\caption{
  Complete description of \protocol{}. $q$ is the LWE ciphertext modulus, and $r$ is the smallest divisor of $q$ such that $r\geq 2(n+1)p$, $p$ is the plaintext modulus and $\Delta = q/p$.
  Database $\db\in\ZZ_p^{N_0\times d_0}$ where $N=d_0 d_1 \cdots d_k$ and $N_{\ell} = N / (d_0 d_1 \cdots d_{\ell})$ for all $\ell$. Also, as setup $\textbf{A} \sample \ZZ_q^{d_0 \times n}$. Paillier ciphertexts are in $\ZZ_{m^2}$. We denote Paillier homomorphic addition and scalar multiplication by $\oplus$ and $\otimes$, respectively.
}
	 \label{alg:compresspir}
	 \begin{algorithmic}[1]
    \Procedure{Setup}{$\db \in \ZZ_q^{N_0 \times d_0}$}
        \State $\hint = \db \times \textbf{A} \in \ZZ_q^{N_0 \times n}$ \label{compresspir:hint-compute}
        \State \Return $\hint$
    \EndProcedure
    \vspace{3mm}
    \Procedure{Query}{$(i,i_0)\in [N_0]\times[d_0]$}
        \State Generate Paillier keys $(\paillierpk, \paillierkey)$
        \State Sample LWE key $\lwekey\sample\{0,1\}^{n}$
        \State $\ck \leftarrow \textsc{PaillierEncrypt}(\paillierkey, \sk)$ \label{compresspir:compression-key}
        \For {$\ell \in \{1,2,\cdots,k\}$}
            \State $i_{\ell} = \floor{i/N_{\ell}} \mod d_{\ell}$
        \EndFor
        \State $u_j =$ selection vector for index $i_j$, $j\in[k+1]$
        \State Sample $e\leftarrow \chi^n$
        \State $\qu_0 = \textbf{A}\cdot \lwekey + e + \Delta\cdot u_0$ \Comment{$\qu_0\in\ZZ_q^{d_0}$}\label{compresspir:lwe-encrypt}
        \For {$\ell \in \{1,2,\cdots,k\}$}
                \State $\qu_{\ell} = \textsc{PaillierEnc}(\paillierkey, u_{\ell})$ 
            \Comment{$\qu_{\ell}\in\ZZ_{m^2}^{d_{\ell}}$}
                \label{compresspir:paillier-encrypt}
        \EndFor
        \State \Return $(\paillierkey, (\paillierpk, \ck, {\qu}_0, {\qu}_1, \cdots, {\qu}_k))$
    \EndProcedure
    \vspace{3mm}
    \Procedure{Response}{$\db, \hint,\qu=(\paillierpk, \ck,{\qu}_0, {\qu}_1, \cdots, {\qu}_k)$}
        \State $\eck \leftarrow \textsc{ExpandCompressionKey}_{r}(\ck)$ \label{compresspir:expand-key}
        \State $b = \db \cdot {\qu}_0$ \label{compresspir:online-lwe}
        \State $\textbf{D} = [\hint | b] \in \ZZ_r^{N_0 \times (n+1)}$
        \State $\textbf{D}_0\leftarrow$ Rescale elements in $\textbf{D}$ to modulus $r$ \label{compresspir:rescale-online}
        \For {$i\in [N_0]$}
            \Comment{$c_0\in\ZZ_{m^2}^{N_0\times 1}$}
            \State $c_0[i] = \textsc{FastLWECompress}_{r}(\eck, \textbf{D}_0[i])$
            \label{compresspir:fastcompress}
        \EndFor
        \For {$\ell = \{1, \cdots, k\}$} \label{compresspir:start-paillier-pir}
            \State Initialize $c_{\ell}$ with zeros
            \Comment{$c_{\ell} \in \ZZ_{m^2}^{N_{\ell}\times 2^{\ell}}$}
            \For {$t\in [N_{\ell}]$}
                \For {$h \in [2^{\ell-1}]$}
                    \For {$j \in [d_{\ell}]$}
                        \State $u_{0j} \leftarrow c_{\ell-1}[jN_{\ell}+t][h] \mod m$
                        \State $u_{1j} \leftarrow \floor{c_{\ell-1}[jN_{\ell}+t][h] / m}$
                        \State $c_{\ell}[t][2h] \leftarrow c_{\ell}[t][2h] \oplus (\qu_{\ell}[j] \otimes u_{0j}) $ \label{compresspir:paillier-pir-0}
                        \State $c_{\ell}[t][2h+1] \leftarrow c_{\ell}[t][2h+1] \oplus (\qu_{\ell}[j] \otimes u_{1j})$ \label{compresspir:paillier-pir-1}
                    \EndFor
                \EndFor
            \EndFor
        \EndFor
        \State \Return $c_k[0] \in \ZZ_{m^2}^{2^k}$
    \EndProcedure
    \vspace{3mm}
    \Procedure{Extract}{$\st = \paillierkey, f_k \in \ZZ_{m^2}^{2^k}$}
        \For {$\ell \in \{k, k-1, \cdots, 1\} $}
        \label{compresspir:start-paillier-decrypt}
            \State $p_{\ell} = \textsc{PaillierDec}(\paillierkey, f_{\ell})$
            \Comment{$p_{\ell}\in\ZZ_{m}^{2^{\ell}}$}
            \For {$h\in[2^{\ell-1}]$}
                \State $f_{\ell-1}[h] = m\cdot p_{\ell}[2h+1] + p_{\ell}[2h]$
                \label{compresspir:paillier-merge}
            \EndFor
        \EndFor
        \State $f=\textsc{ModifiedLWEDecrypt}_{r, p}(\paillierkey, f_0)$
        \label{compresspir:lwe-dec}
        \State\Return $f$
    \EndProcedure    
  \end{algorithmic}
\end{algorithm}



\begin{theorem}[\protocol{}]
    For LWE parameters $(n, q, \chi_e, \chi_s)$, assume $\chi_e$ is a discrete Gaussian with standard deviation $\sigma$ and $\chi_s$ is a binary distribution. Assume these parameters are $\epsilon_{L}$-secure for LWE with $d_0$ samples and take plaintext modulus $p$ such that $p|q$ and 
    \begin{align}
        q/p > 2p\sigma \sqrt{2d_0\ln (2/\delta)} 
        \label{eq:correctness}
    \end{align}
    Also, assume we instantiate the Paillier cryptosystem with modulus $m$ such that it is $\epsilon_{P}$-secure and $m > q+nq$. Then for a random matrix $\textbf{A}\in\ZZ_{q}^{d_0\times n}$, \protocol{} is a $2(\epsilon_{L}+\epsilon_{P})$-secure PIR scheme on database of size $N$ with items in $\ZZ_p$, with $1-\delta$ success rate.
\end{theorem}

The complete proof of correctness and security are provided in \appsection{appendix:proof}.

\subsubsection{Concrete Costs of \protocol{}}
\label{sec:concrete-costs}

The concrete number of operations in each routine in \protocol{}, along with the party that must perform those operations is listed below.
\begin{itemize}
    \item $\textsc{Setup}$ (Server): $N_0 d_0 n$ multiplications and additions in $\ZZ_q$ (\Cref{compresspir:hint-compute})
    \item $\textsc{Query}$ (Client): $d_0$ LWE encryptions (\Cref{compresspir:lwe-encrypt}) and $n+\sum_{\ell=1}^{k} d_{\ell}$ Paillier encryptions (\Cref{compresspir:compression-key} and \Cref{compresspir:paillier-encrypt})
    \item $\textsc{Response}$ (Server): $N=N_0d_0$ multiplications and additions in $\ZZ_q$ (\Cref{compresspir:online-lwe}), and $n\log r+\frac{1}{2} n\log_2 r$ multiplications in $\ZZ_{m^2}$, i.e., Paillier additions (\Cref{compresspir:expand-key} and \Cref{compresspir:fastcompress}) and $\sum_{\ell\in[k]} 2^{\ell} N_{\ell}$ exponentiations in $\ZZ_{m^2}$, i.e., Paillier scalar multiplications (\Cref{compresspir:paillier-pir-0} and \Cref{compresspir:paillier-pir-1}).
    \item $\textsc{Extract}$ (Client): $2^{k+1}$ Paillier decryptions
\end{itemize}

Similarly, the concrete communication costs of the protocol are listed below. 
\begin{itemize}
    \item Client to Server: $d_0 \log_2 q + 2 \log_2 m (n + \sum_{\ell=1}^{k} d_i)$
    \item Server to Client: $2^{k+1}\log_2 m$
\end{itemize}

% \begin{table}[H]
%     \caption{Concrete number of operations and concrete communication costs in \protocol{}}
%     \label{tab:my_label}
%     \centering
%     \begin{tabular}{rl}
%     \toprule
%         \textbf{Step} & \textbf{Number of Operations} \\
%     \midrule
%     \midrule
%         $\textsc{Setup}$ (S) & \begin{tabular}{l}$N_0 d_0 n$ multiplications and additions in $\ZZ_q$\end{tabular} \\
%     \midrule
%         $\textsc{Query}$ (C) & 
%         \begin{tabular}{l}
%              $d_0$ LWE encryptions (\Cref{compresspir:lwe-encrypt}) and \\
%              $n+\sum_{\ell=1}^{k} d_{\ell}$ Paillier encryptions (\Cref{compresspir:compression-key} and \ref{compresspir:paillier-encrypt})
%         \end{tabular} \\
%     \midrule
%         $\textsc{Response}$ (S) &
%         \begin{tabular}{l}
%              $N=N_0d_0$ mult. and add in $\ZZ_q$ (\Cref{compresspir:online-lwe})\\
%              $n\log r+\frac{1}{2} n\log_2 r$ multiplications in $\ZZ_{m^2}$, \\
%              ~~~~~~i.e., Paillier add (\Cref{compresspir:expand-key} and \ref{compresspir:fastcompress})\\
%              $\sum_{\ell\in[k]} 2^{\ell} N_{\ell}$ exponentiations in $\ZZ_{m^2}$,\\
%              ~~~~~~i.e., Paillier scalar mult. (\Cref{compresspir:paillier-pir-0} and \ref{compresspir:paillier-pir-1})
%         \end{tabular}
%         \\
%     \midrule
%         $\textsc{Extract}$ (C) & \begin{tabular}{l}
%              $2^{k+1}$ Paillier decryptions
%         \end{tabular} \\
%     \bottomrule
%     \toprule
%         \textbf{Step} & \textbf{Communication Cost} \\
%     \midrule
%     \midrule
%         Query & $d_0 \log_2 q + 2 \log_2 m (n + \sum_{\ell=1}^{k} d_i)$ \\
%     \midrule
%         Response & $2^{k+1}\log_2 m$ \\
%     \bottomrule
%     \end{tabular}
% \end{table}

\subsection{Updating the Hint} 
When the database changes, the hint must also be updated, but the hint can be updated locally by the server and does not require any communication with the clients.
This is in contrast to other works which rely on hints that require sending updates to the clients~\cite{henzingerOneServerPrice2023, davidsonFrodoPIRSimpleScalable2023}.
Moreover, small changes to the database can be handled with small changes to the hint to reduce the computation cost.
For example, assume $\db'$ is an updated database compared to $\db$. If we denote the hint for the new database by $\hint'$, then the relationship between the previous hint and the new hint would be as follows
\begin{align}
    \hint' = \mask\cdot\db' = \mask\cdot(\db +\db_{\Delta}) = \hint + \mask\cdot\db_{\Delta}
\end{align}
where $\db_{\Delta}$ is the difference between the two databases.
Assuming the change is small, many columns of $\db_{\Delta}$ will be zero. For example, assume that only column $k$ of $\db_{\Delta}$ has non-zero elements, then we only need to calculate $\mask\cdot\db_{\Delta}[:,k]$, which is a matrix-vector multiplication with only $d_0n$ multiplications and additions in $\ZZ_q$.

\subsection{Smaller Keys or Compressed Large Payloads}
\protocol{} can be modified in one of two ways to either reduce the size of the compression keys or produce a more compressed response.
The changes required for these two modifications can not combined, so we propose two variants of \protocol{} which we denote \protocolsingle{} (with smaller compression keys) and \protocolbatched{} (with more compressed responses).
We provide a high-level description of these modifications and leave the full detailed description for the full version.

In \protocolsingle{}, we use the technique from \Cref{sec:smaller-compression-key} to produce packed compression keys.
The server must then unpack the compressed keys before using them.
More precisely, in \Cref{alg:compresspir}, we change \Cref{compresspir:compression-key} to encrypt the key in a compressed way using \textsc{GeneratePackedKey} from \Cref{alg:packed-key-compress}.
We also add a step before \Cref{compresspir:expand-key} to unpack the key using \textsc{UnpackCompressionKey} and change the \Cref{compresspir:lwe-dec} to the corresponding function with packed keys, \textsc{ModifedLWEDecryptPackedKey}.

In \protocolbatched{}, we adapt the protocol to produce more compressed responses when the payload is large, which is done using the batched compression technique.
The high-level description of \protocolbatched{} is as follows:
Assume each database element is an element in $\ZZ_p^{\ell}$ for some $\ell\in\NN$.
Let $\db^j$ denote a database consisting of the $j^{th}$ component of all elements in this database.
Corresponding to this, we generate $\hint^j$, $\textbf{D}^j$, and $\textbf{D}_{0}^{j}$, as is done in \Cref{alg:compresspir}.
We replace \Cref{compresspir:fastcompress} to perform a batched compression in the following manner
\begin{align}
    \textsc{FastBatchedLWECompress}_{r, \gamma}(\eck, \{\mathbf{D}_0^{j}\}_{j\in[\ell]})
\end{align}

and proceed with the rest of the protocol as before.
We also change the decryption function in \Cref{compresspir:lwe-dec} to the corresponding decryption for modified batched decryption.

\subsection{Additional techniques for \protocol{}}

In addition to the techniques mentioned in the previous two section, we use two more techniques to further reduce communication costs.
Firstly, we can use the technique from \Cref{sec:overlapping-noise} in one of two ways 1) Pack more LWE ciphertexts within each Paillier ciphertext to produce a smaller response or 2) Pack more bits of the secret key with each Paillier ciphertext to have a smaller compression key.
As mentioned, to produce correct results using this technique, the error in the LWE ciphertext must be small enough, so we must consider this constraint for correctness.
This changes the correctness condition in \Cref{eq:correctness} to 
\begin{align}
    \label{eq:correctness-modified}
    q/p > 4p\sigma \sqrt{2d_0\ln (2/\delta)} 
\end{align}
which is what we use in our experimental evaluation.
We also use a technique proposed by Beck~\cite{beckRandomizedDecryptionRD2015} to reduce the size of uploaded Paillier ciphertexts, at the cost of small computational overhead for the server.
Due to space restrictions, we provide the proof of correctness and security of \protocol{} using these techniques in the full version of the paper.

\section{PIR Evaluation}

For our evaluation, we first detail the process for selecting the parameters of \protocol{}.
Given the many parameters that must be chosen, this amounts to a non-trivial optimization problem.
After that, we provide runtimes for \protocol{} to demonstrate the scalability. Finally, we compare with related work on PIR with no setup such as WhisPIR, HintlessPIR, and YPIR.
Our results demonstrate that \protocol{} introduces a new category of PIR protocols with low communication that 

\subsection{Parameter Selection for \protocol{}}
The LWE parameters directly effect the performance of \protocol{}.
However, the set of secure LWE parameters is large and experimenting with all parameters set is infeasible.
Hence, we instantiate \protocol{} with three LWE parameters $(n,q,\chi_e, \chi_s)$ which are representative of different tradeoffs.
A smaller $n$ and $q$ results in fewer operations in based on the analysis of \Cref{sec:concrete-costs}, but limit the choice of $p$.
In contrast, higher $n$ and $q$ allow for a larger $p$ and $d_0$.
We choose three $(n,q)$ pairs, and let $\chi_e$ and $\chi_s$ be a discrete Gaussian with standard deviation $\sigma = 6.4$ and uniform binary distribution, respectively.
While in other works based on LWE~\cite{henzingerOneServerPrice2023,davidsonFrodoPIRSimpleScalable2023}, $q$ is chosen as a power of two, e.g., $2^{32}$ or $2^{64}$, to leverage the native CPU word size, we opt for a small $q$ since the bitlength of $q$ determines the total communication cost and number of operations.
Our chosen parameters for LWE provide 128-bit security based on the lattice estimator~\cite{albrechtConcreteHardnessLearning2015}.
We set the failure rate to $\delta=2^{-40}$ and for every $p$ find the upper bound for $d_0$ based on the correctness constraint, \Cref{eq:correctness}.
The upper bound on $d_0$ for each parameter set and each value of $p$ is shown in \Cref{tab:d0-bound}.
For the Paillier cryptosystem, we use a 3072-bit modulus which provides 128-bit security~\cite{barkerRecommendationKeyManagement2020}.

% \begin{table}[H]
%     \centering
%     \caption{Upper bound on $d_0$ for every value of $p$, based on a variant of \Cref{eq:correctness}. In all cases, $\sigma=6.4$, and $\delta=2^{-40}$.}
%     \label{tab:d0-bound}
%     \begin{tabular}{c|c|c|c|c|c|c|c|c}
%     \toprule
%          $(n,q)$ & $2^1$ & $2^2$ & $2^3$ & $2^4$ & $2^5$ & $2^6$ & $2^7$ & $2^8$ \\
%     \midrule
% $(630, 17)$ & 28825 & 1801 & 112 & 7 & - & - & - & - \\
% $(840, 22)$ & 3.0e+07 & 1.8e+06 & 1.2e+05 & 7206 & 450 & 28 & 1 & - \\
% $(1023, 27)$ & 3.0e+10 & 1.9e+09 & 1.2e+08 & 7.4e+06 & 4.6e+05 & 28825 & 1801 & 112 \\
%     \bottomrule
%     \end{tabular}
% \end{table}

\begin{table}[H]
    \centering
    \caption{Upper bound on $d_0$ for every value of $p$, based on \Cref{eq:correctness-modified}. In all cases, $\sigma=6.4$, and $\delta=2^{-40}$. Dashes indicate cases where no $d_0$ satisfies the equation.}
    \label{tab:d0-bound}
    \begin{tabular}{c|c|c|c}
    \toprule
         \diagbox{$p$}{$(n,q)$} & $(630, 17)$ & $(840, 22)$ & $(1023, 27)$ \\
    \midrule
        $2^1$ & 28825 & 29517568 & 30225990335 \\
        $2^2$ & 1801 & 1844848 & 1889124395 \\
        $2^3$ & 112 & 115303 & 118070274 \\
        $2^4$ & 7 & 7206 & 7379392 \\
        $2^5$ & - & 450 & 461212 \\
        $2^6$ & - & 28 & 28825 \\
        % $2^7$ & - & 1 & 1801 \\
        % $2^8$ & - & - & 112 \\
    \bottomrule
    \end{tabular}
\end{table}


The two important metrics to evaluate performance are total communication cost and server online runtime.
The remainder of the parameters, such as the dimensions of the database $\{d_i\}$, $p$, and the choice of the protocol (\protocolsingle{} or \protocolbatched{}) are chosen to minimize these costs.
However, the selection of these parameters is a non-trivial optimization problem.
While the communication cost can be derived with a closed-form formula, this is not the case for the server online runtime.
Moreover, many parameter sets fall on the Pareto frontier, i.e., are dominant in either communication or computation.
Hence, for a fixed number of rows and payload size, we aim to find as many parameter sets that fall on the Pareto frontier.
For this, we iterate over the list of all parameter sets and maintain a list which is Pareto optimal.
To narrow down the search space, represent each parameter set by the number of operations in the different steps, as calculated in \Cref{sec:concrete-costs}.
Parameter sets which are worse than another parameter set in all steps are trivially excluded.
Moreover, we use logistic regression to predict if a parameter set A dominates another parameter set B, given the concrete number of operations in the steps of the protocol.
This further reduces the space of parameter sets to a manageable size, which we can run experimentally.

\subsection{Performance of \protocol{}}
\Cref{fig:zippir-costs-per-num-rows} visualizes the communication and computation cost of \protocol{} as a function of the database size, with the goal of retrieving at least one bit from the database.
Using the procedure described in the previous section, we maintain the list of Pareto optimal parameters for each database size and plot them.
For each database size, each point on the communication graph corresponds to a point on the runtime graph, i.e., the point with higher communication has lower computation and vice-versa.
Within the communication graph, we also include the minimum required communication for related work on low-communication PIR.

There are several important observations from this graph.
Firstly, we observe that \protocolsingle{} is the best option, given that the requested payload is small.
Cases which \protocolbatched{} only appear when the payload size is large.
Second, for small databases, the communication cost of \protocol{} is small, as opposed to all other protocols in the literature, which have a lower bound on communication due to the use of large cryptographic keys.
Lastly, the minimum communication cost of \protocol{} grows sublinearly, roughly proportional to $|\db|^{0.27}$, which demonstrates the scalability of the protocol.

\newcommand{\myScatterClasses}{
    scatter/classes={
        small single={mark=*,mark size=0.6pt,yellow},
        medium single={mark=*,mark size=0.8pt,orange},
        large single={mark=*,mark size=1pt,red},
        small batched={mark=*,mark size=0.6pt,white},
        medium batched={mark=*,mark size=0.8pt,white},
        large batched={mark=*,mark size=1pt,white}
    }
}

\newcommand{\protocolsinglesize}{1.5pt}
\newcommand{\protocolsinglecolor}{red}

\newcommand{\protocolbatchedsize}{1.5pt}
\newcommand{\protocolbatchedcolor}{blue}

\newcommand{\hintlesssize}{1.5pt}
\newcommand{\hintlesscolor}{cyan}

\newcommand{\whispirsize}{1.5pt}
\newcommand{\whispircolor}{teal}

\newcommand{\ypirsize}{1.5pt}
\newcommand{\ypircolor}{green}


\begin{figure}[t]
    \centering
    \begin{subfigure}{\columnwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                % xlabel={Number of Rows},
                ylabel={\footnotesize Online Time (s)},
                \myScatterClasses,
                width=\textwidth,
                height=0.4\textwidth,
                xmode=log,
                log basis x=2,                   
                ymode=log,
                log basis y=10,                   
                xtick={
                        8388608, 33554432, 134217728, 536870912, 2147483648, 8589934592, 34359738368, 137438953472, 549755813888, 2199023255552    
                },
                xticklabels={}
            ]
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s1.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=N input, y=Server Online Time] {\datatable};
            \end{axis}
        \end{tikzpicture}
        % \caption{8MB $=2^{20}\times$ 8B}
    \end{subfigure}
    ~
    \begin{subfigure}{\columnwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                xlabel={Database Size},
                ylabel={\footnotesize Total Size (KB)},
                \myScatterClasses,
                width=\textwidth,
                height=0.6\textwidth,
                xmode=log,
                log basis x=2,                   
                ymode=log,
                log basis y=10,       
                % ymax = 400,
                xtick={
                    % 8388608,
                    16777216,
                    % 33554432,
                    % 67108864,
                    134217728,
                    % 268435456,
                    % 536870912,
                    1073741824,
                    % 2147483648,
                    % 4294967296,
                    8589934592,
                    % 17179869184,
                    34359738368,
                    % 68719476736,
                    137438953472,
                    % 274877906944, 549755813888, 1099511627776, 2199023255552,
                    4398046511104
                    },
                xticklabels={
                    % 1,
                    2MB,
                    % 4MB,
                    % 8,
                    16MB,
                    % 32MB,
                    % 64MB,
                    128MB,
                    % 256MB,
                    % 512,
                    1GB,
                    % 2048,
                    4GB,
                    % 8192,
                    16GB,
                    % 32768, 65536, 131072, 262144,
                    524288
                },
                tick label style={font=\footnotesize}, % or \footnotesize, \scriptsize, \tiny
                legend pos = north west
            ]
            
            \addplot[mark=none, \hintlesscolor, samples=2, domain=8000000:160000000000] {387};
            \addlegendentry{\scriptsize HintlessPIR (Lower Bound)}

            \addplot[mark=none, \whispircolor, samples=2, domain=8000000:160000000000] {441};
            \addlegendentry{\scriptsize WhisPIR (Lower Bound)}

            \addplot[mark=none, \ypircolor, samples=2, domain=8000000:160000000000] {846};
            \addlegendentry{\scriptsize YPIR (Lower Bound)}
            
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s1.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=N input, y=Total Size (KB)] {\datatable};

            % \addplot+[mark=none,samples=200,unbounded coords=jump,domain=8000000:160000000000] {pow(x, 0.21)};
            
            \end{axis}
        \end{tikzpicture}
        % \caption{Payload = 8 B}
    \end{subfigure}
    \caption{
        Communication cost and Server Online Runtime as a function of the database size. Each point in the upper graph as a corresponding point in the lower graph.
        We also plot the minimum communication required for other protocols in the literature.
        The yellow, orange, and red points correspond to $n=(630,17),(840,22),(1023, 27)$, respectively.
    }
    \label{fig:zippir-costs-per-num-rows}
\end{figure}


% \begin{figure*}[t]
%     \centering
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 % xlabel={Number of Rows},
%                 ylabel={\footnotesize Online Time (s)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s64.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Server Online Time] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%         % \caption{8MB $=2^{20}\times$ 8B}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 % xlabel={Number of Rows},
%                 ylabel={\footnotesize Online Time (s)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s2048.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Server Online Time] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 % xlabel={Number of Rows},
%                 ylabel={\footnotesize Online Time (s)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s262144.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Server Online Time] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%     \end{subfigure}
%     ~
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 xlabel={\footnotesize Number of Rows},
%                 ylabel={\footnotesize Total Size (KB)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 ymode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s64.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Total Size (KB)] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%         \caption{Payload = 8 B}
%     \end{subfigure}
%     \hfill    
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 xlabel={\footnotesize Number of Rows},
%                 ylabel={\footnotesize Total Size (KB)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 ymode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%                 % title={Payload = 256 B},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s2048.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Total Size (KB)] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%         \caption{Payload = 256 B}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.3\textwidth}
%         \centering
%         \begin{tikzpicture}
%             \begin{axis}[
%                 xlabel={\footnotesize Number of Rows},
%                 ylabel={\footnotesize Total Size (KB)},
%                 \myScatterClasses,
%                 width=\textwidth,
%                 height=0.6\textwidth,
%                 xmode=log,
%                 ymode=log,
%                 xtick={1024, 16384, 524288},
%                 xticklabels={$2^{10}$, $2^{14}$, $2^{19}$},
%             ]
%             \pgfplotstableread[col sep=comma]{data/Total_Size_vs_N_s262144.csv}\datatable
%             \addplot[
%                 scatter, 
%                 only marks,
%                 scatter src=explicit symbolic
%             ] table [meta=mode, x=N, y=Total Size (KB)] {\datatable};
%             \end{axis}
%         \end{tikzpicture}
%         \caption{Payload = 32 KB}
%     \end{subfigure}
%     \caption{Communication cost and Server Online Runtime as a function of the number of rows}
%     \label{fig:zippir-costs-per-num-rows}
% \end{figure*}


\subsection{Evaluating PIR with No Setup}
We compare \protocol{} with other PIR protocols without setup by measuring communication and computation costs for different database sizes, with the goal of retrieving at least one bit.
We report our measurements in \Cref{fig:eval-pir-comm-comp} in four graphs, corresponding to four different database sizes.
For each database size, we include points corresponding to related work such as HintlessPIR, WhisPIR, and YPIR. Other PIR protocols have communication costs that are much higher than these works.

From these graphs, we can make the following observations.
\protocol{} offers a low communication alternative to existing work, such that in some configurations, we require less than 25\% of the total communication cost of related work.
However, this low communication comes with higher computation costs, which can be addressed in future work.

% Our results show that \protocol{} has less than 100 KB communication cost for any configuration, which is less than 50\% of any related work.
% Hence, \protocol{} is the least communication-intensive PIR protocol in the literature.
% Regarding runtime, \protocol{} is slower than related work, particularly those that allow hints and offline communication, but this is an expected consequence.

\begin{figure*}[t]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            height=0.2\columnwidth,
            width=2*\columnwidth, % Ensure this axis is as wide as both subfigures together
            hide axis,
            xmin=0,
            xmax=1,
            ymin=0,
            ymax=1,
            legend columns=-1, % Horizontal legend
            legend style={/tikz/every even column/.append style={column sep=0.5cm}},
            legend to name=namedtradeoff, % Define legend name for referencing
        ]
            \addlegendimage{color=\protocolsinglecolor, mark size=2pt, mark=*}
            \addlegendentry{\protocolsingle{}}
    
            % \addlegendimage{color=\protocolbatchedcolor, mark size=2pt, mark=*}
            % \addlegendentry{\protocolbatched{}}
    
            \addlegendimage{color=\hintlesscolor, mark size=2pt, mark=*}
            \addlegendentry{HintlessPIR}
    
            \addlegendimage{color=\whispircolor, mark size=2pt, mark=*}
            \addlegendentry{WhisPIR}

            \addlegendimage{color=\ypircolor, mark size=2pt, mark=*}
            \addlegendentry{YPIR}
            
        \end{axis}
        \end{tikzpicture}
    
        \ref{namedtradeoff} % Referencing the named legend

    \begin{subfigure}{0.24\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                xlabel={\footnotesize Server Online Time (s)},
                ylabel={\footnotesize Total Size (KB)},
                \myScatterClasses,
                width=1.1\textwidth,
                height=0.75\textwidth,
                ymode=log,
                log basis y=2,   
                % xmode=log,
                % xmax=100,
                ymax=2000,
                tick label style={font=\footnotesize}, % or \footnotesize, \scriptsize, \tiny
            ]
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_Server_Online_Time_2147483648x1=256.00MB_all.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=Server Online Time, y=Total Size (KB)] {\datatable};
            % \addplot[
            %     scatter,
            %     only marks,
            %     mark=*, mark size=\whispirsize, \whispircolor
            % ] coordinates {
            %     (1.691,564)
            %     (1.35,620)
            %     (1.037,878)
            %     (1.662,1044)
            % };
            
            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\hintlesssize, \hintlesscolor
            ] coordinates {
                (0.575,1260)
            };

            \end{axis}
        \end{tikzpicture}
        \caption{$|\db|=$ 0.25 GB}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.24\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                xlabel={\footnotesize Server Online Time (s)},
                \myScatterClasses,
                width=1.2\textwidth,
                height=0.75\textwidth,
                ymode=log,
                log basis y=2,   
                % xmode=log,
                % xmax=100,
                ymax=2000,
                tick label style={font=\footnotesize}, % or \footnotesize, \scriptsize, \tiny
            ]
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_Server_Online_Time_4294967296x1=512.00MB_all.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=Server Online Time, y=Total Size (KB)] {\datatable};
            
            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\hintlesssize, \hintlesscolor
            ] coordinates {
                (0.768,1639)
            };

            \end{axis}
        \end{tikzpicture}
        \caption{$|\db|=$ 0.5 GB}
    \end{subfigure}
    \hfill  
    \begin{subfigure}{0.24\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                xlabel={\footnotesize Server Online Time (s)},
                \myScatterClasses,
                width=1.2\textwidth,
                height=0.75\textwidth,
                ymode=log,
                log basis y=2,   
                % xmode=log,
                xmax=100,
                ymax=2450,
                tick label style={font=\footnotesize}, % or \footnotesize, \scriptsize, \tiny
            ]
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_Server_Online_Time_8589934592x1=1024.00MB_all.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=Server Online Time, y=Total Size (KB)] {\datatable};
            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\whispirsize, \whispircolor
            ] coordinates {
                (1.691,564)
                (1.077,620)
                (1.037,878)
                (0.814,1044)
            };
            
            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\hintlesssize, \hintlesscolor
            ] coordinates {
                (1.03,2131)
            };

            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\ypirsize, \ypircolor
            ] coordinates {
                (0.428,858)
            };
            \end{axis}
        \end{tikzpicture}
        \caption{$|\db|=$ 1 GB}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.24\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                xlabel={\footnotesize Server Online Time (s)},
                \myScatterClasses,
                width=1.2\textwidth,
                height=0.75\textwidth,
                ymode=log,
                log basis y=2,   
                ymax=2500,
                tick label style={font=\footnotesize}, % or \footnotesize, \scriptsize, \tiny
            ]
            \pgfplotstableread[col sep=comma]{data/Total_Size_vs_Server_Online_Time_68719476736x1=8192.00MB_all.csv}\datatable
            \addplot[
                scatter, 
                only marks,
                scatter src=explicit symbolic
            ] table [meta=mode, x=Server Online Time, y=Total Size (KB)] {\datatable};
            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\whispirsize, \whispircolor
            ] coordinates {
                (8.412,852)
                (7.432,963)
                (5.984,1183)
                (6.254,2047)
            };            

            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\hintlesssize, \hintlesscolor
            ] coordinates {(2.3, 2128)};

            \addplot[
                scatter,
                only marks,
                mark=*, mark size=\ypirsize, \ypircolor
            ] coordinates {(0.992, 1512)};
            
            \end{axis}
        \end{tikzpicture}
        \caption{$|\db| = $ 8 GB}
    \end{subfigure}
    \caption{Communication cost vs. server online runtime for several database sizes. The red, orange, and yellow points correspond to ZipPIR with different parameters, as described \Cref{fig:eval-pir-comm-comp}.}
    \label{fig:eval-pir-comm-comp}
\end{figure*}


% \begin{table}[]
%     \centering
%     \label{tab:eval-pir}    
%     \caption{
%         Performance of PIR protocols for ephemeral clients.
%         We use \protocolsingle{} for small payloads and \protocolbatched{} for the large payloads.
%         % The top two sections are cases where the payload size is small (and we use \protocol{} with the packed compression key).
%         % In this case, the packed compression key is only 8 KB of the query.
%         % The two lower sections are cases with a larger payload and we use \protocol{} with batched compression.
%         % The compression key is about 400 KB in this case.
%     }
%     \begin{tabular}{c|c|c|c|c}
%     \toprule
%      Protocol & & HintlessPIR & WhisPIR & \protocol{} \\
%      & & \cite{liHintlessSingleServerPrivate2023} & \cite{castroWhisPIRStatelessPrivate2024} &  \\
%     \midrule
%         & Query & 399 KB & & 49 KB \\
%         & Response & 151 KB & & 48 KB \\
%         $2^{20}\times$ 8B
%         & Total & 450 KB & $\approx$ 300 KB & 97 KB \\
%         \cline{2-5}
%         (8 MB)
%         & Offline & 3.11 s & ?? & 3.8 s \\
%         & Online & 271 ms & ?? & 12 s \\
%     \midrule
%         & Query & 480 KB & ?? & 175 KB \\
%         & Response & 1159 KB & ?? & 48 KB \\
%         $2^{26}\times$ 8B
%         & Total & 1260 KB & 300 & 223 KB \\
%         \cline{2-5}
%         (537 MB)
%         & Offline & 93.58 s & & 65 s \\
%         & Online & 768 ms & & 188 s \\
%     \midrule
%     \midrule
%         & Query & 453 KB & & 667 KB \\
%         & Response & 807 KB & & 15 KB \\
%         $2^{20}\times$ 256 B
%         & Total & 1260 KB & $\approx$ 300 & 682 KB \\
%         \cline{2-5}
%         (268 MB)
%         & Offline & 51.57s & \\
%         & Online & 575 ms & \\
%     \midrule
%         & Query & 518~KB & & 676 KB \\
%         & Response & 1610~KB & & 826 KB \\
%         $2^{18}\times$ 32~KB
%         & Total & 2128~KB & $\approx$ 300 & 1502 KB \\
%         \cline{2-5}
%         (8.59 GB)
%         & Offline & 2128 s & & - \\
%         & Online & 2309 ms & & - \\
%     \bottomrule
%     \end{tabular}
% \end{table}


% \newcommand{\plotheight}{0.4}
% \begin{figure*}[t]
%     \begin{tikzpicture}
%         \begin{axis}[
%             height=0.2\columnwidth,
%             width=\linewidth,
%             hide axis,
%             xmin=0,
%             xmax=1,
%             ymin=0,
%             ymax=1,
%             legend columns=-1, % Horizontal legend
%             legend style={/tikz/every even column/.append style={column sep=0.5cm}},
%             legend to name=named, % Define legend name for referencing
%         ]
%             % \addlegendimage{color=blue, mark size=1pt, mark=*}
%             % \addlegendentry{Comm. Optimal}
    
%             % \addlegendimage{color=red, mark size=1pt, mark=*}
%             % \addlegendentry{Comp. Optimal}
            
%         \end{axis}
%     \end{tikzpicture}
%     \centering
%     \ref{named} % Referencing the named legend
%     \begin{subfigure}[b]{\columnwidth}
%         \begin{tikzpicture}[]
%             \begin{axis}[
%                 name=single_comm,
%                 at={(0,0)},
%                 xlabel = {\# of Rows},
%                 ylabel = {Communication (KB)},
%                 height = \plotheight \columnwidth,
%                 width = \columnwidth,
%                 xmode=log,
%                 ymode=log,
%                 log basis x={2},
%                 % ymax=500,
%                 legend pos=north west
%             ]
    
%                 \addplot [color=blue, mark size=1pt, mark=*] table [
%                     x={Items},
%                     y={Total Size (KB)},
%                     col sep=comma
%                 ] {data/results_single_comm.csv};
%                 % \addlegendentry{Comm Optimal}
%                 \addplot [color=red, mark size=1pt, mark=*] table [
%                     x={Items},
%                     y={Total Size (KB)},
%                     col sep=comma
%                 ] {data/results_single_comp.csv};
%                 % \addlegendentry{Comp Optimal}
%             \end{axis}    
%         \end{tikzpicture}
%         \caption{Small Payload (8B)}
%     \end{subfigure}
%     ~
%     \begin{subfigure}[b]{\columnwidth}
%         \begin{tikzpicture}[]
%             \begin{axis}[
%                 name=batched_comm,
%                 at={(0,0)},
%                 xlabel = {\# of Rows},
%                 ylabel = {Communication (KB)},
%                 height = \plotheight \columnwidth,
%                 width = \columnwidth,
%                 xmode=log,
%                 ymode=log,
%                 log basis x={2}
%             ]
    
%                 \addplot [color=blue, mark size=1pt, mark=*] table [
%                     x={Items},
%                     y={Total Size (KB)},
%                     col sep=comma
%                 ] {data/results_batched_comm.csv};
%                 \addplot [color=red, mark size=1pt, mark=*] table [
%                     x={Items},
%                     y={Total Size (KB)},
%                     col sep=comma
%                 ] {data/results_batched_comp.csv};
%             \end{axis}    
%         \end{tikzpicture}
%         \caption{Large Payload (32KB)}
%     \end{subfigure}
% \begin{subfigure}[b]{\columnwidth}
%     \begin{tikzpicture}[]
%         \begin{axis}[
%             name=single_comp,
%             at={(0,0)},
%             xlabel = {\# of Rows},
%             ylabel = {Server Time (s)},
%             height = \plotheight \columnwidth,
%             width = \columnwidth,
%             xmode=log,
%             ymode=log,
%             log basis x={2},
%             % ymax=200
%         ]

%             \addplot [color=blue, mark size=1pt, mark=*] table [
%                 x={Items},
%                 y expr=\thisrow{Server Online Time}/1000000,
%                 col sep=comma
%             ] {data/results_single_comm.csv};
%             \addplot [color=red, mark size=1pt, mark=*] table [
%                 x={Items},
%                 y expr=\thisrow{Server Online Time}/1000000,
%                 col sep=comma
%             ] {data/results_single_comp.csv};
%         \end{axis}    
%     \end{tikzpicture}
%     \caption{Small Payload (8B)}
% \end{subfigure}
% ~
% \begin{subfigure}[b]{\columnwidth}
%     \begin{tikzpicture}[]
%         \begin{axis}[
%             name=batched_comp,
%             at={(0,0)},
%             xlabel = {\# of Rows},
%             ylabel = {Server Time (s)},
%             height = \plotheight \columnwidth,
%             width = \columnwidth,
%             xmode=log,
%             ymode=log,
%             log basis x={2},
%             % ymax=200
%         ]

%             \addplot [color=blue, mark size=1pt, mark=*] table [
%                 x={Items},
%                 y expr=\thisrow{Server Online Time}/1000000,
%                 col sep=comma
%             ] {data/results_batched_comm.csv};
%             \addplot [color=red, mark size=1pt, mark=*] table [
%                 x={Items},
%                 y expr=\thisrow{Server Online Time}/1000000,
%                 col sep=comma
%             ] {data/results_batched_comp.csv};
%         \end{axis}    
%     \end{tikzpicture}
%     \caption{Large Payload (32KB)}
% \end{subfigure}
% \caption{Communication and computation costs of \protocol{} as a function of the number of rows in the database. On the left, we have small 8B payloads so we use $\protocol{}_C$ and on the right, we have large 32KB payloads so we use \protocolbatched{}.}
% \label{fig:zippir-costs-per-num-rows}
% \end{figure*}


\section{Related Work on PIR}
Computational PIR (CPIR) protocols follow one of three approaches:
1) the server gives a \textit{hint} to the client 2) the client sends cryptographic keys to the server 3) there is no setup, hint, or apriori key exchange.
We describe each approach briefly, the advantages and disadvantages of each approach and list related work.

\subsection{Hint-based PIR}
One approach is for the server to generate a database-dependant hint which is transmitted to the client before the query is issued.
The objective of the hint is to speed up subsequent queries.
SimplePIR~\cite{henzingerOneServerPrice2023} and FrodoPIR~\cite{davidsonFrodoPIRSimpleScalable2023} are two recent works that propose a PIR protocol based on LWE with a client-independent hint.
The hint size is $O(\sqrt{N}n)$ for $N$ database rows and LWE dimension of $n$.
All clients use the same hint which helps respond quickly to PIR queries and achieve very high throughput (up to 10 GB/s).
However, the hint is a high upfront cost (100 MB for a 1 GB database) and must be recalculated and redistributed to the clients every time the database is updated.
The authors show how to update the client hint with a small amount of communication.
DoublePIR extends SimplePIR so that the hint that must be sent to the client is smaller but the overall throughput is less.
In recent work, Henzinger et al. used an improved version of SimplePIR for a private web search application to avoid sending a large hint to the client in a method similar to our work, but with the use of an RLWE-based cryptosystem~\cite{henzingerPrivateWebSearch2023}.

\subsection{PIR with Setup}
Another category of works assumes auxiliary information is sent before the start of the protocol, usually in the form of cryptographic keys.
The cost of sending these keys is amortized over many queries but requires per-client storage on the server.
While this approach is good if there is an established connection between the client and server, it is a high upfront cost.
Moreover, the public keys allow the server to correlate different queries that the client makes so it is not suitable to combine with anonymity networks.
Henzinger et al. also showed that such long-term persistent keys expose the client to state-recovery attacks that could compromise past queries.
Despite these disadvantages, the online time in such protocols is very small and if sufficient queries are made, the runtime and communication cost of setup is amortized.


Works that follow this model include SealPIR~\cite{angelPIRCompressedQueries2018a}, MulPIR~\cite{Ali2019CommunicationComputationTI}, OnionPIR~\cite{mugheesOnionPIRResponseEfficient2021}, Constant-weight PIR~\cite{mahdaviConstantweightPIRSingleround2022}, Pantheon~\cite{ahmadPantheonPrivateRetrieval2022}, FastPIR~\cite{ahmadAddraMetadataprivateVoice2021}, Spiral (and its variants)~\cite{menonSPIRALFastHighRate2022}, and SparsePIR~\cite{patelDonBeDense2023}.

\subsection{PIR without Hints or Setup}
The previous approaches require an established connection between a client and server to amortize the cost of the hint or cryptographic keys across many queries.
For applications where the client only performs a few queries, previous solutions are impractical
Naively applying previous solutions would require the cryptographic keys to be sent as part of the query, resulting in large queries.
Hence, the third approach is to design a PIR protocol that does not require precomputed hints or large cryptographic keys.
Our work also falls in this category and achieves the lowest total communication cost of all PIR protocols in the literature.

HintlessPIR~\cite{liHintlessSingleServerPrivate2023} is a protocol which expands on SimplePIR to remove the need to send the hint.
In short, HintlessPIR retrieves the necessary row of the hint from the server, essentially delegating the step which requires the hint to the server.
YPIR~\cite{menonYPIRHighThroughputSingleServer2024} also takes a similar approach and retrieves the necessary row of the hint using high-rate RLWE ciphertexts.

WhisPIR~\cite{castroWhisPIRStatelessPrivate2024}, on the other hand, expands on the protocols with setup and aims to reduce the number of required cryptographic keys.
The authors propose a PIR protocol focused on being stateless, i.e., working well for ephemeral clients and having low communication.
Two main contributions of WhisPIR are
1) modifications to reduce the number of cryptographic keys that are required 2) not performing relinearization after homomorphic multiplications.
Using these techniques along with a careful choice of parameters, WhisPIR achieves a communication cost that is smaller than related work.
