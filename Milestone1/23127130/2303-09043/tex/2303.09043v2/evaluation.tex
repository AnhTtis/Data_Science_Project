\section{Evaluation}
\label{sec:evaluation}

We implemented our compression technique as a library in C++ using GMP.
We use Paillier as the additive encryption scheme, which is extended to Damgard-Jurik when we require a larger plaintext space.
We use a 3072-bit modulus for Pallier, composed of two 1536-bit primes, which is the recommended modulus size for 128-bit security~\cite{barkerRecommendationKeyManagement2020}.
We experiment with LWE and RLWE parameters satisfying 128-bit security but our methods can be applied to other LWE and RLWE parameters without any change.

Our code is open source and available upon acceptance. 
We also integrated it into existing FHE libraries like OpenFHE~\footnote{\url{https://github.com/openfheorg/openfhe-development}} and Concrete~\footnote{\url{https://github.com/zama-ai/concrete}} to show the effectiveness.
We also parallelized our implementation to minimize the latency of the compression.
Specifically, we parallelize over the LWE dimension $n$ or the number of LWE ciphertexts that are compression, depending on whichever is larger.
Using this dynamic approach, we use existing cores on our machines even when compressing few ciphertexts.

\paragraph{Experiment Scenarios.}

We experiment under two scenarios: 1) compressing a single LWE ciphertext or RLWE coefficient 2) compressing many LWE ciphertexts or multiple RLWE coefficients.
The former is useful in applications with small outputs such as private inference, whereas the latter is used for applications with large outputs such as image processing.

\subsection{Single Compression Evaluation}

\Cref{tab:evaluation-lwe-compress} summarizes the results for compressing a single LWE ciphertext. We choose LWE parameters adopted in existing libraries implementing variants of LWE encryption~\cite{zamaConcreteTFHECompiler2022,albadawiOpenFHEOpenSourceFully2022}.
The results show that we consistently provide high compression rates. Notably, for $\log_2 q = 64$, our compression rates are over 84\%.

Similarly, for compression of a single RLWE coefficient, we use common parameters for RLWE-based schemes such as BFV~\cite{brakerskiFullyHomomorphicEncryption2012,fan2012somewhat} and BGV~\cite{brakerskiLeveledFullyHomomorphic2012}, which are used in libraries such as SEAL~\cite{MicrosoftSEALRelease2023}, Lattigo and OpenFHE~\cite{albadawiOpenFHEOpenSourceFully2022}.
Recall that compression is compatible with modulus switching so we choose the parameters corresponding to the lowest level in a BFV/BGV parameter set. We achieve over 85\% compression and up to 98\%.

% We also observe that we require a compression key, which is the encryption of the LWE/RLWE encryption key using Paillier.
% While the compression key is over 300 KB, this is small compared to the bootstrapping keys required in libraries such as Concrete~\cite{zamaConcreteTFHECompiler2022}, which are over 10 MB, so it would add a small overhead to the existing key material that it sent from the client to the server.

% \begin{itemize}
%     \item Explain the results, over 90\% compression for a single ciphertext compression
% \end{itemize}

% The evaluation shows a significant size reduction for all parameter sets. There is at least 86\% reduction for the evaluated parameter sets for LWE and up to 95\% for CGGI in OpenFHE. Similarly, for RLWE, there is up to 97\% size reduction using the compression technique.

% Encryption of the LWE/RLWE secret key using Paillier, which is more expensive, is only performed once. Moreover, the encrypted secret key is still small compared to other keys used in FHE, e.g. public keys, key-switching keys and bootstrapping keys, which can be as large as many megabytes.

\subsection{Measuring Compression Key Sizes}

Using the technique described in \Cref{sec:smaller-compression-key}, we can pack the compression key and have the server unpack the key.
The unpacking can be done offline, as soon as the server receives the packed key, to reduce latency during compression.
The compression procedure is identical after the key has been unpacked, so we do not report the runtime of compression again.
Instead, we measure the size of the compression key, with and without packing, and report the time required to unpack the key.
We also distinguish two cases, non-binary and binary keys.
In the case of binary keys, we use $\delta=q+nq$ so more bits of the secret key can fit within the same ciphertext.
\Cref{tab:packed-compression-key} shows the size of the packed compression keys in the two cases. Note that even the size of the unpacked key is much smaller than commonly used cryptographic keys such as relinearization keys, automorphism keys, and bootstrapping keys, which could be as large as 100 MB.


\begin{table}[b]
    \centering
    \caption{
        Size of packed compression keys and unpacking time.
        We distinguish the case of binary and non-binary keys since binary keys can be packed more than non-binary keys.
        The Paillier modulus is 3072 bits in all cases.
    }
    \resizebox{\columnwidth}{!}{
    \begin{tabular}{c|c|c|c|c}
    \toprule
         $(n,\log_2 q)$ & (630,64) & (742,64) & (870,64) & (1305,11) \\
    \midrule
        Unpacked Key & 240 KB & 284 KB & 334 KB & 501 KB \\
    \midrule
        Packed Non-binary Key & 22 KB & 26 KB & 30 KB & 11 KB \\
        Unpacking Time & 14 ms & 25 ms & 74 ms & 15 ms \\
    \midrule
        Packed Binary Key & 12 KB & 14 KB & 16 KB & 7 KB \\
        Unpacking Time & 13 ms & 12 ms & 13 ms & 15 ms \\
    \bottomrule
    \end{tabular}
    }
    \label{tab:packed-compression-key}
\end{table}

\subsection{Batched Compression Evaluation}


\begin{figure*}[t]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            height=0.2\columnwidth,
            width=2*\columnwidth, % Ensure this axis is as wide as both subfigures together
            hide axis,
            xmin=0,
            xmax=1,
            ymin=0,
            ymax=1,
            legend columns=-1, % Horizontal legend
            legend style={/tikz/every even column/.append style={column sep=0.5cm}},
            legend to name=named, % Define legend name for referencing
        ]
            % \addlegendimage{color=red, mark size=1pt, mark=*}
            % \addlegendentry{Uncompressed LWE Ciphertexts}
    
            \addlegendimage{color=blue, mark size=1pt, mark=*}
            \addlegendentry{Compressed}
    
            \addlegendimage{color=black, mark size=1pt, mark=*}
            \addlegendentry{Compressed (Binary Key)}

            \addlegendimage{color=orange, mark size=1pt, mark=*}
            \addlegendentry{Rescaled \& Compressed (Binary Key)}
    
            \addlegendimage{color=teal, mark size=1pt, mark=*}
            \addlegendentry{Chen}
        \end{axis}
        \end{tikzpicture}
    
        \ref{named} % Referencing the named legend
\begin{subfigure}[b]{\columnwidth}
    \centering
    \begin{tikzpicture}[
        declare function={
            logb(\x,\y) = ln(\x)/ln(\y);
            s=1; % example value
            log2m=3072; % example value
            n=630; % example value
            log2q=64; % example value
            newlog2q=20; % example value
        },
    ]
    \begin{axis}[
        name=plot1,
        at={(0,0)},
        xlabel = {\footnotesize Number of Compressed LWE Ciphertexts},
        ylabel = {\footnotesize Aggregate Size (KB)},
        domain=0:1000,
        samples=100,
        ymin = 0.4,
        ymax = 400,
        ymode = log,
        xmin = -50,
        xmax = 1090,
        height = 0.45\columnwidth,
        width = \columnwidth,
        legend style={at={(0.2,0.6)},anchor=east} % Places legend at middle right side of the axis
    ]

        \addplot [color=red, mark size=0.75pt] {x * (n+1) * log2q / 8192 };
        % \addlegendentry{LWE Ciphertexts}
    
        \addplot [color=blue, mark size=0.75pt, mark=*] { (s+1)*log2m * ceil(x / floor(s * log2m / (1 + ceil(logb(n,2)) + 2*log2q))) / 8192 };
        % \addlegendentry{Compressed}

        \addplot [color=black, mark size=0.75pt, mark=*] { (s+1)*log2m * ceil(x / floor(s * log2m / (1 + ceil(logb(n,2)) + log2q))) / 8192 };
        % \addlegendentry{Compressed (Binary Key)}

        \addplot [color=orange, mark size=0.75pt, mark=*] { (s+1)*log2m * ceil(x / floor(s * log2m / (1 + ceil(logb(n,2)) + newlog2q))) / 8192 };
        % \addlegendentry{Compressed (Binary Key)}

        \addplot [color=teal, mark size=0.75pt, mark=*] table [
            x=slots,
            y expr=\thisrow{compressed_size_B}/1024,
            col sep=comma
        ] {data/chen.csv};
        % \addlegendentry{Chen}
        
    \end{axis}    
    \end{tikzpicture}
    \caption{Compressed Size}
    \label{fig:batched-lwe-compression-n=630-communication}
\end{subfigure}
~
\begin{subfigure}[b]{\columnwidth}
    \begin{tikzpicture}[]
        \begin{axis}[
            name=plot1,
            at={(0,0)},
            xlabel = {\footnotesize Number of Compressed LWE Ciphertexts},
            ylabel = {\footnotesize Compression Time (s)},
            height = 0.45 \columnwidth,
            width = \columnwidth,
            ymode=log,
            legend pos=south east,
            error bars/y dir=both,
            error bars/y explicit
        ]

            \addplot [color=blue, mark size=1pt, mark=*] table [
                x=num_cts,
                y expr=\thisrow{compress_time_us_mean}/1000000,
                y error expr=\thisrow{compress_time_us_std}/1000000,
                col sep=comma
            ] {data/table2_nonbinkey.csv};
            % \addlegendentry{Compressed}

            \addplot [color=black, mark size=1pt, mark=*] table [
                x=num_cts,
                y expr=\thisrow{compress_time_us_mean}/1000000,
                y error expr=\thisrow{compress_time_us_std}/1000000,
                col sep=comma
            ] {data/table2_binkey.csv};
            % \addlegendentry{Compressed (Binary Key)}

            \addplot [color=orange, mark size=1pt, mark=*] table [
                x=num_cts,
                y expr=\thisrow{compress_time_us_mean}/1000000,
                y error expr=\thisrow{compress_time_us_std}/1000000,
                col sep=comma
            ] {data/table2_binkey_switched.csv};
            % \addlegendentry{Compressed (Binary Key)}

            \addplot [color=teal, mark size=1pt, mark=*] table [
                x=slots,
                y expr=\thisrow{total_time_ms}/1000,
                col sep=comma
            ] {data/chen.csv};
            % \addlegendentry{Chen}
        \end{axis}    
    \end{tikzpicture}
    \caption{Time for Compression}
    \label{fig:batched-lwe-compression-n=630-computation}
\end{subfigure}
    \caption{
        Compressed size and compression time required for compressing LWE ciphertexts with $(n,q)=(630, 2^{64})$ using batched compression. The red line denotes the baseline size of uncompressed LWE ciphertexts.
    }
    \label{fig:compressing-batched-lwe}
\end{figure*}


Next, we evaluate the batched compression of LWE ciphertexts.
In both cases, we use the batched compression algorithm to compress $\ell$ ciphertext into additive Paillier ciphertexts.
% It is possible to use Damgard-Jurik ciphertexts when we compress many LWE ciphertexts, which offers a computation/communication tradeoff.
% We elaborate on this tradeoff in \appsection{sec:larger-space}.
Note that for batched compression, we can not use packed compression keys.

We distinguish the case of binary keys from non-binary keys in the experiment, denoted by blue and black lines, respectively.
As mentioned in \Cref{sec:batched-compression}, we set the scale to $\gamma=q + n q^2$ and $\gamma=q + n q$ in the case of non-binary and binary keys, respectively.
We also visualize a case where we rescale to a smaller modulus before compression.

The alternative approach to packing many LWE ciphertexts is RLWE packing~\cite{chenEfficientHomomorphicConversion2021,chillottiTFHEFastFully2020}.
Our reference point for RLWE packing is the work of Chen et al.~\cite{chenEfficientHomomorphicConversion2021} which is state-of-the-art in compression and has better runtime than related work.
This work maps LWE ciphertexts in $\ZZ_q^n\times\ZZ$ to an RLWE ciphertext in $\ZZ_q[X]/(X^n+1)$.

\Cref{fig:batched-lwe-compression-n=630-communication} shows the size after compression as a function of the number of compressed LWE ciphertexts.
\Cref{fig:batched-lwe-compression-n=630-computation} also shows the runtime of batched compression.
The blue and black plots correspond to non-binary and binary keys, respectively.
The orange plot also shows batched compression but over ciphertexts that are rescaled to $r=2^{20}$.
In the case of non-binary keys, we only need one Paillier ciphertext for up to 14 LWE ciphertexts and for binary keys, it is about 26.
Overall, compressing more LWE ciphertexts offers more compression compared to compressing only one LWE ciphertext.
This is because more of the plaintext space of Paillier is being utilized as more ciphertexts are compressed.
We also observe that rescaling improves the runtime and allows more compression, as is expected.
In comparison to the work of Chen et al., our compression protocol offers more than one order of magnitude compression compared to RLWE packing.
However, our compression approach is slower than RLWE packing, particularly due to the use of expensive modular exponentiations.

% \paragraph{Batch Compression of RLWE Coefficients}

% Compression of RLWE coefficients offers a different tradeoff.
% When fewer ciphertexts are compressed, the compression rate is higher but decreases as the number of compressed coefficients increases.
% This is because the size of the original RLWE ciphertext is fixed, but the size of the compressed ciphertexts increases.

% \Cref{fig:batched-rlwe-compression} visualized this tradeoff. For $N=2048$ respectively, you can compress over 1700 coefficients of the RLWE plaintext before the compression procedure does not offer any advantage.
% Similar trends hold for other parameter sets.

% \begin{table}
%     \centering
%     \caption{
%         Compressing $n_0$ LWE ciphertexts using our technique and RLWE packing.
%         Comparison with the work of Chen et al.~\cite{chenEfficientHomomorphicConversion2021} which uses $(N,\log_2 q) = (4096, 72)$. Numbers are taken from their paper since their implementation is not available.
%     }    
%     \resizebox{\columnwidth}{!}{
%     \begin{tabular}{c|c|c|c|c}
%     \toprule
%         % $(N,q)$ & & $(2^{12}, 72)$ \\ 
%          & Uncompressed & & Our Work & \cite{chenEfficientHomomorphicConversion2021} \\
%     \midrule
%         \multirow{3}{*}{$n_0=2$} & \multirow{3}{*}{72 KB} & Time & 12.5 ms & \textbf{11.4 ms} \\
%         & & Size & 512 B & 72 KB \\
%         & & Compression & \textbf{144$\times$} & 1$\times$ \\
%     \midrule
%         \multirow{3}{*}{$n_0=8$} & \multirow{3}{*}{288 KB} & Time & 51.8 ms & \textbf{16.8 ms} \\
%         & & Size & 512 B & 72 KB \\
%         & & Compression & \textbf{567$\times$} & 4$\times$ \\
%     \midrule
%         \multirow{3}{*}{$n_0=32$} & \multirow{3}{*}{1152 KB} & Time & 215.2 ms & \textbf{45.0 ms}\\
%         & & Size & 1.5 KB & 72 KB \\
%         & & Compression & \textbf{768$\times$} & 16$\times$ \\
%     \bottomrule
%     \end{tabular}
%     }
%     \label{tab:compare-chen}
% \end{table}