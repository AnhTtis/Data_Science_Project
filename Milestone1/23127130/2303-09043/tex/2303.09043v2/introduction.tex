\section{Introduction}
\label{sec:introduction}

Privacy-preserving services such as compromised credential checks and private contact discovery~\cite{liProtocolsCheckingCompromised2019a, Thomas2019ProtectingAF} have become more prevalent in recent years.
However, privacy-preserving services are associated with a computation and communication overhead, which is a barrier to using these services in many cases.
If private services can be offered with less overhead, it will make them more amenable and users more likely to access and use them.
While these services are built using a variety of tools and techniques, one commonly used tool is homomorphic encryption.

Fully Homomorphic Encryption (FHE), often deemed the holy grail of encryption, is a form of encryption which permits computation on data in encrypted form, without the need to decrypt.
Initial homomorphic cryptosystems were impractically slow~\cite{gentryFullyHomomorphicEncryption2011,vandijkFullyHomomorphicEncryption2010}.
Over the last decade, FHE has advanced significantly and there have been many advances in functionality and many orders of magnitude improvements in runtime~\cite{brakerskiFullyHomomorphicEncryption2012,fan2012somewhat,brakerskiLeveledFullyHomomorphic2012,cheonHomomorphicEncryptionArithmetic2017a,chillottiTFHEFastFully2020}.

However, another important aspect of performance for FHE is its communication costs.
FHE is frequently used to design a protocol in a client-server model~\cite{liProtocolsCheckingCompromised2019a}, where the client uploads its encrypted inputs to the server.
The server processes the information and returns the encrypted result to the client.
While such protocols require one round trip, the bandwidth usage can be extremely high because homomorphic ciphertexts are much larger than their underlying plaintext.
The server can improve the runtime via better hardware and parallelization, but it is impractical to assume all clients have a reliable and high-bandwidth network connection.

The main reason for high communication costs in FHE protocols is large ciphertexts.
Homomorphic encryption schemes based on lattices, which are the most widely used today, have large ciphertext sizes~\cite{regevLatticesLearningErrors2009,lyubashevskyIdealLatticesLearning2010}.
In the aforementioned client-server setup, communication costs consist of uploaded ciphertexts, in the form of a query, and downloaded ciphertexts which are the response.
While there are effective methods to reduce upload costs~\cite{aliCommunicationComputationTradeoffs2021a,choTranscipheringFrameworkApproximate2021a,dobraunigPastaCaseHybrid2021,dobraunigRastaCipherLow2018,albrechtCiphersMPCFHE2015,canteautStreamCiphersPractical2018}, the same techniques can not be applied to reduce download costs and a different approach is required

\emph{Approaches to Reduce Download Costs.}
Works as early as the work of Naehrig et al.~\cite{naehrigCanHomomorphicEncryption2011a} suggested switching to smaller parameters in the LWE-based schemes before sending the ciphertexts back to the client.
In RLWE-based schemes, it is common to perform a modulus switching to the lowest prime modulus before sending the results back to the client~\cite{MicrosoftSEALRelease2023,cheonHomomorphicEncryptionArithmetic2017a}.
Such techniques result in ciphertexts that do not support further homomorphic operations but contain the same message as the original ciphertext.
Despite these improvements, the size of the ciphertext is still proportionate to $O(n\log q)$ in the case of LWE, where $n$ and $q$ are the ciphertext dimension and ciphertext modulus, respectively.
Other works propose compression of GSW ciphertexts~\cite{gentryCompressibleFHEApplications2019,brakerskiLeveragingLinearDecryption2019} and LTV ciphertexts~\cite{huImprovingEfficiencyHomomorphic2013}, but these ciphertexts are not usually sent over the network and are used internally in procedures such as bootstrapping~\cite{chillottiTFHEFastFully2020}.
Moreover, size reduction is only achieved when there are many ciphertexts to compress~\cite{gentryCompressibleFHEApplications2019, brakerskiLeveragingLinearDecryption2019}.

\emph{Our Approach.}
To achieve smaller response sizes in practical applications, we propose a technique to compress ciphertexts based on LWE and RLWE, which are commonly transmitted over the network.
Our technique exploits the linear step in LWE and RLWE decryption to delegate part of the decryption to the server.
Our idea is to use additively homomorphic encryption for this step which has a much smaller ciphertext expansion factor.
However, a naive application of this idea is neither communication nor computation efficient and we develop several optimizations to help this technique advance over the state-of-the-art.
Our evaluation shows that this results in size reduction from 6.8KB to 512 bytes (about 90\%) for a single LWE ciphertext with common parameters.
By compressing many ciphertexts at once, we can achieve higher compression ratios of up to 99\%.
The only necessary information for this size reduction is a small compression key which can be reused across interactions and to compress all ciphertexts encrypted under a specific public key.
Our techniques can be readily applied to applications which transmit LWE ciphertexts back to the client in a plug-and-play fashion.
Aside from the generic application of our technique, we also identified specific applications which benefit from compression.
One such application is private information retrieval.

\emph{Problem of PIR protocols.}
In a Private Information Retrieval (PIR) protocol, the client wishes to retrieve an element from a database such that the server learns nothing about the client's desired query.
In many real-world applications of PIR, the client may not have an established, permanent connection with the server.
Many existing PIR protocols are not suitable for ephemeral, temporary clients.
More specifically, they suffer from one of two limitations:
1) They require clients to send large cryptographic keys, which the server has to store.
This is a per-client storage on the server which would only be beneficial if the clients were making many queries.
2) The server gives a database-dependant hint to the client(s).
While this hint makes online queries very fast, it is a high upfront communication cost that needs to be amortized over many queries.
% Moreover, if the database is updated, the hint needs to be updated and transmitted to all clients, incurring more overhead. 

\emph{\protocol{}: Low-Communication PIR using Compression}
Using our compression technique, we devise a practical PIR protocol with preprocessing, dubbed \protocol{}, which does not require any hint to be transmitted to the clients but only our small compression keys from the client to the server. 
These compression keys are small and change between interactions.
Therefore, there is no need for per-client storage on the server.
Our construction only requires client-independent preprocessing by the server, which can easily be updated as the database changes.
\protocol{} requires only 200 KB - 500 KB of communication, even for large databases, and has a competitive runtime with other protocols operating in the same model.
In summary, \protocol{} has the lowest communication of all state-of-the-art PIR protocols in the literature \cite{castroWhisPIRStatelessPrivate2024, liHintlessSingleServerPrivate2023}, making it suitable for applications with ephemeral clients in low latency networks and frequently updating databases.