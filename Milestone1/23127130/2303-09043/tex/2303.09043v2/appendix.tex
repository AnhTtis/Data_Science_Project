% Appendices
\begin{appendices}


\section{LWECompress Using Packed Compression Keys}
\label{sec:lwe-compress-packed-keys}

The necessary procedures for using a packed compression key is given in \Cref{alg:packed-key-compress}. The $\textsc{GeneratePackedKey}$ procedure generates the packed key from the LWE secret key.
The unpacking procedure computes the compression key from the packed compression key by scaling the packed key with different values.
By packing in this particular manner, the compression procedure can be done similar to before, without any changes.
The final change is made in the decryption.
The response is not necessarily in the lower order bits of the additive ciphertext ciphertext anymore, so a division is required before continuing with the rest of the LWE decryption procedure.

\begin{algorithm}[t]
	 \caption{Procedures for using a packed compression key,       including generating the packed key, unpacking it, and the corresponding modified decryption function.
        }
	 \label{alg:packed-key-compress}
	 \begin{algorithmic}[1]
    \Procedure{GeneratePackedKey}{$\addkey,\sk$}
        \State $t = \floor{\frac{0.5\log_2 m}{\log_2\delta}}$
        \For {$i\in[\ceil{n/t}]$}
            \State $r \leftarrow \delta^{-(t-1)} (\sum_{j\in[t]}\sk[it+j] \cdot \delta^{j}) \mod m$
            \State $ \pck_{i} \leftarrow \texttt{AEnc}(\addkey, r)$  
        \EndFor
        \State \Return $\pck$
    \EndProcedure
    \vspace{3mm}
    \Procedure{UnpackCompressionKey$_q$}{$\pck$}
        \For {$i\in[\ceil{n/t}]$}
            \For {$j\in[t]$}
                \State $\ck[it+j] \leftarrow \delta^{t-1-j} \otimes \pck[i]$
            \EndFor
        \EndFor
    \State \Return $\ck$
    \EndProcedure
    \vspace{3mm}
    \Procedure{ModifiedLWEDecryptPackedKey$_{q, p}$}{$\addkey,x$}
        \State $y \leftarrow \delta^{(t-1)}  \texttt{ADec}(\addkey, x) \mod m$ 
        \State $\mu^{**} = \floor{y / \delta^{(t-1)}} \mod q$
        \vspace{1mm}
        \State $ \mu'' = \lfloor \mu^{**}/\Delta\rceil$
        \Comment{$\Delta=\round{q/p}$}
        \vspace{2mm}
        \State \Return $\mu'' \in \ZZ_{p}$
   \EndProcedure
    \end{algorithmic}
\end{algorithm}

% \section{Increasing the Plaintext Space}
% \label{sec:larger-space}


% Up to this point, we have restricted ourselves to Paillier ciphertexts, which have a fixed plaintext size for given parameters and, as explained in \Cref{sec:batched-compression}, we can only compress 
% $$
%     \floor{\frac{\log_2 m}{\log_2 (q+nq^2)}}
% $$
% LWE ciphertexts into one Paillier ciphertext with plaintext space $m$.
% One approach is to use multiple Paillier ciphertexts to compress more ciphertexts that can fit into one Paillier ciphertext.
% Even if the entire plaintext space of Paillier is utilized, Paillier ciphertexts are twice as large as their underlying plaintext. Hence, the ratio between the aggregate size of the phases of the LWE ciphertexts and the Paillier ciphertexts will never drop below 1/2.
% To tackle this problem and achieve better compression rates, we can increase the plaintext space.

% Damgard-Jurik is a generalization of Paillier which has the freedom to increase the plaintext space.
% Specifically, if $m$ is the public key of the cryptosystem, Damdard-Jurik can encrypt plaintexts in $\ZZ_{m^s}$ with ciphertexts in $\ZZ_{m^{s+1}}$.
% Hence, the expansion ratio of Damgard-Jurik is $\frac{s \log_2 m}{(s+1)\log_2 m} = \frac{s}{s+1}$, which is better than the expansion ratio of Pailier which is $1/2$.

% However, the drawback of using Damgard-Jurik is the time required for compression.
% Operations over Damgard-Jurik ciphertexts are more computationally expensive.
% The reason is that the modulus over which the operations are happening is much larger. So we aim to answer the question: how large can $s$ be to offer meaning compression at a reasonable computational cost?

% To visualize this tradeoff, we conduct an experiment where we compress $n_0=400,800$ LWE ciphertexts using Damgard-Jurik as the additive ciphertext with varying $s$.
% If $s$ is small such that the $n_0$ LWE ciphertexts do not fit within the same Damgard-Jurik ciphertext, we use multiple ciphertexts.
% \Cref{fig:comm-comp-tradeoff} visualizes the tradeoff between compression time and the aggregate compressed size.
% We vary $s$ to show the effect of this parameter.
% \Cref{fig:comm-comp-tradeoff} shows that we have 35\% more compression by using $s=2$ instead of $s=1$ at the cost of about 80\% more runtime. 
% Increasing $s$ beyond 2 offers diminishing returns for compression and drastically increases the runtime.

% \begin{figure}[t]
%     \centering
%     \begin{tikzpicture}
%         \begin{axis}[
%             height=0.6\columnwidth,
%             width=\columnwidth,
%             xlabel={Compression Time (s)},
%             ylabel={Compressed Size (KB)},
%             grid=major,
%             scatter/classes={a={mark=square*,black}},
%             scatter, 
%             scatter src=explicit symbolic,
%             visualization depends on={\thisrow{s}*0.5pt \as \marksize},
%             scatter/@pre marker code/.append style={/tikz/mark size=\marksize}
%         ]
%             \addplot table [x=compress_time_s, y=compressed_ct_size_KB, meta=s, col sep=comma] {data/tradeoff_num_cts=400.csv};
%             \addlegendentry{$n_0=400$}

%             \addplot table [x=compress_time_s, y=compressed_ct_size_KB, meta=s, col sep=comma] {data/tradeoff_num_cts=800.csv};
%             \addlegendentry{$n_0=800$}
            
%         \end{axis}
%     \end{tikzpicture}
%     \caption{Aggregate compressed ciphertext size as a function of the compression time, when compressing $n_0$ LWE ciphertexts. We the parameter of Damgard-Jurik from $s=1$ to $s=7$ to visualize the effect. Smaller markers correspond to smaller values of $s$. We plot this graph for compressing 400 and 800 LWE ciphertexts. }
%     \label{fig:comm-comp-tradeoff}
% \end{figure}

% \section{Using smaller scales for batched compression}
% \label{sec:smaller-scale}

% \begin{proof}
%     \TODO{fix this proof}
%     By the proof of \Cref{thm:lwe-compress-correct} we know that if $\mu^{**}_j=\texttt{ADec}_{\texttt{s}}(x_j)$, then $0\leq \mu^{**}_j < \gamma = q + nq^2$. Hence, we have
%     \begin{align*}
%         \mu^{**} = \sum_{j\in[\ell]} \gamma^j \mu^{**}_j \leq \sum_{j\in[\ell]} \gamma^j (\gamma-1) = \gamma^{\ell} - 1 < \gamma^{\ell} < m .
%     \end{align*}
%     Hence, the plaintext corresponding to $x$, i.e. $\mu^{**}$, does not overflow in the plaintext space of the additive ciphertext.
%     If $\mu^*_j$ us equivalent to $\mu^*$ in the \textsc{LWEEncrypt} procedure, then for some value $t$,
%     \begin{align*}
%         &\mu''_j =\floor{\mu^{**}/\gamma^j} \mod \gamma \\
%         &= (\floor{\mu^*_{j-1}/\gamma} + \mu^*_j + \gamma \cdot t ) \mod \gamma \\
%         &= \floor{\mu^*_{j-1}/\gamma} + \mu^*_j \\
%         & \leq \floor{(q + nq^2) / \gamma} + \mu^*_j \\
%         & = \Delta/4 + \mu^*_j \\
%     \end{align*}
%     which produces the same result as $\mu^*_j$, if the error in $\mu^*_j$ is less than $\Delta/4$
% \end{proof}

% \section{RLWE Batched Compression Evaluation}

% RLWE coefficients can be compressed in batched manner, similar to how we compressed LWE ciphertexts.
% However, compression of RLWE coefficients offers a different tradeoff.
% When fewer ciphertexts are compressed, the compression rate is higher but decreases as the number of compressed coefficients increases.
% This is because the size of the original RLWE ciphertext is fixed, but the size of the compressed ciphertexts increases.

% \Cref{fig:batched-rlwe-compression} visualized this tradeoff. For $N=2048$, you can compress up to 800 coefficients of the RLWE plaintext before the compression procedure does not offer any advantage.


% \begin{figure}[t]
%     \centering

%     \begin{tikzpicture}[
%         declare function={
%             logb(\x,\y) = ln(\x)/ln(\y);
%             s=1; % example value
%             log2m=3072; % example value
%             N=2048; % example value
%             log2Q=54; % example value
%         },
%     ]
%     \begin{axis}[
%         name=plot1,
%         at={(0,0)},
%         xlabel = {Number of Compressed RLWE Coefficients},
%         ylabel = {Aggregate Ciphertext Size (KB)},
%         domain=0:800,
%         samples=100,
%         ymin = 0,
%         ymax = 40,
%         ymode = log,
%         xmin = 0,
%         xmax = 800,
%         height = 0.52 \columnwidth,
%         width = \columnwidth,
%         legend style={at={(.95,0.27)},anchor=east} % Places legend at middle right side of the axis
%     ]
%         \addplot [color=blue, mark size=1pt, mark=*] { (s+1)*log2m * ceil(x / floor(s * log2m / (2 + ceil(logb(N,2)) + 2*log2Q))) / 8192 };
%         \addlegendentry{Compressed}

%         \addplot [color=black, mark size=1pt, mark=*] { (s+1)*log2m * ceil(x / floor(s * log2m / (2 + ceil(logb(N,2)) + log2Q))) / 8192 };
%         \addlegendentry{Compressed (Binary Keys)}

%         \addplot [color=red, mark size=1pt, mark=*] {2 * N * log2Q / 8192 };
%         \addlegendentry{RLWE Ciphertext}
%     \end{axis}
%     \end{tikzpicture}
%     \caption{Compressing RLWE Coefficients $(N,q)=(2048, 2^{54})$}
%     \label{fig:batched-rlwe-compression}    
% \end{figure}


\section{Proof of RLWE Compression}
\label{sec:prove-rlwe-compress}

\begin{proof}

Line 1 of \Cref{alg:rlwe-compress-response} computes 
$$
B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\
$$
encrypted under additive encryption, which is possible due to the linear properties.
We know that all coefficients of $A(X)$, $B(X)$, and $S(X)$ are elements in $\ZZ_q$, hence

{\footnotesize
    \begin{align*}
        B[k] + \left(\sum_{i=0}^{k} (q-A[k-i]) \cdot S[i]\right)
        + \left(\sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right)\\
        \leq q + \left(\sum_{i=0}^{k} q \cdot q\right) + \left(\sum_{i=k+1}^{N-1} q \cdot q\right)
        = q + Nq^2 < m
    \end{align*}
}%
so there is no overflow in the plaintext space of the additive cryptosystem.

{\tiny
    \begin{align*}
        & \mu^{**}_{k} = \texttt{ADec}_{s}(x) \mod q \\
        & = \left(\left(B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] \right. \right.\\
        & ~~~~~~~~~~~~~~~~~~~~~~~~~~ \left.\left.+\sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right) \mod m \right) \mod q \\
        & = \left( B[k] + \sum_{i=0}^{k} (q-A[k-i]) \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i]\right) \mod q \\
        & = B[k] - \sum_{i=0}^{k} A[k-i] \cdot S[i] + \sum_{i=k+1}^{N-1} A[N+k-i] \cdot S[i] \mod q
    \end{align*}
}%

which is equivalent to the $k^{th}$ coefficient of 
$$
    \mu^*(X) = B(X) - A(X) \cdot S(X) \mod R_q
$$
which can be seen by expanding the equation.
Given that line 16 of \Cref{alg:lwe-encrypt-decrypt} performs rounding coefficient-wise, it produces the same result as line 10 of \Cref{alg:rlwe-compress-response}.
\end{proof}

\section{Modulus Switching Theorem}
\label{sec:modulus-switching-theorem}


Modulus switching is a known technique, mainly for RLWE schemes for various reasons.
We use it as well but for LWE-based schemes.
Particularly, if the error in an LWE ciphertext is not too high, the modulus can be smaller. The following theorem summarizes this fact.

\begin{lemma}
    Define LWE dimension $n$, ciphertext modulus $q$, plaintext modulus $p$, such that $p|q$.
    Also, assume $\sk\in\{0,1\}^{n}$ is a binary secret key.
    Assume $ct=(\textbf{a},b)$ is an LWE ciphertext encrypting message $m\in \ZZ_p$ such that $b = \sum \textbf{a}[i] \sk[i] + e + \frac{q}{p}m \mod q$ such that $|e|<\frac{q}{4p}$.
    Now define $ct' = (\textbf{a}',b')$ where $\textbf{a}'[i]=\round{\frac{r\textbf{a}[i]}{q}}$ and $b'=\round{\frac{r b}{q}}$. If $r\geq 2(n+1)p$ and then 
    {\footnotesize
    \begin{align}
        \textsc{LWEDecrypt}_{r,p}(\sk, ct) = \textsc{LWEDecrypt}_{q,p}(\sk, ct') = m
    \end{align}
    }
\end{lemma}

\newcommand{\half}{\frac{1}{2}}

\begin{proof}
    By definition, we can find a $k\in\ZZ$ such that
    \begin{align}
        b - kq = \sum \textbf{a}[i] \sk[i] + e + \frac{q}{p} m
    \end{align}
    So
    \begin{align}
        & b' - \sum \textbf{a}[i]' \cdot \sk[i] \\
        &= \round{\frac{r b}{q}} - \sum \round{\frac{r\textbf{a}[i]}{q}} \cdot \sk[i]  \\
        &\leq \frac{r b}{q} + \half - \sum (\frac{r\textbf{a}[i]}{q} - \half) \cdot \sk[i] \\
        &= \frac{r}{q}(b' - \sum \textbf{a}[i]\sk[i]) + \half + \half \sum \sk[i] \\
        &= \frac{r}{q} ( kq + e + \frac{q}{p} m) + \half + \half \sum \sk[i] \\
        &= kr + \frac{r}{p} m + \frac{er}{q} + \half + \half \sum \sk[i]
    \end{align}
    Now if we name $e' = \frac{er}{q} + \half + \half \sum \sk[i]$ then it suffices to have $|e'| < \frac{r}{2p}$ to have correct decryption, and using the assumptions we can see that 
    {\footnotesize
    \begin{align}
        |e'| = |\frac{er}{q} + \half + \half \sum \sk[i]| \leq |\frac{q}{4p}\frac{r}{q}| + |\frac{n+1}{2}| \leq |\frac{r}{2p}|
    \end{align}
    }
\end{proof}

\section{Definitions}
Our compression technique and proposed PIR protocol rely on two important problems, Learning with Errors and the security of the Paillier cryptosystem.

\subsection{Learning with Errors}
The Learning with Errors (LWE) assumption is parameterized by dimension $n\in\NN$, modulus $q\in\NN$, an error distribution $\chi_e$ over $\ZZ$, and a secret key distribution $\chi_s$ over $\ZZ_q$, and number of samples $m\in\NN$. 
The LWE hardness assumption states that the following two distributions
\begin{align*}
    \mathcal{D}_0 &= \{ (\mask, \mask\cdot\sk+e ) | \mask\sample\ZZ_{m\times n},~\sk\leftarrow\chi_s,~e\leftarrow\chi_e^m\} \\
    \mathcal{D}_1 &= \{ (\mask, r ) | \mask\sample\ZZ_{m\times n},~r\sample\ZZ_q^m\}
\end{align*}
are computationally indistinguishable. 
More concretely, $(n,q,\chi_e,\chi_s)$-LWE is $\epsilon$-hard, if for any PPT time adversary $\adv$ has at most $\epsilon$ advantage in distinguishing the two distributions.

\subsection{Paillier Cryptosystem}
The Paillier cryptosystem~\cite{paillierPublicKeyCryptosystemsBased1999} is a semantically secure cryptosystem based on the hardness of the composite residuosity assumption.
We say that Paillier is $\epsilon_{P}$-secure, if any PPT adversary has at most $\epsilon_{P}$ advantage in the IND-CPA game.

\section{Security \& Correctness of ZipPIR}
\label{appendix:proof}

\begin{theorem}[Correctness]
    For LWE parameters $(n,q,\chi)$ where $\chi$ is a discrete Gaussian with standard deviation $\sigma$, plaintext modulus $p$ such that $p|q$, and failure rate $\delta$ such that 
    \begin{align}
        \Delta > 2p\sigma \sqrt{2d_0\ln (2/\delta)} 
    \end{align}
    where $\Delta=q/p$ and for random $\mask\in\ZZ_q^{d_0\times n}$, for any database $\db\in\ZZ_{p}^{N_0\times d_0}$, and any query $(i,i_0)\in[N_0]\times[d_0]$, if 
    \begin{align}
        \hint\leftarrow\textsc{Setup}(\db) \\
        (\paillierkey, \qu) \leftarrow \textsc{Query}((i,i_0)) \\
        \ans \leftarrow \textsc{Response}(\db, \qu) \\
        f \leftarrow \textsc{Extract}(\paillierkey, \ans)
    \end{align}
    then $\PP[\db[i][i_0] = f] > 1 - \delta$.
\end{theorem}

\begin{proof}
We break down the proof into several steps.
First, we prove that $\textsc{LWEDecrypt}_{q,p}(\sk, D[j]) = \db[j][i_0]$ for every $j\in[N_0]$ with probability $\delta$.
We see that 
\begin{align}
    D[j] & = [H[j]|b[j]] \\
    & = [\db\cdot\mask[j] | \db\cdot \qu_0[j] ]\\
    & = (\db \cdot [\mask|\qu_0])[j]\\
    & = (\db[j] \cdot [\mask|\qu_0])
\end{align}
Now, note that in the first step of LWE decryption, we compute the following
\begin{align}
    & D[j][n] - D[j][:n] \cdot \sk \\
    & = \db[j] \cdot \qu_0 - \db[j] \cdot \mask \cdot \sk \\
    & = \db[j] \cdot (\mask \cdot \sk + e + \Delta u_0) - \db[j] \cdot \mask \cdot \sk \\
    & = \db[j] \cdot e + \db[j] \cdot \Delta u_0 = e_0 + \Delta \db[j][i_0]
\end{align}
where we define $e_0=\db[j] \cdot e$.
Note the required bound for correct decryption is simply $|e_0|<\Delta/2$, but we check for a stricter condition which will become necessary in the next step.
Specifically, we will check the probability that $|e_0|<\Delta/4$. Assume that the standard deviation of the discrete Gaussian distribution $\chi$ is $\sigma=\frac{s}{2\pi}$ for some $s>0$.
We follow the analysis of Henzinger et al.\cite[Theorem C.1]{henzingerOneServerPrice2023} and we see that for any $T>0$,  
\begin{align}
    \PP\left[ | \db[j] \cdot e | \geq T s \eudist{\db[j]} \right] < 2\exp(-\pi T^2)
\end{align}
where $\eudist{\cdot}$ denotes the Euclidean norm.
We plug in $T = \frac{\Delta}{4s\eudist{\db[j]}}$ and also observe that $\eudist{\db[j]} \leq \sqrt{d_0 (p/2)^2}$. Simplifying the equation and plugging in the fact that $s=\sigma\sqrt{2\pi}$, we see that 

\begin{align}
    \PP\left[ | \db[j] \cdot e | \geq \Delta/4 \right] &< 2\exp(-\pi T^2) \\
    &= 2\exp(-\pi (\frac{\Delta }{ 4s\eudist{\db[j]}}) ^2) \\
    &\leq 2\exp(-\pi (\frac{\Delta}{4\sigma \sqrt{2\pi} \frac{p}{2}\sqrt{d_0}})^2) \\
    &\leq 2\exp(-(\frac{\Delta}{2p \sigma\sqrt{2 d_0}})^2)
\end{align}

so we only require the last equation to be less than $\delta$ for the theorem to hold, which will occur if and only if

\begin{align}
    2\exp(-(\frac{\Delta}{2p \sigma\sqrt{2 d_0}})^2) < \delta
    \iff \Delta > 2p\sigma \sqrt{2d_0\ln (2/\delta)} 
\end{align}

So given that $|e_0| < \Delta/4 < \Delta/2$ with high probability, the decryption of $D[j]$ will succeed with high probability.

In the next step of the proof, we exploit the fact that $|e_0| < \Delta/4$ with high probability to use the modulus switching theorem from \appsection{sec:modulus-switching-theorem}. Hence, with probability $1-\delta$, 
\begin{align}
    \textsc{LWEDecrypt}(\sk, D_0[j]) = \textsc{LWEDecrypt}(\sk, D[j])
\end{align}

In the next step, we prove that for $\ell\in[k+1]$
\begin{align}
    f_{\ell} = c_{\ell}[i_{\ell+1}N_{\ell+1} + \cdots + i_{k}N_{k}]
    \label{eq:f-to-c-transform}
\end{align}
which we prove by induction. By definition, we know that $f_{k} = c_k[0]$. 
Assume that \Cref{eq:f-to-c-transform} holds for every $\ell \geq \ell'$ for some $\ell'$. We will show that \Cref{eq:f-to-c-transform} holds for $\ell=\ell'-1$.
For succinctness, define $t=i_{\ell+1}N_{\ell+1} + \cdots + i_{k}N_{k}$ and $\dec(\cdot)=\textsc{PaillierDecrypt}(\paillierkey, \cdot)$. Now for any $h\in[2^{\ell}]$ we have
\begin{align}
    f_{\ell-1}[h]
    & = m \cdot p_{\ell}[2h+1] + p_{\ell}[2h] \\
    & = m \cdot \dec(f_{\ell}[2h+1]) + \dec(f_{\ell}[2h]) \\
    & = m \cdot \dec(c_{\ell}[t][2h+1]) +\dec(c_{\ell}[t][2h]) \\
    & = m \cdot \floor{c_{\ell-1}[i_{\ell}N_{\ell} + t][h]/m} \\
    &   + c_{\ell-1}[i_{\ell}N_{\ell}+t][h] \mod m \\
    & = c_{\ell-1}[i_{\ell}N_{\ell}+t][h]\\
    & = c_{\ell-1}[i_{\ell}N_{\ell}+i_{\ell+1}N_{\ell+1} + \cdots + i_{k}N_{k}][h]
\end{align}
and by combining this for all values of $h$, we see that 
$$
    f_{\ell-1} = c_{\ell-1}[i_{\ell}N_{\ell} + \cdots + i_{k}N_{k}]
$$
We now have all the pieces to prove the full theorem. 
Due to the last step, we can see that $f_{0} = c_{0}[i_{0}N_{0} + \cdots + i_{k}N_{k}]=c_0[i]$.
Note that we used the fact that based on the definition of $i_\ell$, we have $i=i_{0}N_{0} + \cdots + i_{k}N_{k}$.
So  
\begin{align}
   f & = \textsc{ModifiedLWEDecrypt}_{r, p}(\paillierkey, f_0) \\
     & = \textsc{ModifiedLWEDecrypt}_{r, p}(\paillierkey, c_0[i]) \\
     & = \textsc{LWEDecrypt}_{r, p}(\sk, \textbf{D}_0[i]) \\
     & = \textsc{LWEDecrypt}_{q, p}(\sk, \textbf{D}[i]) \\
     & = \db[i][i_0]
\end{align}
where the second to third line holds since
\begin{align*}
    c_0[i] = \textsc{FastLWECompress}_{r}(\eck, \textbf{D}_0[i])
\end{align*}
and this proves the theorem.
\end{proof}


% \begin{theorem}[Security]
%     Assume that \protocol{} is instantiated with $\epsilon_{L}$-secure LWE parameters $(n,q,\chi_e,\chi_s)$ and $\epsilon_{P}$-secure parameters for Paillier.
%     If $\textsc{Query}$ denotes the query function of \protocol{}, then for any PPT adversary $\adv$ and for any two queries $(i,i_0),(j,j_0)\in[N_0]\times[d_0]$, 
%     \begin{align}
%         \lvert \PP[\adv&(1^\lambda, \qu) | (\_, \qu) \leftarrow \textsc{Query}(i, i_0) ] - \\
%                 & \PP[\adv(1^\lambda, \qu) | (\_, \qu) \leftarrow \textsc{Query}(j, j_0) ] \rvert \\
%                 &~< 2(\epsilon_{P}+\epsilon_{L})
%     \end{align}
% \end{theorem}

% \begin{proof}
%     In the first step of the proof, we will show that the following three distributions are indistinguishable.
%     \begin{align}
%         \mathcal{Q}_{i,i_0} &= \{ \qu ~|~ (\_, \qu) \leftarrow Query(i, i_0) \} \\
%         \mathcal{Q}'_{i,i_0} &= \{ \\
%             &~~~(\pk, r_c, \qu_0, r_1, \cdots, r_k) : \\ 
%             &~~~(\_, (\pk, \ck, \qu_0, \qu_1, \cdots, \qu_k)) \leftarrow Query(i, i_0), \\
%             &~~~r_c\sample\ZZ_{m^2}^{n},~r_i\sample \ZZ_{m^2}^{d_i}\\
%             &\} \\
%         \mathcal{R} &= \{ (\pk,r_c,r_0,r_1,\cdots,r_k) : r_c\sample\ZZ_{m^2}^{n},~r_i\sample \ZZ_{m^2}^{d_i} \}
%     \end{align}

%     We reduce the indistinguishability of Paillier to the indistinguishability of the first two distributions, and the indistinguishability of LWE to the indistinguishability of the second two.
    
%     % If there is an adversary, we will show that there is an adversary that can break Paillier or LWE.
%     % Assume there is an adversary $\adv_1$ that can distinguish the two $\mathcal{Q}_{i,i_0}$ and $\mathcal{Q}'_{i,i_0}$ with non-negligible probability.
%     % We build the adversary $\mathcal{B}_1$ that can win the Paillier distinguishing game and it works as follows:
%     % \begin{itemize}
%     %     \item Get $\pk$
%     %     \item Sample $s$ 
%     %     \item Send $m_0 = \{ s, u_1, u_2, \cdots, u_k \}$ and $m_1 = \{ r_s, r_1, r_2, \cdots, r_k\}$ and get back $\ct = (\ct_s, \ct_1, \ct_2, \cdots, \ct_k)$
%     %     \item Compute $\qu_0 = A \cdot s + e + \Delta u_0$
%     %     \item If $o=\adv_1(pk, ct_s, \qu_0, ct_u)=1$ then output $b'=0$ otherwise, output $b'=1$.
%     % \end{itemize}
%     % The advantage of $\mathcal{B}_1$ is 
%     % \begin{align}
%     %     & |\PP[b'=b]-\half| \\
%     %     &= |\half \PP[b'=0|b=0] + \half \PP[b'=1|b=1] -\half| \\
%     %     &= |\half \PP[o=1|b=0] - \half \PP[o=1|b=1]| < \epsilon/2
%     % \end{align}


%     Finally, to conclude the proof, define $\mathcal{Q}_{j,j_0}$ similar to above, but the subscript changed.
%     Similar to the argument above, we can prove that $\mathcal{Q}_{j,j_0}$ is computationally indistinguishable from $\mathcal{R}$ up to an advantage of $\epsilon_{P}+\epsilon_{L}$.
%     Hence, using the triangle inequality, $\mathcal{Q}_{i,i_0}$ and $\mathcal{Q}_{j,j_0}$ are computationally indistinguishable up to an advantage of $2(\epsilon_{P}+\epsilon_{L})$.
% \end{proof}



% \section{Parameter Choices for \protocol{}}
% \label{sec:zippir-param-choices}

% \begin{figure}[t]
%     \centering
%     \begin{tikzpicture}
%         \begin{axis}[
%             height=0.2\columnwidth,
%             width=0.33\linewidth,
%             hide axis,
%             xmin=0,
%             xmax=1,
%             ymin=0,
%             ymax=1,
%             legend columns=-1, % Horizontal legend
%             legend style={/tikz/every even column/.append style={column sep=0.5cm}},
%             legend to name=named, % Define legend name for referencing
%         ]
%             \addlegendimage{color=blue, mark size=1pt, mark=*}
%             \addlegendentry{$\protocol{}_C$}
%             \addlegendimage{color=green, mark size=1pt, mark=*}
%             \addlegendentry{$\protocol{}_B$}
%         \end{axis}
%     \end{tikzpicture}
%     \ref{named} % Referencing the named legend
%     \centering
%     \begin{subfigure}[b]{\linewidth}
%         \begin{tikzpicture}[]
%             \begin{axis}[
%                 name=small_payload,
%                 at={(0,0)},
%                 % xlabel = {Server Time (s)},
%                 ylabel = {Comm (KB)},
%                 height = 0.4\columnwidth,
%                 width = \columnwidth,
%                 ymode=log,
%                 xmode=log,
%                 log basis y={2},
%                 grid=major,
%                 scatter, 
%                 scatter src= explicit symbolic,
%                 visualization depends on={\thisrow{log_p}*0.75pt \as \marksize},,
%                 title={Payload = 8B}
%             ]
%             \addplot [
%                 color=blue,
%                 only marks,
%                 scatter/@pre marker code/.style={/tikz/mark size=\marksize},
%                 scatter/@post marker code/.style={}
%             ] table [
%                 x expr=\thisrow{Server Online Time}/1000000,
%                 y={Total Size (KB)},
%                 col sep=comma,
%                 meta=log_p
%             ] {data/results_single_s8.csv};
%             \end{axis}    
%         \end{tikzpicture}
%         % \caption{Payload = 8B}
%     \end{subfigure}
%     \begin{subfigure}[b]{\linewidth}
%         \begin{tikzpicture}[]
%             \begin{axis}[
%                 name=mid_payload,
%                 at={(0,0)},
%                 % xlabel = {Server Time (s)},
%                 ylabel = {Comm (KB)},
%                 height = 0.4\columnwidth,
%                 width = \columnwidth,
%                 ymode=log,
%                 xmode=log,
%                 log basis y={2},
%                 grid=major,
%                 scatter, 
%                 scatter src= explicit symbolic,
%                 visualization depends on={\thisrow{log_p}*0.75pt \as \marksize},
%                 title={Payload = 256B}
%                 ]
    
%                 \addplot [
%                     color=blue,
%                     only marks,
%                     scatter/@pre marker code/.style={/tikz/mark size=\marksize},
%                     scatter/@post marker code/.style={}
%                 ] table [
%                     x expr=\thisrow{Server Online Time}/1000000,
%                     y={Total Size (KB)},
%                     col sep=comma,
%                     meta=log_p
%                 ] {data/results_single_s256.csv};
%                 \addplot [
%                     color=green,
%                     only marks,
%                     scatter/@pre marker code/.style={/tikz/mark size=\marksize},
%                     scatter/@post marker code/.style={}
%                 ] table [
%                     x expr=\thisrow{Server Online Time}/1000000,
%                     y={Total Size (KB)},
%                     col sep=comma,
%                     meta=log_p
%                 ] {data/results_batched_s256.csv};
%             \end{axis}    
%         \end{tikzpicture}
%         % \caption{Payload = 256B}
%     \end{subfigure}
%     \begin{subfigure}[b]{\linewidth}
%         \begin{tikzpicture}[]
%             \begin{axis}[
%                 name=large_payload,
%                 at={(0,0)},
%                 xlabel = {Server Time (s)},
%                 ylabel = {Comm (KB)},
%                 height = 0.4\columnwidth,
%                 width = \columnwidth,
%                 ymode=log,
%                 xmode=log,
%                 log basis y={2},
%                 grid=major,
%                 scatter, 
%                 scatter src= explicit symbolic,
%                 visualization depends on={\thisrow{log_p}*0.75pt \as \marksize},
%                 title={Payload = 1KB}
%             ]
    
%             \addplot [
%                 color=green,
%                 only marks,
%                 scatter/@pre marker code/.style={/tikz/mark size=\marksize},
%                 scatter/@post marker code/.style={}
%             ] table [
%                 x expr=\thisrow{Server Online Time}/1000000,
%                 y={Total Size (KB)},
%                 col sep=comma,
%                 meta=log_p
%             ] {data/results_batched_s1024.csv};
%             \end{axis}    
%         \end{tikzpicture}
%         % \caption{Payload = 1KB}
%     \end{subfigure}

% \end{figure}

\end{appendices}
