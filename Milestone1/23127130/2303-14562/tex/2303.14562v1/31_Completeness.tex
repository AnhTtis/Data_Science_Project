\label{sec:completeness}
\newcommand{\algrand}{{\tt RAND-ACT}}
\newcommand{\algdep}{{\tt DEP-ACT}}

%A complete task planner should be able to find a sequence of actions to retrieve the object if it exists or return failure if no such sequence exists. Ultimately, task and motion planners cannot be formally complete since a continuous space of configurations can't be exhaustively explored. However, a planner could be probabilistically complete, meaning the probability of failing to converge to a solution approaches zero as time goes to infinity, or it could be resolution complete, meaning it is guaranteed to find a solution for a fine enough discretizing of the configuration space.


%The proposed planner will inherit one of these two forms of completeness depending on the underlying motion planner, grasp sampler, and object placement sampler. Namely, 
Given a (formally) complete motion planner (finds solution in finite time if exists),
%[Why do we need to include "a continuous space"? It seems redundent. Maybe we can say complete grasp sampler? Do we need to say both prob. complete and resol. complete? can we simply say resol. complete, and just say similarly the prob. complete holds?] 
a continuous space grasp sampler, and continuous placement sampler, the proposed pipeline would be $\tt PC$
%(converges in the limit to solution if exists). 
Given a $\tt RC$ motion planner, 
%(guaranteed to find solution if it exists for some $\epsilon$-discretization)
a discrete space grasp sampler, and discrete placement sampler, the proposed pipeline would be $\tt RC$.
%Since, truly complete motion planners don't exist, the proposed implementation in this work is resolution complete.

To show the $\tt PC$ or $\tt RC$ of the algorithm proposed in this work, a simpler version of the algorithm is analysed first. Without loss of generality, the actual proposed algorithm will be likewise proven complete.

Consider a much simpler algorithm that, at every iteration, tries to pick an object at random and, if is not the target object, subsequently place it randomly in the explored region of the workspace; call this \algrand.
%The termination condition for \algrand~is to pick the target object. 

\begin{blemma}
\algrand~is $\tt PC$ or $\tt RC$ (depending on the planning and sampling subroutines).
\end{blemma}
\begin{proof}
At every iteration, \algrand~attempts to perform a random action. Consequently, \algrand~executes a random walk on the space of all actions. Since pick and place actions are reversible, if a sequence of such valid actions exists, this algorithm will eventually perform it (or an augmented version of the sequence - i.e. placing an object back to where it was picked from) in the limit (or finite time for {\tt RC} subroutines).
\end{proof}

\begin{coro}
\autoref{alg:pipeline} is $\tt PC$ or $\tt RC$ (depending on the planning and sampling subroutines)).
\end{coro}
\begin{proof}
Indeed \autoref{alg:pipeline} is really a fancy implementation of \algrand. At every iteration, the dependency graph is used to identify (and heuristically rank) the currently pickable objects. One of these is chosen randomly for a pick and place action via the $\tt TryMoveOne$ subroutine. 
%\edited{(Not sure if I understand the following sentence...)} 
The $\tt MoveOrPlaceback$ subroutine acts as a fallback in case there are no new discovered placements found; it delays placement sampling till after the environment is re-sensed with the picked object moved out of the way.
Notice further, that even if the pickable objects are sampled weighted according to their ranking rather than uniformly, the action space is still explored entirely because each action has a positive probability of being sampled.
Thus, {\bf w.l.o.g. \autoref{alg:pipeline}} is $\tt PC$ or $\tt RC$ as well.
\end{proof} 

{\bf Failure Detection:} 
The implementation in this work uses the $\tt RC$ approach.
In addition to $\tt RC$, \autoref{alg:pipeline} takes a step closer towards achieving general completeness by actually detecting certain unsolvable cases within the completeness constraints of the motion and sampling subroutines.
The detectable unsolvable instances for which the algorithm will return failure in finite time are as follows.
\begin{myitem}
    \item No object can be grasped. This could happen if two objects each block the grasp of the other.
    \item No objects can be placed anywhere (except its current spot). This could happen in a highly cluttered scene where the only valid placement for each object is to just put it back where it was.
\end{myitem}
Thus, \autoref{alg:pipeline} has stronger guarantees than $\tt RC$ but is not formally complete since it may run forever by juggling two objects between two placements.

{\bf A Caveat:} A fundamental assumption in the argument presented is that actions are reversible. This is not always true in practice depending on the implementation of the sampling subroutines. And indeed, the implementation of the placement sampling process proposed in \autoref{subsec:placement_sampling} implies irreversible actions for scenes with stacked objects because it does not consider the possibility of re-stacking objects. Thus, the proposed pipeline (as implemented) is only resolution complete on the any sub-task where the objects are no longer stacked. Implementation of stacking actions is planned for future work.
%{
%\color{red}
%\subsection{Time Analysis}
%Since \autoref{alg:pipeline} is probabilistic complete, it doesn't have an absolute bound on its running time. However, it is possible to bound the expected running time. For resolution based sampling routines (as implemented in this paper) assume the maximum number of possible placements for all objects is $m$, with $n$ objects in total. 

%How to convert next part to expected runtime?

%Then by restricting the algorithm to only visit unexplored arrangement configurations, there are in total of $m^n$ configurations. Assuming that no repeated actions are required (e.g. to reveal occlusion or removing blocks), then the worst case scenario requires $O(m^n)$ pick and place actions, and $O((m^n)!)$ if the order of configurations matter.
%}

%Look more into:
%\url{https://arxiv.org/pdf/2003.11420.pdf}
%\url{https://arxiv.org/pdf/2003.10863.pdf}