
\documentclass{article} % For LaTeX2e
\usepackage{iclr2023_conference,times}

% Optional math commands from https://github.com/goodfeli/dlbook_notation.
\input{math_commands.tex}

\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}

\usepackage[ruled]{algorithm2e}
\usepackage{algpseudocode}

\title{Evolving Populations of Diverse RL Agents with MAP-Elites}

% Authors must not appear in the submitted version. They should be hidden
% as long as the \iclrfinalcopy macro remains commented out below.
% Non-anonymous submissions will be rejected without review.

\author{Thomas Pierrot\\
InstaDeep\\
\texttt{t.pierrot@instadeep.com} \\
\And
Arthur Flajolet \\
InstaDeep \\
\texttt{a.flajolet@instadeep.con} \\
}

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\input{my_commands}
\iclrfinalcopy % Uncomment for camera-ready version, but NOT for submission.
\begin{document}

\maketitle

\begin{abstract}
Quality Diversity (\qd) has emerged as a powerful alternative optimization paradigm that aims at generating large and diverse collections of solutions, notably with its flagship algorithm \me (\mesc) which evolves solutions through mutations and crossovers. While very effective for some unstructured problems, early \mesc implementations relied exclusively on random search to evolve the population of solutions, rendering them notoriously sample-inefficient for high-dimensional problems, such as when evolving neural networks. Follow-up works considered exploiting gradient information to guide the search in order to address these shortcomings through techniques borrowed from either Black-Box Optimization (\bbo) or Reinforcement Learning (\rl). While mixing \rl techniques with \mesc unlocked state-of-the-art performance for robotics control problems that require a good amount of exploration, it also plagued these \mesc variants with limitations common among \rl algorithms that \mesc was free of, such as hyperparameter sensitivity, high stochasticity as well as training instability, including when the population size increases as some components are shared across the population in recent approaches. Furthermore, existing approaches mixing \mesc with \rl tend to be tied to a specific \rl algorithm, which effectively prevents their use on problems where the corresponding \rl algorithm fails. To address these shortcomings, we introduce a flexible framework that allows the use of any \rl algorithm and alleviates the aforementioned limitations by evolving populations of agents (whose definition include hyperparameters and all learnable parameters) instead of just policies. We demonstrate the benefits brought about by our framework through extensive numerical experiments on a number of robotics control problems, some of which with deceptive rewards, taken from the \qd-\rl literature. We open source an efficient \jax-based implementation of our algorithm in the QDax library \footnote{\url{https://github.com/adaptive-intelligent-robotics/QDax}}. 

% This last point is particularly problematic as one of the main advantages of \qd methods lies in the fact that convergence speed can scale with the population size. 

% \todo{announce release in \jax with high efficiency as part of the \qdax suite}



% empirically estimated by stochastically perturbing the parameters a number of times or by using considered mixing techniques inspired from Reinforcement Learning. The former was only marginally better as the number of samples required to accurately estimate the gradients was prohibitive. The latter brought about significant improvements that unlocked state-of-the-art performances on some problems. However it also plagued MAP-Elites with common RL shortcomings such as hyperparameter sensitivity and training instability 
\end{abstract}

\section{Introduction}

Drawing inspiration from natural evolution's ability to produce living organisms that are both diverse and high-performing through competition in different niches, Quality Diversity (\qd) methods evolve populations of diverse solutions to solve an optimization problem. In contrast to traditional Optimization Theory, where the goal is to find one solution maximizing a given scoring function, \qd methods explicitly use a mapping from solutions to a vector space, referred to as a \emph{behavior descriptor space}, to characterize solutions and maintain a data structure, referred to as a \emph{repertoire}, filled with high-performing solutions that cover this space as much as possible, in a process commonly referred to as \emph{illumination}. This new paradigm has led to breakthroughs over the past decade in many domains ranging from robotics control to engineering design and games generation~\citep{gaier2018data, sarkar2021generating, gravina2019procedural, cully2018hierarchical}. There are a number of advantages to \qd methods over standard optimization ones. Actively seeking and maintaining diversity in a population of solutions has proved to be an effective exploration strategy, by reaching high-performing regions through a series of stepping stones, when the fitness function has no particular structure~\citep{gaier2019quality}. Additionally, having at disposal a diverse set of high-performing solutions can be greatly beneficial to a decision maker~\citep{lehman2020surprising}, for instance because the scoring function may fail to model accurately the reality~\citep{cully2015robots}.

% a diversity of solutions is an interesting target in itself as it provides the final user with not only one but several efficient ways to solve its problem  Finally, enforcing diversity is also a mean to reduce the sim-to-reality gap when optimization happens in a surrogate model or simulator .

\me~\citep{mouret2015illuminating} has emerged as one of the most widely used algorithm in the \qd community for its simplicity and efficacy. It divides the behavior descriptor space into a discrete mesh of cells and strives to populate them all with solutions with matching behavior descriptors that maximize the fitness function as much as possible. This algorithm has been used in many  applications with great success, such as developing controllers for hexapod robots that can adapt to damage in real time~\citep{cully2015robots}. However, just like many evolutionary algorithms, it struggles on problems with high-dimensional search spaces, such as when evolving controllers parametrized by neural networks, as it uses random mutations and crossovers to evolve the population.

The breakthroughs of Deep Reinforcement Learning in sequential decision making problems prompted a new line of work in the \qd field to make the algorithms capable of dealing with deep neural network parametrizations. These new methods borrow techniques from either Black-Box Optimization (\bbo) or Reinforcement Learning (\rl) in order to exploit gradient information to guide the search. Methods based on \bbo techniques~\citep{colas2020scaling, conti2018improving} follow the approaches from earlier works on scaling evolutionary algorithms to neuro-evolution, such as \citet{salimans2017evolution, stanley2002evolving}, and empirically evaluate gradients w.r.t. the parameters by stochastically perturbing them by small values a number of times. Methods borrowing tools from \rl, such as \citet{nilsson2021policy, pierrot2022qdpg}, exploit the Markov-Decision-Process structure of the problem and adapt off-policy \rl algorithms, such as \tddd~\citep{fujimoto2018addressing}, to evolve the population. This often entails adding additional components to the evolutionary algorithm (e.g. a replay buffer, critic networks, hyperparameters of the \rl agent, ...) and methods differ along the way these components are managed. \rl-based \me approaches have outperformed other \me variants, and even state-of-the art \rl methods, on a variety of robotics control problems that require a substantial amount of exploration due to deceptive or sparse rewards. However, the introduction of \rl components in \me has come with a number of downsides: (i) high sensibility to hyperparameters~\citep{khadka2019collaborative, zhang2021importance}, (ii) training instability, (iii) high variability in performance, and perhaps most importantly (iv) limited parallelizability of the methods due to the fact that many components are shared in these methods for improved sample-efficiency. Furthermore, existing \rl-based \me approaches are inflexibly tied to a specific \rl algorithm, which effectively prevents their use on problems where the latter fails.

These newly-introduced downsides are particularly problematic as they are some of the main advantages offered by evolutionary methods that are responsible for their widespread use. These methods are notoriously trivial to parallelize and there is almost a linear scaling between the convergence speed and the amount of computational power available, as shown in \citet{qdax} for \me. This is all the more relevant with the advent of modern libraries, such as \jax~\citep{jax2018github}, that seamlessly enable not only to distribute the computations, including computations taking place in the physics engine with \brax~\citep{freeman2021brax}, over multiple accelerators but also to fully leverage their parallelization capabilities through automated vectorization primitives, see \citet{qdax, flajolet2022fast, evojax2022}. Evolutionary methods are also notoriously robust to the exact choice of hyperparameters, see \citet{khadka2019collaborative}, which makes them suited to tackle new problems. This is in stark contrast with \rl algorithms that tend to require problem-specific hyperparameter tuning to perform well~\citep{khadka2019collaborative, zhang2021importance}.

In order to overcome the aforementioned limitations of \rl-based \me approaches, we develop a new \me framework that \textbf{1.} can be generically and seamlessly compounded with any \rl agent, \textbf{2.} is robust to the exact choice of hyperparameters by embedding a meta-learning loop within \me, \textbf{3.} is trivial to scale to large population sizes, which helps alleviating stochasticity and training stability issues, without entering offline \rl regimes a priori by independently evolving populations of entire agents (including all of their components, such as replay buffers) instead of evolving policies only and sharing the other components across the population. Our method, dubbed \pbtme, builds on \me and combines standard isoline operators with policy gradient updates to get the best of both worlds. We evaluate \pbtme when used with the \sac~\citep{haarnoja2018soft} and \tddd~\citep{fujimoto2018addressing} agents on a set of five standard robotics control problems taken from the \qd literature and show that it either yields performance on par with or outperforms state-of-the-art \me approaches, in some cases by a strong margin, while not being provided with hyperparameters tuned beforehand for these problems. Finally, we open source an efficient \jax-based implementation of our algorithm that combines the efficient implementation of \pbt from \citet{flajolet2022fast} with that of \me from \citet{qdax}. We refer to these two prior works for speed-up data points compared to alternative implementations.

% \todo{announce release in \jax with high efficiency as part of the \qdax suite}

% disentangle the choice of the \rl agent  the evolutionary and RL method to ease distribution and to allow the user to change easily the RL agent without having to change the rest of the method and 2. by leveraging the evolution process as a meta-learning loop to learn the \rl agent hyperparameters. To that end, we suggest to extend the usual framework for neuroevolution. Instead of evolving populations of policies, we propose to evolve populations of agents comprising all their components (replay buffer, critic network, target network, ...) and hyperparameters. Our method, dubbed \pbtme, builds on \me to evolve populations of agents and combine standard isoline operators and policy gradient updates to get the best of both worlds. \pbtme is designed to work with any type of \rl agents as long as ranges for the hyperparameters can be defined. We tried in practice \pbtme with \sac and \tddd agents on a set of five classical robotics environments from the \qd literature and show that in both cases \pbtme matches or outperforms its competitors, in some cases even by a strong margin, while having no access to prior over good hyperparameters for the considered environments.

% A second strength of these algorithms lies in their robustness to hyperparametrization  The recent introduction of policy gradient updates in these methods improved strongly their sample efficiency and final performance, which was their strongest limitations so far, but made harder their distribution and decreased their robustness to hyperparameters. 


% First, these methods are often easy to distribute and s This is all the more true several works showed that these methods can be easily vectorized on accelerators \cite{qdax, flajolet2022fast, evojax2022} with modern libraries such as  leading to greater time performance with less resources. 




% adds several constraints coming from the usage of replay buffers and critic networks for instance that imposed to these algorithms design choices that limit the distribution of the method. Also, as it is well known for off-policy \rl methods \cite{khadka2019collaborative, zhang2021importance} to be very sensible to the choice of hyperparameters thus propagating this sensibility into \me.

% The second category of methods  more recent, recent policy gradients computations to guide the search. To compute policy gradients, these methods rely on successful off-policy \rl methods such as \tddd \cite{fujimoto2018addressing} or \sac \cite{haarnoja2018soft} 
% This second family of methods demonstrated very promising results both in terms of sample efficiency and final performance, outperforming by a strong margin the first class of methods, on a variety of benchmarks for robotics control both in problems exhibiting hard exploration or for diversity generation.
% This thus improving the convergence speed and asymptotic performance when the dimension of the search space increases. 
% Motivated by the ability of \me to evolve robust and efficient closed loop robotics controllers and by several papers introduced techniques to scale \me to perform neuro-evolution. In particular, evolving populations of deep neural networks was out of reach for \me, given the breakthroughs brought about by Deep Reinforcement Learning. 




\section{Background}
\label{sec:background}
\textbf{Problem Definition.} We consider the problem of generating a repertoire of neural policies that are all high-performing for a given task while maximizing the diversity of policies stored in the repertoire. More formally, we consider a finite-horizon Markov Decision Process (\mdp) $\left( \mathcal{S}, \mathcal{A}, \mathcal{R}, \mathcal{T} \right)$, where $\mathcal{A}$ is the action space, $\mathcal{S}$ is the state space, $\mathcal{R}: \mathcal{S} \times \mathcal{A} \rightarrow \reals$ is the reward signal, $\mathcal{T}: \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}$ is the transition function, and $T$ is the episode length. A neural policy corresponds to a neural network $\pi_{\theta}: \mathcal{S} \rightarrow \mathcal{D}(\mathcal{A})$ where $\theta \in \Theta$ denotes the weights of the neural network and $\mathcal{D}(\mathcal{A})$ is the space of distributions over the action space. At each time step, we feed the current environment state to the neural network and we sample an action from the returned distribution, which we subsequently take. Once the action is carried out in the environment, we receive a reward and the environment transitions to a new state. The fitness $F(\pi_{\theta})$ of a policy $\pi_{\theta}$ is defined as the expected value of the sum of rewards thus collected during an episode. We denote the space of trajectories thus followed in the environment by $\tau \in \Omega$. In the \qd literature, diversity is not directly measured in the parameter space $\Theta$, but rather in another space $\mathcal{D}$, referred to as the behavior descriptor space or sometimes simply descriptor space, which is defined indirectly through a pre-specified and problem-dependent mapping $\Phi: \Omega \rightarrow \mathcal{D}$. A policy $\pi_{\theta}$ is thus characterized by rolling it out in the environment and feeding the trajectory to $\Phi$. With a slight abuse of notation, we denote by $\Phi(\pi_{\theta})$ the behavior descriptor of the policy $\pi_{\theta}$. Diversity of a repertoire of policies is measured differently across \qd approaches.

% A set of policies is diverse if their descriptors are far away for a distance metric in the descriptor space. 

\textbf{MAP-Elites.} \me uses a tesselation technique to divide the descriptor space into a finite number of cells, which collectively define a discrete repertoire. In this work, we use the Centroidal Voronoi Tessellation (\cvt) technique~\citep{vassiliades2017using} for all considered methods as it has been shown to be general and easy to use in practice~\citep{vassiliades2017using, pierrot2022qdpg}. \me starts by randomly initializing a set of $M$ policies. Each of these policies is then independently evaluated in the environment and they are sequentially inserted into the repertoire according to the following rule. If the cell corresponding to the descriptor of the policy at hand is empty, the policy is copied into this cell. In the opposite situation, the policy replaces the current incumbent only if it has a greater fitness and is dropped otherwise. During each subsequent iteration, policies are randomly sampled from the repertoire, copied, and perturbed to obtain a new set of $M$ policies which are then tentatively inserted into the repertoire following the aforementioned rule. Implementations of \me often differ along the exact recipe used to perturb the policies. The original \me algorithm~\citep{mouret2015illuminating} relies on random perturbations. In this work, we use the isoline variation operator~\citep{vassiliades2018discovering} that, given two parent policies, say policies $\theta_1$ and $\theta_2$, adds Gaussian noise $\mathcal{N}(0, \sigma_1)$ to $\theta_1$ and offsets the results along the line $\theta_2 - \theta_1$ by a magnitude randomly sampled from a zero-mean Gaussian distribution with variance $\mathcal{N}(0, \sigma_2)$. This strategy has proved to be particularly effective to evolve neural networks~\citep{rakicevicCK21}. Pseudocode for \me is provided in the Appendix.

\textbf{BBO-based QD.} To improve sample efficiency and asymptotic performance, methods such as \mees~\citep{colas2020scaling} use first-order updates to perturb the policies with the objective of both increasing the fitness of the policies in the repertoire and improving the coverage of the repertoire (i.e. the number of non-empty cells). To generate the updates, \mees use the Evolution Strategy from \citet{salimans2017evolution}. Specifically, after selecting a policy from the repertoire, its neural network parameters are perturbed stochastically with a small amount of Gaussian noise a number of times and the resulting policies are rolled out in the environment for a full episode. All of the collected samples are then used to empirically estimate gradients for a smoothed version around the starting policy of either (1) the fitness function, (2) a novelty function which is defined as the average Euclidean distance between the starting policy's behavior descriptor and its $k$ nearest neighbors among all previously computed behavior descriptors, or (3) alternatively the fitness function and the novelty function to increase both quality and diversity, which is the version we use in this work (see the Appendix for the pseudocode). Note that similar strategies using the \nses family of algorithms exist, such as \citet{conti2018improving}, but these methods are outperformed by \mees~\citep{colas2020scaling}.

\textbf{RL-based QD.} Using evolution strategies to guide the search with first-order updates improves upon random search but remains doomed to a low sample-efficiency due to the need of rolling out a significant number of policies over entire trajectories to get reasonably accurate gradient estimates. More recent techniques, such as \qdpg~\citep{pierrot2022qdpg} and \pgame~\citep{nilsson2021policy}, exploit the \mdp structure of the problem and leverage policy-gradient techniques from \rl as well as off-policy extensions for improved sample efficiency and better asymptotic convergence. Both \qdpg and \pgame build on the \tddd agent~\citep{fujimoto2018addressing}. \pgame combines random mutations derived through the isoline variation operator with mutations obtained through policy gradient computations. \qdpg introduces the notion of a diversity reward, a signal defined at the timestep-level to drive policies towards unexplored regions of the behavior descriptor space, which makes it possible to leverage the \rl machinery to compute policy gradients to increase the diversity of the population, referred to as diversity policy gradients, in addition to the standard policy gradients to increase the fitness of the policies, referred to as quality policy gradients. At each \me iteration, half of the selected policies are updated using quality policy gradients and the other half are updated using diversity policy gradients. In contrast to \pgame, \qdpg does not relies on random search updates. Both \qdpg and \pgame use a single shared replay buffer where all the transitions collected when evaluating the agents are stored and from which batches are sampled to compute policy gradients. 

Critic networks are managed differently by each algorithm. \qdpg uses two different sets of critic parameters, one for quality rewards and one for diversity rewards, that are shared across the population and both are updated any time a policy gradient is computed. \pgame maintains a greedy policy and its associated critic which are updated independently of the rest of the repertoire. The greedy policy is regularly inserted in the repertoire and the critic is used to compute policy gradients updates for all other policies but is only updated using the greedy policy.

These precise design choices not only make \pgame and \qdpg difficult to distribute efficiently but they also harm the flexibility of these methods. For instance, if one would like to replace \tddd by another popular off-policy algorithm such as \sac, which is known to perform better for some environments, numerous new design choices arise. For instance for \sac, one would have to decide how to handle the temperature parameter and the entropy target within the population. Furthermore, while sharing critic parameters and using a single replay buffer was motivated by a desire for greater sample efficiency, this introduces new issues when scaling these methods. For instance, as the number of policies updated concurrently at each iteration increases we get closer to an offline \rl setting, which is known to harm performance, since all policies share the same replay buffer. Conversely, as the size of the repertoire increases, any single policy stored in the repertoire is updated all the less frequently than the critic which may cause them to significantly lag behind over time. Finally, both \qdpg and \pgame assume that good hyperparameters are provided for \tddd while it is known that tuning these values for the problem at hand is necessary to get good performance. This effectively puts the burden on the user to tune hyperparameters for \tddd as a preliminary step, which limits the usability of such methods in new settings. Pseudocodes for \qdpg and \pgame are provided in the Appendix.
 


% but introduce strong off-policyness issues that lead to brittleness of the algorithm as observed in \qdpg. They also make the distribution of the method more challenging. Finally, both \qdpg and \pgame rely on well-known hyper-parametrisations for \tddd on classical robotics environment and even though demonstrated that some parameters needed to be fine-tuned further in some environments. This limits the re-usability of such methods in new settings thus limiting their practical interest.


% suggested to compute policy gradients instead motivated by the exploitation of the known analytical structure of the neural policy and exploitation of the reward signal at each, thus helping to reduce the estimate variance which leads to improved sample efficiency and better asymptotic convergence. 




\section{Method}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.0\linewidth]{images/PBTMEmain.png}
    \caption{\textbf{Left Panel.} The set of \qd-\rl environments used to evaluate all methods. All environments are implemented using the \brax simulator and are available in the \qdax suite. In \walkeruni, \antuni, and \halfcheetahuni, the goal is to learn to control the corresponding robot to run as fast as possible with gaits that are as diverse as possible.
    %while discovering diversity on the robot gait thus testing the capacity of our method to produce a collection of very diverse and performing solutions.
    In \anttrap and \humanoidtrap, the robot should travel as far as possible along the x-axis direction, which entails sidestepping the trap to get the highest possible return thus putting the exploration capabilities of considered methods to test. \textbf{Right panel.} Illustration of the \pbtme algorithm. \pbtme maintains a population of agents (policy parameters, other learnable parameters as well as hyperparameters) and a \me repertoire of agents. The repertoire update, generating more diversity, and the population update, improving the fitness of the policies, are intertwined. }
    \label{fig:main_fig}
    \vspace*{-0.4cm}
\end{figure}

In order to overcome the limitations of \rl-based \qd methods identified in the last section, we revisit the neuro-evolution problem defined in Section~\ref{sec:background} and introduce a new algorithm, dubbed \pbtme, that evolves populations of agents as opposed to populations of policies. An agent is defined by a tuple $(\theta, \phi, \mathbf{h})$ where $\theta$ denotes the policy parameters, $\phi$ denotes all other learnable parameters of the agent (e.g. critic parameters and target critic parameters), and $\mathbf{h}$ denotes its hyperparameters (e.g. learning rates and magnitude of the exploration noise). As in the original formulation, we assume that the fitness and behavior descriptor functions depend only on the policy, i.e. on $\theta$. The learnable parameters and the hyperparameters are only used when agents are updated. \pbtme internally uses a policy-search-based \rl algorithm which can be selected freely by the user. In particular, it may be on-policy or off-policy.

\pbtme maintains a \me repertoire as well as a population of $P$ agents. The population is randomly initialized (including the hyperparameters), evaluated, copied and inserted into the repertoire. We also initialize $P$ replay buffers if the underlying \rl algorithm makes use of them. Additionally, a batch of agents is sampled from the repertoire and a variation operator is applied to obtain $M$ offspring that are also evaluated and inserted into the repertoire as part of the initialization phase. Then, the algorithm proceeds in iterations, each of which consists of two consecutive steps: 1. population update and 2. \me repertoire update. 


\textbf{Population Update.} To update the population of agents, we use the following strategy inspired from \citet{jaderberg2017population}. We first rank all agents in the population by fitness based on the evaluation that took place at the end of the last iteration. Agents that are in the bottom $p\%$ of the population are replaced by agents sampled uniformly from the top $n\%$ of the population, with $0 < p < 1 - n < 1$. We also randomly select $k\%$ of the agents in the population among the ones that are neither in the top $n\%$ nor in the bottom $p\%$ and we replace them by agents randomly sampled from the current \me repertoire. All other agents remain unchanged. This mechanism allows potentially lower-performing, but more diverse, individuals from the repertoire to enter the population while maintaining high-performing agents alive. When agents are replaced, new hyperparameter values are sampled uniformly from pre-specified ranges. The agents' policy parameters as well as all other learnable parameters are subsequently trained for $S$ steps, using the user-selected \rl algorithm. If needed, the collected experience is stored inside the replay buffers. In contrast to \pgame and \qdpg, we closely follow the general recipe followed by most \rl algorithms and only add the experience collected during training, in exploration mode, to the replay buffers while the experience collected during evaluation, in exploitation mode, is discarded. Additionnaly, note that the agents are trained independently from one another, which makes it trivial to parallelize the most computationally intensive part of this step. This is in stark contrast with other \me-\rl methods that share some parameters across the population, e.g. the critic parameters for \qdpg and \pgame, which are typically updated concurrently by all agents.


% ones with the best fitness and 

% $k\%$ of the agents (nor from the $p\%$ with the best nor from the $n\%$ with worse fitness) are replaced by agents randomly sampled from the \me repertoire. The other agents remain untouched. 


\textbf{Repertoire Update.} Once the agents in the population have been trained, they are evaluated and inserted into the repertoire. Then, just like during the initialization phase, a batch of agents is randomly sampled from the repertoire and undergoes a variation operator to obtain $M$ offspring which are evaluated and inserted into the grid. As in \pgame, the variation operator is meant to increase the descriptor space coverage but we have also observed that this process stabilizes the algorithm as a whole. In order to define a variation operator that can be used with agents, as opposed to policies, we deal with variations over the policy and learnable parameters separately from variations over the hyperparameters. Specifically, an isoline operator is applied to policy and other learnable parameters while the offspring simply inherit the hyperparameters of one of their parents. While more sophisticated strategies could be investigated, we have observed that this simple mechanism works well in practice in our experiments.


Observe that optimization of the quality as well as the diversity of the policies happens at two different levels in \pbtme. Quality is encouraged through both the elitist population update and the repertoire insertion mechanism. Diversity is induced through both the addition of agents from the repertoire to the population and the use of random variation operators at each iteration. The pseudocode of the algorithm is provided in the Appendix.


\section{Literature Review}
\textbf{Quality Diversity.} \qd methods aim to simultaneously maximize diversity and performance. Among existing options, \me and Novelty Search with Local Competition (\nslc) are two of the most popular \qd algorithms. \nslc builds on the Novelty Search algorithm~\citep{lehman2011abandoning} and maintains an unstructured archive of solutions selected for their high performance relative to other solutions in their neighborhoods while \me relies on a tesselation technique to discretize the descriptor space into cells. Both algorithms rely extensively on Genetic Algorithms (\ga) to evolve solutions. As a result, they struggle when the dimension of the search space increases, which limits their applicability. These approaches have since been extended using tools from Evolution Strategies (\es) to improve sample efficiency and asymptotic performance over the original implementations based on \ga~\citep{salimans2017evolution}. \cmame~\citep{fontaine2020covariance} relies on Covariance Matrix Adaptation (CMA) to speed up the illumination of the descriptor space. \nsraes and \nsres~\citep{conti2018improving} build on recent \es tools to improve \qd methods' exploration capabilities on deep \rl problems with deceptive or sparse rewards. \mees~\citep{colas2020scaling} introduces alternate \es updates for quality and diversity in order to solve deep \rl problems with continuous action spaces that require a good amount of exploration. While \es-based approaches improve over \ga-based ones, they are still relatively sample-inefficient due to the fact that they need to roll out a large of number of policies over entire trajectories to empirically estimate gradients with reasonable accuracy. Several recent methods propose to exploit analytical gradients when this is possible instead of estimating them empirically. \dqd~\citep{Fontaine2021} builds a mutation operator that first computes gradients of the fitness and behavior descriptor functions at the current solution and carry out a first-order step by summing the gradients with random coefficients. \citet{tjanaka2022approxdqd} applies the same technique to deep \rl problems with continuous action spaces. \pgame~\citep{nilsson2021policy} and \qdpg~\citep{pierrot2022qdpg} exploit the \mdp structure of the problems to compute policy gradients using the \tddd algorithm, outperforming all \qd competitors for deep \rl problems with continuous actions. However, both methods are tied a single \rl algorithm and are highly sensitive to the choice of \tddd hyperparameters.

\textbf{Population Based Reinforcement Learning.} Our work has different motivations than classical \rl algorithms as we do not aim to find a policy than achieves the best possible return but rather to illuminate a target descriptor space. However, we share common techniques with Population-Based \rl (\pbrl) algorithms. In this field, the closest method to ours is the Population-Based-Training (\pbt) algorithm~\citep{jaderberg2017population} 
 which uses a genetic algorithm to learn the hyperparameters of a population of \rl agents concurrently to training them. While \pbtme and \pbt use similar strategies to update the population of agents, \pbt only seeks the highest-performing agent by extracting the best one from the final population while \pbtme aims to find a diverse collection of high-performing agents. Several methods such as \cerl, \erl, and \cemrl~\citep{pourchot2018cem, khadka2018evolutionaryNIPS, khadka2019collaborative} combine \es algorithms with \pbrl methods to improve the asymptotic performance and sample efficiency of standard \rl methods. Other methods, such as \dvd~\citep{parker2020effective} and \pssstddd~\citep{jung2020population}, train populations of agents and add terms in their loss functions to encourage the agents to explore different regions of the state-action space but always with the end goal of maximizing the performance of the best agent in the population. \citet{flajolet2022fast} show how to vectorize computations across the population to run \pbrl algorithms as efficiently as possible on accelerators through the use of the \jax library. \citet{qdax} introduced similar techniques to accelerate \me through the evaluation of thousands of solutions in parallel with \jax. In this study, we build on both of these works and implement \pbtme in the \jax framework to make it fast and scalable.

\section{Experiments}


\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.0\linewidth]{images/plots_pbt_me.pdf}
    \caption{Performance comparison of \pbtme with baselines on the basis of standard metrics from the \qd literature for five environments from the \qdax suite (which is based on the \brax engine). We benchmark two variants of \pbtme, one where it is composed with \sac and one where it is composed with \tddd. All methods are trained with a total budget of $N = 1.5e8$ environment timesteps. Experiments are repeated over 5 runs with different random seeds and the medians (resp. first and third quartile intervals) are depicted with full lines (resp. shaded areas). }
    \label{fig:main_results}
\end{figure}

\textbf{Environments.} We use five robotics environments that fall into two categories:

\textbf{1.} \halfcheetahuni, \walkeruni and \antuni are environments widely used in the \qd community to evaluate an algorithm's ability to illuminate a complex descriptor space, see for instance \citet{cully2015robots, nilsson2021policy, tjanaka2022approxdqd}. In these environments, the goal is to make a legged robot run as fast as possible along the forward direction while optimizing for diversity w.r.t. the robot's gaits, indirectly characterized as the mean frequencies of contacts between the robots' legs and the ground. This last quantity defines the behavior descriptor for these environments while the reward at each timestep is the velocity of the robot's center of gravity projected onto the forward direction. 

\textbf{2.} \anttrap and \humanoidtrap are environments with deceptive reward signals used in the \qd-\rl literature to evaluate an algorithm's ability to solve complex continuous control problems that require a good amount of exploration, see \citet{colas2020scaling, conti2018improving, pierrot2022qdpg}. In these environments, the goal is also to make the legged robot run as fast as possible in the forward direction, though with the additional difficulty that the robot is initially facing a trap. As a result, following the reward signal in a greedy fashion leads the robot into the trap. The robot must explore the environment and learn to go around the trap, even though this is temporarily suboptimal, in order to obtain higher returns. In these environments, the behavior descriptor is defined as the position of the robot's center of gravity at the end of an episode. All of these environments are based on the \brax simulator~\citep{freeman2021brax} and are available in the \qdax suite~\citep{qdax}.
% As for the three other environments, 




% The first family of environments have been introduce to compare methods in their capabilities 


% e while the second family has been introduced to evaluate \qd algorithms capabilities 


 

% \begin{figure}[ht!]
\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{images/mepbt_hyperparams.png}
    \caption{Visualizations of the performance and hyperparameters of the agents stored in the \me repertoire of \pbtme (\tddd) at different time points during training on the \anttrap environment. The first row corresponds to the fitnesses of the agents. The second row corresponds to the exploration noise added by the agents to the actions returned by their policies when collecting experience in exploration mode. The third row corresponds to the discount factor $\gamma$ used by the agents. Snapshots of the repertoire are taken at uniformly-spaced intervals during training.}
    \label{fig:hyperparams_maps}
    % \vspace*{-0.5cm}
\end{figure}

\textbf{Setup.} We compare \pbtme to state-of-the-art \me-based methods, namely \me, \mees, \pgame as well as \qdpg. For these experiments, we benchmark two variants of \pbtme: one where it is composed with \sac and one where it is composed with \tddd. For the sake of fairness, we use the same values for parameters that are used by multiple methods. In particular, all \me-based methods maintain a repertoire of $1024$ cells and use \cvt with the same parametrization to discretize the behavior descriptor space into $1024$ cells. Similarly, when a variation operator is needed, we always use the isoline operator with the same parameters $\sigma_1=0.005$ and $\sigma_2=0.05$. All policy and critic networks are implemented by two \mlps layers with 256 hidden neurons per layer. For methods relying on the \tddd agent, the hyperparameters used are the ones introduced in the original paper for \mujoco environments. Pseudocodes and parameter values for all algorithms under study are provided in the Appendix.

Additionally, we compare \pbtme to the \pbt algorithm~\citep{jaderberg2017population} (pseudocode provided in the Appendix) when it is used to optimize populations of \sac agents. Both \pbtme and \pbt evolve populations of $80$ agents and use the same ranges for the hyperparameters. All policy and critic networks are implemented by two-layer \mlps with 256 hidden neurons per layer, just like for \tddd for \pgame and \qdpg. Furthermore, the parameters of all agents in the population are identically initialized. For \pbtme (resp. \pbt), agents in the bottom $p = 0.2$ (resp. $p = 0.4$) fraction of the population (in terms of fitness) are replaced by agents sampled from the top $n = 0.1$ fraction of the population. For \pbtme, a fraction $k = 0.4$ of the agents that are neither in the bottom $20\%$ nor in the top $10\%$ of the population are replaced by agents randomly sampled from the \me repertoire. All other parameters and design choices are identical for these two methods.


% we compute three metrics that are often used in the QD community to track the performance
% of a collection of solutions: (i) the maximum fitness of the repertoire, computed as the maximum
% fitness attained across the solutions stored in the repertoire, (ii) the coverage of the repertoire,
% computed as the number of cells (behavior niches) that have been filled, and (iii) the QD score,
% computed as the sum of fitnesses attained by the solutions stored in the repertoire

\textbf{Metrics and fair comparisons.} Following standard practice in the \qd literature, we monitor three metrics used to evaluate the performance of a collection of policies during training. 1. We measure the \textbf{maximum fitness}, defined as the maximum expected return across policies in the collection. 2. We measure the \textbf{coverage} over the descriptor space, computed as the number of cells that have been filled. 3. We measure the \textbf{QD-score},
computed as the sum of fitnesses attained by the policies stored in the repertoire. For this last metric to be meaningful, we assume that fitnesses are all non-negative. If not, a positive value is added to all fitnesses to enforce it. In any case, this value is the same for all methods for fairness. Since some of the metrics require a repertoire to be properly defined, we introduce a passive repertoire for \pbt to be able to evaluate it on the same basis as the other methods. Specifically, at the end of each \pbt iteration, the population of agents generated by \pbt is evaluated and inserted into a repertoire. For each method, we report the evolution of these metrics w.r.t. the total number of interactions with the environment. Note that while the evaluation of an agent contributes to the total number of interactions for \me-based methods, this is not the case for \pbt as the evaluations are only used to estimate the metrics for this method. 

\section{Results and Discussion}
Statistics on \qd metrics are reported for all environments and methods on Figure~\ref{fig:main_results}.

\textbf{Performance comparison to other \me-based methods.} We observe that \pbtme (\sac) is the only method able to solve \humanoidtrap within the allocated timestep budget, outperforming all the other methods by a significant margin. \humanoidtrap is a challenging environment as obtaining high returns requires not only to get the humanoid robot to run, which is a challenging continuous problem in itself, but also to learn to sidestep the trap in spite of a deceptive reward signal. This environment, introduced in \citet{colas2018gep}, has remained out of reach for \me-based methods, setting aside \mees which solves it with a timestep budget two orders of magnitude higher. Interestingly, the maximum fitness remains below 2000 for \tddd-based methods, which means they were not able to get the humanoid robot to run at all. This is a testament to the difficulty of the problem. Recall that \tddd was not able to solve the \mujoco-based version of the Humanoid environment in the original paper that introduced this algorithm~\citep{fujimoto2018addressing}. A careful tuning of the algorithm design choices and hyperparameters, carried out in a later study, was required to get \tddd to perform well on this environment. Setting aside the \walkeruni environment, note that \pbtme (\sac) either outperforms, often by a significant margin for the maximum fitness metric, or performs on par with \me-based methods. Interestingly, the \sac variant of \pbtme often performs better than the \tddd variant, but not always. On a side note, we also observe that \mees surprisingly gets outperformed by all \me competitors, including the original \me algorithm, in all environments. This can be explained by the fact that \mees uses 1000 evaluations (i.e. $1e6$ timesteps) to update a single policy. As a result, for a repertoire consisted of 1024 cells and with a budget of $1.5e8$ timesteps, the maximum coverage that can be reached by \mees is 15\% only. In the original study, \mees manages to outperform other \me-based methods with a budget of $1e10$ timesteps.

% couldn't solve neither the and managed to do it only in later versions through very careful change of design choices in the 



\textbf{Performance comparison to PBT.} We observe that \pbt outperforms the \sac variant of \pbtme in terms of maximum fitness on \halfcheetahuni and \antuni. This is expected as: (1) these environments do not require a significant amount of exploration, (2) \pbt only aims to maximize the maximum fitness, and (3) \pbtme aims to maximize both the maximum fitness and the policies' diversity. However, we observe the opposite trend on \anttrap and \humanoidtrap where significant exploration is required to achieve high returns given the deceptive nature of the reward signal. We conclude that optimizing for diversity turns out to play a crucial role for these two environments. As expected, \pbtme outperforms \pbt in terms of coverage and \qd-score in all environments, setting aside \humanoidtrap. The seemingly unexpected results observed on \humanoidtrap stem from the fact that covering the behavior descriptor directly correlates with exploration of the $(x, y)$ space, which is required to achieve high returns in this environment due to the presence of the trap. 



% On the other hand, we observe the opposite tendency in \anttrap and \humanoidtrap in which the search for diversity plays a crucial role given the deceptive nature of the reward signal. Surprisingly, \pbtme matches \pbt on the \walkeruni environment even though this environment is not supposed to require extra exploration. 





\textbf{Repertoire interpretation.} By visualizing the evolution of the fitnesses and hyperparameters of the agents stored in \pbtme's repertoire at different time points during training, see Figure~\ref{fig:hyperparams_maps}, we observe that \pbtme evolves locally-coherent (w.r.t. the descriptor space) maps of hyperparameters that change significantly during training. In particular, we remark that \pbtme dynamically increases the amount of exploration noise of the \tddd agents to boost exploration when needed to go around the trap and decreases this parameter once the trap has been sidestepped to focus on getting high returns. This mechanism gives a significant advantage to \pbtme over \qdpg and \pgame, for which this parameter is set to a constant value.

% it adapts them during training, for instance to adjust the level of exploration.


\section{Conclusion} 

In this work, we revisit the standard formulation of the \qd neuro-evolution problem by evolving repertoires of full agents (including hyperparameters among other things) as opposed to only policies. This extension brings flexibility compared to existing frameworks as it allows us to combine any \rl algorithm with \me in a generic and scalalable fashion. This formulation also allows us to dynamically learn the hyperparameters of the underlying \rl agent as part of the regular training process, which removes a significant burden from the user. Surprisingly, we observe that learning the hyperparameters improves both the asymptotic performance and the sample efficiency in practice for most of the environments considered in this work. Our method is the first to solve the \humanoidtrap environment with less than one billion interactions with the simulator, to be compared with tens of billions of interactions for state-of-the-art \qd methods. We hope that this work constitutes one more step towards bridging the gap between Neuro-Evolution and Reinforcement Learning, combining the best of both worlds in a simple framework.


% learning the hyperparameters and other learnable parameters would require more samples, 



% for dynamic learning of the \rl agent hyperparameters allowing for better exploration and removing the burden on the user to define them, facilitating also the transfer to new environments.





\newpage

\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\newpage

\appendix

\section{Pseudocodes for all Algorithms}
\label{supp:algo}
\input{algorithm}

% \newpage

\section{Experimental Details}
\label{supp:exp_setup}

In this section, we detail the parameters used for all algorithms. In particular, we stress that we use the same values used in the original studies for all \me-based algorithms other than the one introduced in this paper, namely \me, \pgame, \qdpg, and \mees. Additionally, we run the implementations of these algorithms provided in the \qdax library~\citet{qdax} for our experiments. All \me-based algorithms use a grid with $1024$ cells initialized using \cvt with 50,000 initial random points.


\begin{table}[ht!]
\caption{\pbt parameters}
\label{tab:pbt-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Population size $P$        &80 \\
Proportion of worst agents $p$           &0.4 \\
Proportion of best agents  $n$           &0.1 \\
Number of training steps per iteration per agent $S$ &5000 \\
Replay buffer size & 100000 \\
\end{tabular}
\end{center}
\end{table}

\begin{table}[ht!]
\caption{\pbtme parameters}
\label{tab:pbtme-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Number of isoline-variation offsprings per iteration $M$  &240 \\
Size of the population of RL agents $P$        &80 \\
Proportion of worst agents $p$           &0.2 \\
Proportion of agents to sample from the repertoire $k$           &0.4 \\
Proportion of best agents  $n$           &0.1 \\
Number of training steps per iteration per agent $S$ &5000 \\
Replay buffers size &100000 \\
Isoline $\sigma_1$  & 0.005\\
Isoline $\sigma_2$ & 0.05
\end{tabular}
\end{center}
\end{table}

\begin{table}[ht!]
\caption{\me parameters.}
\label{tab:me-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Number of offsprings per iteration $M$ & 1000 \\
Isoline $\sigma_1$  & 0.005\\
Isoline $\sigma_2$ & 0.05 \\
\end{tabular}
\end{center}
\end{table}

\begin{table}[ht!]
\caption{\mees parameters.}
\label{tab:mees-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Number of consecutive gradient steps for a given policy $S$  & 10 \\
Number of evaluations for gradient approximations $N_{\textbf{grad}}$ & 1000 \\
Number of randomly-initialized policies used to initialize the repertoire $N_{\textbf{init}}$ & 1 \\
Std of the normal distribution to perturb parameters for gradient approximations $\sigma$ & 0.2 \\
Learning rate $\eta$ & 0.01 \\
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{\pgame parameters.}
\label{tab:pgma-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Number of offsprings per iteration $M$ & 100 \\
Number of TD3 training steps used to update the shared critic per iteration $S_c$ & 300 \\
Number of TD3 policy update steps per iteration per policy $S_p$ & 100 \\
Discount factor $\gamma$       & 0.99  \\
Policy learning rate           & 3e-4 \\
Critic learning rate           & 3e-4  \\
Noise clipping            & 0.5 \\
Policy noise            & 0.2 \\
Exploration noise            & 0.0 \\
Soft update tau                & 0.005 \\
Batch size                     & 256\\
Replay buffer size & 100000 \\
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{\qdpg parameters.}
\label{tab:qdpg-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Value}
\\ \hline \\
Size of the population of RL agents $P$  & 100 \\
Number of TD3 training steps per iteration per agent $S$ & 100 \\
Discount factor $\gamma$       & 0.99  \\
Policy learning rate           & 3e-4 \\
Critic learning rate           & 3e-4  \\
Noise clipping            & 0.5 \\
Policy noise            & 0.2 \\
Exploration noise            & 0.0 \\
Soft update tau                & 0.005 \\
Batch size                     & 256\\
Replay buffer size & 100000 \\
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{\sac hyperparameters' ranges (or values  if the hyperparameter does not change during training) that \pbt and \pbtme sample from.}
\label{tab:sac-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Range / Value}
\\ \hline \\
Discount factor $\gamma$       &[0.9, 1.0] \\
Policy learning rate           &[3e-5, 3e-3] \\
Critic learning rate           &[3e-5, 3e-3] \\
Alpha learning rate            &[3e-5, 3e-3] \\
Reward scaling factor          &[0.1, 10] \\
Soft update tau                &0.005 \\
Alpha initial value            &1.0\\
Batch size                     &256\\
\end{tabular}
\end{center}
\end{table}

\begin{table}[t!]
\caption{\tddd hyperparameters' ranges (or values  if the hyperparameter does not change during training) that \pbt and \pbtme sample from.}
\label{tab:tddd-params}
\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{\bf Parameter}  &\multicolumn{1}{c}{\bf Range / Value}
\\ \hline \\
Discount factor $\gamma$       &[0.9, 1.0] \\
Policy learning rate           &[3e-5, 3e-3] \\
Critic learning rate           &[3e-5, 3e-3] \\
Noise clipping            &[0.0, 1.0] \\
Policy noise            &[0.0, 1.0] \\
Exploration noise            &[0.0, 0.2] \\
Soft update tau                &0.005 \\
Batch size                     &256\\
\end{tabular}
\end{center}
\end{table}




\end{document}
