\section{Highly-Responsive Data Stream Joins}\label{sec:join}
In typical time-series databases, band-joins are used to integrate such series~\cite{dewitt1991evaluation, khayyat2015lightning}, where all items within a certain time-delta are grouped together.
True band-joins are challenging in streaming systems where data may arrive out-of-order or in a bursty way leading to potentially unbounded buffering, so existing streaming systems offer an approximation using tumbling time windows~\cite{flink, apachestorm, apache-samza, spark-structured-streaming,photon,facebook-streaming-join}.
All items that fall within the same tumbling time window are grouped together.
We refer to this type of streaming join as a \textit{time-triggered join}, i.e, the join condition is triggered by a clock tick.

This type of join can cause delays that affect the timeliness of predictions.
A multimodal model's response time to new data is limited by the width of the tumbling window.
An alternative to time-triggered joins is to join eagerly as soon as a new item is published to the stream, which we call a \textit{data-triggered join}.
The novelty of this approach is that it is responsive to new data, while having a bounded buffer size.
We will discuss both join methods in more detail below.

\subsection{Time-triggered Join}\label{sec:time-join}
As the name suggests, a time-triggered join buffers incoming messages from all streams over a time window, and triggers a join result at the end of the time window.
Within each time window, only the latest message from each stream is kept as that stream's input. The definition of `latest' here can be either event time or processing time. These latest messages are combined as a tuple before sending downstream.

\begin{figure}[t]
    \centering
    \begin{minipage}{.5\columnwidth}
      \centering
      \includegraphics[width=\linewidth]{figures/time-triggered-join.pdf}
      \caption{Time-triggered join.}
      \label{fig:time-triggered-join}
    \end{minipage}%
    \begin{minipage}{.5\columnwidth}
      \centering
      \includegraphics[width=\linewidth]{figures/data-triggered-join.pdf}
      \caption{Data-triggered join.}
      \label{fig:data-triggered-join}
    \end{minipage}
\end{figure}
Figure~\ref{fig:time-triggered-join} is an example of a time-triggered join.
% A join is issued whenever a fixed time window is passed.
In this example, we assume event time and processing time are the same for simplicity. The join results are as follows:
join 1 (A1, B1, C1, D1);
join 2 (A1, B2, C1, D2);
join 3 (A1, B3, C2, D2);
join 4 (A2, B3, C2, D2).
% They can be performed based on either event-time or processing-time.
Intuitively, waiting for a time-triggered join resembles waiting for a bus.
Since B2 arrives immediately after the join at $t=T$ was issued, it will have to wait until $t=2T$ to get processed, resulting in a longer waiting time.
On the other hand, time-triggered joins are beneficial when joins are desired at fixed frequencies, as they smooth out the burstiness of incoming data.

The state management for a time-triggered join is rather straightforward.
If the join is based on processing time, only the latest messages from each stream need to be buffered.
If the join is based on event time, all messages within a fixed time window need to be additionally buffered, in case they arrive out of order in terms of event time.

\subsection{Data-triggered Join}\label{sec:data-join}
An alternative to a time-triggered join is to perform a join whenever a new piece of data from any stream arrives.
Intuitively, the latest known data from all streams are buffered in order to join with the \underline{new data item} (underlined in the following example). We will show how this works precisely in the two-way case, and it should be clear how to extend this to a multi-way join.

Given two streams StreamA and StreamB, the algorithm tracks the latest known item from each stream and its timestamp.
Each time the stream publishes a new data item, it is joined with the latest known item from the other stream.
As before, the timestamp can refer to either event time or processing time.
However, the order of joined tuples is not guaranteed in terms of event time, since the joining process depends on when the data is actually received by the joiner.

\vspace{0.25em}
\noindent\fbox{%
\footnotesize
    \parbox{0.8\columnwidth}{%
        \noindent \textbf{Data-Triggered Join Algorithm} \\

\textbf{Given: } StreamA, StreamB 

\textbf{Set: $(a, a_t) \leftarrow (\emptyset, -\infty)$, $(b, b_t) \leftarrow (\emptyset, -\infty)$} \\

\textsf{onStreamA(x: data, t: timestamp): }
\begin{enumerate}
    \item If b is not $\emptyset$, yield $(x, b)$
    \item If $t > a_t$, $(a, a_t) \leftarrow (x, t)$
\end{enumerate} 

\textsf{onStreamB(x: data, t: timestamp): }
\begin{enumerate}
    \item If a is not $\emptyset$, yield $(a, x)$
    \item If $t > b_t$, $(b, b_t) \leftarrow (x, t)$
\end{enumerate}
    }
    %
}

Figure~\ref{fig:data-triggered-join} is an example of a data-triggered join.
Again for simplicity, we assume event time and processing time are the same. The join results are as follows:
join 1 (A1, B1, C1, \underline{D1});
join 2 (A1, \underline{B2}, C1, D1);
join 3 (A1, B2, C1, \underline{D2});
join 4 (A1, \underline{B3}, C1, D2);
join 5 (A1, B3, \underline{C2}, D2);
join 6 (\underline{A2}, B3, C2, D2).
In this way, we ensure that the system reacts immediately to new data at the expense of more frequent joins.
Data-triggered join is preferred when at least one data stream is bursty, as it is difficult to set a good time window with bursty data involved.

\subsection{When Is Data-triggered Join Better}
Data-triggered joins are more suitable for event-based streams whereas time windows are good aggregators for continuous data streams (e.g. sensor data).
In certain cases such as activity recognition, there is no activity of interest for most of the time.
For example, a Nest Cam only emits data when it finds people, vehicles, or animals in sight.
Data-triggered joins can capture these events as soon as they happen.
It is possible to combine time-triggered join and data-triggered join to get the best of two worlds.
\S\ref{sec:target-pred-freq} describes a hybrid method that primarily operates on a data-triggered basis, while strategically integrating time-triggered elements as a rate limiter.
Data-triggered joins further provide a completeness guarantee to the downstream data consumer. 
\emph{Every message is guaranteed to be present in at least one join tuple.}

% Relevant video clips can be combined with network traffic data collected from IoT devices to infer human activity~\cite{shaowang2023amir}.
% We can treat the event streams (e.g. occasional Nest Cam clips) as ``primary keys'' that trigger data-triggered joins, and set a fixed time window for continuous data streams (e.g. network traffic data).

In both time-triggered and data-triggered joins, we see repeated data appearing in multiple join results due to the lower frequency of some streams. Ideally, we want to send at most one copy of the same data over the network to avoid unnecessary bandwidth usage, especially if the data payload is large. Section~\ref{sec:lazy} proposes a novel technique called lazy data routing to address this problem.

% This would result in repeated occurrences of old data from other streams, but it ensures the timeliness of joins.
% This ensures the timeliness of data for latency-sensitive applications.
