\section{Spatial Constraints for Visualization}
\label{section:constraints}

We introduce a spatial constraint model to depict the positioning of visual objects within visualizations. We provide an overview of spatial constraints frequently employed in visualizations and establish definitions for \textbf{atomic constraints} to model spatial layouts. We illustrate the applicability of atomic constraints in representing typical visualizations through examples.



\subsection{Modeling Visualization Layouts with Forces}
\label{sec:vis_force_case}


This section introduces a conceptual framework that models visual objects with constraints, using several illustrative scenarios. As depicted in Figure \ref{fig:filter_circle} (a), each bar within the chart can be treated as an area-type object with four control points. When implementing the bar chart programmatically, the position and shape of each bar are determined using predefined algorithms. For instance, if the chart is constructed using a tool like D3~\cite{bostock2011d3}, the programmer assigns attributes (such as \texttt{x}, \texttt{y}, \texttt{width}, and \texttt{height}) to each \texttt{<rect>} element.
However, in situations where certain bars, such as the pink bars, are removed, the programmer must implement a function to readjust the positions of the remaining bars, aligning them with the $x$-axis. Achieving fluid transitions in such cases requires additional significant effort.

In our approach, bars can be conceptualized as physical objects stacked on a supporting surface (ground). All objects are influenced by gravity, naturally descending towards the ground. In this context, the $x$-axis serves as the supporting ground, facilitating intuitive and automated movement of visual objects. As depicted in Figure \ref{fig:filter_circle}, when the pink bars are removed, the blue bars naturally descend to rest upon the $x$-axis, aided by the ``hold-up'' force exerted by the $x$-axis. Consequently, the final spatial arrangement of visual objects results in a simplified bar chart.
Furthermore, beyond external forces impacting visual objects, there are internal forces preserving the shapes of these objects. For instance, the fixed distance between the bottom-left and top-left corner points is maintained both vertically and horizontally.






\begin{figure}[!htb]
    \centering
    \setlength{\belowcaptionskip}{10px}
    \includegraphics[width=.9\columnwidth]{image/filter_circle}
    \caption{The position of the existing visual objects will be updated after some visual objects are removed.}
    \label{fig:filter_circle}
\end{figure}


\autoref{fig:filter_circle} depicts a stacked area chart and a bubble chart. After the removal of the pink area in the stacked area chart, the blue area descends to the "ground". Within the stacked area chart, each point is influenced by multiple horizontal positions (i.e., ticks). Additionally, there are collision forces among the visual objects in the vertical direction to prevent the blue area from overlapping with the pink area. In the bubble chart, collision forces also exist among the bubbles. Simultaneously, all the points are drawn towards the center in the horizontal direction. In these examples, the control points are subject to three types of constraints:
\begin{itemize}
  \item \textbf{Environmental Constraints}: In the bar chart and area chart depicted in \autoref{fig:filter_circle}, each visual object is influenced by both gravity and "hold-up" forces in the vertical direction. These forces are referred to as the \textbf{gravity} and \textbf{support} constraints, respectively.
  
  \item \textbf{Inter-object Constraints}: Vertical collision forces come into play among visual objects, such as the stacked blue and pink bars in \autoref{fig:filter_circle}. These \textbf{collision} constraints ensure that the blue bars are stacked atop the pink bars, preventing overlap. Additionally, for point-like visual objects, collision forces maintain separation between circles.
  
  \item \textbf{Intra-object Constraints}: Visual objects also have \textbf{fixed} relationships among their internal points to preserve their shapes. For instance, fixed vertical distances between control points (e.g., between the top-left and bottom-left corners) maintain a constant bar height.
\end{itemize}
  











\subsection{Control Points}


Three types of visual objects exist: points (\inlinegraphics{image/point_visual_mark}), lines (\includegraphics{image/line_visual_mark}), and areas (\includegraphics{image/area_visual_mark}). Control points serve as the fundamental units for these visual objects. These objects manifest as individual control points, connected sequences of control points forming lines, and enclosed regions defined by control points.
In the context of SVG (Scalable Vector Graphics), control points for lines and areas can be extracted by parsing the endpoints of each segment from an SVG path. For instance, in a bar chart, each bar is defined by its four corner points, which function as control points. Similarly, in a circular chart, each circle is represented as a point with an associated radius.
In a stacked area chart, points encompass the areas of each visual object. Presently, our focus is on 2-D visualization, where a control point occupies a position defined by two dimensions. Formally, a control point is represented as $$P_i = \{(x, y), r\},$$ where $x$ and $y$ denote coordinates along the horizontal and vertical axes in a Cartesian coordinate system. The value of $r$ represents the point's radius.
For line-type and area-type visual objects, the radii of their control points are set to $0$, while a point-type object may possess a non-zero radius. This distinction in radii contributes to the nuanced representation of these various visual elements.



\subsection{Atomic Constraints}

As summarized in subsection~\ref{sec:vis_force_case}, our analysis reveals four fundamental atomic constraints: gravity, support, collision, and fixed constraints. The subsequent paragraphs provide the formal definitions for each of these constraints.

\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.09\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_gravity}
      \vspace{-0.03\columnwidth}
    \end{center}
\end{wrapfigure}
\textbf{Gravity constraints} induce an attractive force towards a control point $P$ from a specific position, either horizontally or vertically. Formally, a gravity constraint for a control point $P$ in the $x$ direction is established by minimizing $$f_g\left(x - d\right),$$ where $f_g$ increases as the magnitude of $|x - d|$ increases.
To ensure the continuity and differentiability of gravity constraints for optimization purposes, we define $$f_g \left( t\right) = (t)^2,$$ which represents the simplest function that maintains continuity and differentiability. The accompanying diagram on the right provides an illustrative instance of gravitational attraction towards the control point in the $x$-direction.








\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.03\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_constraint}
      \vspace{-0.03\columnwidth}
    \end{center}
\end{wrapfigure}
\textbf{Support constraints} exert controlled influence on the coordinates of a given control point $P$, either compelling them to exceed or remain below specific thresholds along the horizontal or vertical axes. 
An instance is enforcing a point's positioning above a designated threshold. 
This can be observed in \autoref{fig:filter_circle}, where support constraints are enforced on the bars from $x$-axis.
Mathematically, the support constraint for a control point $P$ is defined as
$$x \pm \xi = d,$$
where $\xi$ represents a non-negative slack variable. This constraint ensures that $\xi \geq 0$ in all cases. When the positive sign is selected for $\pm$, as in $$x + \xi = d,$$
control point $P$ is positioned to the left of the distance $d$.











\begin{wrapfigure}{r}{0.16\columnwidth}
  \begin{center}
    \vspace{-0.03\columnwidth}
    \includegraphics[width=0.16\columnwidth]{image/formula_collision_A}
    \vspace{-0.04\columnwidth}
  \end{center}
\end{wrapfigure}
\textbf{Collision constraints} pertain to the spatial relationship between control points. Two types of collision constraints exist: the collision of control points along the vertical or horizontal axes and the collision relationship among point-type visual objects. The former guarantees specific positions relative to each other, positioning control point $A$ to the left, right, above, or below control point $B$.
Mathematically, the constraint in the x-direction is expressed as
$$x_{b} - x_a - d \pm \xi = 0,$$
When the $\pm$ sign is negative, thus yielding
$$x_{b} - x_a - d - \xi = 0,$$
as illustrated in the right figure, Point $B$ is situated to the right of Point $A$, with a minimum distance of $d$ between them.

\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.06\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_collision}
      \vspace{-0.08\columnwidth}
    \end{center}
\end{wrapfigure}
The collision constraints among point-type visual objects prevent overlapping of points within a 2D space.
This constraint guarantees that the distance between two points exceeds the sum of their radii. The collision constraint between two points, $P_a$ and $P_b$, can be expressed as
$$\ d\left(P_a, P_b\right) = \sqrt{(x_a - x_b)^2 + (y_a - y_b)^2} \geq r_a + r_b.$$


\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.04\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_fixed}
      \vspace{-0.12\columnwidth}
    \end{center}
\end{wrapfigure}
\textbf{Fixed constraints} are related to the fixed distance of control points inside a visual object.
For example, the fixed-distance between corner points of a bar.
Formally, a fixed constraint for points $A$ and $B$ in the x-direction is presented as $$(x_a - x_b - d) = 0.$$


\subsection{Modeling Visualization Layouts with Atomic Constraints}

This subsection offers an introduction to the methodology of representing common visualizations using atomic constraints. \autoref{fig:chart_constraint} showcases a matrix that includes four common visualizations, each accompanied by its corresponding atomic constraints.


Within the conceptual framework, our spatial constraint model can be built upon control points, integrating a range of constraint types, thus facilitating versatile representations. Commencing with visualizations articulated in control point format within a two-dimensional Cartesian coordinate system, we employ a set of visualizations as case studies. These encompass both categorical and quantitative axes.

\begin{itemize}
\item \textbf{Gravity constraints:}
Coordinate axes can apply gravity constraints to their associated positions. For example, in a line chart or scatter plot, the positions of control points are defined by the data they represent along their respective coordinates. Gravity constraints are solely relevant to line charts and scatter plots, with no involvement of collision or fixed constraints. As the coordinate axes are rescaled, the visual objects within these charts experience scale adjustments accordingly.

\item \textbf{Fixed constraints:} Slightly more complex visualizations incorporate fixed constraints, as seen in bar charts and area charts.
Fixed constraints can align with data mappings or pre-established configurations. For instance, in the context of a bar chart, the height corresponds to data values, while the width represents pre-defined settings.

\item \textbf{Support constraints:}
Moreover, in the case of stacked visualizations along an axis, gravity and support forces can be utilized to guarantee the vertical alignment of content along the x-axis (assuming we are discussing visualizations stacked along the x-direction).

\item \textbf{Collision constraints:}
Interactions among visual objects lead to compression and collision effects. For instance, take a stacked area chart, where a collision relationship exists between the visual objects both above and below, requiring collision constraints.
In a grouped bar chart, collision constraints are relevant to the left and right visual objects within a group.



\end{itemize}



Expanding on these insights, we illustrate the process of constraint inference through various representative examples. Specifically, for the purpose of demonstration, we offer instances involving stacked bar charts, grouped bar charts, stacked area charts, and bubble charts. Following this, we broaden our analysis to encompass basic bar charts, area charts, line charts, and scatter plots.
All these instances are rooted in visualizations within a two-dimensional Cartesian coordinate system.






\begin{figure}[!ht]
  \centering
  \includegraphics[width=.8\columnwidth]{image/force}
  \caption{Constraints for exemplary visualizations. Each column corresponds to a visualization type, and each row represents a specific category of atomic constraints.}
  \label{fig:chart_constraint}
\end{figure}

\begin{itemize}
\item \textbf{Stacked bar chart}.
\autoref{fig:chart_constraint} (a) displays a stacked bar chart alongside its four types of atomic constraints.
Each bar adheres to fixed constraints along all four edges.
Vertical collision constraints exist among the stacked bars within a group, ensuring their non-overlapping alignment.
Simultaneously, all bars experience a horizontal gravitational force that pulls them towards the center position of the tick marks (such as ``Tick A'' for the left bars).
Moreover, all control points are subjected to gravitational and supportive constraints originating from the $x$-axis, designated as the \textbf{baseline axis}.
Through the collective interplay of these four constraint types, the visual objects assume their respective positions.



\item \textbf{Grouped bar chart}.
As depicted in \autoref{fig:chart_constraint} (b), the fixed constraints, gravity constraints, and support constraints applicable to a grouped bar chart closely mirror those of a stacked bar chart.
Within a single group, horizontal collision constraints arise among the bars.
The fundamental divergence between a grouped bar chart and a stacked bar chart pertains solely to the orientation of the collision constraints.

\item \textbf{Stacked area chart}.
A stacked area chart typically portrays the temporal evolution of multiple data series.
As depicted in \autoref{fig:chart_constraint} (c), the control points forming a vertical line in a visual object are governed by fixed constraints, ensuring a constant height at a specific x-position.
Each point's x-position is subject to horizontal gravity constraints.
Analogous to a stacked bar chart, gravity constraints and support constraints originating from the baseline axis are also applicable.
Furthermore, collision constraints in the vertical direction prevent visual objects from overlapping.


\item \textbf{Bubble chart}.
\autoref{fig:chart_constraint} (d) illustrates a bubble chart, where bubbles experience compression from the left and right sides while being drawn towards the horizontal line.
The absence of overlap among bubbles is due to collision constraints.
A vertical gravity constraint originates from the center, while support constraints are present on the left and right sides.



\item \textbf{Other visualizations.}
The constraints can also be applied to model other prevalent visualizations. For instance, a simple bar chart exhibits a subset of the constraints found in a stacked bar chart, with the exception of collision forces.
Regarding line charts and scatter plots, collision constraints are not applicable to visual objects within them.
Gravity constraints in both horizontal and vertical directions can effectively underpin the modeling process.

\end{itemize}

In stacked/grouped bar charts and stacked area charts, collision constraints exclusively pertain to the control points of distinct visual objects sharing the same tick value on the $x$-axis; this subset of objects is termed the collision group.
To illustrate, in \autoref{fig:chart_constraint}, stacked or grouped bars occupying identical tick positions on the $x$-axis, or points aligned along the same vertical line within the stacked area chart, form part of a collision group.
The control points within a collision group maintain an order and direction, denoted as the collision order and collision direction, respectively.
For instance, the stacked area chart presented in \autoref{fig:chart_constraint} (c) exhibits a collision order: the blue visual element is positioned above the red one, with a vertical collision direction.




We utilize these examples to demonstrate the efficacy of atomic constraints.
Such constraints can stabilize control points in their present locations and facilitate enhanced interactivity, a topic elaborated upon in ~\autoref{section:manipulation}.




\subsection{Construction of Constraints for Existing Charts}



We present a heuristic algorithm for constructing constraints in an existing visualization based on the analysis of prevalent design patterns.
Initially, we extract the control points from the given chart.
Subsequently, we establish the \textbf{visual object set}, which constitutes a collection of visual objects of the same category.
In the case of area objects (such as bars and areas), the constraint construction involves detecting the baseline axis, calculating collision constraints, and determining fixed constraints.
Regarding point objects (like points and bubbles), we incorporate a point collision detection mechanism.
For line objects (including line charts), since there typically exist no collision constraints among visual elements (as lines are usually not stacked together), we can assign gravity constraints to maintain their current positions.


\textbf{Control point extraction.}
We initiate the process by utilizing a visualization in SVG format to extract the control point positions.
In our methodology, a \texttt{<circle>} element is interpreted as a point visual object.
A line or an open path in the SVG corresponds to a line visual object.
Closed paths and rectangles are parsed as area visual objects.
The absolute coordinates of each control point are calculated.
Subsequently, we compile a roster of visual objects along with their corresponding control points.
A bar encompasses four control points located at its corners.
In contrast, each bubble constitutes an object with a solitary control point positioned at its center.
For area objects, control points are positioned at the termini of each segment within the \texttt{<path>} element of the SVG.



\textbf{Visual object set extraction.}
A visual object set comprises a group of visual objects employed in establishing constraints.
A visualization encompasses a series of data items depicted by a set of visual objects.
An area object set facilitates the creation of diverse chart types, such as stacked and basic area charts, as well as stacked, grouped, and basic bar charts.
For instance, a set of uniformly spaced bars forms a bar chart.
Point sets are employed in crafting scatter plots and bubble charts.
A singular line or an assemblage of lines can be harnessed to craft a line chart.



\begin{figure}[htbp]
    \centering
    \setlength{\belowcaptionskip}{-10px}
    \includegraphics[width=\columnwidth]{image/bar_area_deducing}
    \caption{Baseline axes and ticks of bar charts and area charts.}
    \label{fig:bar_area_deducing}
\end{figure}

\textbf{Baseline axis detector.}
For bar charts and area charts, a baseline axis is established, which enforces gravity and support constraints on the visual objects.
As demonstrated in \autoref{fig:bar_area_deducing}, a shared configuration (d) featuring a baseline axis showcases multiple parallel tick lines perpendicular to the baseline.
By analyzing the positions of control points and visual objects, we identify the baseline.
In both stacked and simple bar charts, the centers of bars are uniformly aligned along the baseline axis, simplifying the computation of tick positions via these visual object centers.
Similarly, in stacked area charts, control points oriented along the baseline axis are uniformly distributed, enabling us to designate these equidistant positions as ticks.
In the scenario of grouped bar charts, the intermediate positions on the scale do not exhibit perfect uniformity. Consequently, we ascertain these positions in conjunction with the arrangement of text (which is uniformly distributed) along the axes.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=\columnwidth]{image/evenly_distribute}
  \caption{Evenly distributed intervals can be extracted using the peaks in the frequency domain even with some noise.}
  \label{fig:evenly_distributed}
\end{figure}


The central step in establishing the baseline axis involves assessing the uniform distribution of visual objects, control points, and text along the vertical or horizontal dimension.
We derive their positions in the x- and y-directions, followed by a transformation into the frequency domain using Fourier analysis.
Illustrated in \autoref{fig:evenly_distributed}, the identification of evenly spaced intervals is facilitated by identifying peaks in the frequency domain.
As shown in \autoref{fig:evenly_distributed}, positions are projected with a 5-pixel interval, accompanied by some degree of noise.
By detecting peaks within the frequency domain, we can extract distribution intervals.
This interval corresponds to a wavelength within the frequency domain, and its calculation is as follows:
$interval = \frac{50}{10} = 5.$
By employing the computed interval to filter out noise, we deduce the positions of ticks.
Upon tick detection, the baseline direction is established.
With the identification of the baseline axis direction, the baseline position can be readily determined using the positions of visual objects along the perpendicular direction.
Subsequently, the support constraints and gravity constraints are ascertained.

\textbf{Calculation of collision constraints.}
Collision constraints solely come into effect for control points of distinct visual objects situated within the same tick area, as depicted in \autoref{fig:bar_area_deducing}.
We ascertain the absence of overlapping by evaluating both the x and y directions of the control points.
In instances where a group of visual objects within a tick area exhibit non-overlapping alignment in a specific direction, we conclude that these elements possess collision constraints with one another.
For instance, in a grouped bar chart, collision constraints are oriented parallel to the baseline axis to ensure bars align in parallel along it.
In contrast, stacked area and stacked bar charts impose collision constraints perpendicular to the baseline axis to ensure elements are orthogonally stacked.


\textbf{Calculation of fixed constraints.}
Fixed constraints are confined to control points situated within the boundaries of the same visual objects and tick intervals. As depicted in \autoref{fig:bar_area_deducing}, we can enforce fixed constraints on visual objects that fall within a shared tick interval. In cases where a visual object is entirely contained within a tick interval, such as a bar in a bar chart, we establish fixed constraints on the two vertices of an edge along each of the four sides, thereby preserving the edge's positioning. In situations where elements extend across multiple tick intervals, fixed constraints are applied to the same element within the corresponding tick interval. For instance, in the context of an area chart, fixed constraints are set on two points at the same x-position perpendicular to the axis.









\textbf{Point collision detector.}
We propose a point collision detection algorithm designed to ascertain whether a collection of point objects is subject to collision constraints. When a series of circles are closely situated, the separation between pairs of circles approaches the summation of their radii, resulting in $Distance(A, B) - r_a - r_b \sim 0$.
Our collision detection algorithm computes the distribution of $Distance(A, B) - r_a - r_b$, with the expected minimum value being approximately 0 if collision constraints exist. In scenarios involving numerous interconnected pairs of circles, the FloodFill algorithm is employed to identify a continuous area of interconnected circles, originating from a specified circle.

For visual object groupings devoid of collision constraints, such as line charts and scatter plots, the gravity constraints can be aligned with the present positions of control points along both the x- and y-axes. In such visualizations, axis scaling can be adjusted to modify the gravity constraints on the control points.





It is noteworthy that the algorithms presented in this section serve as inference algorithms, grounded in prevalent implementation approaches for visualizations. The algorithm is founded on vector visualization and encompasses several established principles, such as aligning multiple labels horizontally or vertically along the axes. It encompasses a range of common visualizations, including bar charts (stacked, grouped, simple), area charts (stacked, overlapped, simple), bubble charts (including collision detection), scatter plots, and line charts.
Nevertheless, this inference method does not represent the sole solution, as alternative reverse engineering approaches~\cite{savva2011revision, poco2017reverse} for extracting visualization results can also be equivalently expressed as outcomes derived from the inference process outlined in this method.



\begin{algorithm}[!htb]
    \caption{Optimization Process: the calculation of the position of control points.}
    \label{alg:optimization}
    \begin{algorithmic}[1]
    \Require 
    \Statex Control points list $P_i$, with position $(P_i.x, P_i.y)$, velocity $(P_i.v_x, P_i.v_y)$, and radius $(P_i.r)$, $P_i.v_x = 0$, $P_i.v_y = 0$;
    \Statex Gravity constraints list $G_i$, $i = 1, 2 \ldots N_g$, $G_i = \{P, d, dim\}$; \Comment{$P$ is the position; $dim$ is the coordinate direction of $G_i$, i.e., $dim \in \{x, y\}$}
    \Statex Support constraints list $S_i$, $i = 1, 2 \ldots N_s$, $S_i = \{P, d, dim, op\}$; \Comment{$op \in \{\leq, \geq\}$.}
    \Statex Fixed constraints list $F_i$, $i = 1, 2 \ldots N_f$, $F_i = \{P_{1}, P_{2}, d, dim\}$; \Comment{$d$ is the distance.}
    \Statex Collision I constraints list $L_{i}$, $i = 1, 2 \ldots N_l$, $L_i = \{P_{1}, P_{2}, d, dim\}$; %
    \Statex Collision II constraints list $C_i$, $i = 1, 2 \ldots N_c$, $C_i = \{P_{1}, P_{2}, d\}$; %
    \Statex alpha; \Comment{The strength of current iteration.}
    
    \For{ $i = 1;\ i \leq N_g;\ i \gets i + 1$}\Comment{Handle gravity constraints.}
    \State $dim = G_i.dim$\Comment{$dim \in \{x, y\}$}
    \State $\epsilon \gets G_i.P[dim] + G_i.P.v[dim] - G_i.distance$
    \State $G_i.P.v[dim] \gets G_i.P.v[dim]  -\epsilon * alpha$; 
    \EndFor

    \For{ $i = 1;\ i \leq N_s;\ i\gets i + 1$}\Comment{Handle support constraints.}
    \State $dim = S_i.dim$
    \If{not $S_i.P[dim] + S_i.P.v[dim]\ S_i.op\ S_i.d$}\Comment{$S_i.op \in \{\leq,\geq\}$}
    \State $S_i.P[dim] \gets S_i.d$
    \State $S_i.P.v[dim] \gets 0$; 
    \EndIf
    \EndFor

    \For{ $i = 1;\ i \leq N_f;\ i\gets i + 1$}\Comment{Handle fixed constraints.}
    \State $dim = F_i.dim$; $d \gets F_i.d$;  $P_1 \gets F_i.P_1$; $P_2 \gets F_i.P_2$
    \State $\epsilon \gets P_{1}[dim] + P_{1}.v[dim] - P_{2}[dim] - P_{2}.v[dim] - d$
    \State $P_{1}[dim] \gets P_{1}[dim] - \epsilon * 0.5$;  $P_{2}[dim] \gets P_{2}[dim]  + \epsilon * 0.5$
    \State $P_{1}.v[dim], P_{2}.v[dim] \gets (P_{1}.v[dim] + P_{2}.v[dim])/2$
    \EndFor
    \For{ $i = 1;\ i \leq N_l;\ i\gets i + 1$}\Comment{Handle collision I constraints.}
    \State $dim \gets L_i[dim]$; $P_1 \gets L_i.P_1$; $P_2 \gets L_i.P_2$
    \State $\epsilon \gets P_{1}[dim] + P_{1}.v[dim] - P_{2}[dim] - P_{2}.v[dim] - L_i.d$
    \If{$\epsilon < 0$}
    \State $P_{1}[dim] \gets P_{1}[dim]  -\epsilon * 0.5$; $P_{2}[dim] \gets P_{2}[dim]  +\epsilon * 0.5$
    \State $v_{avg} \gets P_{1}.v[dim] + P_{2}.v[dim]$
    \State $P_{1}.v[dim] \gets v_{avg}$; $P_{2}.v[dim] \gets v_{avg}$
    \EndIf
    \EndFor
    
    \For{ $i = 1;\ i \leq N_c;\ i\gets i + 1$}\Comment{Handle collision II constraints.}
    \State $P_1 \gets C_i.P_1$; $P_2 \gets C_i.P_2$
    \State $d_x \gets (P_{1}.x + P_{1}.v_x - P_{2}.x - P_{2}.v_x)$
    \State $d_y \gets (P_{1}.y + P_{1}.v_y - P_{2}.y - P_{2}.v_y)$
    \State $d \gets \sqrt{(d_x)^2 + (d_y)^2}$
    \State $\epsilon \gets d - N_i.d$
    \If{$\epsilon < 0$}
    \State $bias \gets (P_{1}.radius) ^ 2 / ((P_{1}.radius) ^ 2 + (P_{2}.radius) ^ 2)$
    \State $P_{1}.v_x \gets P_{1}.v_x - \epsilon * d_x / d * bias$
    \State $P_{1}.v_y \gets P_{1}.v_y - \epsilon * d_y / d * bias$
    \State $P_{2}.v_x \gets P_{2}.v_x - \epsilon * d_x / d * (1- bias)$
    \State $P_{2}.v_y \gets P_{2}.v_y - \epsilon * d_y / d * (1 - bias)$
    \EndIf
    \EndFor
    \For{ $i = 0; i < N_p; i\gets i + 1$}\Comment{Update control points' position.}
    \State $P_i.x \gets P_i.x + P_i.v_x$; $P_i.y \gets P_i.y + P_i.v_y$
    \EndFor
    \end{algorithmic}
\end{algorithm}


\subsection{Optimization Process}

The interaction process involves three key stages: dragging, dropping, and optimization, as depicted in \autoref{fig:pipeline}.
Spatial constraints guide visual objects towards a new equilibrium.
To make the optimization process interactive and continuous, we employ physical forces to encode these constraints.
Once visual objects, control points, and constraints are extracted from the visualization, we convert the constraint conditions into forces that facilitate spatial transformations of the control points.
Each visual object is linked to an ordered sequence of control points, collectively defining point, line, or area-type visual entities based on their arrangement.
Every control point possesses attributes of position and velocity. During each iteration, these control points update their positions and velocities, resulting in the rendering of a new visual object based on the revised control point positions.
We leverage D3's force-directed simulation~\cite{bostock2011d3}, tailoring the forces to accommodate spatial constraint integration.
Further details are provided in Algorithm~\ref{alg:optimization}.
The computational complexity of a force-directed layout is $O(k * (n^2))$, where $k$ denotes the number of iterations, and $n$ signifies the count of control points.
Except for circle collisions, constraints operate solely along horizontal or vertical axes.
Consequently, the influence of each control point on others is limited, curbing the magnitude of $n$ in the complexity equation.
For circle collisions, a quad-tree division is employed before computation, reducing the collision complexity to $O(kn\ log(n))$.
In a visualization featuring 1,000 control points (e.g., a bar chart with 250 bars), the optimization process can converge within a matter of seconds.













































    

















