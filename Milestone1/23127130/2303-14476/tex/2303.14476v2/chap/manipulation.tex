

\section{Manipulation Supported by Constraints}
\label{section:manipulation}

As depicted in \autoref{fig:manipulate_classification}, direct manipulations can be classified into three distinct types based on their targets: visual objects, axes, and constraints. These manipulations are respectively referred to as object-level, axis-level, and constraint-level manipulations.



\begin{figure*}[!ht]
  \centering
  \includegraphics[width=\textwidth]{image/manipulate_classification}
  \caption{
    Our approach empowers users to directly manipulate visual objects, axes, and constraints. It accommodates a wide range of interaction tasks within visualizations.
  }
  \label{fig:manipulate_classification}
\end{figure*}

\subsection{Manipulating Visual Objects}
\label{sec:manipulate_object}

Object-level manipulations directly alter the positions of visual objects.
User intent might be implicitly embedded within object manipulations.
Manipulations involving distinct directions, distances, and velocities convey diverse user intentions.
For instance, dragging visual objects along the collision direction implies adjustments to stacking or grouping order, while moving a visual object beyond the current canvas suggests transferring it to a new canvas.


\textbf{Changing the stacking direction.}
A set of visual objects can be stacked either along the $x$-direction (e.g., in a grouped bar chart) or the $y$-direction (e.g., in a stacked bar chart).
Examples of changing the stacking direction include transforming a grouped bar chart into a stacked bar chart, converting a stacked bar chart into a grouped bar chart, or altering a stacked area chart into an overlapped area chart or vice versa.
The alteration of stacking direction involves reconfiguring collision constraints to align with the new direction.
For example, in \autoref{fig:manipulate_classification} (a), when collision constraints along the $y$-direction shift to the $x$-direction, the newly introduced collision constraints cause the blue bars to spread horizontally from the red bars.
At the same time, the downward gravitational force affects the descent of the blue bars.
Transforming a stacked bar chart into a grouped bar chart facilitates intra-group bar comparisons, while converting a grouped bar chart into a stacked bar chart aids in depicting totals.



\textbf{Changing the stacking order.}
As demonstrated in \autoref{fig:manipulate_classification} (b), the user performs a drag action, moving the pink bar above the blue bar.
This action implies an intention to alter the stacking order of these two visual objects.
We subsequently recompute the collision order based on the updated positions of these visual objects.
Specifically, within each tick area, the horizontal position of the pink bar is adjusted to be higher than that of the blue bar.
Consequently, the gravitational force pushes the blue bar downward towards the $x$-axis, resulting in the pink bar descending and being stacked atop the blue bar.

\textbf{Moving to a new canvas.}
When a visual object (or a group of visual objects) is dragged beyond the canvas boundaries (\autoref{fig:manipulate_classification} (c)), a new canvas is generated to accommodate the relocated visual object(s).
The spatial constraints from the original canvas are inherited by the new canvas.
Manipulation and optimization are carried out independently for the visual objects within each canvas.
Visual objects can be moved between existing canvases by dragging.
Rapidly dragging and dropping visual objects outside the canvas will result in the deletion of these objects.

\subsection{Manipulating Axes}
\label{sec:manipulate_axes}


Axis-level manipulation is founded on the alteration of axis-related constraints driven by user interactions.
These constraints encompass gravity, support, and fixed constraints, all aligned with the axis direction.
Manipulations on the axis lead to rescaling and reordering visual objects.
Based on the encoded data attributes, axes are categorized into two types: those with continuous attributes (quantitative and temporal) and those with discrete attributes (categorical).
The determination of axis type is contingent upon the labels present on the axis ticks. An axis is classified as continuous if its text labels can be converted to numeric values or time stamps;
otherwise, it is interpreted as a discrete axis.
Manipulations executed on the axis engender changes in its scale or order.
For continuous axes, users can effect rescaling or reordering by magnifying (via scrolling or pinching) the axis or dragging its ticks.
On discrete axes, tick rearrangements can be accomplished through tick dragging, and rescaling can be achieved by zooming (e.g., altering the widths of bars).
Correspondingly, as the scale or order undergoes modification, the associated constraints evolve in tandem.
These constraints also act as drivers for the convergence of control points to new positions.


\textbf{Rescaling axes.}
As shown in \autoref{fig:manipulate_classification} (d), users can zoom in on a continuous axis to change the scale of the axis.
In our method, users can zoom in on a continuous axis in three ways, namely, by pinching, scrolling, and dragging a tick label.
The scale of the axis changes according to the zooming rate.
According to the changed scale, our model updates the gravity, support, and fixed constraints of the control points in the axis direction.



\textbf{Reordering axes.}
If the axis is discrete (e.g., categorical), users can reorder the axis directly by dragging the ticks, as shown in \autoref{fig:manipulate_classification} (e).
After dragging the ticks, the order of the ticks is recalculated according to the ticks' new positions.
The gravity constraints of a specific tick on the axis are changed accordingly.
Moreover, as dragging each tick to sort the ticks is time-consuming, we also implement a sort function; by right-clicking the axis, the ticks can be sorted according to selected visual objects' attributes (e.g., width, height, left, right, or color).
For example, we can sort the bars of a bar chart according to the height of the bars.


\begin{figure}[htb]
    \centering
    \setlength{\belowcaptionskip}{-10px}
    \includegraphics[width=\columnwidth]{image/case_force_set}
    \caption{
        Manipulating constraints and setting new constraints for visual objects results in diverse new layouts of visual objects.
        (a) A bubble chart.
        (c) Constructing an aggregated view by setting support and gravity constraints.
    }
    \label{fig:force_handle}
\end{figure}


\subsection{Manipulating Constraints}
\label{sec:manipulate_cons}

The manipulation of constraints includes two parts: changing the existing constraints and setting new constraints.

\textbf{Changing constraints.}
The selected visual objects' constraints can be modified directly through dragging.
Our interface presents the top-$k$ gravity and support constraints with the most control points.
Each constraint has a handle for the users to manipulate.
When the constraints are dragged, related visual objects' constraints are changed.
For example, we can transform a stacked area chart into a ThemeRiver~\cite{havre2002themeriver} by dragging all visual objects' gravity constraints to the center, as illustrated in \autoref{fig:manipulate_classification} (f).
In \autoref{fig:manipulate_classification} (g), the bubbles can be squeezed by changing the support constraints.

\textbf{Setting new constraints.} 
Except for manipulating an existing constraint, users can set new constraints.
For instance, \autoref{fig:manipulate_classification} (g) and (f) can be interpreted as the establishment of new constraints.
Moreover, setting constraints on visual objects can construct diverse visualization layouts.
For example, as shown in~\autoref{fig:force_handle}, the bubble chart is reshaped to a bar chart by setting new support and gravity constraints.

\textbf{Setting groups of constraints.} 
When users want to rearrange visual objects based on their visual attribute values, they can assign different constraints to visual objects with different attribute values.
Considering that it is time-consuming to individually set constraints for each visual element, we allow users to batch set a group of different constraints based on a specific attribute (e.g., height, width, color).
The outcome is the segregation of visual objects with different attributes.
As depicted in \autoref{fig:manipulate_classification} (f), different $x$-axis gravity constraints can be assigned to bubbles of different colors.










\subsection{High-Level Interactions}

In subections~\ref{sec:manipulate_object}, \ref{sec:manipulate_axes}, and \ref{sec:manipulate_cons}, we describe low-level manipulations supported by our model.
These low-level manipulations are basic interactions for change the spatial layouts of the visualization.
These manipulations can compose high-level interactions for users' various requirements.
Users can perform various interactions using these manipulations.
We list interactions and discuss how they are composed by these manipulations.

\begin{itemize}

\item \textbf{Navigating} changes the users' viewpoints.
Navigating effectively narrows the field of view to allow users to observe details, e.g., in a dense scatterplot or a multi-line chart.
Visualization with continuous axes allows navigation interactions.
In our model, the navigation is performed by rescaling the continuous axes. 


\item \textbf{Filtering} reduces the number of visual objects. 
Our method supports filtering by selecting focused visual objects and dragging them to a new canvas or by selecting unfocused visual objects and deleting them.
Filtering is a generic interaction for common visualizations such as, for example, bar charts, area charts, line charts, and scatterplots.

\item \textbf{Rearranging} changes the spatial organization of visual objects; it includes reordering, realignment, etc. 
Rearranging is supported by our model on three levels: there is object-level, axis-level, and constraint-level rearranging.
At the object level, users can drag visual objects to reorder, align, and stack them.
For example, users can reorder the categories of a ThemeRiver graph. 
At the axis level, manipulating discrete axes means reordering or sorting the axes.
At the constraint level, flexible constraint settings create a large space for rearrangement.
For example, a user can set support constraints for visual objects to align them.

\item \textbf{Re-encoding} represents to change the encoding of the visual objects.
Our model enables users to change encoding of visualizations at object level or constraint level.
At the object level, users can transform a grouped bar chart into a stacked bar chart or a stacked area chart into an overlapping area chart by simply drag on the visual objects.
At the constraint level, users can set groups of gravity constraints for visual objects according to their size or color, and they can re-encode their positions, as \autoref{fig:manipulate_classification} (h) shows, the constraint-level manipulation supports high freedom for users to define a new layout for the visualization.

\item \textbf{Aggregating} changes the granularity of the visual objects by gathering visual objects of the same type.
Users can set different gravity and support constraints at the constraint level for visual objects with different attributes, such as those with different colors. 
There is ample flexibility in setting constraints to aggregate certain visual objects.
For example, as illustrated in \autoref{fig:force_handle}, by setting collision, support, and gravity constraints, a bubble chart can be transformed into an aggregated bar chart.

\end{itemize}





\begin{figure}[!ht]
    \centering
    \setlength{\belowcaptionskip}{-10px}
    \includegraphics[width=1.04\columnwidth]{image/interface}
    \caption{
        The interface of our system.
        Top: direct interactions with visual objects or axis.
        Bottom: direct setting constraints for visual objects directly.
    }
    \label{fig:interface}
\end{figure}

\subsection{Direct Manipulation Interface}
\label{section:interface}



The frontend interface is developed using JavaScript and the D3 library.
As illustrated in \autoref{fig:interface}, a visualization is rendered on a canvas.
To initiate the process, we create a canvas and reproduce the existing visualization on it.
Since we are redrawing the original visual objects using new paths, the corresponding visual objects are removed from the original visualization.
A new layer is introduced for visual objects and axes, employing control points to delineate these visual objects.
For area-type visual objects, we generate closed regions using the control points, while for line-type visual objects, we connect the control points.
Point-type elements are depicted as circular visual elements created using paths.
Visual attributes such as color, opacity, stroke color, and stroke width are preserved for these visual objects.
The resulting paths incorporate interactive features, enabling user actions like dragging.
Similarly, axes are fully redrawn using the D3 library, while maintaining the original axes' font styles and sizes.
The interface provides users with the ability to manipulate visual objects, axes, and constraints.

Furthermore, canvas operations have been implemented, including drag functionality, canvas creation, canvas duplication, canvas deletion, and scaling.
Four icons located in the top-left corner allow users to perform these actions, respectively: canvas deletion, canvas duplication, canvas reset, and display of the constraints layer.
Concerning the constraints layer, appropriate representations have been selected based on metaphors associated with different types of constraints.
Clicking the constraints button unveils a new layer that exhibits constraints and provides buttons for setting new constraints, as depicted at the bottom of \autoref{fig:interface}.
Constraints pertaining to the selected visual object are displayed and can be directly manipulated.
New constraints can be defined for the selected visual objects, encompassing support (upward, downward, left, rightward), gravity (vertical and horizontal), and collision constraints.










  

