\section{Spatial Constraints for Visualization}
\label{section:constraints}

We propose a spatial constraint model to represent the positions of visual objects in visualizations. We summarize spatial constraints commonly used in visualizations and define \textbf{atomic constraints} for modeling the spatial layout. We demonstrate that atomic constraints can be used to represent common visualizations through examples.



\subsection{Modeling Visualization Layouts with Forces}
\label{sec:vis_force_case}

This section presents a conceptual framework for modeling visual objects with constraints in several exemplary cases.
As shown in Figure \ref{fig:filter_circle} (a), each bar in the chart can be considered an area-type object with four control points.
When implementing the bar chart programmatically, the position and shape of each bar are calculated using pre-defined algorithms.
For example, if the chart is implemented using D3~\cite{bostock2011d3}, the programmer sets the attributes (i.e., \texttt{x}, \texttt{y}, \texttt{width}, and \texttt{height}) for each \texttt{<rect>} element.
However, if certain bars are removed, the programmer must implement a function to reset the remaining bars' position so that they move down to align with the x-axis, which also requires significant effort to encode transition animations.

In our force-based approach for modeling bar charts, the bars can be treated as physical objects stacked on a ground, with all the objects driven by gravity to move downwards towards the ground. The x-axis is considered the ground that supports these objects, allowing visual objects to move intuitively and automatically.
As shown in Figure \ref{fig:filter_circle}, when the pink bars are removed from the chart, the blue bars fall down onto the x-axis naturally and stop on the x-axis due to the "hold-up" force from the x-axis. The final spatial layout results in a simple bar chart.
In addition to external influences on the visual objects, there are also internal influences to maintain the shapes of the visual objects. For example, the bottom-left and top-left corner points have a fixed distance in both the vertical and horizontal directions.






\begin{figure}[!htb]
    \centering
    \setlength{\belowcaptionskip}{10px}
    \includegraphics[width=.9\columnwidth]{image/filter_circle.png}
    \caption{The position of the existing visual objects will be updated after some visual objects are removed.}
    \label{fig:filter_circle}
\end{figure}


\autoref{fig:filter_circle} shows a stacked area chart and a bubble chart.
After removing the pink area in the stacked area chart, the blue area falls to the ``ground''.
In the stacked area chart, each point is attracted to several horizontal positions (i.e., ticks).
Moreover, there are collision forces among the visual objects in the vertical direction to keep the blue area from overlapping with the pink area.
In the bubble chart, there are also collision forces among bubbles. 
Meanwhile, all the points are attracted to the center in the horizontal direction.
In these examples, the control points have three types of constraints:
\begin{itemize}
    \item \textbf{Constraints from the environment}. For each visual object in the bar chart and area chart shown in \autoref{fig:filter_circle}, there are the gravity and ``hold-up'' forces in the vertical direction, \revision{which are denoted as the \textbf{gravity} and \textbf{support} constraints, respectively.} 
    \item \textbf{Constraints among visual objects}. 
    There are vertical collision forces among the visual objects, such as the stacked blue bars and pink bars in \autoref{fig:filter_circle}.
    \textbf{Collision} constraints make the blue bars stack on top of the pink bars rather than overlapping with them. 
    For point-like visual objects, \revision{the collision force keeps the circles from overlapping with each other.}
    \item \textbf{Constraints within a visual object}. 
    There are \textbf{fixed} relations among the points inside a visual object to keep the shape of the visual object.
    \revision{For example, there are fixed distances in the vertical direction of the control points in a bar (e.g., between the top-left corner and bottom-left corner) to keep the height of the bar constant.}

\end{itemize}











\subsection{Control Points}

There are three types of visual objects, namely, points~\inlinegraphics{image/point_visual_mark.pdf}, lines~\includegraphics{image/line_visual_mark.pdf}, and areas~\includegraphics{image/area_visual_mark.pdf}.
These visual objects are treated as points, connected lines of points, and enclosed areas of points, respectively.
These points are defined as control points; the control point is the basic layout unit in our framework.
In the practice of SVG (scalable vector graphics), the line and area control points can be parsed using each segment's endpoints from an SVG path.
\revision{In a bar chart, the four corner points of each bar are the control points.}
Each circle is regarded as a point with a radius in a circle chart.
A stacked area chart has points enclosing the area of each visual object.
Currently, we consider the visualization in a 2-D scenario, where a control point has a position with two dimensions. 
The formal definition is $P_i = \{(x, y), r\},$
where $x$ and $y$ are the coordinates of two directions, i.e., the horizontal and vertical dimensions in a Cartesian coordinate system, and $r$ is the point's radius. 
The radii of the control points of line-type and area-type visual object are set to 0, while a point-type object may have a non-zero radius.



\subsection{Atomic Constraints}

According to the summarization in subsection~\ref{sec:vis_force_case}, we have four atomic constraints, including gravity, support, collision, and fixed constraints.
We give the formal definitions of these constraints in the following texts.

\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.07\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_gravity.pdf}
      \vspace{-0.07\columnwidth}
    \end{center}
\end{wrapfigure}
\textbf{Gravity constraints} cause a certain position to have an attractive force to a control point $P$ in the horizontal or vertical direction.
Formally, a gravity constraint for a control point $P$ in the $x$ direction involves minimizing $(f_g\left(x - d\right))$, where $f_g$ increases when $|x - d|$ increases.
To make the gravity constraints continuous and differentiable (for optimization), we set $f_g \left( t\right) = (t)^2$, which is the simplest function.
The figure on the right shows an example of gravitational attraction to the control point in the $x$-direction.







\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.06\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_constraint.pdf}
      \vspace{-0.06\columnwidth}
    \end{center}
\end{wrapfigure}
\revision{\textbf{Support constraints} cause the coordinates of a control point $P$ to be forcibly greater or smaller than a certain value in the horizontal or vertical direction.
For example, they can be used to force a point above a certain position.}
The $x$-axis imposes support constraints on the bars in \autoref{fig:filter_circle}.
Formally, the support constraint for a control point $P$ is
$x \pm \xi = d$.  
$\xi$ is a slack variable that is always non-negative.
When the sign of $\pm$ is positive, i.e., $x + \xi = d$, $P$ is to the left of the position $d$.



\begin{wrapfigure}{r}{0.16\columnwidth}
  \begin{center}
    \vspace{-0.05\columnwidth}
    \includegraphics[width=0.16\columnwidth]{image/formula_collision_A.pdf}
    \vspace{-0.05\columnwidth}
  \end{center}
\end{wrapfigure}
\textbf{Collision constraints} are related to the distance relationship of the control points.
There are two collision constraints: the collision of control points in the vertical or horizontal direction, and the collision relationship among point-type visual objects.
The former can ensure that control point A is to the left, right, above, or below control point B.
Formally, the constraint in the x-direction is presented as
$x_{b} - x_a - d \pm \xi = 0,$ 
where $\xi$ is a slack variable.
When the sign $\pm$ is negative, i.e., $x_{b} - x_a - d - \xi = 0,$
as shown in the figure to the right, Point B is to the right of Point A, and the distance between them is not less than $d$.

\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.04\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_collision.pdf}
      \vspace{-0.04\columnwidth}
    \end{center}
\end{wrapfigure}
The collision constraints among point-type visual objects ensure the points of a 2D space do not overlap with each other.
This constraint ensures that the distance between two points is larger than the sum of their radii.
The collision constraint between two points $P_a$ and $P_b$ is$
\ d\left(P_a, P_b\right) = \sqrt{(x_a - x_b)^2 + (y_a - y_b)^2} \geq r_a + r_b.$


\begin{wrapfigure}{r}{0.16\columnwidth}
    \begin{center}
      \vspace{-0.04\columnwidth}
      \includegraphics[width=0.16\columnwidth]{image/formula_fixed.pdf}
      \vspace{-0.04\columnwidth}
    \end{center}
\end{wrapfigure}
\textbf{Fixed constraints} are related to the fixed distance of control points inside a visual object.
Formally, a fixed constraint for two points $A$ and $B$ in the x-direction is presented as $(x_a - x_b - d) = 0.$


\subsection{Modeling Layouts with Atomic Constraints}

This subsection introduces how to model some common visualizations with atomic constraints.
\autoref{fig:chart_constraint} shows a matrix of four common visualizations and their atomic constraints.

\begin{figure}[!ht]
  \centering
  \setlength{\belowcaptionskip}{-5px}
  \includegraphics[width=.8\columnwidth]{image/force.pdf}
  \caption{Constraints of common visualization examples. Each column is a visualization type, while each row is an atomic constraint.}
  \label{fig:chart_constraint}
\end{figure}

\textbf{Stacked bar chart}. 
\autoref{fig:chart_constraint} (a) shows the original stacked bar chart and its atomic constraints.
Each bar has fixed constraints on the four edges.
There are vertical collision constraints among the stacked bars.
The collision constraints keep the bars from overlapping with each other.
Meanwhile, all bars have a horizontal gravitational attraction to the center position of the tick (e.g., ``Tick A'' for the left bars).
All control points have gravity constraints and support constraints from the x-axis, which is denoted as the \textbf{baseline axis}.


\textbf{Grouped bar chart}.
As \autoref{fig:chart_constraint} (b) shows, the fixed constraints, gravity constraints, and support constraints of a grouped bar chart are similar to the constraints of the stacked bar chart.
There are horizontal collision constraints among bars in the same group.
The only difference is the direction of the collision constraints.


\textbf{Stacked area chart}.
A stacked area chart usually presents temporal changes in several data series.
As shown in \autoref{fig:chart_constraint} (c), the control points of a visual object in a vertical line have fixed constraints, which ensure that the height of the visual object at a certain x-position remains constant.
Each point's x-position has horizontal gravity constraints.
Similar to a stacked bar chart, the gravity constraints and support constraints from the baseline axis also exist.
Moreover, there are collision constraints in the vertical direction to keep the visual objects from overlapping with each other.



\textbf{Bubble chart}.
\autoref{fig:chart_constraint} (d) is a bubble chart; the bubbles are squeezed by the left and right sides while being attracted by the horizontal line. 
The bubbles do not overlap with each other because there are collision constraints among the bubbles.
There is a gravity constraint from the vertical center and support forces from the left and right sides.



\textbf{Other visualizations.}
The constraints can also be used to model other common visualizations, e.g., a simple bar chart has a subset of the constraints of a stacked bar chart, except for the collision force.
As for line charts and scatter plots, there are no collision constraints among the visual objects.
The gravity constraints in both the horizontal and vertical directions can sufficiently support the modeling.


In a stacked/grouped bar chart and a stacked area chart, the collision constraints only exist for the control points among different visual objects with the same tick-value on the x-axis; these objects are defined as the \textbf{collision group}.
For example, in \autoref{fig:chart_constraint}, the stacked bars or grouped bars at the same tick on the x-axis or the points on the same vertical line in the stacked area chart belong to a collision group.
Control points of several visual objects in a collision group have an order and a direction, which are denoted as the \textbf{collision order} and \textbf{collision direction}, respectively.
For example, the stacked area chart in \autoref{fig:chart_constraint} (c) has a collision order: the blue visual object is above the red one, and the collision direction is vertical.



We use these examples to show the effectiveness of the atomic constraints. 
These constraints can stabilize the control points at their current positions and support more interactivity, which we discuss in Section~\ref{section:manipulation}.



\subsection{Construction of Constraints for Existing Charts}


We introduce a heuristic construction of constraints for an existing visualization based on the observation of a common design.
First, we extract the control points from the given chart.
Then, we extract the \textbf{visual object set}, which is a group of visual objects of the same type.
For the area objects (e.g., bars and areas), the construction of the constraints consists of baseline axis detection, the calculation of collision constraints, and the calculation of fixed constraints.
For the point objects (e.g., points and bubbles), we implement a point collision detector.
For line objects (including the line chart), as there are no collision constraints among the visual objects (i.e., usually, the lines cannot be stacked together), we can set the gravity constraints to their current position.

\textbf{Control point extraction.}
We start with a visualization in the SVG format to obtain the positions of control points.
In our method, a \texttt{<circle>} is regarded as a point visual object.
A line or an open path in SVG corresponds to line visual objects.
Closed paths and rectangles are parsed as the area visual objects.
The absolute coordinate of each control point is calculated.
We obtain a list of visual objects with their corresponding control points.
A bar has four control points in the corners.
Each bubble is an object with only one control point in the center.
An area object has control points at the ends of each segment in the \texttt{<path>} element of an SVG.


\textbf{Visual object set extraction.}
A visual object set is a group of visual objects that is used to construct the constraints.
A visualization has a set of visual objects that represent a list of data items.
An area object set can construct stacked/simple area charts and stacked/grouped/simple bar charts.
For example, a set of evenly distributed bars composes a bar chart.
Points sets can be used to construct scatter plots and bubble charts.
A line or a line set can be used to construct a line chart.



\begin{figure}[htbp]
    \centering
    \setlength{\belowcaptionskip}{-10px}
    \includegraphics[width=\columnwidth]{image/bar_area_deducing.pdf}
    \caption{Baseline axes and ticks of bar charts and area charts.}
    \label{fig:bar_area_deducing}
\end{figure}

\textbf{Baseline axis detector.}
For a bar chart or an area chart, there is a baseline axis with gravity and support constraints on the visual objects.
As shown in \autoref{fig:bar_area_deducing}, there is a common structure (d) with a baseline axis, where several parallel \textbf{tick lines} are perpendicular to the baseline.
We count the positions of the control points and visual objects to detect the baseline.
The centers of the bars of stacked and simple bar charts are evenly distributed on the baseline axis.
Therefore, we can calculate the tick positions using the centers of the visual objects.
For the stacked area chart, the control points in the direction of the baseline axis are also evenly distributed, and we can consider the evenly distributed positions as ticks.
For grouped bar charts, the middle positions of the scales are not completely evenly distributed, so we determine them together with the position of the text (as it is evenly distributed) on the axes.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\columnwidth]{image/evenly_distribute.pdf}
  \caption{Evenly distributed intervals can be extracted using the peaks in the frequency domain even with some noise.}
  \label{fig:evenly_distributed}
\end{figure}



The core step of determining the baseline axis is to judge whether or not the visual objects, control points, and text are evenly distributed in the vertical or horizontal direction.
We obtain their positions in the x- and y- directions and transform them into the frequency domain using the Fourier transform.
As shown in \autoref{fig:evenly_distributed}, the evenly distributed intervals can be extracted using the peaks of the frequency domain.
\autoref{fig:evenly_distributed} shows a projection of positions that have an interval of 5 pixels, with some noise.
The distribution intervals can be extracted using the peaks in the frequency domain.
The interval is the wavelength in the frequency domain, and it can be calculated as follows: 
$interval = \frac{50}{10} = 5.$
We can filter out noises using the calculated interval and deduce the ticks' position.
When a tick is detected, the baseline direction is determined.
As the baseline axis direction has been detected, the baseline position can be easily obtained using the positions of visual objects in another direction.
The support constraints and gravity constraints are then determined.

\textbf{Calculation of collision constraints.}
Collision constraints exist only among the control points of different visual objects in the same tick area, as shown in \autoref{fig:bar_area_deducing}.
We calculate the control points in both the x and y directions to determine if they are arranged without overlapping.
If the control points of a group of elements within a tick area are arranged without overlapping in a particular direction, we consider the elements to have collision constraints with each other.
For example, a grouped bar chart has collision constraints parallel to the base axis to ensure that the bars are arranged parallel to the base axis.
On the other hand, a stacked area chart and a stacked bar chart have collision constraints perpendicular to the base axis to ensure that the elements are stacked in a direction perpendicular to the base axis.

\textbf{Calculation of fixed constraints.}
Fixed constraints are limited to control points within the same visual objects and tick areas. As illustrated in Figure~\ref{fig:bar_area_deducing}, we can impose fixed constraints on visual objects within the same tick area. For visual objects that entirely reside within a tick area, such as a bar in a bar chart, we set fixed constraints on the two vertices of an edge along the four sides to ensure the edge's position. For elements that span across tick areas, we impose fixed constraints on the same element in the same tick area. For instance, for an area chart, we set fixed constraints on two points on the same x- position perpendicular to the axis.








\textbf{Point collision detector.}
We propose a point collision detection algorithm to determine whether a group of point objects has collision constraints.
When a set of circles are closely connected, the distance between pairs of circles is close to the sum of their radii, such that $Distance(A, B) - r_a - r_b \sim 0$.
We calculate the distribution of $Distance(A, B) - r_a - r_b$ in our collision detection algorithm, and the minimum value should be around 0 if there are collision constraints. If there are many connected circle pairs, we use the FloodFill algorithm to obtain a continuously connected area of circles starting from a given circle.

For visual object groups without collision constraints, such as line charts and scatter plots, the gravity constraints can be set to the current position of control points in both the x- and y-directions. In such visualizations, the scale of the axes can be manipulated to adjust the gravity constraints on the control points.

In this subsection, we provide a heuristic approach for extracting constraints from static visualizations. It is worth noting that this constraint extraction approach is just one path of many. Other reverse engineering methods~\cite{savva2011revision, poco2017reverse} can also be combined with our approach to construct constraints after extracting visual objects.



\begin{algorithm}[!htb]
    \caption{Optimization Process: the calculation of the position of control points in each iteration of the optimization process.}
    \label{alg:optimization}
    \begin{algorithmic}[1]
    \Require 
    \Statex Control points list $P_i$, with position $(P_i.x, P_i.y)$, velocity $(P_i.v_x, P_i.v_y)$, and radius $(P_i.r)$, $i = 1, 2 \ldots N_p$, $P_i.v_x = 0$, $P_i.v_y = 0$;
    \Statex Gravity constraints list $G_i$, $i = 1, 2 \ldots N_g$, $G_i = \{P, d, dim\}$; \Comment{$P$ is the position; $dim$ is the coordinate direction of $G_i$, i.e., $dim \in \{x, y\}$}
    \Statex Support constraints list $S_i$, $i = 1, 2 \ldots N_s$, $S_i = \{P, d, dim, op\}$; \Comment{$op \in \{\leq, \geq\}$.}
    \Statex Fixed constraints list $F_i$, $i = 1, 2 \ldots N_f$, $F_i = \{P_{1}, P_{2}, d, dim\}$; \Comment{$d$ is the distance.}
    \Statex Collision I constraints list $L_{i}$, $i = 1, 2 \ldots N_l$, $L_i = \{P_{1}, P_{2}, d, dim\}$; %
    \Statex Collision II constraints list $C_i$, $i = 1, 2 \ldots N_c$, $C_i = \{P_{1}, P_{2}, d\}$; %
    \Statex alpha; \Comment{The strength of current iteration.}
    
    \For{ $i = 1;\ i \leq N_g;\ i \gets i + 1$}\Comment{Handle gravity constraints.}
    \State $dim = G_i.dim$\Comment{$dim \in \{x, y\}$}
    \State $\epsilon \gets G_i.P[dim] + G_i.P.v[dim] - G_i.distance$
    \State $G_i.P.v[dim] \gets G_i.P.v[dim]  -\epsilon * alpha$; 
    \EndFor

    \For{ $i = 1;\ i \leq N_s;\ i\gets i + 1$}\Comment{Handle support constraints.}
    \State $dim = S_i.dim$
    \If{not $S_i.P[dim] + S_i.P.v[dim]\ S_i.op\ S_i.d$}\Comment{$S_i.op \in \{\leq,\geq\}$}
    \State $S_i.P[dim] \gets S_i.d$
    \State $S_i.P.v[dim] \gets 0$; 
    \EndIf
    \EndFor

    \For{ $i = 1;\ i \leq N_f;\ i\gets i + 1$}\Comment{Handle fixed constraints.}
    \State $dim = F_i.dim$; $d \gets F_i.d$;  $P_1 \gets F_i.P_1$; $P_2 \gets F_i.P_2$
    \State $\epsilon \gets P_{1}[dim] + P_{1}.v[dim] - P_{2}[dim] - P_{2}.v[dim] - d$
    \State $P_{1}[dim] \gets P_{1}[dim] - \epsilon * 0.5$;  $P_{2}[dim] \gets P_{2}[dim]  + \epsilon * 0.5$
    \State $P_{1}.v[dim], P_{2}.v[dim] \gets (P_{1}.v[dim] + P_{2}.v[dim])/2$
    \EndFor
    \For{ $i = 1;\ i \leq N_l;\ i\gets i + 1$}\Comment{Handle collision I constraints.}
    \State $dim \gets L_i[dim]$; $P_1 \gets L_i.P_1$; $P_2 \gets L_i.P_2$
    \State $\epsilon \gets P_{1}[dim] + P_{1}.v[dim] - P_{2}[dim] - P_{2}.v[dim] - L_i.d$
    \If{$\epsilon < 0$}
    \State $P_{1}[dim] \gets P_{1}[dim]  -\epsilon * 0.5$; $P_{2}[dim] \gets P_{2}[dim]  +\epsilon * 0.5$
    \State $v_{avg} \gets P_{1}.v[dim] + P_{2}.v[dim]$
    \State $P_{1}.v[dim] \gets v_{avg}$; $P_{2}.v[dim] \gets v_{avg}$
    \EndIf
    \EndFor
    
    \For{ $i = 1;\ i \leq N_c;\ i\gets i + 1$}\Comment{Handle collision II constraints.}
    \State $P_1 \gets C_i.P_1$; $P_2 \gets C_i.P_2$
    \State $d_x \gets (P_{1}.x + P_{1}.v_x - P_{2}.x - P_{2}.v_x)$
    \State $d_y \gets (P_{1}.y + P_{1}.v_y - P_{2}.y - P_{2}.v_y)$
    \State $d \gets \sqrt{(d_x)^2 + (d_y)^2}$
    \State $\epsilon \gets d - N_i.d$
    \If{$\epsilon < 0$}
    \State $bias \gets (P_{1}.radius) ^ 2 / ((P_{1}.radius) ^ 2 + (P_{2}.radius) ^ 2)$
    \State $P_{1}.v_x \gets P_{1}.v_x - \epsilon * d_x / d * bias$
    \State $P_{1}.v_y \gets P_{1}.v_y - \epsilon * d_y / d * bias$
    \State $P_{2}.v_x \gets P_{2}.v_x - \epsilon * d_x / d * (1- bias)$
    \State $P_{2}.v_y \gets P_{2}.v_y - \epsilon * d_y / d * (1 - bias)$
    \EndIf
    \EndFor
    \For{ $i = 0; i < N_p; i\gets i + 1$}\Comment{Update control points' position.}
    \State $P_i.x \gets P_i.x + P_i.v_x$
    \State $P_i.y \gets P_i.y + P_i.v_y$
    \EndFor
    \end{algorithmic}
\end{algorithm}


\subsection{Optimization Process}

Our interaction process follows three steps: dragging, dropping, and optimizing, as shown in \autoref{fig:pipeline}.
Spatial constraints drive visual objects into a new equilibrium.
\revision{We use physical forces to encode the constraints to make the optimization process interactive and continuous.
We utilize the force-directed simulation of D3~\cite{bostock2011d3} and customize the force according to the integration of spatial constraints. 
In each iteration, the positions and velocities of the control points are updated according to the constraints involved.}
The details are shown in Algorithm~\ref{alg:optimization}.
The computational complexity of a force-directed layout is $O(k * (n^2))$, where $k$ is the iteration number, and $n$ is the number of control points.
The constraints, except for the circle collisions, are only in the horizontal or vertical directions.
Therefore, the number of control points that will influence each other is small, which limits the value of $n$ in the complexity function.
\revision{For the circle collisions, we employ the quadtree division before calculation.
The complexity for circle collision is reduced to $O(k*n*log(n))$.}
For a visualization with 1,000 control points (e.g., a bar chart with 250 bars), the optimization can converge in several seconds.











































    

















