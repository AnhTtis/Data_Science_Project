\section{Introduction}
\label{sec_introduction}

%
\textbf{Recursive descent parsing} is a technique for (manually or mechanically) writing \emph{top-down} parsers based on the description of a context-free grammar. 
%
Recursive descent parsers have in common that every (nonterminal and terminal) symbol of the grammar is implemented by a piece of code, that these pieces of code can be placed in a sequence -- implementing an alternate of the grammar -- and that the choice between a nonterminal's alternates is implemented by branching control-flow.
%
Recursive descent parser generators implement a direct translation from grammar to parser.
%
Every symbol is translated independently (separate compilation) and the code for symbols can be tested independently (semantic modularity).
%
As a result, generated parsers are easy to maintain and debug; updated grammar specifications require minimal recompilation and unexpected behavior can be identified by isolating the parts of the parser and input that cause the unexpected behavior.
%

The functional characteristics of recursive descent parsers vary depending on the top-down parsing algorithm on which they are based, but recursive descent parsers have historically struggled with left-recursive nonterminals and non-factorized alternates.
%
Typical implementations only accept LL(k) grammars: the set of context-free grammars for which it holds that, with $k \geq 0$ terminal symbols lookahead, no two alternates are simultaneously applicable.
%
Employing a recursive descent parser generator often involves applying grammar transformations to remove left-recursion and/or to apply left-factorization to produce an LL(k) grammar.
%
However, applying grammar transformations may not always be desirable or even possible; there are context-free grammars for which there is no LL(k) equivalent.
%

\textbf{Bottom-up parsing} is more often possible without applying grammar transformations.
%
Bottom-up parsers are also very fast, benefiting from pre-computed information recorded in a table -- the so-called `parse table'.
%
These properties have made bottom-up parsing more popular than top-down parsing as the basis for parser generators, as evidenced by the large variety of algorithms such as LALR, SLR and GLR~\cite{tomita1985} and implementations such as by Yacc, Bison, Happy~\cite{happy}, Menhir~\cite{menhir}, Rascal~\cite{rascal2009}, Spoofax~\cite{kats2010} and SDF~\cite{vandenbrand2002}.
%
However, the users of bottom-up parser generators do not benefit from separate compilation and semantic modularity.
%

%
This paper discusses a new back-end for Happy which generates recursive descent parsers based on the generalized LL (GLL) algorithm.
%
The back-end has the aforementioned advantages of recursive descent parsing, but does not require any grammar transformations.
%
\textbf{Generalized parsing algorithms} are \textit{general} in the sense that they accept arbitrary context-free grammars and \textit{complete} in the sense that they produce all possible derivations of a given input string.
%
The generalized LL (GLL) algorithm~\cite{scott2013,scott2016} relies on intricate bookkeeping within potentially large datastructures to simultaneously ensure that parsers terminate and find all derivations. 
%
Despite this added complexity, GLL parsers are still easy to maintain, debug and support separate compilation and semantic modularity (like other recursive descent parsers).
%

\textbf{Generalized parser combinators} are recent technologies that combine the benefits of generalized parsing and parser combinators~\cite{ridge2014,afroozeh2016,binsbergen2018a,binsbergen2020}.
%
The mentioned approaches have in common that they involve explicit representations of grammar components such as symbols and productions rules -- as is required by Earley's generalized parsing algorithm~\cite{earley1970}, GLR~\cite{tomita1985} and GLL~\cite{scott2013} -- whereas conventional parser combinators have no explicit representation of grammar components.
%
The libraries presented by~\cite{ridge2014} and~\cite{binsbergen2018a} generate an actual grammar object before providing it as input to a standalone generalized parsing algorithm (voiding separate compilation). 
%
This idea of so-called grammar combinators has also been applied outside the context of generalized parsing by \cite{ljunglof2002}, \cite{baars2004}, and \cite{devriese2011}.
%

\textbf{Grammar combinators} blur the line between combinator libraries and parser generators, leaving only a few essential differences: grammar combinator libraries generate parsers at runtime rather than in a separate phase and grammar combinator libraries define \emph{embedded} domain-specific languages (EDSLs) whereas parser generators define external domain-specific languages (DSLs).
%
EDSLs are typically easy to extend, with the power of the host language available to define new operators. 
%
This holds true for parser combinators and, to a lesser degree, for grammar combinators~\cite{binsbergen_thesis}.
%

The \textbf{FUN-GLL} variant of the GLL algorithm computes the minimal amount of grammar information necessary for generalized parsing~\cite{binsbergen2020}. 
%
The algorithm can be used by parser combinators because grammar information is computed on an as-needed basis during parsing, rather than in a separate phase.
%
This way, reuse through abstraction with separate compilation is realized in FUN-GLL, and in our Happy back-end based on FUN-GLL.
%

\textbf{Parser generators}, viewed as implementing DSLs, typically provide a \emph{fixed} number of language constructs, often corresponding to some variation of Extended Backus-Naur Form (EBNF).
%
The `parameterized nonterminals\footnote{Referred to as `parameterized productions' in the user manual of Happy.}' of the Happy parser generator make it possible for users to define their own operators over grammar symbols, akin to macro-grammars~\cite{fischer68,thiemann2004} and the parameterized nonterminals of the Menhir~\cite{menhir} and \precc{}~\cite{precc} parser generators.
%
However, parameterized nonterminals do not reach their full potential in the existing (LALR and GLR) back-ends of Happy as it is not possible to reuse user-defined operators across grammars.
%
Moreover, the back-ends rely on an algorithm that effectively performs macro-expansion on all parameterized nonterminals.
%
This algorithm may fail to terminate or may result in exponentially large parsers generated in an exponential amount of time.
%
The GLL back-end for Happy presented in this paper overcomes these problems by generating reusable, higher-order functions, akin to FUN-GLL parser combinators, for the nonterminals of a grammar.
%

The contributions of this paper are as follows. This paper:
\begin{itemize}
\item Presents a strategy for generating modular, reusable and complete top-down parsers from syntax descriptions with parameterized nonterminals
\item Adds a back-end to Happy that realizes the full potential of Happy's parameterized nonterminals, making Happy one of the few parser generators to support `reuse through abstraction' of which it is perhaps the first to generate complete parsers that find all derivations of an input string
%\item A Haskell library is presented that implements the core datastructures and operations required by the purely functional GLL (FUN-GLL) algorithm of~\cite{binsbergen2020}. This library is used by an implementation of the parser combinators in~\cite{binsbergen2020} as well as by the new Happy back-end.
\item The GLL back-end is to our knowledge the first implementation of GLL in a parser generator for Haskell and the first back-end for Happy with all the benefits of recursive descent parsing
\item The GLL back-end is compared to the existing GLR and LALR back-ends in a number of experiments, demonstrating the characteristics of the new back-end
\end{itemize}
%
%Although presented in a Haskell, the ideas of this paper should transfer to other grammar formalisms and host languages with higher-order functions.

Section~\ref{sec_motivation} motivates the GLL back-end by explaining the advantages of recursive descent parsing and parameterized nonterminals.
%
Section~\ref{sec_fungll} explains how the GLL back-end translates parameterized nonterminals to reusable GLL parsers that compute all interpretations of an input string.
%
Section~\ref{sec_implementation} discusses practical aspects of the implementation of the GLL back-end, including some specific aspects of the Happy grammar formalism such as monadic semantic actions.
%
Section~\ref{sec_evaluation} demonstrates certain advantages of the alternative treatment of parameterized nonterminals and compares the running times of the different Happy back-ends in an empirical evaluation. 
%
Sections~\ref{sec_related_work} and~\ref{sec_conclusion} discuss related work and conclude.
