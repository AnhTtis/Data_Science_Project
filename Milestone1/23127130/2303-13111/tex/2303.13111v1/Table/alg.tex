\begin{algorithm}[t]
\caption{\small Pseudo code for MLPP (PyTorch-like)}
\label{alg:spatial_stage}
\definecolor{codeblue}{rgb}{0.25,0.5,0.25}
\lstset{
	backgroundcolor=\color{white},
	basicstyle= \fontsize{6.5pt}{6.5pt}\ttfamily\selectfont,
	columns=fullflexible,
	breaklines=true,
	captionpos=b,
	commentstyle=\fontsize{6.5pt}{6.5pt}\color{codeblue},
	keywordstyle=\fontsize{6.5pt}{6.5pt}\color{blue}
}
\begin{lstlisting}[language=python]
# H: height, W: width, C: channel, D: depth, L: segment length
# x: input tensor of shape (H, W, D, C)

def init():
    g = C // L
    proj_h = Linear(C, C)    # Encoding information along the vertical axis
    proj_w = Linear(C, C)    # Encoding information along the horizontal axis
    proj_c = Linear(C, C)    # Encoding channel information
    proj_d = Linear(C, C)    # Encoding through-plane information
    attn = Linear(L * L, L * L)   # Auxiliary Attention
    proj_1, proj_2, proj_3 = Linear(C, C), Linear(C, C), Linear(C, C) # Information fusion
    norm_1, norm_2, norm_3 = Layernorm(), Layernorm(), Layernorm()

def IP-MLP(x): 
    x_att = x.reshape(H // L, L, W // L, L, D, C)
    x_att = x_att.permute(0, 2, 4, 5, 1, 3).reshape(H // L, W // L, D, C, L * L)
    x_att = attn(x_att).reshape(H // L, W // L, D, C, L, L)
    x_att = x_att.permute(0, 4, 1, 5, 2, 3).reshape(H, W, D, C)
    
    x_h = x.transpose(1,0).reshape(H * W // L, L, D, L, g)
    x_h = x_h.permute(0, 3, 2, 1, 4).reshape(H * W // L, L, D, L * g)
    x_h = proj_h(x_h).reshape(H * W // L, L, D, L, g)
    x_h = x_h.permute(0, 3, 2, 1, 4).reshape(W, H, D, C).transpose(1,0)
    
    x_w = x.reshape(H * W // L, L, D, L, g)
    x_w = x_w.permute(0, 3, 2, 1, 4).reshape(H * W // L, L, D, L * g)
    x_w = proj_w(x_w).reshape(H * W // L, L, D, L, g)
    x_w = x_w.permute(0, 3, 2, 1, 4).reshape(H, W, D, C)
    
    x_c = proj_c(x)
    
    x = x_h + x_w + x_c
    x = (1 + x_att) * x
    x = proj_1(x)
    return x

def TP-MLP(x):
    x_d = x.reshape(H, W, D // L, L, L, g)
    x_d = x.permute(0, 1, 2, 4, 3, 5).reshape(H, W, D // L, L, L * g)
    x_d = proj_d(x_d).reshape(H, W, D // L, L, L, g)
    x_d = x_d.permute(0, 1, 2, 4, 3, 5)
    x_d = proj_2(x_d)
    return x_d

def MLPP(x):
    x = x + IP-MLP(norm_1(x))
    x = x + TP-MLP(norm_2(x))
    x = x + proj_3(norm_3(x))
    return x
\end{lstlisting}
\end{algorithm}