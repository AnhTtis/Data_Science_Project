%Nowadays single-core quantum processors are far from being general-purpose quantum computers and from the so-called quantum practicality. To achieve these goals, scalability is necessary, but going beyond the NISQ era and developing a scalable quantum computer is a challenge, as it must handle an increasing number of qubits without losing fidelity.

%Current single-core quantum computers have been scaled considerably in the past years, reaching a total of 127 qubits by the quantum processor Eagle developed by IBM~\cite{Eagle}, and planning to achieve the number of 1000 qubits in the following years~\cite{IBMRoadmap}. 

%However, scaling this kind of architecture entails several challenges due to the increasing amount of errors. Principal errors are caused by: i) qubit decoherence. ii) Gates and measurements are imperfect and prone to errors caused by, for instance, frequency collisions~\cite{8614500} or crosstalk~\cite{Ding_2020}. iii) Hardware complications such as wiring, system cooling or isolation from the environment to preserve qubits' states~\cite{sebastiano2020cryo}. Increasing the number of qubits on a single chip considerably increases the above-mentioned errors, decreasing execution fidelity and complicating scalability.


%\begin{figure}
%\centering
%\includegraphics[width=86mm]{fig/map_process.drawio.png}
%\vspace{-0.5cm}
%\caption{Mapping process procedure. The compiler receives as input the quantum hardware description, on the right, as well as the quantum algorithm, on the left. It outputs the scheduled operations, i.e compiled quantum algorithm, that can be executed by the quantum device and performs the initial placement and the routing process.}
%\vspace{-0.1cm}
%\label{fig:map_process}
%\end{figure}

%           ---> !!! FIGURES IN THE MAIN FILE FOR EASY ORDERING !!! <----

Quantum circuit mapping techniques have been developed for single-chip NISQ processors, as part of the compilation process, to deal with their constraints and allow to successfully execute quantum algorithms~\cite{https://doi.org/10.48550/arxiv.2007.01000,mappings, 8382253, 7059001, Venturelli_2018,10.1145/3168822,8980312,10.1145/3297858.3304075}. More precisely, quantum circuit mapping is about transforming hardware-agnostic quantum circuit descriptions into a hardware-compliant version that considers all physical restrictions of a given quantum processor. One of the main constraints in current quantum devices is the reduced connectivity between physical qubits, which usually limits their possible interactions to only nearest-neighbour requiring qubits to be moved to adjacent positions to execute the desired two-qubit operation (e.g. CNOT gate). The circuit mapping procedure consists of different steps: i) \textbf{gate decomposition}, in which gates of the circuit are decomposed into a series of native gates implementable in the quantum processor; ii) \textbf{initial placement} of qubits, where quantum circuit qubits, i.e. virtual qubits, are assigned to the physical qubits of the device. This process helps to minimize the (movement) operations needed in the routing stage; iii) \textbf{routing} of qubits, in which non-neighboring qubits that need to perform a two-quit gate are moved to adjacent physical qubits (which share a connection) by means of, for instance, SWAP gates; and iv) \textbf{scheduling} of operations to leverage parallelism while respecting their dependencies and quantum hardware constraints. An example of the quantum circuit mapping process is shown in Figure~\ref{fig:map_example}.

%The compilation or mapping of a quantum algorithm is proved to be an $NP$-completed problem~\cite{complexity} in which a hardware-agnostic quantum algorithm is translated into one that considers all physical constraints a quantum processor has. The main constraint is the limited connectivity between physical qubits, which restricts their possible interactions requiring qubits to be moved to execute the desired operations. The mapping process introduces several gates (commonly SWAPs gates) to place qubits in the required positions, which causes an increase in the circuit depth, decreasing the success probability of the algorithm.






%The gates the initial quantum circuit has may not be supported by the quantum processor; the \textbf{gate decomposition} process adapts them into a set of universal quantum gates that the quantum processor can recognize. The \textbf{scheduler} organizes gates through time, parallelizing operations while respecting quantum processor constraints and gate dependencies. In the \textbf{initial placement}, quantum circuit qubits, i.e. logical qubits, are assigned to the physical qubits. This process optimizes further steps by minimizing future operations needed in the routing stage. After the initial placement, the \textbf{routing} procedure checks whether all two-qubit gates can be performed. When the qubits involved in operations do not satisfy the connectivity restrictions, the routing process finds a path (e.g. shortest path) where the involved qubits are moved to the required positions. An example of the mapping process is in Figure~\ref{fig:map_example}.




As mentioned in the previous section, multi-core quantum computing architectures are a promising approach to scale up current single-core quantum computers.
%alleviating the increasing number of errors. 
Existing proposals agree on an architecture based on interconnecting multiple NISQ processors~\cite{QuantumIntranet, https://doi.org/10.48550/arxiv.2201.08861} consisting of tens to hundreds of qubits, increasing the total qubit count without losing that much fidelity and improving isolation. In this architectural design, NISQ processors will be ultimately interconnected through short-range quantum-coherent links and classical links in the form of a so-called `quantum intranet'~\cite{QuantumIntranet}. Quantum coherent links will be responsible for transporting qubits (or quantum states) from core to core, for instance, by means of shuttling o quantum teleportation. Several challenges arise with this new architecture, being the most relevant for this work the need for exchanging quantum information between cores. %Similar to the single-core mapping problem, qubits will need to find a way to interact across cores, but in this case from core to core, whenever they need to interact.
Note that these inter-core communications are more expensive and error prone than those performed in single-core architectures. Therefore, multi-core quantum computing architectures require the development of a new breed of compilation techniques that will have to consider the following fundamental different aspects:  
 
 

%This approach has been proposed for different quantum technologies, such as superconducting qubits~\cite{https://doi.org/10.48550/arxiv.2201.08861, https://doi.org/10.48550/arxiv.2201.08825}, and ion trap devices~\cite{Monroe_2014, IONQ}. The first multi-core quantum processors are planned to be launched by IBM in the following years~\cite{IBMRoadmap}. 
%Heron will first feature only classical links, followed by Flamingo, which will incorporate quantum links, and finally, Kookaburra, combining classical and quantum links~\cite{IBMRoadmap}.

%Several challenges arise with this new architecture, being the most relevant for this work the need for exchanging quantum information among cores. Similar to the single-core mapping problem, qubits will need to be moved, but in this case from core to core, whenever they need to interact. These communications between cores are more expensive and error prone than those performed in single-core architectures.

%being necessary to optimize the compilation, trying to avoid the inter-core movements by optimally planning and moving qubits among cores.
%performing two-qubit remote gates~\cite{https://doi.org/10.48550/arxiv.2201.08861} or an efficient compilation.




%\textcolor{red}{Go to the point. We do not need to show an example of trivial and optimal mapping. We just need to show that in order to make the circuit runnable we need to add some extra SWAP gates. Explain how mapping works in the caption of the example. We just need the left figure.}

%The mapping procedure consists of four different processes in no specific order i) gate decomposition, ii) initial placement, iii) routing, and iv) scheduling. The gates the initial quantum circuit has may not be supported by the quantum processor; the \textbf{gate decomposition} process adapts them into a set of universal quantum gates that the quantum processor can recognize. The \textbf{scheduler} organizes gates through time, parallelizing operations while respecting quantum processor constraints and gate dependencies. In the \textbf{initial placement}, quantum circuit qubits, i.e. logical qubits, are assigned to the physical qubits. This process optimizes further steps by minimizing future operations needed in the routing stage. After the initial placement, the \textbf{routing} procedure checks whether all two-qubit gates can be performed. When the qubits involved in operations do not satisfy the connectivity restrictions, the routing process finds a path (e.g. shortest path) where the involved qubits are moved to the required positions. An example of the mapping process is in Figure~\ref{fig:map_example}.

%\textcolor{red}{Once the previous point is made mention that several single-core mapping techniques have been proposed and add references and enumerate (bullets) and explain the main challenges and therefore differences. Also, talk about compilers for distributed quantum computers and try to derive some similarities and differences.}

%In multi-core quantum processors, the mapping of quantum algorithms can be more complicated due to the movements of qubits between cores via coherent quantum links. As mentioned before, these communications are more expensive than intra-core communications, being necessary to optimize the compilation trying to avoid the inter-core movements by optimally planning and moving qubits among cores. Note that the mapping of quantum algorithms on multi-core architectures has two different parts: first, an optimal mapping of qubits between cores must be performed, and second, qubits on single cores should be arranged to be nearest neighbors.

%Several differences can be observed in the mapping steps between single-cores and multi-cores quantum architectures. One main difference is the time consumption of qubit movements between cores. The time is not deterministic (e.g. teleportation) so it must be calculated at runtime, complicating the scheduling process. The operation time of inter-core communications is then unknown at compile time, meaning that the scheduler must be dynamic. In addition, the scheduler must have control of the available resources, i.e. which qubits are available and which are occupied with performing inter-core movements.

%The initial placement must consider different qubit movement costs: inter-core movements will be more expensive than intra-core movements. It should place the qubits considering movement costs and qubits interactions; i.e. qubits that will interact must be placed, if possible, in the same core. The gate decomposition and routing process are similar to single-core architectures. 


%There are several mapping techniques for single-core NISQ devices~\cite{https://doi.org/10.48550/arxiv.2007.01000,mappings, 8382253, 7059001, Wille2016UsingD, Venturelli_2018,10.1145/3168822}. 

%However, performing the mapping procedure in multi-core architectures entails new challenges:

\textbf{Inter-core communication}: Similar to the single-chip case in which qubits need to be adjacent for interacting, qubits placed in different cores cannot directly perform a two-qubit gate. To do so, they have to make use of entanglement-based quantum communication protocols that require the generation of the so-called \textit{Bell pairs} allowing to perform, for instance, remote CNOTs between distant qubits or to teleport quantum states from one core to another~\cite{9334411, rodrigo2022characterizing}. This comes with an overhead of resources needed for creating and distributing entangled pairs. In addition, the entanglement generation is a non-deterministic process making the scheduling task more complex. 


\textbf{Not all qubits have the same functionality}: In each of the quantum cores there will be qubits devoted to computation and storage and qubits used for communication. Communication qubits will handle inter-core communications, whereas storage qubits will perform local operations. Mapping techniques will have to include information about qubit `types' and which ones are being used as well as the resources available for communication. Note that the more qubits are dedicated to communication, the higher the number of inter-core communications that can be performed in parallel.

%\newpage
 
\textbf{ A two-step quantum circuit mapping process}: An initial qubit placement and routing should be done at the quantum core level, placing qubits that need to interact on the same core and use efficient routing techniques to reduce inter-communication operations, but also within the quantum processors to reduce the overhead created due to their limited qubit connectivity as in  the single-chip case. 

%by optimally planning and moving qubits among cores. Following it, mapping approaches for single-core processors should be applied separately to each core.
 
 
 
 
    %\item  The time consumption of qubit movements between cores is not deterministic, requiring a dynamic scheduler.
    
    %\item  The scheduler must have control of the available resources, i.e. which qubits are available and which are occupied performing inter-core movements.
    %\item The initial placement should place the qubits considering the different qubit movement costs and qubits interactions: qubits that will interact must be placed, if possible, on the same core.
    
   % \item The mapping must be performed in two steps: first, optimally planning and moving qubits among cores; second, mapping approaches for single-core processors should be applied separately to each core. 
%\end{itemize}

%There are several mapping solutions for single-core NISQ devices~\cite{https://doi.org/10.48550/arxiv.2007.01000,mappings, 8382253, 7059001, Wille2016UsingD, Venturelli_2018}. However, only a mapping approach for mapping quantum algorithms in multi-core quantum architectures~\cite{10.1145/3387902.3392617}, has been proposed so far, which will be discussed in the next section. 

Multi-core or modular architectures for scaling up quantum devices share a lot of similarities with the quantum networks that are being deployed for a future quantum internet~\cite{van2016path,https://doi.org/10.48550/arxiv.2201.08825,8910635}. The main difference resides in the fact that communications links, instead of being short-range, are long-range~\cite{Kozlowski_2019}, resulting in the need for a more complicated infrastructure to move qubits between quantum devices, i.e. quantum repeaters. Due to this quantum network infrastructure, moving qubits among devices would be more complex, needing to perform entanglement swaps~\cite{9334411}, which increases latency considerably as its duration grows exponentially with the distance between devices. One possible application of quantum networks is to perform distributed quantum computing, for which compilation techniques have been already proposed~\cite{9334411,https://doi.org/10.48550/arxiv.2112.14139,Cicconetti_2022}. However, not so much attention has been paid so far to the development of compilers for multi-core quantum computing architectures \cite{rodrigo2021double, 10.1145/3387902.3392617}. In the next sections, we  will focus on the mapping technique proposed in~\cite{10.1145/3387902.3392617}. % and further analyse its performance by performing an architectural scalability analysis. 

