
%           ---> !!! FIGURES IN THE MAIN FILE FOR EASY ORDERING !!! <----

%The work presented in~\cite{10.1145/3387902.3392617} is, so far, the only mapping technique for multi-core or modular quantum architectures. Their results are based on an architecture of 10 cores and 10 qubits per core with all-to-all connectivity.

As previously mentioned, in this work we further analyze the performance of the quantum circuit mapping approach in ~\cite{10.1145/3387902.3392617} by considering different multi-core architecture designs with  still all-to-all qubit and cores connectivity. For this purpose, several quantum benchmarks have been used. %~\cite{thesis}. 
In this paper, results for the Cuccaro and the QFT adder are presented as they have very dissimilar circuit characteristics. The Cuccaro adder is a well parallelizable and easy to scale algorithm with a low number of two-qubit gates and circuit depth. In contrast, the QFT adder is a more sequential algorithm with a huge number of two-qubit gates and large depth. In addition, two performance metrics are used: the number of non-local communications (i.e. inter-core movements) and the execution time (i.e. time it takes to calculate all valid assignments).



%\textcolor{red}{Proposal: 1)combine figures (a) and (b) on the same graph. 2) combine figures (d) and (e) on the same graph. 3) remove (c) and (f). 4) Leave strong and week scaling but not to use quantum volume unless it is necessary.}

 Figure~\ref{fig:sub1} compares how the mapping algorithm behaves when a fixed and a variable number of qubits per core is assumed, both architectures counting with ten cores. In other words, in the first case cores always consist of 10 qubits per core independently of the circuit width, whereas in the second case, the minimum (even) number of qubits per core is used based on the algorithm requirements.    %It should be noted that when a variable number of qubits per core is considered, the number of qubits should always be even since an odd number of qubits could cause a failure in the mapping procedure. 
Similar behavior with respect to non-local communications can be observed for a fixed and variable number of qubits for both quantum circuits. However, note that the difference between both cases is much more pronounced for the Cuccaro adder due to its circuit characteristics. This means that the relevance of the number of physical qubits in the architecture regarding non-local communications depends on the algorithm to be executed. In contrast, the total number of physical qubits in the architecture is crucial for the rOEE runtime. As shown in Figure~\ref{fig:sub2}, a lower execution time is required for the variable case. The reason is that the rOEE algorithm computes over physical qubits to find a valid assignment, and therefore the more physical qubits, the more iterations are needed, increasing the execution time. Furthermore, note the large difference in non-local communications as well as in execution time between the Cuccaro and the QFT adder.


%When the number of physical qubits is fixed the execution time scales linearly with the logical qubits. However, when the number of physical qubits increases with the logical qubits, the execution time drastically increases with the number of physical qubits. The rOEE computes over physical qubits to find a valid assignment, the more physical qubits, the more operations it performs, increasing the execution time,  leading to the conclusion that the number of physical qubits that an architecture has may have a limit due to the execution time. This experiment has been repeated for a larger number of physical and logical qubits, resulting in the same behavior.

In addition, two more architectural scalability experiments have been performed, named \textit{weak and strong} scaling. In weak scaling, the total number of physical qubits is fixed, whereas the number of cores and qubits per core varies, increasing the number of cores while decreasing the number of qubits per core. In Figure~\ref{fig:sub4} the weak scaling results are shown; both, the rOEE runtime as well as the non-local communications increase when more cores are added to the architecture. The more cores and fewer qubits per core, the more computations will be performed until the rOEE algorithm finds a valid assignment and the higher the inter-core movements are. %Note that the runtime rises more when the number of cores increases than the non-local communications

In strong scaling, the number of qubits per core is fixed but we increase the number of cores and therefore the total number of qubits in the device. Four different architectures have been used with 4, 6, 8, and 10 qubits per core, starting with 2 cores and increasing them until a total number of 100 qubits is reached. As shown in Figures~\ref{fig:sub5} and~\ref{fig:sub3},  non-local communications increase as more cores are added. Moreover, on architectures with fewer qubits per core, a higher number of non-local communications is observed due to higher constraints to find a valid assignment. The execution time in relation to the total number of qubits is similar for  all four cases since, as mentioned before, the most crucial parameter concerning execution time is the total number of physical qubits and not how they are distributed. 