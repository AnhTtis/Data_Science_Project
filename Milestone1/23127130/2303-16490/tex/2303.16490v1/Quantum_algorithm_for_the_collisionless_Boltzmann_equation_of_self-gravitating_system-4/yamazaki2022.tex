\documentclass[a4paper,twocolumn,11pt,unpublished]{quantumarticle}
\pdfoutput=1
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}

\usepackage[numbers]{natbib}

\usepackage{graphicx}
\usepackage[hang,small,bf]{caption}
\usepackage[subrefformat=parens]{subcaption}
\captionsetup{compatibility=false}

\usepackage{physics}
\usepackage{here}
\usepackage{comment}
\usepackage{color}

\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\mybv}{\boldsymbol{v}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\dx}{\Delta x}
\newcommand{\mydv}{\Delta v}
\newcommand{\dt}{\Delta t}

%=========== Delete this when you submit ===========
\newcommand{\KF}[1]{{\color{red} #1}}
%===================================================

\begin{document}


\title{Quantum algorithm for collisionless Boltzmann simulation of self-gravitating systems}

\author{Soichiro Yamazaki}
\affiliation{Department of Physics, The University of Tokyo, 7-3-1 Hongo, Bunkyo, Tokyo 113-0033, Japan}
\orcid{0009-0001-2710-186X}

\author{Fumio Uchida}
\affiliation{Department of Physics, The University of Tokyo, 7-3-1 Hongo, Bunkyo, Tokyo 113-0033, Japan}
\affiliation{Research Center for the Early Universe (RESCEU), School of Science, The University of Tokyo, 7-3-1 Hongo, Bunkyo, Tokyo 113-0033, Japan}
\orcid{0000-0002-7527-5100}

\author{Kotaro Fujisawa}
\affiliation{Department of Liberal Arts, Tokyo University of Technology, 5-23-22 Kamata, Ota, Tokyo 144-8535, Japan}
\affiliation{Research Center for the Early Universe (RESCEU), School of Science, The University of Tokyo, 7-3-1 Hongo, Bunkyo, Tokyo 113-0033, Japan}
\orcid{0000-0002-9072-4744}

\author{Naoki Yoshida}
\affiliation{Department of Physics, The University of Tokyo, 7-3-1 Hongo, Bunkyo, Tokyo 113-0033, Japan}
\affiliation{Kavli Institute for the Physics and Mathematics of the Universe (WPI), UT Institutes for Advanced Study, The University of Tokyo, Kashiwa, Chiba 277-8583, Japan}
\orcid{0000-0001-7925-238X}

\begin{abstract}
The collisionless Boltzmann equation (CBE) is a fundamental equation that governs the dynamics of a broad range of astrophysical systems from space plasma to star clusters and galaxies.
It is computationally expensive to integrate the CBE directly in a phase space, and thus the applications to realistic astrophysical problems have been limited so far.
Recently, Todorova \& Steijl (2020) proposed an efficient quantum algorithm for solving the CBE with a significantly reduced computational complexity.
We extend the method to perform quantum simulations that follow the evolution of self-gravitating systems.
We first run a 1+1 dimensional test calculation of free streaming motion on 64Ã—64 grids using 13 simulated qubits and validate our method. 
We then perform simulations of Jeans collapse, and compare the result with analytic and linear theory calculations.
We propose a direct method to generate initial conditions as well as a method to retrieve necessary information from a register of multiple qubits.
Our simulation scheme achieves $\mathcal{O}(N_v^3)$ less computational complexity than the classical method, where $N_v$ is the number of discrete velocity grids per dimension.
It will thus allow us to perform large-scale CBE simulations on future quantum computers. 
\end{abstract}

\keywords{Quantum computing -- Collisionless Boltzmann equation}

\maketitle

\section{Introduction}
 A wide variety of numerical simulations are performed in astrophysics to study the formation of galaxies, clusters of galaxies, and the large-scale structure of the universe. Often particle-based $N$-body methods are employed to follow the gravitational dynamics. 
Although there exist well-known problems such as artificial two-body relaxation and shot noise in discrete $N$-body simulations, the particle-based method has been a practical choice since it is computationally less expensive than numerical integration of the collisionless Boltzmann equation (CBE).
A critical problem with direct Boltzmann simulations 
is the large dimension of the phase space to be considered; a simulation with full three spatial dimensions requires integration of CBE in a six-dimensional phase space. Such applications of CBE solvers have been limited so far even on
supercomputers that are capable of more than $10^{15}$ calculations per second \citep{2013ApJ...762..116Y}.

Quantum computation may hold promise in performing
numerical simulations with large dimensions.
Recently, a novel, efficient scheme for solving the CBE on a quantum computer was proposed \citep{2020JCoPh.40909347T}.
It is based on a quantum version of the so-called reservoir method for simulations of hyperbolic systems. Its successful applications include both classical and quantum simulations of hyperbolic systems with conservation laws \citep{Alouges08,Fillion19}.
Ref.~\citep{2020JCoPh.40909347T} performs quantum simulations of
free-molecular flows and flows under a homogeneous force field. It would be highly interesting if the 
quantum computation can also be applied to self-gravitating systems.
Here, we propose an efficient algorithm that can also treat a variable force field. We also propose novel methods for generating initial quantum states and for retrieving information from intermediate and final results of a simulation.
With these implementations, we perform a set of test calculations and validate our numerical scheme.

The rest of the paper is organized as follows.
We introduce our computational scheme in Sec.~\ref{sec2}, and then explain our methods to generate initial quantum states and to retrieve information from qubit arrays in Sec.~\ref{sec3}.
We then discuss the computational complexity of the algorithm in Sec.~\ref{sec4}, and finally show the results of simulations of self-gravitating systems in Sec.~\ref{sec5}.


\section{\label{computationalscheme} Computational Scheme}
\label{sec2}
\subsection{Collisionless Boltzmann equation}
The Boltzmann equation is a kinetic equation 
that describes the behavior of a system with a large number of particles, and is written  
\begin{equation}
    \frac{\partial f}{\partial t} + \mybv \cdot \frac{\partial f}{\partial \bx} + \bF \cdot \frac{\partial f}{\partial \mybv} = C(f,f')
\end{equation}
where the right-hand side expresses the collision term. 
The velocity distribution function $f(\bx,\mybv,t)$ represents the fraction of
particles existing in a small phase space volume ${\rm d}\bx \,{\rm d}\mybv$. 
Throughout the present paper,
we consider the collisionless
systems with $C(f,f')=0$, which represent, for instance, self-gravitating stars and dark matter systems in astrophysics. 


\subsection{The reservoir method}
Let us consider a one-dimensional collisionless system. The governing equation is
\begin{equation}
    \frac{\partial f}{\partial t} + v \frac{\partial f}{\partial x} + F 
    \frac{\partial f}{\partial v} = 0.
\end{equation}
We consider operator splitting as
\begin{equation}
    \frac{\partial f}{\partial t} + v \frac{\partial f}{\partial x} = 0,
\end{equation}
\begin{equation}
    \frac{\partial f}{\partial t} + F \frac{\partial f}{\partial v} = 0,
\end{equation}
which can then be discretized in time $\dt_n$ and in phase space $\dx \times \mydv$
using upwind differencing:
\begin{equation}
    f_{k;j}^{n+1} = f_{k;j}^{n} - v_k\frac{\dt_n}{\dx}
    \begin{cases}
        f_{k;j}^{n} - f_{k;j-1}^{n} & (v_k > 0) \\
        f_{k;j+1}^{n} - f_{k;j}^{n} & (v_k < 0)
    \end{cases}
\end{equation}
\begin{equation}
    f_{k;j}^{n+1} = f_{k;j}^{n} - F_j\frac{\dt_n}{\mydv}
    \begin{cases}
        f_{k;j}^{n} - f_{k-1;j}^{n} & (F_j > 0) \\
        f_{k+1;j}^{n} - f_{k;j}^{n} & (F_j < 0)
    \end{cases}
\end{equation}
where $f_{k;j}^{n}$ abbreviates $f(t_n, x_j, v_k)$
with
\begin{equation}
    t_n = \sum_{i=0}^{n-1}\dt_i, \,\,\,x_j = j\dx, \,\,\,\,v_k = k\mydv.
\end{equation}
The reservoir method \citep{Alouges08} utilizes variables $C_k, D_j$ called CFL counters to 
set the time when $f_{k;j}$ is updated.
The CFL counters are initialized to 0 in the beginning, and then 
updated over $\dt_n$ as
\begin{equation}
    C_k \leftarrow C_k + v_k\frac{\dt_n}{\dx}
\end{equation}
\begin{equation}
    D_j \leftarrow D_j + F_j\frac{\dt_n}{\mydv},
\end{equation}
where $\dt_n$ is chosen such that $|C_k|$ and $|D_j|$ do not exceed unity, 
to satisfy the CFL criteria. 
The time-stepping proceeds such that $f_{k;j}$ is updated to $f_{k;j\mp1}$ when $C_k = \pm1$, and when $D_j = \pm1$, $f_{k;j}$ is updated to $f_{k\mp1;j}$. After each update, we reset the CFL counters whose absolute values are 1. This is the essence of the reservoir method.

We note that there is manifestly no dissipation in this method in the sense that the value of $f_{k;j}$ does {\it not} vary over time, but it is simply advected in phase space. This feature makes the application of the reservoir method to quantum computing as an excellent choice.

\section{Quantum Algorithm}
\label{sec3}
There are three critical steps to perform quantum Boltzmann simulation using the reservoir method: \\
     (1) generating initial conditions in the form of quantum states,
     (2) updating $f_{k;j}$ through a sequence of quantum gate operations,
    and 
     (3) retrieving information from the resulting quantum states.
We first consider a simple case
in which the force $F$ exerted on the system is independent of $f$. 
We also assume periodic boundary conditions.

\subsection{Initialization}
\label{init}
Suppose that a phase space volume in 1+1 dimension 
is divided into $2^{n_x}\times 2^{n_v}$ grids. 
With a small number of ancilla qubits, a total of $n_x+n_v+a$ qubits are 
needed to represent the velocity distribution function
by quantum states and to manipulate them.
There are a variety of ways to represent $f_{k;j}$ by a quantum state
\begin{equation}
    | q_{x_0}, q_{x_1}, \cdots, q_{x_{n_x-1}} | q_{v_0}, q_{v_1}, \cdots, q_{v_{n_v-1}} | q_a \rangle.
\end{equation}
We propose five different manners (see Appendix for details). Here we focus on a particular method based on quantum Fourier transform. 
In the following, we redefine $x_j=j$ and $v_k=(2k+1)\frac{V}{2^{n_v}}-V$, where $V$ is the maximum velocity assumed in our simulations.

\begin{figure}[htbp]
        \includegraphics[width=6cm]{label2.png}
        \caption{A quantum circuit that embeds an array of labels into quantum phases. The bottom line corresponds with an ancilla qubit initialized to $\ket{0}$.}
        \label{labeling}
\end{figure}
      
\begin{figure*}[htbp]
            \begin{minipage}[b]{0.45\linewidth}
                \centering
                \includegraphics[width=8cm]{speed_sei.png}
                \subcaption{$D_j > 0$}
                \label{speed>}
            \end{minipage}
            \begin{minipage}[b]{0.45\linewidth}
                \centering
                \includegraphics[width=8cm]{speed_fu.png}
                \subcaption{$D_j < 0$}
                \label{speed<}
            \end{minipage}
            \caption{Quantum circuits for advection in velocity space.
             A quantum register assigned to the space (velocity) coordinate is denoted by $\ket{q_x}$ ($\ket{q_v}$).
            The component $MX(j)$ is an array of $X$ gates that controls the qubits using Toffoli gates only when $\ket{q_x} = \ket{j}$.
            Details of the basic gate operations are explained in Appendix \ref{quantum_gates}.}
\end{figure*}
        
\begin{figure*}[htbp]
            \begin{minipage}[b]{0.45\linewidth}
                \centering
                \includegraphics[width=8cm]{space_sei.png}
                \subcaption{$v_k > 0$}
                \label{space>}
            \end{minipage}
            \begin{minipage}[b]{0.45\linewidth}
                \centering
                \includegraphics[width=8cm]{space_fu.png}
                \subcaption{$v_k < 0$}
                \label{space<}
            \end{minipage}
            \caption{Quantum circuits for advection in configuration space.
            }
\end{figure*}
        
    The key idea is to assign $f_{k;j}$ to quantum states by labeling or indexing.
    Let us consider a bijective mapping $\mathcal{M} : \mathbb{Z}/2^{n_x}\mathbb{Z} \times \mathbb{Z}/2^{n_v}\mathbb{Z} \rightarrow \mathbb{Z}/2^{n_x+n_v}\mathbb{Z}$ such that $\mathcal{M}((j,k)) = 2^{n_v}j+k$.
    We label each element in phase-space by $\mathcal{M}$, and embed the label, instead of the value of $f_{k;j}$, into the phase of a quantum state using quantum Fourier transform (QFT):
    \begin{align}
        &\mbox{QFT} \cdot \left(I^{n_x+n_v-1}\otimes CX_{a_0, v_{n_v-1}}\right) \ket{0^{n_x+n_v+1}} \notag\\
            =& \frac{1}{\sqrt{2}^{n_x+n_v+1}}\sum_{j=0}^{2^{n_x+n_v}-1}\ket{j}\otimes\left(\exp\left[\frac{2\pi ij}{2^{n_x+n_v}}\right]\ket{1} + \ket{0}\right) \notag \\.
    \end{align}
    The corresponding quantum circuit is depicted in Fig.~\ref{labeling}.
    The ancilla qubit is added to the quantum state in order to estimate the labels by the process of quantum state tomography (Sec.~\ref{section:extraction}).
    The ``proxy'' of $f_{k;j}$ can be embedded into the quantum state in this manner.
    This is well suited to our reservoir method which preserves the values of $f_{k;j}$. The advection operation simply transfers 
    $f_{k;j}$ in 
    phase-space without changing the value itself, and thus it is sufficient
    to transfer the initial {\it label} of the discretized velocity distribution function. At the end of a simulation, one can retrieve the actual value of $f_{k;j}$ by the $\mathcal{M}^{-1}$
    mapping.
  
    Other methods for initialization are introduced in Appendix \ref{iqs},
and the relevant elements of quantum gates are explained in Appendix \ref{quantum_gates}.


\subsection{Updating $f_{k;j}$}
From the definition of $v_k$, the time when $C_k = \pm 1$ can be calculated from $i/{|v_k|}$ for all $i = 1, 2, \dots$. We fix the time steps to
\begin{equation}
    \begin{split}
        \{t_i\}_{i=0,1,2,\dots} &= \mbox{sorted sequence of} \\ &\left\{\frac{i}{\vert v_k\vert}~\middle|~i=0,1,2,\dots,~~k=0,1,\dots,2^{n_v}-1\right\}
    \end{split}
\end{equation}
so that the simulation proceeds in this order by counting and resetting $D_j$ in the manner explained in the next section.

At each time step, we first perform advection in velocity space, followed by advection in the configuration space.


\subsubsection{Advection in velocity space}
        
We first update the CFL counter $D_j$ as
        \begin{equation}
            D_j \leftarrow D_j + F_j\frac{\dt_n}{\mydv}.
        \end{equation}
        If $D_j > 0$, we use a quantum circuit in Fig.~\ref{speed>} for $\lfloor D_j\rfloor$ times, and then we reset $D_j$ as
        \begin{equation}
            D_j \leftarrow D_j - \lfloor D_j\rfloor.
        \end{equation}
        
        Otherwise, we use a quantum circuit in Fig.~\ref{speed<} for $\lceil D_j\rceil$ times, and reset $D_j$ as
        \begin{equation}
            D_j \leftarrow D_j - \lceil D_j\rceil.
        \end{equation}
        Here, $\lfloor \cdot \rfloor$ is a floor function that returns the largest integer less than or equal to the input number, and $\lceil \cdot \rceil$ is a ceiling function that returns the smallest integer more than or equal to the input number.
        
        The circuit of Fig.~\ref{speed>} effectively performs an increment to the index of the velocity coordinate at the position of spacial coordinate index $j$.
        This operation corresponds to advection in velocity space over precisely one grid.

\subsubsection{Advection in configuration space}
We perform the advection operation only for grids with the velocity index $k$ such that $t_iv_k\in \mathbb{Z}$.
        If $v_k > 0$, a quantum circuit in Fig.~\ref{space>} is used, and otherwise the one in Fig.~\ref{space<} is used.
The above sequence of operations complete the quantum version of the reservoir method in phase space.

\subsection{Information extraction} \label{section:extraction}
After the advection operations, the resulting ``solution'' would be the quantum state of the following form
\begin{equation}
    \frac{1}{\sqrt{2}^{n_x+n_v+1}}\sum_{j=0}^{2^{n_x+n_v}-1}\ket{j}\otimes\left(\exp\left[\frac{2\pi i\sigma(j)}{2^{n_x+n_v}}\right]\ket{1} + \ket{0}\right),
\end{equation}
where $\sigma$ is an element of a symmetry group, $\sigma \in \mathfrak{S}_{2^{n_x+n_v}}$.
We can extract the labels $\sigma$ by a combination of quantum state tomography \citep{10.5555/1972505} and eigendecomposition.
Eigendecomposition is used to get the resulting quantum state $\ket{\Psi}$ from a density matrix $\rho$ obtained from the quantum state tomography:
\begin{equation}
    \rho = \ket{\Psi}\bra{\Psi}.
\end{equation}
Then we obtain the value of $f_{k;j}$ by associating the labels with $f_{\mathcal{M}^{-1}(\sigma)}$.


\subsection{Systems with variable forces}
\label{sec:variable}
For general self-gravitating systems, 
we need to calculate the gravitational force field $F$
at every time step.
If on a classical computer, a straightforward way would be
to solve Poisson equation
\begin{equation}
\nabla^2 \phi = 4 \pi G \rho (x)
\end{equation}
from the density field 
\begin{equation}
\rho(x) = \int f(x,v) \,{\rm d}v,
\end{equation}
and then calculate the force as the spacial derivative of potential $\phi$. 
On a quantum computer, integration or even simple summation is a non-trivial task.
We do not implement a quantum Poisson solver in our simulations in the present paper, but
propose an efficient way to compute the mass density $\rho$ as a sum of the velocity distribution function. In Appendix \ref{iqs}, we describe a particular method
 to compute the sum of $f_{k;j}$ by operating H gates. Once the density field as a sum of $f_{k;j}$ is calculated, the gravitational potential (and hence the force) field can be derived by solving Poisson equation. There are several promising quantum Poisson solvers proposed recently
\citep{Cao13,Wang20,Childs21,2021PhRvA.104e2409S,Leong22}. Combining with such an efficient quantum solver will
enable a fully consistent quantum simulation,
and we will enjoy advantages such as single measurement error and very low computational complexity.

In practice, for the simulations we present in the next section, we solve Poisson equation classically as in Ref.~\citep{2013ApJ...762..116Y} and use the values of $F$ in the quantum advection operation in velocity space.

\section{\label{computationalcomplexity} Computational complexity}
\label{sec4}
We first discuss the time complexity of our numerical algorithm. 
A system's characteristic time is $T=1/\mbox{min}(|v_k|)$. 
This is a basis for the analysis of time complexity.
The Toffoli gates are assumed to be executed with the complexity of $\mathcal{O}(1)$ in this section, and also $N_v$ in Eq.~\eqref{eq:resolution} is assumed for the simulation to work.
Advection in velocity space is executed $\mathcal{O}(L^dF_sT/\mydv) = \mathcal{O}(L^dN_v)$ times every system time $T$, 
where $d$ denotes the spatial dimension we consider, $L$ denotes the size of the computational domain, and $F_s$ is a characteristic magnitude of $F$.
Advection in configuration space takes place $\mathcal{O}(dN_v^2)$ times every system time $T$. 
Because the number of $X$ and Toffoli gates in the quantum circuit for both advection is $\mathcal{O}(n_x+n_v)$, it costs $\mathcal{O}((n_x+n_v)N_v(L^d + dN_v))$ per system time $T$ considering all of the above while classical reservoir method costs $\mathcal{O}(dN_v^{d+1}L^d)$ \citep{2020JCoPh.40909347T}.

We assume here that we perform the advection calculations using a quantum computer whereas the gravity calculation is done by using a classical computer (Sec.~\ref{sec:variable}).
Namely, we take a hybrid approach.
The overall accuracy of the solution will not
be affected significantly if we calculate $F$ every advection or every $1/\max(|v_k|)$, and thus we assume that the calculation of $F$ is done every $1/\max(|v_k|)$.
It costs $\mathcal{O}(L^d \log L)$ for calculation of $F$, which does not change the time complexity.
Note the significant decrease in dimension of $O(N_v^3)$ compared to the classical calculation in three dimension.
If measurement is to be performed every time step in order
to get data of $f_{k;j}$ at an intermediate step, it would then be necessary to reproduce the state as the initial condition for continuation, which can add to the time complexity. 
In the future, this increase in time complexity can be avoided if quantum computers capable of parallel computing are available.

The number of required qubits without ancilla qubits is $n_x + n_v$, and that of ancilla qubits is $\mathcal{O}(n_x + n_v)$.
In a classical computer, however, we need to hold $\mathcal{O}(L^3)$ CFL counters $D_j$.
Therefore, space complexity amounts a total of $\mathcal{O}(L^3 + n_v)$.

\section{Numerical Simulations}
\label{sec5}
We have implemented the algorithm described so far using qiskit version 0.23.6 \footnote{{https://qiskit.org}} and QASM Simulator backend in aer, which are open-source software development kit with quantum computers and its simulator.
We have performed the following test calculations \citep{2013ApJ...762..116Y} using Python version 3.8.6 because simulations on currently available quantum computers are still expensive.


\subsection{Free Streaming}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=8cm]{adv_figs.png}
    \caption{
    Snapshots of the one-dimensional free-streaming simulation with $F=0$ and $n_x=n_v=6$. From left to right, the distribution function $f$ at $t=0, 1, 2$, and $3$ cycles are shown. A white "box" at $t=0$ flows without deformation other than shearing in phase space.}
    \label{adv_figs}
\end{figure}
We set $F=0$, $n_x=n_v=6$, and configure a ``box'' initial condition for $f$ as shown in Fig.~\ref{adv_figs}, where the white region has $f=1$ and black region $f=0$.
The exact solution should be simple free streaming in phase space, and $f$ is advected over time to produce
shear motion.
The reservoir method does not allow deformation other than shearing, which we confirm with our numerical result.

\subsection{\label{jeansinstability} Jeans instability}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=9cm]{adv_figs2.png}
    \caption{
    One-dimensional Jeans collapse with $n_x=n_v=6$ and with $A=0.1$, $k = 0.5 k_\text{J}$.
    The values of $f$ at $t=0, 1, 2,$ and $3$ are shown
    (see the colorbar on the right).
    }
    \label{adv_figs2}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=8cm]{A2_plot.png}
    \caption{
    The time evolution of the Fourier amplitude 
    $A_2$ of the density fluctuations in the run with  $k/k_\text{J}=0.5$.
    We compare with the linear growth rate.
    }
    \label{a2_plot}
\end{figure}

Our next example is one-dimensional gravitational instability.
The force field $F$ is the fluid's self-gravity.
For a homogeneous mass distribution, there exists a stationary solution, i.e., the Maxwell distribution
\begin{equation}
    f_\mathrm{M}(x,v) = \frac{\rho_\mathrm{ref}}{\sqrt{2\pi \sigma^2}}\exp\left(-\frac{v^2}{2\sigma^2}\right).
\end{equation}
We add a perturbation of
\begin{equation}
    \label{bis}
    f(x,v) = f_\mathrm{M}(x,v)(1 + A\cos k x)
\end{equation}
with $A=0.1, k=0.5k_{\text J}$ where the Jeans wavenumber is given by
\begin{equation}
    k_\mathrm{J}=\frac{\sqrt{4\pi G\rho_{\mathrm{ref}}}}{\sigma}.
\end{equation}
Fig.~\ref{adv_figs2} shows the outputs of our simulation. The phase-space structure is followed accurately up to $t=2$ with the relatively low resolution with
$n_x=n_v=6$, compared to the result of the high-accuracy classical
simulation of Ref.~\citep{2013ApJ...762..116Y} (see their Figure 6 on $128\times 128$ grids). 
At $t=3$, the distribution appears noisy, and
the spiral structure commonly seen in high-resolution
simulations is not well reproduced. This is likely
owing to the coarse resolution of our simulation.

\begin{figure*}[htbp]
    \begin{minipage}[b]{0.45\linewidth}
        \centering
        \includegraphics[width=8cm]{A2_6_6_15.png}
        \subcaption{$n_v=6$}
        \label{a2_6_6_15}
    \end{minipage}
    \begin{minipage}[b]{0.45\linewidth}
        \centering
        \includegraphics[width=8cm]{A2_6_11_15.png}
        \subcaption{$n_v=11$}
        \label{a2_6_11_15}
    \end{minipage}
    \caption{
    Comparison with an analytical solution of Fourier transform $A_2$ of the density fluctuation with $k/k_{\text J}=1.5$.
    Left figure shows the result of $n_v=6$ and right one shows the result of $n_v=11$.
    Only $n_v=11$ allows us to simulate $A_2$ with the same growth rate as the analytical solution.
    }
\end{figure*}
From the initial condition Eq.~\eqref{bis}, we can calculate the analytical solution for linear growth part of Fourier transform $A_m$ of $\delta(x,t)=\rho(x,t)-\rho_\mathrm{ref}$ \citep{2008gady.book.....B},
which is defined as
\begin{equation}
    \delta (x,t) = \sum_{m \geq 0}A_m(t)\exp(i m\frac{2\pi}{2^{n_x}}x).
\end{equation}
The linear growth rate $\gamma$ is obtained by solving the plasma dispersion relation 
\begin{align}
        (k/k_{\text J})^2 =& 1 + w Z(w), \nonumber \\
         w =& \frac{\pm i\gamma}{\sqrt{8\pi G\rho}\,(k/k_{\text J})}, \nonumber \\
        Z(w) =& \frac{1}{\sqrt{\pi}}\int_{-\infty}^{\infty} {\rm d}s\frac{e^{-s^2}}{s-w}. 
\end{align}
Fig.~\ref{a2_plot} shows that the growth of the perturbation is reproduced as predicted by linear theory. We thus conclude that our numerical scheme is well suited to follow the evolution of
one-dimensional self-gravitating systems.

\section{Discussion}
\label{sec6}
We have developed a quantum algorithm based on the reservoir method to solve the collisionless Boltzmann equation on a quantum computer.
We have successfully performed simulations of self-gravitating systems.

We discuss here the limitation of our numerical simulation. 
With the current implementation, the number of discrete grids in velocity space is $N_v=2^{n_v}$.
The corresponding time step width $\dt_c$ necessary for update is, at each space point,
\begin{equation}
    \dt_c = \frac{\dx}{\max (|v_k|)} = \frac{N_v \dx}{V(N_v-1)},
\end{equation}
whereas the reservoir method requires
\begin{equation}
    F_s \frac{\dt_c}{\mydv} = \mathcal{O}(1),
\end{equation}
where $F_s$ is a characteristic magnitude of $F$
and $\mydv = 2V/N_v$.
If this condition is not met, the advection operation in velocity space does not take place for a sufficiently large number of times,  
leading to inaccurate evolution of the velocity
distribution function.
This effectively imposes a requirement on the velocity space resolution of
\begin{equation}
    N_v = \mathcal{O}\left(\frac{V^2}{F_s\dx}\right).
    \label{eq:resolution}
\end{equation}
To examine the effect of insufficient resolution, we have performed simulations of gravitational Landau damping \citep{2008gady.book.....B} with $k = 1.5 k_{\text J}$ for two setups with $n_v = 6$ and $n_v = 11$. The other conditions are kept the same as in Sec.~\ref{jeansinstability}.
We plot the measured Fourier amplitude of $A_2$ and the damping rate in Fig.~\ref{a2_6_6_15} and \ref{a2_6_11_15}. 
Clearly, the run with poor resolution with $n_v = 6$ yields too rapid damping and spurious oscillations, whereas the run with $n_v = 11$ reproduces the correct initial damping as predicted by linear theory. We find that Eq.~\eqref{eq:resolution} serves as a practical
condition to be checked and monitored through a simulation.

We have proposed a method that utilizes two separate CFL counters for advection in configuration space and in velocity space in an operator-splitting manner (Sec.~\ref{computationalscheme}). 
It allows us to
perform simulations with a variable force field
under the condition and limitation as discussed in the above.
With the small computational complexity as derived in Sec.~\ref{computationalcomplexity}, future quantum computing has the potential to 
perform very large collisionless Boltzmann simulations. In our future work, we study applications to 
general Vlasov--Poisson systems including electro-static and electro-magnetic plasma.

\begin{acknowledgments}
    SY and FU acknowledge financial support from the Forefront Physics and Mathematics Program to Drive Transformation (FoPM).
\end{acknowledgments}







\bibliographystyle{quantum}
\bibliography{yamazaki2022}{}




        
\begin{figure*}[htbp]
            \centering
            \includegraphics[width=18cm]{phase2.png}
            \caption{Quantum circuit for embedding $f_{k;j}$ in the phase.}
            \label{phase}
\end{figure*}




\appendix
\begin{comment}
\section{Quantum bits}
A quantum bit (qubit for short) is a quantum version of the classical binary bit.
A qubit is represented by a sum of two orthonormal bases $\ket{0}$ and $\ket{1}$.
With $n$ qubits, a pure quantum state can be expressed as
\begin{equation}
    \ket{\psi} = \sum_{i=0}^{2^n-1}c_i\ket{i},
\end{equation}
where the amplitudes $c_i$ are complex numbers 
and satisfy
\begin{equation}
    \sum_{i=0}^{2^n-1}|c_i|^2 = 1,
\end{equation}
and 
\begin{equation}
    \ket{i} = \bigotimes_{j=0}^{n-1}\ket{i_j},
\end{equation}
where $i_0i_1\cdots i_{n-1}$ is the binary expression of $i$.

\end{comment}

\section{Quantum gates}
\label{quantum_gates}
\begin{comment}

A quantum computer controls a register of 
multiple qubits through a sequence of quantum gates.
By writing a qubit as a vector
\begin{equation}
    c_0\ket{0}+c_1\ket{1} =
    \begin{pmatrix}
    c_0 \\
    c_1
    \end{pmatrix},
\end{equation}
we can express a quantum gate as a unitary matrix 
\begin{equation}
    c_{00}\ket{0}\bra{0} + c_{01}\ket{0}\bra{1} + c_{10}\ket{1}\bra{0} + c_{11}\ket{1}\bra{1} =
    \begin{pmatrix}
    c_{00} & c_{01} \\
    c_{10} & c_{11}
    \end{pmatrix}.
\end{equation}

Let us introduce four basic single qubit gates:
\begin{equation}
    X = 
    \begin{pmatrix}
    0 & 1 \\
    1 & 0
    \end{pmatrix}
\end{equation}
\begin{equation}
    H = \frac{1}{\sqrt{2}}
    \begin{pmatrix}
    1 & 1 \\
    1 & -1
    \end{pmatrix}
\end{equation}
\begin{equation}
    R_y (\theta) = 
    \begin{pmatrix}
    \cos{\left(\frac{\theta}{2}\right)} & -\sin{\left(\frac{\theta}{2}\right)} \\[3pt]
    \sin{\left(\frac{\theta}{2}\right)} & \cos{\left(\frac{\theta}{2}\right)}
    \end{pmatrix}
\end{equation}
\begin{equation}
    R_z (\theta) = 
    \begin{pmatrix}
    e^{-i\frac{\theta}{2}} & 0 \\
    0 & e^{i\frac{\theta}{2}}
    \end{pmatrix}.
\end{equation}

\end{comment}



An $n$-qubits gate $MX(N)$, where $0\leq N \leq 2^{n}-1$, is defined by a set of $X$-gates as
\begin{equation}
    MX(N) = \bigotimes_{i=0}^{n-1}X^{1-N_i},
\end{equation}
where $N_i$ is the $(n-i)$-th digit of the binary expression of $N$.

A single qubit gate $R(n, i)$ is defined by $R_y$ as
\begin{equation}
    R(n, i) = R_y(2\lambda (n, i)),
\end{equation}
where
\begin{equation}\hspace{-1mm}
    \lambda(n, i) = \arccos \left( \sqrt{ \frac{ \sum\limits_{j=0}^{2^{n_x+n_v-n-1}-1} f_{j+i*2^{n_x+n_v-n}} }{ \sum\limits_{j=0}^{2^{n_x+n_v-n}-1} f_{j+i*2^{n_x+n_v-n}}}} \right)
\end{equation}
with a convention that labels an index by the mapping ${\cal M}^{-1}$
\begin{equation}
f_l = f_{\left(l ~ \mathrm{mod} ~ 2^{n_v}\right);\lfloor l/2^{n_v} \rfloor}.
\end{equation}
   



\begin{figure*}[htbp]
            \centering
            \includegraphics[width=18cm]{coef.png}
            \caption{Quantum circuit for putting $f_{k;j}$ in the coefficient magnitude.}
            \label{coef}
\end{figure*}

\section{Initialization and information extraction}
\label{iqs}
We have proposed an initialization method in Sec.~\ref{init}.
Generating an arbitrary quantum state itself is a hard problem, but there are several possible manners to initialize a quantum state, and here we consider four different methods. The first one utilizes the phase of a quantum state.
        The value of $f_{k;j}$ can be embedded in the phase of a quantum state as
        \begin{widetext}
            \begin{equation}
                \frac{1}{\sqrt{2}^{n_x+n_v+1}}\sum_{j=0}^{2^{n_x}-1}\sum_{k=0}^{2^{n_v}-1}\ket{j}\otimes\ket{k}\otimes\left(\ket{0}+\exp\left[i\frac{f_{k;j}}{M_p}\pi\right]\ket{1}\right),
                \label{eq:A_phase}
            \end{equation}
        \end{widetext}
        where $M_p$ is a real number greater than or equal to the maximum of $f_{k;j}$.
        This quantum state can be realized using the quantum circuit shown in Fig.~\ref{phase}.
        At the end of a numerical simulation, the values of $f_{k;j}$ in the form of Eq.~\eqref{eq:A_phase} can be retrieved by a combination of quantum state tomography and eigendecomposition.
            
    The second method assigns 
        $f_{k;j}$ as coefficients of the quantum state as
        \begin{equation}
            \frac{1}{\sqrt{M_1}}\sum_{j=0}^{2^{n_x}-1}\sum_{k=0}^{2^{n_v}-1}\sqrt{f_{k;j}}\ket{j}\otimes\ket{k},
            \label{eq:coeff1}
        \end{equation}
        where $M_1$ is the sum of $f_{k;j}$ over all $k$ and $j$. Ref.~\citep{2002quant.ph..8112G} proposes an efficient algorithm to generate a realization of a designated probability distribution. 
        The corresponding quantum state can be generated using the quantum circuit in Fig.~\ref{coef}. 
        The final solution of a simulation can be obtained by considering the velocity distribution function as a probability $P_{k;j}$ on the grid $(x_j, v_k)$:
        \begin{equation}
            f_{k;j} = M_1 P_{k;j}.
            \label{eq:f_prob}
        \end{equation}
            Obviously estimating the probability requires repeated measurements for a number of realizations. 
     
        As yet another approach,
        the values of $f_{k;j}$ can be assigned as the amplitudes of a quantum state as
        \begin{equation}
            \frac{1}{\sqrt{M_2}}\sum_{j=0}^{2^{n_x}-1}\sum_{k=0}^{2^{n_v}-1}f_{k;j}\ket{j}\otimes\ket{k},
            \label{eq:coeff2}   
        \end{equation}
        where $M_2$ is a sum of $f_{k;j}^2$ over all $k$ and $j$.
        This quantum state can be realized using the quantum circuit similar to Fig.~\ref{coef}.
        We can retrieve the final distribution function 
        $f_{k;j} = \sqrt{M_2P_{k;j}}$ as a probability distribution similarly 
        to the description in the above.
        
    The fourth method is to represent
        $f_{k;j}$ in an approximate manner by using
        ancilla qubits as
        \begin{equation}
            \frac{1}{\sqrt{2^{n_x+n_v}}}\sum_{j=0}^{2^{n_x}-1}\sum_{k=0}^{2^{n_v}-1}\ket{j}\otimes\ket{k}\otimes\ket{\tilde{f}_{k;j}},
        \end{equation}
        where $\tilde{f}_{k;j}$ is the integer part of $f_{k;j}$ multiplied by a (large) constant.
        This quantum state can be easily realized by Toffoli gates.
        By repeating measurement, we can collect $\tilde{f}_{k;j}$.
        Dividing $\tilde{f}$ by the same constant, we finally get the values of $f_{k;j}$.

For collisionless Boltzmann simulations of 
self-gravitating systems, one needs to calculate the integral of the distribution function 
\begin{equation}
\rho(x) = \int f(x,v) \,{\rm d}v.
\end{equation}
The density field $\rho (x)$ is used to
calculate the gravitational force field $F(x)$ via Poisson equation. 
To this end, an efficient method of calculating $\rho(x)$ is needed.
We propose two ways to achieve this.
If we adopt the representation of Eq.~\eqref{eq:coeff1}, we obtain
\begin{equation}
     \rho_j = \mydv M_1 P_j,  
\end{equation}
where $P_j = \sum_{k} P_{k,j}$ (Eq.~[\ref{eq:f_prob}]).
Alternatively, if we adopt the representation of Eq.~\eqref{eq:coeff2}, we operate H gates to the quantum state $\ket{\psi}$ after the advection operation as
        \begin{align}
            &\left(I^{\otimes n_x} \otimes H^{\otimes n_v}\right)\ket{\psi} \nonumber \\
            &= \frac{1}{\sqrt{M_2}}\sum_{j=0}^{2^{n_x}-1}\sum_{k=0}^{2^{n_v}-1}\sum_{l=0}^{2^{n_v}-1}f_{k;j}\frac{(-1)^{k\cdot l}}{\sqrt{2}^{n_v}}\ket{j}\otimes\ket{l} \nonumber \\
            &= \frac{1}{\sqrt{2^{n_v}M_2}}\sum_{j=0}^{2^{n_x}-1}\sum_{l=0}^{2^{n_v}-1}\left(\sum_{k=0}^{2^{n_v}-1}(-1)^{k\cdot l}f_{k;j}\right)\ket{j}\otimes\ket{l},
            \label{q21}
        \end{align}
        where $\cdot$ denotes bitwise AND.
        This state holds $\rho_j$ for $l=0$.
        Note that the probability of the state $l=0$ being realized upon measurement is generally higher than other $l$s because $f_{k;j}\geq 0$ ; the coefficients tend to cancel each other unless $l=0$.

\end{document}