
\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles.
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\usepackage{todonotes}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Amortized Analysis via Coinduction} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Harrison Grodin}{Computer Science Department, Carnegie Mellon University, United States \and \url{https://www.harrisongrodin.com}}{hgrodin@cs.cmu.edu}{https://orcid.org/0000-0002-0947-3520}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Robert Harper}{Computer Science Department, Carnegie Mellon University, United States \and \url{https://www.cs.cmu.edu/~rwh/}}{rwh@cs.cmu.edu}{https://orcid.org/0000-0002-9400-2941}{}

\authorrunning{H. Grodin and R. Harper} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Harrison Grodin and Robert Harper} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

% LTeX: enabled=false

\begin{CCSXML}
  <ccs2012>
     <concept>
         <concept_id>10003752.10003790.10011740</concept_id>
         <concept_desc>Theory of computation~Type theory</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10003790.10002990</concept_id>
         <concept_desc>Theory of computation~Logic and verification</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
         <concept_desc>Software and its engineering~Functional languages</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10010124.10010131.10010137</concept_id>
         <concept_desc>Theory of computation~Categorical semantics</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10010124.10010138</concept_id>
         <concept_desc>Theory of computation~Program reasoning</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
   </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Software and its engineering~Functional languages}
\ccsdesc[300]{Theory of computation~Program reasoning}
\ccsdesc[300]{Theory of computation~Categorical semantics}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

% LTeX: enabled=true

\keywords{amortized analysis, coinduction, data structure, mechanized proof} %TODO mandatory; please add comma-separated list of keywords

\category{Early Ideas} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{}
\supplementdetails[subcategory={Source Code}, cite={niu-sterling-grodin-harper>calf}, swhid={}]{Software}{github.com/jonsterling/agda-calf}

\funding{This material is based upon work supported by the United States Air Force Office of Scientific Research under grant number FA9550-21-0009 (Tristan Nguyen, program manager) and the National Science Foundation under grant number CCF-1901381. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the AFOSR or NSF.}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{We are grateful to Yue Niu for many insightful discussions about this research.}%optional

\nolinenumbers %uncomment to disable line numbering

% LTeX: enabled=false


%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Paolo Baldan and Valeria de Paiva}
\EventNoEds{2}
\EventLongTitle{10th Conference on Algebra and Coalgebra in Computer Science (CALCO 2023)}
\EventShortTitle{CALCO 2023}
\EventAcronym{CALCO}
\EventYear{2023}
\EventDate{June 19--21, 2023}
\EventLocation{Indiana University Bloomington, IN, USA}
\EventLogo{}
\SeriesVolume{270}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\calf}{\textbf{calf}}
\newcommand{\Set}{\mathbf{Set}}

\usepackage{colonequals}
\usepackage{bbm}
\usepackage{relsize}
\usepackage{mathpartir}
\usepackage{mathtools}

\NewDocumentCommand{\kw}{m}{\mathsf{#1}}
\NewDocumentCommand{\lab}{m}{\mathsf{#1}}
\newcommand{\code}[1]{\lstinline{#1}}


\definecolor{OrangeRed}{RGB}{237,19,90}
\definecolor{Cerulean}{RGB}{0,162,227}
\NewDocumentCommand{\POSITIVE}{m}{{\color{OrangeRed}{#1}}}
\NewDocumentCommand{\NEGATIVE}{m}{{\color{Cerulean}{#1}}}
% \NewDocumentCommand{\NEGATIVE}{m}{{\color{Cerulean}{\underline{#1}}}}
% \NewDocumentCommand{\POSITIVE}{m}{#1}
% \NewDocumentCommand{\NEGATIVE}{m}{#1}

\DeclarePairedDelimiter{\tuple}{\langle}{\rangle}
\newcommand{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\NewDocumentCommand{\T}{s o}{\POSITIVE{\kw{T}}{\IfBooleanT#1{\POSITIVE{(}}}{\IfValueT{#2}{#2}}{\IfBooleanT#1{\POSITIVE{)}}}}

\NewDocumentCommand{\tyU}{s m}{\POSITIVE{\kw{U}\IfBooleanT#1{\POSITIVE{(}}\NEGATIVE{#2}\IfBooleanT#1{\POSITIVE{)}}}}
\NewDocumentCommand{\tyUnitP}{}{\POSITIVE{1}}
\NewDocumentCommand{\tyProdP}{m m}{\POSITIVE{{#1} \times {#2}}}
\NewDocumentCommand{\tyVoid}{}{\POSITIVE{0}}
\NewDocumentCommand{\tySum}{m m}{\POSITIVE{{#1} + {#2}}}
\NewDocumentCommand{\tyInd}{m m}{\POSITIVE{\mu{#1}.\ {#2}}}
\NewDocumentCommand{\tyNat}{}{\POSITIVE{\mathbb{N}}}
\NewDocumentCommand{\tyConP}{m m}{\POSITIVE{\kw{#1}({#2})}}
\NewDocumentCommand{\tyList}{m}{\tyConP{list}{#1}}

\NewDocumentCommand{\expUnitP}{}{\tuple{}}
\NewDocumentCommand{\expProdP}{m m}{\tuple{{#1}, {#2}}}
\NewDocumentCommand{\expSome}{m}{\kw{some}({#1})}
\NewDocumentCommand{\expNone}{}{\kw{none}}

\NewDocumentCommand{\tyF}{s m}{\NEGATIVE{\kw{F}\IfBooleanT#1{\NEGATIVE{(}}\POSITIVE{#2}\IfBooleanT#1{\NEGATIVE{)}}}}
\NewDocumentCommand{\tyUnitN}{}{\NEGATIVE{1}}
\NewDocumentCommand{\tyProdN}{m m}{\NEGATIVE{{#1} \times {#2}}}
\NewDocumentCommand{\tyMixedProd}{m m}{\NEGATIVE{\POSITIVE{#1} \ltimes {#2}}}
\NewDocumentCommand{\tyMixedDSum}{m m m}{\NEGATIVE{\Sigma^{+-}\ (}{#2 : \POSITIVE{#1}}\NEGATIVE{).\ }{#3}}
\NewDocumentCommand{\tyArr}{m m}{\NEGATIVE{\POSITIVE{#1} \to {#2}}}
\NewDocumentCommand{\tyCoi}{m m}{\NEGATIVE{\nu{#1}.\ {#2}}}
\NewDocumentCommand{\CofreeComonad}{o}{\NEGATIVE{D}\IfValueT{#1}{_{\NEGATIVE{#1}}}}
\NewDocumentCommand{\tyConN}{m m}{\NEGATIVE{\kw{#1}({#2})}}
\NewDocumentCommand{\tyQueue}{m}{\tyConN{queue}{#1}}

\NewDocumentCommand{\expF}{m}{\kw{ret}({#1})}
\NewDocumentCommand{\expBind}{m m m}{{#2} \leftarrow {#1};\ {#3}}
\NewDocumentCommand{\expUnitN}{}{\tuple{}}
\NewDocumentCommand{\expProdN}{m m}{\tuple{{#1}, {#2}}}
\NewDocumentCommand{\expProj}{m}{\kw{proj}_{#1}}
\NewDocumentCommand{\expMixedProd}{m m}{\tuple{{#1}, {#2}}}
\NewDocumentCommand{\expArr}{m m}{\lambda {#1}.\ {#2}}
\NewDocumentCommand{\expCoi}{m m m}{\kw{gen}({#1}.\ {#2};\ {#3})}

\NewDocumentCommand{\Step}{o m m}{\kw{step}\IfValueT{#1}{_{\NEGATIVE{#1}}}^{#2}({#3})}

\lstdefinelanguage{agda}{
  morekeywords={%
    tp,
    F, U,
    ret, bind, step,
    record, coinductive, field
  }
}

\lstset{language=agda,
literate=%
{Π}{{$\Pi$}}1
{→}{{$\to$}}1
{λ}{{$\lambda$}}1
{Σ}{{$\Sigma$}}1
{×}{{$\times$}}1
{⁺}{{$^+$}}1
{⁻}{{$^-$}}1
{₁}{{$_1$}}1
{₂}{{$_2$}}1
{ʳ}{{$^r$}}1
{∷}{{$\coloncolon$}}1
{≡}{{$\equiv$}}1
{⟨}{{$\langle$}}1
{⟩}{{$\rangle$}}1
{˘}{{$\breve{}$}}1
{∎}{{$\blacksquare$}}1
{≡}{{$\approx$}}1
{ℂ}{{$\mathbb{C}$}}1
{Φ}{{$\Phi$}}1
{ψ}{{$\psi$}}1
{++}{{$\mdoubleplus$}}1
{⋉}{{$\ltimes$}}1
}


% LTeX: enabled=true

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Amortized analysis is a program cost analysis technique for data structures in which the cost of operations is specified in aggregate, under the assumption of continued sequential use.
Typically, amortized analyses are presented inductively, in terms of finite sequences of operations.
We give an alternative coinductive formulation and prove that it is equivalent to the standard inductive definition.
We describe a classic amortized data structure, the batched queue, and outline a coinductive proof of its amortized efficiency in \calf{}, a type theory for cost analysis.
\end{abstract}


\section{Introduction}

The \calf{} framework is a dependent type theory that supports verification of both correctness conditions and cost bounds~\cite{niu-sterling-grodin-harper>2022}, based on call-by-push-value~\cite{levy>thesis,pedrot-tabareau>2019}.
Amortized analysis is a cost analysis technique for data structures in which the operation costs are specified in aggregate, under the assumption of continued sequential use~\cite{tarjan>1985}.
In this work we demonstrate how amortized analysis can be understood as coalgebraic in \calf{}.

In call-by-push-value there are two sorts of types: value types $\POSITIVE{A}, \POSITIVE{B}, \POSITIVE{C}$ and computation types $\NEGATIVE{X}, \NEGATIVE{Y}, \NEGATIVE{Z}$.
The type $\tyF{A}$ is a computation type classifying computations that result in a value of type $\POSITIVE{A}$, and the type $\tyU{X}$ is a value type classifying suspended computations of type $\NEGATIVE{X}$.
Computation types beyond simply $\tyF{A}$ will be essential for amortized analysis; in particular, we will make extensive use of products $\tyProdN{X}{Y}$, functions $\tyArr{A}{X}$, and coinductive types $\tyCoi{X}{Y(X)}$ \cite{balan-kurz>2010}, all of which are computation types.

Semantically, we will interpret value types in $\Set$ and computation types in category of $\mathbb{C}$-sets, where $\mathbb{C}$ is a monoid representing cost, as is standard for cost analysis of functional programs~\cite{danielsson>2008,danner-licata-ramyaa>2015,kavvos-morehouse-licata-danner>2019,cutler-licata-danner>2020}.
This is a simplification of \calf{}, avoiding modalities.
As in \calf{}, we provide a primitive effect $\Step{c}{-}$ that incurs $c$ units of abstract cost, interpreted using the $\mathbb{C}$-action.
The $\mathbb{C}$-action associated to a computation type justifies equations describing how steps are incorporated into its elements:
\begin{align*}
  \Step[\tyProdN{X}{Y}]{c}{\expProdN{x}{y}} &= \expProdN{\Step[X]{c}{x}}{\Step[Y]{c}{y}} \\
  \Step[\tyArr{A}{X}]{c}{\expArr{a}{x}} &= \expArr{a}{\Step[X]{c}{x}} \\
  \Step[\tyCoi{X}{Y(X)}]{c}{\expCoi{a}{y}{a_0}} &= \expCoi{a}{\Step[Y(\tyCoi{X}{Y(X)})]{c}{y}}{a_0}
\end{align*}
Cost at a product or function type is incurred pointwise, and cost at a coinductive type is propagated forward.

In \calf{}~\cite{niu-sterling-grodin-harper>2022}, we have another computation type: the \emph{mixed dependent sum}, written $\tyMixedDSum{A}{a}{\NEGATIVE{X}a}$.
Here, we will use a non-dependent instance of this type, the \emph{mixed product}:
\[ \tyMixedProd{A}{X} \triangleq \tyMixedDSum{A}{-}{\NEGATIVE{X}} \]
The $\mathbb{C}$-action justifies the following equation:
\begin{align*}
  \Step[\tyMixedProd{A}{X}]{c}{\expMixedProd{a}{x}} &= \expMixedProd{a}{\Step[X]{c}{x}}
\end{align*}
Cost is pushed into the second component.
Note as a special case that $\tyMixedProd{\tyUnitP{}}{X} \cong \NEGATIVE{X}$.
\begin{remark}
  The mixed product is not available in an arbitrary model of call-by-push-value.
  Semantically, it must freely extract the $\POSITIVE{A}$ component and transfer any effects into the $\NEGATIVE{X}$ component only, which is only possible for a limited range of effects.
\end{remark}


\section{Cofree Comonads for Amortized Abstract Data Types}\label{sec:cofree-comonad-adt}

Throughout this paper, we will use queues as a running example of an abstract data type, although the development generalizes to other sequential-use abstract data types.
Queues are an abstract type representing an ordered collection with a first-in-first-out data policy.
Let value type $\POSITIVE{E}$ be the type of elements; the queue operations can be written as follows:
\begin{align*}
  \lab{enqueue}[e] &\sim \tyUnitP{} \\
  \lab{dequeue} &\sim \tySum{E}{\tyUnitP{}}
\end{align*}
This signature describes an operation $\lab{enqueue}[e]$ for each $e : \POSITIVE{E}$ and an operation $\lab{dequeue}$.

In a non-polarized type theory, a machine offering these operations is given via the following cofree comonad~\cite{jacobs>1995,power-shkaravska>2004,plotkin-power>2008} on $\Set{}$:
{\renewcommand{\POSITIVE}[1]{#1}\renewcommand{\NEGATIVE}[1]{#1}
\[ \tyQueue{X} \triangleq \tyCoi{Q}{\tyProdN{(\lab{quit} : \NEGATIVE{X})}{\tyProdN{(\lab{enqueue} : \tyArr{E}{Q})}{(\lab{dequeue} : \tyProdP{(\tySum{E}{\tyUnitP})}{Q})}}} \]
}
Up to isomorphism, each operation corresponds to a product of its output type and $Q$, using a function for an $E$-wide product.
In a polarized type theory, though, this is not immediately sensible: the product of a value type $\tySum{E}{\tyUnitP{}}$ and a computation type $\NEGATIVE{Q}$ cannot be formed.
There are multiple ways to return a value of type $\tySum{E}{\tyUnitP{}}$ along with a computation of type $\NEGATIVE{Q}$, each of which interacts differently with the cost effect.
Two reasonable options are:
\begin{enumerate}
  \item
    The type $\tyF*{\tyProdP{(\tySum{E}{\tyUnitP{}})}{\tyU{Q}}}$ causes each $\lab{dequeue}$ to be immediately costly, after which a result and a suspended remainder queue are available.
  \item
    The type $\tyMixedProd{(\tySum{E}{\tyUnitP{}})}{Q}$ propagates the cost of a $\lab{dequeue}$ into the remainder queue, allowing cost-free access to the returned $\tySum{E}{\tyUnitP{}}$.
    The type of queues built on this approach describes queues for which the cost of an operation is deferred until $\lab{quit}$ is executed.
\end{enumerate}
In other words, the second technique describes an \emph{amortized} abstract data type, where cost accumulates during a sequence of operations.
Thus, we define the type of amortized queues:
\[ \tyQueue{X} \triangleq \tyCoi{Q}{\tyProdN{(\lab{quit} : \NEGATIVE{X})}{\tyProdN{(\lab{enqueue} : \tyArr{E}{Q})}{(\lab{dequeue} : \tyMixedProd{(\tySum{E}{\tyUnitP})}{Q})}}} \]
The type $\tyQueue{X}$ can be understood as ``object-oriented''~\cite{cook>1991,jacobs>1996-objects-coalgebraically,cook>2009}, since the use of a queue involves a sequence of $\lab{enqueue}$ and $\lab{dequeue}$ projections terminated by a $\lab{quit}$.


\section{Coinductive Amortized Analysis}

Let $\mathbb{C} = (\mathbb{N}, +, 0)$.
Equipped with the definition of amortized queues $\tyQueue{X}$, we define two queue implementations and prove their amortized equivalence.
Here, we let $\NEGATIVE{X} = \tyF{\tyUnitP}$, requiring that the queues terminate with an element of $\tyF{\tyUnitP}$ (i.e., simply a cost in $\mathbb{C}$).

\begin{example}[Specification Queue]
\begin{lstlisting}[float,caption={Single-list specification implementation of a queue.},label=code:list-queue]
spec-queue : list E → queue (F unit)
quit    (spec-queue l) = ret triv
enqueue (spec-queue l) e = step 1 (spec-queue (l ++ [ e ]))
dequeue (spec-queue []) = ret (nothing , spec-queue [])
dequeue (spec-queue (e ∷ l)) = ret (just e , spec-queue l)
\end{lstlisting}

One simple implementation of a queue, called \code{spec-queue}, is given in \cref{code:list-queue} by coinduction using copattern matching~\cite{abel-pientka-thibodeau-setzer>2013}, using a single list as the underlying representation type.
The enqueue operation is annotated with one unit of cost; however, this is unrealistic, since a full traversal of the list is performed for each enqueue operation.
We will treat this implementation as a client-facing specification, next defining a queue that actually implements this cost model.
\lipicsEnd
\end{example}

\begin{example}[Batched Queue]
\begin{lstlisting}[float,caption={Amortized-efficient batched implementation of a queue.},label=code:batched-queue]
batched-queue : list E → list E → queue (F unit)
quit    (batched-queue bl fl) = step (Φ (bl , fl)) (ret triv)
enqueue (batched-queue bl fl) e = batched-queue (e ∷ bl) fl
dequeue (batched-queue bl []) with reverse bl
... | [] = ret (nothing , batched-queue [] [])
... | e ∷ fl = step (length bl) (ret (just e , batched-queue [] fl))
dequeue (batched-queue bl (e ∷ fl)) =
  ret (just e , batched-queue bl fl)
\end{lstlisting}
Now, we define an amortized-efficient implementation which only incurs one large cost infrequently~\cite{gries>1989,hood-melville>1981,burton>1982,okasaki>thesis}.
This underlying representation type of the implementation is two lists: the ``front list'', $\mathsf{fl}$, and the ``back list'', $\mathsf{bl}$.
Elements are enqueued to $\mathsf{bl}$ and dequeued from $\mathsf{fl}$; if $\mathsf{fl}$ is empty when attempting to dequeue, the current $\mathsf{bl}$ is reversed and used in place of $\mathsf{fl}$ going forward.
The \calf{} implementation, called \code{batched-queue}, is shown in \cref{code:batched-queue}.
The $\lab{quit}$ case uses a \emph{potential function} $\Phi(\mathsf{bl}, \mathsf{fl}) = \mathsf{length}(\mathsf{bl})$, as in the physicist's method of amortized analysis~\cite{tarjan>1985}, accounting for elements enqueued on $\mathsf{bl}$ that were never moved to $\mathsf{fl}$.
\lipicsEnd
\end{example}

The amortized analysis is proved via a bisimulation; the theorem statement is analogous to the traditional amortized analysis, using the potential function to accumulate payment~\cite{tarjan>1985}.
Every $\lab{enqueue}$ to \code{spec-queue} pushes one unit of cost forward, while \code{batched-queue} pushes $\mathsf{length}(\mathsf{bl})$ units of cost forward only on the occasional $\lab{dequeue}$, retroactively using its surplus potential from previous $\lab{enqueue}$ operations.

\begin{theorem}[Amortized Analysis of Batched Queue]
  For all lists $\mathsf{bl}$ and $\mathsf{fl}$,
  \[ \text{\normalfont\code{batched-queue}}\ \mathsf{bl}\ \mathsf{fl} = \Step{\Phi (\mathsf{bl} , \mathsf{fl})}{\text{\normalfont\code{spec-queue}}\ (\mathsf{fl} \mdoubleplus \mathsf{reverse}\ \mathsf{bl})}. \]
\end{theorem}
\begin{proof}
  By routine coinduction, propagating cost forward over computation types.
\end{proof}


\section{Relation to Inductive Amortized Analysis}

Amortized analysis is typically framed algebraically, describing the cost incurred by a finite sequence of operations.
In the preceding sections we observed that the analysis is naturally viewed as \emph{coalgebraic}.
In fact these perspectives are equivalent.
Define the free monad corresponding to the queue operation signature given in \cref{sec:cofree-comonad-adt}:
\[ \tyConP{program}{A} \triangleq \tyInd{P}{\tySum{(\lab{return} : A)}{\tySum{(\lab{enqueue} : \tyProdP{E}{P})}{(\lab{dequeue} : \tyU{(\tyArr{\tySum{E}{\tyUnitP}}{\tyF{P}})})}}} \]
An element of $\tyConP{program}{A}$ is a finite sequence of queue instructions terminated by returning a value of type $\POSITIVE{A}$.
We may evaluate a program on a queue, by induction on the program:
\[ \kw{eval} : \tyArr{\tyConP{program}{A}}{\tyArr{\tyU*{\tyQueue{X}}}{\tyMixedProd{A}{X}}} \]
\begin{lstlisting}[float,caption={Program evaluation at a queue.},label=code:evaluate-program]
eval : queue-program A → U (queue X) → A ⋉ X
eval (return a   ) q = a , Queue.quit q
eval (enqueue e p) q = eval p (Queue.enqueue q e)
eval (dequeue k  ) q =
  bind (k (proj₁ (Queue.dequeue q))) λ p →
  eval p (proj₂ (Queue.dequeue q))
\end{lstlisting}
This expresses the usual notion of running a sequence of operations on a data structure; the code is in \cref{code:evaluate-program}.
We note a resemblance to monad-comonad interaction laws~\cite{plotkin-power>2008,katsumata-rivas-uustalu>2020}, here adjusted for call-by-push-value.
Using $\kw{eval}$, we may define an alternative notion of queue equivalence.
Let $q_1, q_2 : \tyConN{queue}{X}$:
\begin{definition}[Sequence-of-Operations Queue Equivalence]
  Say $q_1 \approx q_2$ iff for all types $\POSITIVE{A}$ and programs $p : \tyConP{program}{A}$, it is the case that $\kw{eval} (p, q_1) = \kw{eval} (p, q_2)$.
\end{definition}
\begin{theorem}[Amortizing Sequences of Operations]
  It is the case that $q_1 = q_2$ iff $q_1 \approx q_2$.
\end{theorem}
\begin{proof}
  By routine $(\Rightarrow)$ induction and $(\Leftarrow)$ coinduction.
\end{proof}
Thus, coalgebraic amortized equivalence coincides with the traditional algebraic notion.
Unsurprisingly, a proof that $q_1 \approx q_2$ shares the same core reasoning as a proof that $q_1 = q_2$; however, it requires the auxiliary definitions of $\tyConP{program}{A}$ and $\kw{eval}$.


\section{Conclusion}

Here, we developed a computation type of amortized queues in \calf{} as the cofree comonad of a functor based on the product and mixed product type constructors, built to propagate cost forward for end-of-use accounting.
We defined specification and amortized queue implementations and stated a theorem relating them via the physicist's method of amortized analysis.
Finally, we observed that coinductive bisimulation coincides with traditional sequence-of-operations reasoning in amortized analysis.
Our results for queues and two other simple amortized data structures are formalized in \calf{}, which is embedded in Agda~\cite{niu-sterling-grodin-harper>calf}.

In future work we hope to characterize effects supporting the mixed product.
Additionally, we hope to better characterize the given constructions, accounting for the asymmetry present in call-by-push-value.
We also hope to extend this approach to support abstract data types with binary and parallel operations, infinite sequences of operations, and situations in which amortization is strictly bounded by the specification.


%%
%% Bibliography
%%

%% Please use bibtex,

\clearpage
\bibliography{amortized}

\end{document}
