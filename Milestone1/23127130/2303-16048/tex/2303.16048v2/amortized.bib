@article{abel-pientka-thibodeau-setzer>2013,
  title = {Copatterns: Programming Infinite Structures by Observations},
  shorttitle = {Copatterns},
  author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
  year = {2013},
  month = jan,
  journal = {ACM SIGPLAN Notices},
  volume = {48},
  number = {1},
  pages = {27--38},
  issn = {0362-1340},
  doi = {10.1145/2480359.2429075},
  urldate = {2023-06-06},
  abstract = {Inductive datatypes provide mechanisms to define finite data such as finite lists and trees via constructors and allow programmers to analyze and manipulate finite data via pattern matching. In this paper, we develop a dual approach for working with infinite data structures such as streams. Infinite data inhabits coinductive datatypes which denote greatest fixpoints. Unlike finite data which is defined by constructors we define infinite data by observations. Dual to pattern matching, a tool for analyzing finite data, we develop the concept of copattern matching, which allows us to synthesize infinite data. This leads to a symmetric language design where pattern matching on finite and infinite data can be mixed. We present a core language for programming with infinite structures by observations together with its operational semantics based on (co)pattern matching and describe coverage of copatterns. Our language naturally supports both call-by-name and call-by-value interpretations and can be seamlessly integrated into existing languages like Haskell and ML. We prove type soundness for our language and sketch how copatterns open new directions for solving problems in the interaction of coinductive and dependent types.}
}

@article{balan-kurz>2010,
  title = {On {{Coalgebras}} over {{Algebras}}},
  author = {Balan, Adriana and Kurz, Alexander},
  year = {2010},
  month = aug,
  journal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the {{Tenth Workshop}} on {{Coalgebraic Methods}} in {{Computer Science}} ({{CMCS}} 2010)},
  volume = {264},
  number = {2},
  pages = {47--62},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2010.07.013},
  urldate = {2023-05-15},
  abstract = {We extend Barr's well-known characterization of the final coalgebra of a Set-endofunctor as the completion of its initial algebra to the Eilenberg-Moore category of algebras for a Set-monad M for functors arising as liftings. As an application we introduce the notion of commuting pair of endofunctors with respect to the monad M and show that under reasonable assumptions, the final coalgebra of one of the endofunctors involved can be obtained as the free algebra generated by the initial algebra of the other endofunctor.},
  langid = {english}
}

@article{burton>1982,
  title = {An Efficient Functional Implementation of {{FIFO}} Queues},
  author = {Burton, F. Warren},
  year = {1982},
  month = jul,
  journal = {Information Processing Letters},
  volume = {14},
  number = {5},
  pages = {205--206},
  issn = {0020-0190},
  doi = {10.1016/0020-0190(82)90015-1},
  urldate = {2023-03-24},
  langid = {english}
}

@inproceedings{cook>1991,
  title = {Object-Oriented Programming versus Abstract Data Types},
  booktitle = {Foundations of {{Object-Oriented Languages}}},
  author = {Cook, William R.},
  editor = {{de Bakker}, J. W. and {de Roever}, W. P. and Rozenberg, G.},
  year = {1991},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {151--178},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/BFb0019443},
  abstract = {This tutorial collects and elaborates arguments for distinguishing between object-oriented programming and abstract data types. The basic distinction is that object-oriented programming achieves data abstraction by the use of procedural abstraction, while abstract data types depend upon type abstraction. Object-oriented programming and abstract data types can also be viewed as complimentary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.},
  isbn = {978-3-540-46450-1},
  langid = {english}
}

@inproceedings{cook>2009,
  title = {On Understanding Data Abstraction, Revisited},
  booktitle = {Proceedings of the 24th {{ACM SIGPLAN}} Conference on {{Object}} Oriented Programming Systems Languages and Applications},
  author = {Cook, William R.},
  year = {2009},
  month = oct,
  series = {{{OOPSLA}} '09},
  pages = {557--572},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1640089.1640133},
  urldate = {2023-01-26},
  abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
  isbn = {978-1-60558-766-0}
}

@article{cutler-licata-danner>2020,
  title = {Denotational Recurrence Extraction for Amortized Analysis},
  author = {Cutler, Joseph W. and Licata, Daniel R. and Danner, Norman},
  year = {2020},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {ICFP},
  pages = {97:1--97:29},
  doi = {10.1145/3408979},
  urldate = {2023-06-06},
  abstract = {A typical way of analyzing the time complexity of functional programs is to extract a recurrence expressing the running time of the program in terms of the size of its input, and then to solve the recurrence to obtain a big-O bound. For recurrence extraction to be compositional, it is also necessary to extract recurrences for the size of outputs of helper functions. Previous work has developed techniques for using logical relations to state a formal correctness theorem for a general recurrence extraction translation: a program is bounded by a recurrence when the operational cost is bounded by the extracted cost, and the output value is bounded, according to a value bounding relation defined by induction on types, by the extracted size. This previous work supports higher-order functions by viewing recurrences as programs in a lambda-calculus, or as mathematical entities in a denotational semantics thereof. In this paper, we extend these techniques to support amortized analysis, where costs are rearranged from one portion of a program to another to achieve more precise bounds. We give an intermediate language in which programs can be annotated according to the banker's method of amortized analysis; this language has an affine type system to ensure credits are not spent more than once. We give a recurrence extraction translation of this language into a recurrence language, a simply-typed lambda-calculus with a cost type, and state and prove a bounding logical relation expressing the correctness of this translation. The recurrence language has a denotational semantics in preorders, and we use this semantics to solve recurrences, e.g analyzing binary counters and splay trees.}
}

@article{danielsson>2008,
  title = {Lightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures},
  author = {Danielsson, Nils Anders},
  year = {2008},
  month = jan,
  journal = {ACM SIGPLAN Notices},
  volume = {43},
  number = {1},
  pages = {133--144},
  issn = {0362-1340},
  doi = {10.1145/1328897.1328457},
  urldate = {2023-06-06},
  abstract = {Okasaki and others have demonstrated how purely functional data structures that are efficient even in the presence of persistence can be constructed. To achieve good time bounds essential use is often made of laziness. The associated complexity analysis is frequently subtle, requiring careful attention to detail, and hence formalising it is valuable. This paper describes a simple library which can be used to make the analysis of a class of purely functional data structures and algorithms almost fully formal. The basic idea is to use the type system to annotate every function with the time required to compute its result. An annotated monad is used to combine time complexity annotations. The library has been used to analyse some existing data structures, for instance the deque operations of Hinze and Paterson's finger trees.}
}

@inproceedings{danner-licata-ramyaa>2015,
  title = {Denotational Cost Semantics for Functional Languages with Inductive Types},
  booktitle = {Proceedings of the 20th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Danner, Norman and Licata, Daniel R. and Ramyaa, Ramyaa},
  year = {2015},
  month = aug,
  series = {{{ICFP}} 2015},
  pages = {140--151},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2784731.2784749},
  urldate = {2023-03-18},
  abstract = {A central method for analyzing the asymptotic complexity of a functional program is to extract and then solve a recurrence that expresses evaluation cost in terms of input size. The relevant notion of input size is often specific to a datatype, with measures including the length of a list, the maximum element in a list, and the height of a tree. In this work, we give a formal account of the extraction of cost and size recurrences from higher-order functional programs over inductive datatypes. Our approach allows a wide range of programmer-specified notions of size, and ensures that the extracted recurrences correctly predict evaluation cost. To extract a recurrence from a program, we first make costs explicit by applying a monadic translation from the source language to a complexity language, and then abstract datatype values as sizes. Size abstraction can be done semantically, working in models of the complexity language, or syntactically, by adding rules to a preorder judgement. We give several different models of the complexity language, which support different notions of size. Additionally, we prove by a logical relations argument that recurrences extracted by this process are upper bounds for evaluation cost; the proof is entirely syntactic and therefore applies to all of the models we consider.},
  isbn = {978-1-4503-3669-7}
}

@book{gries>1989,
  title = {The {{Science}} of {{Programming}}},
  author = {Gries, David},
  year = {1989},
  month = apr,
  publisher = {{Springer New York}},
  abstract = {This is the very first book to discuss the theory and principles of computer programming on the basis of the idea that a proof of correctness and a program should be developed hand in hand. It is built around the method first proposed by Dijkstra in his monograph The Discipline of Programming (1976), involving a "calculus for the derivation of programs." Directing his materials to the computer programmer with at least one year of experience, Gries presents explicit principles behind program development, and then leads the reader through example programs using those principles. Propositions and predicate calculus are presented as a took for the programmer, rather than simply an object of study. The reader should come away with a fresh outlook on programming theory and practice, and the assurance to develop correct programs effectively.},
  isbn = {978-0-387-96480-5},
  langid = {english}
}

@article{hood-melville>1981,
  title = {Real-Time Queue Operations in Pure {{LISP}}},
  author = {Hood, Robert and Melville, Robert},
  year = {1981},
  month = nov,
  journal = {Information Processing Letters},
  volume = {13},
  number = {2},
  pages = {50--54},
  issn = {0020-0190},
  doi = {10.1016/0020-0190(81)90030-2},
  urldate = {2023-03-24},
  langid = {english}
}

@inproceedings{jacobs>1995,
  title = {Mongruences and Cofree Coalgebras},
  booktitle = {Algebraic {{Methodology}} and {{Software Technology}}},
  author = {Jacobs, Bart},
  editor = {Alagar, V. S. and Nivat, Maurice},
  year = {1995},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {245--260},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-60043-4_57},
  abstract = {A coalgebra is introduced here as a model of a certain signature consisting of a type X with various ``destructor'' function symbols, satisfying certain equations. These destructor function symbols are like methods and attributes in object-oriented programming: they provide access to the type (or state) X. We show that the category of such coalgebras and structure preserving functions is comonadic over sets. Therefore we introduce the notion of a `mongruence' (predicate) on a coalgebra. It plays the dual role of a congrence (relation) on an algebra.},
  isbn = {978-3-540-49410-2},
  langid = {english}
}

@incollection{jacobs>1996-objects-coalgebraically,
  title = {Objects {{And Classes}}, {{Co-Algebraically}}},
  booktitle = {Object {{Orientation}} with {{Parallelism}} and {{Persistence}}},
  author = {Jacobs, Bart},
  editor = {Freitag, Burkhard and Jones, Cliff B. and Lengauer, Christian and Schek, Hans-J{\"o}rg},
  year = {1996},
  series = {The {{Kluwer International Series}} in {{Engineering}} and {{Computer Science}}},
  pages = {83--103},
  publisher = {{Springer US}},
  address = {{Boston, MA}},
  doi = {10.1007/978-1-4613-1437-0_5},
  urldate = {2023-02-27},
  abstract = {The co-algebraic perspective on objects and classes in object-oriented programming is elaborated: classes are described as co-algebras, which may occur as models (implementations) of co-algebraic specifications. These specifications are much like deferred (or virtual) classes with assertions in Eiffel. An object belonging to a class is an element of the state space of the class, as co-algebra. We show how terminal co-algebras of co-algebraic specifications give rise to canonical models (in which all observationally indistinguishable objects are identified). We further describe operational semantics for objects, with an associated notion of bisimulation (for objects in classes modeling the same specification), expressing observational indistinguishability.},
  isbn = {978-1-4613-1437-0},
  langid = {english}
}

@inproceedings{katsumata-rivas-uustalu>2020,
  title = {Interaction {{Laws}} of {{Monads}} and {{Comonads}}},
  booktitle = {Proceedings of the 35th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Katsumata, Shin-ya and Rivas, Exequiel and Uustalu, Tarmo},
  year = {2020},
  month = jul,
  series = {{{LICS}} '20},
  pages = {604--618},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3373718.3394808},
  urldate = {2022-10-20},
  abstract = {We introduce and study functor-functor and monad-comonad interaction laws as mathematical objects to describe interaction of effectful computations with behaviors of effect-performing machines. Monad-comonad interaction laws are monoid objects of the monoidal category of functor-functor interaction laws. We show that, for suitable generalizations of the concepts of dual and Sweedler dual, the greatest functor resp. monad interacting with a given functor or comonad is its dual while the greatest comonad interacting with a given monad is its Sweedler dual. We relate monad-comonad interaction laws to stateful runners. We show that functor-functor interaction laws are Chu spaces over the category of endofunctors taken with the Day convolution monoidal structure. Hasegawa's glueing endows the category of these Chu spaces with a monoidal structure whose monoid objects are monad-comonad interaction laws.},
  isbn = {978-1-4503-7104-9}
}

@article{kavvos-morehouse-licata-danner>2019,
  title = {Recurrence Extraction for Functional Programs through Call-by-Push-Value},
  author = {Kavvos, G. A. and Morehouse, Edward and Licata, Daniel R. and Danner, Norman},
  year = {2019},
  month = dec,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {POPL},
  pages = {15:1--15:31},
  doi = {10.1145/3371083},
  urldate = {2022-12-06},
  abstract = {The main way of analysing the complexity of a program is that of extracting and solving a recurrence that expresses its running time in terms of the size of its input. We develop a method that automatically extracts such recurrences from the syntax of higher-order recursive functional programs. The resulting recurrences, which are programs in a call-by-name language with recursion, explicitly compute the running time in terms of the size of the input. In order to achieve this in a uniform way that covers both call-by-name and call-by-value evaluation strategies, we use Call-by-Push-Value (CBPV) as an intermediate language. Finally, we use domain theory to develop a denotational cost semantics for the resulting recurrences.}
}

@phdthesis{levy>thesis,
  title = {Call-{{By-Push-Value}}},
  author = {Levy, Paul Blain},
  year = {2001},
  abstract = {Call-by-push-value (CBPV) is a new programming language paradigm, based on the slogan ``a value is, a computation does''. We claim that CBPV provides the semantic primitives from which the call-by-value and call-by-name paradigms are built. The primary goal of the thesis is to present the evidence for this claim, which is found in a remarkably wide range of semantics: from operational semantics, in big-step form and in machine form, to denotational models using domains, possible worlds, continuations and games. In the first part ofthe thesis, we come to CBPV and its equational theory by looking critically at the call-by-value and call-by-name paradigms in the presence ofgeneral computational effects. We give a Felleisen/Friedman-style CK-machine semantics, which explains how CBPV can be understood in terms of push/pop instructions. In the second part we give simple CBPV models for printing, divergence, global store, errors, erratic choice and control effects, as well as for various combinations ofthese effects. We develop the store model into a possible world model for cell generation, and (following Steele) we develop the control model into a ``jumping implementation'' using a continuation language called Jump- With-Argument (JWA). We present a pointer game model for CBPV, in the style of Hyland and Ong. We see that the game concepts of questioning and answering correspond to the CBPV concepts of forcing and producing respectively. We observe that this game semantics is closely related to the jumping implementation. In the third part of the thesis, we study the categorical semantics for the CBPV equational theory. We present and compare 3 approaches: ? models using strong monads, in the style of Moggi; ? models using value/producer structures, in the style of Power and Robinson; ? models using (strong) adjunctions. All the concrete models in the thesis are seen to be adjunction models.},
  school = {University of London}
}

@article{niu-sterling-grodin-harper>2022,
  title = {A Cost-Aware Logical Framework},
  author = {Niu, Yue and Sterling, Jonathan and Grodin, Harrison and Harper, Robert},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  pages = {9:1--9:31},
  doi = {10.1145/3498670},
  urldate = {2022-09-04},
  abstract = {We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants. We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist's method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid's algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.},
  copyright = {All rights reserved}
}

@misc{niu-sterling-grodin-harper>calf,
  title = {{{{\textbf{calf}}}}: A {{Cost-Aware Logical Framework}}},
  shorttitle = {{{{\textbf{calf}}}}},
  author = {Niu, Yue and Sterling, Jon and Grodin, Harrison and Harper, Robert},
  url = {https://github.com/jonsterling/agda-calf},
  urldate = {2023-06-06},
  abstract = {A cost-aware logical framework, embedded in Agda.},
  copyright = {Apache-2.0}
}

@phdthesis{okasaki>thesis,
  title = {Purely {{Functional Data Structures}}},
  author = {Okasaki, Chris},
  year = {1996},
  volume = {1129},
  number = {September},
  issn = {16113349},
  doi = {10.1007/3-540-61628-4_5},
  isbn = {3540616284},
  school = {Carnegie Mellon University}
}

@article{pedrot-tabareau>2019,
  title = {The {{Fire Triangle}}: {{How}} to {{Mix Substitution}}, {{Dependent Elimination}}, and {{Effects}}},
  shorttitle = {The {{Fire Triangle}}},
  author = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  year = {2019},
  month = dec,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {POPL},
  pages = {58:1--58:28},
  doi = {10.1145/3371126},
  urldate = {2022-11-14},
  abstract = {There is a critical tension between substitution, dependent elimination and effects in type theory. In this paper, we crystallize this tension in the form of a no-go theorem that constitutes the fire triangle of type theory. To release this tension, we propose {$\partial$}CBPV, an extension of call-by-push-value (CBPV) \textemdash a general calculus of effects\textemdash to dependent types. Then, by extending to {$\partial$}CBPV the well-known decompositions of call-by-name and call-by-value into CBPV, we show why, in presence of effects, dependent elimination must be restricted in call-by-name, and substitution must be restricted in call-by-value. To justify {$\partial$}CBPV and show that it is general enough to interpret many kinds of effects, we define various effectful syntactic translations from {$\partial$}CBPV to Martin-L\"of type theory: the reader, weaning and forcing translations.}
}

@article{plotkin-power>2008,
  title = {Tensors of {{Comodels}} and {{Models}} for {{Operational Semantics}}},
  author = {Plotkin, Gordon and Power, John},
  year = {2008},
  month = oct,
  journal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the 24th {{Conference}} on the {{Mathematical Foundations}} of {{Programming Semantics}} ({{MFPS XXIV}})},
  volume = {218},
  pages = {295--311},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2008.10.018},
  urldate = {2022-10-11},
  abstract = {In seeking a unified study of computational effects, one must take account of the coalgebraic structure of state in order to give a general operational semantics agreeing with the standard one for state. Axiomatically, one needs a countable Lawvere theory L, a comodel C, typically the final one, and a model M, typically free; one then seeks a tensor C{$\otimes$}M of the comodel with the model that allows operations to flow between the two. We describe such a tensor implicit in the abstract category theoretic literature, explain its significance for computational effects, and calculate it in leading classes of examples, primarily involving state.},
  langid = {english}
}

@article{power-shkaravska>2004,
  title = {From {{Comodels}} to {{Coalgebras}}: {{State}} and {{Arrays}}},
  shorttitle = {From {{Comodels}} to {{Coalgebras}}},
  author = {Power, John and Shkaravska, Olha},
  year = {2004},
  month = dec,
  journal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the {{Workshop}} on {{Coalgebraic Methods}} in {{Computer Science}} ({{CMCS}})},
  volume = {106},
  pages = {297--314},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2004.02.041},
  urldate = {2023-06-06},
  abstract = {We investigate the notion of a comodel of a (countable) Lawvere theory, an evident dual to the notion of model. By taking the forgetful functor from the category of comodels to Set, every (countable) Lawvere theory generates a comonad on Set. But while Lawvere theories are equivalent to finitary monads on Set, and that result extends to higher cardinality, no such result holds for comonads, and that is not only for size reasons: it is primarily because, while Set is cartesian closed, Setop is not. So every monad with rank on Set generates a comonad on Set, but not conversely. Our leading example is given by the countable Lawvere theory for global state: its category of comodels is the category of arrays, yielding a precise relationship between global state and arrays. Restricting from arbitrary comonads to those comonads generated by Lawvere theories allows us to study new and interesting constructions, in particular that of tensor product.},
  langid = {english}
}

@article{sterling-harper>2021,
  title = {Logical {{Relations}} as {{Types}}: {{Proof-Relevant Parametricity}} for {{Program Modules}}},
  shorttitle = {Logical {{Relations}} as {{Types}}},
  author = {Sterling, Jonathan and Harper, Robert},
  year = {2021},
  month = oct,
  journal = {Journal of the ACM},
  volume = {68},
  number = {6},
  pages = {41:1--41:47},
  issn = {0004-5411},
  doi = {10.1145/3474834},
  urldate = {2023-03-21},
  abstract = {The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the phase distinction, computational effects, and type abstraction. We contribute a fresh ``synthetic'' take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a lax modality that encapsulates computational effects, placing projectibility of module expressions on a type-theoretic basis. Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a parametricity structure. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-relevant families, where there may be non-trivial evidence witnessing the relatedness of two programs\textemdash simplifying the metatheory of strong sums over the collection of types, for although there can be no ``relation classifying relations,'' one easily accommodates a ``family classifying small families.'' Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan logical relations as types, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic Artin gluing construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.}
}

@article{tarjan>1985,
  title = {Amortized {{Computational Complexity}}},
  author = {Tarjan, Robert Endre},
  year = {1985},
  month = apr,
  journal = {SIAM Journal on Algebraic Discrete Methods},
  volume = {6},
  number = {2},
  pages = {306--318},
  publisher = {{Society for Industrial and Applied Mathematics}},
  issn = {0196-5212},
  doi = {10.1137/0606031},
  urldate = {2023-03-21},
  abstract = {We analyse the amortized behavior of AVL-trees under sequences of insertions. We show that the total rebalancing cost (=balance changes) for a sequence of n arbitrary insertions is at most \$2.618n\$. For random insertions the bound is improved to \$2.26n\$. We also show that the probability that t or more balance changes are required decreases exponentially with t.}
}
