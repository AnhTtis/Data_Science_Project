
\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles.
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Amortized Analysis via Coinduction} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Harrison Grodin}{Computer Science Department, Carnegie Mellon University, United States \and \url{https://www.harrisongrodin.com}}{hgrodin@cs.cmu.edu}{https://orcid.org/0000-0002-0947-3520}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Robert Harper}{Computer Science Department, Carnegie Mellon University, United States \and \url{https://www.cs.cmu.edu/~rwh/}}{rwh@cs.cmu.edu}{https://orcid.org/0000-0002-9400-2941}{}

\authorrunning{H. Grodin and R. Harper} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Harrison Grodin and Robert Harper} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\begin{CCSXML}
  <ccs2012>
     <concept>
         <concept_id>10003752.10003790.10011740</concept_id>
         <concept_desc>Theory of computation~Type theory</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10003790.10002990</concept_id>
         <concept_desc>Theory of computation~Logic and verification</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
         <concept_desc>Software and its engineering~Functional languages</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10010124.10010131.10010137</concept_id>
         <concept_desc>Theory of computation~Categorical semantics</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
     <concept>
         <concept_id>10003752.10003790.10011119</concept_id>
         <concept_desc>Theory of computation~Abstraction</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
   </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Software and its engineering~Functional languages}
\ccsdesc[300]{Theory of computation~Categorical semantics}
\ccsdesc[300]{Theory of computation~Abstraction}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{amortized analysis, coinduction, data structure, mechanized proof} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

\funding{This material is based upon work supported by the United States Air Force Office of Scientific Research under grant number FA9550-21-0009 (Tristan Nguyen, program manager) and the National Science Foundation under grant number CCF-1901381. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the AFOSR or NSF.}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{We are grateful to Yue Niu for many insightful discussions about this research.}%optional

\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\calf}{\textbf{calf}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\step}[2]{\mathsf{step}^{#1}({#2})}
\newcommand{\code}[1]{\lstinline{#1}}
\newcommand{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}
\usepackage{colonequals}

\lstdefinelanguage{agda}{
  morekeywords={%
    tp,
    F, U,
    ret, bind, step,
    record, coinductive, field
  }
}

\lstset{language=agda,
literate=%
{Π}{{$\Pi$}}1
{→}{{$\to$}}1
{λ}{{$\lambda$}}1
{Σ}{{$\Sigma$}}1
{×}{{$\times$}}1
{⁺}{{$^+$}}1
{⁻}{{$^-$}}1
{₁}{{$_1$}}1
{₂}{{$_2$}}1
{ʳ}{{$_r$}}1
{∷}{{$\coloncolon$}}1
{≡}{{$\equiv$}}1
{⟨}{{$\langle$}}1
{⟩}{{$\rangle$}}1
{˘}{{$\breve{}$}}1
{∎}{{$\blacksquare$}}1
{≈}{{$\approx$}}1
{ℂ}{{$\mathbb{C}$}}1
{Φ}{{$\Phi$}}1
{ψ}{{$\psi$}}1
{++}{{$\mdoubleplus$}}1
}


\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Amortized analysis is a program cost analysis technique for data structures in which the cost of operations is specified in aggregate, under the assumption of continued sequential use.
Typically, amortized analyses are presented inductively, in terms of finite sequences of operations; we demonstrate that coinduction provides an equivalent but more natural characterization.
We describe a classic amortized data structure, the batched queue, and outline a coinductive proof of its amortized efficiency in \calf{}, a type theory for cost analysis.
\end{abstract}


\section[Program Cost Analysis in calf]{Program Cost Analysis in the \calf{} Framework}

The \calf{} framework is a dependent type theory that supports verification of both correctness conditions and cost bounds~\cite{niu-sterling-grodin-harper>2022}, based on dependent call-by-push-value~\cite{levy>thesis,pedrot-tabareau>2019}.
In \calf{}, the primitive effect $\step{c}{-}$ incurs $c$ units of abstract cost.
Value types are interpreted in $\Set$, and computation types are interpreted in the Eilenberg-Moore category $\Set^W$ of the writer monad on some cost monoid $\mathbb{C}$, $W = \mathbb{C} \times (-)$.


\section{Cofree Comonads for Abstract Data Types}

Queues are an abstract data type representing an ordered collection with a first-in-first-out data policy.
Let $E$ be the type of elements, and let $Q$ be the queue representation type; the destructor signature can be written as follows, using $F$ and $U$ of call-by-push-value:
\begin{align*}
  \mathsf{enqueue} &:^- Q \to (E \Rightarrow Q) \\
  \mathsf{dequeue} &:^- Q \to F((E + 1) \times UQ)
\end{align*}
We may thus find the corresponding cofree comonad~\cite{jacobs>1995} to be the following coinductive type:
\[ \mathsf{queue}_E \triangleq \nu Q.\ (\mathsf{quit} : F1) \times (\mathsf{enqueue} : E \Rightarrow Q) \times (\mathsf{dequeue} : F((E + 1) \times UQ)) \]
Here, we fix the comonad parameter to be $F1$, requiring that queues terminate with an element of $F1$ (i.e., a cost $\mathbb{C}$); a definition using \calf{}-inspired pseudocode is shown in \cref{code:queue}.
The type $\mathsf{queue}_E$ can be understood as ``object-oriented''~\cite{cook>1991,jacobs>1996-objects-coalgebraically,cook>2009}.
One simple implementation of a queue, called \code{QUEUE}, is given in \cref{code:list-queue} by coinduction, using a single list as the underlying representation type.
The enqueue operation is annotated with one unit of cost; however, this is unrealistic, since a full traversal of the list is performed for each enqueue operation.
We will use this implementation as a specification, later defining a queue whose implementation actually reflects this idealized cost model in a suitable sense.


\section{Amortized Analysis}

Amortized analysis is a cost analysis technique for data structures where the operation costs are specified in aggregate, under the assumption of sequential use of the data structure.~\cite{tarjan>1985}

\begin{example}
  As discussed, the single-list implementation of a queue is slow.
  Thus, we may wish to use a different implementation which only incurs one large cost infrequently; this approach will have low amortized cost, equivalent to the specification in \cref{code:list-queue}.~\cite{gries>1989,hood-melville>1981,burton>1982,okasaki>thesis}
  This underlying representation type of the ``batched'' implementation is two lists: the ``front list'', $\mathsf{fl}$, and the ``back list'', $\mathsf{bl}$.
  Elements are enqueued to $\mathsf{bl}$ and dequeued from $\mathsf{fl}$; if $\mathsf{fl}$ is empty when attempting to dequeue, the current $\mathsf{bl}$ is reversed and used in place of $\mathsf{fl}$ going forward.
  The \calf{} implementation, called \code{batched-queue}, is shown in \cref{code:batched-queue}.

  The cost specification for batched queues claims that an enqueue incurs one cost and a dequeue incurs zero cost, \emph{amortized}.
  To prove this, one may use a potential function $\Phi(\mathsf{bl}, \mathsf{fl}) = \mathsf{length}(\mathsf{bl})$ to track how much cost is ``owed'' for future dequeues.
  It remains to show that the cost of an operation is as stated, up to changes in $\Phi$.
  To make the cost align with the specification precisely, the potential $\Phi$ is explicitly spent in the \code{quit} method.
  \lipicsEnd
\end{example}

Amortized analysis is typically framed algebraically, describing the cost incurred after a finite sequence of operations.
% \begin{quotation}
%   In many uses of data structures, a sequence of operations, rather than just a single operation, is performed, and we are interested in the total time of the sequence, rather than in the times of the individual operations.~\cite{tarjan>1985}
% \end{quotation}
However, we take the perspective that the analysis is more naturally viewed as \emph{coalgebraic}.
We define a relation $\approx$ on $\mathsf{queue}_E$ relating queues with the same behavior and cost, up to amortization.
The relation, given in \cref{code:approx-queue}, is a relaxation of the standard bisimulation; the \code{dequeue} component allows cost to be deferred for amortization.
Eventually, the implementation must ``pay up'' to satisfy the \code{quit} requirement.

% \begin{lemma}
%   For all $c$, for all $q_1, q_2 : \mathsf{queue}_E$, if $q_1 \approx q_2$, then $\step{c}{q_1} \approx \step{c}{q_2}$.
% \end{lemma}
\begin{theorem}
  For all lists $\mathsf{bl}$ and $\mathsf{fl}$,
  $\text{\normalfont\code{batched-queue}}\ \mathsf{bl}\ \mathsf{fl} \approx \step{\Phi (\mathsf{bl} , \mathsf{fl})}{\text{\normalfont\code{QUEUE}}\ (\mathsf{fl} \mdoubleplus \mathsf{reverse}\ \mathsf{bl})}$.
\end{theorem}
The proof by coinduction is in \cref{code:amortized-analysis}, mirroring the usual argument via $\Phi$.
This technique can be elegantly related to the existing definition of amortized analysis, as well.
Define the free monad corresponding to the constructor signature dual to the presentation of queues:
\[ \mathsf{program}_E(A) \triangleq \mu P.\ (\mathsf{return} : A) + (\mathsf{enqueue} : P \times E) + (\mathsf{dequeue} : U((E + 1) \Rightarrow FP)) \]
An element of $\mathsf{program}_E(A)$ is a finite sequence of queue instructions terminated by returning a value of type $A$.
We may evaluate a program on a queue, by induction on the program:
\[ \psi :^- \mathsf{program}_E(A) \times U(\mathsf{queue}_E) \Rightarrow FA \]
This expresses the usual notion of running a sequence of operations on a data structure; the code is in \cref{code:evaluate-program}.
We note a similarity to monad-comonad interaction laws~\cite{katsumata-rivas-uustalu>2020}, here adjusted for call-by-push-value.

\begin{lemma}
  For all $c$, $p$, and $q$, it is the case that $\step{c}{\psi(p, q)} = \psi(p, \step{c}{q})$.
\end{lemma}
\begin{theorem}[Amortizing Sequences of Operations]
  Suppose $\mathbb{C}$ is commutative, and let $q_1, q_2 :^- \mathsf{queue}_E$.
  Then, $q_1 \approx q_2$ iff for all $A$ and $p :^+ \mathsf{program}_E(A)$, $\psi (p, q_1) = \psi (p, q_2)$.
\end{theorem}

Thus, the coalgebraic notion of amortized equivalence is equivalent to the classical algebraic notion.
In future work, we hope to generalize and more precisely characterize the given constructions, especially in the context of call-by-push-value.
We also hope to extend this approach to support abstract data types with binary and parallel operations.


%%
%% Bibliography
%%

%% Please use bibtex,

\bibliography{amortized}

\appendix

\clearpage
\section{Code Samples}

\begin{lstlisting}[caption={Specification of the queue abstract data type via coinduction.},label=code:queue]
record queue (E : tp⁺) : tp⁻ where
  coinductive
  field
    quit     :⁻ F unit
    enqueue  :⁻ E → queue E
    dequeue  :⁻ F (prod⁺ (maybe E) (U (queue E)))
\end{lstlisting}

\begin{lstlisting}[caption={Single-list specification implementation of a queue.},label=code:list-queue]
QUEUE :⁻ list E → queue E
quit    (QUEUE l) = ret triv
enqueue (QUEUE l) e = step 1 (QUEUE (l ++ [ e ]))
dequeue (QUEUE []) = ret (nothing , QUEUE [])
dequeue (QUEUE (e ∷ l)) = ret (just e , QUEUE l)
\end{lstlisting}

\begin{lstlisting}[caption={Amortized-efficient batched implementation of a queue.},label=code:batched-queue]
batched-queue :⁻ list E → list E → queue E
quit    (batched-queue bl fl) = step (Φ (bl , fl)) (ret triv)
enqueue (batched-queue bl fl) e = batched-queue (e ∷ bl) fl
dequeue (batched-queue bl []) with reverse bl
... | [] = ret (nothing , batched-queue [] [])
... | e ∷ fl = step (length bl) (ret (just e , batched-queue [] fl))
dequeue (batched-queue bl (e ∷ fl)) =
  ret (just e , batched-queue bl fl)
\end{lstlisting}

\begin{lstlisting}[caption={Coinductive queue amortized-equivalence relation.},label=code:approx-queue]
record _≈_ (q₁ q₂ :⁻ queue E) : tp⁻ where
  coinductive
  field
    quit     :⁻ queue.quit q₁ ≡ queue.quit q₂
    enqueue  :⁻ (e : E) queue.enqueue q₁ e ≈ queue.enqueue q₂ e
    dequeue  :⁻
      queue.dequeue q₁ ≡ step c₁ (ret (e₁ , q₁')) ×
      queue.dequeue q₂ ≡ step c₂ (ret (e₂ , q₂')) ×
      (e₁ ≡ e₂) × (step c₁ q₁' ≈ step c₂ q₂')
\end{lstlisting}

\begin{lstlisting}[caption={Coinductive amortized analysis of \code{batched-queue}.},label=code:amortized-analysis]
≈-cong :⁻ (c : ℂ) → q₁ ≈ q₂ → step c q₁ ≈ step c q₂

amortized-analysis :⁻ (bl fl : list E) →
  batched-queue bl fl ≈ step (Φ (bl , fl)) (QUEUE (fl ++ reverse bl))
_≈_.quit    (amortized-analysis bl fl) = refl
_≈_.enqueue (amortized-analysis bl fl) e =
  Eq.subst₂
    (λ c l → batched-queue (e ∷ bl) fl ≈ step c (QUEUE l))
    (Nat.+-comm 1 (length bl))
    (begin
      fl ++ reverse (e ∷ bl)
    ≡⟨ Eq.cong (fl ++_) (List.unfold-reverse e bl) ⟩
      fl ++ (reverse bl ++ [ e ])
    ≡˘⟨ List.++-assoc fl (reverse bl) [ e ] ⟩
      (fl ++ reverse bl) ++ [ e ]
    ∎)
    (amortized-analysis (e ∷ bl) fl)
_≈_.dequeue (amortized-analysis bl []) with reverse bl
... | [] = refl , amortized-analysis [] []
... | e ∷ fl =
  refl ,
  ≈-cong
    (length bl)
    ( Eq.subst
        (λ l → batched-queue [] fl ≈ QUEUE l)
        (List.++-identityʳ fl)
        (amortized-analysis [] fl)
    )
_≈_.dequeue (amortized-analysis bl (e ∷ fl)) =
  refl , amortized-analysis bl fl
\end{lstlisting}

\begin{lstlisting}[caption={Program evaluation at a queue.},label=code:evaluate-program]
ψ :⁻ program E A → U (queue E) → F A
ψ (return b   ) q = bind (quit q) λ _ → ret b
ψ (enqueue e p) q = ψ p (enqueue q e)
ψ (dequeue f  ) q =
  bind (dequeue q) λ (e , q') →
  bind (f e) λ p' →
  ψ p' q'
\end{lstlisting}

\end{document}
