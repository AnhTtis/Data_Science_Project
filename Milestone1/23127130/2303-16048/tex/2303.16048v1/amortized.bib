@article{burton>1982,
  title = {An Efficient Functional Implementation of {{FIFO}} Queues},
  author = {Burton, F. Warren},
  year = {1982},
  month = jul,
  journal = {Information Processing Letters},
  volume = {14},
  number = {5},
  pages = {205--206},
  issn = {0020-0190},
  doi = {10.1016/0020-0190(82)90015-1},
  urldate = {2023-03-24},
  langid = {english}
}

@inproceedings{cook>1991,
  title = {Object-Oriented Programming versus Abstract Data Types},
  booktitle = {Foundations of {{Object-Oriented Languages}}},
  author = {Cook, William R.},
  editor = {{de Bakker}, J. W. and {de Roever}, W. P. and Rozenberg, G.},
  year = {1991},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {151--178},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/BFb0019443},
  abstract = {This tutorial collects and elaborates arguments for distinguishing between object-oriented programming and abstract data types. The basic distinction is that object-oriented programming achieves data abstraction by the use of procedural abstraction, while abstract data types depend upon type abstraction. Object-oriented programming and abstract data types can also be viewed as complimentary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.},
  isbn = {978-3-540-46450-1},
  langid = {english}
}

@inproceedings{cook>2009,
  title = {On Understanding Data Abstraction, Revisited},
  booktitle = {Proceedings of the 24th {{ACM SIGPLAN}} Conference on {{Object}} Oriented Programming Systems Languages and Applications},
  author = {Cook, William R.},
  year = {2009},
  month = oct,
  series = {{{OOPSLA}} '09},
  pages = {557--572},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1640089.1640133},
  urldate = {2023-01-26},
  abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
  isbn = {978-1-60558-766-0}
}

@book{gries>1989,
  title = {The {{Science}} of {{Programming}}},
  author = {Gries, David},
  year = {1989},
  month = apr,
  publisher = {{Springer New York}},
  abstract = {This is the very first book to discuss the theory and principles of computer programming on the basis of the idea that a proof of correctness and a program should be developed hand in hand. It is built around the method first proposed by Dijkstra in his monograph The Discipline of Programming (1976), involving a "calculus for the derivation of programs." Directing his materials to the computer programmer with at least one year of experience, Gries presents explicit principles behind program development, and then leads the reader through example programs using those principles. Propositions and predicate calculus are presented as a took for the programmer, rather than simply an object of study. The reader should come away with a fresh outlook on programming theory and practice, and the assurance to develop correct programs effectively.},
  isbn = {978-0-387-96480-5},
  langid = {english}
}

@article{hood-melville>1981,
  title = {Real-Time Queue Operations in Pure {{LISP}}},
  author = {Hood, Robert and Melville, Robert},
  year = {1981},
  month = nov,
  journal = {Information Processing Letters},
  volume = {13},
  number = {2},
  pages = {50--54},
  issn = {0020-0190},
  doi = {10.1016/0020-0190(81)90030-2},
  urldate = {2023-03-24},
  langid = {english}
}

@inproceedings{jacobs>1995,
  title = {Mongruences and Cofree Coalgebras},
  booktitle = {Algebraic {{Methodology}} and {{Software Technology}}},
  author = {Jacobs, Bart},
  editor = {Alagar, V. S. and Nivat, Maurice},
  year = {1995},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {245--260},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-60043-4_57},
  abstract = {A coalgebra is introduced here as a model of a certain signature consisting of a type X with various ``destructor'' function symbols, satisfying certain equations. These destructor function symbols are like methods and attributes in object-oriented programming: they provide access to the type (or state) X. We show that the category of such coalgebras and structure preserving functions is comonadic over sets. Therefore we introduce the notion of a `mongruence' (predicate) on a coalgebra. It plays the dual role of a congrence (relation) on an algebra.},
  isbn = {978-3-540-49410-2},
  langid = {english}
}

@incollection{jacobs>1996-objects-coalgebraically,
  title = {Objects {{And Classes}}, {{Co-Algebraically}}},
  booktitle = {Object {{Orientation}} with {{Parallelism}} and {{Persistence}}},
  author = {Jacobs, Bart},
  editor = {Freitag, Burkhard and Jones, Cliff B. and Lengauer, Christian and Schek, Hans-J{\"o}rg},
  year = {1996},
  series = {The {{Kluwer International Series}} in {{Engineering}} and {{Computer Science}}},
  pages = {83--103},
  publisher = {{Springer US}},
  address = {{Boston, MA}},
  doi = {10.1007/978-1-4613-1437-0_5},
  urldate = {2023-02-27},
  abstract = {The co-algebraic perspective on objects and classes in object-oriented programming is elaborated: classes are described as co-algebras, which may occur as models (implementations) of co-algebraic specifications. These specifications are much like deferred (or virtual) classes with assertions in Eiffel. An object belonging to a class is an element of the state space of the class, as co-algebra. We show how terminal co-algebras of co-algebraic specifications give rise to canonical models (in which all observationally indistinguishable objects are identified). We further describe operational semantics for objects, with an associated notion of bisimulation (for objects in classes modeling the same specification), expressing observational indistinguishability.},
  isbn = {978-1-4613-1437-0},
  langid = {english}
}

@inproceedings{katsumata-rivas-uustalu>2020,
  title = {Interaction {{Laws}} of {{Monads}} and {{Comonads}}},
  booktitle = {Proceedings of the 35th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Katsumata, Shin-ya and Rivas, Exequiel and Uustalu, Tarmo},
  year = {2020},
  month = jul,
  series = {{{LICS}} '20},
  pages = {604--618},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3373718.3394808},
  urldate = {2022-10-20},
  abstract = {We introduce and study functor-functor and monad-comonad interaction laws as mathematical objects to describe interaction of effectful computations with behaviors of effect-performing machines. Monad-comonad interaction laws are monoid objects of the monoidal category of functor-functor interaction laws. We show that, for suitable generalizations of the concepts of dual and Sweedler dual, the greatest functor resp. monad interacting with a given functor or comonad is its dual while the greatest comonad interacting with a given monad is its Sweedler dual. We relate monad-comonad interaction laws to stateful runners. We show that functor-functor interaction laws are Chu spaces over the category of endofunctors taken with the Day convolution monoidal structure. Hasegawa's glueing endows the category of these Chu spaces with a monoidal structure whose monoid objects are monad-comonad interaction laws.},
  isbn = {978-1-4503-7104-9}
}

@phdthesis{levy>thesis,
  title = {Call-{{By-Push-Value}}},
  author = {Levy, Paul Blain},
  year = {2001},
  abstract = {Call-by-push-value (CBPV) is a new programming language paradigm, based on the slogan ``a value is, a computation does''. We claim that CBPV provides the semantic primitives from which the call-by-value and call-by-name paradigms are built. The primary goal of the thesis is to present the evidence for this claim, which is found in a remarkably wide range of semantics: from operational semantics, in big-step form and in machine form, to denotational models using domains, possible worlds, continuations and games. In the first part ofthe thesis, we come to CBPV and its equational theory by looking critically at the call-by-value and call-by-name paradigms in the presence ofgeneral computational effects. We give a Felleisen/Friedman-style CK-machine semantics, which explains how CBPV can be understood in terms of push/pop instructions. In the second part we give simple CBPV models for printing, divergence, global store, errors, erratic choice and control effects, as well as for various combinations ofthese effects. We develop the store model into a possible world model for cell generation, and (following Steele) we develop the control model into a ``jumping implementation'' using a continuation language called Jump- With-Argument (JWA). We present a pointer game model for CBPV, in the style of Hyland and Ong. We see that the game concepts of questioning and answering correspond to the CBPV concepts of forcing and producing respectively. We observe that this game semantics is closely related to the jumping implementation. In the third part of the thesis, we study the categorical semantics for the CBPV equational theory. We present and compare 3 approaches: ? models using strong monads, in the style of Moggi; ? models using value/producer structures, in the style of Power and Robinson; ? models using (strong) adjunctions. All the concrete models in the thesis are seen to be adjunction models.},
  school = {University of London}
}

@article{niu-sterling-grodin-harper>2022,
  title = {A Cost-Aware Logical Framework},
  author = {Niu, Yue and Sterling, Jonathan and Grodin, Harrison and Harper, Robert},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  pages = {9:1--9:31},
  doi = {10.1145/3498670},
  urldate = {2022-09-04},
  abstract = {We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants. We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist's method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid's algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.}
}

@phdthesis{okasaki>thesis,
  title = {Purely {{Functional Data Structures}}},
  author = {Okasaki, Chris},
  year = {1996},
  volume = {1129},
  number = {September},
  issn = {16113349},
  doi = {10.1007/3-540-61628-4_5},
  isbn = {3540616284},
  school = {Carnegie Mellon University}
}

@article{pedrot-tabareau>2019,
  title = {The {{Fire Triangle}}: {{How}} to {{Mix Substitution}}, {{Dependent Elimination}}, and {{Effects}}},
  shorttitle = {The {{Fire Triangle}}},
  author = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  year = {2019},
  month = dec,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {POPL},
  pages = {58:1--58:28},
  doi = {10.1145/3371126},
  urldate = {2022-11-14},
  abstract = {There is a critical tension between substitution, dependent elimination and effects in type theory. In this paper, we crystallize this tension in the form of a no-go theorem that constitutes the fire triangle of type theory. To release this tension, we propose {$\partial$}CBPV, an extension of call-by-push-value (CBPV) \textemdash a general calculus of effects\textemdash to dependent types. Then, by extending to {$\partial$}CBPV the well-known decompositions of call-by-name and call-by-value into CBPV, we show why, in presence of effects, dependent elimination must be restricted in call-by-name, and substitution must be restricted in call-by-value. To justify {$\partial$}CBPV and show that it is general enough to interpret many kinds of effects, we define various effectful syntactic translations from {$\partial$}CBPV to Martin-L\"of type theory: the reader, weaning and forcing translations.}
}

@article{plotkin-power>2008,
  title = {Tensors of {{Comodels}} and {{Models}} for {{Operational Semantics}}},
  author = {Plotkin, Gordon and Power, John},
  year = {2008},
  month = oct,
  journal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the 24th {{Conference}} on the {{Mathematical Foundations}} of {{Programming Semantics}} ({{MFPS XXIV}})},
  volume = {218},
  pages = {295--311},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2008.10.018},
  urldate = {2022-10-11},
  abstract = {In seeking a unified study of computational effects, one must take account of the coalgebraic structure of state in order to give a general operational semantics agreeing with the standard one for state. Axiomatically, one needs a countable Lawvere theory L, a comodel C, typically the final one, and a model M, typically free; one then seeks a tensor C{$\otimes$}M of the comodel with the model that allows operations to flow between the two. We describe such a tensor implicit in the abstract category theoretic literature, explain its significance for computational effects, and calculate it in leading classes of examples, primarily involving state.},
  langid = {english}
}

@article{sterling-harper>2021,
  title = {Logical {{Relations}} as {{Types}}: {{Proof-Relevant Parametricity}} for {{Program Modules}}},
  shorttitle = {Logical {{Relations}} as {{Types}}},
  author = {Sterling, Jonathan and Harper, Robert},
  year = {2021},
  month = oct,
  journal = {Journal of the ACM},
  volume = {68},
  number = {6},
  pages = {41:1--41:47},
  issn = {0004-5411},
  doi = {10.1145/3474834},
  urldate = {2023-03-21},
  abstract = {The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the phase distinction, computational effects, and type abstraction. We contribute a fresh ``synthetic'' take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a lax modality that encapsulates computational effects, placing projectibility of module expressions on a type-theoretic basis. Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a parametricity structure. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-relevant families, where there may be non-trivial evidence witnessing the relatedness of two programs\textemdash simplifying the metatheory of strong sums over the collection of types, for although there can be no ``relation classifying relations,'' one easily accommodates a ``family classifying small families.'' Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan logical relations as types, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic Artin gluing construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.}
}

@article{tarjan>1985,
  title = {Amortized {{Computational Complexity}}},
  author = {Tarjan, Robert Endre},
  year = {1985},
  month = apr,
  journal = {SIAM Journal on Algebraic Discrete Methods},
  volume = {6},
  number = {2},
  pages = {306--318},
  publisher = {{Society for Industrial and Applied Mathematics}},
  issn = {0196-5212},
  doi = {10.1137/0606031},
  urldate = {2023-03-21},
  abstract = {We analyse the amortized behavior of AVL-trees under sequences of insertions. We show that the total rebalancing cost (=balance changes) for a sequence of n arbitrary insertions is at most \$2.618n\$. For random insertions the bound is improved to \$2.26n\$. We also show that the probability that t or more balance changes are required decreases exponentially with t.}
}
