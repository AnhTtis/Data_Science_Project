\section{Conclusion}
\label{sec:concl}

Previous work~\cite{Ye2022,Ye2021} has shown the modelling of aleatoric uncertainty in RoboChart based on the semantics of MDP and in \emph{pGCL} based on the theory of probabilistic designs and the automated verification of probabilistic behaviours using probabilistic model checking and theorem proving.
This work presents a new probabilistic semantic framework, \emph{ProbURel}, and probabilistic programming to cover modelling both aleatoric and epistemic uncertainties and the automated verification of probabilistic systems exhibiting both uncertainties using theorem proving. 
We discuss our probabilistic vision in Sect.~\ref{sec:intro}, and the new semantic framework is our first step in the big picture. With ProbURel, we can give semantics to deterministic, probabilistic sequential programs with the support of discrete distributions and time.

We have based our work on Hehner's predicative probabilistic programming and addressed obstacles to applying his work by formalising and mechanising its semantics in Isabelle/UTP. We have introduced an Iverson bracket notation to separate arithmetic semantics from relational semantics so that reasoning about a probabilistic program can reuse existing reasoning techniques for both arithmetic and relational semantics. 
We have used the UTP's alphabetised relational calculus to formalise its relational semantics, and so probabilistic programs benefit from automated reasoning in Isabelle/UTP. 
We have used the summations over the topological space of real numbers for arithmetic semantics, and so probabilistic programs also benefit from mechanised theories in Isabelle/HOL for reasoning. We have enriched the semantics domains from probabilistic distributions to subdistributions and superdistributions to use the constructive Kleene fixed point theorem to give semantics to probabilistic loops based on the least fixed point and derive a unique fixed point theorem to vastly simplify the reasoning of probabilistic loops. With formalisation and mechanisation, we have reasoned about six examples of probabilistic programs. 

{
%\paragraph{\textbf{Our probabilistic vision}}
\subsection{{Our probabilistic vision}}
\label{sec:concl:vision}
Recently, we presented a probabilistic extension~\cite{Ye2022} to RoboChart~\cite{Miyazawa2019}, a state machine-based DSL for robotics, to allow the modelling of probabilistic behaviour in robot control software. 
RoboChart~\cite{Miyazawa2019,Ye2022} is a core notation in the RoboStar%
\footnote{%
  \url{robostar.cs.york.ac.uk}.%
} framework~\cite{Cavalcanti2021} that brings modern modelling and verification technologies into software engineering for robotics. In this framework, three key elements are models, formal mathematical semantics for models, and automated modelling and verification tool support.  
RoboChart is a UML-like architectural and state machine modelling notation featuring discrete time and probabilistic modelling. It has formal semantics: state machines and architectural semantics~\cite{Miyazawa2019} based on the CSP process algebra~\cite{Hoare1985,Roscoe2011} and time semantics~\cite{Miyazawa2019} based on \emph{tock}-CSP~\cite{Baxter2021,Roscoe2011}. CSP is a formal notation to describe concurrent systems where processes interact using communication. In the framework, robot hardware and control software are captured in robotic platforms, and controllers of RoboChart. The environment is captured in RoboWorld~\cite{Cavalcanti2021a} whose semantics is based on \textit{\textsf{CyPhyCircus}}~\cite{Foster2020a}, a hybrid process algebra, because of the continuous nature of the environment.

While RoboChart and RoboWorld are high-level specification languages, RoboSim~\cite{Cavalcanti2019} is a cycle-based simulation-level notation in the RoboStar framework. RoboSim also has semantics in CSP and \emph{tock}-CSP. A RoboSim model can be automatically transformed from a RoboChart model directly, and its correctness is established by refinements~\cite{Roscoe2011} in CSP.

Probability is used to capture uncertainties from physical robots and the environment and randomisation in controllers. The probabilistic extension in the RoboStar framework requires its semantic extension to either base on process algebras and hybrid process algebras or have the richness to deal with probabilistic concurrent and reactive systems. The features of its probabilistic semantics that we consider in this big vision include discrete and continuous distributions, discrete time, nondeterminism, concurrency, and refinement. The type system and the comprehensive expression language of RoboChart~\cite{Miyazawa2019}, additionally, are based on those of the Z notation~\cite{Spivey1992,Woodcock1996} and include mathematical data types such as relations and functions, quantifications, and lambda expressions. Because of such richness in semantics and language features of RoboChart, the formal verification support of RoboChart requires theorem proving and model checking.

Our immediate thought is to consider existing probabilistic extensions to process algebras, including CSP-based~\cite{Morgan1996,Morgan2005,Nunez1995,Gomez1997,Kwiatkowska1998,Georgievska2012}, CCS-based~\cite{Hansson1990,Giacalone1990,Yi1992,Vanglabbeek1995}, and ACP-based~\cite{Andova2002}. The main difference between these extensions is how existing constructs or operators, particularly nondeterministic and external choice, interact with probabilistic choice. We also looked at extensions based on probabilistic transition systems~\cite{Larsen1991,Bloom1989,Jonsson2001} and automata~\cite{Wu1997,Hartmanns2015}. To preserve the distributivity of existing operators over probabilistic choice, some algebraic properties are lost, such as the congruence for hiding and asynchronous parallel composition~\cite{Kwiatkowska1998}, idempotence for nondeterministic choice~\cite{Morgan1996a}, or even no standard nondeterministic choice~\cite{Gomez1997,Seidel1995}. The critical problem, however, is the lack of tool support for these extensions. For example, FDR~\cite{T.GibsonRobinson2014}, a refinement model checker for CSP and tock-CSP, cannot verify the probabilistic extensions in CSP. For this reason, we explored other solutions. 

In~\cite{Woodcock2019,Ye2022}, we give probabilistic semantics of RoboChart on probabilistic designs~\cite{Ye2021} in Hoare and He's Unifying Theories of Programming (UTP)~\cite{Hoare1998} and then use the theorem prover Isabelle/UTP~\cite{Foster2020}, an implementation of UTP in Isabelle/HOL, to verify probabilistic models. Probabilistic designs are an embedding of standard non-probabilistic designs into the probabilistic world. The theory of probabilistic designs gives probabilistic semantics to the imperative nondeterministic probabilistic sequential programming language \emph{pGCL}~\cite{McIver2005}, but not reactive aspects of RoboChart. We have thought about lifting probabilistic designs into probabilistic reactive designs. Still, the main obstacle is the complexity of reasoning about probabilistic distributions in probabilistic designs because distributions are captured in a dedicated variable $prob$, representing a probability mass function. In particular, the definition~\cite{Ye2021} of sequential composition includes an existential quantification over intermediate distributions. The proof of sequential composition needs to supply a witness for the intermediate distributions, which is helpful but non-trivial.

We also gave RoboChart probabilistic semantics~\cite{Ye2022,Miyazawa2020} in the PRISM language~\cite{Kwiatkowska2011}. We developed plugins for RoboTool,\footnote{\url{www.cs.york.ac.uk/robostar/robotool/}} an accompanying tool for RoboChart, to support automated verification through probabilistic model checking using PRISM. PRISM, however, employs a closed-world assumption: systems are not subjected to environmental inputs. To verify a RoboChart model, such as a high voltage controller\footnote{\url{github.com/UoY-RoboStar/hvc-case-study/tree/prism_verification/sbmf}} for a painting robot~\cite{Murray2020} and an agricultural robot\footnote{\url{github.com/UoY-RoboStar/uvc-case-study}} for UV-light treatment using PRISM, we need to constrain the environmental input and verify its expected outputs through an additional PRISM module being in parallel with the corresponding PRISM model that is automatically transformed from the RoboChart model. Finally, the safety and reachability properties of the RoboChart model (checked by the trace refinement in FDR) become deadlock freedom problems in PRISM. However, this cannot verify other properties like liveness, which requires failures-divergences refinement in CSP and FDR.

The research question that we aim to answer is a probabilistic semantic framework that 
\begin{enumerate*}[label={(\arabic*)}]
%\begin{inparaenum}
    \item has rich semantics to capture our probabilistic vision, 
    \item is simple and flexible to allow further extensions, and
    \item supports theorem proving.
%\end{inparaenum}
\end{enumerate*}
This question is comprehensive and needs a research programme, instead of a project, to address it. The work we present in this paper is our first step to answering this question. 
% We need a probabilistic semantic framework that achieves the following:
% \begin{enumerate*}[label={(\arabic*)}]
% %\begin{inparaenum}
%     \item it gives semantics to imperative deterministic, probabilistic sequential programming languages with the support of discrete distributions and time,
%     \item it is simple and flexible to allow further extensions towards nondeterminism and concurrency and supports continuous distributions and time (and so hybrid), and 
%     \item it supports theorem proving.
% %\end{inparaenum}
% \end{enumerate*}
}

\subsection{Future work}
{We have not proved and mechanised the SRW example~\ref{ex:srw}. Our immediate future work is to verify SRW: its semantics, termination, and expected runtime in terms of the parameters $m$ and $p$. We are also interested in the mathematical (that is, the probability theory) way to calculate the termination distribution and comparing it with our programming way (that is, lfp) to establish the equivalence between them.}

% Infinite state space
Our fixed point theorems, such as Theorems~\ref{thm:rec_least_fixed_point}, \ref{thm:rec_great_fixed_point}, \ref{thm:rec_unique}, and \ref{thm:rec_unique_fin} for probabilistic loops, cannot deal with the programs (the loop body) whose final observation space contains infinite states with positive probabilities. 
%For example, the introduced time variable $t$ for the coin flip as discussed in Sect.~\ref{ssec:cases_coin} will result in countably infinite states with positive probabilities. 
The restriction is introduced in Theorems~\ref{thm:incseq_limit_is_lub_all} and \ref{thm:decseq_limit_is_glb_all}, which are used to prove continuity theorems~\ref{thm:continuity_lfun_bot} and \ref{thm:continuity_lfun_top}, and eventually for the least and greatest fixed point theorems \ref{thm:rec_least_fixed_point} and \ref{thm:rec_great_fixed_point}. Our immediate future work is to extend our fixed point theorem to support such countably infinite state space, enabling us to give semantics to loops containing such programs. Our approach is to use Cousot's constructive version of the Knasterâ€“Tarski fixed point theorem~\cite{Cousot1979} to weaken continuity to monotonicity and treat the least fixed point as the stationary limit of transfinite iteration sequences. 
With this extension, our semantics can tackle more general probabilistic programs with countably infinite state space. % such as the one- or two-dimensional symmetric random walker and probabilistic loops with time $t$ (to count loops) for the reasoning of distributions over time, such as average termination time. So the coin flip and the die-throw examples will be revisited to give new semantics with time, and their average termination time will be analysed.
{Hehner~\cite{Hehner2011} presented a simpler semantics for loops. His approach is to include a time variable of type extended integer or real numbers to count iterations, similar to the $t$ (but its type is natural numbers) in our examples. He argued that if a fixed point is proved for a loop, then it is the only fixed point, and so the semantics for the loop. This is very interesting to us. We could formalise his proof and mechanise it in Isabelle/UTP, which may benefit our approach to simplify reasoning of loops or address the limitation of finite states with positive probabilities.} %than the semantics that is based on fixed-point theories like our work}.

% Continuous distributions
The probabilistic programming we present in this paper only considers discrete probabilistic distributions. One of our future works is to support continuous distributions such as normal or Gaussian distributions, uniform distributions, and exponential distributions, which are naturally presented in many physical systems in our semantics. Each point has zero probability in (absolute) continuous distributions, so the probability mass functions for discrete distributions could not describe them. Instead, they are characterised by probability density functions, which require measure theory to deal with probabilities and integration~\cite{Dahlqvist2020} over intervals. We, therefore, will introduce measure theory to our semantics and mechanise it in Isabelle/UTP based on the measure theory in Isabelle. After these lines of future work are complete, our probabilistic programming can automatically model a wide range of probabilistic systems and reasoning about them. 

% Unification of semantics
With UTP and ProbURel, we could bring different approaches to handling uncertainty, such as epistemic mu-calculus and probabilistic synthesis, together and unify these approaches. Our semantics for ProbURel are denotational, which could underpin the operational semantics for other approaches. By unifying these theories, we could link different tools. For example, one model could be analysed using our theorem prover, and it could also be transformed into another probabilistic programming language and analysed by the supported tools for it, such as PRISM. This will be beneficial for analysis by leveraging the advantages of different tools.

% Nondeterminism

% Real-time and reactive 
