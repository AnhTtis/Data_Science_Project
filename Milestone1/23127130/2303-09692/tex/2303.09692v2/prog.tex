\section{Probabilistic programming}
\label{sec:program}
This section concerns our probabilistic programming language's syntax and denotational semantics. Probabilistic recursion is not considered here, and its syntax and semantics will be introduced in Sect.~\ref{sec:rec}. 

Before presenting the semantics, we define a notation of Iverson brackets in Sect.~\ref{ssec:prob_iverson} and introduce various expression types used in our language to constrain programs in Sect.~\ref{prob:type_abbr}. Our probabilistic programs are functions characterised as probabilistic distributions or subdistributions in Sect.~\ref{prob:dist_functs}. Our definition of Iverson brackets is real-valued functions, but probabilistic programs are $\ureal$-valued functions. We must convert between these functions to use Iverson brackets in our semantics. The conversion is defined in Sect.~\ref{prob:type_abbr}.

After the presentation of syntax and semantics, we show a collection of proved algebraic laws for each construct in Sects.~\ref{ssec:prog_top_bot} to \ref{ssec:prog_parallel_comp}. These laws are used in compositional reasoning to simplify probabilistic programs.

\subsection{Iverson brackets}
\label{ssec:prob_iverson}
Iverson brackets establish a correspondence between the predicate calculus and arithmetic, generalising the Kronecker delta.\footnote{Iverson brackets are a notation for the characteristic function on predicates. The convention was invented by Kenneth Eugene Iverson in 1962. Donald Knuth advocated using square brackets to avoid ambiguity in parenthesised logical expressions.}
\begin{definition}[Iverson bracket]
    The Iverson bracket of a predicate $P$ of type $[S]\upred$ defines a function $S \fun \real$, which gives a real number 0 or 1 if $P$ is false or true for a particular state $s$ (of type $S$). \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_iverson_bracket.thy\#L45}
   \begin{align*}
       & \ibracket{P} \defs \usexpr{\IF P \THEN 1 \ELSE 0}
   \end{align*}
\end{definition}

Several laws follow immediately from this definition.
\begin{thm}
    \label{thm:ib}
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_iverson_bracket.thy\#L63}
    \begin{align}
        \ibracket{\pfalse} & = \rfzero \label{thm:ib_false} \\
        \ibracket{\ptrue} & = \rfone \label{thm:ib_true} \\
        Q \refinedby P & \implies \ibracket{P} \leq \ibracket{Q} \label{thm:ib_monotone} \\ 
        \ibracket{\lnot P} & = \usexpr{1 - \ibracket{P}} \label{thm:ib_neg}\\
        \ibracket{P \land Q} & = \usexpr{\ibracket{P} * \ibracket{Q}} \label{thm:ib_conj}  \\
        \ibracket{P \lor Q} & = \usexpr{\ibracket{P} + \ibracket{Q} - \ibracket{P} * \ibracket{Q}} \label{thm:ib_disj}\\
        \ibracket{\lambda s@ s \in A \cap B} & = \usexpr{\ibracket{\lambda s@ s \in A} * \ibracket{\lambda s@ s \in B} } \label{thm:ib_inter}\\
        \usexpr{\ibracket{\lambda s@ s \in A} + \ibracket{\lambda s@ s \in B}} & = \usexpr{\ibracket{\lambda s@ s \in A \cap B} + \ibracket{\lambda s@ s \in A \cup B}} \label{thm:ib_plus}\\ 
        \usexpr{\umax\left(x, y\right)} & = \usexpr{x * \ibracket{x > y} + y * \ibracket{x \leq y}} \label{thm:ib_max} \\
        \usexpr{\umin\left(x, y\right)} & = \usexpr{x * \ibracket{x \leq y} + y * \ibracket{x > y}} \label{thm:ib_min} \\
        {\sum_{P(k)} f(k)} & = {\sum_{k} \usexpr{f*\ibracket{P}} (k)} \label{thm:ib_summation} 
    \end{align}
\end{thm}

Laws~(\ref{thm:ib_false}) and (\ref{thm:ib_true}) show the arithmetic representations of predicates $\pfalse$ and $\ptrue$ are simply constant functions $\rfzero$ and $\rfone$. Iverson brackets are monotone, as shown in Law~(\ref{thm:ib_monotone}). 
%The Iverson bracket of logic negation of a predicate $P$ corresponds to the Iverson bracket of $P$ subtracted from 1, as given in Law~\ref{thm:ib_neg}. 
%The Iverson bracket of logic negation, conjunction, or disjunction corresponds to subtraction, multiplication,  
Laws~(\ref{thm:ib_neg}) to (\ref{thm:ib_plus}) establish direct correspondence between arithmetic, logic, and set operations. Laws~(\ref{thm:ib_max}) and (\ref{thm:ib_min}) show the maximum and minimum operations that can be implemented using the Iverson bracket. Law~(\ref{thm:ib_summation}) shows summation over a subset of indices characterised by $P(k)$ can be expressed as a summation over whole indices with the summation function $f(x)$ multiplied by the Iverson bracket of $P$. According to Donald E. Knuth~\cite{Knuth1992}, it is not easy to make a mistake when dealing with summation indices by using the notation of the right side of the law. 
We omit other properties of Iverson brackets here for simplicity.

\subsection{Type Abbreviations}
\label{prob:type_abbr}
We define several type abbreviations for real-valued and $\ureal$-valued functions used to type constructs in our language.
 \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L175}
\begin{align*}
    [S] \rexpr & = [\real, S] \uexpr \tag*{(Real-valued expression)} \label{typeabb:rexpr}\\
    [S_1, S_2] \rvfun & = [\real, S_1 \times S_2] \uexpr \tag*{(Relational real-valued expression)} \label{typeabb:rvfun}\\
    [S] \rvhfun & = [S, S] \rvfun \tag*{(Homogeneous relational real-valued expression)} \label{typeabb:rvhfun}\\
    [S] \urexpr & = [\ureal, S] \uexpr \tag*{($\ureal$-valued expression)} \label{typeabb:urexpr}\\
    %& [S_1, S_2] \urelexpr = [\ureal, S_1 \times S_2] \urexpr \tag*{[Relational $\ureal$-valued expression]} \label{typeabb:rexpr}\\
    %& [S] \hurelexpr = [S, S] \urelexpr \tag*{[Homogeneous relational $\ureal$-valued expression]} \label{typeabb:rexpr}
    [S_1, S_2] \prfun & = [\ureal, S_1 \times S_2] \urexpr \tag*{(Relational $\ureal$-valued expression)} \label{typeabb:prfun}\\
    [S] \prhfun & = [S, S] \prfun \tag*{(Homogeneous relational $\ureal$-valued expression)} \label{typeabb:prhfun}
\end{align*}

We define two functions $\prrvfun$ (\isaref{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L184}) and $\rvprfun$ (\isaref{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L181}) to convert $P$ of type $[S_1, S_2] \prfun$ to an expression of type $[S_1, S_2] \rvfun$, and $f$ of type $[S_1, S_2] \rvfun$ to an expression of type $[S_1, S_2] \prfun$.
\begin{definition}[Conversion of relational real-valued and $\ureal$-valued functions]
    \label{def:rvfun2prfun}
    \begin{align*}
        & \prrvfun(P) \defs \usexpr{\ur{P}} \tag*{(Probabilistic programs to real-valued functions)} \label{def:rvfun_of_prfun}\\
        & \rvprfun(f) \defs \usexpr{\ru{f}} \tag*{(Real-valued functions to probabilistic programs)} \label{def:prfun_of_rvfun}
    \end{align*}
\end{definition}
The notations $\ur{p}$ and $\ru{r}$ (Definition~\ref{def:u2r_r2u}) used ablove convert a $\ureal$ number to a real number and a real number to a $\ureal$ number, respectively. In this paper, we also use symbols $\prrvfunsym{P}$ and $\rvprfunsym{f}$ for $\prrvfun(P)$ and $\rvprfun(f)$, the conversions of functions.

\begin{rmk}
   For two reasons, we define two types $\prfun$ and $\rvfun$.
   First, infinite summation and limits are defined over topological space, and so over real numbers, which form a Banach space, but not over $\ureal$. We, therefore, need to convert probabilistic programs into real-valued functions to calculate summation and limits. After calculation, the results are converted back to probabilistic programs. Second, two functions in parallel composition or joint probability, introduced later in Sect.~\ref{ssec:syntax_semantics}, are not necessary to be probabilistic, and they can be more general real-valued functions.
\end{rmk}

\subsection{Distribution functions}
\label{prob:dist_functs}

A real-valued expression $p$ is \emph{nonnegative} if its range is real numbers larger than or equal to 0. 
\begin{definition}[Nonnegative] \label{def:nonneg} 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L15}
\begin{align*}
    & \isnonneg(p) \defs \tautology{p \geq 0}
\end{align*}
where $\tautology{p}$ is a tautology on predicate $p$ and is expanded to $\forall s @ \usexpr{p}(s)$.
\end{definition}

A real-valued expression $p$ is \emph{probabilistic} if its range is real numbers between 0 and 1 inclusive. This expression is characterised by a function $\isprob$ of type $[S]\rexpr \fun \bool$.

\begin{definition}[Probability expression] \label{def:isprob} 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L18}
\begin{align*}
    & \isprob(p) \defs \tautology{p \geq 0 \land p \leq 1}
\end{align*}
\end{definition}

\begin{thm}[Iverson bracket is probabilistic]
    \label{thm:isprob_ibracket}
    $\isprob(\ibracket{p})$ 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L76}
\end{thm}

A probabilistic function is called a \emph{distribution} function if the probabilities of all states sum to 1, which is characterised by a function $\isdist$ of type $[S]\rexpr \fun \bool$.
\begin{definition}[Probabilistic distributions] \label{def:isdist} 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L29}
    \begin{align*}
        & \isdist(p) \defs \isprob(p) \land \infsum s @ p(s) = 1
    \end{align*}
\end{definition}
where $\infsum$ denotes a summation over possible infinite states. %For simplicity, we use $\Sigma$ for $\infsum$ in the rest of the paper.

A probabilistic function is called a \emph{subdistribution} function if the probabilities of all states sum to less than or equal to 1, which is characterised by a function $\issubdist$.
\begin{definition}[Probabilistic subdistributions] \label{def:issubdist} 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L32}
    \begin{align*}
        \issubdist(p) \defs \isprob(p) \land \infsum s @ p(s) > 0 \land \infsum s @ p(s) \leq 1
    \end{align*}
\end{definition}
We note that a probabilistic distribution is also a subdistribution.
\begin{lem}
   $\isdist(p) \implies \issubdist(p)$ 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L79}
\end{lem}

For relational real-valued expressions $p$ of type $[S_1, S_2]\rvfun$, we define three functions to specify if the final state of a program is characterised by the expression $p$ is probabilistic, distributions, or subdistributions.
To specify these functions, we define a curried operator $\curried{p}$ ($\defs \lambda s~s' @ p(s, s')$) to turn $p$ into lambda terms, and so $\curried{p}(s)$ is a function from the final state $s'$ to real numbers. 
\begin{definition}[Final states are probabilistic, distributions, and subdistributions]
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L36}
    \begin{align*}
%        & \isfinalprob(e) \defs \forall s @ \isprob(\curried{e}(s)) \tag*{[Final probabilistic]} \label{def:isfinalprob} \\
%        & \isfinaldist(e) \defs \forall s @ \isdist(\curried{e}(s)) \tag*{[Final distributions]} \label{def:isfinaldist}\\
%        & \isfinalsubdist(e) \defs \forall s @ \issubdist(\curried{e}(s)) \tag*{[Final subdistributions]} \label{def:isfinalsubdist}
        \isfinalprob(p) & \defs \tautology{\isprob(\curried{p})} \tag*{(final probabilistic)} \label{def:isfinalprob} \\
        \isfinaldist(p) & \defs \tautology{\isdist(\curried{p})} \tag*{(final distributions)} \label{def:isfinaldist}\\
        \isfinalsubdist(p) & \defs \tautology{\issubdist(\curried{p})} \tag*{(final subdistributions)} \label{def:isfinalsubdist}
    \end{align*}
\end{definition}
For all initial states $s$, if such a curried expression $\curried{p}$ is probabilistic, a distribution, or a subdistribution, then we say $p$ is probabilistic, a distribution, or a subdistribution over the final states, characterised by functions $\isfinalprob$, $\isfinaldist$, and $\isfinalsubdist$.

For an expression $P$ of type $[S_1, S_2]\prfun$, if $\isfinalprob(\prrvfunsym{P})$, we say $P$ is probabilistic. Similarly, we say $P$ is a distribution or a subdistribution (over its final states), if $\isfinaldist(\prrvfunsym{P})$ or $\isfinalsubdist(\prrvfunsym{P})$.

Using the function $\summable$, we introduce convergence for relational expressions and for the product of relational expressions over final states.

\begin{definition}[Summable on final states]
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L188}
    \label{def:summable_on_finals}
    \begin{align}
        \summableonfinal (p) &\defs \left(\forall s @ \summable\left(\curried{p}(s), \univ\right) \right) \label{def:summable_on_final}\\
        \summableonfinals (p, q) &\defs \left(\forall s @ \summable\left(\lambda s' @ p(s, s') * q(s, s'), \univ\right)\right) \label{def:summable_on_final2}
    \end{align}
\end{definition}
The function $\summableonfinal$ characterises the relational expression $p(s)$ over final states are summable on the universe $\univ$ of state space for any initial state $s$. The function $\summableonfinals$ characterises the product of the expressions $p(s)$ and $q(s)$ over final states that are summable on $\univ$.

We also define functions below to characterise if the final states of a relational expression are reachable and the final states of two relational expressions are reachable at the same states.
\begin{definition}[Reachable final states]
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L194}
    \begin{align}
        \finalreachable(p) & \defs \left(\forall s @ \exists s' @ p(s, s') > 0 \right) \label{def:final_reachable}\\
        \finalreachables(p, q) & \defs \left(\forall s @ \exists s' @ p(s, s') > 0 \land q(s, s') > 0 \right) \label{def:final_reachable2}
    \end{align}
\end{definition}
The final states of $p$ are reachable, $\finalreachable(p)$, if from any initial state $s$ there exists at least one final state $s'$ such that $p(s,s')$ is larger than 0, or reaching $s'$ from $s$ is possible.
The $\finalreachables(p,q)$ characterises the possibility for $p(s)$ and $q(s)$ to reach the same state $s'$ from any initial state $s$.

Convergence and reachability of a relational expression $p$ can be derived from whether $p$ is a distribution or subdistribution over its final states, as shown below.
\begin{thm}\label{thm:final_distribtion}
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L375}
    \begin{align}
        \isfinaldist(p) & \implies \left(
        \begin{array}[]{l}
            \isprob(p) \land \left(\forall s @ \infsum s' @ p(s, s') = 1\right) \land \\
            \summableonfinal(p)  \land \finalreachable(p)
           %\forall s @ \summable\left(\curried{p}(s), \univ\right) \land \\
           %\forall s @ \exists s' @ p(s, s') > 0\\
        \end{array}
        \right) \label{thm:final_distribtion_1} \\
       %
        \isfinalsubdist(p) & \implies \left(
        \begin{array}[]{l}
            \isprob(p) \land \left(\forall s @ \infsum s' @ p(s, s') > 0\right) \land \left(\forall s @ \infsum s' @ p(s, s') \leq 1\right) \\
            \summableonfinal(p)  \land \finalreachable(p)
           %\forall s @ \summable\left(\curried{p}(s), \univ\right) \land \\
           %\forall s @ \exists s' @ p(s, s') > 0\\
        \end{array}
        \right) \label{thm:final_subdistribtion}
    \end{align}
\end{thm}
Law~\ref{thm:final_distribtion_1} shows if $p$ is a distribution over its final states, then $p$ is probabilistic, summable over its final states, and reachable. The second conjunct restates $p$ as a distribution over its final states.
Law~\ref{thm:final_subdistribtion} shows if $p$ is a subdistribution over the final states, then $p$ is probabilistic, the summation of $p$ over its final states is larger than 0, and less than or equal to 1, and $p$ is summable over its final states and reachable. The second and third conjuncts restate $p$ as a subdistribution over its final states.

Normalisation $\norm(p)$ is the distribution whose values are in the same proportion as the values of $p$. Here, $p$ is not required to be a distribution, but the result of normalisation can be.

\begin{definition}[Normalisation]
    \label{def:norm}
    We fix $p$ of type $[S]\rexpr$,
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L55}
\begin{align*}
    \norm(p) \defs \usexpr{p / \left(\infsum s: S @ p(s)\right)}
\end{align*}
\end{definition}
The $\norm(p)$ gives the distribution of the state space (both the initial and final states for a relational expression) in $p$. For example, suppose that $x$ is in the $1..n$ range. 

\begin{example}
\begin{align*}
    & \norm\left(\ibracket{x'=x+1 \lor x'=x+2}\right) \\
   = & \cmt{~\text{Definition~\ref{def:norm}}~} \\
   =  & \usexpr{\ibracket{x'=x+1 \lor x'=x+2} / \left(\infsum (x,x'): (1..n)\cross (1..n) @     \ibracket{x'=x+1 \lor x'=x+2}\right)} \\ 
   = & \cmt{~\text{Theorem~\ref{thm:ib} Law~\ref{thm:ib_summation}}~} \\
   =  & \usexpr{\left(\ibracket{x'=x+1 \lor x'=x+2}\right) / \left(\infsum (x,x') @ \left(\ibracket{x'=x+1 \lor x'=x+2}\right)*\ibracket{(x,x') \in (1..n)\cross (1..n)}\right)} \\
   = & \cmt{~\text{Theorem~\ref{thm:ib} Law~\ref{thm:ib_disj}}~} \\
   =  & \usexpr{
       \begin{array}[]{l}
       \left(x'=x+1 \lor x'=x+2\right) / \\
       \left(\infsum (x,x') @ \left(
       \begin{array}[]{l}
        \ibracket{x'=x+1} + \ibracket{x'=x+2} - \\
        \ibracket{x'=x+1}*\ibracket{x'=x+2}
       \end{array}
    \right)*\ibracket{(x,x') \in (1..n)\cross (1..n)}\right)
       \end{array}
    } \\
   = & \cmt{~Theorem~\ref{thm:ib} Law~\ref{thm:ib_conj}, $\ibracket{x'=x+1}*\ibracket{x'=x+2}=\rfzero$, and summation distributes through sum~} \\
   =  & \usexpr{
   \begin{array}[]{l}
        \left(\ibracket{x'=x+1 \lor x'=x+2}\right) / \\
        \left(
       \begin{array}[]{l}
\infsum (x,x') @ \ibracket{x'=x+1}*\ibracket{(x,x') \in (1..n)\cross (1..n)} + \\
\infsum (x,x') @ \ibracket{x'=x+2}*\ibracket{(x,x') \in (1..n)\cross (1..n)}\\
       \end{array}
    \right)
       \end{array}
} \\
   = & \cmt{~Theorem~\ref{thm:ib} Law~\ref{thm:ib_conj} and Iverson bracket summation one-point rule~} \\
   =  & \usexpr{\left(\ibracket{x'=x+1 \lor x'=x+2}\right) / \left(
       \begin{array}[]{l}
\infsum x @ \ibracket{(x,x+1) \in (1..n)\cross (1..n)} + \\
\infsum x @ \ibracket{(x,x+2) \in (1..n)\cross (1..n)}\\
       \end{array}
    \right)} \\
   = & \cmt{~arithmetic~} \\
   =  & \usexpr{\left(\ibracket{x'=x+1 \lor x'=x+2}\right) / \left(
\infsum x @ \ibracket{x \in 1..n-1} + \infsum x @ \ibracket{x \in 1..n-2}
    \right)} \\
   = & \cmt{~Iverson summation~} \\
   =  & \usexpr{\left(\ibracket{x'=x+1 \lor x'=x+2}\right) / \left(
    n - 1 + n - 2
    \right)} \\
   = & \cmt{~arithmetic~} \\
   =  & \usexpr{\left(x'=x+1 \lor x'=x+2\right) / \left(2*n - 3\right)} 
\end{align*}

\end{example}

Often we want the distribution of just the final state if $p$ is a relational expression.

\begin{definition}[Normalisation of the final state]
    \label{def:normf}
    We fix $p$ of type $[S_1,S_2]\rvfun$,
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L58}
\begin{align*}
    %\norm(e) \defs \lambda (s, s') @ e (s, s') / \left(\infsum ss: S_2 @ e (s, ss)\right)
    \normf(p) \defs \usexpr{p / \left(\infsum v_0: S_2 @ p[v_0/\vv']\right)}
\end{align*}
\end{definition}
The value $p(s,s')$ of $p$ for a pair $(s, s')$ of the initial state $s$ and the final state $s'$ is divided by the summation of $p(s, v_0)$ over the all final states $v_0$ for the initial state $s$.
The normalisation of $p$ is a distribution over its final states, given $p$ is nonnegative and reachable, and $\curried{p}(s)$ is convergent for any state $s$. 
\begin{thm}
    $\isnonneg(p) \land \finalreachable(p) \land \summableonfinal(p) \implies \isfinaldist \left(\normf(p)\right)$
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L2266}
\end{thm}

A probabilistic program $P$ is a relational $\ureal$-valued expression of type $[S_1, S_2] \prfun$. We show the conversion of $P$ to a real-valued function $\rvprfunsym{P}$ is probabilistic and pointwise subtraction of $\rvprfunsym{P}$ from the constant 1 function is also probabilistic.

\begin{thm}
    \label{thm:prrvfun_prob}
Provided $P$ is an expression of type $[S_1, S_2] \prfun$, then $\isprob\left(\prrvfunsym{P}\right)$ and $\isprob\left(\rfone - \prrvfunsym{P}\right)$.
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L593}
\end{thm}

The conversion of $P$ to a real-valued function and then back to the $\ureal$-valued function is still $P$.
\begin{thm}
    \label{thm:rvprfun_inverse}
    $\rvprfun$ is the inverse of $\prrvfun$, that is, $\rvprfunsym{\left(\prrvfunsym{P}\right)} = P$. 
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L613}
\end{thm}

The conversion of $p$ of type $[S_1, S_2] \prfun$ to a $\ureal$-valued function and then back to a real-value function is still $p$ if $p$ is probabilistic. 
\begin{thm}
    \label{thm:prrvfun_inverse}
    $\prrvfun$ is the inverse of $\rvprfun$ if $p$ is a probabilistic, that is, $\isprob(p) \implies \prrvfunsym{\left(\rvprfunsym{p}\right)} = p$. 
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L600}
\end{thm}

A corollary of this theorem, given below, states that the conversion of an Iverson bracket expression to $\prfun$ and then back to $\rvfun$ gives the expression itself because Iverson bracket expressions are probabilistic (Theorem~\ref{thm:isprob_ibracket}).
\begin{thm}
    \label{thm:prrvfun_inverse_ibracket} 
    $\prrvfunsym{\left(\rvprfunsym{\ibracket{p}}\right)} = \ibracket{p}$.
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L621}
\end{thm}

\subsection{Syntax and semantics}
\label{ssec:syntax_semantics}

Our probabilistic programming language includes six constructs (except probabilistic recursions), and their semantics is given as follows.
\begin{definition}[Probabilistic programs]
    \label{def:prob_programs}
    We fix $P$ and $Q$ as probabilistic programs of type $[S_1, S_2] \prfun$, $r$ as an expression of type $[S_1, S_2] \prfun$, $b$ as a relation of type $[S_1, S_2] \urel$, and $R$ and $T$ as relational real-valued expressions of type $[S_1, S_2]\rvfun$.
 \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L225}
    \begin{align*}
        \pskip & \defs \rvprfunsym{\ibracket{\II}} \tag*{(skip)} \label{def:prog_skip} \\
        \left(\passign{x}{e}\right) & \defs \rvprfunsym{\ibracket{x := e}} \tag*{(assignment)} \label{def:prog_assign} \\
        \left(\ppchoice{r}{P}{Q}\right) & \defs \rvprfunsym{\usexpr{\prrvfunsym{r} * \prrvfunsym{P} + \left(\rfone - \prrvfunsym{r}\right) * \prrvfunsym{Q}}}\tag*{(probabilistic choice)} \label{def:prog_pchoice} \\ 
        \left(\pcchoice{b}{P}{Q}\right)& \defs \rvprfunsym{\usexpr{\IF b \THEN \prrvfunsym{P} \ELSE \prrvfunsym{Q}}}\tag*{(conditional choice)} \label{def:prog_condchoice} \\ 
        %\pseq{P}{Q} & \defs \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{P}[v_0/\vv'] * \prrvfunsym{Q}[v_0/\vv]}}\tag*{(sequential composition)} \label{def:prog_seq} \\ 
        \pseq{P}{Q} & \defs \rvprfunsym{\fseq{\prrvfunsym{P}}{\prrvfunsym{Q}}} \mbox{ where }
        \fseq{R}{T} \defs {\usexpr{\infsum v_0 @ {R}[v_0/\vv'] * {T}[v_0/\vv]}} \tag*{(sequential composition)} \label{def:prog_seq} \\ 
%        & \pparallel{P}{Q} \defs \rvprfunsym{\norm \usexpr{\prrvfunsym{P} * \prrvfunsym{Q}}}\tag*{(Parallel composition or joint probability of probabilistic programs)} \label{def:prog_parallel_pp} \\ 
 %       & \pparallel{R}{Q} \defs \rvprfunsym{\norm \usexpr{R * \prrvfunsym{Q}}}\tag*{(Parallel composition or joint probability)} \label{def:prog_parallel_fp} \\ 
        \pparallel{R}{T} & \defs \rvprfunsym{\normf \usexpr{R * T}}\tag*{(parallel composition)} \label{def:prog_parallel_ff}
    \end{align*}
    %\begin{align*}
    %    \pskip & \defs \rvprfunsym{\ibracket{\II}} \tag*{(skip \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L224})} \label{def:prog_skip} \\
    %    \left(\passign{x}{e}\right) & \defs \rvprfunsym{\ibracket{x := e}} \tag*{(assignment \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L239})} \label{def:prog_assign} \\
    %    \left(\ppchoice{r}{P}{Q}\right) & \defs \rvprfunsym{\usexpr{\prrvfunsym{r} * \prrvfunsym{P} + \left(\rfone - \prrvfunsym{r}\right) * \prrvfunsym{Q}}}\tag*{(probabilistic choice \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L253})} \label{def:prog_pchoice} \\ 
    %    \left(\pcchoice{b}{P}{Q}\right)& \defs \rvprfunsym{\usexpr{\IF b \THEN \prrvfunsym{P} \ELSE \prrvfunsym{Q}}}\tag*{(conditional choice \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L283})} \label{def:prog_condchoice} \\ 
    %    \pseq{P}{Q} & \defs \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{P}[v_0/\vv'] * \prrvfunsym{Q}[v_0/\vv]}}\tag*{(sequential composition \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L299})} \label{def:prog_seq} \\ 
%   %     & \pparallel{P}{Q} \defs \rvprfunsym{\norm \usexpr{\prrvfunsym{P} * \prrvfunsym{Q}}}\tag*{(Parallel composition or joint probability of probabilistic programs)} \label{def:prog_parallel_pp} \\ 
 %  %     & \pparallel{R}{Q} \defs \rvprfunsym{\norm \usexpr{R * \prrvfunsym{Q}}}\tag*{(Parallel composition or joint probability)} \label{def:prog_parallel_fp} \\ 
    %    \pparallel{R}{T} & \defs \rvprfunsym{\normf \usexpr{R * T}}\tag*{(parallel composition \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L327})} \label{def:prog_parallel_ff}
    %\end{align*}
\end{definition}
We note that the semantics of all these constructs are converting the corresponding real-valued expressions to the $\ureal$-valued expressions by $\rvprfun$. 

The probability skip $\pskip$ is the $\ureal$ version of the Iverson bracket of the relational skip $\II$. It changes no variables and terminates immediately. On termination, the final state equals the initial state with probability 1; all other assignments to the final state have probability 0.
Similarly, the probability assignment ($\passign{x}{e}$) is the $\ureal$ version of the Iverson bracket of the relational assignment ($x := e$). An assignment is a one-point distribution of the final state. 

The probabilistic choice $\left(\ppchoice{r}{P}{Q}\right)$, also denoted $\ppifchoice{r}{P}{Q}$, is the weighted sum of $\prrvfunsym{P}$ (the conversion of $P$ to the real-valued expression) and $\prrvfunsym{Q}$ based on their weights $\prrvfunsym{r}$ and $(\rfone-\prrvfunsym{r})$. Because of the type $[S_1, S_2] \prfun$ of $r$, both $\prrvfunsym{r}$ and $\rfone-\prrvfunsym{r}$ are probabilistic (or between 0 and 1) by Theorem~\ref{thm:prrvfun_prob}.

In the conditional choice $\left(\pcchoice{b}{P}{Q}\right)$, $b$ is a relation. If $b$ is evaluated to true, the choice is $\prrvfunsym{P}$. Otherwise, it is $\prrvfunsym{Q}$.

Sequential composition $(\pseq{P}{Q})$ is the serial composition of $\prrvfunsym{P}$ with $\prrvfunsym{Q}$ by $\fseq{}{}$ where both $P$ and $Q$ have the same type of $[S]\prhfun$. The $\fseq{R}{T}$, where both $R$ and $T$ are type of $[S]\prfun$, is the conditional probability of $T$ given $R$. Indeed, it is the summation of the product of $R[v_0/\vv']$, the substitution of $v_0$ for $\vv'$ in $R$, and $T[v_0/\vv]$, the substitution of $v_0$ for $\vv$ in $T$, over their intermediate states $v_0$. Its semantics can be interpreted as starting from an initial state $s$, the probability of $(\pseq{P}{Q})$ reaching a final state $s'$ is equal to the summation of the probability of $\prrvfunsym{Q}$ reaching state $s'$ from $v_0$, given the probability of $\prrvfunsym{P}$ reaching $v_0$ from $s$, over all intermediate states $v_0$. %Its semantics can be interpreted as starting from an initial state $s$, the probability of $(\fseq{R}{T})$ reaching a final state $s'$ is equal to the summation of the probability of $T$ reaching state $s'$ from $v_0$, given the probability of $R$ reaching $v_0$ from $s$, over all intermediate states $v_0$. 

The $\pparallel{R}{T}$ is the parallel composition of ${R}$ with ${T}$, semantically as normalisation of the product of ${R}$ and ${T}$. It is the joint probability of $R$ and $T$. In its most general form, neither $R$ nor $T$ need to be proper probabilistic programs, but the result will be a probabilistic program.

In Bayesian inference, the posterior probability of $A$ given $B$ is computed based on a prior probability, which is estimated before $B$ is observed, a likelihood function over $B$ given fixed $A$, and model evidence $B$ according to Bayes' theorem given below.
\begin{align*}
    %{\displaystyle P(H\mid E)={\frac {P(E\mid H)\cdot P(H)}{P(E)}}} 
    {\text{posterior} = \frac{\text{prior}*\text{likelihood}}{\text{evidence}}} \qquad \text{or}\qquad {\displaystyle P(A  \mid B)={\frac {P(A)P(B\mid A)}{P(B)}}} 
\end{align*}
where $B$ is a new observed data or evidence.
In our programming language, the update of the posterior probability is modelled using parallel composition for learning new facts and sequential composition for making actions, such as the movement of robots. This is illustrated in the forgetful Monty, the robot localisation, and the COVID diagnosis examples in Sects.~\ref{ssec:cases_forgetful_monty}, \ref{ssec:cases_robot_localisation}, and \ref{ssec:cancer_diagnosis}.

\subsection{Top and bottom}
\label{ssec:prog_top_bot}
According to Theorem~\ref{thm:ureal_func_complete}, the set of probabilistic programs is a complete lattice under $\leq$. The top and bottom elements of the lattice satisfy the properties below. 
\begin{thm}
    \label{thm:top_bot}
Provided that $P$ is a probabilistic program and $p$ is a real-valued function.
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L906}
    \begin{align*}
        {\arraycolsep=10pt\def\arraystretch{1.0}
        \begin{array}[]{cccccccc}
        \top = \ufone & \bot = \ufzero & P \geq \ufzero & P \leq \ufone & \rvprfunsym{\rfone} = \ufone  & \rvprfunsym{\rfzero} = \ufzero & \prrvfunsym{\ufone} = \rfone  & \prrvfunsym{\ufzero} = \rfzero  \\
        p * \rfzero = \rfzero & p * \rfone = p & P * \ufzero = \ufzero & P * \ufone = P & & & & 
        \end{array}
        }
    \end{align*}
\end{thm}
The top element $\top$ is $\ufone$ and the bottom $\bot$ is $\ufzero$. Any probabilistic program $P$ is between $\bot$ and $\top$. 
The constant $\ufone$ and $\rfone$ mutually correspond in $\ureal$-valued and real-valued functions, and they can be converted to each other. This is similar for $\ufzero$ and $\rfzero$.
Real-valued functions and $\ureal$-valued functions satisfy the right-zero and right-one laws. 
% The conversion $\rvprfunsym{\rfone}$ from $\rfone$ to $\ureal$-valued expression is just $\ufone$. The conversion $\rvprfunsym{\rfzero}$ from $\rfone$ to $\ureal$-valued expression is just $\ufone$.

\subsection{Skip}
\label{ssec:prog_skip}
The $\pskip$ is a special case of assignment $\passign{x}{x}$ and is also a distribution as shown below.
\begin{thm}
    \label{thm:pskip}
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L950}
    \begin{align}
        & \pskip = \left(\passign{x}{x}\right) \label{thm:pskip_id}\\
        & \isfinaldist\left(\prrvfunsym{\pskip}\right) \label{thm:pskip_final_dist} \\
        & \prrvfunsym{\left(\rvprfunsym{\ibracket{\II}}\right)} = \ibracket{\II} \label{thm:pskip_inverse}
    \end{align}
\end{thm}
Law~\ref{thm:pskip_inverse} shows that the conversion of $\ibracket{\II}$ to the $\ureal$-valued function, and then back to the real-valued function is still $\ibracket{\II}$.

\subsection{Assignments}
\label{ssec:prog_assigns}
A probabilistic assignment is a distribution.
\begin{thm}
    \label{thm:prob_assign_finaldist}
    $\isfinaldist\left(\prrvfunsym{\passign{x}{e}}\right)$
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L991}
    %\begin{align*}
        %$\isfinaldist\left(\prrvfunsym{x := e}\right)% \tag{(1)} \label{thm:passign_final_dist}
    %\end{align*}
\end{thm}

\subsection{Probabilistic choice}
\label{ssec:prog_prob_choice}

Probabilistic choice preserves various properties below. 
\begin{thm}
    \label{thm:prob_prob_choice}
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L998}
    \begin{align}
        & \isfinaldist\left(\prrvfunsym{P}\right) \land \isfinaldist\left(\prrvfunsym{Q}\right) \implies \isfinaldist\left(\prrvfunsym{\ppchoice{r}{P}{Q}}\right) \label{thm:pchoice_final_dist}\\
        & \left(\ppchoice{r}{P}{Q}\right) = \left(\ppchoice{\ufone-r}{Q}{P}\right) \label{thm:pchoice_commute}\\
        & \left(\ppchoice{\ufzero}{P}{Q}\right) = Q \label{thm:pchoice_zero}\\
        & \left(\ppchoice{\ufone}{P}{Q}\right) = P \label{thm:pchoice_one} \\
%        & \left(\ppchoice{w_1}{P}{\left(\ppchoice{w_2}{Q}{R}\right)}\right) = \left(\ppchoice{r_2}{\left(\ppchoice{r_1}{P}{Q}\right)}{R}\right) \tag*{[Associative]} \label{thm:pchoice_one}\\
        & \left(\ppchoice{r}{P}{Q}\right) = \rvprfunsym{\prrvfunsym{r}*\prrvfunsym{P} + \left(\rfone - \prrvfunsym{r}\right) * \prrvfunsym{Q}} \label{thm:pchoice_altdef}
    \end{align}
\end{thm}
Law~\ref{thm:pchoice_final_dist} shows if $P$ and $Q$ are distributions, then the probabilistic choice is also a distribution. Laws~\ref{thm:pchoice_commute} to \ref{thm:pchoice_one} state the probabilistic choice is quasi-commutative, a zero, and a unit.

The weight $r$ in the probabilistic choice is an $\ureal$-valued expression over the product $S_1 \cross S_2$ of initial and final states. This is a very general form. Usually, we have the weight $r$ only related to initial states or just a constant expression. For this reason, we define a lift operator to lift an expression over its initial state $s$ to an expression over the product of its initial $s$ and final states $s'$.
\begin{definition}[Lift a condition to a relation]
    Fix $r$ of type $[V, S]\uexpr$, 
\isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice.thy\#L274}
    \begin{align*}
     \liftpre{r} \defs \lambda (s, s') @ r(s)   
    \end{align*}
\end{definition}
This operator $\liftpre{r}$ lifts $r$ to a relational expression $[V, S \cross \tau]\uexpr$ with any type $\tau$ for final states.

The probabilistic choice is also quasi-associative.
\begin{thm}[Quasi-associativity]
    \label{thm:pchoice_quasi_assoc}
    We fix $w_1, w_2, r_1, r_2: [S]\urexpr$, %\[\tautology{\left(1 - w_1\right)*\left(1 - w_2\right) = \left(1 - r_2\right)}\] and \[\tautology{w_1 = r_1 * r_2}\], then 
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1199}
    \begin{align*}
        & \tautology{\left(\ufone - w_1\right)*\left(\ufone - w_2\right) = \left(\ufone - r_2\right)} \land \tautology{w_1 = r_1 * r_2}
        \implies \left(\ppchoice{\liftpre{w_1}}{P}{\left(\ppchoice{\liftpre{w_2}}{Q}{R}\right)}\right) 
        = \left(\ppchoice{\liftpre{r_2}}{\left(\ppchoice{\liftpre{r_1}}{P}{Q}\right)}{R}\right)
    \end{align*}
\end{thm}
The probabilistic choice is quasi-associative under the two assumptions involving $w_1$, $w_2$, $r_1$, and $r_2$. %One example is $w_1=0.5$, $w_2=0.6$, $r_1=0.625$, and $r_2=0.8$.

\subsection{Conditional choice}
Conditional choice satisfies various properties below. 
\label{ssec:prog_cond_choice}
\begin{thm}
    \label{thm:prog_cond_choice}
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1294}
    \begin{align}
        & \isfinaldist\left(\prrvfunsym{P}\right) \land \isfinaldist\left(\prrvfunsym{Q}\right) \implies \isfinaldist\left(\prrvfunsym{\pcchoice{b}{P}{Q}}\right) \label{thm:cchoice_final_dist}\\
        & \left(\pcchoice{b}{P}{P}\right) = P \label{thm:cchoice_id}\\
        & \left(\pcchoice{b}{P}{Q}\right) = \left(\ppchoice{\rvprfunsym{\ibracket{b}}\ }{P}{Q}\right) \label{thm:cchoice_pchoice}\\
        & \left(P_1 \leq P_2 \land Q_1 \leq Q_2\right) \implies \left(\pcchoice{b}{P_1}{Q_1}\right) \leq \left(\pcchoice{b}{P_2}{Q_2}\right) \label{thm:cchoice_mono}
    \end{align}
\end{thm}
Law~\ref{thm:cchoice_final_dist} shows if $P$ and $Q$ are distributions, then the conditional choice is also a distribution. Laws~\ref{thm:cchoice_id} shows the conditional choice between $P$ and $P$ is $P$ itself. A conditional choice is a special form of probabilistic choice, as given in Law~\ref{thm:cchoice_pchoice}, with its weight $\ibracket{b}$ being the Iverson bracket of $b$: either 0 (if $b$ is evaluated to false) or 1 (if $b$ is evaluated to true). The conditional choice is also monotonic, shown in Law~\ref{thm:cchoice_mono}.

\subsection{Sequential Composition}
\label{ssec:prog_seq_comp}
A variety of properties are held for sequential composition.
\begin{thm}
    \label{thm:prog_seq_comp}
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1378}
    \begin{align}
        & \isfinaldist\left(\prrvfunsym{P}\right) \land \isfinaldist\left(\prrvfunsym{Q}\right) \implies \isfinaldist\left(\prrvfunsym{\pseq{P}{Q}}\right) \label{thm:pseq_final_dist}\\
        & \pseq{\ufzero}{P} = \ufzero \label{thm:pseq_left_zero}\\
        & \pseq{P}{\ufzero} = \ufzero \label{thm:pseq_right_zero}\\
        & \pseq{\pskip}{P} = P \label{thm:pseq_left_unit}\\
        & \pseq{P}{\pskip} = P \label{thm:pseq_right_unit}\\
        & \isfinaldist(\prrvfunsym{P}) \implies \pseq{P}{\ufone} = \ufone \label{thm:pseq_one}\\
        %% TODO: add assumptions about 
        & \left(P_1 \leq P_2 \land Q_1 \leq Q_2\right) \implies \left(\pseq{P_1}{Q_1}\right) \leq \left(\pseq{P_2}{Q_2}\right) \label{thm:pseq_mono}\\
        & \isfinaldist\left(\prrvfunsym{P}\right) \land \isfinaldist\left(\prrvfunsym{Q}\right) \land \isfinaldist\left(\prrvfunsym{R}\right) \implies \left(\pseq{P}{(\pseq{Q}{R})} = \pseq{(\pseq{P}{Q})}{R}\right) \label{thm:pseq_assoc}\\
        & \isfinalsubdist\left(\prrvfunsym{P}\right) \land \isfinalsubdist\left(\prrvfunsym{Q}\right) \land \isfinalsubdist\left(\prrvfunsym{R}\right) \implies \left(\pseq{P}{(\pseq{Q}{R})} = \pseq{(\pseq{P}{Q})}{R}\right) \label{thm:pseq_assoc_subdist}\\
        & \isfinalsubdist\left(\prrvfunsym{P}\right) \implies \left(\pseq{P}{\left(\pcchoice{b}{Q}{R}\right)} = \rvprfunsym{\usexpr{\prrvfunsym{\left(\pseq{P}{\left(\ibracket{b}*Q\right)}\right)} + \prrvfunsym{\left(\pseq{P}{\left(\ibracket{\lnot b}*R\right)}\right)} }}\right) \label{thm:pseq_dist_cchoice} \\
        & \pseq{\rvprfunsym{\ibracket{p}}}{\rvprfunsym{\ibracket{q}}} = \rvprfunsym{\usexpr{\infsum v_0 @ \ibracket{p[v_0/\vv'] \land q[v_0/\vv]}}} \label{thm:pseq_ibracket} 
    \end{align}
\end{thm}
If $P$ and $Q$ are distributions, then sequential composition of $P$ and $Q$ is also a distribution (Law~\ref{thm:pseq_final_dist}). Sequential composition is left zero (Law~\ref{thm:pseq_left_zero}), right zero (Law~\ref{thm:pseq_right_zero}), left unit (Law~\ref{thm:pseq_left_unit}), right unit (Law~\ref{thm:pseq_right_unit}), monotonic (Law~\ref{thm:pseq_mono}), and associative (Laws~\ref{thm:pseq_assoc} and~\ref{thm:pseq_assoc_subdist} if $P$, $Q$, and $R$ are distributions or subdistributions). If $P$ is a subdistribution, then Law~\ref{thm:pseq_dist_cchoice} shows $P$ is distributive through conditional choice.

An interesting Law~\ref{thm:pseq_one} (\isaref{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1845}) states if $P$ is a distribution over the final state, then sequence composition of $P$ with $\ufone$ is $\ufone$. Its proof is given below.
\begin{proof}
\begin{align*}
  & \pseq{P}{\ufone} \\
= & \cmt{Definition~\ref{def:prog_seq}} \\
  & \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{P}[v_0/\vv'] * \prrvfunsym{\ufone}[v_0/\vv]}} \\
= & \cmt{Theorem~\ref{thm:top_bot} and ${\rfone}[v_0/\vv] = \rfone$} \\
  & \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{P}[v_0/\vv'] * {\rfone}}} \\
= & \cmt{Pointwise multiplication and multiplication unit law: $x * 1 = x$} \\
  & \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{P}[v_0/\vv']}} \\
= & \cmt{ Assumption: $\isfinaldist\left(\prrvfunsym{P}\right)$ and Theorem~\ref{thm:final_distribtion} Law~\ref{thm:final_distribtion_1}: $\left(\forall s @ \infsum s' @ \prrvfunsym{P}(s, s') = 1\right)$} \\
  & \rvprfunsym{\rfone} \\
= & \cmt{Theorem~\ref{thm:top_bot}} \\
  & \ufone 
\end{align*}
\end{proof}

The sequential composition of two Iverson bracket expressions can be simplified to the summation of the Iverson bracket of conjunction, as shown in Law~\ref{thm:pseq_ibracket} (\isaref{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1418}). This law is proved below.
\begin{proof}
\begin{align*}
 & \pseq{\rvprfunsym{\ibracket{p}}}{\rvprfunsym{\ibracket{q}}}  \\
= & \cmt{Definition~\ref{def:prog_seq}} \\
& \rvprfunsym{\usexpr{\infsum v_0 @ \prrvfunsym{\left(\rvprfunsym{\ibracket{p}}\right)}[v_0/\vv'] * \prrvfunsym{\left(\rvprfunsym{\ibracket{q}}\right)}[v_0/\vv]}} \\
= & \cmt{Theorem~\ref{thm:prrvfun_inverse_ibracket}} \\
& \rvprfunsym{\usexpr{\infsum v_0 @ \ibracket{p}[v_0/\vv'] * \ibracket{q}[v_0/\vv]}} \\
= & \cmt{Substitution distributive through Iverson bracket} \\
& \rvprfunsym{\usexpr{\infsum v_0 @ \ibracket{p[v_0/\vv']} * \ibracket{q[v_0/\vv]}}} \\
= & \cmt{Theorem~\ref{thm:ib} Law~\ref{thm:ib_conj}} \\
 & \rvprfunsym{\usexpr{\infsum v_0 @ \ibracket{p[v_0/\vv'] \land q[v_0/\vv]}}} 
\end{align*}
\end{proof}

A corollary of this law, given below, states that if the two expressions cannot agree on an intermediate state $v_0$, the sequence is just $\ufzero$. 
\begin{thm}
    \label{thm:pseq_ibracket_contradictory}
   $c_1 \neq c_2 \implies \pseq{\rvprfunsym{\ibracket{x'=c_1}}}{\rvprfunsym{\ibracket{x=c_2}}} = \ufzero$ 
   \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1428}
\end{thm}
The intermediate state can be ignored if the two expressions agree on one intermediate state $c_1$.
\begin{thm}
    \label{thm:pseq_ibracket_agree_1_final_unspecified}
   $\pseq{\rvprfunsym{\ibracket{x=c_0 \land x:=c_1}}}{\rvprfunsym{\ibracket{x=c_1}}} = {\rvprfunsym{\ibracket{x=c_0}}}$ 
   \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1443}
\end{thm}
The intermediate state can be ignored if the second expression is also a point distribution, but its final state is still specified.
\begin{thm}
    \label{thm:pseq_ibracket_agree_1_point}
   $\pseq{\rvprfunsym{\ibracket{x=c_0 \land x:=c_1}}}{\rvprfunsym{\ibracket{x=c_1 \land x: = c_2}}} = {\rvprfunsym{\ibracket{x=c_0 \land x'=c_2}}}$ 
   \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L1464}
\end{thm}

\subsection{Normalisation}
\label{ssec:prog_normalisation}

% For expressions that are not distributions, we use the normalisation defined below to turn them into distributions.
% \begin{definition}[Normalisation]
% Normalisation $\norm$ of an expression $P$ of type $[S_1, S_2]\relexpr$ is also an expression of the same type but with the value of $P$ for each initial state $s$ and final state $s'$ pair divided by the summation of the values of $e$ over all reachable final states from $s$.
% \begin{align*}
%     %\norm(e) \defs \lambda (s, s') @ e (s, s') / \left(\infsum ss: S_2 @ e (s, ss)\right)
%     \norm(P) \defs \usexpr{P / \left(\infsum v_0: S_2 @ P[v_0/\vv']\right)}
% \end{align*}
% \end{definition}
% 

% $\norm(p)$ in Definition~\ref{def:norm} specifies the distribution of the final state, given values for the initial state. For example, 

The $\normf$ in Definition~\ref{def:normf} gives a distribution of the final state, that is, over all variables in the state space. We also want the distribution of just one particular variable instead of all, for example, to define a uniform distribution. For this purpose, we define the alphabetised normalisation below.

\begin{definition}[Alphabetised normalisation]
    \label{def:norm_alpha}
    We fix $p$ of type $[S_1,S_2]\rvfun$ and a program variable $x$ of type $T_x$,
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L63}
\begin{align*}
    %\norm(x, e) \defs \lambda (s, s') @ e (s, s') / \left(\infsum v : T_x @ e (s)[v/x]\right)
    \normal(x, p) \defs \usexpr{p / \left(\infsum x_0: T_x @ p[x_0/x']\right)}
\end{align*}
\end{definition}

Uniform distributions are defined using $\normal$.
\begin{definition}[Uniform distributions]
    \label{def:uniform_dist}
    We fix a program variable $x$ of type $T_x$ and a finite set $A$ of type $\power~T_x$,
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_distribution.thy\#L69}
\begin{align*}
    %(x, A) \defs \normal (x, \ibracket{\bigsqcup v \in A @ x := v})
    %\uniformdist{x}{A} \defs \normal \left(x, \livbr \Union v \in A @ x := v \rivbr\right)
    \uniformdist{x}{A} \defs \normal \left(x, \livbr \Inf v \in A @ x := v \rivbr\right)
\end{align*}
\end{definition}
A uniform distribution of $x$ from a finite set $A$ is an alphabetised normalisation of a program $\ibracket{\Inf v \in A @ x := v }$, nondeterministic choice $\Inf$ of the value of $x$ from $A$, over $x'$. Here, $\Inf$ is inside the Iverson bracket and is a UTP relation operator infimum, simply disjunction $\Union$.

The uniform distribution operator satisfies the properties below.
\begin{thm}
    \label{thm:uniform_dist}
    We fix $P$ of type $[S_1,S_2]\prfun$,
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L2222}
    \begin{align}
%        & \isnonneg{p} \land \finalreachable{p} \land \left(\forall s @ \summable\left(\curried{p}(s), \univ\right)\right) \implies \isfinaldist\left(\norm(p) \right) \tag*{[Normalisation is a distribution]} \label{thm:norm_dist} \\
        & \uniformdist{x}{\emptyset} = \rfzero \label{thm:uniform_emptyset} \\
        & \finite(A) \implies \isprob\left(\uniformdist{x}{A}\right) \label{thm:uniform_prob} \\
        & \finite(A) \land A \neq \emptyset \implies \isfinaldist\left(\uniformdist{x}{A}\right)\label{thm:uniform_finaldist} \\
        & \finite(A) \land A \neq \emptyset \implies \left(\forall v \in A @ \pseq{\uniformdist{x}{A}}{\ibracket{x = v}} = \usexpr{1/\card (A)}\right) \label{thm:uniform_uniform} \\
        & \finite(A) \land A \neq \emptyset \implies \left(\uniformdist{x}{A} = \livbr \Union v \in A @ x := v \rivbr / \card (A)\right)\label{thm:uniform_form2} \\
        & \finite(A) \land A \neq \emptyset \implies \left(\pseq{\rvprfunsym{\uniformdist{x}{A}}}{P} = \rvprfunsym{\left(\infsum v \in A @ \prrvfunsym{P}[v/x]\right) / \card (A)}\right)\label{thm:uniform_pseq} 
    \end{align}
\end{thm}
Law~\ref{thm:uniform_emptyset} shows the distribution over an empty set $\emptyset$ is just the constant function $\rfzero$. Provided $A$ is finite, then $\uniformdist{x}{A}$ is probabilistic (Law~\ref{thm:uniform_prob}). If $A$ is also not empty ($A \neq \emptyset$), $\uniformdist{x}{A}$ is also a distribution (Law~\ref{thm:uniform_finaldist}). Under the same assumptions about $A$, $\uniformdist{x}{A}$ is truly a uniform distribution, that is, $x$ being any value from $A$ is equally likely ($1/\card(A)$ where $\card(A)$ is the cardinality of $A$), as shown in Law~\ref{thm:uniform_uniform}, where we use sequential composition $\pseq{\uniformdist{x}{A}}{\ibracket{x = v}}$ to express the probability of $x$ being a particular value $v$. The distribution $\uniformdist{x}{A}$ can be simplified to another form, shown in Law~\ref{thm:uniform_form2}. The sequence of a uniform distribution and $P$ is a left one-point, shown in Law~\ref{thm:uniform_pseq}.

\subsection{Parallel composition}
The \ref{def:prog_parallel_ff} is defined over real-valued functions and specifies a $\ureal$-valued function. It satisfies the properties below.
\label{ssec:prog_parallel_comp}
\begin{thm}
    Fix $p$, $q$, and $r$ of type $[S_1, S_2] \rvfun$, and $P$, $Q$, and $R$ of type $[S_1, S_2] \prfun$.
    \isalink{https://github.com/RandallYe/probabilistic_programming_utp/blob/6a4419b8674b84988065a58696f15093d176594c/probability/probabilistic_relations/utp_prob_rel_lattice_laws.thy\#L2559}
    \begin{align}
        & \isnonneg(p*q)\implies \isprob\left(\normf \usexpr{p * q}\right) \label{thm:pparallel_norm_prob} \\
        & \left(
        \begin{array}[]{l}
            \isfinalprob(p) \land \isfinalprob(q) \land \\
            \left(\summableonfinal(p) \lor \summableonfinal(q)\right) \land \finalreachables(p,q) 
        \end{array}\right)
        \implies \isfinaldist\left(\pparallel{p}{q}\right)\label{thm:pparallel_dist} \\
        & \left(
        \begin{array}[]{l}
            \isnonneg(p) \land \isnonneg(q) \land \lnot\finalreachables(p,q) 
        \end{array}\right)
        \implies \pparallel{p}{q} = \ufzero \label{thm:pparallel_contradiction_zero} \\
        & \pparallel{\rfzero}{p} = \ufzero \label{thm:pparallel_left_zero} \\
        & \pparallel{p}{\rfzero} = \ufzero \label{thm:pparallel_right_zero} \\
        % & \pparallel{(\lambdas @ c)}{p} = \rvprfunsym{p} \tag*{[Left unit]} \label{thm:pparallel_left_unit} \\
        & c \neq 0 \land \isfinaldist(p) \implies \pparallel{(\lambda s @ c)}{p} = \rvprfunsym{p} \label{thm:pparallel_left_unit} \\
        & c \neq 0 \land \isfinaldist(p) \implies \pparallel{p}{(\lambda s @ c)} = \rvprfunsym{p} \label{thm:pparallel_right_unit} \\
        & \pparallel{p}{q} = \pparallel{q}{p} \label{thm:pparallel_commute} \\
        & \left(
        \begin{array}[]{l}
            \isnonneg(p) \land \isnonneg(q) \land \isnonneg(r)\land \\
            \summableonfinals(p, q) \land 
            \summableonfinals(q, r) \land  \\
            \finalreachables(p, q) \land 
            \finalreachables(q, r) 
            %\forall s @ \left(\summable\left(\lambda s' @ p(s, s') * q(s, s'), \univ\right)\right) \\
            %\forall s @ \left(\summable\left(\lambda s' @ q(s, s') * r(s, s'), \univ\right)\right) \\
            %\forall s @ \exists s' @ \left(p(s, s') > 0 \land q(s, s') > 0\right) \\
            %\forall s @ \exists s' @ \left(q(s, s') > 0 \land r(s, s') > 0\right) \\
        \end{array}\right)
        \implies \pparallel{\left(\pparallel{p}{q}\right)}{r} = \pparallel{p}{\left(\pparallel{q}{r}\right)} \label{thm:pparallel_assoc} \\
        & %\left(
        \summableonfinal(\prrvfunsym{Q})
        %\begin{array}[]{l}
        %    \forall s @ \left(\summable\left(\lambda s' @ \prrvfunsym{Q}(s, s'), \univ\right)\right) \\
        %\end{array}\right)
        \implies \pparallel{\left(\pparallel{\prrvfunsym{P}}{\prrvfunsym{Q}}\right)}{\prrvfunsym{R}} = \pparallel{\prrvfunsym{P}}{\left(\pparallel{\prrvfunsym{Q}}{\prrvfunsym{R}}\right)} \label{thm:pparallel_assoc2} \\
        & \finite(A) \land A \neq \emptyset \implies \left(\pparallel{\uniformdist{x}{A}}{p} = \rvprfunsym{\usexpr{\left(\infsum v \in A @ \ibracket{x := v} * p[v/x']\right) / \left(\infsum v \in A @ p[v/x']\right)}}\right) \label{thm:pparallel_uniform} 
    \end{align}
\end{thm}
%
Law~\ref{thm:pparallel_norm_prob} shows the normalisation of the product $p*q$ of $p$, and $q$ is probabilistic if $p*q$ is nonnegative. %Because parallel composition $\pparallel{p}{q}$ is defined using the normalisation of $p*q$, we also way $\pparallel{p}{q}$ is probabilistic.
If both $p$ and $q$ are probabilistic and summable on their final states, reachable on at least one same final state at the same time, then $\pparallel{p}{q}$ is also a distribution of the final state (Law~\ref{thm:pparallel_dist}). If both $p$ and $q$ are nonnegative and not reachable on at least one same final state at the same time (or a contradiction between $p$ and $q$), then $\pparallel{p}{q}$ is a zero (Law~\ref{thm:pparallel_contradiction_zero}). 

Parallel composition is a left zero (Law~\ref{thm:pparallel_left_zero}) and a right zero (Law~\ref{thm:pparallel_right_zero}), and a left unit (Law~\ref{thm:pparallel_left_unit}) and a right unit (Law~\ref{thm:pparallel_right_unit}) if a constant $c$ is not 0 and $p$ is a distribution. It is also commutative (Law~\ref{thm:pparallel_commute}).

Law~\ref{thm:pparallel_assoc} shows if $p$, $q$, and $r$ are nonnegative, both $p$ and $q$ are summable and reachable on their product, and both $q$ and $r$ are summable and reachable on their product, then the parallel composition is associative. If, however, $p$, $q$, and $r$ are converted from probabilistic programs $P$, $Q$, and $R$, and also $Q$ is summable on its final state, then the parallel composition is also associative (Law~\ref{thm:pparallel_assoc2}).

Law~\ref{thm:pparallel_uniform} shows if $A$ is finite and not empty, then the parallel composition of a uniform distribution over $x$ from $A$ and $p$ can be simplified to a division whose numerator denotes the value of $p$ reaching a final state with $x$ being a particular value $v$ and whose denominator represents the summation of the values of $p$ reaching final states with $x$ being any value $v$ from $A$.

%This section presents the syntax and semantics of our probabilistic programming language. 
