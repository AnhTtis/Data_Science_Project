\documentclass[10pt,twocolumn,letterpaper]{article}
\usepackage[table]{xcolor}
\usepackage{iccv}
\usepackage{times}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amssymb}
\usepackage{bbding}
\usepackage{pifont}
\usepackage{wasysym}
\usepackage{utfsym}
\usepackage{fontawesome}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algorithmicx}  
\usepackage{algpseudocode}
\usepackage{comment}
\usepackage{tablefootnote}
% \usepackage[section]{placeins}
% Include other packages here, before hyperref.

% If you comment hyperref and then uncomment it, you should delete
% egpaper.aux before re-running latex.  (Or just hit 'q' on the first latex
% run, let it finish, and you should be clear).
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}
\def\mathbi#1{\textbf{\em #1}}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\iccvfinalcopy % *** Uncomment this line for the final submission

\def\iccvPaperID{3746} % *** Enter the ICCV Paper ID here
\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
\ificcvfinal\pagestyle{empty}\fi
\begin{document}

%%%%%%%%% TITLE
% \title{Exploring Efficient Long-Sequence Multi-View 3D Object Detection}
\title{Exploring  Object-Centric Temporal Modeling for Efficient Multi-View 3D Object Detection}
\author{
Shihao Wang$^{1\dagger}$ \hspace{0.35cm} 
Yingfei Liu$^2$ \hspace{0.25cm} Tiancai Wang$^2$ \hspace{0.25cm} Ying Li$^1$ \hspace{0.25cm} 
Xiangyu Zhang$^2$ \\ [.5ex] $^1$Beijing Institute of Technology \hspace{0.9cm} $^2$MEGVII Technology \\ [.5ex]
}
\twocolumn[
{
\renewcommand\twocolumn[1][]{#1}%
\maketitle
\vspace{-0.25cm}
\begin{figure}[H]
\hsize=\textwidth
    \vspace{-1cm}
    \includegraphics[scale=0.525]{figs/intro.pdf}
    \caption{Different temporal fusion methods from bird-eye-view (BEV) space, perspective view, and our proposed object-centric. RF indicates receptive field. The solid lines and dotted lines represent spatial and temporal operations respectively.}
    \label{intro}
\end{figure}
}
]
\let\thefootnote\relax\footnotetext{$\dagger$ Work done during the internship at MEGVII Technology.}

%%%%%%%%% ABSTRACT
\begin{abstract}
\vspace{-0.25cm}
In this paper, we propose a long-sequence modeling framework, named StreamPETR, for multi-view 3D object detection. Built upon the sparse query design in the PETR series, we systematically develop an object-centric temporal mechanism. The model is performed in an online manner and the long-term historical information is propagated through object queries frame by frame. Besides, we introduce a motion-aware layer normalization to model the movement of the objects. StreamPETR achieves significant performance improvements only with negligible computation cost, compared to the single-frame baseline. 
% On the standard nuScenes benchmark, it reaches a new state-of-the-art performance (67.6\% NDS). 
On the standard nuScenes benchmark, it is the first online multi-view method that achieves comparable performance  (67.6\% NDS \& 65.3\% AMOTA) with lidar-based methods. 
The lightweight version realizes 45.0\% mAP and 31.7 FPS, outperforming the state-of-the-art method (SOLOFusion) by 2.3\% mAP and 1.8$\times$ faster FPS. Code has been available at \href{https://github.com/exiawsh/StreamPETR}{\color{red} https://github.com/exiawsh/StreamPETR.git}.

\vspace{-0.5cm}
\end{abstract}

%%%%%%%%% BODY TEXT
\section{Introduction}

Camera-only 3D detection is crucial for autonomous driving because of the low deployment cost and ease of detecting road elements. Recently, multi-view object detection has made remarkable progress by leveraging temporal information~\cite{li2022bevformer,huang2022bevdet4d,liu2022petrv2,li2022bevdepth,park2022time,lin2022sparse4d}. The historical features facilitate the detection of occlusion objects and greatly improve the performance. According to the differences between temporal representations, existing methods can be roughly divided into \emph{BEV temporal} and \emph{perspective temporal} methods.



BEV temporal methods~\cite{li2022bevformer,huang2022bevdet4d,li2022bevdepth,park2022time} explicitly warp BEV features from historical to current frame, as illustrated in Fig.~\ref{intro} (a),
where BEV features serve as an efficient intermediate representation for temporal modeling.
However, the highly structured BEV features limit the modeling of moving objects. This paradigm requires a large receptive field to alleviate this problem~\cite{huang2022bevdet4d,park2022time,li2022bevformer}. 

Different from these approaches,
perspective temporal methods ~\cite{liu2022petrv2,lin2022sparse4d} are mainly based on DETR~\cite{carion2020detr,zhu2020deformable}.  The sparse query design facilitates the modeling of moving objects ~\cite{lin2022sparse4d}. However, the sparse object queries need to interact with multi-frame image features for long-term temporal dependence (see Fig.~\ref{intro} (b)), leading to multiple computations.
Thus, existing works are either stuck in solving the moving objects or introducing multiple computation costs. 


Based on the above analysis, we suppose it is possible to employ sparse queries as the hidden states of temporal propagation. In this way, we can utilize object queries to model moving objects while keeping high efficiency. 
Therefore, we introduce a new paradigm: \emph{object-centric temporal} modeling and design an efficient framework, termed StreamPETR, as shown in Fig.~\ref{intro} (c). StreamPETR directly performs frame-by-frame 3D predictions on streaming video. It is effective for motion modeling and is able to build long-term spatial-temporal interaction.

Specifically, a memory queue is first built to store the historical object queries. Then a propagation transformer conducts long-range temporal and spatial interaction with current object queries. The updated object queries are used to generate 3D bounding boxes and pushed into the memory queue. Besides, a motion-aware layer normalization (MLN) is introduced to implicitly encode the motion of the ego vehicle and surrounding objects at different time stamps. 

\begin{figure}[t]
\centering
\includegraphics[scale=0.09]{figs/speed_vs_acc.pdf}
\caption{The speed-accuracy trade-off of different models on nuScenes val set. The inference speed is calculated on RTX3090 GPU in online streaming video. T indicates the model with temporal modeling.}
\vspace{-0.5cm} 
\label{speed_vs_acc}
\end{figure}

Compared with existing temporal methods, the proposed object-centric temporal modeling brings several advantages. StreamPETR only processes a small number of object queries instead of dense feature maps at each time stamp, consuming negligible computational burden (as shown in Fig.~\ref{speed_vs_acc}). For moving objects, MLN alleviates the cumulative error in video streaming. Except for the location prior used in previous methods, StreamPETR additionally considers the semantic similarity by global attention, which facilitates the detection in motion scenes. To summarize, our contributions are:




\begin{itemize}
\item We pull out the key of streaming multi-view 3D detection and systematically  design an \emph{object-centric} temporal modeling paradigm. The long-term historical information is propagated through object queries frame by frame.


\item We develop an object-centric temporal modeling framework, termed StreamPETR. 
% utilizes object queries as an intermediate representation. 
It models moving objects and long-term spatial-temporal interaction simultaneously, consuming negligible storage and computation costs.

\item  On the standard nuScenes dataset, StreamPETR outperforms all online camera-only algorithms. Extensive experiment shows that it can be well generalized to other sparse query-based methods, e.g. DETR3D~\cite{wang2022detr3d}. 
\end{itemize}

\section{Related Work}
\begin{figure*}[t]
	\centering  
	% \includegraphics[width=0.9\linewidth]{figs/overall.pdf}
     \includegraphics[width=0.95\linewidth]{figs/framework.pdf}
	\caption{Overall architecture of the proposed StreamPETR. The memory queue stores the historical object queries. In the propagation transformer, recent object queries successively interact with historical queries and current image features to obtain temporal and spatial information. The output queries are further used to generate detection results and the top-K foreground queries are pushed into the memory queue. Through the recurrent update of the memory queue, the long-term temporal information is propagated frame by frame.}
	\label{architecture}
\vspace{-0.5cm} 
\end{figure*}

\subsection{Multi-view 3D Object Detection}
Multi-view 3D detection is an important task in autonomous driving, which needs to continuously process multi-camera images and predict 3D bounding boxes over time.
Pioneer's works~\cite{wang2022detr3d,liu2022petr,huang2021bevdet,li2022bevformer, jiang2022polarformer, wang2023object} focus on the efficient transformation from multiple perspective views to a unified 3D space in a single frame. The transformation can be divided into BEV-based methods~\cite{huang2021bevdet,li2022bevformer,xie2022m,huang2023fast,li2022bevdepth,jiang2022polarformer} and sparse query based methods~\cite{wang2022detr3d,liu2022petr,lin2022sparse4d,chen2022polar,wang2023object}. To alleviate the occlusion problem and ease the difficulty of speed prediction, recent works additionally introduce temporal information to extend these two paradigms. 

It is relatively intuitive to extend the single-frame BEV methods for temporal modeling.
BEVFormer~\cite{li2022bevformer} first introduces sequential temporal modeling into multi-view 3D object detection and applies temporal self-attention. BEVDet series~\cite{huang2022bevdet4d,li2022bevdepth, li2022bevstereo} use concatenate operation to fuse the adjacent BEV features and achieve remarkable results. Furthermore, SOLOFusion~\cite{park2022time} extends BEVStereo~\cite{li2022bevstereo} to long-term memory and reaches a promising performance. Without an intermediate feature representation, the temporal modeling of query-based methods is more challenging. PETRv2~\cite{liu2022petrv2} performs the global cross-attention, while DETR4D ~\cite{luo2022detr4d} and  Sparse4D~\cite{lin2022sparse4d} apply sparse attention to model the interaction between multi-frames, which introduce multiple computations. However, the sparse query design is convenient to model the moving objects~\cite{lin2022sparse4d}. In order to combine the advantages of the two paradigms, we utilize sparse object queries as the intermediate representation, which can model moving objects and efficiently propagate long-term temporal information.

\subsection{Query Propagation}
Since DETR~\cite{carion2020detr} is proposed in 2D object detection, the object query has been applied in many downstream tasks~\cite{zeng2022motr,meinhardt2022trackformer,zhang2022motrv2, zhang2022mutr3d,he2022queryprop} to model the temporal interaction. For video object detection, LWDN~\cite{jiang2019video} adopts a brain-inspired memory mechanism to propagate and update the memory feature.
QueryProp~\cite{he2022queryprop} performs query interaction to reduce the computational cost on non-key frames. It achieves significant improvements and maintains high efficiency. 3D-MAN~\cite{yang20213d} has a similar idea and extends a single-frame Lidar detector to multi-frames, which effectively combines the features coming from different perspectives of a scene. In object tracking, MOTR~\cite{zeng2022motr} and TrackFormer~\cite{meinhardt2022trackformer} propose the track query to model the object association across frames. MeMOT ~\cite{cai2022memot} employs a memory bank to build long temporal dependence, which further boosts performance. MOTRv2~\cite{zhang2022motrv2} eases the conflict between the detection and association tasks by incorporating an extra detector. MUTR~\cite{zhang2022mutr3d} and PF-Track~\cite{pang2023standing} extend MOTR~\cite{zeng2022motr} into multi-view 3D object tracking and achieve a promising result. 


\section{Delving into Temporal Modeling}\label{analysis}
To facilitate our study, we present a generalized formulation for various temporal modeling designs. Given the perspective view features $F_{2d} = \{F^{0}_{2d}\cdots  F^{t}_{2d}\}$, dense BEV features  $F_{bev} = \{F^{0}_{bev}\cdots F^{t}_{bev}\}$ and sparse object features $F_{obj} = \{F^{0}_{obj}\cdots F^{t}_{obj}\}$. The dominant temporal modeling methods can be formulated as:
\begin{equation}\label{eq4}
\begin{aligned}
\tilde{F}_{out}\!=\!\varphi(F_{2d}, F_{bev}, F_{obj})
\end{aligned}
\end{equation}
where $\varphi$ is the temporal fusion operation, $\tilde{F}_{out}$ is the output feature that includes temporal information. We first describe the existing temporal modeling from BEV and perspective view. After that, the proposed object-centric temporal modeling is elaborated.
\begin{figure*}[thb]
	\centering  
	\includegraphics[width=1.0\linewidth]{figs/transformer.pdf}
    % \includegraphics[width=1.0\linewidth]{figs/transformer.png}
	\caption{The details of the propagation transformer and motion-aware layer normalization. In the propagation Transformer~\cite{vaswani2017attention}, object queries interact with hybrid queries and image features iteratively. The motion-aware layer normalization encodes the motion attributes  (ego pose, timestamps, velocity) and performs a compensation implicitly. Rectangles of varying hues symbolize queries from distinct frames, gray rectangles represent initialized queries of current frame, dashed rectangles correspond to background queries.}
	\label{transformer}
\vspace{-0.5cm}
\end{figure*}

\noindent\textbf{BEV Temporal Modeling} uses the grid-structured BEV features to perform the temporal fusion. To compensate for the ego vehicle motion, the last frame feature $F^{t-1}_{bev}$ is usually aligned to the current frame. 
\begin{equation}\label{eq_bevdet4d}
\begin{aligned}
\tilde{F}^{t}_{bev} = \varphi(F^{t-1}_{bev}, F^{t}_{bev})
\end{aligned}
\end{equation}
Then a temporal fusion function $\varphi$  (concatenation~\cite{huang2022bevdet4d, li2022bevdepth} or deformable attention~\cite{li2022bevformer}) can be applied for intermediate temporal representation $\tilde{F}^{t}_{bev}$. Extending the above process to long temporal modeling, there are two main routes. The first one is to align the historical $k$ BEV features and concatenate them with the current frame.
\begin{equation}\label{eq_solofusion}
\begin{aligned}
\tilde{F}^{t}_{bev} = \varphi(F^{t-k}_{bev}, \cdots, F^{t-1}_{bev}, F^{t}_{bev})
\end{aligned}
\end{equation}
% In Eq.~\ref{eq_solofusion}, the historical BEV features with $k$ frames will be aligned and concatenated with the current frame. 
For another one, the long-term historical information is propagated through the hidden states of BEV features $\tilde{F}^{t-1}_{bev}$ in a recurrent manner. 
\begin{equation}\label{eq_bevformer}
\begin{aligned}
\tilde{F}^{t}_{bev} = \varphi(\tilde{F}^{t-1}_{bev}, F^{t}_{bev})
\end{aligned}
\end{equation}

However, the BEV temporal fusion only considers the static BEV features and ignores the movement of the objects, leading to spatial dislocation.

% \textbf{Hybrid Temporal}:
\noindent\textbf{Perspective Temporal Modeling} is mainly performed via interactions between object queries and perspective features. The temporal function $\varphi$ is usually achieved by the spatial cross-attention~\cite{liu2022petrv2, lin2022sparse4d, luo2022detr4d}:

\begin{equation}\label{eq5}
\begin{aligned}
\tilde{F}^{t}_{obj} = \varphi(F^{t-k}_{2d}, {F}^{t}_{obj}) \cdots + \varphi(F^{t}_{2d}, F^{t}_{obj})
\end{aligned}
\end{equation}

The cross-attention between object query and multi-frame perspective view requires repeated feature aggregation. Simply extending to long-term temporal modeling greatly increases the computation cost.

\noindent\textbf{Object-centric Temporal Modeling} is our proposed object-centric solution, which models the temporal interaction by object queries.
Through object queries, the motion compensation can be conveniently applied based on estimated states ${F}^{t-1}_{obj}$. 

\begin{equation}\label{eq_compensation}
\begin{aligned}
\tilde{F}^{t-1}_{obj} = \mu({F}^{t-1}_{obj} , M)
\end{aligned}
\end{equation}

where $\mu$ is an explicit linear velocity model or implicit function to encode motion attributes $M$ (including the relative time interval $\triangle t$, estimated velocity $v$, and ego-pose matrix $E$, which are the same definition in Sec.~\ref{sec_method}).
Further, a global attention $\varphi$ is constructed to propagate temporal information through object queries frame by frame:

\begin{equation}\label{eq_object}
\begin{aligned}
\tilde{F}^{t}_{obj} = \varphi(\tilde{F}^{t-1}_{obj}, F^{t}_{obj})
\end{aligned}
\end{equation}

\section{Method}
\label{sec_method}
\subsection{Overall Architecture}
As illustrated in Fig.~\ref{architecture}, StreamPETR is built upon end-to-end sparse query-based 3D object detectors~\cite{liu2022petr, wang2022detr3d}. It consists of an image encoder, a recursively updated memory queue, and a propagation transformer~\cite{vaswani2017attention}. The image encoder is a standard 2D backbone, which is applied to extract semantic features from multi-view images. Then the extracted features, information in the memory queue, and object queries are fed into the propagation transformer to perform the spatial-temporal interaction. The main difference between StreamPETR and single-frame baseline is the memory queue, which recursively updates the temporal information of object queries. Combined with the propagation transformer, the memory queue can propagate temporal priors from previous to current frames efficiently.


\subsection{Memory Queue}
We design a memory queue of $N\times K$ for effective temporal modeling. $N$ is the number of stored frames and $K$ is the number of objects stored per frame. According to the experience, we set $N=4$ and $K=256$ (ensuring high recall in complex scenarios). After the preset time interval $\tau$, the relative time interval $\triangle t$, context embedding $Q_{c}$, object center $Q_{p}$, velocity $v$, and ego-pose matrix $E$ of selected object queries are stored in memory queue. Specifically, the above information, corresponding to foreground objects (with top-$K$ highest classification score), is selected and pushed into the memory queue. The entrance and exit of the memory queue follow the first-in, first-out (FIFO) rule. When information from a new frame is added to the memory queue, the oldest is discarded. Actually, the proposed memory queue is highly flexible and customized, users can freely control the maximal memory size $N\times K$ and saving interval $\tau$ during both training and inference.  


\subsection{Propagation Transformer}
\label{propagation_transformer}
As illustrated in Fig.~\ref{transformer}, the propagation transformer consists of three main components:  (1) the motion-aware layer normalization module implicitly updates the object state according to the context embedding and motion information recorded in the memory queue; (2) the hybrid attention replaces the default self-attention operation. It plays the role of temporal modeling and removing duplicated predictions; (3) the cross-attention is adopted for feature aggregation. It can be replaced with an arbitrary spatial operation to build the relationship between image tokens and 3D object queries, such as global attention in PETR~\cite{liu2022petr} or sparse projective attention in DETR3D~\cite{wang2022detr3d}. 


\noindent\textbf{Motion-aware Layer Normalization}
% The motion-aware layer normalization 
is designed to model the movement of objects. For simplicity, we take the transformation process from the last frame $t-1$ as the example and adopt the same operation for other previous frames. Given the ego pose matrix from the last frame $E_{t-1}$ and current frame $E_{t}$, the ego transformation $E_{t-1}^{t}$ can be calculated as:
\begin{equation}
\label{explicit_align_1}
E_{t-1}^{t} =\ E_{t}^{inv}\cdot\ E_{t-1} 
\end{equation} 
Assume that objects are static, 3D centers $Q_{p}^{t-1}$ in memory queue can be explicitly aligned to the current frame, which is formulated as:

\begin{equation}
\label{explicit_align_2}
\tilde{Q}_{p}^{t} = E_{t-1}^{t} \cdot Q_{p}^{t-1}
\end{equation}

\input{tables/main_val_set_v1}

where $\tilde{Q}_{p}^{t}$ is the aligned centers. Motivated by the task-specific control in generative model~\cite{dumoulin2016learned, park2019gaugan, zhang2023adding}, we adopt a conditional layer normalization to model the movement of the objects. As shown in Fig.~\ref{transformer}, the default affine transformation in layer normalization (LN) is closed. The motion attributes ($E_{t-1}^{t}, v, \triangle t$)  are flattened and converted to affine vectors $\gamma$ and $\beta$ by two linear layers ($\xi_1$, $\xi_2$):
\begin{equation}
    \label{motion-ln-mlp}
    \begin{aligned}
    \gamma &= \xi_1(E_{t-1}^{t}, v, \triangle t) ,\\   
    \beta &= \xi_2(E_{t-1}^{t}, v, \triangle t)
    \end{aligned}
\end{equation}

Afterward, the affine transformation is performed to get the motion-aware context embedding $\tilde{Q}_{c}^{t}$ and motion-aware position encoding 
$\tilde{Q}_{pe}^{t}$. 

% \vspace{-1.5em}
% The whole operation is formulated as:
\begin{equation}
    \label{motion-ln}
    \begin{aligned}
    \tilde{Q}_{pe}^{t}&=\gamma \cdot LN(\psi(\tilde{Q}_{p}^{t})) + \beta ,\\
    \tilde{Q}_{c}^{t} &=\gamma \cdot LN(Q_{c}^{t}) + \beta
    \end{aligned}
% \vspace{-1.5em}
\end{equation}
% \vspace{-1.5em}

where $\psi$ is a multi-layer perceptron (MLP) that converted the 3D sampled points $\tilde{Q}_{p}^{t}$ into position encoding $\tilde{Q}_{pe}^{t}$. For the sake of unification, the MLN is also adopted into current object queries. The velocity $v$ and time interval $\triangle t$ of the current frame are zero-initialized.

\noindent\textbf{Hybrid Attention layer.} 
The self-attention in DETR~\cite{carion2020detr} contributes to duplicated prediction removal. We replace it with hybrid attention, which additionally introduces temporal interaction. As shown in Fig.~\ref{transformer}, all stored object queries in the memory queue are concatenated with current queries to obtain the hybrid queries. The hybrid queries are regard as the $key$ and $value$ in multi-head attention. Since the number of hybrid queries is small (about 2$k$, which is far less than image tokens in the cross-attention), the hybrid attention layer brings negligible computation cost.

Following PETR~\cite{liu2022petr}, the $query$ can be defined as a randomly initialized 3D anchor. To fully utilize the spatial and context priors in streaming video, some object queries in the memory queue are directly propagated into the current frame. In our implementation, queries from the last frame are concatenated with randomly initialized queries. For a fair comparison, the number of randomly initialized queries and propagated queries are set to 644 and 256 respectively.

\input{tables/main_test_set_v0}

\section{Experiments}
\subsection{Dataset and Metrics}
We evaluate our approach on the large-scale NuScenes dataset~\cite{caesar2020nuscenes} and Waymo Open dataset~\cite{sun2020scalability}.

\noindent\textbf{The nuScenes Dataset} includes 1000 scenes, which are 20 seconds in length and annotated at 2Hz. The camera rig covers the full 360Â° field of view (FOV). The annotations contain up to 1.4M 3D bounding boxes, and 10 common classes are used for evaluation: car, truck, bus, trailer, construction vehicle, pedestrian, motorcycle, bicycle, barrier, and traffic cone. We compare the methods with the following metrics, the nuScenes Detection Score (NDS), mean Average Precision (mAP), and 5 kinds of True Positive (TP) metrics including average translation error (ATE), average scale error (ASE), average orientation error (AOE), average velocity error (AVE), average attribute error (AAE). Following the standard evaluation
metrics, we report the average multi-object tracking accuracy (AMOTA), average multi-object tracking precision
(AMOTP), recall (RECALL), multi-object tracking
accuracy (MOTA) and ID switch (IDS) for 3D object tracking task.

\noindent\textbf{Waymo Open Dataset} collects camera data only spanning a horizontal FOV of ~230 degrees. The ground truth bounding boxes are annotated to a maximum range of 75 meters. The longitudinal error tolerant metrics LET-3D-AP, LET-3D-AP-H and LET-3D-APL are used for evaluation. Noting that we only use 20\% of training data for fair comparison according to common practice.
\vspace{-0.25cm}
\input{tables/main_tracking_test_set}
\subsection{Implementation Details}
We conduct experiments with ResNet50~\cite{he2016resnet}, ResNet101, V2-99~\cite{lee2019energy} and ViT~\cite{dosovitskiy2020image} backbones under different pre-training. Following previous methods~\cite{li2022bevformer, liu2022petr, park2022time}, the performance of ResNet50 and ResNet101 models with pre-trained weights ImageNet~\cite{deng2009imagenet} and nuImages~\cite{caesar2020nuscenes} are provided on the nuScenes val set. To scale up our method, we also report results on the nuScenes test set with V2-99 initialized from DD3D~\cite{park2021dd3d} checkpoint 
% and ConvNext~\cite{liu2022convnet} benefited from nuImages pre-training.
and ViT-Large~\cite{dosovitskiy2020image}.
Following BEVFormerv2~\cite{yang2022bevformer}, the ViT-Large~\cite{dosovitskiy2020image} is pre-trained on  Objects365~\cite{shao2019objects365} and COCO~\cite{lin2014microsoft} dataset.

StreamPETR is trained by AdamW~\cite{loshchilov2017decoupled} optimizer with a batch size of 16. The base learning rate is set to 4e-4 and the cosine annealing policy is employed. Only key frames are used during both training and inference.  All experiments are conducted without CBGS~\cite{zhu2019class} strategy. Our implementation is mainly based on Focal-PETR~\cite{wang2022focal}, which introduces auxiliary 2D supervision. The models in the ablation study are trained for 24 epochs, while trained for 60 epochs when compared with others. In particular, we only train 24 epochs for ViT-L~\cite{dosovitskiy2020image} to prevent over-fitting. For image and BEV data augmentation, we adopt the same methods as PETR~\cite{huang2021bevdet,liu2022petr}. We randomly skip 1 frame during the training sequence for temporal data augmentation~\cite{li2022bevformer}. 

\input{tables/Waymo_val}

\subsection{Main Results}
\noindent\textbf{NuScenes Dataset.} We compare the proposed StreamPETR with previous state-of-the-art vision-based 3D detectors on the nuScenes val and test set. As shown in Tab.~\ref{tab:main_val_set}, StreamPETR shows superior performance on mAP, NDS, mASE, and mAOE metrics when adopting ResNet101 backbone with nuImages pretraining. Compared with the single frame baseline Focal-PETR, StreamPETR has  considerable improvements of 11.4\% mAP and 13.1\% NDS. The mATE of StreamPETR is 10.9\% better than Focal-PETR, indicating that our object-centric temporal modeling is able to improve both the accuracy of localization. With image resolutions of 256$\times$704 and adopting ResNet50 backbone, StreamPETR exceeds the state-of-the-art method (SOLOFusion) by 0.5 \% mAP and 0.6 \% NDS.  When we reduce the number of queries and apply nuImages pre-training, our method has 2.3 \% and 1.6 \% advantages in mAP and NDS. At the same time, the inference speed of StreamPETR is 1.8$\times$ faster.


 When we compare the performance on the test set in Tab.~\ref{tab:main_test_set} and adopt a smaller V2-99 backbone, StreamPETR can surpass SOLOFusion with  ConvNext-Base backbone by 1.0\% mAP and 1.7\% NDS. 
 % Scaling up the backbone to ConvNext-Base, StreamPETR achieves 55.0\% of mAP, 63.1\% of NDS, and 24.3\% of mAVE. We conjecture that due to the global receptive field brought by the PETR head, the improvement of a larger backbone is limited.
Scaling up the backbone to ViT-Large~\cite{dosovitskiy2020image}, StreamPETR achieves 62.0\% of mAP, 67.6\% of NDS, and 25.8\% of mAOE. Note that it is the first online multi-view method that achieves comparable performance with CenterPoint.

For 3D multi-object tracking task, we simply extend the multi-object tracking of CenterPoint~\cite{yin2021center} to the multi-view 3D setting. Owing to the exceptional detection and velocity estimation performance, StreamPETR significantly outperforms ByteTrackv2~\cite{zhang2023bytetrackv2} with an impressive margin of +8.9\% AMOTA in Tab.~\ref{tab:tracking}. 
Furthermore, StreamPETR excels over CenterPoint~\cite{yin2021center} in AMOTA, and demonstrates superior benefits in RECALL. 

\begin{figure}[t]
\centering
\includegraphics[scale=0.15]{figs/motion_static_ap.pdf}
\caption{The mAP results with different distance thresholds (Dist TH) on the nuScenes val set. $*$ indicates StreamPETR without the proposed motion-aware layer normalization. Top: Boxes with a velocity lower than 1m/s are maintained for analysis. Down: Boxes with a velocity higher than 1m/s are maintained for analysis.}
\label{moving_static_ap}
\vspace{-0.5cm}
\end{figure}

\noindent\textbf{Waymo Open Dataset.} 
In this section, we provide experimental results on the Waymo val set, as shown in Tab.~\ref{tab:waymo_val}. Our model has trained 24 epochs and the saving interval of the memory queue is set to 5. It can be seen that our method shows superiority in official metrics compared with the dense BEV methods, \eg BEVFormer++~\cite{ZhiqiLi2023BEVFormer} and MV-FCOS3D++~\cite{wang2022mv}. The Waymo open dataset has a larger evaluation range than nuScenes, our object-centric modeling method still shows obvious advantages in localization capability and longitudinal prediction. We also re-implemented PETR-DN and PETRv2 (all with query denoising~\cite{li2022dn}) as baseline models. StreamPETR outperforms the single-frame PETR-DN with a margin of 4.1\% mAPL, 5.1\% mAP, and 5.5\% mAP-H. The Waymo open dataset covers part of the horizontal FOV, while object-centric temporal modeling still brings significant improvement. When we adopt the checkpoint and adjust saving interval $\tau$ to 1 during testing, StreamPETR has slight performance degradation, proving the adaptability on sensor frequency.

\subsection{Ablation Study \& Analysis}
\noindent\textbf{Impact of Training Sequence Length.} 
StreamPETR is trained in local sliding windows and tested in online streaming video. To analyze the inconsistency between training and testing, we conduct experiments with varying numbers of training frames and show results in Tab.~\ref{tab:ablation_time_window}. When adding more training frames, the performance of StreamPETR continues to grow, and the performance gap between sliding windows and online video decreases obviously. It is worth noting that when the number of training frames increases to 8, video testing (40.2\% mAP, 50.5\% NDS) shows superior performance than the sliding window (39.6\% mAP, 50.1\% NDS), which proves that our method has a good potential to build long-term temporal dependency. Expanding to 12 frames brings limited performance improvement, so we train our models on 8 frames for experimental efficiency.

\noindent\textbf{Effect of Motion-aware Layer Normalization.}
We compare the different designs for decoupling the ego vehicle and moving objects in Tab.~\ref{tab:motion_ln_ablation}. It can be seen that the performance does not improve when adopting explicit motion compensation (MC). We argue that the explicit way may cause error propagation in the early training phase. The MLN implicitly encodes and decouples the movements of the ego vehicle and moving objects. Specifically, implicit encoding of ego poses has achieved significant improvements, among which mAP increases by 2.0\% and NDS increases by 1.8\%. Besides, the encoding of relative time offset $\triangle t$ and object velocity $v$ can further boost the performance. Both mAP and NDS are increased by 0.4\%, which indicates that dynamic properties have a beneficial effect on the temporal interaction between object queries.
% E_{t-1}^{t}, v, \triangle t

\input{tables/ablation_time_window}
\input{tables/ablation_motion_ln}
\input{tables/ablation_memory_len}

\begin{figure*}[t]
\centering
\includegraphics[scale=0.1]{figs/vis.pdf}
\caption{Visualization results of StreamPETR. On the BEV plane (right), the groud-truth and predictions are drawn in green and blue rectangles respectively. The failure cases are marked by red circles.}
\label{scene_vis}
\vspace{-0.4cm}
\end{figure*}

\noindent\textbf{Number of Frames for Long-term Fusion.}
In Tab.~\ref{tab:ablation_memory_len}, we analyze the impacts of memory size on hybrid attention. We can find that the mAP and NDS are improved with the increase of the memory size and begin to saturate when reaching 2 frames (nearly 1 second). The object query in StreamPETR is propagated and updated recursively, so even without a large-capacity memory queue, our method can still build a long-term spatial-temporal dependency. Since increasing the memory queue brings negligible computing costs, we use 4 frames to alleviate forgetting and obtain more stable results.

\noindent\textbf{Perspective v.s. Object-Centric.}
StreamPETR achieves efficient temporal modeling through the interaction of sparse object queries. An alternative solution is to build temporal interaction via the perspective memory~\cite{liu2022petrv2}. As shown in Tab.~\ref{tab:ablation_dual_memory}, the query-based temporal modeling has superior performance than perspective-based both on speed and accuracy. The combination of the query and perspective memory does not further improve the performance, implying that the temporal propagation of global query interaction is sufficient to achieve leading performance. Besides, concatenating current object queries with the queries of the last frame improves 0.7\% mAP and 0.9\% NDS.



\noindent\textbf{Analysis of Moving Objects.} In this section, we detailed analyze the performance of StreamPETR on perceiving static and moving objects respectively. For fair comparisons, all models are trained with 24 epochs without CBGS~\cite{zhu2019class} and evaluated on the nuScenes ~\cite{caesar2020nuscenes} val set. The detection performance of moving objects still lags behind that of static objects to a large margin even with temporal modeling. Compared with dense BEV paradigms~\cite{li2022bevstereo, huang2022bevpoolv2}, StreamPETR$*$ has reached promising performance on both static and moving objects. This proves the superiority of object-centric temporal modeling, which has global temporal and spatial receptive fields. Applying the implicit encoding for motion information, the performance of StreamPETR can be further improved.

\input{tables/ablation_dual_memory}
\subsection{Failure Cases}
We show the detection results of a challenging scene in Fig.~\ref{scene_vis}. 
StreamPETR shows impressive results on crowded objects within the detection range of 30m. However, our method has many False Positives on remote objects. It is a common phenomenon of camera-based methods.
In a complex urban scene, the duplicated predictions on remote objects can be tolerable and cause relatively little impact.
% This may be caused by the fact that we do not introduce an explicit depth prior to the network. 
% In a complex urban scene, the duplicated predictions on remote objects can be tolerable on downstream tasks and cause relatively little impact.

\section{Conclusion}
In this paper, we propose StreamPETR, an effective long-sequence 3D object detector. Different from the previous works, our method explores an object-centric paradigm that propagates temporal information through object queries frame by frame. In addition, a motion-aware layer normalization is adopted to introduce the motion information. StreamPETR achieves leading performance improvements while introducing negligible storage and computation cost. It is the first online multi-view method that achieves comparable performance with lidar-based methods. We hope StreamPETR can provide some new insights into long-sequence modeling for the community.

% \noindent\textbf{Limitations and Future Work.}
% Our method has limited performance gain when adopting a larger backbone, e.g. ConvNext-Base, as shown in Tab.~\ref{tab:main_test_set}. In the future, we will conduct more experiments to verify the performance on large-scale models.


\section*{A. Appendix}
\subsection*{A.1. Algorithm Workflow}
\input{tables/algorithm}
The workflow of our proposed Propagation Transformer is shown in Alg.~\ref{alg:streampetr}, which is divided into four stages:

(1) The motion compensation takes the information of the memory queue as input (including the relative time interval $\triangle t$, context embedding $Q_{c}$, object center $Q_{p}$, velocity $v$, and ego-pose matrix $E$). The object 3D centers ${Q}_{p}^{t-N:t-1}$ in the memory queue are explicitly aligned to the current frame according to the ego pose $Ego$. Then the aligned centers $\Tilde{Q}_{p}^{t-N:t-1}$ are used to generate position encoding of object query by a single MLP layer $\psi$. Afterward, we apply the Motion aware Layer Normalization (MLN) to encode motion information $M$ into the historical queries.

(2) The generation of the object queries is mainly based on the learnable query embedding $[Q_{pe}^{init}, Q_{c}^{init}]$ and the obtained propagated query embedding $[\Tilde{Q}_{pe}^{t-1}, \Tilde{Q}_{c}^{t-1}]$ from the last frame $t-1$.

(3) The spatial-temporal interaction of the Propagation Transformer has stacked L layers of the hybrid attention ($Hybrid\_Attn$) and cross attention ($Cross\_Attn$). For each layer, the hybrid attention performs the interaction of current queries $[Q_{c}^{i}, Q_{pe}^{i}]$ and historical queries $[\Tilde{Q}_{c}^{hybrid}, \Tilde{Q}_{pe}^{hybrid}]$, and the cross attention performs the interaction of current queries and image tokens $[F_{2d}^t, F_{3d\_pe}^t]$. $F_{3d\_pe}^t$ is the 3D position encoding proposed in PETR~\cite{liu2022petr}.

(4) After the layer-by-layer refinement, a 3D Head ($Head$) are conducted to generate the predictions. Then we select top-K foreground objects according to the classification scores and push the information of the selected objects to the memory queue \mathbi{X}. 
\input{tables/flash_attn}
\subsection*{A.2. Additional Details}
Qualitative results of StreamPETR are provided in \href{https://drive.google.com/file/d/1vNY2o6-QwR1dWj8H7BdzTR0VDSXMoJcY/view?usp=sharing}{video}.

Here we provide more details for reproducing the results. First, we detach the gradient of the first 6 frames and compute the gradient and losses of the last 2 frames,  which can accelerate the convergence. We additionally adopt Flash Attention~\cite{dao2022flashattention} to further save the GPU memory, as shown in Tab.~\ref{tab:fash_attn}. The query denoising~\cite{li2022dn} is also conducted following PETRv2~\cite{liu2022petrv2}. When measuring the inference speed, we close the Flash Attention.

\input{tables/ablation_detr3d}
\subsection*{A.3. Extension of Our Method}
% \noindent\textbf{Extension of Our Method.}
To verify the extensibility of our method, we conduct experiments on another sparse query base model DETR3D~\cite{wang2022detr3d}. We use ResNet101-DCN as the backbone, without additional augmentation and CBGS~\cite{zhu2019class}. Results in Tab.~\ref{tab:ablation_detr3d} show that StreamDETR3D brings 4.9\%  and 6.8\% improvements on mAP and NDS, while the inference speed is little impacted. Compared with the PETR paradigm, the improvement of DETR3D is relatively small. One possible reason is that the local spatial attention
adopted by DETR3D limits the performance.



{\small
\bibliographystyle{ieee_fullname}
\bibliography{egbib}
}
\end{document}
