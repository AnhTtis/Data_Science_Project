\documentclass[11pt,pdfa]{article}
\usepackage[in]{fullpage}
\usepackage{palatino}

% Unicode compatibility
%\usepackage{iftex}
%\ifPDFTeX
%  \usepackage[utf8]{inputenc}
%  \usepackage[noTeX]{mmap}
%  \usepackage[T1]{fontenc}
%\fi
% XeTeX does not support mmap
%\ifLuaTeX
%  \usepackage{luatex85}
%  \usepackage[noTeX]{mmap}
%\fi

\usepackage[style=alphabetic,minalphanames=3,maxalphanames=4,maxnames=99,backref=true]{biblatex}
  \renewcommand*{\labelalphaothers}{\textsuperscript{+}}
  \renewcommand*{\multicitedelim}{\addcomma\space}
  \addbibresource{crypto.bib}\addbibresource{custom.bib}

\usepackage[normalem]{ulem}
\usepackage{comment}
\usepackage[shortlabels]{enumitem}
\usepackage{bm}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{qtree}
\usepackage{tree-dvips}
\usepackage{float}
\usepackage{hyperref}
\usepackage{physics}
\usepackage{breakurl}
\usepackage{braket}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{qcircuit}
\usepackage[nameinlink,capitalize]{cleveref}

\newcommand{\fullversion}[1]{#1}
\newcommand{\subversion}[1]{}

  \hypersetup{colorlinks={true},linkcolor={blue},citecolor=magenta}

  \theoremstyle{plain}
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{lemma}[theorem]{Lemma}
  %\newtheorem{claim}{Claim}
  %\Crefname{claim}{Claim}{Claims}
  %\newtheorem*{lemma*}{Lemma}
  \newtheorem{corollary}[theorem]{Corollary}
  %\newtheorem{proposition}{Proposition}
  %\newtheorem{observation}{Observation}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{claim}[theorem]{Claim}
  \newtheorem{importedtheorem}[theorem]{Imported Theorem}
 \newtheorem{construction}{Construction}
 \newtheorem{conjecture}{Conjecture}
  
  %\usepackage[numbers,sort&compress]{natbib}
  %\def\bibfont{\footnotesize}
  %\def\bibsep{\smallskipamount}
  %\def\bibhang{24pt}
  
  %\bibliographystyle{alpha}
  
  \usepackage[style=alphabetic,minalphanames=3,maxalphanames=4,maxnames=99,backref=true]{biblatex}
  \renewcommand*{\labelalphaothers}{\textsuperscript{+}}
  \renewcommand*{\multicitedelim}{\addcomma\space}
  
  \newcommand{\email}[1]{\href{mailto:#1}{\texttt{#1}}}
\newtheorem{fact}[theorem]{Fact}
\newcommand{\samptd}{\mathsf{SampTD}}
\newcommand{\GenTrap}{\mathsf{GenTrap}}

\newcommand{\algo}{\mathcal}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\mxA}{\mathbf{A}}
\newcommand{\bfA}{\mxA}
\newcommand{\mxtd}{\mathbf{T}}
%\newcommand{\Tr}{\mathrm{Tr}}
\newcommand{\bfs}{{\bf s}}
\newcommand{\sk}{\mathsf{sk}\xspace}
\newcommand{\pk}{\mathsf{pk}\xspace}
\newcommand{\mpk}{\mathsf{mpk}\xspace}
\newcommand{\msk}{\mathsf{msk}\xspace}
\newcommand{\vk}{\mathsf{vk}\xspace}
\newcommand{\ct}{\mathsf{CT}\xspace}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\setup}{\mathsf{KeyGen}}
\newcommand{\bit}{\{0,1\}}
\newcommand{\Eval}{\mathsf{Eval}}
\newcommand{\SIS}{\mathsf{SIS}}
\newcommand{\ISIS}{\mathsf{ISIS}}
\newcommand{\LWE}{\mathsf{LWE}}
\newcommand{\enc}{\mathsf{Enc}}
\newcommand{\PKE}{\ensuremath{\mathsf{PKE}}\xspace}
\newcommand{\Revoke}{\mathsf{Revoke}}
\DeclareMathAlphabet\mathbfcal{OMS}{cmsy}{b}{n}
\newcommand{\FHE}{\ensuremath{\mathsf{FHE}}\xspace}
\newcommand{\proj}[1]{\ensuremath{|#1\rangle \langle #1|}}
\newcommand{\regR}{\mathbf{R}}
\newcommand{\regX}{\mathbf{X}}
\newcommand{\extractor}{{\cal E}}
\newcommand{\setS}{{\cal S}}

\newcommand{\keygen}{\mathsf{KeyGen}}
\newcommand{\KeyGen}{\mathsf{KeyGen}}
\newcommand{\Del}{\mathsf{Del}}
\newcommand{\Vrfy}{\mathsf{Vrfy}}
\newcommand{\PPT}{\mathsf{PPT}}
\newcommand{\POVM}{\mathsf{POVM}}
\newcommand{\Invert}{\mathsf{Invert}}
\newcommand{\QPT}{\mathsf{QPT}}
\newcommand{\CPTP}{\mathsf{CPTP}}
\newcommand{\aux}{\mathsf{aux}}
\newcommand{\FT}{\mathsf{FT}}
\newcommand{\dec}{\mathsf{Dec}}
\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
\newcommand{\rand}{\raisebox{-1pt}{\ensuremath{\,\xleftarrow{\raisebox{-1pt}{$\scriptscriptstyle\$$}}\,}}}
\newcommand{\expt}{\mathsf{Expt}}
\newcommand{\ch}{\mathsf{Ch}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\valid}{\mathsf{Valid}}
\newcommand{\invalid}{\mathsf{Invalid}}
%\newcommand{\bfX}{\mathbf{X}}
%\newcommand{\tr}{\mathsf{Tr}}
%\newcommand{\ketbra}[2]{\left|#1\right\rangle\!\!\left\langle #2\right|}
\newcommand{\negl}{\mathsf{negl}}
\newcommand{\bfP}{\mathbf{P}}
\newcommand{\bfv}{\mathbf{v}}
\newcommand{\bfR}{\mathbf{R}}
\newcommand{\bfB}{\mathbf{B}}

\newcommand{\bfT}{\mathbf{T}}
\newcommand{\bfx}{\mathbf{x}}
\newcommand{\bft}{\mathbf{t}}
\newcommand{\bfG}{\mathbf{G}}
\newcommand{\distr}{\mathcal{D}}
% Bold vectors instead of arrow vectors

\newcommand{\alex}[1]{{\color{blue} Alex: #1 }}
\newcommand{\james}[1]{{\color{red} James: #1 }}
\newcommand{\dakshita}[1]{{\color{orange} Dakshita: #1 }}

\title{Publicly-Verifiable Deletion via Target-Collapsing Functions}
%or\\
%Cryptography with Publicly-Verifiable Deletion\\
%or\\
%\title{
%Target-Collapsing Hashes and Publicly-Verifiable Deletion}
\author{James Bartusek\footnote{bartusek.james@gmail.com}\\UC Berkeley\and 
Dakshita Khurana\footnote{dakshita@illinois.edu}\\UIUC \and 
Alexander Poremba\footnote{{aporemba@caltech.edu}}\\Caltech
}
\date{}


\newcommand{\poly}{\mathrm{poly}}

%\input{headers}
\input{macros}
\begin{document}

\maketitle

\begin{abstract}

We build quantum cryptosystems that support publicly-verifiable deletion from standard cryptographic assumptions. We introduce target-collapsing as a weakening of collapsing for hash functions, analogous to how second preimage resistance weakens collision resistance; that is, target-collapsing requires indistinguishability between superpositions and mixtures of preimages of an honestly sampled image. 

We show that target-collapsing hashes enable publicly-verifiable deletion ($\PVD$), proving 
conjectures from [Poremba, ITCS'23] and demonstrating that the Dual-Regev encryption (and corresponding fully homomorphic encryption) schemes support $\PVD$ under the LWE assumption. 
We further build on this framework to obtain a variety of primitives supporting publicly-verifiable deletion from weak cryptographic assumptions, including:
\begin{itemize}
    \item Commitments with $\PVD$ assuming the existence of injective one-way functions, or more generally, {\em almost-regular} one-way functions. Along the way, we demonstrate that (variants of) target-collapsing hashes can be built from almost-regular one-way functions.
    \item Public-key encryption with $\PVD$ assuming trapdoored variants of injective (or almost-regular) one-way functions. We also
    demonstrate that the encryption scheme of [Hhan, Morimae, and Yamakawa, Eurocrypt'23] based on pseudorandom group actions
    has $\PVD$.
    \item $X$ with $\PVD$ for $X \in \{$attribute-based encryption, quantum fully-homomorphic encryption, witness encryption, time-revocable encryption$\}$,
    assuming $X$ and trapdoored variants of injective (or almost-regular) one-way functions.  
\end{itemize}
\end{abstract}

\newpage
\tableofcontents

\newpage
\input{intro}

\section{Preliminaries}

In this section, we review basic concepts from quantum computing and cryptography.

\subsection{Quantum Computing}

We refer to \cite{NielsenChuang11,Wilde13} for a comprehensive background on quantum computation. 

A finite-dimensional complex Hilbert space is denoted by $\mathcal{H}$, and we use subscripts to distinguish between different systems (or registers); for example, we let $\mathcal{H}_{\mathsf{A}}$ be the Hilbert space corresponding to a system $\mathsf{A}$. 
The tensor product of two Hilbert spaces $\algo H_{\mathsf{A}}$ and $\algo H_{\mathsf{B}}$ is another Hilbert space denoted by $\algo H_{\mathsf{AB}} = \algo H_{\mathsf{A}} \otimes \algo H_{\mathsf{B}}$.  We let $\algo L(\algo H)$
denote the set of linear operators over $\algo H$.
A quantum system over the $2$-dimensional Hilbert space $\mathcal{H} = \mathbb{C}^2$ is called a \emph{qubit}. For $n \in \mathbb{N}$, we refer to quantum registers over the Hilbert space $\mathcal{H} = \big(\mathbb{C}^2\big)^{\otimes n}$ as $n$-qubit states. We use the word \emph{quantum state} to refer to both pure states (unit vectors $\ket{\psi} \in \mathcal{H}$) and density matrices $\rho \in \mathcal{D}(\mathcal{H)}$, where we use the notation $\mathcal{D}(\mathcal{H)}$ to refer to the space of positive semidefinite linear operators of unit trace acting on $\algo H$. 
Occasionally, we consider \emph{subnormalized states}, i.e. states in the space of positive semidefinite operators over $\algo H$ with trace norm not exceeding $1$.

The \emph{trace distance} of two density matrices $\rho,\sigma \in \mathcal{D}(\mathcal{H)}$ is given by
$$
\TD(\rho,\sigma) = \frac{1}{2} \Tr\left[ \sqrt{ (\rho - \sigma)^\dag (\rho - \sigma)}\right].
$$

A quantum channel $\Phi:  \algo L(\algo H_{\mathsf{A}}) \rightarrow \algo L(\algo H_{\mathsf{B}})$ is a linear map between linear operators over the Hilbert spaces $\algo H_{\mathsf{A}}$ and $\algo H_{\mathsf{B}}$. 
We say that a channel $\Phi$ is \emph{completely positive} if, for a reference system $R$ of arbitrary size, the induced map $I_R \otimes \Phi$ is positive, and we call it \emph{trace-preserving} if $\Tr[\Phi(X)] = \Tr[X]$, for all $X\in \algo L(\algo H)$. A quantum channel that is both completely positive and trace-preserving is called a quantum $\CPTP$ channel. 

A polynomial-time \emph{uniform} quantum algorithm (or $\QPT$ algorithm) is a polynomial-time family of quantum circuits given by $\algo C = \{C_\lambda\}_{\lambda \in \N}$, where each circuit $C \in \algo C$ is described by a sequence of unitary gates and measurements; moreover, for each $\lambda \in \N$, there exists a deterministic polynomial-time Turing machine that, on input $1^\lambda$, outputs a circuit description of $C_\lambda$. Similarly, we also define (classical) probabilistic polynomial-time $(\PPT)$ algorithms. A quantum algorithm may, in general, receive (mixed) quantum states as inputs and produce (mixed) quantum states as outputs. Occasionally, we restrict $\QPT$ algorithms implicitly; for example, if we write $\Pr[\mathcal{A}(1^{\lambda}) = 1]$ for a $\QPT$ algorithm $\mathcal{A}$, it is implicit that $\mathcal{A}$ is a $\QPT$ algorithm that outputs a single classical bit.

\paragraph{Quantum Fourier transform.} Let $q \geq 2$ be a modulus and $n \in \N$ and let $\omega_q = e^{ \frac{2 \pi i}{q}} \in \mathbb{C}$ denote the primitive $q$-th root of unity.
The $m$-qudit \emph{$q$-ary quantum Fourier transform} over the ring $\Z_q^m$ is defined by the operation,
$$
\FT_q : \quad \ket{\vec x} \quad \mapsto \quad \sqrt{q^{-m}} \displaystyle\sum_{\vec y \in \Z_q^m} \omega_q^{\langle \vec x,\vec y\rangle} \ket{\vec y}, \quad\quad \forall \vec x \in \Z_q^m.
$$
The $q$-ary quantum Fourier transform is \emph{unitary} and can be efficiently implemented on a quantum computer for any integer modulus $q \geq 2$~\cite{892139}.


\paragraph{Pauli Twirling.}

We use the following unitary operators:
\begin{itemize}
    \item Pauli-$\mathsf{Z}$ operator:

    $$
\mathsf{Z}^z = \sum_{x \in \bit} (-1)^{x \cdot z} \proj{x}, \quad \text{ for } z \in \bit.
$$

\item Multi-qubit Pauli-$\mathsf{Z}$ operator:

    $$
\mathsf{Z}^z = \mathsf{Z}^{z_1} \otimes \dots \otimes \mathsf{Z}^{z_m}, \quad \text{ for } z \in \bit^m.
$$

\item Controlled-$\mathsf{Z}$ operator:


    $$
\mathsf{C}\mathsf{Z}^z = \sum_{c \in \bit} \proj{c} \otimes \mathsf{Z}^{c \cdot z}, \quad \text{ for } z \in \bit^m.
$$

\end{itemize}
Here, we use the notation $\mathsf{Z}^0 = I$ and $\mathsf{Z}^1 = \mathsf{Z}$, as well as $c \cdot z = (c \cdot z_1,\dots,c \cdot z_m)$ for $z \in \bit^m$.

We use the following well-known property of the Pauli-$\mathsf{Z}$ dephasing channel which says that, on average, a random Pauli-Z twirl induces a measurement in the computational basis.

\begin{lemma}[Pauli-$\mathsf{Z}$ Twirl]\label{lem:random-Z}
The Pauli-$\mathsf{Z}$ dephasing channel applied to an $m$-qubit state $\rho$ satsifies
$$
\algo Z(\rho) \,\overset{\mathrm{def}}{=} \,\ 2^{-m} \sum_{z \in \bit^m}  \mathsf{Z}^{z} \rho \left(\mathsf{Z}^{z}\right)^\dag= \sum_{x \in \bit^m} \Tr[\ketbra{x}{x} \rho] \,\ketbra{x}{x}.
$$
\end{lemma}



\subsection{Cryptography}

Throughout this work, wet $\lambda\in \N$ denote the security parameter. We assume that the reader is familiar with the fundamental cryptographic concepts. 

\paragraph{The Short Integer Solution problem.}
%\label{sec:sis}

The (inhomogenous) $\SIS$ problem was introduced by Ajtai~\cite{DBLP:conf/stoc/Ajtai96} in his seminal work on average-case lattice problems. The problem is defined as follows. 

\begin{definition}[Inhomogenous SIS problem,\cite{DBLP:conf/stoc/Ajtai96}]\label{def:ISIS} Let $n,m \in \N$ be integers, let $q\geq 2$ be a modulus and let $\beta >0$ be a parameter. The Inhomogenous Short Integer Solution problem $(\ISIS)$ problem is to find a short solution $\vec x \in \Z^m$ with $\|\vec x\| \leq \beta$ such that $\vec A \cdot \vec x = \vec y \Mod{q}$ given as input a tuple $(\vec A \rand \Z_q^{n \times m},\vec y \rand \Z_q^n)$.
The Short Integer Solution $(\SIS)$ problem is a homogenous variant of the $\ISIS$ problem with input $(\vec A \rand \Z_q^{n \times m},\vec 0 \in\Z_q^n)$.
\end{definition}


Micciancio and Regev~\cite{DBLP:journals/siamcomp/MicciancioR07} showed that the $\SIS$ problem is, on the average, as hard as approximating worst-case lattice problems to within small factors. Subsequently, Gentry, Peikert and Vaikuntanathan~\cite{cryptoeprint:2007:432} gave an improved reduction showing that, for parameters $m=\poly(n)$, $\beta=\poly(n)$ and prime $q \geq \beta \cdot \omega(\sqrt{n \log q})$, the average-case $\SIS_{n,q,\beta}^m$ problem is as hard as approximating the shortest independent vector problem $(\mathsf{SIVP})$ problem in the
worst case to within a factor $\gamma = \beta \cdot \tilde{O}(\sqrt{n})$.
We assume that $\SIS_{n,q,\beta}^m$, for $m=\Omega(n \log q)$, $\beta = 2^{o(n)}$ and $q=2^{o(n)}$, is hard against polynomial-time quantum adversaries.

\paragraph{The Learning with Errors problem.}
%\label{sec:lwe}

The \emph{Learning with Errors} problem serves as the primary basis of hardness of post-quantum cryptosystems and was introduced by Regev~\cite{Regev05}. The problem is defined as follows. 


\begin{definition}[Learning with Errors problem, \cite{Regev05}]\label{def:decisional-lwe} Let $n,m \in \N$ be integers, let $q\geq 2$ be a modulus and let $\alpha \in (0,1)$ be a noise ratio parameter. The (decisional) Learning with Errors $(\LWE_{n,q,\alpha q}^m)$ problem is to distinguish between the following samples
$$
(\vec A \rand \Z_q^{n \times m},\vec s^\intercal \vec A+ \vec e^\intercal \Mod{q}) \quad \text{ and } \quad (\vec A \rand \Z_q^{n \times m},\vec u \rand \Z_q^m),\,\,
$$
where $\vec s \rand  \Z_q^n$ is a uniformly random vector and where $\vec e \sim D_{\Z^m,\sigma}$ is a discrete Gaussian error vector, where $D_{\Z^m,\sigma}$
assigns probability proportional to
$\rho_\sigma(\vec x) = \exp(-\pi \|\vec x \|^2/ \sigma^2)$ to each $\vec x \in \Z^m$, for $\sigma = \alpha q>0$.

We rely on the quantum $\LWE_{n,q,\alpha q}^m$ assumption which states that the samples above are computationally indistinguishable for any $\QPT$ algorithm.

\end{definition}

It was shown in~\cite{Regev05,cryptoeprint:2017/258} that the $\LWE_{n,q,\alpha q}^m$ problem with parameter $\alpha q \geq 2 \sqrt{n}$ is at least as hard as approximating the shortest independent vector problem $(\mathsf{SIVP})$ to within a factor of $\gamma = \widetilde{O}(n / \alpha)$ in worst case lattices of dimension $n$. In this work we assume the subexponential hardness of $\LWE_{n,q,\alpha q}^m$ which relies on the worst case hardness of approximating short vector problems in
lattices to within a subexponential factor. 
We assume that $\LWE_{n,q,\alpha q}^m$, for $m=\Omega(n \log q)$, $q=2^{o(n)}$, $\alpha=1/2^{o(n)}$,  is hard against polynomial-time quantum adversaries. 
%We note that this assumption implies  $\SIS_{n,q,\beta}^m$ for the parameters described in~\Cref{sec:sis}. 

\input{main-theorem}




\section{Publicly-Verifiable Deletion from Dual-Regev Encryption}\label{sec:Dual-Regev}

In this section, we recall the constructions of Dual-Regev public-key encryption as well as fully homomorphic encryption with publicly-verifiable deletion introduced by Poremba~\cite{Poremba22}. Using our main result on certified-everlasting target-collapsing hashes in \Cref{thm:CETC-generalization}, we prove the \emph{strong Gaussian-collapsing conjecture} in~\cite{Poremba22}, and then conclude that the aforementioned constructions achieve certified-everlasting security assuming the quantum hardness of $\LWE$ and $\SIS$.

First, let us recall the definition of public-key encryption with publicly-verifiable deletion. 

\subsection{Definition: Encryption with Publicly-Verifiable Deletion}

A public-key encryption (PKE) scheme with publicly-verifiable deletion (PVD) has the following syntax.

\begin{itemize}
    \item $\KeyGen(1^\secp) \to (\pk,\sk)$: the key generation algorithm takes as input the security parameter $\secp$ and outputs a public key $\pk$ and secret key $\sk$.
    \item $\Enc(\pk,m) \to (\vk,\ket{\ct})$: the encryption algorithm takes as input the public key $\pk$ and a plaintext $m$, and outputs a (public) verification key $\vk$ and a ciphertext $\ket{\ct}$.
    \item $\Dec(\sk,\ket{\ct}) \to m$: the decryption algorithm takes as input the secret key $\sk$ and a ciphertext $\ket{\ct}$ and outputs a plaintext $m$.
    \item $\Del(\ket{\ct}) \to \pi$: the deletion algorithm takes as input a ciphertext $\ket{\ct}$ and outputs a deletion certificate $\pi$.
    \item $\Vrfy(\vk,\pi) \to \{\top,\bot\}$: the verify algorithm takes as input a (public) verification key $\vk$ and a proof $\pi$, and outputs $\top$ or $\bot$.
\end{itemize}

\begin{definition}[Correctness of deletion]\label{def:correctness-deletion}
A PKE scheme with PVD satisfies \emph{correctness of deletion} if for any $m$, it holds with $1-\negl(\secp)$ probability over $(\pk,\sk) \gets \Gen(1^\secp), (\vk,\ket{\ct}) \gets \Enc(\pk,m),\pi \gets \Del(\ket{\ct}),\mu \gets \Vrfy(\vk,\pi)$ that $\mu = \top$.
\end{definition}

\begin{definition}[Certified deletion security]\label{def:security-deletion}
A PKE scheme with PVD satisfies \emph{certified deletion security} if it satisfies standard semantic security, and moreover, for any QPT adversary $\{\cA_\secp\}_{\secp \in \bbN}$, it holds that 
\[\TD\left(\mathsf{EvPKE}_{\cA,\secp}(0),\mathsf{EvPKE}_{\cA,\secp}(1)\right) = \negl(\secp),\] where the experiment $\mathsf{EvPKE}_{\cA,\secp}(b)$ is defined as follows.
\begin{itemize}
    \item Sample $(\pk,\sk) \gets \Gen(1^\secp)$ and $(\vk,\ket{\ct}) \gets \Enc(\pk,b)$.
    \item Run $\cA_\secp(\pk,\vk,\ket{\ct})$, and parse their output as a deletion certificate $\pi$ and a left-over quantum state $\rho$.
    \item If $\Vrfy(\vk,\pi) = \top$, output $\rho$, and otherwise output $\bot$.
\end{itemize}
\end{definition}

\ \\
Before we introduce the
Dual-Regev public-key schemes proposed by Poremba~\cite{Poremba22}, let us first recall some basic facts about
Gaussian superpositions.

\subsection{Gaussian 
Superpositions}

Let $m \in \N$. The \emph{Gaussian measure} $\rho_\sigma$ with parameter $\sigma > 0$ is defined as
\begin{align*}
\rho_\sigma(\vec x) = \exp(-\pi \|\vec x \|^2/ \sigma^2), \quad \,\, \forall \vec x \in \mathbb{R}^m.   
\end{align*}
Given a modulus $q \in \N$ and $\sigma \in (\sqrt{2m},q/\sqrt{2m})$, the \emph{truncated} discrete Gaussian distribution $D_{\Z_q^m,\sigma}$ over the finite set $\Z^m \cap (-\frac{q}{2},\frac{q}{2}]^m$ with support $\{\vec x \in \Z_q^m : \|\vec x\| \leq \sigma \sqrt{m}\}$ is defined as
$$
D_{\Z_q^m,\sigma}(\vec x) = \frac{\rho_\sigma(\vec x)}{\displaystyle\sum_{\vec z \in \Z_q^m,\|\vec z\| \leq \sigma\sqrt{m} } \rho_\sigma(\vec z)}.
$$
In this section, we consider
Gaussian superposition states over $\Z^m \cap (-\frac{q}{2},\frac{q}{2}]^m$ of the form
    $$
 \ket{\psi} =    \sum_{\vec x \in \Z_q^m} \rho_\sigma(\vec x) \ket{\vec x}.
    $$
The state $\ket{\psi}$ is not normalized for convenience. A standard tail bound~\cite[Lemma 1.5 (ii)]{Banaszczyk1993} implies that (the normalized variant of) $\ket{\psi}$ is within negligible trace distance of a \emph{truncated} discrete Gaussian superposition $ \ket{\tilde{\psi}}$
with support $\{\vec x \in \Z_q^m : \|\vec x\| \leq \sigma \sqrt{\frac{m}{2}}\}$, where
$$
\ket{\tilde{\psi}}
= 
\left(\sum_{\vec z \in \Z_q^m,\|\vec z\| \leq \sigma \sqrt{\frac{m}{2}} } \rho_{\frac{\sigma}{\sqrt{2}}}(\vec z) \right)^{-\frac{1}{2}}\sum_{\vec x \in \Z_q^m : \|\vec x\| \leq \sigma \sqrt{\frac{m}{2}}}
\rho_\sigma(\vec x) \ket{\vec x}.
$$
Note that a measurement of $\ket{\tilde{\psi}}$ results in a sample from the truncated discrete Gaussian distribution $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$.
We remark that Gaussian superpositions with parameter $\sigma = \Omega(\sqrt{m})$ can be efficiently implemented using standard quantum state preparation techniques; for example using \emph{quantum rejection sampling} and the \emph{Grover-Rudolph algorithm}~\cite{Grover2002CreatingST,Regev05,Brakerski18,brakerski2021cryptographic}.

Let $\vec A \in \Z_q^{n \times m}$. We use the following algorithm, denoted by $\mathsf{GenGauss}(\vec A,\sigma)$ which prepares a partially measured Gaussian superposition of pre-images of a randomly generated image.
\begin{enumerate}
\item Prepare a Gaussian superposition in system $X$ with parameter $\sigma > 0$:
    $$
 \ket{\psi} =    \sum_{\vec x \in \Z_q^m} \rho_\sigma(\vec x) \ket{\vec x} \otimes \ket{\vec 0}.
    $$
\item Apply the unitary $U_{\vec A}: \ket{\vec x}\ket{\vec 0} \rightarrow \ket{\vec x} \ket{\vec A \cdot \vec x \Mod{q}}$, which results in the state
$$
 \ket{ \psi} =   \sum_{\vec x \in \Z_q^m} \rho_\sigma(\vec x) \ket{\vec x} \otimes \ket{\vec A \cdot \vec x \Mod{q}}.
  $$
  \item Measure the second register in the computational basis, which results in $\vec y \in \Z_q^n$ and a state
    $$
    \ket{\psi_{\vec y}} = \sum_{\substack{\vec x \in \Z_q^m:\\ \vec A \vec x= \vec y \Mod{q}}} \rho_\sigma(\vec x) \ket{\vec x}.
    $$
\end{enumerate}

Finally, we use the following lemma which characterizes the Fourier transform of a partially measured Gaussian superposition.

\begin{lemma}[\cite{Poremba22}, Lemma 16]\label{lem:duality}
Let $m \in \N$, $q \geq 2$ be a prime and $\sigma \in (\sqrt{8m},q/\sqrt{8m})$.
Let $\vec A \in \Z_q^{n \times m}$ be a matrix whose columns generate $\Z_q^n$ and let $\vec y \in \Z_q^n$ be arbitrary. Then, the $q$-ary quantum Fourier transform of the (normalized variant of the) Gaussian coset state
$$
 \ket{\psi_{\vec y}} = \sum_{\substack{\vec x \in \Z_q^m\\ \vec A \vec x = \vec y \Mod{q}}}\rho_{\sigma}(\vec x) \ket{\vec x}
$$
is within negligible (in $m \in \N$) trace distance of the (normalized variant of the) Gaussian state
$$
 \ket{\hat\psi_{\vec y}} = \sum_{\vec s \in \Z_q^n} \sum_{\vec e \in \Z_q^m} \rho_{q/\sigma}(\vec e) \, \omega_q^{-\langle\vec s,\vec y \rangle} \ket{\vec s^\intercal \vec A + \vec e^\intercal \Mod{q}}.
$$
\end{lemma}


\subsection{(Strong) Gaussian-Collapsing Property.}

We use the following result which says that the Ajtai hash function is target-collapsing with respect to the truncated discrete Gaussian distribution.

\begin{theorem}[Gaussian-collapsing property, \cite{Poremba22}, Theorem 4]\label{thm:Gauss-collapsing}
Let $n\in \N$ and $q$ be a prime with $m \geq 2n \log q$, each parameterized by $\lambda \in \N$. Let  $\sigma \in (\sqrt{8m},q/\sqrt{8m})$.
Then,
the following samples are computationallyindistinguishable assuming the quantum hardness of decisional $\mathsf{LWE}_{n,q,\alpha q}^m$, for any noise ratio $\alpha \in (0,1)$ with relative noise magnitude $1/\alpha= \sigma \cdot 2^{o(n)}:$
$$
\Bigg(\vec  A \rand \Z_q^{n \times m},\,\, \ket{\psi_{\vec y}}=\sum_{\substack{\vec x \in \Z_q^m\\ \vec A \vec x = \vec y}}\rho_{\sigma}(\vec x) \,\ket{\vec x}, \,\,\vec y\in \Z_q^n \Bigg)\,\, \approx_c \,\,\,\, \Bigg(\vec  A \rand \Z_q^{n \times m}, \,\,\ket{\vec x_0},\,\, \vec A \cdot \vec x_0 \,\in \Z_q^n\Bigg)
$$
where $(\ket{\psi_{\vec y}},\vec y) \leftarrow \mathsf{GenGauss}(\vec A,\sigma)$ and where $\vec x_0 \sim D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$ is a discrete Gaussian error.
\end{theorem}

Using our main theorem on certified-everlasting target-collapsing hashes in \Cref{thm:CETC-generalization}, we can now prove a stronger variant of \Cref{thm:Gauss-collapsing}. We show the following:

\begin{theorem}\label{thm:ajtai-certified-everlasting}
Let $\lambda \in \N$ be the security parameter, $n(\lambda) \in \N$, $q(\lambda) \in \N$ be a modulus, $m \geq 2n \log q$ and $\sigma \in (\sqrt{2m},q/\sqrt{2m})$. Then, the Ajtai hash function family
$\algo H = \{H_\lambda\}_{\lambda \in \N}$ with
$$
H_\lambda = \left\{ h_{\vec A}: \big\{\vec x \in \Z_q^m : \|\vec x\| \leq \sigma \sqrt{m/2}\big\} \rightarrow \Z_q^n \, \text{ s.t. } \, h_{\vec A}(\vec x) = \vec A \cdot \vec x \Mod{q}; \, \vec A \in \Z_q^{n \times m} \right\}.
$$
is certified everlasting $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing assuming the quantum hardness of $\SIS_{n,q,\sigma\sqrt{2m}}^m$ and $\mathsf{LWE}_{n,q,\alpha q}^m$, for any noise ratio $\alpha \in (0,1)$ with relative noise magnitude $1/\alpha= \sigma \cdot 2^{o(n)}$.
\end{theorem}
\begin{proof}
By the Gaussian-collapsing property in \Cref{thm:Gauss-collapsing}, it follows that $\algo H$ is $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing assuming the quantum hardness of $\mathsf{LWE}_{n,q,\alpha q}^m$, for any noise ratio $\alpha \in (0,1)$ with relative noise magnitude $1/\alpha= \sigma \cdot 2^{o(n)}$. Moreover, from the quantum hardness of $\SIS_{n,q,\sigma\sqrt{2m}}^m$ it follows that $\algo H$ is $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collision-resistant. Therefore, the claim follows from \Cref{thm:CETC-generalization}.
\end{proof}

As a corollary, we immediately recover the so-called strong Gaussian-collapsing property of the Ajtai hash function which was previously stated as a conjecture by Poremba~\cite{Poremba22}.

\begin{corollary}[Strong Gaussian-collapsing property]\label{SGC}\ \\
Let $\lambda \in \N$ be the security parameter, $n(\lambda) \in \N$, $q(\lambda) \in \N$ be a modulus and $m > 2n \log q$. Let $\sigma = \Omega(\sqrt{m})$ be a parameter. Then, the Ajtai hash function satisfies the strong Gaussian-collapsing property assuming the quantum hardness of $\SIS_{n,q,\sigma\sqrt{2m}}^m$ and $\mathsf{LWE}_{n,q,\alpha q}^m$, for any noise ratio $\alpha \in (0,1)$ with relative noise magnitude $1/\alpha= \sigma \cdot 2^{o(n)}$. In other words, for every $\QPT$ adversary $\algo A$,
$$
|\Pr[\mathsf{StrongGaussCollapseExp}_{\algo A,n,m,q,\sigma}(0)=1] - \Pr[\mathsf{StrongGaussCollapseExp}_{\algo A,n,m,q,\sigma}(1)=1] \leq \negl(\lambda)
$$
where $\mathsf{StrongGaussCollapseExp}_{\algo A,n,m,q,\sigma}(b)$ is the experiment from \Cref{fig:SGC}.
\end{corollary}
\begin{proof} 
To prove the statement, we can simply reduce the certified everlasting $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing security of the Ajtai hash $\vec A = [\bar{\vec A} \, \| \, \bar{\vec A} \cdot \bar{\vec x} \Mod{q}] \in \Z_q^{n \times m}$ with $\bar{\vec x} \rand \bit^{m-1}$ to the
strong Gaussian-collapsing security, and invoke \Cref{thm:ajtai-certified-everlasting}. Here we rely on the fact that the distribution of $\vec A$ is statistically close to uniform by the leftover hash lemma whenever $m > 2n \log q$. Now consider the unbounded reduction that given $\vec A \in \Z_q^{n \times m}$, samples a uniformly random vector $\vec t = (\vec x,-1) \in \Z^{m}$ with $\vec x \in \bit^{m-1}$ such that $\bar{\vec A} \vec x = \bar{\vec A} \bar{\vec x} \Mod{q}$, and then runs the second part of the strong Gaussian-collapsing adversary on input $\vec t$ in order to predict the challenger's bit. Note that such vectors $\vec t$ exist because of how the matrix $\vec A$ is constructed in the experiment. If the strong Gaussian-collapsing adversary has noticeable advantage, then so does the reduction, which would break the certified everlasting $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing security of the Ajtai hash. 
\end{proof}


\subsection{Dual-Regev Public-Key Encryption with Publicly-Verifiable Deletion}

We now consider the following Dual-Regev encryption scheme introduced by Poremba~\cite{Poremba22}.

\begin{construction}[Dual-Regev $\mathsf{PKE}$ with Publicly-Verifiable Deletion]\label{cons:dual-regev-cd}
Let $n \in \N$ be the security parameter, $m \in \N$ and $q$ be a prime. Let $\alpha \in (0,1)$ and $\sigma = 1/\alpha$ be parameters.
The Dual-Regev $\mathsf{PKE}$ scheme $\mathsf{DualPKECD} = (\KeyGen,\Enc,\Dec,\Del,\Vrfy)$ with certified deletion is defined as follows:
\begin{description}
\item $\KeyGen(1^\lambda) \rightarrow (\pk,\sk):$ sample a random matrix $\bar{\vec A} \rand \Z_q^{n\times m}$ and a vector $\bar{\vec x} \rand \bit^{m}$
and choose $\vec A = [\bar{\vec A} \| \bar{\vec A} \cdot \bar{\vec x} \Mod{q}]$.
Output $(\pk,\sk)$, where $\pk=\vec A \in \Z_q^{n \times (m+1)}$ and $\sk = (-\bar{\vec x}, 1) \in \Z_q^{m+1}$.
\item $\Enc(\pk,b) \rightarrow (\vk,\ket{\ct})$: parse the public key as $\vec A \leftarrow \pk$. To encrypt a single bit $b \in \bit$, generate the following pair for a random $\vec y \in \Z_q^n$:
$$
\vk \leftarrow (\vec A, \vec y), \quad \ket{\ct} \leftarrow \sum_{\vec s \in \Z_q^n} \sum_{\vec e \in \Z_q^{m+1}} \rho_{q/\sigma}(\vec e) \, \omega_q^{-\langle\vec s,\vec y \rangle}\ket{\vec s^\intercal \vec A + \vec e^\intercal +b \cdot (0,\dots,0, \lfloor\frac{q}{2} \rfloor)},
$$
where $\vk$ is the public verification key and $\ket{\ct}$ is an $(m+1)$-qudit quantum ciphertext.


\item $\Dec(\sk,\ket{\ct}) \rightarrow \bit:$ to decrypt, measure $\ket{\ct}$ in the computational basis with outcome $\vec c \in \Z_q^m$. Compute $\vec c^\intercal \cdot \sk \in \Z_q$ and output $0$, if it is closer to $0$ than to $\lfloor\frac{q}{2}\rfloor$, and output $1$, otherwise.

\item $\Del(\ket{\ct}) \rightarrow \pi:$ Measure $\ket{\ct}$ in the Fourier basis and output the measurement outcome $\pi \in \Z_q^{m+1}$.
\item $\Vrfy(\vk,\pi) \rightarrow \{\top,\bot\}:$ to verify a deletion certificate $\pi \in \Z_q^{m+1}$, parse $(\vec A,\vec y) \leftarrow \vk$ and output $\top$, if $\vec A \cdot \pi = \vec y \Mod{q}$ and $\| \pi \| \leq \sqrt{m+1}/\sqrt{2}\alpha$, and output $\bot$, otherwise.
\end{description}
\end{construction}


%%
Let us now illustrate how the deletion procedure takes place. Recall from \Cref{lem:duality} that the Fourier transform of the ciphertext $\ket{\ct}$ results in the \emph{dual} quantum state
\begin{align}\label{eq:dual-with-phase}
\ket{\widehat{\ct}}=\sum_{\substack{\vec x \in \Z_q^{m+1}:\\ \vec A \vec x = \vec y \Mod{q}}}\rho_{\sigma}(\vec x) \, \omega_q^{\langle\vec x,b \cdot (0,\dots,0,  \lfloor\frac{q}{2} \rfloor)\rangle} \,\ket{\vec x}.
\end{align}
In other words, a Fourier basis measurement of $\ket{\ct}$ necessarily erases all information about the plaintext $b \in \bit$ and results in a \emph{short} vector $\pi \in \Z_q^{m+1}$ such that $\vec A \cdot \pi = \vec y \Mod{q}$. Hence, to publicly verify a deletion certificate we can simply check whether it is a solution to the $\ISIS$ problem specified by the verification key $\vk=(\vec A,\vec y)$. Using \Cref{thm:ajtai-certified-everlasting}, we obtain the following:

\begin{theorem}
Let $n\in \N$ and let $q \geq 2$ be a prime modulus such that $q=2^{o(n)}$ and $m \geq 2n \log q$. Let $\sigma \in (\sqrt{8m},q/\sqrt{8m})$ and $\alpha \in (0,1)$ be a noise ratio with $1/\alpha= 2^{o(n)} \cdot \sigma$.
Then, the Dual-Regev public-key encryption scheme in \Cref{cons:dual-regev-cd} has everlasting certified deletion security assuming the quantum (subexponential) hardness of $\mathsf{LWE}_{n,q,\alpha q}^m$ and $\SIS_{n,q,\sigma\sqrt{2m}}^m$.
\end{theorem}
\begin{proof}
The proof is identical to the template used in~\cite[Theorem 7]{Poremba22}, except that the adversary is allowed to be computationally unbounded once the deletion certificate is submitted. This is in contrast with the original proof who considered forwarding the \emph{secret key} during the security experiment. We remark that we do not invoke the strong Gaussian-collapsing property to prove the indistinguishability of the hybrids; instead we use the (stronger) notion of certified everlasting $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing property of the Ajtai hash shown in \Cref{thm:ajtai-certified-everlasting}. This results in the stronger notion of everlasting certified
deletion security.
\end{proof}



\subsection{Dual-Regev (Leveled) Fully Homomorphic Encryption with Publicly-Verifiable Deletion}\label{sec:dualfhe-pvd}

A homomorphic encryption scheme with certified deletion~\cite{Broadbent_2020,Poremba22,BBK22} is a scheme that supports both homomorphic operations as well as certified deletion of quantum ciphertexts. Here, the two properties are thought of as \emph{separate} features that may or may not be mutually exclusive. Several works~\cite{Poremba22,BBK22,BGGKMRR} have also considered the possibility of realizing both homomorphic evaluation and certified deletion \emph{simultaneously} within a single (possibly interactive) protocol. For example, Poremba~\cite{Poremba22} proposed a four-message protocol that allows a client to learn the outcome of a homomorphic evaluation performed by an untrusted quantum server, while simultaneously certifying that the server has subsequently deleted all data. Bartusek and Khurana~\cite{BBK22} subsequently defined the notion of a four-message protocol for \emph{blind delegation with certified deletion}, which can be instantiated using any $\FHE$ scheme with certified deletion. Crucially, both of the aforementioned four-message protocols require that the server is \emph{honest} during the evaluation phase of the protocol. Finally, in a subsequent follow-up work, Bartusek et al.~\cite{BGGKMRR} constructed a \emph{maliciously} secure bind delegation protocol with certified deletion which relied on succinct non-interactive arguments (SNARGs) for polynomial-time computation.

In this section, we recall the Dual-Regev (leveled) fully homomorphic encryption scheme with publicly-verifiable deletion introduced by Poremba~\cite{Poremba22}. The scheme is based on the \emph{dual variant} of of the (leveled) $\FHE$ scheme by Gentry, Sahai and Waters~\cite{GSW2013,mahadev2018classical}. 
Using our main result on certified-everlasting target-collapsing hashes in \Cref{thm:CETC-generalization}, we then prove the scheme achieves certified-everlasting security assuming the quantum hardness of $\LWE$ and $\SIS$.
Contrary to related works~\cite{Poremba22,BBK22,BGGKMRR}, we only consider the basic notion of $\FHE$ with publicly-verifiable deletion which treats both properties as separate features.

\paragraph{Parameters.} Let $\lambda \in \N$ be the security parameter and let $n \in \N$. Let $L$ be an upper bound on the depth of the polynomial-sized Boolean circuit which is to be evaluated. We choose the following set of parameters for the Dual-Regev leveled $\FHE$ scheme (each parameterized by $\lambda$).
\begin{itemize}
    \item a prime modulus $q \geq 2$.
    \item an integer $m \geq 2n \log q$.
    \item an integer $N = (m+1) \cdot \lceil \log q \rceil$.
     
     \item a noise ratio $\alpha\in (0,1)$ such that
$$
\sqrt{8(m+1)}\leq \alpha q \leq \frac{q}{\sqrt{8}(m+1)\cdot (N+1)^L}.
$$
\end{itemize}


\begin{construction}[Dual-Regev leveled $\mathsf{FHE}$ scheme with certified deletion]\label{cons:FHE-cd}
Let $\lambda \in \N$ be the security parameter.
The Dual-Regev (leveled) $\mathsf{FHE}$ scheme $\mathsf{DualFHECD} = (\KeyGen,\Enc,\Dec,\Eval,\Del,\Vrfy)$ with certified deletion consists of the following algorithms.
\begin{description}
\item $\KeyGen(1^\lambda,1^L) \rightarrow (\pk,\sk):$ sample $\bar{\vec A} \rand \Z_q^{n\times m}$ and vector $\bar{\vec x} \rand \bit^{m}$
and let $\vec A = [\bar{\vec A} \| \bar{\vec A} \cdot \bar{\vec x} \Mod{q}]^\intercal$.
Output $(\pk,\sk)$, where $\pk=\vec A \in \Z_q^{(m+1) \times n}$ and $\sk = (-\bar{\vec x}, 1) \in \Z_q^{m+1}$.
\item $\Enc(\pk,x) \rightarrow (\vk,\ket{\ct}):$ to encrypt a bit $x\in \bit$, parse the public key as $\vec A \in \Z_q^{(m+1) \times n} \leftarrow \pk$ and generate the following pair consisting of a verification key and ciphertext for a random $\vec Y \in \Z_q^{n \times N}$ with columns $\vec y_1,\dots,\vec y_N \in \Z_q^{n}$:
$$
\vk \leftarrow (\vec A,\vec Y), \quad\,\,
\ket{\ct} \leftarrow \sum_{\vec S \in \Z_q^{n \times N}} \sum_{\vec E \in \Z_q^{(m+1)\times N}} \rho_{q/\sigma}(\vec E) \, \omega_q^{-\Tr[\vec S^\intercal \vec Y]} \ket{\vec A\cdot \vec S + \vec E + x \cdot \vec G},
$$
where $\vec G = [\vec I \, \| \, 2 \vec I \, \| \, \dots \, \| \, 2^{\lceil \log q \rceil -1} \vec I] \in \Z_q^{(m+1) \times N}$  denotes the \emph{gadget matrix} and where $\sigma = 1/\alpha$.

\item $\Eval(\mathsf{C}_0,\mathsf{C}_1) \rightarrow \mathsf{C}_0 \mathsf{C}_1 \mathsf{C}$: to apply a $\mathsf{NAND}$ gate onto two registers $\mathsf{C}_0$ and $\mathsf{C}_1$ (possibly part of a larger ciphertext), append an ancilla system $\ket{\vec 0}_{\mathsf{C}}$, and apply the unitary $U_{\mathsf{NAND}}$, defined by
$$
U_{\mathsf{NAND}}: \quad \ket{\vec X}_{\mathsf{C}_0} \otimes \ket{\vec Y}_{\mathsf{C}_1} \otimes \ket{\vec Z}_\mathsf{C} \quad \rightarrow \quad  \ket{\vec X}_{\mathsf{C}_0} \otimes \ket{\vec Y}_{\mathsf{C}_1} \otimes \ket{\vec Z + \vec G - \vec X \cdot \vec G^{-1}(\vec Y) \Mod{q}}_{\mathsf{C}},
$$
where $\vec X,\vec Y,\vec Z \in \Z_q^{(m+1)\times N}$
and $\vec G^{-1}$ is the (non-linear) inverse operation such that $\vec G \circ \vec G^{-1} = \vec I$.
Output the resulting registers $\mathsf{C}_0 \mathsf{C}_1 \mathsf{C}$.


\item $\Dec(\sk,\mathsf{C}) \rightarrow \bit \, \mathbf{or} \, \bot:$ measure the register $\mathsf{C}$ in the computational basis to obtain $\vec C \in \Z_q^{(m+1)\times N}$ and compute $c = \sk^\intercal \cdot \vec c_N \in \Z \cap (-\frac{q}{2},\frac{q}{2}]$, where $\vec c_N \in \Z_q^{m+1}$ is the $N$-th column of $\vec C$; output $0$, if $c$
is closer to $0$ than to $\lfloor\frac{q}{2}\rfloor$,
and output $1$, otherwise.

\item $\Del(\ket{\ct}) \rightarrow \pi:$ measure $\ket{\ct}$ in the Fourier basis with outcomes $\pi = (\pi_1|\dots|\pi_N) \in \Z_q^{(m+1)\times N}$.

\item $\Vrfy(\vk,\pk,\pi) \rightarrow \bit:$ to verify the deletion certificate $\pi = (\pi_1\|\dots\|\pi_N) \in \Z_q^{(m+1)\times N}$, parse $(\vec A \in \Z_q^{(m+1) \times n},(\vec y_1 \|\dots \|\vec y_N)  \in \Z_q^{n \times N}) \leftarrow \vk$ and output $\top$, if both $\vec A^\intercal \cdot \pi_i = \vec y_i \Mod{q}$ and $\| \pi_i \| \leq \sqrt{m+1}/\sqrt{2}\alpha$ for every $i \in [N]$, and output $\bot$, otherwise.
\end{description}
\end{construction}

For additional details on the correctness of the scheme, we refer to Section $9$ of \cite{Poremba22}.

\begin{theorem}\label{thm:FHE-CD-security} Let $\lambda \in \N$ be the security parameter and let $L$ be an upper bound on the size of the Boolean circuit which is to be evaluated. Let $n \in \N$, let $q\geq 2$ be a prime modulus and let $m \geq 2 n \log q$. Let $N = (m+1) \cdot \lceil \log q \rceil$. Let $\alpha \in (0,1)$ be a noise ratio such that$$
\sqrt{8(m+1)N}\leq \alpha q \leq \frac{q}{\sqrt{8}(m+1)\cdot (N+1)^L}.
$$
Then, $\mathsf{DualFHECD}$ in \Cref{cons:FHE-cd} has everlasting certified deletion security assuming the quantum (subexponential) hardness of $\SIS_{n,q,\sigma\sqrt{2m}}^m$ and $\mathsf{LWE}_{n,q,\alpha q}^m$.
\end{theorem}
\begin{proof}
The proof is identical to the template in~\cite[Theorem 10]{Poremba22}, except that the adversary is allowed to be computationally unbounded once the deletion certificate is submitted. This is in contrast with the original proof who considered forwarding the \emph{secret key} during the security experiment. We remark that we do not invoke the strong Gaussian-collapsing property to prove the indistinguishability of the hybrids; instead we use the (stronger) notion of certified everlasting $D_{\Z_q^m,\frac{\sigma}{\sqrt{2}}}$-target-collapsing property of the Ajtai hash function shown in \Cref{thm:ajtai-certified-everlasting}. This results in the stronger notion of everlasting certified
deletion security.
\end{proof}





%\input{OWF}
%\input{generalization}

\input{regOWF}
%\input{group-actions}
%\input{misc}




\printbibliography

\newpage 
\appendix




\end{document}
