\section{\sys: An MILP Solver for PWA-Control}
\label{sec:overview}

\begin{figure*}[t!]
    \centering
    \includegraphics[width=0.85\textwidth]{imgs/overview.png}
    \caption{Architectural overview of \sys.}
    \label{fig:overview}
\vspace{-0.6cm}
\end{figure*}


We now present \sys, a specialized MILP solver for PWA control that combines the proposed techniques in Secs.~\ref{sec:dpllt} and \ref{sec:soi}. \sys is implemented in $\sim$15K lines of original C++ code with 100+ unit tests. Fig.~\ref{fig:overview} exhibits the architectural design of \sys. 

\smallskip \noindent \textbf{Parser} \sys takes as input MILP problems in the standard \mps format, which are supported by most off-the-shelf MICP solvers and can be generated by popular robotic software such as Drake~\cite{drake}. This makes it relatively straightforward to use \sys or compare it with existing solvers. Our \mps parser transforms the given constraints into an internal representation (IR). A unique feature is that it will automatically extract \emph{one-hot constraints} from the \mps file and create for them both the standard arithmetic representation and a propositional logic level representation.

\smallskip \noindent \textbf{Pre-solver} Before entering the main solving loop described in Alg.~\ref{alg:complete}, \sys first performs interval analysis on both the linear constraints and the logical constraints. For example, if in a certain equation, all variables but one are bounded, the analysis will derive sound bounds for the unbounded variable. In practice, we find pre-solving can significantly reduce the runtime of the convex procedure.

\smallskip \noindent \textbf{Engine} After pre-solving, the updated IR (with tighter variable bounds) is passed on to the main solving engine, which has three components, a SAT Solver, a convex solver, and the \deepsoi engine. The former two combined execute the DPLL(T) procedure described in Alg.~\ref{alg:complete}. We instantiate \satProc with the Cadical SAT solver~\cite{cadical}, and \convProc/\convOptProc with the LP solver in the Gurobi Optimizer~\cite{gurobi}, which is capable of generating explanations~\cite{gurobiexplanation}. We leverage incremental solving in Cadical and Gurobi whenever possible.

There are two reasons we implement our own DPLL(T) solver rather than building on top of existing SMT solvers. First, LP engines in SMT-solvers use arbitrary-precision rational arithmetic, which can be many times slower than off-the-shelf floating-point LP solvers. While precise arithmetic is necessary for ensuring soundness in formal verification, it is not as crucial in our setting, where the goal is to \emph{find solutions}. Secondly, we hope to support more general MICP in the future, but support for convex programming beyond LP is less mature in SMT solvers. %Finally, it can be challenging to implement domain-specific optimization in general-purposed SMT solvers. Our vision is to support in \sys other common logical constraints in robotics.
