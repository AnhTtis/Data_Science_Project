\section{Evaluation on Control of PWA Systems}
\label{sec:experiments}

We evaluate \sys on MILP encodings of PWA control problems. We compare \sys with two state-of-the-art MICP solvers -- \gurobi~\cite{gurobi} and \mosek~\cite{mosek} -- and perform ablation studies to show the effectiveness of our techniques. The main evaluation criterion is the run-time performance of finding a feasible solution (a trajectory).

\subsection{Solver configurations} 

We denote our best configuration as \best and compare with \gurobi and \mosek in their default configurations. Anecdotally, Gurobi has a particular strength in MILP, which is in fact the setting we consider. \emph{We remark that the relative performance of these solvers on the specific benchmarks we study may not be representative of their relative performance on other kinds of problems.} 

We run three ablation configurations, each of which differs from \best by one feature: 
\begin{enumerate*} [(1) ]
    \item \nocdcl does not extract theory lemmas from the convex procedure or perform logical reasoning with the SAT solver (i.e., Line \ref{line:checksat} of Alg.~\ref{sec:dpllt} is not executed). This configuration is a bare-bones branch-and-bound-like complete search that runs \deepsoi at each search state;
    \item \nosoi does not perform the \deepsoi procedure but runs a normal convex procedure during the search, making it less likely to find feasible solutions until it reaches the bottom of the search tree;
    \item \noprop uses the Walksat-based strategy in Sec.~\ref{sec:soi} rather than the propagation-based proposal strategy in \deepsoi.
\end{enumerate*}


\subsection{Benchmarks}

We evaluate on two types of existing PWA control problems, namely \emph{Stepping Stones}~\cite{marcucci2021shortest} and \emph{Ball and Paddle}~\cite{marcucci2019mixed}. 

\paragraph{Stepping Stones~\cite{marcucci2021shortest}}

\newcommand{\position}{\textbf{\textit{q}}}
\newcommand{\velocity}{\textbf{\textit{v}}}
\newcommand{\force}{\textbf{\textit{a}}}
\newcommand{\control}{\eta}
\newcommand{\timestamp}{t}
\newcommand{\timeMax}{T}

In these problems, an agent must navigate from a starting position to a destination, stepping only on the (convex) blue and red regions, as illustrated in Fig.~\ref{fig:stepping_stone}. We use the same dynamics as~\cite{marcucci2021shortest}, but design two new maps, \ssa and \ssb. The goal is to reach the destination position with zero velocity within a fixed number of time steps. The white regions are not reachable, while the blue and red regions have different costs. The one-hot constraint in this case is used to specify the fact that the agent is in one of the convex regions, and the number of modes is equal to the number of convex regions.
This problem can be seen as an abstraction of the footstep planning scenario in Fig.~\ref{fig:motivation}, although we remark that the latter requires quadratic constraints, so the problem becomes MIQP rather than MILP. Supporting MIQP in \sys is a direction for future work.

We generated $100$ MILP encoding instances from map \ssa by randomly varying the vertical positions of the starting and ending points in $[0, 11] \times [2, 9]$, respectively. We generated another $100$ MILP problems from map \ssb by randomly selecting $5$ (red regions in Fig~\ref{fig:stepping_stone2}) out of the $16$ convex regions to have a lower control parameter, which makes navigation harder. We refer to the benchmark sets as \ssa and \ssb in Table~\ref{tab:main}.

\begin{figure}
    \centering
        \begin{subfigure}[b]{0.70\linewidth}
            \includegraphics[height=2.5cm]{imgs/mapa_example.png}
            \caption{\ssa: 1st map}
        \end{subfigure}
        \hspace{-0.5cm}
        \begin{subfigure}[b]{0.28\linewidth}
            \includegraphics[height=2.55cm]{imgs/mapb_example.png}
            \caption{\ssb: 2nd map \label{fig:stepping_stone2}}
        \end{subfigure}
        \vspace{-2mm}
    \caption{Two types of maps with example solutions (planning trajectories from \sys) in the Stepping Stones benchmark.}
    \label{fig:stepping_stone}\vspace{-5mm}
\end{figure}


\paragraph{Ball and Paddle~\cite{marcucci2019mixed}}

\newcommand{\paddle}{\textbf{\textit{u}}}

This problem, as shown in Fig.~\ref{fig:ball_paddle}, is to rotate a two-dimensional ball using a paddle (bottom in red) under a fixed ceiling (top in gray). 
% The mechanical system, which is the same as the one described in \cite{marcucci2019mixed}, %The control input $\paddle \in \R^2$ is the translational acceleration of the paddle. The state is in $\R^{10}$, which includes the 2D-positions of the ball and the paddle, the angle of the ball, and their time derivatives. The ball is subject to the gravity as well as the contact forces from the interactions with both the paddle and the ceiling. 
The original system has 7 modes: no contact, ball in contact with the paddle (sticking, sliding left or right), and ball in contact with the ceiling (sticking, sliding left or right). We fix the terminal state and generate different instances by varying the initial state. The first benchmark set, denoted as \bpeasy, is generated by randomly varying the horizontal position of the ball in the interval $[0, l/2]$, where $l$ is the width of the paddle. The second benchmark set, denoted as \bphard, is from randomly varying the horizontal position and the angle of the ball in the interval $[0, l]\times [-\pi, \pi]$. Each benchmark set contains $100$ instances.

\begin{figure}
    \centering
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000000.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000045.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000060.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000075.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000090.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000120.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000150.png}
    \includegraphics[width=0.22\linewidth]{imgs/ball_paddle_video_frames/0000183.png}
    \caption{Flipping the ball by $180\degree$ with a paddle. The top right image is the \emph{initial} state and the bottom right is the \emph{terminal} state. These images are sampled frames from the animation video in the supplementary materials.}
    \label{fig:ball_paddle}
    \vspace{-0.7cm}
\end{figure}

\paragraph{Experimental setup}
Each benchmark is stored in MPS format. Each configuration was given one thread and a 20 minute CPU-timeout per benchmark. Experiments were performed on a cluster equipped with Intel Xeon E5-2637 v4 CPUs running Ubuntu 20.04. We measure the CPU time each configuration takes on each instance. The instances that timed out are assigned the time limit as their running time. 

\subsection{Comparison with existing solvers}



\begin{table*}[t!]
\setlength\tabcolsep{5pt}
\begin{center}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{cccccccccccc}
& & \multicolumn{2}{c}{\ssa} & \multicolumn{2}{c}{\ssb} & \multicolumn{2}{c}{\bpeasy} & \multicolumn{2}{c}{\bphard} & \multicolumn{2}{c}{Total} \\ 
\toprule
& \textbf{Configuration}  & Time   & \# Solved & Time & \# Solved & Time & \# Solved & Time & \# Solved & Time   & \# Solved \\
\cmidrule(lr){2-2} \cmidrule(lr){3-4} \cmidrule(lr){5-6} \cmidrule(lr){7-8}  \cmidrule(lr){9-10} \cmidrule(lr){11-12} 
\multirow{3}{*}{\bf{Main}} & \gurobi             & \textbf{868}    &    100   &  \textbf{212}  &  100    & 3465 &      100  &  8803 &     99 & 13348  & 399 \\
&\mosek              & 41683  &    75    & 1666 &   100    & 109373 &      13 & 111053 &    14  & 263775 & 202 \\
&\textbf{\best}              & 1057    &   100    & 458 &   100    & \textbf{1488} &  100 & \textbf{2757}  &  100 & \textbf{6367} & \textbf{400}  \\ \hline
\multirow{2}{*}{\bf{Virtual}} & \gurobiandbest & 738 & 100 & 201 & 100 & 1205 & 100 & 2387 & 100 & 4531 & 400 \\
&   \virtualall  & 729 & 100 & 200 & 100 & 1205 & 100 & 2387 & 100 & 4521 & 400 \\ 
\hline
\multirow{3}{*}{\bf{Ablation}} & \nocdcl & 1430 & 100 & 533 & 100 & 37165 & 74 & 58282 & 55 & 97410 & 329  \\
&  \nosoi  & 26709 & 89 & 549 & 100 & 118957 & 5 & 109658 & 9 & 255873 & 203 \\
&  \noprop & 1207 & 100 & 636 & 100 & 2670 & 100 & 4642 & 100 & 9155 & 400 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Runtime performance (in seconds) of different solver configurations on the benchmarks. The configuration are divided into the \textbf{main} configurations, the \textbf{virtual} portfolio configurations, and the \textbf{ablation} configurations.} \label{tab:main}
\vspace{-4mm}
\end{table*}

The runtime performance of all configurations running on all benchmarks is shown in Table~\ref{tab:main}. 
%
We first compare \best with \gurobi and \mosek (the \textbf{Main} block). On the Stepping Stones benchmarks (the \ssa and \ssb columns), both \best and \gurobi can efficiently solve all the instances, while \mosek fails to solve 25 instances within the time limitation. \gurobi is overall faster on those benchmarks, with an average runtime of 8.7 seconds per instance on \ssa and 2.12 seconds per instance on \ssb; in contrast, \best has an average runtime of 10.6 and 4.6 seconds, respectively. 

The Ball and Paddle benchmarks take significantly more time to solve. \mosek struggles in this more challenging use case and only solves 27 instances. On the other hand, \best performs significantly better than \gurobi. Not only does it take 57\% less time on \bpeasy and 69\% less time on \bphard, it also solves all of the 200 instances while Gurobi times out on 1 of them. Running with a longer time limit reveals that \textbf{it takes \gurobi 7 hours and 39 minutes to find a feasible solution for this instance}. In contrast, \best solves this instance in 501 seconds. 

A scatter plot of the runtime of \best and \gurobi on all benchmarks is shown in Fig.~\ref{fig:scatter}. Overall, \best performs best, but the two solvers frequently show complementary behaviors. Indeed, as shown in Table~\ref{tab:main}, if we consider a virtual portfolio strategy that runs \best and \gurobi in parallel (\gurobiandbest), further performance gain can be obtained on \emph{all} of the four benchmark sets. This suggests that running multiple competitive solvers in parallel is advisable in practice. Marginal gain can be obtained if we also include \mosek in the portfolio (\virtualall).


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.66\linewidth]{imgs/scatter.pdf}
    \caption{Scatter plot of the runtime of \best and \gurobi.}
    \vspace{-2mm}
    \label{fig:scatter}
    \vspace{-4mm}
\end{figure}


\subsection{Ablation studies}

The \textbf{Ablation} block of Tab.~\ref{tab:main} shows the runtime performance of the ablation configurations. The number of solved instances drops significantly if we turn off logical reasoning (\nocdcl) or if we do not perform \deepsoi (\nosoi). Without \deepsoi, the performance of \best is disastrous on the Ball and Paddle benchmarks, solving only 14 of the 200 instances. Interestingly, we observe a similar pattern on the performance of \mosek and \nosoi: they both fail on a fraction of \ssa, solve all of \ssb, and perform badly on \bpeasy and \bphard. This leads us to speculate that \mosek does not invest in local search during MILP solving. Finally, if we use a Walksat-like proposal strategy instead of the propagation-based proposal strategy in the \deepsoi procedure, we are still able to solve all instances, but the overall runtime degrades by 44\% (from 6367 to 9155 seconds).  The conclusion of these ablation studies is that each of the proposed techniques contributes to the competitive performance of \best.
