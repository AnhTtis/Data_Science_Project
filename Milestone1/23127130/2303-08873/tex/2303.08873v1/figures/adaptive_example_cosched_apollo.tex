\begin{minted}[numbersep=1pt, highlightlines={2-15}, highlightcolor=celadon!50, fontsize=\footnotesize,linenos,escapeinside=!!,breaklines]{c++}
void vecAdd(double *A, double *B, double *C, size_t N) {
  float GPU_FRAC;
  static void *region = NULL;
  float MIN_FRAC=0.0f, MAX_FRAC=1.0f, STEP=0.1;

  !\label{lst5_apollo:create:begin}!if(region == NULL)
    region = __apollo_region_create(/* id */ "vecAdd",
    /* num_features */ 1, /* num_policies */ 11, 
    /*model params */ "DecisionTree,explore=RoundRobin",
    !\label{lst5_apollo:create:end}!/* min_train_data */ 11 * 10);
      
  !\label{lst5_apollo:apollo:begin}!__apollo_region_begin(region);
  __apollo_region_set_feature(N);
\end{minted}
\begin{minted}[firstnumber=14, numbersep=1pt, highlightlines={14-28}, highlightcolor=beaublue!50, fontsize=\footnotesize,linenos,escapeinside=!!,breaklines]{c++}
  !\label{lst5_apollo:apollo:end}!int policy = __apollo_region_get_policy(region);
  GPU_FRAC = MIN_FRAC + policy * STEP;
  !\label{lst5_apollo:enter:begin}!#pragma omp target enter data \
    map(to: A[0:GPU_FRAC*N], B[0:GPU_FRAC*N]) \
    !\label{lst5_apollo:enter:end}!map(from: C[0:GPU_FRAC*N])
  // GPU execution
  !\label{lst5_apollo:gpu:begin}!#pragma omp target teams distribute parallel for nowait
  for(size_t i = 0; i < GPU_FRAC*N; ++i)
      !\label{lst5_apollo:gpu:end}!C[i] = A[i] + B[i];
  // CPU execution
  !\label{lst5_apollo:cpu:begin}!#pragma omp parallel for
  for(size_t i = GPU_FRAC*N; i < N; ++i)
      !\label{lst5_apollo:cpu:end}!C[i] = A[i] + B[i];
  !\label{lst5_apollo:taskwait}!#pragma omp taskwait
  !\label{lst5_apollo:exit}!#pragma target exit data map(from: C[0:GPU_FRAC*N])
\end{minted}
\begin{minted}[firstnumber=29, numbersep=1pt, highlightlines={29}, highlightcolor=bubblegum!50, fontsize=\footnotesize,linenos,escapeinside=!!,breaklines]{c++}   
  !\label{lst5_apollo:region:end}!__apollo_region_end(region);
}
\end{minted}
