\begin{figure}
  \begin{subfigure}{\columnwidth}
\begin{minted}[bgcolor=light-gray]{python}
def foo(row):
  if row['A'] == row['B'] and row['A'] < row['C']:
    return 'X'
  elif row['A'].startswith('Y'):
    return 'Y'
  elif row['B'] in ls:
    return 'Z'
  else:
    return 'NA'

df.apply(foo, axis=1)
\end{minted}
    \caption{Original \code{pandas} \code{apply()}. It processes each row
    sequentially, using the interpreter.}
    \label{fig:apply_vectorized_orig}
  \end{subfigure}
  \hfill
  \begin{subfigure}{\columnwidth}
\begin{minted}[bgcolor=light-gray]{python}
conditions = [
  (df['A'] == df['B']) & (df['A'] < df['C']),
  df['A'].str.startswith('Y'),
  df['B'].isin(ls)
]
choices = [
  'X', 'Y', 'Z'
]
np.select(conditions, choices, default='NA')
\end{minted}
    \caption{Vectorized execution using \code{numpy.select()}}
    \label{fig:apply_vectorized_rewr}
  \end{subfigure}
  \caption{VectorizedConditionals: Vectorized \code{apply()} with conditions, which can be hundreds of
  times faster \cite{pygotham_apply_vectorized}. However, performing this
  rewrite automatically is challenging.}
  \label{fig:apply_vectorized}
\end{figure}