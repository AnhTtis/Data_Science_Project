\begin{figure}
  \begin{subfigure}[t]{0.45\linewidth}
\begin{minted}[bgcolor=light-gray]{python}
def weighted_rating(x, m=m, C=C):
  v = x['vote_count']
  R = x['vote_average']
  return (v/(v+m) * R) + (m/(m+v) * C)


df.apply(weighted_rating, axis=1)
\end{minted}
    \caption{Loop through rows (extracted from a Kaggle notebook
    \cite{real_nb_apply_math}). This, effectively, loops sequentially over each
    row, and the operations are performed in the Python interpreter.}
    \label{fig:apply_only_math_orig}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.45\linewidth}
\begin{minted}[bgcolor=light-gray]{python}
def weighted_rating(x, m=m, C=C):
  v = x['vote_count']
  R = x['vote_average']
  return (v/(v+m) * R) + (m/(m+v) * C)

# Pass the whole `df` directly.
weighted_rating(df)
\end{minted}
    \caption{The function contains only column operations and thus can be applied directly to the whole \code{DataFrame}.}
    \label{fig:apply_only_math_rewr}
  \end{subfigure}
  \caption{A rewrite example where we avoid \code{apply()}. The rewritten
  version, which uses vectorized, native execution, can run up to 1000$\times$ faster.}
  \label{fig:apply_only_math}
\end{figure}






