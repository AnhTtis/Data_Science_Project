\section{\system{} Overview}
\label{sec:System}

\input{figures/system_overview.tex}

%We now present \system{}, a system that accelerates interactive data science workloads by transparently rewriting Python that interfaces with Pandas code and which addresses all the previously mentioned challenges. In order to do so, \system{} has two high-level components. First, \system{}' \textit{syntactic pattern-matcher} identifies matches the input code against the LHS parts of the rewrite rules. The second component is a \emph{rewriter}, which validates the preconditions of the rewrite rules and on passing them, rewrites the code to the RHS version and executes it. We show a high-level overview in Figure \ref{fig:system_overview}.

We now present the high-level architecture of \system{}, a rewrite engine that
automatically applies rewrite rules to improve the performance of ad-hoc EDA
workloads.

We designed \system{} with two high-level components. First, \system{}'
\textit{syntactic pattern matcher} matches the input code against the syntactic
patterns the rewrite rules. The second component is a \emph{rewriter}, which
checks the runtime preconditions of the rewrite rules and on success, rewrites
the code to an equivalent, but faster version and executes it. We show a
high-level overview in Figure \ref{fig:system_overview}.

We have several desiderata for \system: it should facilitate applying complex
rewrites automatically with minimal overhead. Further, it should guarantee that
the rewritten code is semantically equivalent to the original code i.e.,
that it is sound, which presents the main technical challenge.

To guarantee soundness, we first formalize the rewrites
(Section~\ref{sec:pandas_rewr_rules}). Second, we accurately describe the
conditions under which a rewrite can be applied, some of which can be quite
involved. For example, some require \system{} to check the form of whole
functions. And finally, most of these conditions can only be checked at runtime,
and checking them at the correct program points requires delicate program
transformations (Section~\ref{sub-sec:rewriter}).

\hfill{}

% In the subsequent sections, we describe how we designed the pattern matcher (Section~\ref{sub-sec:patt-match}) and the 
% rewriter (Section~\ref{sub-sec:rewriter}) to overcome these challenges. First, we introduce the structure of the rewrite rules briefly in Section~\ref{sec:pandas_rewr_rules}.

% In this Figure, the pattern-matcher matched an LHS (highlighted in green); a substring search for the string \code{'G'} in \code{df['Name']}. We can do the same substring search but much faster. Note that the pattern-matcher, in accordance with our descriptions of the LHS's, identifies purely syntactic patterns. So, it does not (and cannot) perform semantic-related or dynamic checks.

% Having matched an LHS, \system{} uses. For example, to rewrite the substring search, the name \code{df} should be of type \code{DataFrame}, otherwise the rewriting is (possibly) invalid. Most of the time, the rewriter can bake these dynamic checks as part of the rewritten code (as in Figure \ref{fig:system_overview}). This is not always possible though but we will return to this later.



%\input{figures/multi_stmt_patt.tex}

\input{figures/example_rewrite.tex}
\input{rewrite-rules.tex}

\section{\system{} Rewrite System}

\system{} consists of two main parts: a syntactic pattern matcher and a rewriter
that rewrites the code matched against patterns. We now describe how the two
parts were designed in detail.

\subsection{\system{} Pattern Matcher}
\label{sub-sec:patt-match}

% \input{figures/lst_patt_match.tex}

The pattern matcher is responsible for matching a sequence of statements
with the \textbf{LHS} part of any rewrite rule. Whether any \textbf{LHS}
(represented as an AST) matches any part of the source AST, is essentially a
sub-tree search problem. The pattern matcher performs a greedy search and it
returns the first LHS it matches.

To minimize matching overhead, we designed the pattern matcher to be
hierarchical, by factoring patterns based on their commonalities. The common
parts are matched first before hierarchically matching more specific components
of a rule. This eliminates repeatedly matching components that are common to
multiple rules.

% Consider the pattern-matching code that matches two patterns: the third pattern
% of Table~\ref{tbl:rewr_rules} and the one that enables the rewrite of
% Figure~\ref{fig:apply_only_math}. The LHS of the former is shown in the table.
% The LHS of the latter is \code{@\{expr: e\}.apply(@\{Name: fun\}, axis=1)} (see
% Section~\ref{sub-sec:rewriter}). Notice that these LHS's share parts; they both
% require a function call, that is an attribute of some expression and the name of
% the function is \code{apply}. We want to check the common parts of the pattern
% at a single place to exploit commonalities across patterns.
% Listing~\ref{lst:patt-match} shows a sketch of the pattern-matching code that
% matches these two patterns. %The input is a statement represented as an AST. The
% function returns an object representing a pattern if it matches one, or None
% otherwise. It recursively loops through all the AST nodes of type \code{stmt}
% and checks for the two patterns by first checking for an attribute function
% called \code{apply} and then matching against either one of the patterns
% specifically.

Lastly, the pattern matcher needs to be able to match patterns that span
multiple statements. Having a function that matches single-statement patterns by
performing a greedy search, there is another function that matches multiple
statements. The latter function operates on a higher level, viewing
multi-statement patterns as sets of smaller ones. So, for a 2-statement pattern,
if it matches the first part, it then checks the next statement for the second
part.

\subsection{\system{} Rewriter}
\label{sub-sec:rewriter}

%\input{pandas_code_rewriting.tex}
%\input{rewrite-rules.tex}

%\subsection{Applying Rewrites}

When a piece of code is successfully matched with a rewrite rule's
\textbf{LHS}, if there are no runtime preconditions (i.e.,
\textbf{RuntimePrecond} just returns \code{True}), then the rewriter can invoke
\textbf{TransformLHS} on the \textbf{LHS}, and replace the \textbf{LHS} with the
result.

For example, consider the rule in Figure~\ref{fig:sort-values-rule}.
\code{@\{called\_on\}} needs to be evaluated first, let us name the resulting
object \code{res}, then execution needs to \textit{stop}, check the precondition
on \code{res}, and then continue (i.e., evaluating either
\code{res.sort\_values().head()} or \code{res.nsmallest()}, depending on the
precondition result).

% \input{figures/precond_naive.tex}

This is more difficult than it looks because we do not have arbitrary
control over the evaluation of the code, since we are operating at the source
level. So, we need to \textit{effectively} do the same thing but using
source-level transformations. This is difficult because we are not allowed to
evaluate \code{@\{called\_on\}} twice. The obvious solution is to just evaluate
it once and reuse it.

\input{figures/sort_values_nested.tex}
% \input{figures/precond_naive2.tex}
% \input{figures/ocaml_local_binding.tex}
\input{figures/precond_correct.tex}

However, this requires careful orchestration. Consider for example the code in
Figure~\ref{fig:sort-values-nested}. The evaluation-and-reuse should happen
\textit{exactly} where the original sub-expression (involving
\code{sort\_values()}) appears. Otherwise (e.g., if we save it in a variable by
adding a statement above), it is possible that \code{read\_x()} will read a
stale value.

To solve that in general, we need a local binding of the evaluation of
\code{@\{called\_on\}} \footnote{In the style of a \code{let} expression in
OCaml.}. However, Python does not have local bindings, so the workaround is to
create a function and call it at the place of the original expression, as in
Figure~\ref{fig:sort-values-precond-correct}. The local binding here is the
binding to the function's parameter.

\paragraph{\textbf{Dynamic RHS}}

Observe that in the solution we just mentioned, to create the function
\code{sort\_head()}, we need to know the RHS a-priori. This is true when
\textbf{TransformLHS} does not depend on dynamic information and thus we can
``run'' it offline. This is the case for the rule in
Figure~\ref{fig:sort-values-rule}. However, this is not the case for the
\code{RemoveAxis1} rule, because it depends on the body of \code{@\{func\}},
which is not known offline. To implement such rules, all of which involve
\code{apply()} and which face the same problem, we just overwrite
\code{apply()}. In the overwritten body, we invoke \textbf{RuntimePrecond},
which depends on the body of \code{@\{func\}}, which is however available
because it is passed as an argument. If the preconditions pass, we rewrite the
body on the fly and invoke it appropriately. For example, in the case of
\code{RemoveAxis1}, we rewrite the body as described earlier and we call
\code{self[theOneSeries].apply(new\_body)}. Note that \code{self} is the
evaluated \code{@\{expr\}}. We never see this \code{@\{expr\}}, but we know this
fact because \code{self} is bound to the object on which (the overwritten) \code{apply()}
gets called.

%\input{figures/columnar.tex}


% In retrospect, there is a much better solution (in terms of code complexity of \system{} and in terms of the correctness it provides and in terms of being more transparent to the user) which is an improvement over the problematic solution we wanted to avoid. Instead of inserting the code that performs the checks and the rewriting as part of the rewritten code, we put them in functions and in the rewritten code we just insert a call to them (after all, \system{} can act as a library). This would achieve the same effect as sliced execution but all the complexity of the latter goes away as it now happens organically. We aim to do this in a future version.
