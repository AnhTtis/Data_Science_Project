\section{Related Work}
\label{sec:Related}

\paragraph{\textbf{Optimizing Pandas}} Most previous work on optimizing
dataframe libraries focuses on optimizing \code{pandas}, mainly through the use
of parallel and distributed execution. Systems like \code{modin} \cite{modin},
\code{dask} \cite{dask}, Koalas \cite{koalas_web}, PolaRS \cite{polars_web},
Ponder \cite{ponder_web}, PolyFrame \cite{polyframe} and Magpie \cite{magpie}
are all essentially custom versions of \code{pandas} (some are full rewrites,
while others implement the \code{pandas} API over some underlying system).
Similarly, even techniques like BELE \cite{best_effort_lazy}, whose optimization
targets the \code{pandas}-Python interface, are limited \textit{within} the
library's boundaries, which weakens the view and control of the surrounding
code. In contrast to all these techniques, \system{} is the first system to use
dynamic rewriting at the \code{pandas}-Python interface, and it does so
\textit{externally}, which lets it views all user's code compared to just
library code and can modify any part of it. This is the main conceptual
difference, but there are also other practical drawbacks as we outlined
earlier, mainly arising from the fact that these systems do not focus on
single-machine, ad-hoc, diverse use cases.

\revis{There is also previous work on optimizing \code{pandas} code using static
analysis \cite{opt_ds_static_anal}, which also utilizes library-specific
knowledge. \system{} is different in that it is a dynamic rewriter.
Theoretically, the same rules we use could be applied with static analysis, but
static analysis in Python is quite inaccurate and it does not fit the
read-eval-print-loop (REPL) workflow of EDA workloads.}

\paragraph{\textbf{Pandas for Interactive Settings}} A slightly different and
interesting line of work focuses on optimizing dataframe queries for interactive
workloads \cite{pandas_interactive, lux}. Some of their optimizations include
displaying partial results, reordering operations and performing computation
during \emph{think-time}, i.e., when the user is inspecting results. We also
recognize the importance of interactive workloads, which include the EDA,
single-machine, ad-hoc workloads we focus on in this paper, but we are taking a
different path in optimizing them. We use rewriting at the interface boundary,
which is fundamentally different from the techniques used in this previous work.

\paragraph{\textbf{Rewrite systems in compilers}} Program rewriting is prevalent in compilers. Production-level compilers use peephole optimizers to perform local rewrites. LLVM~\cite{llvm} uses InstCombine \cite{llvm_instcombine} and VectorCombine \cite{llvm_vectorcombine} to perform IR rewrites on scalars and vectors respectively. Further, there have been many works such as Alive~\cite{alive}, Alive2~\cite{alive2}, Souper~\cite{souper} that try to prove or automatically find such rewrites inside traditional compilers. TASO~\cite{taso} and PET~\cite{pet} have looked into how rewrites can be used to optimize tensor computations in tensor compilers. Domain specific languages such as Halide~\cite{halide} include extensive rewrite engines to perform optimizations~\cite{halide-rewrites}. Even complicated optimization passes such as dataflow optimizations~\cite{multiple-rewrites} and vectorization~\cite{vegen} can be expressed as a series of rewrites. In fact, the compiler infrastructure MLIR~\cite{mlir} is rooted on the premise of rewriting to express complex IR transformations. \system{} takes inspiration from these systems that mainly perform static program rewrites and performs rewrites for \code{pandas} implemented in the dynamically-typed Python language.

\paragraph{\textbf{Dynamic Optimization}} There has been a large body of work
that optimizes programs at runtime. Just-in-time (JIT) compilation is one common
technique applied to interpreted languages like Javascript (TraceMonkey
\cite{trace-monkey}, V8 \cite{v8-engine}) and recently Python
\cite{python-spec-adapt-interp}, but also non-native languages like Java
(HotSpot \cite{java-hotspot}). However, all these methods optimize the host
language, focusing on low-level optimizations and not the host-library
combination. On the other hand, our technique can perform higher-level (and
higher-impact) improvements because it understands the semantics of both the
host language and the library.

