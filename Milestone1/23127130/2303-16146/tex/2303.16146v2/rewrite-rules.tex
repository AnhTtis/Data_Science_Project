\subsection{Pandas Rewrite Rules}
\label{sec:pandas_rewr_rules}

\input{figures/sort_values_rule.tex}

% \input{figures/tbl_rewr_rules.tex}

%\input{figures/sort_values_formal.tex}

The abstract form of the rewrite rules \system{} supports can be modeled as transforming a Left Hand Side (LHS) set of statements to Right Hand Side (RHS) set of statements subject to certain preconditions on the LHS.

The most general form of a rule consists of the following:

\begin{enumerate}[leftmargin=25pt]
  \item \textbf{LHS}: A code fragment with some parts that may vary. We call
  those the \textbf{varyingSet}. This LHS must be recognizable with a subtree
  search on the AST.
  \item \textbf{TransformLHS}: An AST transformer that transforms the LHS. We
  call the result the RHS of the rule.
  \item \textbf{RuntimePrecond}: An algorithm for checking the runtime
  preconditions under which using the RHS instead of the LHS is
  semantic-preserving. This is essentially a callback function, with inputs a
  subset of the \textbf{varyingSet}, but evaluated. This callback also gets a
  state snapshot of the interpreter as input. It returns \code{true} or \code{false}.
\end{enumerate}

\paragraph{\textbf{LHS}} We introduce some notation to show the structure of the
LHS. Consider the original code in Figure~\ref{fig:example_rewrite}(a) rewritten
to Figure~\ref{fig:example_rewrite}(b) using the rewrite rule shown in
Figure~\ref{fig:sort-values-rule}. A \code{@\{...\}} entry denotes a varying
part of the rule (i.e., an element of the \textbf{varyingSet}). These parts can
be matched to multiple valid options. Inside the curly brackets, we describe
these valid options using a derivation rule of the Python grammar
\cite{python_ast}. For example, \code{@\{expr\}} denotes that any expression can
appear in its place. For \code{Constant}s, which we refer to as \code{Const} for
short, we optionally specify the type of the constant inside
parentheses.\footnote{We can determine the type of constants from the AST
\cite{python_ast_constants}.} So, \code{@\{Const(int)\}} denotes that any
integer constant can appear in its place. We need to refer to elements of the
\textbf{varyingSet} in other components of the rewrite rule. So, we bind them to
names. For example, the code string \code{df.sort\_values().head()} matches the
LHS of Figure~\ref{fig:sort-values-rule} and \code{called\_on} is bound to (the
string) \code{df}. Everything that is not in \code{@\{\}} should appear as is.
With these in mind, we can read the LHS of Figure~\ref{fig:sort-values-rule} as
matching any Python expression on which \code{sort\_values()} is applied,
followed by \code{head()} with any constant integer as the argument of the
formal parameter \code{n}.

\input{figures/sort_values_rhs.tex}
\input{figures/remove_axis_1_ex.tex}

\paragraph{\textbf{TransformLHS}} This is a function which takes as input
the \textbf{LHS} as an AST and outputs the RHS as an AST. The simplest form is a
function that outputs a constant string, with some elements of
\textbf{varyingSet} (also strings) interpolated. For example, the RHS of
Figure~\ref{fig:sort-values-rule} can be implemented as shown in
Figure~\ref{fig:sort-values-rhs}. The values of \code{called\_on} and
\code{first\_n} are part of the \textbf{varyingSet}. This LHS transformer is
quite simple, but others can be significantly more complex and they can also
depend on \textit{dynamic} information (the transformer we just described does
not as \code{called\_on} and \code{first\_n} are extracted from the text).

\paragraph{\textbf{RuntimePrecond}} The runtime preconditions describe
conditions which have to hold at \emph{runtime} for the original (LHS) and the
RHS to be semantically equivalent. For example, in Figure
\ref{fig:sort-values-rule}, the result of the \code{called\_on} expression that
was matched in the LHS should be a \code{pandas.DataFrame}. The runtime
preconditions implicitly impose an order of evaluation. In this example,
\code{called\_on} must be evaluated first, then the preconditions are checked on
the resulting object, and then this object is used in place of \code{called\_on}
in the RHS. Note that unconditionally evaluating \code{called\_on} is correct
even if the conditions do not hold because it would be evaluated anyway in the
original.

In general, \textbf{RuntimePrecond} imposes some restrictions
which are up to the rule designer and implementer. For example, it should be the
case that the subset of \textbf{varyingSet} used in the preconditions is
evaluated regardless of the result of the precondition check.

In their generic form, the runtime preconditions are also functions that
depend on dynamic information. These can be simple, like the one in
Figure~\ref{fig:sort-values-rule}, or more complicated (i.e., whole
algorithms).

\input{figures/tbl_rewr_rules.tex}

\revis{Table~\ref{tbl:rewr_rules} shows nine more rewrite rules we use in
\system{}. The first two correspond to the examples in Figure~\ref{fig:split}
and Figure~\ref{fig:concat-with-lists}, respectively. The \code{TransformLHS}'s
are simple transformers which output a paremeterized string, similar
Figure~\ref{fig:sort-values-rhs} which we saw above. Also, we introduce some
notation for syntactic preconditions, which are prefixed by $\mathfrak S$. These
are simple syntactic conditions (i.e., equalities on ASTs) which are part of the
LHS (and which are checked in the pattern matcher). They differ from the runtime
preconditions (\textbf{RuntimePrecond}), which are prefixed by $\mathfrak R$. 

Together with the rules in Figure~\ref{fig:sort-values-rule}, the rule that
achieves the rewrite in Figure~\ref{fig:apply_only_math} (named
\code{ApplyOnlyMath}), \code{RemoveAxis1} (which we discuss below) and the
\code{VectorizedConditionals} rule (which we discuss as a case study in
Section~\ref{sub-sec:ablation}), they make up all the rules used in \system{}.
We note that we leave for future work the formal description of the latter three
rules.}

\input{figures/remove_axis_1_lhs.tex}

\paragraph{\textbf{RemoveAxis1}} We will briefly discuss one more rule,
called \code{RemoveAxis1}, whose \textbf{RuntimePrecond} and
\textbf{TransformLHS} components are significantly more complicated. An example
of applying this rule is shown in Figure~\ref{fig:remove-axis-1-ex}. This rule
targets cases where \code{apply()} is applied to a whole \code{DataFrame}. It
checks whether the function passed to \code{apply()} touches only a single
column and if so, it rewrites the code so that the function is applied only to
this column.

We show the LHS in Figure~\ref{fig:remove-axis-1-lhs}. The
\textbf{RuntimePrecond} component, which we do not include here for clarity
purposes, is a whole algorithm which basically checks that only a single column
of the \code{DataFrame} is accessed. The \textbf{TransformLHS} component
replaces all \code{Subscript}'s inside \code{@\{func\}} with just their object
and it removes the \code{axis} argument.

% \input{figures/alg_remove_axis_1.tex}

% Easter egg: This style of typesetting was used in Turing's seminal paper.

%These rewrite rules span simple .... to complex ... \stef{Can't have diversity in how complex the rules are. Either we have such simple rules or way more complicated like vectorization. . As an alternative, I put rules that are tricky and explained all of them concisely.} \charith{Explain 2 rules concisely from the table}. 

% The first rule is the one in Figure~\ref{fig:split} that we discussed earlier. In Section~\ref{sub-sec:case-studies} we present an in-depth case study. %Finally, we have yet another rule that crosses the library boundaries as we move from Pandas to Python (by converting to a list) and then back to Pandas. The interesting thing here is in the preconditions: the name \code{pd} must be bound to the Pandas module. It is possible that there is another module that the user imported as \code{pd} which has a function \code{Series} that accepts lists.

%We note that Series are not just collections of elements. They also have an index with which the elements are accessed. Usually, this is a \code{RangeIndex} \cite{pandas_range_idnex}, i.e. a contiguous range of integers as in Python lists. But it need not be, and thus in rules where the rewritten version is implemented using pure Python and lists, when converting back to a \code{Series}, we need to preserve the original index.

 

%We will now present \system{}, a system that accelerates interactive data science workloads by transparently rewriting Python that interfaces with Pandas code and which addresses all the previously mentioned challenges. In order to do so, \system{} has two high-level components. First, \system{}' \textit{syntactic pattern-matcher} identifies matches the input code against the LHS parts of the rewrite rules. The second component is a \emph{rewriter}, which validates the preconditions of the rewrite rules and on passing them, rewrites the code to the RHS version and executes it. We show a high-level overview in Figure \ref{fig:system_overview}.

%\stef{Elaboration on the Figure?}

%We now describe each component in depth.
