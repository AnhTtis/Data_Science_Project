
\section{Extended Results}

In Section~\ref{sec:Evaluation} we focused only on ten out of the twenty random
notebooks we picked (see Section~\ref{sub-sec:exp-setup}). Here, we include
results for all twenty notebooks.

\paragraph{\textbf{Per-Cell Speedups}} Figure~\ref{fig:ext:cell_level} shows the
cell-level speedups, corresponding to Figure~\ref{fig:cell_level}. The plots
look almost identical, and this is because \system{} does not decelerate
notebooks it does not rewrite. Thus, since this plot includes only slowdowns or
speedups that are outside the 10\% range, there is hardly any discernible
difference. Similar observations are derived from
Figure~\ref{fig:ext:cells-slowdowns}, where the slowdowns are still under
interactive latency, i.e., 300ms.

These results further validate our hypothesis in
Section~\ref{sub-sec:vs-pandas}. That is, the slowdowns we observe are the
result of rewriting, independent of who performs it (in this case, \system{}).

When we include all twenty notebooks, the geometric mean speedup is 1.1$\times$
and the maximum slowdown is 28\%.

\paragraph{\textbf{Per-Notebook Speedups}} In Figure~\ref{fig:ext:nb_level} we
show the notebook-level speedups. This figure corresponds to
Figure~\ref{fig:nb_level}. As we mentioned, \system{} does not rewrite code in
the the ten new notebooks, so we do not see any additional speedup. However, it
remains that the slowdowns, when \system{} does not succeed, are minimal. The
geometric mean speedup is now 1.13$\times$ while the maximum slowdown is 3.5\%.

\paragraph{\textbf{Comparison with Modin}} In
Figure~\ref{fig:ext:modin_nb_level}, which corresponds to
Figure~\ref{fig:modin_nb_level}, our conclusions are again unaltered.
\code{modin} slows down all the ten new notebooks and it rarely scales with the
number of cores. The geometric mean and maximum speedup remain the same (see
Figure~\ref{fig:modin_nb_level}).


In Figure~\ref{fig:ext:modin_nb_mem}, which corresponds to
Figure~\ref{fig:modin_nb_mem}, we show the memory consumption of \system{},
\code{pandas}, and \code{modin}, when we consider all twenty notebooks. The
results are not significantly different for \code{pandas} and \system{}. However,
\code{modin}'s memory consumption becomes even more aggressive. We see that
for one notebook, \code{modin} consumes almost 250GB when \code{pandas} and
\system{} consume less than 5GB.

\hfill{}\\
\hfill{}\\
\hfill{}\\
\hfill{}\\
\hfill{}\\
\hfill{}\\
\hfill{}\\
\input{figures/extended/cells_only_slowdowns.tex}
\input{figures/extended/modin_nb_mem.tex}
\input{figures/extended/ext_nb_level.tex}

\input{figures/extended/cell_level_speedups.tex}

\input{figures/extended/modin_nb_level.tex}