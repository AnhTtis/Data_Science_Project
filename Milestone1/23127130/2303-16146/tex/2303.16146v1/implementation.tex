\section{Implementation}
\label{sec:Implementation}

\subsection{IPython Integration}

\system{} is built on top of IPython \cite{ipython_org}, which is an enhanced
Python interpreter. This implies that a current limitation of our implementation
is that does not work with standard Python. In practice, this is not a problem
because the dominant platform for the notebooks we target is the IPython
notebook (usually accessed through Jupyter \cite{jupyter}), which requires
IPython.

An IPython notebook consists of a collection of code snippets called
\emph{cells}. Each cell can be executed individually, which is commonly done in
interactive EDA workloads. The core feature of IPython that allows \system{} to
operate transparently is the magic function \cite{ipython_magic_functions}.
\system{} leverages magic functions to invoke its rewriter upon cell execution.
Unfortunately, the user needs to add a small annotation on top of every cell
such that \system{} is invoked on every execution. We hope to remove this in a
future version.

An important detail is that \system{} runs on the \emph{same} IPython instance
as the notebook, having access to the same namespace as the underlying cells.
This is necessary for sliced execution, because \system{} needs to inspect the
names, types, objects, etc. of the program. 

Upon running a cell, \system{} gets a single argument, which is the cell
code as a string, which it first parses as an AST. For that, we use the Python
\code{ast} library \cite{python_ast}, which parses Python code. This implies a
limitation because cells can contain invalid Python syntax (but valid for
IPython, e.g., other magic functions), which this library will not handle. This
did not cause serious problems in practice but we hope to fix in the future.
After the code is parsed as an AST, we just match patterns on it using the
pattern matcher, and rewrite/execute it using the rewriter.

\subsection{Crossing Library Boundaries}

It might seem that we could achieve the same optimizations simply by modifying
the \code{pandas} library. For example, consider the problem we described in
Section~\ref{sub-sec:rewriter}, where we have to use complex logic to get the
code of the function passed to \code{apply}. If instead of operating as an
external tool, we modified the internals of \code{apply}, much of this complexity
would vanish. Specifically, \code{apply} gets the function to be called as its
first parameter. So, \system{} could check the code when \code{apply} is called,
possibly rewrite it and call it, all that without changing the interface.


The reason we implemented \system{} as an external tool is it needs to view
\textit{all} the user code (and not just the calls to the library) to perform
rewrites that cross the library boundaries (e.g.,
Figure~\ref{fig:concat-with-lists}). Currently, we only explore the direction of
going from \code{pandas} to Python, which leads to surprising, multiple-fold
speedups. The inverse i.e., going from Python to \code{pandas}, still leads to
speedups, and it is something we hope to explore in the future using rewriting.

% \iffalse
% The first why ust logistics. If we modified the Pandas code,  we would have to
% keep two code bases in-sync, and the user would have to download our version of
% Pandas. With the current approach, the user only has to download and update one
% package.

% ---

% This is not a good argument. If we could support all functionality by changing
% the library, then the user would have to download only one package (our version
% of the library), which they have to do now too. Now, seemingly there can be a
% problem with keeping in sync. Meaning, if our library lacks behind, then the
% user will have to also download Pandas to use the latest features of Pandas. But
% the user anyway has to download Pandas now. Finally, there might be a problem if
% Pandas changes its API and a rewrite that was correct now isn't. This is also.
% In both cases (either as a library or as an external tool), you can solve that
% by checking the version of the library.

% Basically, there is only one reason for not doing it in the form a library and
% that's because it lacks power. That's the reason we give below.
% \fi
