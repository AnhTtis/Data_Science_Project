\subsection{Pandas Rewrite Rules}
\label{sec:pandas_rewr_rules}

\input{figures/sort_values_rule.tex}

\input{figures/tbl_rewr_rules.tex}

%\input{figures/sort_values_formal.tex}

The abstract form of the rewrite rules \system{} supports can be modeled as transforming a Left Hand Side (LHS) set of statements to Right Hand Side (RHS) set of statements subject to certain preconditions on the LHS. 
We introduce some notation to show the structure of our parameterized rewrite rules. The parameterized portions of the rewrite rules are general and can match multiple valid code segments subject to certain conditions (e.g. types). For example consider the original code in Figure~\ref{fig:example_rewrite}(a) rewritten to Figure~\ref{fig:example_rewrite}(b) using the rewrite rule shown in Figure~\ref{fig:sort-values-rule}. %For example consider the rewrite rule shown in Figure~\ref{fig:sort-values-rule}. \system{} uses it to perform the rewrite shown in Figure~\ref{fig:example_rewrite}. We begin with the LHS. 
A \code{@\{...\}} entry denotes a parameterized part of the rule. These parts
can be matched to multiple valid options by \system{}. Inside the curly brackets,
we describe these valid options using a derivation rule of the Python grammar
\cite{python_ast}. For example, \code{@\{expr\}} denotes that any expression can
appear in its place. For \code{Constant}s, we optionally specify the type of the
constant inside parentheses.\footnote{We can determine the type of constants
from the AST \cite{python_ast_constants}.} So, \code{@\{Constant(int)\}} denotes
that any integer constant can appear in its place. We need to refer to the parts of the LHS that are parameterized in the preconditions and the RHS. So, we bind these parts to names. For example, the code string \code{df.sort\_values().head()} matches the LHS of Figure~\ref{fig:sort-values-rule} and \code{called\_on} is bound to \code{df}. Everything that is not in \code{@\{\}} should appear as is.
%It is important to note that the LHS section is concerned purely with syntax. This implies that the bindings, and their uses in the other sections, are purely \textit{textual}; no evaluation happens (a name binding in the LHS is like a macro definition in C). 
With these in mind, we can read the LHS of Figure~\ref{fig:sort-values-rule} as matching any Python expression on which \code{sort\_values()} is applied, followed by \code{head()} with any constant integer as the argument of the formal parameter \code{n}.

There are two kinds of preconditions, syntactic and runtime ones. Syntactic preconditions describe conditions related to the matched \textit{text}. Usually, they require that two matched entries of the LHS are \emph{syntactically} equal. The runtime preconditions describe conditions which have to hold at \emph{runtime} for the original (LHS) and the rewritten code (RHS) to be semantically equivalent and they are expressed in Python syntax and semantics. For example, in Figure \ref{fig:sort-values-rule}, the result of the \code{called\_on} expression that was matched in the LHS should be a \code{pandas.DataFrame}. The runtime preconditions implicitly impose an order of evaluation. In this example, \code{called\_on} must be evaluated first, then the preconditions are checked on the resulting object, and then this object is used in place of \code{called\_on} in the RHS. Note that unconditionally evaluating \code{called\_on} is correct even if the conditions do not hold because it would be evaluated anyway in the original.

%Section~\ref{sec:Evaluation} presents in-depth case studies on real world Pandas codes where non-trivial rewrites enable significant performance improvements. For brevity, we only show the parameterized form of the rewrite rule when the fixed and parameterized parts of the rewrite is not apparent from the context.

% The preconditions should be evaluated when the LHS would be evaluated. If the preconditions pass, then evaluating the RHS should be functionally equivalent with evaluating the RHS. %Finally, in the RHS, we just list the code with which we replace the LHS. %We give a more formal description in Figure \ref{fig:sort-values-formal} in the form of operational semantics \stef{Give citation; not worth describing here}. %\stef{Not sure how to write this last sentence}. %We consider such formal descriptions to be out of scope for this paper, so for the rest of it, we will use our simplified notation of preconditions as in Figure \ref{fig:sort-values-rule}.


% The $\Gamma$'s are contexts, which for simplicity can be thought as snapshots of the Python namespace. Above horizontal line there is a set of premises, which, if true, they entail the statements below the line. The premise $(E, \Gamma_{1}) \Downarrow V, \Gamma_{2}$ states that if the expression $E$ is evaluated under context $\Gamma_{1}$, then its value is $V$ and it updates the context to $\Gamma_{2}$. In short, the rule says that if we evaluate \code{called\_on} first and then check the precondition in Figure \ref{fig:sort-values-rule}, then evaluating the LHS should be functionally equivalent with evaluating the RHS.

%The interpretation of the RHS section is the same as that of the LHS section.

%\charith{Too low level explain with high-level constructs}. \stef{Not sure what this means :/}


Table~\ref{tbl:rewr_rules} shows three more rewrite rules we use in \system{}. The first two correspond to the examples in Figure~\ref{fig:split} and Figure~\ref{fig:concat-with-lists}, respectively. Rules can have both runtime and syntactic conditions. For example, in the second rule, we have the syntactic precondition \code{@\{par1\} == @\{par2\}} requires that the two names be equal. To differentiate between the two kinds of preconditions, we prefix the syntactic preconditions with $\mathfrak S$ and the runtime ones with $\mathfrak R$.

% Easter egg: This style of typesetting was used in Turing's seminal paper.

%These rewrite rules span simple .... to complex ... \stef{Can't have diversity in how complex the rules are. Either we have such simple rules or way more complicated like vectorization. . As an alternative, I put rules that are tricky and explained all of them concisely.} \charith{Explain 2 rules concisely from the table}. 

% The first rule is the one in Figure~\ref{fig:split} that we discussed earlier. In Section~\ref{sub-sec:case-studies} we present an in-depth case study. %Finally, we have yet another rule that crosses the library boundaries as we move from Pandas to Python (by converting to a list) and then back to Pandas. The interesting thing here is in the preconditions: the name \code{pd} must be bound to the Pandas module. It is possible that there is another module that the user imported as \code{pd} which has a function \code{Series} that accepts lists.

%We note that Series are not just collections of elements. They also have an index with which the elements are accessed. Usually, this is a \code{RangeIndex} \cite{pandas_range_idnex}, i.e. a contiguous range of integers as in Python lists. But it need not be, and thus in rules where the rewritten version is implemented using pure Python and lists, when converting back to a \code{Series}, we need to preserve the original index.

 

%We will now present \system{}, a system that accelerates interactive data science workloads by transparently rewriting Python that interfaces with Pandas code and which addresses all the previously mentioned challenges. In order to do so, \system{} has two high-level components. First, \system{}' \textit{syntactic pattern-matcher} identifies matches the input code against the LHS parts of the rewrite rules. The second component is a \emph{rewriter}, which validates the preconditions of the rewrite rules and on passing them, rewrites the code to the RHS version and executes it. We show a high-level overview in Figure \ref{fig:system_overview}.

%\stef{Elaboration on the Figure?}

%We now describe each component in depth.
