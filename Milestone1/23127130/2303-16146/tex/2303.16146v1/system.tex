\section{\system{} Overview}
\label{sec:System}

\input{figures/system_overview.tex}

%We now present \system{}, a system that accelerates interactive data science workloads by transparently rewriting Python that interfaces with Pandas code and which addresses all the previously mentioned challenges. In order to do so, \system{} has two high-level components. First, \system{}' \textit{syntactic pattern-matcher} identifies matches the input code against the LHS parts of the rewrite rules. The second component is a \emph{rewriter}, which validates the preconditions of the rewrite rules and on passing them, rewrites the code to the RHS version and executes it. We show a high-level overview in Figure \ref{fig:system_overview}.

We now present the high-level architecture of \system{}, a rewrite engine that
automatically applies rewrite rules to improve the performance of ad-hoc EDA
workloads.

We designed \system{} with two high-level components. First, \system{}'
\textit{syntactic pattern matcher} matches the input code against the left-hand
side (LHS) parts of the rewrite rules and validates the syntactic preconditions.
The second component is a \emph{rewriter}, which checks the runtime
preconditions of the rewrite rules and on success, rewrites the code to the
right-hand side (RHS) version and executes it. We show a high-level overview in
Figure \ref{fig:system_overview}.

We have several desiderata for \system: it should facilitate applying complex
rewrites automatically with minimal overhead. Further, it should guarantee that
the rewritten code is semantically equivalent to the original code. There are
two main challenges in achieving these goals.

\paragraph{\textbf{Preserving Correctness of the Rewrites}} \system{} needs to
emit dynamic checks to ascertain whether runtime preconditions are preserved.
Some of these checks are quite involved, for example, checking the form of whole
functions. Further, certain checks concerning a statement can only be performed
after all the code up to that statement has been executed. For these reasons, the
rewriter should be a rewriter, an executor, and a dynamic checker.

\paragraph{\textbf{Tight Latency Budget}} EDA notebooks are created
incrementally, where the user is in a continuous write-execute-inspect loop.
Thus, we cannot optimize the notebook offline because we do not have the code.
This demands that the system operate at \textit{runtime}, which enforces a tight
latency budget. Ideally, rewrites should be applied within interactive speeds
(i.e., under 300ms).

\hfill{}

In the subsequent sections, we describe how we designed the pattern matcher (Section~\ref{sub-sec:patt-match}) and the 
rewriter (Section~\ref{sub-sec:rewriter}) to overcome these challenges. First, we introduce the structure of the rewrite rules briefly in Section~\ref{sec:pandas_rewr_rules}.

% In this Figure, the pattern-matcher matched an LHS (highlighted in green); a substring search for the string \code{'G'} in \code{df['Name']}. We can do the same substring search but much faster. Note that the pattern-matcher, in accordance with our descriptions of the LHS's, identifies purely syntactic patterns. So, it does not (and cannot) perform semantic-related or dynamic checks.

% Having matched an LHS, \system{} uses. For example, to rewrite the substring search, the name \code{df} should be of type \code{DataFrame}, otherwise the rewriting is (possibly) invalid. Most of the time, the rewriter can bake these dynamic checks as part of the rewritten code (as in Figure \ref{fig:system_overview}). This is not always possible though but we will return to this later.

\input{figures/example_rewrite.tex}
\input{rewrite-rules.tex}

%\input{figures/multi_stmt_patt.tex}

\section{\system{} Rewrite System}

\system{} consists of two main parts: a syntactic pattern matcher and a rewriter that rewrites the code matched against patterns. We now describe how the two parts were designed in detail.

\subsection{\system{} Pattern Matcher}
\label{sub-sec:patt-match}

\input{figures/lst_patt_match.tex}

The pattern matcher is responsible for matching a sequence of statements with
the LHS part of any rewrite rule. This is reminiscent of regular expressions,
but the language we match is not regular. So, instead, we parse the code as a
Python abstract syntax tree (AST) \cite{python_ast} and do pattern matching at
the AST level.

%\system's pattern-matcher needs to operate within interactive
%latencies. 
To minimize matching overhead, we designed the pattern matcher to factor patterns based on their commonalities. The common parts are matched first before hierarchically matching more specific components of a rule. This eliminates repeatedly matching components that are common to multiple rules.

%\system{} factors patterns based on their commonalities to One method of matching patterns would be to check the whole AST
%against individual patterns. However, this would result in redundant work.
%Instead, \system{} factors patterns based on their commonalities.

Consider the pattern-matching code that matches two patterns: the third pattern of Table~\ref{tbl:rewr_rules} and the one that enables the rewrite of Figure~\ref{fig:apply_only_math}. The LHS of the former is shown in the table. The LHS of the latter is \code{@\{expr: e\}.apply(@\{Name: fun\}, axis=1)} (see Section~\ref{sub-sec:rewriter}). Notice that these LHS's share parts; they both require a function call, that is an attribute of some expression and the name of the function is \code{apply}. We want to check the common parts of the pattern at a single place to exploit commonalities across patterns. Listing~\ref{lst:patt-match} shows a sketch of the pattern-matching code that matches these two patterns. %The input is a statement represented as an AST. The function returns an object representing a pattern if it matches one, or None otherwise. 
It recursively loops through all the AST nodes of type \code{stmt} and checks for the two patterns by first checking for an attribute function called \code{apply} and then matching against either one of the patterns specifically. %The code performs exactly what we described with words by performing the check of an attribute function called \code{apply} only once. The difficulty of this exploitation of commonalities is in not writing the code but in identifying the commonalities.

%For example, suppose we want to create a pattern-matcher that matches only two patterns: the second pattern of Table~\ref{tbl:rewr_rules} and the one that enables the rewrite of Figure~\ref{fig:apply_only_math}. The LHS of former is shown in the table. The LHS of the latter is \code{@\{expr: e\}.apply(@\{Name: func\})}. Notice that these LHS's share parts; they both require a function call, that is an attribute of some expression and the name of the function is \code{apply}. It is exactly such commonalities that we want to exploit and more specifically, we want to check the common parts only once. Algorithm~\ref{alg:patt-match} shows a sketch of an algorithm that matches these two patterns. The input is a statement represented as an AST. The function returns an object representing a pattern if it matches one, or None otherwise. The body of the function recursively loops through all the nodes of \code{stmt} and checks for the two patterns. The code performs exactly what we described with words by performing the check of an attribute function called \code{apply} only once. The difficulty of this exploitation of commonalities is in not writing the code but in identifying the commonalities.

Lastly, the pattern matcher needs to be able to match patterns that span multiple statements. %For example, one rewrite we support is shown in Figure \ref{fig:multi_stmt_patt}.
Having a function that matches single-statement patterns (like the one in Listing~\ref{lst:patt-match}), there is another function that matches multiple statements. The latter function operates on a higher level, viewing multi-statement patterns as sets of smaller ones. So, for a 2-statement pattern, if it matches the first part, it will then checks the next statement for the second part.

\subsection{\system{} Rewriter}
\label{sub-sec:rewriter}

%\input{pandas_code_rewriting.tex}
%\input{rewrite-rules.tex}

%\subsection{Applying Rewrites}

When a piece of code is successfully matched with a rewrite rule's LHS, if there
are no preconditions, the rewriter can emit the RHS code in place of the LHS and
execute it. This is simple and it is done with a series of AST transformations.
However, checking preconditions is challenging because the rewriter must check
them at points, during the execution, when it is correct to do so.

To check the preconditions, the rewriter needs to derive facts about the
execution of the Python program (e.g., the type of an object at a particular
point). Ideally, we would derive such facts from static program analysis.
However, since Python is dynamically typed, we cannot statically determine how a
Python program will behave when executed. Further, Python does not have a
complete description of its formal semantics (e.g., \cite{k_fram_python} is not
complete). Thus, even advanced program analyses over Python are limited
\cite{static_anal_python}.

The natural alternative is to derive these facts dynamically during execution.
In particular, we are interested in knowing the type of Python objects. Python
programs can introspect their own objects and so the simplest way to perform a
check is to include the code that performs the check as part of the rewritten
code. This is conceptually simple and it fits simple checks (like the
type-related ones). This is what we do in Figure \ref{fig:system_overview}.
There, we insert code that checks the preconditions. We also insert the RHS and
the program will branch to it if the preconditions are satisfied. Otherwise, we
branch to the original code. However, notice that this style of a check requires
that we know the (concrete version of the) RHS a priori. This is not the case
for all rewrite rules.

\paragraph{\textbf{Sliced Execution}}

Let us consider a more demanding rule; that of
Figure~\ref{fig:apply_only_math}. For this rewrite to be correct, the
function passed to \code{apply()} must have a certain form. Then, a rewrite rule
for this rewrite could have an LHS that matches a function definition with that
form, followed by a call (on an \code{expr}) to \code{apply()} with the name of
the defined function as the first argument. Such a rule would have a subtle
benefit. Observe that when we perform this rewrite, we rewrite the function
passed to \code{apply()}, which means we need to \textit{know} the code of the
function at the time of rewriting. Because the function body is matched as part
of the LHS, we do know it.

However, this rule is weak. More specifically, the function definition may not
appear in the same cell or even notebook (it might be part of an external
library). One way to strengthen the rule is to relax the LHS onto just \code{@\{expr:
df\}.apply(@\{Name: fun\}, axis=1)} (so, the function definition is not part of
the LHS and the first argument can be any \code{Name}) and add the condition
that the function should follow a certain form to the runtime
conditions.\footnote{A function is an object in Python, that we can inspect and
recover its source code. So, checking this condition at runtime is possible.}
The rewriter now needs to insert the code that checks the form of the function
as part of the rewritten code, similar to checking the type of an object.

But what is the RHS that we emit? Remember that to create the rewritten version
we need the code of the function. Thus, we end up having to also emit the code
that does the rewriting as part of the rewritten code! On confronting this
situation, we searched for an alternative solution as that one would result in
huge code duplication and unintelligible generated code \footnote{Note, however,
that this solution is possible.}.

This gave rise to sliced execution. In this mode, we execute the code up to, but
not including, the call to \code{apply}. Then, stop and inspect the code of the
passed function and check the preconditions. Upon passing, we rewrite the code
on the fly, and then we execute it. Essentially, we have two forms of rewrite
rules: The regular and the deferred ones. For regular rewrite rules, all the
checks can happen either statically or they are simple enough that we bake them
in the rewritten code. On the other hand, for the deferred ones, we need to have
executed all the code up to some statement involved in the rule to perform the
necessary dynamic checks and rewriting. For this reason, we may need to do many
rounds of check-rewrite-execute, which effectively means that we split the cell
into slices. We signify this flow with the back-edge in Figure
\ref{fig:system_overview}.

%\input{figures/columnar.tex}


% In retrospect, there is a much better solution (in terms of code complexity of \system{} and in terms of the correctness it provides and in terms of being more transparent to the user) which is an improvement over the problematic solution we wanted to avoid. Instead of inserting the code that performs the checks and the rewriting as part of the rewritten code, we put them in functions and in the rewritten code we just insert a call to them (after all, \system{} can act as a library). This would achieve the same effect as sliced execution but all the complexity of the latter goes away as it now happens organically. We aim to do this in a future version.
