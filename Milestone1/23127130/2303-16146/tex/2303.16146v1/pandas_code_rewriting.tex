
\subsection{Pandas Code Rewriting}

\stef{Section overview?}



\charith{Let's use the following paragraph structure:
\begin{itemize}
    \item Introducing rewrites
    \item Non-obvious rewrites
    \item Why an automatic rewrite system is neededs of such a system over exisiting solutions (it does not have the 3 drawbacks, plus it gets good speedups)
    \item What are the non-obvious benefits we get from a rewrite system (going beyond abstraction boundary)
\end{itemize}}

%% purpose of the para: introducing rewrites and why other systems may not address it.
Rewriting, for optimization purposes, is the process of replacing some part of code with a functionally equivalent but faster version. As an example, consider the task of selecting the 5 smallest elements of a \code{DataFrame} column. Figure \ref{fig:sort_values} shows user-written code, extracted from a Kaggle notebook, that performs this task. The same code can be rewritten as in Figure \ref{fig:nsmallest}. Figure \ref{fig:sort_values} first sorts the values and then selects the first 5 elements whereas the code in Figure \ref{fig:nsmallest} uses the Pandas function \code{nsmallest}, which selects the \code{n} smallest elements directly. As we can expect, Figure \ref{fig:nsmallest} is faster. Similarly, there are many opportunities in real-world notebooks to perform rewrites into more optimized versions. %We describe such rewrite opportunities in detail in Section~\ref{}.

Rewriting appears simple, but it can be challenging when performed manually. There are many non-obvious rewrites that the user may not be able to discover easily. For example, it might seem that the only way to make \code{pandas} code faster through rewriting is by replacing it with other \code{pandas} code, or using a similar library such as \code{numpy}. This has been reinforced over years of data scientists being trained to remain within \code{pandas}/\code{numpy} as much as possible because these use native, vectorized implementations and are thus much faster pure Python.

\input{figures/split.tex}

It might, then, be surprising that moving out of \code{pandas} and into pure Python can lead to (significant) speedups. One example is shown in Figure \ref{fig:split}. The task here is to split a \code{Series} of strings by the delimiter \code{'('}. The code in Figure~\ref{fig:split_pandas} (extracted from a Kaggle notebook) does it by using a \code{pandas}-provided function. One would expect that this is the best way to perform this operation. Nevertheless, the version in Figure \ref{fig:split_python} is 3.5$\times$ faster. %What this code does is seemingly completely unorthodox. 
It moves from \code{pandas} to pure Python (by converting \code{df['C']} to a Python list) and performs the operation with a sequential Python loop \footnote{It then converts the results to \code{Series} for functional equivalence with the original. Note that it has to have the same index; more on that later.} (in our case studies in Section~\ref{sub-sec:case-studies}, we explain why this version is faster). We detail some of the rewrite rules we use in Section~\ref{sec:pandas_rewr_rules} including these complex rules.

It is unreasonable to expect general \code{pandas} users to comprehend Python, \code{pandas}, and \code{numpy} to such an extensive level so as to be able to discover such equivalent versions and evaluate their relative performance. Second, even if the user succeeds in these tasks, the rewritten version can be significantly harder to write and read, as is evident from Figure \ref{fig:split}. This can further lead to correctness concerns about the rewrite. Third, manual rewriting breaks the library abstraction. In the original code of Figure \ref{fig:split}, the user has to think only of \emph{what} \code{split()} does. But, to come up with the rewritten version, this abstraction is broken as the user needs to think of \emph{how} to implement it. %Finally, rewriting becomes more complicated once correctness concerns arise. 

%\input{figures/apply_vectorized.tex}

This motivated us to build \system{}, a system that performs such rewrites \textit{automatically}, by guaranteeing \textit{correctness} and with minimal overhead. Section \ref{sec:System} describes the internal workings of \system{} in detail. 

Rewriting avoids the previously mentioned drawbacks of library-based optimization systems. First, it inherently does not suffer from a lack of API support since the rewritten code uses only \code{pandas} and Python features that are already supported. \stef{The previous seems to miss the important and exciting fact that the rewriter is fundamentally different. The lack of API support does not even make sense in this context. I'd rewrite it as: "because it is fundamentally different: it is not a replacment for \code{pandas} and it can always leave the code untouched if it cannot handle it.}  Second, the rewriting overheads scale proportionally only to the code, not the data. %In fact, the code of a single cell. 
%IPython notebooks (see Section \ref{sec:Implementation)}) are populated incrementally and thus the rewriter cannot know all the code. 
\system{} considers only a single cell at a time \footnote{it could also consider the history, although we have not found that necessary} and needs to save only the AST representation of the code and a few light and ephemeral internal data structures during rewrite code generation. %Further, the rewritten code only have a few dynamic checks. 
These overheads are thus negligible both in terms of memory and execution time \charith{Do we have numbers to show this overhead is low?}. \stef{Yes. I have to add plots}
%On the other hand, pattern-matching and rewriting reduce to fast tree search and a few dynamic checks.
%These overheads are thus negligible both in terms of memory and execution time.
Finally, when the rewriter succeeds, the rewritten code is almost always faster than the original, to the extent that there are such patterns. As we will show in Section \ref{sec:Evaluation}, the patterns we have used always result in speedups except for degenerate cases. \stef{Do we need data that the patterns always result in a speedup?}

Additionally, there are fundamental advantages \system{} has over library based optimization approaches. The rewrite system is transparent. When the user observes a speedup, they can always see the code that the rewriter used. In other words, the user does not need to understand the system to understand the cause of the speedup. At the same time, the user's code remains intact. Further, rewriting has the benefit of being able to optimize across library boundaries. For example, \system{} can automatically perform the rewrite that we described in Figure~\ref{fig:split}. \stef{This example does not drive the point home because a library could do it. That's why I had another simple example which cross library boundaries} To perform this rewrite, a tool needs to view all the code and understand semantic equivalences and differences across library boundaries (in this case \code{pandas} and the host language, Python). This is not possible with optimization appproaches that purely aim at accelerating Panadas functions.  %However, a rewriter is naturally such a tool as it views all the user code. 
However, because the rewriter views, and understands, both the library semantics and also the host language semantics (in this case, Python), it can optimize across library boundaries.


%There are many advantages of using automatic Pandas code rewriting to optimize Pandas workloads. One such advantage is that an automatic rewriting system preserves the readability and interpretability of the code. When the user observes a speedup, they can always see the code that the rewriter used. In other words, the user does not need to understand the system to understand the speedup cause. At the same time, the user's code remains intact in case they want to change it later. Second, a rewriting system has low implementation complexity. By complexity, we do not mean lines of code, as this is an irrelevant metric. Rather, the really burdensome complexity is the mental one, which is increased mostly as the number of interactions between different parts of code increases. A rewriting system's complexity is low because it needs only clearly separated components. Furthermore, the complexity does not increase with every new pattern because the patterns are independent.

%Rewriting also avoids the previously mentioned drawbacks. First, a rewriting system for Pandas is not a replacement for Pandas but a clear addition. Therefore, it inherently does not suffer from a lack of API support. Second, the rewriting overheads scale proportionally only to the code, not the data. In fact, the code of a single cell. IPython notebooks (see Section \ref{sec:Implementation)} are populated incrementally and thus the rewriter cannot know all the code. Thus, it has to consider a single cell at a time \footnote{it could also consider the history, although we have not found that necessary}. These overheads are thus negligible both in terms of memory and execution time. On the one hand, a rewriting system needs to save only the AST representation of the code and a few light internal data structures. On the other hand, pattern-matching and rewriting reduce to fast tree search and a few dynamic checks. Finally, when the rewriter succeeds, the rewritten code is almost always faster than the original, to the extent that there are such patterns. As we will show in Section \ref{sec:Evaluation}, the patterns we have used always result in speedups except for degenerate cases. \stef{Do we need data that the patterns always result in a speedup?}

%\input{figures/concat_with_lists.tex}

%As a last note, we note that rewriting has the non-obvious benefit of optimizing across library boundaries. Consider the case of concatenating two Pandas Series. Figure \stef{add it} shows user-written code extracted from a Kaggle notebook. The user (e.g., because they don't remember what Pandas API call performs the equivalent operation) first converts the Series into lists, concatenates them, then converts the result to a Series. Pandas provides a function to concatenate two Series directly, as shown in the rewritten version in Figure \stef{add it}. To perform this rewrite, a tool needs to view all the code because when converting the Series to lists, we \textit{cross} the library boundaries. At this point, Pandas (or any replacement for Pandas) has no control. A rewriter is naturally such a tool as it views all the user code. In summary, because the rewriter views, and understands, both the library semantics but also the host language semantics (in this case, Python), it can optimize across library boundaries.


