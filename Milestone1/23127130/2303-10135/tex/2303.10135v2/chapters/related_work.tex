\section{Related Work}

\paragraph{Assembly Sequence Planning} 
A popular assembly graph representation for \gls{asp} is the AND/OR Graph~\cite{54734}, a formalism to encode the space of feasible assembly sequences, which can be created with the Disassembly For Assembly strategy~\cite{1087132, 1217194, 7559140, 7294142}. 
However, these approaches are restricted on time to find a solution efficiently due to the feasibility checks.
While graph search methods are impractical for larger assemblies because of the combinatorial explosion problem, heuristic intelligent search methods provide another alternative.
They reject infeasible sequences and search for feasible ones close to the optimal based on manually designed termination criteria\cite{9762444, Iwankowicz2016}, learned~\cite{chen2008three,sinanouglu2005assembly} or hand-crafted~\cite{Rashid2017} energy functions.
More recently, Zhao \etal\cite{zhao2019aspw} and Watanabe \etal\cite{watanabe2020search} applied deep \gls{rl} for \gls{asp}.
Different to us, they do not have a graph representation to take into account relations between parts.
Targeting at \gls{rasp}, Rodriguez \etal\cite{rodriguez2019iteratively, rodriguez2020pattern} suggested inferring assembly rules (\eg a specific part should be assembled before another), which can be transferred from previous identified sub-assemblies to those of larger sizes to prune the search space, thus reducing planning time.
Their approach only produces rules, from which the final assembly sequences need to be derived additionally.
It also requires further re-training when adapting to other product variants.
Enlightened by them, we refine their graph representation to a more fine-grained level and adapt their idea with a learning-based approach, aiming to mitigate these issues. 
Similar to us, Ma \etal\cite{ma2022planning} used \gls{gnn} for \gls{asp} of LEGO structures. 
However, they differ from us in two aspects, first they do not consider assembly robots in the loop and second they model assemblies only with a coarser graph representation whose edges only consider connections among parts instead of part surfaces.
To clearly show different characteristics among relevant works, we provide a concise comparison in Tab. \ref{tab:comparison}.

\paragraph{Graph Representation Learning in Task Planning} 
In this setting, graphs commonly incorporate nodes for manipulated objects~\cite{nguyen2020self,bapst2019structured,zhu2021hierarchical}, their target positions~\cite{lin2022efficient,funk2022learn2assemble} and the robot gripper~\cite{ye2020object}. 
Edges can represent high-level relations between objects~\cite{nguyen2020self,zhu2021hierarchical}.
With the graph representation, Zhu \etal~\cite{zhu2021hierarchical} and Ye \etal~\cite{ye2020object} generated feasible candidate paths by sampling, and trained a network that predicts a sequence of feasible actions in backward and forward search, respectively. 
Nguyen \etal~\cite{nguyen2020self} performed sampling to find action sequences that transform the source to target graph and then used optimization to eliminate invalid sequences subject to the environment constraints. 
Besides, some researchers resorted to \gls{rl}~methods such as~\cite{bapst2019structured,funk2022learn2assemble}, and \cite{li2020towards}, who used \gls{gnn}s for task planning.
Recently, Lin \etal~\cite{lin2022efficient} utilized \gls{il} to train two \gls{gnn}s, one for selecting objects in the scene and another picking a suitable goal state from a set of possible goal positions for long-horizon manipulation tasks.
Inspired by them, we train our \gls{gnn}s for \gls{rasp} task by leveraging \gls{il} for ease and efficiency in training.
