\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[legalpaper, margin=1in]{geometry}
\usepackage{algorithm}
\usepackage{amsmath}
% \usepackage{caption}
\usepackage{color,soul}
\usepackage{bm}
\usepackage{natbib}

\title{Constructing the Rashomon set of Generalized Additive Models}
% \author{Chudi Zhong}
\date{}

\begin{document}

\maketitle

\section{Introduction}
Generalized additive models (GAMs), which combine several flexible single-feature models through a linear function, are fundamental type of important algorithms for interpretable machine learning. Current state-of-the-art algorithm FastSparse \citep{???} can output a single sparse model using a subset of features, leaving a gap between the model that minimize the loss function and a model with almost-similar-loss but benefits users' needs. This project provides a new algorithm to construct the Rashomon set for GAMs when the support set is fixed. The algorithm is also able to find the Rashomon set when the support set is slightly changed, e.g. $18<\textrm{age}\leq 20$ is changed to $18<\textrm{age}\leq 23$.

\section{Methodology}
\begin{enumerate}
    \item proof logistic loss function + $\ell_2$ difference is bounded and convex. It means our framework is suitable for all convex loss + convex penalty objective functions
    \item proof that all other dimensions are fixed, the segments formed by one dimension intersects with $\epsilon$ is concave. 
    
\end{enumerate}

\section{Algorithm}

\definecolor{comment}{rgb}{0.2,0.4,0.2}
\def\comment#1{\textcolor{comment}{\textit{ // #1 }}}

\begin{algorithm}[ht]
\caption{RSetGAMS$(\bm{\omega}, X, y, \lambda, \theta, \delta, \textrm{max\_iter})$}
\begin{tabbing}
xxx \= xx \= xx \= xx \= xx \= xx \kill
1: \textbf{for} $t \in \{1, \textrm{max\_iter}\}$ \textbf{do}\\
2: \> \textbf{for} $j \in \{1,...,K\}$ \textbf{do}\\
\> \> \comment{find the left and right boundaries for $\omega_j$. Given all other coefficients fixed, $\omega_j$ can take any }\\
\>\>\comment{values between the left and right boundaries to make the model be in the Rashomon set.}\\
3: \> \> $\omega_j^{\textrm{left}}, \omega_j^{\textrm{right}} \leftarrow$ 
GET\_SEGMENTS\_ENDS($j, \bm{\omega}, X, y, \lambda, \theta,\delta$)\\
\>\> \comment{Find a value for $\omega_j$ within $[\omega_j^{\textrm{left}}, \omega_j^{\textrm{right}}]$ s.t. the volume of the polytope is maximized.} \\
\>\> \comment{A bracketing search algorithm is used.}\\
4: \>\> \textbf{while} $|\omega_j^{\textrm{right}}-\omega_j^{\textrm{left}}| > \delta$ \textbf{do}\\
5: \>\>\> $\omega_j^{mid_1} \leftarrow \omega_j^{\textrm{left}} + (\omega_j^{\textrm{right}}-\omega_j^{\textrm{left}}) / 3$\\
6: \>\>\> $\omega_j^{mid_2} \leftarrow \omega_j^{\textrm{left}} + 2 \times (\omega_j^{\textrm{right}}-\omega_j^{\textrm{left}}) / 3$\\
7: \>\>\> $\bm{\omega}[j] \leftarrow \omega_j^{mid_1}$\\
7: \>\>\> $V_{mid_1} \leftarrow$ GET\_VOLUME($\bm{\omega}, X, y, \lambda, \theta$)\\ 
7: \>\>\> $\bm{\omega}[j] \leftarrow \omega_j^{mid_2}$\\
8: \>\>\> $V_{mid_2} \leftarrow$ GET\_VOLUME($\bm{\omega}, X, y, \lambda, \theta$)\\ 
9: \>\>\> \textbf{if} $V_{mid_1} < V_{mid_2}$ \textbf{then}\\
10: \>\>\>\> $\omega_j^{\textrm{left}} \leftarrow \omega_j^{mid_1}$\\
11: \>\>\> \textbf{else}\\
12: \>\>\>\> $\omega_j^{\textrm{right}} \leftarrow \omega_j^{mid_2}$\\
13: \>\> $\bm{\omega}[j] \leftarrow \omega_j^{\textrm{left}}$\\
13: \>\> $V_{\textrm{left}} \leftarrow$ GET\_VOLUME($\bm{\omega}, X, y, \lambda, \theta$)\\
13: \>\> $\bm{\omega}[j] \leftarrow \omega_j^{\textrm{right}}$\\
14: \>\> $V_{\textrm{right}} \leftarrow$ GET\_VOLUME($\bm{\omega}, X, y, \lambda, \theta$)\\
15: \>\> \textbf{if} $V_{\textrm{left}} < V_{\textrm{right}}$ \textbf{then}\\
16: \>\>\> $\bm{\omega}[j] \leftarrow \omega_j^{\textrm{right}}, V \leftarrow V_{\textrm{right}}$\\
17: \>\> \textbf{else}\\
18: \>\>\> $\bm{\omega}[j] \leftarrow \omega_j^{\textrm{left}}, V \leftarrow V_{\textrm{left}}$\\
19: \textbf{return} $\bm{\omega}, V$
\end{tabbing}
\end{algorithm}

\begin{algorithm}[ht]
\caption{GET\_SEGMENTS\_ENDS$(j, \bm{\omega}, X, y, \lambda, \theta, \delta)$}
\begin{tabbing}
xxx \= xx \= xx \= xx \= xx \= xx \kill
\comment{Aggressively get left and right boundaries for $\omega_j$ s.t. the losses at these boundaries are larger than $\theta$. }\\
\comment{This gives a range for binary search. }\\
1: $l \leftarrow$ GET\_BOUNDS($j, \bm{\omega}, \theta, \delta, left=$True)\\
2: $r \leftarrow$ GET\_BOUNDS($j, \bm{\omega}, \theta, \delta, left=$False)\\
\comment{Use the binary search to find the left and right ends for $omega_j$ s.t. the losses at these ends are smaller }\\
\comment{than or equal to $\theta$.}\\
3: $\omega_j^{\textrm{left}} \leftarrow$ BINARY\_SEARCH($j, \bm{\omega}, l, \omega_j, \theta, \delta$)\\
4: $\omega_j^{\textrm{right}} \leftarrow$ BINARY\_SEARCH($j, \bm{\omega}, \omega_j, r, \theta, \delta$)\\
5: \textbf{return} $\omega_j^{\textrm{left}}, \omega_j^{\textrm{right}}$\\
-------------------------------------------------------------------------------------------------------------------------------------------------\\
\textbf{subroutine} GET\_BOUNDS($j, \bm{\omega}, \theta, \delta, left$)\\
6: \textbf{if} $left$ \textbf{then}\\
7: \> $\delta \leftarrow -\delta$\\
8: $\omega_j^{\textrm{end}} \leftarrow \omega_j$\\
9: \textbf{while} True \textbf{do}\\
10: \> $\omega_j^{\textrm{end}} += \delta$\\
11: \> \textbf{if} $R(\bm{\omega}_{-j}, \omega_j^{\textrm{end}}, X, y) > \theta$ \textbf{then}\\
12: \>\> \textbf{return} $\omega_j^{\textrm{end}}$\\
13: \> \textbf{else}\\
14: \>\> $\delta \leftarrow 2\times \delta$\\
-------------------------------------------------------------------------------------------------------------------------------------------------\\
\textbf{subroutine} BINARY\_SEARCH($j, \bm{\omega}, l, r, \theta, \delta$)\\
15: \textbf{while} True \textbf{do}\\
16: \>\> $\omega_j^{mid} \leftarrow (l+r)/2$\\
17: \>\> \textbf{if} $R(\bm{\omega}_{-j}, \omega_j^{\textrm{mid}}, X, y) > \theta$ \textbf{then}\\
18: \>\>\> $r \leftarrow \omega_j^{\textrm{mid}}$\\
19: \>\> \textbf{else}\\
20: \>\>\> \textbf{if} $|r-l| < \delta$ \textbf{then}\\
21: \>\>\>\> \textbf{return} $\omega_j^{\textrm{mid}}$\\
22: \>\>\> \textbf{else}\\
23: \>\>\>\> $l \leftarrow \omega_j^{mid}$
\end{tabbing}
\end{algorithm}

\begin{algorithm}[ht]
\caption{GET\_VOLUME$(\bm{\omega}, X, y, \lambda, \theta, \delta)$}
\begin{tabbing}
xxx \= xx \= xx \= xx \= xx \= xx \kill
1: $V \leftarrow 1$ \comment{Initialize the volume}\\
2: \textbf{for} $j \in \{1,...,K\}$ \textbf{do}\\
3: \> $\omega_j^{\textrm{left}}, \omega_j^{\textrm{right}} \leftarrow \textrm{GET\_SEGMENTS\_ENDS}(j, \bm{\omega},\lambda, \theta, \delta)$\\
4: \> $V \leftarrow V \times (\omega_j^{\textrm{right}}- \omega_j^{\textrm{left}})$\\
5: \textbf{return} $V$
\end{tabbing}
\end{algorithm}

\section{Applications}
\begin{enumerate}
    \item adversarial attack 
    \item counterfactual explanations
\end{enumerate}

\end{document}
