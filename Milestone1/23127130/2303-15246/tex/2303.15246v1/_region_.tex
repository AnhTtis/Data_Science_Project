\message{ !name(main.tex)}\documentclass[a4paper,11pt]{article}

\usepackage{jheppub}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{todonotes}

\graphicspath{{figures/}}

\DeclareMathOperator{\tr}{tr}

\begin{document}

\message{ !name(Improvements.tex) !offset(12) }
weights has only a minor impact on the statistical convergence,
cf.~\todo{equation}.

The computational cost of cell resampling tends to be completely
dominated by the nearest-neighbour search in step 2. In a naive
approach, one has to calculate the distances between the cell seed and
each other event in the sample. Since the number of cells is
proportional to the sample size $N$, the total computational
complexity is $\mathcal{O}(N^2)$. This renders the naive approach
unfeasible for samples with more than a few million events. For this reason,
an alternative approximate nearest-neighbour search based on
locality-sensitive hashing (LSH)~\cite{Indyk1998,Leskovec:2020} was
considered in~\cite{Andersen:2021mvw}. While this lead to an improved
scaling behaviour, the quality of the approximate search was also
found to deteriorate with an increasing sample size. An improved
version of this algorithm, discussed in appendix~\ref{sec:LSH_search}, still appears
to suffer from the same problem. In section~\ref{sec:nearest-neighbour_search}, we introduce an
exact search algorithm that is orders of magnitude faster than the
naive search.

The problem of costly distance calculations is further exacerbated by
the fact that a direct implementation of the originally proposed
distance function suffers from poor scaling for high
multiplicities. To compute the distance between to events $e$ and
$e'$, we first cluster the outgoing particles into infrared-safe
physics objects, e.g.~jets. We collect objects of the same type $t$
into sets $s_t$ for $e$ and $s_t'$ for $s$. The distance between the
two events is then
\begin{equation}
  \label{eq:d_event}
  d(e,e') = \sum_{t=1}^{T}d(s_t, s_t'),
\end{equation}
where $d(s_t, s_t')$ is the distance between the two sets $s_t, s_t'$. It is given by
\begin{equation}
  \label{eq:d_set}
  d(s_t,s_t') = \min_{\sigma \in S_P} \sum_{i=1}^P d(p_i, q_{\sigma(i)})\,,
\end{equation}
where $p_1,\dots, p_P$ are the momenta of the objects in $s_t$ and
$q_1,\dots, q_P$ the momenta\footnote{If the number of objects in $s_t$
and $s_t'$ is different, we add auxiliary objects with vanishing
momenta as described in~\cite{Andersen:2021mvw}.} in $s_t'$. The sum
runs over all permutations in the symmetric group $S_P$, i.e.~over
$P!$ terms. For large multiplicities $P$ a direct calculation quickly
becomes prohibitively expensive. In~\cite{Andersen:2021mvw}, it was
therefore suggested to use an approximate scheme in this case. In
section~\ref{sec:set-to-set-distance} we discuss how the set-to-set distance can be
calculated both exactly and efficiently.

\subsection{Nearest-Neighbour Search}
\label{sec:nearest-neighbour_search}

Our improved nearest-neighbour search is based on vantage-point
trees~\cite{UHLMANN1991175,10.5555/313559.313789}. To construct a
vantage-point tree, we choose a single event as the first vantage
point. We then compute the distance to the vantage point for each
event. The closer half of the events lie within a hypersphere with
radius given by the median distance to the vantage point. We call the
populated part of this hypersphere the \emph{inside region} and its
complement the \emph{outside region}. We then recursively construct
vantage-point trees inside each of the two regions. The construction
terminates in regions that only contain a single point.

To find the nearest neighbour for any event $e$, we start at the root
of the tree, namely the first chosen vantage point. We calculate the
distance $D$ between this vantage point and $e$. If $D$ is less than
the radius $R$ of the hypersphere defining the inside region, we first continue the search in
the inside subtree, otherwise we choose the outside subtree
first. Let us first consider the case that the inside region is
the preferred one. It will contain a nearest-neighbour \emph{candidate} with
a distance $d$ to the initial event $e$. By the triangle inequality we
deduce that the \emph{actual} nearest neighbour can have a distance of at
most $D+d$ to the current vantage point. Therefore, if $D+d < R$, the actual
nearest neighbour cannot be in the outside region. Conversely, if
we started our search in the outside region and found a
nearest-neighbour candidate with $D-d > R$, then the actual nearest
neighbour cannot lie in the inside region. In summary, if $d < |R
- D|$ only the preferred region has to be considered.

Vantage-point tree search is indeed very well suited for cell
resampling. The construction is completely agnostic to the chosen
distance function. In particular, unlike the LSH-based methods
considered in~\cite{Andersen:2021mvw} and appendix~\ref{sec:LSH_search}, it does not
require a Euclidean metric. For an event sample of size $N$, the tree
construction requires $\mathcal{O}(N \log N)$ steps and can be easily
parallelised. In the ideal case where only the preferred regions are
probed, each nearest-neighbour search requires $\log_2 N$ comparisons,
which again results in a overall asymptotic complexity of
$\mathcal{O}(N \log N)$. While this means that for sufficiently large
event samples cell resampling will eventually require more computing
time than the $\mathcal{O}(N)$ event generation, we find that this is
not the case for samples with up to several billion events. Timings
for a practical application are given in \todo{section}.

We further optimise the nearest-neighbour search in several
aspects. Most importantly, if we limit the maximum cell size to $c$,
we can dramatically increase the probability that only the preferred
regions have to be considered. In fact, if $|R - D| > c$ then any
suitable nearest neighbours have to lie inside the preferred
region. We can further enhance the probability through a judicious choice
of the vantage points. Since input events near the boundary between
inside and outside regions require checking both regions for
nearest neighbours, the general goal is to minimise this surface. To
this end, we choose our first vantage point at the boundary of the
populated phase space. We select a random event, calculate
the distance to all other events, and choose the event with the
largest distance as the vantage point. Then, when constructing the
subtrees for the inside and outside regions, we choose as
vantage points those events that have the largest distance to the
parent vantage point.

In general, when constructing a cell we need to find not only the
nearest neighbour to the cell seed, but $k$ nearest neighbours where
$k$ is a priori unknown. To speed up successive searches, we cache the
results of distance calculations, i.e.~all values of $D$ for a given
input event.

Finally, we note that the vantage-point tree can also be employed for
approximate nearest-neighbour search if one only searches the preferred
region in each step. We exploit this property by first partitioning
the input events into the inside and outside regions of a
shallow vantage point tree, aborting the construction already after
the first few steps. We then apply cell resampling to each partition
independently. This approach allows efficient parallelisation, while
yielding much better results than the independent cell resampling of
randomly chosen partial samples.

\subsection{Set-to-Set Distance at High Multiplicities}
\label{sec:set-to-set-distance}

The distance between two events as defined in~\cite{Andersen:2021mvw}
is the sum of distances between sets of infrared-safe physics objects,
see equation~\eqref{eq:d_event}. To define the distance between two
such sets $s_t, s_t'$, we aim to find the optimal pairing between the
momenta $p_1,\dots, p_P$ of the objects in $s_t$ and the momenta $q_1,\dots, q_P$ of the objects in $s_t'$. The naive approach of
considering all possible pairings, cf.~equation~\eqref{eq:d_set},
scales very poorly with the number of objects. However, the task of
finding an optimal pairing is an instance of the well-studied
\emph{assignment
\message{ !name(main.tex) !offset(-101) }

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
