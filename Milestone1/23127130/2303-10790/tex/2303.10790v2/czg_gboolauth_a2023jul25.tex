%%G. Czedli 2023
\documentclass[reqno]{amsart}
\newcommand \datum {July 25, 2023 (extended version)}
%\setlength{\hoffset}{-4cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\sg {s_G}
\newcommand \defiff{\mathrel{\overset{\textup{def}}\iff}}
\newcommand\size[1]{\textup{size}(#1)}
\newcommand \gsize [1]{\textup{size}(#1)}
\newcommand\Boo[1]{\mathsf B_{#1}}
\newcommand\At[1]{\textup{At}(#1)}
\newcommand\signSp{\textup{Sp}}
\newcommand\Sp[1]{\signSp(#1)}
\newcommand\LASp[1]{\textup{LASp}(#1)}
\newcommand\Prot {\textup{Prot}}
\newcommand\sProt {{^\ast\textup{Prot}}}
\newcommand\Strat {\textup{Strat}}
\newcommand\ciph[1] {\textup{ciph}(#1)}
\newcommand\lint[1]{\lfloor #1\rfloor}
\newcommand\FS [1] {\textup{FS}_\wedge(#1)}
\newcommand\FL [1] {\textup{FL}(#1)}
\newcommand \Aslg  {\mathcal A^\star}
\newcommand \Bslg  {\mathcal B^\ast}
\newcommand \svec [1] {\vec{#1}\kern1.5pt}
\newcommand \pvec [1] {\vec{#1}\kern1.5pt'}
\newcommand \katibank{{\includegraphics[scale=0.25]{kati-bank}}}
\newcommand \woman {Kati}
\newcommand \nothing[1] {}

%\newcommand \oc [1] {#1^\circ}


\usepackage{amssymb,latexsym}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}

\usepackage[dvipsnames]{xcolor}
\usepackage{enumerate}
\numberwithin{equation}{section}
\theoremstyle{plain}
 \newtheorem{theorem}{Theorem}[section]
  \newtheorem*{theoremn}{Theorem}
 \newtheorem{lemma}[theorem]{Lemma}
 \newtheorem{proposition}[theorem]{Proposition}
 \newtheorem{note}[theorem]{Note}
 \newtheorem{observation}[theorem]{Observation} 
 \newtheorem{fact}[theorem]{Fact}
 \newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
 \newtheorem{definition}[theorem]{Definition}
 \newtheorem{nextpart}{Part (of the proof)}
 \newtheorem{example}[theorem]{Example}
 \newtheorem{remark}[theorem]{Remark}
\theoremstyle{remark}


\newcommand \clnp {\textbf{NP}}
\newcommand \clp {\textbf{P}}
\newcommand \Alg   {\mathcal A}
\newcommand \Blg   {\mathcal B}
\newcommand \Mlg   {\mathcal M}

\newcommand \CPr {\textup{CPr}}
\newcommand \DPr {\textup{DPr}}

\newcommand \npp {\textup{PDNP}^{\bullet}}
\newcommand \Hast {H^\ast}
\newcommand \strpsec{\pi_2}
\newcommand \secp[1]{\strpsec(#1)}
\newcommand\Quo[1]{\textup{Quo}(#1)}
\newcommand\Equ[1]{\textup{Equ}(#1)}
\newcommand \filter[1]{\mathord\uparrow\kern0.5pt  #1}
\newcommand \pfilter[1] {\mathord\uparrow_{\kern-1.0pt #1}\kern0.5pt}
\newcommand \FD [1] {\textup{FD}(#1)}
\renewcommand \phi{\varphi}
\newcommand \Nnul {\mathbb N_0}
\newcommand \Nplu {\mathbb N^+}
\newcommand \ideal {\mathord\downarrow\kern0.5pt }
\newcommand \then {\Rightarrow}
\newcommand \tuple [1] {(#1)}
\newcommand \pair [2] {\tuple{#1,#2}}
\newcommand{\tbf}{\textbf}% text bold
\newcommand{\set}[1]{\{#1\}}% set 
\newcommand \red[1]{{\textcolor{red}{#1}\color{black}}}
\newcommand \black[1]{{\textcolor{black}#1}}
\newcommand \magenta [1] {{\color{magenta}#1\color{black}}}
\newcommand \lightgreen [1] {{\color{green!85!magenta}#1}}
\newcommand \green [1] {{\color{green!65!blue}#1\color{black}}}
\newcommand \mrk {{\red{$\clubsuit\clubsuit\clubsuit$ }}}
\newcommand \ncol {\color{green!50!blue}}
\newcommand \bcol {\color{black}}
 
\begin{document}



\title[Authentication and generating Boolean lattices]
{Generating Boolean lattices by few elements and a related  cryptographic protocol for authentication}



\author[G.\ Cz\'edli]{G\'abor Cz\'edli}
\email{czedli@math.u-szeged.hu}
\urladdr{http://www.math.u-szeged.hu/~czedli/}
\address{University of Szeged, Bolyai Institute. 
Szeged, Aradi v\'ertan\'uk tere 1, HUNGARY 6720}


\begin{abstract} 
Let $\Sp k$ denote the number of the $\lint{k/2}$-element subsets of a finite $k$-element set. We prove that the least size of a generating subset of the Boolean lattice with $n$ atoms (or, equivalently, the powerset lattice of an $n$-element set) is the least number $k$ such that $n\leq \Sp k$. Based on this fact, we present a secret key protocol for authentication and cryptography.
%
Furthermore, we prove that the underlying mathematical problem of this protocol is likely to be harder than \clp{} in the sense that if it belongs to the complexity class \clp{} then \clp{} equals \clnp{}. 
We present some ideas (but not a proof) how to make our protocol  hard on the average. 
Finally, as an easy observation, we present a subclass of (the \clnp{}-complete) 3\kern0.2pt SAT that is still \clnp{}-complete.
\end{abstract}

\thanks{This research was supported by the National Research, Development and Innovation Fund of Hungary, under funding scheme K 138892.  \hfill{\red{\tbf{\datum}}}}

\subjclass {Primary: 06D99. Secondary: 94A62, 94A60, 68Q25}

% 06D (1980-now) Distributive lattices
% 06D99 (1980-now) None of the above, but in this section

% 94A60 (1980-now) Cryptography [See also 11T71, 14G50, 68P25, 81P94]

% 94A62 (2000-now) Authentication, digital signatures and secret sharing

% 68 (1940-now) Computer science 
% 68Q25 (1980-now) Analysis of algorithms and problem complexity




\keywords{Boolean lattice, generating set, cryptography, secret key, smallest generating set, \clnp{}-complete, average \clnp{}-complete, authentication, Vernam cipher.}



\maketitle    

\section{Introduction}
Our goal is to prove Theorem \ref{thm:nleqSpk} and Proposition \ref{prop:NP}; furthermore, Corollary \ref{cor:srvmtNbl}, Remark \ref{rem:szrltJLz},  Observation \ref{obs:nmsBzlhB}, and Remark \ref{rem:tlkcStmZgL} could also be interesting.  

This paper \emph{targets a larger
readership} than a lattice theoretic paper in general. Indeed,  those familiar with the concept of a Boolean lattice and that of \clnp{}-completeness should find no difficulty in reading the \emph{results} and most parts of the paper\footnote{but not necessarily the subsequent paragraphs of the current section}.  
For reading the \emph{proof} presented in Section \ref{sec:genBoole}, only a minimal knowledge of lattice theory\footnote{A \emph{lattice} is an algebra $(L;\vee,\wedge)$ and it is also a  poset $(L;\leq)$ in which the two-element subsets have suprema and infima. This paper has nothing to do with ``lattice-based cryptography''.} or universal algebra is required.  
Therefore, there is no concept to introduce at the beginning of the paper. However, the story below 
could be interesting as it exemplifies how a series of abstract investigations (involving inaccessible cardinals and infinite quasiorder lattices, which are interesting only for few lattice theorists) can lead to something that could be interesting outside lattice theory and, possibly, even outside mathematics.


In the perspective of the present paper, \emph{the story began} with Z\'adori \cite{zadori}, who improved one of the results of Strietz \cite{strietz75}--\cite{strietz77} and, more importantly for the present topic, gave a new proof of Strietz's result asserting that the lattice $\Equ A$ of all equivalences of a finite set $A$ with size at least 3  has a 4-element generating set. To say this result in a concise way\footnote{For convenience, momentarily we consider lattices with fewer than 4 elements 4-generated.}, $\Equ A$ is 4-generated for any finite set $A$. 
In the next step, based on Z\'adori's method, Chajda and Cz\'edli \cite{chajdaczg} proved that the lattice $\Quo A$ of all quasiorders (AKA preorders) of the same set $A$ is 6-generated; in fact, this lattice is 3-generated if we add the unary operation
$\rho\mapsto \rho^{-1}=\set{(y,x): (x,y)\in \rho}$
of forming inverses to the set $\set{\vee,\wedge}$ of lattice operations. But what is more interesting in the 1996 paper \cite{chajdaczg} is that, as opposed to the case of equivalence lattices, even the very first version of the proof for $\Quo A$ did not use the finiteness of $A$ and worked for $|A|=\aleph_0$. (Of course, for an infinite $A$, we consider $\Equ A$ and $\Quo A$ \emph{complete} lattices even when this is not explicitly said.) 
Finally, the very first proof, which was similar to Z\'adori's method, became more involved and the scope of \cite{chajdaczg} included every set $A$ such that $|A|$ is smaller than some member of the sequence $\kappa_0:=\aleph_0$, $\kappa_1:=2^{\kappa_0}$, $\kappa_2:=2^{\kappa_1}$, $\kappa_3:=2^{\kappa_2}$, \dots \ (the sequence is of order type $\omega$, so it is countable).  The experience with quasiorders in \cite{chajdaczg}  showed the way 
\begin{equation}
\text{how to overstep the border {between} finite sets and infinite sets,}
\label{eq:hsbDbrthxLsmdyfW}
\end{equation}
and we could show in Cz\'edli \cite{CzGEateq} in 1996 the 4-generability of $\Equ A$ for $|A|=\aleph_0$. Still in the nineties, Cz\'edli \cite{CzGEq4,czgeek} and Tak\'ach \cite{takach} proved that if $A$ is an infinite set and there is no inaccessible cardinal $\lambda$ such that $\lambda\leq |A|$, then $\Equ A$ is 4-generated, 
it has even a four-element non-antichain  generating set, and $\Quo A$ is 6-generated (and 3-generated if forming inverses is allowed). Although we know from Kuratowski \cite{kuratowski}, see also Levy \cite{levy}, that ZFC has a model in which there is no inaccessible cardinal at all, there was an unsuccessful tedious attempt to remove the assumption that no inaccessible $\lambda\leq |A|$ exists. 
Then I met Vilmos Totik in the Bolyai Institute, and after outlining the set theoretical feature of our method, he pointed out (in a minute or so) that this method cannot work for all cardinal numbers, and he immediately proved his statement. Having no other method at hand, the research of small generating sets of $\Equ A$ and $\Quo A$ for $A$ of arbitrary (even inaccessible infinite or finite)  
cardinals stopped for a while with Cz\'edli \cite{czgeek} in 1999.  


The research started again in 2015, when Dolgos \cite{dolgos}, one of Mikl\'os Mar\'oti's students, proved that $\Quo A$ is 5-generated for $|A|\leq \aleph_0$, and  Kulin \cite{kulin} extended this result to all sets $|A|$ such that there is no inaccessible cardinal $\lambda\leq |A|$. Not much later, Cz\'edli \cite{czg2017fourgen} and Cz\'edli and Kulin \cite{czgkulin} reduced the number of generators, so we learned that for all sets $A$ such that 
$|A|\neq 4$ and there is no inaccessible cardinal $\lambda\leq |A|$,  the complete lattice $\Quo A$ is 4-generated. The case $|A|=4$ is still open\footnote{All we currently know is that for $|A|=4$,  $\Quo A$ is 5-generated. By the way, in addition to $\Quo A$ with $|A|=4$ and to the case when there exists an inaccessible $\lambda\leq |A|$, we mention two more open problems. Can Tak\'ach's result be improved when forming inverses are allowed (i.e., are two generators enough)? Can we deal with the rest of sporadic cases of non-antichain generation of $\Quo A$ (see Ahmed and Cz\'edli \cite{delbrinczg} where the unsolved sporadic cases are summarized).} but the result was optimal for many other sets, as \cite{czg2017fourgen} proved that $\Quo A$ is not 3-generated if $|A|\geq 3$. 
Finding 4-element generating sets that are not antichains is more difficult but, after the early results of Strietz \cite{strietz75}--\cite{strietz75} and Z\'adori \cite{zadori}, some sporadic cases were settled not long ago (in 2020--2021) in  Ahmed and Cz\'edli \cite{delbrinczg} and Cz\'edli and Oluoch \cite{czgoluoch}.

In 2020, a progress opposite to \eqref{eq:hsbDbrthxLsmdyfW} happened. It appeared that the technique developed for infinite sets is appropriate to show that even some direct powers and products of some finite equivalence lattices are 4-generated and (consequently) $\Equ A$ and $\Quo A$ have very many 4-element generating sets even if $|A|$, a finite number, is not so large (but $|\Equ A|$ and $|\Quo A|$ are very large); see Cz\'edli \cite{czgDEBRauth} and Cz\'edli and Oluoch  \cite{czgoluoch}. 
As a side effect of the papers written in the nineties and cited in this section, there came to existence a dream: ``if there are enough complications in proving a result by construction, then we might benefit from these complications in cryptography''. Due to this dream and the abundance of the generating sets found in the just mentioned two papers, 
 Cz\'edli \cite{czgDEBRauth} in 2021 suggested a protocol for authentication and cryptography based on lattices. 


Quite recently, looking for small generating sets of some filters of quasiorder lattices in Cz\'edli \cite{czgfiltQuo}, a proof required to know the smallest size of a generating set of a finite Boolean lattice; this was the motivation for Section \ref{sec:genBoole} of the present paper. It appeared  that even though not as few as 4, large finite Boolean lattices can be generated by surprisingly few elements. Then we started to apply the 2021 cryptographic protocol from Cz\'edli \cite{czgDEBRauth} to Boolean lattices.
As opposed to the 2021 paper, where complicated lattices were used and no proof accompanied the heuristic ideas, now we can prove that the  protocol we are going to give here is   
``\emph{likely to be harder than} \clp{}'' in the sense that it is not in the complexity class \clp{} provided that \clp{} is different from \clnp. 
Even though this fact in itself does not guarantee\footnote{{In view of Remark \ref{rem:tlkcStmZgL}, the situation becomes a bit better.}} the reliability of our protocol  when an adversary threatens with intercepting and changing messages and even when some questions waits for further analysis, the ``likely to be harder than \clp{}'' property or the underlying problem increases our belief\footnote{Note at this point that 
I am a lattice theorist but not an expert of cryptography.}  that the present protocol and the 2021 protocol have some value in
 authentication and cryptography.

The protocol based on Boolean lattices and it connection to \clnp{}-completeness are given in Sections \ref{sect:ACprtcl} and \ref{sect:NPh}, respectively. Section \ref{sect:prrslt} indicates that there are plenty of secret keys for the protocol; the corresponding computer program is given in the Appendix (Section \ref{sect:appDx}). 
Section \ref{sect:3SAT} is quite short and, for 3SAT, it contains an immediate consequence of Section \ref{sect:NPh}. 
Section \ref{section:warn} mentions an option how to make our protocol safer and contains some warning about safety. 




\section{Small generating sets of finite Boolean  lattices}\label{sec:genBoole}
For $n\in\Nplu:=\set{1,2,3,\dots}$, let 
$\Boo n$ denote the Boolean lattice with $n$ atoms. It consists of $2^n$ many elements. 
For an element $u$ of a lattice $L$, we use the standard notation $\ideal u$ and $\filter u$ for $\set{x\in L: x\leq u}$ and $\set{x\in L: x\geq u}$, respectively. As   $(\Nplu;\leq)$ is also a lattice,   $\ideal n$ for $n\in \Nplu$ will mean $\set{1,2,\dots, n}$.
Note that $\Boo n$ is isomorphic to the powerset lattice $P(\ideal n)=(P(\ideal n);\subseteq)$. 
A subset $Y$ of $\Boo n$ is a \emph{generating set} of $\Boo n$ if the only sublattice of $\Boo n$ that includes $Y$ is $\Boo n$ itself.
Denote the (lower) integer part of $x\in\mathbb R$ by $\lint x$, and let
\begin{equation}
\Sp n:={{n}\choose{\lint{n/2}}}.
\end{equation}
%
\begin{equation}\left.
\begin{aligned}
\text{For example, }\Sp{22}= 705\,432\text{ \ }\Sp{23}=1\,352\,078, \cr
\Sp{32}= 601\,080\,390, \text{ \ and \ }\Sp{33}=  1\,166\,803\,110.
\end{aligned}\quad\right\}
\label{eq:nLmgpGNkw}
\end{equation}
%
For $n\in\Nplu$, let $\LASp n$ be the smallest $k\in\Nplu$ such that $n\leq \Sp k$.
%
Note the rule: $n\leq \Sp k \iff \LASp n\leq k$; this explains the acronym, which comes from ``Left Adjoint of Sp". The notation $\signSp$ comes from ``Sperner'' as Sperner's theorem will play an important role later.

\begin{theorem}\label{thm:nleqSpk}
For $n,k\in\Nplu$, $\Boo n$ has an at most $k$-element generating set if and only if $n\leq \Sp k$ or, equivalently,  if and only if $\,\LASp n\leq k$. 
\end{theorem}

For example, this theorem together with \eqref{eq:nLmgpGNkw} give that $\Boo{1\,000\,000}$ is $23$-generated but not $22$-generated; similarly, $\Boo{1\,000\,000\,000}$ is $33$-generated but not $32$-generated. 


\begin{proof} Let $\At{\Boo n}$ be the set of atoms of $\Boo n$. 
First, we show that
\begin{equation}
\text{for any generating set }Y\text{ of }\Boo n\text{ and for  }\forall a\in\At{\Boo n}\text{, }a=\bigwedge (Y\cap\filter a). 
\label{eq:ktNrMxtlgRn}
\end{equation}
We can write that $Y=\set{b_1,\dots,b_m}$. As $Y$ generates $\Boo n$,
 there is an $m$-ary lattice term $t$ such that $a=t(b_1,\dots,b_m)$. 
By distributivity, we can assume that $t$ is of a disjunctive normal form, that is, $a$ the join of meets of elements of $Y$. But $a$ is join-irreducible, whereby it is the meet of some elements of $Y$. Let us add  all elements of $Y\cap\filter a$ to this meet as (possibly extra) meetands, this does not destroy anything. Thus, we conclude \eqref{eq:ktNrMxtlgRn}. 

Next, to settle the ``only if'' part of the theorem, we need to prove that for any subset $G$ of $\Boo n$,
\begin{equation}
\text{if $G$ generates $\Boo n$ and $k=|G|$,  then $n\leq \Sp k$.}
\label{eq:BrmpCtznnmKf}
\end{equation}
To show this, assume that $G$ is a $k$-element generating set of $\Boo n$.
Let $X$ be a $k$-element set and take the free meet-semilattice $\FS X$ freely generated by $X$. Denote by $M$ the meet-subsemilattice of $(\Boo n;\wedge)$ generated by $G$. Take a bijective map $f_0\colon X\to G$. 
The freeness of $\FS X$ allows us to extend $f_0$ to a meet-homomorphism $f\colon\FS X\to M$, which is surjective since $f(X)=G$ generates $M$.  By \eqref{eq:ktNrMxtlgRn}, $\At{\Boo n}\subseteq M$. This together with the surjectivity of $f$ allow us to take an injective map $g\colon\At{\Boo n}\to \FS X$ such that, for all $a\in A$,  $f(g(a))=a$.  If we had that $g(a)\leq g(a')$ for distinct $a,a'\in \At{\Boo n}$, then $g(a)=g(a)\wedge g(a')$ would lead to $a=f(g(a))=f(g(a)\wedge g(a'))= f(g(a))\wedge f(g(a'))=a\wedge a'$, yielding that $a\leq a'$ and contradicting that $a$ and $a'$ are distinct atoms of $\Boo n$. 
%
Therefore $g(a)\parallel g(a')$, that is, $g(\At{\Boo n})$ is an $n$-element antichain in $\FS X$. 

Adding a top element to $\FS X$, we obtain another semilattice,  $\set{1}\cup\FS X$.
We know from the folklore or from McKenzie, McNulty, and Taylor \cite[Page 240, \S4]{mcKmcNT} that $\set{1}\cup\FS X$  is order isomorphic to $\Boo{|X|}=\Boo k$.
So $\Boo k$ has an $n$-element antichain. By Sperner's theorem \cite{sperner}, see also Gr\"atzer \cite[half a page after Thm.\ 401 in p.\ 354]{r:Gr-LTFound}, 
 any antichain in $\Boo k$ has at most $\Sp k$ elements,  implying  \eqref{eq:BrmpCtznnmKf} and the ``only if'' part of the theorem.

Next, observe that 
\begin{equation}\left.
\parbox{10.6cm}{for any $m\leq n\in\Nplu$,  $\Boo m$ is a homomorphic image of $\Boo n$. Therefore, if $\Boo n$ has an at most $k$-element generating set, then so does $\Boo m$.}\,\,\right.
\label{eq:wPsrTwgftjG}
\end{equation}
%
It suffices to show only the first part and only for $m=n-1$. Let 
$a\in \At{\Boo n}$. Then $\filter a\cong \Boo m$. The function $f\colon \Boo n\to \filter a$  defined by $x\mapsto a\vee x$ is surjective as it is a retraction, and it is a homomorphism by distributivity. Hence, we conclude \eqref{eq:wPsrTwgftjG}.


Next, to show the ``if'' part of the theorem, assume that $n\leq \Sp k$; we are going to show that $\Boo n$ has an at most $k$-element generating set. We can assume that $k\leq n$. 
Based on \eqref{eq:wPsrTwgftjG} and $k\leq \Sp k$,  it suffices to show that $\Boo{\Sp k}$ has an at most $k$-element generating set.  To ease the notation, we can assume that $n=\Sp k$; so we are looking for a $k$-element generating set of $\Boo n$.  


Let $A:=\At{\Boo k}$ (the subscript is $k$, not $n$).
As $\Boo k$ is isomorphic to the powerset lattice $(P(\set{1,\dots,k});\cup,\cap)$ and the $\lint{k/2}$-element subsets of $\set{1,\dots,k}$ form an $n=\Sp k$-element antichain in $(P(\set{1,\dots,k});\cup,\cap)$, it follows that $\Boo k$ has an $n$-element antichain $H$.  
As $(P(H);\cup,\cap)\cong \Boo n$, 
it suffices to find a $k$-element generating set of the powerset lattice $P(H)=(P(H);\cup,\cap)$. 
For each $a\in A=\At{\Boo k}$, we let $X_a:=H\cap\filter a$. Then $X_a\in P(H)$ and $G:=\set{X_a: a\in A}$ is an at most $k$-element\footnote{Actually, $|G|=k$, but we neither show nor use this equality.} subset of $P(H)$.  We are going to show that $G$ generates the powerset lattice $P(H)$. As the set of singleton sets $\set h$ ($h\in H$) clearly generate $P(H)$, it suffices to show that for every $h\in H$, 
\begin{equation}
\set{h}=\bigcap\set{X_a: a\in A\cap \ideal h}.
\label{eq:rZmszltpLrnts}
\end{equation}
For every $a\in A\cap \ideal h$, we have that $h\in H\cap\filter a=X_a$, which shows the ``$\subseteq$'' part of \eqref{eq:rZmszltpLrnts}. 
%
Now assume that $h'\in H$ belongs to the intersection in \eqref{eq:rZmszltpLrnts}. Then $h'\in X_a$ for every atom $a\in A$ such that $a\leq h$.
Writing this in a more useful way, 
\begin{equation*}
(\forall a\in A)\,\,\bigl( a\leq h \then a\leq h'\bigr)\text{, that is, } A\cap\ideal h\subseteq A\cap\ideal {h'}.
%\label{eq:mhszkVkkBldP}
\end{equation*}
Hence, using that each element of $\Boo k$ is the join of all atoms below it, we have that $h=\bigvee(A\cap\ideal h)\leq \bigvee(A\cap\ideal{h'})=h'$. But $h$ and $h'$ belong to the antichain $H$, whereby their comparability gives that $h'=h\in\set{h}$, showing the ``$\supseteq$'' part of \eqref{eq:rZmszltpLrnts}. Therefore, \eqref{eq:rZmszltpLrnts} and the ``if'' part of the theorem holds.
%
The proof of Theorem \ref{thm:nleqSpk} is complete.
\end{proof}




\begin{corollary}\label{cor:srvmtNbl}
If $2\leq k\in \Nplu$ and $n \leq \Sp k$, then the free distributive lattice $\FD k$ has a sublattice isomorphic to $\Boo n$.
\end{corollary}

\begin{proof} As $\Boo m$ is a sublattice of $\Boo n$ for any $m\leq n$, we can assume that $n=\Sp k$. It follows from Theorem \ref{thm:nleqSpk} that we can pick a surjective homomorphism $f\colon\FD k\to \Boo n$. We know from Balbes \cite[Theorem 7.1(i),(iii')]{balbes} that $\Boo n$ is projective in the class of all distributive lattices. Let $h\colon \Boo n\to\Boo n$ be the identity map (defined by $x\mapsto x$ for $x\in\Boo n$). Then, complying with the notation used in 
Balbes \cite[Definition 2.3]{balbes}, the projectivity of $\Boo n$ yields a homomorphism $g\colon \Boo n\to \FD k$ such that\footnote{We compose functions from right to left, that is, $(f g)(x)=f(g(x))$.} $f g=h$. Since the product $h$ is injective, so is $g$. Thus, $g\colon \Boo n\to \FD k$ is an embedding and $g(\Boo n)$ is a required sublattice of $\FD k$. 
\end{proof}



\section{A protocol for authentication and cryptography based on Boolean lattices}\label{sect:ACprtcl}
%
We recall some elementary facts and terminology from the folklore. Authentication will mean proving the sender's identity to the receiver in communication. 
For example, when  \woman{}{\footnote{``\woman{}'' is the  Hungarian variant of ``Cathy'' and ``Kate''.}} gives an instruction like  "transfer 1000 Euros from \woman{}'s account to  X.Y.'s account" online, then 
authentication is necessary to exclude that
an Adversary intercepts the message, changes "X.Y.'s account" to "the Adversary's account", and then pretending to be \woman{}, sends the corrupted message to the Bank.
There are various protocols for authentication in practice and in the vast literature on (mathematical) \emph{public key}  cryptography.

However, \emph{secret key} cryptography is still important, especially when authentication is of high importance. While a public key protocol is good only to convince the receiver that the second, third, etc. messages are sent by the same sender as the first one, the sender can remain anonymous (by using a false name). In several situations, public keys can even allow that right at the first message (and then at all the subsequent ones) an Adversary takes over \woman{}'s role.  Turning our attention to banks again, note that banks in many countries, including Hungary, do not allow anonymous clients, whereby \woman{} has to visit the Bank before any banking. 
At this first visit, \woman{} and the Bank agree upon a \emph{secret key} that only \woman{} and the Bank will know. Later on, they use this secret key for authentication. There are known methods in the practice like using two independent channels, using a temporary random key together with the secret key at each time, etc.\ to protect the communication between \woman{} and the Bank. 



Some authentication protocols used in the practice have disadvantages. (For example, the Adversary can eavesdrop on both of the independent channels.) Here we only deal with the model in which
there is only a single channel; typically, 
the whole communication happens online, via the Internet.   Furthermore, the secret key can be used many times in our model in spite of the presence of an Adversary in the cyberspace. We assume that the Adversary  intercepts all messages, he tries to extract the secret key from these messages, and even without acquiring the secret key, he does his best to cause harm to \woman{} by modifying the messages that \woman{} sends or receives and sending additional forged messages. However, we exclude that the Adversary intrudes into computers to deploy any virus for phishing or other  malicious activities.%
\footnote{\label{foot:mlCshCk}That is, the Bank and \woman{}'s computers are well protected from the Adversary and they remain intact; they are ``black boxes'' for the Adversary.}. 

Next, we  present a secret key protocol for authentication and cryptography that complies with the guidelines above; in particular, the key can be used many times. Apart from straightforward changes that come from the fact that now we deal only with Boolean lattices rather than with equivalence lattices (which are the same as partition lattices up to isomorphism), the following definition is taken from \cite{czgDEBRauth}.

\ncol alma \bcol alma


\begin{definition}[Cz\'edli \cite{czgDEBRauth}]\label{def:protcol} 
\ncol Here we define a protocol 
\begin{equation}
\Prot=\Prot(n,k,\vec h,b,\Strat,v)
\label{eq:wDPrthr}
\end{equation}
for authentication\footnote{For \emph{authentication}, much less is sufficient. If the reader is interested only in authentication then, skipping over \ncol the colored lines in (this) Section \ref{sect:ACprtcl}\bcol,  he can continue with the paragraph containing \eqref{eq:lrJgfncNpZnkt}, and then he can go directly to Section \ref{sect:prrslt}.} and cryptography as follows. \bcol Pick an $n\in\Nplu$ like $n=1000$ or some integer of a similar magnitude. Let $k\in \Nplu$ such that $\LASp n<k$; for example, let $k=50>\LASp{1000}=13$ or let it be of a similar magnitude\footnote{By Remark \ref{rem:mggrDszGrjtvcf} and the experimental data given in Section \ref{sect:prrslt}, $k=50$ is a reasonable choice.}. 
Unless $n$ is very small, which is not recommended, we can take a $k$ that is much less than $n$; see Section \ref{sect:prrslt}. Pick a vector $\vec h=(h_1,\dots,h_k)$ such that $H = H(\vec h):=\set{h_1,\dots,h_k}$ is a  generating set
of $\Boo n$; {we will point out} in Remark \ref{rem:mggrDszGrjtvcf} and Section \ref{sect:prrslt} that there are many ways to obtain such an $\vec h$.
\ncol
Pick a strategy $\Strat$ of selecting a ``not too simple'' $k$-ary lattice term randomly. Pick a small number $v\in \Nplu$ (we recommend that $v\in\set{1,2,\dots,8}$) and a multiple $b\in\Nplu$ of $v$ such that $b\geq 2$ and, say, {$b\leq 200$}. We call $b$ and $v$ the \emph{block length} and the \emph{Vernam parameter}\footnote{We name this parameter after Vernam as we will use it when the Vernam cipher is applied.}. The Vernam parameter is needed only for sending messages but not for authentication. The variant 
\begin{equation}
\Prot^-:=\Prot(n,k,\vec h,-,\Strat;v)
\label{eq:mMztmPrt}
\end{equation}
also makes sense. It means that whenever a message is sent, then the  block length $b\geq 2$, which is still a multiple of $v$, is tailored to the length of the message.

\bcol Now the secret key that \woman{} and the Bank share is $\vec h$; the rest of the ingredients \ncol of $\Prot$ or $\Prot^-$, see \eqref{eq:wDPrthr} and \eqref{eq:mMztmPrt}, \bcol are known for the Adversary. 

The fact that $\Boo n$ is the $n$-th direct power of the two-element lattice $\Boo 1=\set{0,1}$ allows us to assume that $\Boo n$ consists of $n$-dimensional bit vectors. \ncol (Alternatively, we can work with the powerset lattice $P(A)$ of the $n$-element set $A=\At{\Boo n}$ as we know that $P(A)\cong\Boo n$, and the elements of $P(A)$ are naturally stored in our computers as $n$-dimensional bit vectors.)\bcol 
So all computations with lattice elements are  performed for these bit vectors belonging to $\set{0,1}^n$. 

In case of \emph{authentication}, whenever \woman{} wants to prove her identity to the Bank according to $\Prot$, then 
\woman{} requests a random vector $\vec p=(p_1,\dots,p_b)$ of $k$-ary lattice terms from the Bank. Then 
\begin{equation}
\begin{aligned}
\katibank
\end{aligned}
\label{eq:lrJgfncNpZnkt}
\end{equation}
%
\nothing{
\begin{equation}
\begin{aligned}
\kepk\kern 3pt
\raisebox{19pt}
{\parbox{7.7cm}{the Bank applies Strat to generate such a random vector $\vec p$, sends $\vec p$ to \woman{},  \woman{} computes  $\vec u:=\vec p(\vec h)=(p_1(\vec h),\dots, p_b(\vec h))$  and sends it to the Bank, and the Bank
checks whether $\vec u$ equals $\vec p(\vec h)$.}}\kern3pt\kbank
\end{aligned}
\label{eq:lrJgfncNpZnkt}
\end{equation}}
It is important that  $\vec p$ above should not have been used previously. 

\ncol
Next, let $\vec y\in(\set{0,1}^n)^{b/v}$ be a plain (i.e., non-ciphered) text\footnote{As computers store texts as bit vectors, it is not a restriction that $\vec y$ is a bit vector. Adding extra spaces to the end of the text or using $\Prot^-$ rather than $\Prot$ if necessary, we can assume that the total number of bits in $\vec y$ is $n b/v$.} that \woman{} wants to send to the Bank.
Let us write $\vec y$ in the form $\vec y=(\svec y^{1},\svec y^{2},\dots,\svec y^{b/v})$, where each of the $\svec y^{i}$ is a bit vector belonging $\set{0,1}^n=\Boo n$. We define the enciphered message by  
\begin{align}
\ciph{\vec y}:=\Bigl(&p_1(\vec h)+\dots+p_v(\vec h)+\svec y^{(1)},\,\,\, 
p_{v+1}(\vec h)+\dots+p_{2v}(\vec h)+\svec y^{(2)},\,\dots\, ,
\cr
& p_{b-v+1}(\vec h)+\dots+p_b(\vec h)+\svec y^{(1)}\Bigr) \in (\set{0,1}^n)^{b/v}
\label{eq:twStjrgshdmSnD}
\end{align}
 where the addition is 
performed componentwise in the two-element field $\mathbb Z_2=\set{0,1}$ and $\vec p\,$ is a vector formed by $k$ random $n$-ary lattice terms; either \woman{} generates $\vec p$ or she receives it from the Bank. 
Finally,
\begin{equation}\left.
\parbox{8.0cm} 
{if the Bank generates $\vec p$, then \woman{} sends $\ciph{\vec y}$ to the Bank; otherwise,  she sends the pair $(\vec p, \ciph{\vec y})$.} \,\,\right\}
\label{eq:RszmKlfrptsnP}
\end{equation}
Interchanging their roles, the Bank can send an enciphered message to \woman{} or it can identify itself for \woman{} in the same way.
We have completed Definition \ref{def:protcol}.
\end{definition}








\subsection{Comments, the roles of the parameters, and heuristic considerations}

Let $\FD k$ denote the free distributive lattice on $k$ generators; we note that $|\FD k|\leq 2^{2^k}$; see Kisielewicz \cite{kisz} for  more information, which we do not need here.
Although there are infinitely many $k$-ary lattice terms that determine different term functions in the free lattice  $\FL k$ on $k$ generators,   $k\geq 3$, here we deal only with the \emph{distributive} $\Boo k$. Hence, it suffices to choose $p_1,\dots, p_b$ from an $|\FD k|$-element set of lattice terms. We can even assume (but need not assume at all) that each of 
$p_1,\dots, p_b$ is of a conjunctive normal form or a disjunctive normal form.

The heart of the protocol described in Definition \ref{def:protcol} is that while
we can easily compute  $\vec p(\vec h)$ from $\vec p$ and $\vec h$, it is difficult to compute\footnote
{We do not claim that $\vec p(\vec h)$ and $\vec p$ determine $\vec h$ uniquely. Here and later, ``computing $\vec h$" is understood as ``computing at least one $\vec h$ that satisfies the requirements''.} 
$\vec h$ from $\vec p$ and $\vec p(\vec h)$. 
To enlighten the analogy with cryptographic protocols based on discrete logarithm of base $p$, let us also use the alternative temporary notation $\vec p^{\,\vec h}$ for $\vec p(\vec h)$. Then we obtain $\vec p^{\,\vec h}$ from $\vec p$ and $\vec h$ easily but it is too difficult to compute $\vec h$ from $\vec p$ and  $\vec p^{\,\vec h}$. Actually, this difficulty seems to be at least as big as (if not bigger than) computing the discrete logarithm. Indeed, while we do not know 
much  computing the discrete logarithm is hard,  we can prove that computing $\vec h$ from $\vec p$ and $\vec p(\vec h)$ is likely to be harder than \clp{}; see Proposition \ref{prop:NP}.

Now we turn our attention to \eqref{eq:lrJgfncNpZnkt}. Without knowing $\vec h$, the Adversary hardly has any better method to obtain $\vec u:=\vec p(\vec h)$ from $\vec p$ than guessing\footnote{Of course, we assume that $\vec p$ has been carefully selected and so it is not too trivial. If, say, $\vec p$ was the meet of all the $k$ variables, then it would induce the constant function and the Adversary's task would be easy.}. The vector $\vec u$ in \eqref{eq:lrJgfncNpZnkt} consists of $b n$ bits\footnote{It consists of $b$ components and these components are $n$-bit vectors, to be more precise.}.
So, since the components of $\vec h$ generate $\Boo n$, there are $2^{b n}$ many possible vectors\footnote{\label{foot:mkSTm}This is where we make use of Theorem \ref{thm:nleqSpk}. Indeed, if Theorem \ref{thm:nleqSpk} and any similar statement failed, then we would need a very large $k$ to ensure that  $\vec p(\vec h)$ takes many values, and the system would be less economic.}.  We stipulate that $b n$ should be large enough; then we can exclude that the Adversary is lucky enough to find the proper $\vec u$ by chance or by listing and trying\footnote{For $b n$ large, this would  not be realistic as the Bank hardly allows too many trials.} all the $2^{b n}$ vectors. (This is practically impossible if  $n=1000$ and $b\geq2$.) So the Adversary cannot rely on guessing.



Thus, with reference to Footnote \ref{foot:mlCshCk}, there seems to be only one possibility how the protocol can be broken.
Namely, when the Adversary has intercepted all or some of the earlier vectors $\vec p$ of lattice terms together with the corresponding vectors $\vec p(\vec h)$, see \eqref{eq:lrJgfncNpZnkt}, and he is able to  compute $\vec h$ from the intercepted data. We can assume that he has  intercepted  only one pair $(\vec p,\vec p(\vec h))$ where $\vec p$ is $b$-dimensional (that is, it has $b$ components), because 
\begin{equation}\left.
\parbox{10.5cm}{
the collection of pairs $(\pvec p,\pvec p(\vec h))$,  $(\pvec p',\pvec p'(\vec h))$,  $(\pvec p'',\pvec p''(\vec h))$, \dots \ with $b'$-, $b''$-, $b'''$- , \dots \ dimensional $\pvec p$, $\pvec p'$, $\pvec p''$, etc.{} is equivalent to having a single pair $(\vec p,\vec p(\vec h))$ with a $(b'+b''+b'''+\dots)$-dimensional $\vec p$.}\,\,\right\}
\label{eq:rltMcdjVsBl}
\end{equation} 

For more about the Adversary's poor chance to acquire $\vec h$, see Proposition \ref{prop:NP} later. 
\ncol
If the Adversary intercepts a pair $(\vec p,\ciph{\vec y})$, see \eqref{eq:RszmKlfrptsnP}, then unless he guesses\footnote{\label{ftn:lCk}This cannot be excluded since there can be occasions when many people, including the Adversary, send the same $\vec y$ to the Bank; for example, right before the deadline of paying some tax that is the same for many people.} what $\vec y$ is, his chance is even worse. So, 
\begin{equation}\left.
\parbox{6.5cm}{intercepting \eqref{eq:RszmKlfrptsnP} gives no more possibility to the Adversary than intercepting \eqref{eq:lrJgfncNpZnkt}.}\,\,\right\}
\label{eq:ndWbMwhSngrGd}
\end{equation}


Can the Adversary cause harm to \woman{} by intercepting an enciphered message $(\vec p,\ciph{\vec y})$ and send it to the Bank repeatedly? (For example, paying the yearly tax from \woman{}'s account as many times as the balance of her account permits.) Clearly, this cannot happen provided that  either 
\woman{} is not allowed to send the same message again (for example, at least the ``time stamps'' up to  microseconds have to be different)  or the Bank requires that each transaction has to be confirmed according to \eqref{eq:lrJgfncNpZnkt}; remember that the Bank generates a new random $\vec p$ at each case.


Some secret key cryptosystems, including Vernam Cipher, are easily broken if the same secret key is used (many times) repeatedly. The addition in \eqref{eq:twStjrgshdmSnD} indicates that  the Vernam Cipher is included in our system.
Fortunately, it seems to us by  \eqref{eq:rltMcdjVsBl}, \eqref{eq:ndWbMwhSngrGd}, and Proposition \ref{prop:NP}  that our protocol is not vulnerable to repeated use.
In fact, the underlying problem of our cryptosystem is \emph{likely to be  harder than \textup{\clp}} in the sense that it is not in the complexity class \clp{} provided that \clp{} $\neq$ \clnp, and this is so 
even if $b=2$, and also for $b>2$.
%
\footnote{Practically, as many of us conjecture that \clp{} $\neq$ \clnp, the statement ``likely to be harder than \textup{\clp}''  means that the \emph{worst case} (from the Adversary's point of view) is hopelessly hard.  But there is a warning here: we only guess but have not proved that the \emph{average case} is also hard. For a bit more about the average case, see Remark \ref{rem:tlkcStmZgL}. Note that no matter how hard a protocol is theoretically, 
there is a very very little but positive probability that 
a case (intercepted data) might be a lucky case for the Adversary.} %
% 



\bcol
We have already mentioned that $b n$ should be large. However, the role of $b$ and that of $n$ are quite different. While, in addition to $k$,  the data size of $\vec p(\vec h)$ depends on $b n$, the data size of $\vec p$ depends only on $b$ but not on $n$.
It is reasonable to generate and send not too many random lattice terms. So $b$ should not be too large; even  $b=2$ is sufficient to make the Adversary's job likely to harder than \textup{\clp}.
 

In general, an authentication \ncol or cryptographic\bcol{} protocol is not automatically successful just because its underlying problem is  hard\footnote{\label{foot:hRstnDp}%
For example, it is an issue how to obtain a random term of approximate length $m$.  Here is a heuristic method, in which Polish notation is used; for example, 
$\mathord{\vee}x\mathord{\wedge}y z
=x\vee (y\wedge z)$. We can use time-varying weights to select the components of the requested random term. (The weight of a symbol is the probability of selecting it.)   At the beginning, each of $\vee$ and  $\wedge$ has weight $0.5$ while the variables are of weight 0. At early stage, the weights are chosen so that the term should grow (so that the immediate use of the absorption laws is excluded). Later, the weights give preference to termination of the process. Even though no exact theoretical argument is available at the time of writing,  experiments with the help of computer will give a reasonable strategy.
For an other (but maybe less economic) strategy, see Remark \ref{rem:tlkcStmZgL}.
}%
. \ncol Thus, it would be too 
early to compare our protocol  $\Prot$ or $\Prot^-$ 
to previously known ones. 

\bcol
\begin{remark}\label{rem:dWndktrnglKBnRhb} 
It is highly important that \woman{} should have a very large set of candidate vectors $\vec h$ such that $H(\vec h)$ generates $\Boo n$. Indeed, otherwise the Adversary could try all the possible vectors $\vec h$.  

There is a trivial argument showing that there are very many secret keys $\vec h\in\Boo n^k$ provided that $d:=k-\LASp n$ is not too small.
Indeed, Theorem \ref{thm:nleqSpk} allows us to pick  an\footnote{It follows from Sperner \cite{sperner} that there are at most two such sets $X_0$ but we do not need this fact.} 
 $\LASp n$-element generating set $X_0$ of $\Boo n$.  There are many ways to pick a $d$-element subset $X_1$ of 
$\Boo n\setminus X_0$. Hence, we obtain many sets $X:=X_0\cup X_1$ and each of them is a $k$-element generating set of $\Boo n$. Each of them can be written in a $k$-dimensional vector in $k!$-many ways. Thus, we obtain very many secret keys $\vec h$.

Out of the many other ways, we mention only the following one. For each $x\in X_0$, pick one of the lattice operations $\vee$ and $\wedge$ and pick a few (like two, three, \dots) elements of $\Boo n$ such the join or meet of these elements is $x$. So these few elements become the joinands or meets of $x$. Doing so for each $x\in X_0$, we obtain joinands and meetands, $k$ elements all together, that clearly generate $\Boo n$. 
\end{remark}

None of the two ways mentioned above is powerful above to be recommended. Indeed, if we went after Remark \ref{rem:dWndktrnglKBnRhb}, then the proof of Proposition \ref{prop:NP} would collapse and the Adversary might benefit from this. Fortunately, the following remark is more useful.

\begin{remark}\label{rem:mggrDszGrjtvcf}
In case of reasonably chosen parameters $n$ and $k$, not only the number of suitable secret keys $\vec h$ is large but even the 
probability that the components of a randomly selected vector $\vec h\in \Boo n^k$ generate $\Boo n$ is reasonably high. 
Furthermore, based on the necessary condition \eqref{eq:ktNrMxtlgRn}, which is trivially also a sufficient condition, we can decide quite rapidly in $O(n^2k)$ steps whether the components of $\vec h$ generate $\Boo n$ or not. Therefore, after few random  trials, we find an appropriate  secret key $\vec h$.
\end{remark}





\section{Computer-assisted evidence}\label{sect:prrslt}
In connection with Remark \ref{rem:dWndktrnglKBnRhb}, now we use a computer program to verify that yes, there are many candidate keys $\vec h$ and a suitable algorithm to pick one.
Actually, we have two computer programs for this purpose; both are available at the author's website. The simpler (but about eight times slower) one of them is given in (the Appendix) Section \ref{sect:appDx}.
Both programs, BooGnFtr and  BooGenEZ,  implement the trivial algorithm based on the sufficient and necessary condition \eqref{eq:ktNrMxtlgRn}.  

  
Note that our programs can easily be modified to print the secret keys that they find into text files. Better program languages could lead to somewhat faster programs but this task was neither targeted nor the author is skilled enough for it.

We applied our programs, almost always the fastest one, for several values of $n$ and $k$. 
At each occasion, the program in question tested one  hundred thousand random vectors $\vec h$ of $\Boo n^k$. In the list below, the number of those $\vec h$ that generate $\Boo n$  occur right after ``Generating:''. The list contains the time the program used for computation. For example, 
while  BooGnFtr used 1305.780 seconds (about 22 minutes) to test one hundred thousand vectors $\vec h\in \Boo{1000}^{50}$ (and found out that $59\,003$ out of these vectors, about 53 percent of these vectors, generated $\Boo{1000}$), 
the same task for BooGenEZ  took
10965.266 seconds (approximately 183 minutes).

{\footnotesize 
\begin{verbatim}
n=200 k=30 Tested:100000 Generating:  721; BooGnFtr used       65.594 seconds.
n=200 k=40 Tested:100000 Generating:69274; BooGnFtr used      115.380 seconds.
n=200 k=50 Tested:100000 Generating:97751; BooGnFtr used      151.398 seconds.
n=200 k=50 Tested:100000 Generating:97775; BooGenEZ used      630.650 seconds.

n=400 k=30 Tested:100000 Generating:0;     BooGnFtr used      124.538 seconds.
n=400 k=40 Tested:100000 Generating:25262; BooGnFtr used      242.555 seconds.
n=400 k=45 Tested:100000 Generating:69944; BooGnFtr used      323.834 seconds.
n=400 k=50 Tested:100000 Generating:91710; BooGnFtr used      385.859 seconds.
n=400 k=60 Tested:100000 Generating:99475; BooGnFtr used      462.323 seconds.

n=600 k=30 Tested:100000 Generating:    0; BooGnFtr used      184.144 seconds.
n=600 k=40 Tested:100000 Generating: 5352; BooGnFtr used      350.053 seconds.
n=600 k=46 Tested:100000 Generating:55556; BooGnFtr used      576.888 seconds.
n=600 k=50 Tested:100000 Generating:82547; BooGnFtr used      696.786 seconds.
n=600 k=60 Tested:100000 Generating:98879; BooGnFtr used      861.497 seconds.

n=800 k=30 Tested:100000 Generating:     0; BooGnFtr used      229.103 seconds.
n=800 k=40 Tested:100000 Generating:   691; BooGnFtr used      419.691 seconds
n=800 k=50 Tested:100000 Generating: 70923; BooGnFtr used     1000.597 seconds.
n=800 k=60 Tested:100000 Generating: 97995; BooGnFtr used     1387.090 seconds.
n=800 k=70 Tested:100000 Generating: 99883; BooGnFtr used     1621.501 seconds.
n=800 k=80 Tested:100000 Generating: 99998; BooGnFtr used     1909.324 seconds.
n=800 k=90 Tested:100000 Generating:100000; BooGnFtr used     2041.405 seconds.

n=1000 k=40  Tested:100000 Generating:    42;  BooGnFtr used    506.867 seconds.
n=1000 k=50  Tested:100000 Generating: 59003;  BooGnFtr used   1305.780 seconds.
n=1000 k=50  Tested:100000 Generating: 59162;  BooGenEZ used  10965.266 seconds.
n=1000 k=60  Tested:100000 Generating: 96878;  BooGnFtr used   1967.896 seconds.
n=1000 k=70  Tested:100000 Generating: 99823;  BooGnFtr used   2321.272 seconds.
n=1000 k=80  Tested:100000 Generating: 99990;  BooGnFtr used   2647.147 seconds.
n=1000 k=90  Tested:100000 Generating: 99999;  BooGnFtr used   2974.364 seconds.
n=1000 k=100 Tested:100000 Generating:100000;  BooGnFtr used   3265.869 seconds.
\end{verbatim}
}
Note that  testing\footnote{Our program does not check whether a random vector is different from the previous random vectors.}  one hundred thousand random vectors $\vec h$ \emph{cannot prove} in the rigorous mathematical sense that, say,  there are two different $\vec h$ and $\pvec h$ in $\Boo n^k$ such that both $H(\vec h)$ and $H(\pvec h)$ generate $\Boo n$. However, say for $(n,k)=(1000,70)$, given that the program has found more than 99 thousand such vectors out of one hundred thousand vectors, it has a negligibly little probability that $H(\vec h)$ does \emph{not} generate $\Boo{1000}$ for more than half of the vectors belonging to $\Boo{1000}^{70}$. 

Finally, note that analogous computer-made data about small generating sets of equivalence lattices are available from Cz\'edli \cite{czgDEBRauth} and Cz\'edli and Oluoch \cite{czgoluoch}; the latter contains some statistical analysis of the data.






\section{The underlying problem is hard}\label{sect:NPh}
For $n=1000$ and $b=100$,  
the Adversary has no  chance to find $\vec u$ for \eqref{eq:lrJgfncNpZnkt} by random choices in 
the expected lifetime of the Solar System. Solving the underlying problem seems to be the only way for him. That is, from and intercepted pair  $(\vec p,  \vec u=\vec p(\vec h))$, he should find (at least one) $\vec h$.  (Intercepting several such pairs corresponds to enlarging $b$ and does not help.) 

As in Section \ref{sect:ACprtcl}, we will assume that $n,k,b\in\Nplu$, $\vec p$ is a $b$-dimensional vector of $k$-ary lattice terms, and $\vec u\in \Boo n^b$. Writing $\vec x=(x_1,\dots,x_k)$  instead of $\vec h\in \Boo n^k$, the \emph{underlying problem} of protocol \eqref{eq:lrJgfncNpZnkt} is this:
%
\begin{equation}
\CPr(n,b):\quad
\parbox{9cm}{given an input  $\vec p(\vec x)=\vec u$ with 
$\vec u\in \Boo n ^b$, find a solution of  the equation $\vec p(\vec x)=\vec u$ for the unknown 
$\vec x\in \Boo n ^k$ 
\emph{in those cases} where there exists a solution.} 
\label{eq:sJbKmlDks}
\end{equation}
With the same meaning of $n$, $k$, $b$,  $\vec p$, and $\vec u$, we also define a related decision problem:
\begin{equation}
\DPr(n,b):\quad
\parbox{9cm}{given an input  $\vec p(\vec x)=\vec u$  with $\vec u\in \Boo n ^b$, decide whether the equation $\vec p(\vec x)=\vec u$ has a solution in $\Boo n ^k$ for the unknown $\vec x$.}
\label{eq:lnRbzkTjl}
\end{equation}
The acronyms $\CPr$ and $\DPr$ come from ``Construction Problem'' and ``Decision Problem'', respectively. 
Let $\size{\vec p(\vec x)=\vec u}$ 
and $\size{\vec h}$
denote the \emph{size} of $\vec p(\vec x)=\vec u$ and that of $\vec h$, respectively; these sizes are the numbers of bits in (the usual) binary  representations of $\vec p(\vec x)=\vec u$ and $\vec h$.

There are many books and papers dealing with the widely known concept of the complexity classes \clp{} and \clnp{}; some of them will be cited later but even \href{https://en.wikipedia.org/wiki/NP-completeness}{Wikipedia} is sufficient for us.  However, \clp{}, \clnp{}, and \clnp{}-completeness are usually about \emph{decision problems} 
while $\CPr(n,b)$  in \eqref{eq:sJbKmlDks} is not such. There is another difference: while we require an answer for \emph{each input string} in case of a decision problem, this is not so in case of 
$\CPr(n,b)$. These circumstances constitute our excuse that we neither define what the \clnp{}-completeness of  $\CPr(n,b)$ could mean nor we know whether $\CPr(n,b)$ would have such a property (as we would experience difficulty with a suitable replacement of $\Alg_1(d)$ later in the proof). However, we can safely agree to the following terminology:
%
\begin{equation}
\parbox{10.7cm}%{11.9cm}
{$\CPr(n,b)$, given in \eqref{eq:sJbKmlDks}, \emph{belongs to} \clp{} \quad $\defiff$ \quad there are an algorithm $\Alg(n,b)$ and a polynomial $f^{(n,b)}$ such that for every  input equation $\vec p(\vec x)=\vec u$ of $\CPr(n,b)$, \emph{if} 
 $\vec p(\vec x)=\vec u$ has a solution, 
  \emph{then}  $\Alg(n,b)$ finds one of its solutions in (at most) $f^{(n,b)}(\size{\vec p(\vec x)=\vec u})$ steps.}
\label{eq:jrDljrkthlH}
\end{equation}
The algorithm and the polynomial depend on the parameters $n$ and $b$.
We could have written  ``time'' instead of ``steps''. Later, we will always omit ``(at most)''.  

We have the following statement, in which $b$ denotes the dimension of $\vec p$.

\begin{proposition}\label{prop:NP} For $2\leq b\in\Nplu$ and $n\in\Nplu$, if $\CPr(n,b)$, defined in  \eqref{eq:sJbKmlDks}, belongs to the complexity class \clp{} in the sense of \eqref{eq:jrDljrkthlH}, then \clp{} is equal to \clnp{}. In other words, $\CPr(n,b)$, which is 
the underlying mathematical problem of the authentication protocol \eqref{eq:lrJgfncNpZnkt},   \emph{is likely to be harder than \clp}.
\end{proposition}


Even if the famous ``is \clp{} equal to \clnp{}?'' problem is, unexpectedly, solved affirmatively in the future, the \emph{proof} below will still say something on the difficulty of  $\CPr(n,b)$.




\begin{proof}
In the whole proof, we assume that $2\leq b\in\Nplu$, $n\in\Nplu$, and  $\CPr(n,b)$ belongs to \clp{}. 

In principle, we should have written ``Turing machine'' in  \eqref{eq:jrDljrkthlH} rather than ``algorithm''\footnote{and ``input string'' rather than ``input equation'', but this distinction would not make an essential difference as the syntax of the input string can be checked in polynomial time.}.
Fortunately, the algorithms in the proof (which are clearly equivalent to usual computer programs) can be simulated by Turing machines and this simulation preserves the property ``being in \clp''; see, for example, Theorem 17.4 in Rich \cite{rich}. 
By the same theorem, for $n'$ computer steps%
\footnote{We can think of the commands in low-level computer programming languages but not of  compound commands like ``NextPrimeAbove(n)'' of ``InvertMatrix(A)'' in high-level programming languages.
}
 (and for $n'$ steps in our mind), the simulating Turing machine  needs $(O(n'))^6$ steps.  Therefore,  we will mostly  speak of polynomials without specifying their degrees even when a sub-algorithm is clearly linear (or even better) in our mind, that is, for our computers. For example, 
\begin{equation}
\parbox{11.4 cm}{for each fixed $d\in\Nplu$, there are  a polynomial $f^{(d)}_1$ and an algorithm $\Alg_1(d)$ such that, for  each $\xi\in\Nplu$, 
$\Alg_1(d)$ computes and stores $\xi^d$ in   $f_1^{(d)}(\xi)$ steps.}
\label{eq:sTdOssteps}
\end{equation}
Clearly, there are polynomials $f_2^{(n,b)}$ and $f_3$ and  algorithms $\Alg_2(n,b)$ and $\Alg_3$ such that for all  inputs  $\vec p(\vec x)=\vec u$, as in \eqref{eq:sJbKmlDks}, and   $\vec h\in \Boo n ^k$,
\begin{align}
&\parbox{8cm}{$\Alg_2(n,b)$ decides in  $f_2^{(n,b)}\bigl(\size{\vec p(\vec x)=\vec u}+\size{\vec h}\bigr)$ steps whether $\vec h$ is a solution of $\vec p(\vec x)=\vec u$, and}
\label{eq:xshklXpslg}\\
&\parbox{8cm}{$\Alg_3$ computes and stores the number $\size{\vec p(\vec x)=\vec u}$  in  $f_3\bigl(\size{\vec p(\vec x)=\vec u}\bigr)$ steps.}
\label{eq:dpRkCdVr}
\end{align}
%
Let $\Alg(n,b)$ and $f^{(n,b)}$ be chosen according to \eqref{eq:jrDljrkthlH}. 
We can assume that $f^{(n,b)}$ is of the form $f^{(n,b)}(\xi)=\xi^{d(n,b)}$ for some $d(n,b)\in\Nplu$.  
Then  $\Alg(n,b)$ halts in $\bigl(\size{\vec p(\vec x)=\vec u}\bigr){}^{d(n,b)}$ steps for any solvable input $\vec p(\vec x)=\vec u$ but we do not know what  $\Alg(n,b)$ does and whether it ever  halts at other inputs. Using \eqref{eq:sTdOssteps}--\eqref{eq:dpRkCdVr}, 
we define another algorithm $\Blg(n,b)$ as follows. 
{The input of $\Blg(n,b)$ is an equation $\vec p(\vec x)=\vec u$ from}  \eqref{eq:lnRbzkTjl}; let $s:= \size{\vec p(\vec x)=\vec u}$.
The first task of $\Blg(n,b)$ is to save a copy of  $\vec p(\vec x)=\vec u$; this needs $ f_0(s)$ steps where $f_0$ is a polynomial not depending on the parameters $n$ and $b$ and the input  $\vec p(\vec x)=\vec u$. The second part of $\Blg(n,b)$ is $\Alg_3$, which borrows the  
 input $\vec p(\vec x)=\vec u$ from $\Blg(n,b)$ and puts  $s$ to the output stream  in $f_3(s)$ steps. 
The next part of $\Blg(n,b)$ is $\Alg_1(d(n,b))$, which considers the output of $\Alg_3$ as an input and puts $f^{(n,b)}(s)=s^{d(n,b)}$ into a (counter) variable $c$ in $f_1^{(d(n,b))}(s)$ steps. 
Then $\Blg(n,b)$ performs the steps of $\Alg(n,b)$ and the ``$(\alpha)$--$(\delta)$-strides'' given below alternately. (Here a  ``stride'' means a finite sequence of steps, possibly just one step.) 
After the first $\Alg(n,b)$-step, $\Blg(n,b)$ performs the following strides.
 %
\begin{enumerate}
\item[($\alpha$)] $\Blg(n,b)$ decreases $c$ by 1.
%
\item[($\beta$)] $\Blg(n,b)$ verifies whether $c = 0$.
%
\item[($\gamma$)] $\Blg(n,b)$ checks whether $\Alg(n,b)$ has halted.
%
\item[($\delta$)] If $c=0$ or  $\Alg(n,b)$ has halted then, using the saved copy of  $\vec p(\vec x)=\vec u$,  $\Blg(n,b)$ executes $\Alg_2(n,b)$ to verify whether the output of $\Alg$ is a solution of  $\vec p(\vec x)=\vec u$. If $\Alg_2(n,b)$ terminates with ``yes'', then $\Blg(n,b)$ outputs ``yes, the equation is solvable'' and halts. Otherwise, if $\Alg_2(n,b)$ terminates with ``no'', then $\Blg(n,b)$ outputs ``no, the equation is not solvable'' and halts.
\end{enumerate}
%
After these $(\alpha)$--$(\delta)$-strides, the next $\Alg(n,b)$-step is performed, then the $(\alpha)$--$(\delta)$-strides again, etc. 
The \emph{kernel} of the  $(\delta)$-stride is its part following the \emph{premise}  ``if $c=0$ or  $\Alg(n,b)$ has halted''; this kernel is performed only once.  
As $c\leq s^{d(n,b)}$, there is a polynomial $f_4^{(n,b)}$, not depending on the input of $\Blg(n,b)$, such that each of the $(\alpha)$--$(\gamma)$-strides can be done in $f_4^{(n,b)}(s)$ many  steps and, furthermore, the same holds for every $\Alg$-step (since it is only a one-step stride) and for  the condition  part of $(\delta)$. The $\Alg$-step, $(\alpha)$, $(\beta)$, $(\gamma)$, and the premise of $(\delta)$ are performed $f^{(n,b)}(s)=s^{d(n,b)}$ times, each.  
The kernel of the $(\delta)$-part, which is performed only once, is the same as $\Alg_2(n,b)$. The input of $\Alg_2(n,b)$ in this case is (the saved copy of) $\vec p(\vec x)=\vec u$ (of size $s$) together with $\vec h$, taken from the output stream of $\Alg(n,b)$. (Even if $\Alg(n,b)$ does not halt, there is a memory space --- or, in case of a Turing machine,  there is an output tape --- where $\vec h$ is expected when it exists.) As an element of $\Boo n$ can be stored in $n$ bits, $\size{\vec h}=n k$. Here $n$ is a constant and $k\leq s$ since $\vec x$ has $k$ components that occur in $\vec p=(\vec x)=\vec u$. Hence,
$\size{\vec h}\leq n s$, whereby $\Alg_2(n,b)$ decides in 
$f_2^{(n,b)}(s+n s)=f_2^{(n,b)}((n+1)s)$ steps whether the output of $\Alg(n,b)$ is a solution of our equation.  Therefore, $\Blg(n,b)$ 
 halts after
\begin{equation}
g^{(n,b)}(s):=f_0(s)+f_3(s)+f_1^{(d(n,b))}(s)+ f^{(n,b)}(s)\cdot f^{(n,b)}_4(s)+f_2^{(n,b)}((n+1)s)
\label{eq:lkMdszKznm}
\end{equation}
steps. As we treat the parameters $n$ and $b$ as constants,  $g^{(n,b)}$ is a univariate polynomial.
Since the simulated $\Alg$ finds any solution before the counter $c$ becomes 0, $\Blg$ correctly decides whether $\vec p(\vec x)=\vec u$ has a solution or not. That is, $\Blg$ solves $\DPr(n,b)$. We have seen that  $g^{(n,b)}$  in \eqref{eq:lkMdszKznm} is a polynomial, whereby
%
\begin{equation}
\parbox{7cm}{$\DPr(n,b)$, defined in \eqref{eq:lnRbzkTjl}, is in \clp{}, and $\Blg(n,b)$ solves it in $g^{(n,b)}($input size) steps.}
\label{eq:szKnmRrlSTgF}
\end{equation}


As the next step of the proof, we focus on another problem. 
An input of the \emph{$3$-colorability problem} 
is a finite  graph $G=(\set{1, \dots, t},E)$, where 
$t\in\Nplu$ and the edge set $E$ consists of some two-element subsets of $\set{1,\dots,t}$. 
By a \emph{$3$-coloring}  we mean a sequence $C_1$, $C_2$,  \dots, $C_t$ of nonempty subsets of $\set{r,w,g}:=\{$red, white, green$\}$ such that whenever $\set{i,j}\in E$, then $C_i\cap C_j=\emptyset$. (This is %clearly
equivalent to the original definition, where each vertex has exactly one color
since we can change a color $\xi$ to $\set{\xi}$ and, in the converse direction, we can take the lexicographically first element of each nonempty subset of $\set{r,w,g}$.)

To reduce the 3-colorability problem to problem $\DPr(n,b)$, let $G$ be the graph from the previous paragraph, and let $\sg :=\size G$.
Let  $r_1$, $w_1$, $g_1$,  \dots, $r_t$, $w_t$, $g_t$ be variables;  their task is to determine a 3-coloring. These $k:=3t$  variables form the components of a vector denoted by $\vec x$.  For each vertex $v\in\set{1,\dots,t}$ and each edge $\set{i,j}\in E$, consider the $k$-ary lattice terms 
\begin{equation}
  a_{v}(\vec x):= r_v\vee  w_v\vee  g_v \text{ and }
  b_{i j}(\vec x):=(r_i\wedge r_j)\vee (w_i\wedge w_j)\vee
(g_i\wedge g_j).
\label{eq:mklSkdnmRbg}
\end{equation}
For $m\in\set{2,\dots,t}$, let
\begin{equation}
p_1:=\bigwedge\set{a_{v}(\vec x):v\in\set{1,\dots,t}}\quad
\text{ and }\quad
p_m:=\bigvee\set{b_{i j}(\vec x):\set{i,j}\in E},
\label{eq:dmNrmHnJs}
\end{equation}
$\vec p:=(p_1,\dots,p_t)$, and $\vec u=(u_1,\dots,u_t):=(1,0,\dots,0)$, where\footnote{\label{foot:szNzknvcsntD}Note that, to reduce the size of $\vec p$, we could have let $p_3=\dots=p_t:=r_1\vee w_1\vee g_1$ together with $u_3=\dots=u_t=1$.} $0=0_{\Boo n}$ and $1=1_{\Boo n}$. 
 We claim that 
\begin{equation}
\vec p(\vec x)=\vec u\text{ has a solution in }\Boo n^k\text{ if and only if } G\text{ is 3-colorable.}
\label{eq:hdnlVln}
\end{equation}
To see this, assume that $C_1$, \dots, $C_t$ are color sets witnessing that $G$ is 3-colorable. For $v\in\set{1,\dots, t}$, 
let  $r_v:=1\iff r\in C_v$,  $w_v:=1\iff w\in C_v$, and $g_v:=1\iff g\in C_v$.  If a variable is not 1, then let it be 0. Clearly, these assignments yield a solution in $\Boo n^k$ of $\vec p(\vec x)=\vec u$. 
%
Conversely, assume that $\vec p(\vec x)=\vec u$ has a solution $\vec x'=(r'_1,w'_1,g'_1,\dots, r'_t, w'_t, g'_t)\in\Boo n^k$ for the unknown $\vec x$, and fix an atom\footnote{For experts, there is another way, which does not need this atom. Namely, take a projection homomorphism $\pi\colon\Boo n\cong\prod_{i\in\ideal n}\Boo 1\to \Boo 1$, and work with $\pi(\vec x')$ in $\Boo 1 = \set{\textup{false},\textup{true}}$.}
$e$ in $\Boo n$.
%
For each $v\in\set{1,\dots, t}$, 
define $C_v\subseteq \set{r,w,g}$ by the rules $r\in C_v\iff e\leq r'_v$, $w\in C_v\iff e\leq w'_v$, and  $g\in C_v\iff e\leq g'_v$. 
For any $v\in\set{1,\dots,t}$, $p_1(\vec x')=u_1=1$ and \eqref{eq:dmNrmHnJs} give that 
$e\leq 1=p_1(\vec x')\leq  a_v(\vec x')=r'_v\vee w'_v\vee g'_v$. Using the well-known fact that every atoms (and, in fact, any join-irreducible element) in a finite distributive lattice is join-prime, we obtain that at least one of the inequalities 
$e\leq r'_v$, $e\leq w'_v$, and $e\leq g'_v$ holds, whereby $C_v$ is nonempty. For $\set{i,j}\in E$, 
$p_2(\vec x')=u_2=0$ and \eqref{eq:dmNrmHnJs} give that $(r'_i\wedge r'_j)\vee (w'_i\wedge w'_j)\vee
(g'_i\wedge g'_j)=0$. 
Hence, $r'_i\wedge r'_j=w'_i\wedge w'_j=
g'_i\wedge g'_j=0$. If, say, we had that $r\in C_i\cap C_j$, then $e\leq r'_i$ and $e\leq r'_j$ would lead to
$e\leq r_i'\wedge r'_j=0$, a contradiction. Hence, $r\notin C_i\cap C_j$, and similarly for the colors $w$ and $g$, showing that $C_i\cap C_j=\emptyset$. So $C_1,\dots, C_t$  witness that $G$ is 3-colorable, and we have shown \eqref{eq:hdnlVln}.  


Let  $s_G:=\size G$ and 
$s$ stand for the size of $G$  and, complying with the earlier notation,  the size of  the equation in \eqref{eq:hdnlVln}, respectively. 
It is not hard to see that there are  polynomials $\mu$ and $\eta$ not depending on $G$ such that   $\vec p(\vec x)=\vec u$   can be constructed from $G$ in $\eta(\sg)$ steps and  $s\leq \mu(\sg)$. We define an algorithm $\Mlg$ as follows. 
For a graph  $G$ as an input, $\Mlg$ constructs  $\vec p(\vec x)=\vec u$, 
then it calls $\Blg(n,b)$ and, finally, it  outputs the same answer that $\Blg(n,b)$ has given. By \eqref{eq:szKnmRrlSTgF} and  \eqref{eq:hdnlVln},  $\Mlg$ solves the 3-colorability problem.  As  $s=\size{\vec p(\vec x)=\vec u}\leq \mu(\sg)$, $\Mlg$ does so in $\nu(\sg):= \eta(\sg) + g^{(n,b)}(\mu(\sg))$ steps. 
As $\nu$ is a polynomial, we obtain that the 3-colorability problem is in $\clp$. On the other hand, we know from Garey, Johnson, and Stockmeyer \cite{Gareyatal}, see also Dailey \cite[Theorems 3 and 4]{dailey}, that $3$-colorability is an \clnp{}-complete problem. Now that an  \clnp{}-complete problem turned out to be in \clp, it follows that \clnp{} = \clp{}, completing the proof. 
\end{proof}


\begin{remark}\label{rem:szrltJLz}
The proof above has reduced the \clnp-complete 3-colorability problem to problem $\DPr(n,b)$, defined in \eqref{eq:lnRbzkTjl}. Therefore,  $\DPr(n,b)$  is also an \clnp-complete  problem for any $2\leq b\in\Nplu$ and any $n\in\Nplu$. 
\end{remark}













\section{A variant of 3-SAT}\label{sect:3SAT}
Let us recall that a \emph{literal} is a variable or a negated variable, a \emph{clause}
is a disjunction of literals, and a \emph{conjunctive normal form}, CNF for short, is the conjunction of some clauses. The \emph{size} of a CNF it the number of keystrokes\footnote{More precisely (but without any  difference in our argument): the number of bits we need to store it.} we need to type it. The Boolean satisfiability problem, SAT for short, is the problem that takes a CNF as input and decides whether we can substitute elements of $\Boo 1=\set{0,1}$ for the variables of the CNF such that the value of the CNF becomes 1.  By the Cook-Levin Theorem, see Cook \cite{cook} and Levin \cite{levin}, 
SAT is \clnp{}-complete. If we restrict the CNF's to those in which every clause has exactly three literals (equivalently, at most three literals), then we obtain the so-called 3SAT (problem). By Karp \cite{karp},  3SAT is \clnp{}-complete, too. Even 3SAT can be restricted further. For example, 
the \emph{not-all-equal $3$-satisfiability}
and the \emph{one-in-three-$3$SAT} problems, which we do not define here,  are still \clnp{}-complete; see Schaefer \cite[NP1 and NP2 in page 217]{schaefer}. 
Here we take the opportunity that the previous section offers a short and elementary proof for the following observation. 

\begin{observation}\label{obs:nmsBzlhB} 
Assume that $f$ is a conjunctive normal form such that for each clause $C$ of $f$,
\begin{itemize}
\item either $C$ is the disjunction of three non-negated variables
\item or $C$ is the disjunction of two negated variables.
\end{itemize}
Then it is an \clnp{}-complete problem to decide whether  $f$ is satisfiable, that is, whether we can substitute $0$'s and $1$'s for its variables to obtain $1$.
\end{observation}

For example, $f=(x_1\vee x_2\vee x_2)\wedge(\neg x_1\vee \neg x_4)\wedge (\neg x_2\vee \neg x_4)$ is in the scope of Observation \ref{obs:nmsBzlhB} but $f_2=(\neg x_1\vee \neg x_2\vee \neg x_2)\wedge(x_1\vee  x_4)$ is not.


\begin{proof} 
By \eqref{eq:mklSkdnmRbg}--\eqref{eq:hdnlVln}\footnote{As Footnote \ref{foot:szNzknvcsntD} indicates, $p_3$, \dots, $p_t$ are not important, so we omit them here.},  a graph $G$ is 3-colorable if and only if the corresponding $p_1\wedge \neg p_2=1$ is solvable in the 2-element Boolean lattice $\Boo 1$. 
By de Morgan's laws,  $p_1\wedge \neg p_2$ can be rewritten, in polynomial time, into a CNF $f$ satisfying the requirements of Observation~\ref{obs:nmsBzlhB}. Since $G$ is 3-colorable if and only the equation $f=1$ has a solution,  we have reduced the \clnp-complete 3-colorability problem to the current problem, whereby we conclude the validity of Observation~\ref{obs:nmsBzlhB}.
\end{proof}
 







\section{Warning and perspectives}\label{section:warn}
Note in advance that, occasionally, cryptography can go after conjectures and experimental knowledge if no  rigorous mathematical proof is available. For example, we only \emph{believe} that the RSA crypto-system is safe and \clp{} $\neq$ \clnp{}. This can justify that no proof occurs in Sections \ref{sect:ACprtcl} and \ref{section:warn}.


\begin{remark}\label{rem:sltRsn} 
An authentication or cryptographic protocol with a hard underlying problem does not have to be safe. Thus, Proposition \ref{prop:NP} \emph{in itself} does not guarantee  the safety of protocol \eqref{eq:lrJgfncNpZnkt}.
\end{remark}

In part, this is so because the Adversary might break a protocol without solving the underlying problem. For example, the Adversary can break  \eqref{eq:lrJgfncNpZnkt} 
with parameters $n=1$ and $b=2$ at every fourth random attempt even though the underlying problem is hard by Proposition \ref{prop:NP}. 



The second explanation of Remark \ref{rem:sltRsn} is that  even a hard problem can have many easy instances (i.e., inputs) for which the computation is fast. 
For example, there are fast algorithms that work on the ``average cases'' 
 of some \clnp{}-complete problems even though these algorithms  cannot deal with the hard cases; see the Introduction in Wang \cite{wang} for details. 
It is needless to say  how much harm the Adversary can cause if he can apply a fast algorithm for, say, every tenth case.



\begin{remark}\label{rem:kvtlGs} We would need an algorithm that chooses  $\vec p\,$  for protocol \eqref{eq:lrJgfncNpZnkt} so that, modulo this algorithm, the average case of the underlying problem $\CPr(n,b)$, defined in \eqref{eq:sJbKmlDks}, is hard.
\end{remark}


Even though Footnote \ref{foot:hRstnDp} and  Cz\'edli \cite{czgDEBRauth} give some heuristic ideas how we could choose a random $\vec p$ and these  ideas are likely to satisfy the requirement of Remark \ref{rem:kvtlGs},  these ideas are not  supported by proofs. This is why we mention the \emph{tiling problem} from  Levin \cite{levin}; see also Wang \cite{wang} as a secondary source. This problem, which we do not define here, includes a probabilistic distribution. Levin \cite{levin} proved that, with respect to this distribution, the average case of the tiling problem is hard in some (sophisticated) sense. 



\begin{remark}\label{rem:tlkcStmZgL}
Similarly to the proof of Proposition \ref{prop:NP}, see also Remark \ref{rem:szrltJLz},  
we can reduce the tiling problem to $\DPr(n,b)$ defined in   \eqref{eq:lnRbzkTjl}.  
(The \clnp-completeness of $\DPr(n,b)$ implies the existence of such a reduction but we need a concrete one that is sufficiently economic.)
Then we can pick a random $\vec p$ for  \eqref{eq:lrJgfncNpZnkt} so that first we take a random instance $y$ of the tiling  problem and then we let $\vec p$ be the polynomial vector in the ``$\DPr(n,b)$-representative'' of $y$. As $y$ and, thus, the corresponding equation in $\DPr(n,b)$ are hard on average, we can hope
that this $\vec p$ turns $\CPr(n,b)$, the underlying problem of \eqref{eq:lrJgfncNpZnkt}, hard on average, too.
\end{remark}

%
However, the details of this plan have not been elaborated yet. In particular, we have not proved that the above-suggested method of choosing $\vec p$ (which is only a part of the $\DPr(n,b)$-representative of $y$)  turns $\CPr(n,b)$ (which is another problem)  hard on average. Furthermore,  
it is not clear whether the parameters suggested in Section \ref{sect:ACprtcl} are large enough for the plan suggested in Remark \ref{rem:tlkcStmZgL}. Hence, the heuristic ideas in  Footnote \ref{foot:hRstnDp} and \cite{czgDEBRauth} would also deserve further investigations. 




As we have wandered a bit far from the initial purpose of  the paper, to find small generating set in  Boolean lattices, let us summarize how Theorem \ref{thm:nleqSpk} contributes to cryptography.
%
As we have already mentioned, see Footnote  \ref{foot:mkSTm}, we need that $H(\vec h)=\set{h_1,\dots,h_k}$ generates a sublattice of $\Boo n$ that is  \emph{large}. 
Indeed, if $H(\vec h)$ generates, say, a ten element sublattice, then the Adversary could steal \woman's money from the Bank at every tenth attempt on average. 
The best (and probably the most economic) way the ensure that the sublattice in question is large is to stipulate that $H(\vec h)$ generates the whole $\Boo n$ but this is not enough in itself, $n$ should be large, too. So we conclude: 
\begin{equation}\text{$n$ should be large and $H(\vec h)$ should generate $\Boo n$.}
\label{eq:nBflchrmBpr}
\end{equation}
The sceptic  may argue that with $k\geq n$ (especially with $k$ being much greater than $n$), it would be quite easy to ensure that $H(\vec h)$ generates $\Boo n$. 
%
However, there is an advantage of having a $k$ that is much smaller than $n$. As $\vec u$ in \eqref{eq:lrJgfncNpZnkt} and $\vec y$ in \eqref{eq:RszmKlfrptsnP} consist of $nb$ bits and $n\cdot \frac b v$ bits, respectively, the larger $n$ means that \woman{} can send a  longer (and safer) authentication vector and she can encipher and send a longer message according to  \eqref{eq:lrJgfncNpZnkt} and   \eqref{eq:RszmKlfrptsnP}, respectively 
\emph{while} generating and attaching \emph{smaller} (that is, only $k$-variable)  random lattice terms. Note that to generate a random lattice term, several calls of a  \emph{time-consuming}  (pseudo-)random number generator are necessary; presumably less calls for smaller $k$. Also, for smaller $k$, it is faster to compute $\vec p(\vec h)$, and it is easier to store $\vec h$.

\ncol
There is another advantage of the fact that, due to Theorem \ref{thm:nleqSpk},  $n$ can be much larger than $k$. As $\Boo n\cong \Boo 1^n=\set{0,1}^n$, the elements of $\Boo n$ are (treated as) $n$-dimensional bit vectors and the calculations are done componentwise.
The point is that  \woman{{} and the Bank \emph{do not have the use all the  $n$ components every time}. If the message in \eqref{eq:twStjrgshdmSnD} and \eqref{eq:RszmKlfrptsnP} is short or if only authentication is requested according to \eqref{eq:lrJgfncNpZnkt}, then \emph{it suffices to use only a part of the components}\footnote{If  at least two components are used, then Proposition \ref{prop:NP} applies.}. So we can improve $\Prot$ and $\Prot^-$  from \eqref{eq:wDPrthr} and \eqref{eq:mMztmPrt} to the following protocols
\begin{align}
\sProt&=\sProt(n,k,\vec h, b,\Strat,v,S)
\label{eq:mjTvlHvpra}\text{ and}\\
\sProt^-&=\sProt^-(n,k,\vec h, - ,\Strat,v,S)
\label{eq:mjTvlHvprb}
\end{align} 
where $S$ is, say, an at least $\lint{n/2}$-element subset of $\set{1,2,\dots, n}$.
Consider $\Boo n$ the powerset lattice $P(\set{1,\dots,n}$ and denote $|S|$ by $n_S$. 
Also, consider $\Boo{{n_S}}$ the powerset lattice $P(S)$. The components $h_1,\dots,h_k$ of $\vec h$ are subsets of $\set{1,\dots,n}$, so we can let $\vec h_S:=(h_1\cap S,\dots, h_k\cap S)$. As the function $P(\set{1,\dots,n})\to P(S)$ defined by $X\mapsto X\cap S$ is a surjective lattice homomorphism and surjective homomorphisms send generating sets to generating sets, the components of $\vec h_S$ generate $P(S)=\Boo{n_S}$. These trivial considerations allow us to agree upon the following. 

\begin{definition}\label{def:PrzjvtdnMbs}
The protocols \eqref{eq:mjTvlHvpra} and \eqref{eq:mjTvlHvprb} are used as
$\Prot(n_S,k,\vec h_S,b,\Strat,v)$ from \eqref{eq:wDPrthr} and $\Prot(n_S,k,\vec h_S,-,\Strat,v)$ from \eqref{eq:mMztmPrt}, respectively; the only difference is that
instead of sending a vector $\vec p$ of lattice terms, both $\vec p$ and  $S$ have to be sent.
\end{definition}

There are at least are $2^{n-1}$ possible subsets $S$ for protocols \eqref{eq:mjTvlHvpra} and \eqref{eq:mjTvlHvprb}. (There are exactly $2^{n-1}$ for $n$ even and  there are slightly more for $n$ odd.)  So, in addition to Proposition \ref{prop:NP}, the Adversary  has to face  exponentially many  possible subsets $S$.
\bcol



\section{Appendix: a Pascal program}\label{sect:appDx}

{\footnotesize 
\begin{verbatim}
program BooGenEZ;  uses sysutils; const lineno=13;
 info:array[1..lineno] of string[80]=(
 ' BooGenEZ, a Dev-Pascal 1.9.2. program for studying the small ',
 ' generating sets of B_n, which is the powerset lattice of ',
 ' an n-element set. (For a faster version, see BooGnFtr.) ',
 ' ',
 ' After asking for n and k, the program generates k-dimensional ',
 ' random vectors with components in B_n and counts those vectors ',
 ' the components of which generate B_n. ',
 ' For the first trial,  n <20  and k < 20 are recommended.',
 ' ',
 ' This is not a professional program: improper inputs lead to',
 ' "runtime error" messages.    So the program is as is.  ',
 '   (C) Gabor Czedli, 2023',
 ' ' );

const nmax=2000; kmax=120; vpldate='March 18'; {see next line, too}
  vpfldatum ='"BooGenEZ" '+vpldate
     +' on k-generation of B_n; (C) Gabor Czedli, 2023';
var H:array[1..kmax,1..nmax] of Boolean; {\vec h consists of its rows}
   n,k,ii,again: integer;  timeused: real;
   nt,reqt,ng:longint; {number of tests, requeste test, generating H's}
   hour0,hour1,min0,min1,sec0,sec1, msec0, msec1:word;

procedure randfill;{forward;} var i,j: integer;
 begin for i:=1 to k do for j:=1 to n do
       if random(2)=1 then H[i,j]:=true else H[i,j]:=false
 end;

procedure inputdata;
 begin Write('Enter n in [2...',nmax,'] :'); readln(n);
   Write('Enter k  in [2...',kmax,'] :'); readln(k);
   Write('Enter the (positive!) number of tests, or enter 0 for halt: ');
   readln(reqt); {requested tests}
  if reqt<=0 then reqt:=MaxLongInt;
  if (n>nmax) or (n<3) then
   begin writeln('n is out of range. Hit <enter> to abandon');
    readln; halt;
   end;
  if  (k>kmax) or (k<3) then
   begin writeln('k is out of range. Hit <enter> to abandon');
     readln; halt;
   end;
 end{inputdata};

function doesHgenerate:boolean;
 var colj,colo,rowi: integer; hope,b:boolean; {colo:column-other}
 begin   colj:=0; {column pointer}
  repeat inc(colj); hope:=false;
   for rowi:=1 to k do hope:=hope or H[rowi,colj];
   if hope then
   for colo:=1 to n do if (hope) and (colo<>colj) then
    begin b:=true;
     for rowi:=1 to k do
        if H[rowi,colj] then b:=b and H[rowi,colo];
     if b then hope:=false;
    end; {for colo}
  until  (not hope) or (colj=n); {inspection done}
  doesHgenerate := hope;
 end; {doesHgenerate}

begin {main} for ii:=1 to  lineno do writeln(info[ii]);
 repeat inputdata; nt:=0; ng:=0; randomize; writeln;
   decodetime(time,hour0,min0,sec0,msec0);    writeln(vpfldatum);
   writeln(  'Computation starts at ',hour0,':',min0,':',sec0,'.',msec0);
  writeln;  again:=1;
  repeat   randfill;  inc(nt);{number of tests}
  if doesHgenerate then inc(ng);
    if nt mod 256=0 then write('. ');
  until nt>=reqt;
  decodetime(time, hour1,min1,sec1,msec1);
   writeln;  write('n=',n,' k=',k,' Tested:',nt,' Generating:',ng);
  decodetime(time, hour1,min1,sec1,msec1);
  timeused:= (3600000*(hour1-hour0)+60000*(min1-min0)
             +1000*(sec1-sec0)+msec1-msec0)/1000;
  writeln(   '; BooGenEZ used', timeused:15:3,' seconds.'); writeln;
  write('Enter 1 to start again, or enter 0 to abandon. ');
  readln(again);   writeln;
 until again <> 1;
 write('Thank you for using this program.   Hit <enter>.');  readln;
end.
\end{verbatim}
}


\begin{thebibliography}{99}

\bibitem{delbrinczg}
D. Ahmed and G. Cz\'edli\footnote{Some preprints are available from arXiv or ResearchGate but, at the time of writing, primarily from the author's homepage.}:
(1+1+2)-generated lattices of quasiorders. Acta Sci. Math. (Szeged) 87 (2021), 415--427.


\bibitem{balbes}
Balbes, R.:
Projective and injective distributive lattices.
Pacific J. Math. \tbf{21}405--420 (1967)

\bibitem{chajdaczg}
I. Chajda and G. Cz\'edli:
How to generate the involution lattice of quasiorders?, Studia Sci. Math. Hungar. 32 (1996), 415--427.


\bibitem{cook}
Cook, S. A.: The complexity of theorem-proving procedures.  
Proceedings of the 3rd Annual ACM Symposium on Theory of Computing,  151--158 (1971)


\bibitem{CzGEateq}
G. Cz\'edli: Lattice generation of small equivalences of a countable set. 
Order 13 (1996), 11--16.


\bibitem{CzGEq4}
G. Cz\'edli: Four-generated large equivalence lattices. Acta Sci. Math. (Szeged) 62 (1996), 47--69.


\bibitem{czgeek}
G. Cz\'edli: (1+1+2)-generated equivalence lattices, J. Algebra, 221 (1999), 439--462.


\bibitem{czg2017fourgen}
G. Cz\'edli:
Four-generated quasiorder lattices and their atoms in a four generated sublattice; Communications in Algebra, 45/9 (2017) 4037--4049.

\bibitem{czgDEBRauth}
Cz\'edli, G.:
Four-generated direct powers of partition lattices and authentication. Publicationes Mathematicae (Debrecen) \tbf{99} (2021), 447--472


\bibitem{czgfiltQuo}
Cz\'edli, G.: Generating some large filters of quasiorder lattices. \href{http://arxiv.org/abs/2302.13911}{arXiv:2302.13911} or (the latest version at the time of writing) \url{https://tinyurl.com/czg-genfquo}

\bibitem{czgkulin}
G. Cz\'edli and J. Kulin:
A concise approach to small generating sets of lattices of quasiorders and transitive relations. Acta Sci. Math. (Szeged) 83 (2017), 3--12


\bibitem{czgoluoch}
 G. Cz\'edli and L. Oluoch:
 Four-element generating sets of partition lattices and their direct products. 
Acta Sci. Math. (Szeged) 86,  405--448 (2020).



\bibitem{dailey}
Dailey, D. P.: Discrete Mathematics 30 (1980) 289-293; see Theorems 3--4.  

\bibitem{dolgos}
Dolgos, T.: 
Generating equivalence and quasiorder lattices over finite sets, BSc Thesis, University of Szeged, 2015 (in Hungarian)


\bibitem{Gareyatal}
Garey, M.R., Johnson, D. S., Stockmeyer, L.:
Some simplified \clnp{}-complete problems. 
STOC '74: Proceedings of the sixth annual ACM symposium on Theory of computing, April 1974,  Pages 47--63.
\url{https://doi.org/10.1145/800119.803884}

\bibitem{r:Gr-LTFound} 
   Gr\"atzer, G.:    Lattice Theory: Foundation.   Birkh\"auser, Basel (2011)


\bibitem{karp}
Karp, R.M. (1972). Reducibility among Combinatorial Problems. In: Miller, R.E., Thatcher, J.W., Bohlinger, J.D. (eds) Complexity of Computer Computations. The IBM Research Symposia Series. Springer, Boston, MA.
%https://doi.org/10.1007/978-1-4684-2001-2_9


\bibitem{kisz}
Kisielewicz, A.: A solution of Dedekind's problem on the number of isotone Boolean functions. J. Reine Angew. Math. \tbf{386}, 139--144 (1988) 


\bibitem{kulin}
J. Kulin: 
Quasiorder lattices are five-generated. Discuss. Math. Gen. Algebra Appl. 36
(2016), 59--70.

\bibitem{kuratowski}
K. Kuratowski: Sur l'\'etat actuel de  l'axiomatique de la th\'eorie des ensembles. 
Ann. Soc. Polon. Math. \tbf 3, 146--147, 1925.


\bibitem{levin}
Levin L. A.: Universal Sequential Search Problems. Problemy Peredachi Informatsii \tbf{9}:3, 115--116,  1973; Problems Inform. Transmission, \tbf{9}:3, 265--266 (1973) 
\nothing{https://www.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=ppi&paperid=914&option_lang=eng}

\bibitem{levinav}
Levin, L.A.: Average case complete problems.
SIAM J. Comput. \tbf{15}, No.\ 1. 285--286, February 1986, 
\url{https://gwern.net/doc/cs/algorithm/1986-levin.pdf}


\bibitem{levy}
A. Levy: Basic Set Theory. 
Springer-Verlag, Berlin--Heidelberg--New York, 1979.

\bibitem{mcKmcNT}
 McKenzie, R.N.,  McNulty, G.F.,  Taylor, W.F.:
Algebras, Lattices, Varieties. Vol. 1.
Wadsworth $\&$ Brooks/Cole, Monterey, California, 1987

\bibitem{rich}
Rich, Elaine: Automata, Computability, and Complexity --- Theory and Applications.
Pearson Prentice Hall, 
Upper Saddle River, NJ
2008.


\bibitem{schaefer}
Schaefer, T. J.: The complexity of satisfiability problems. 
STOC '78: Proceedings of the tenth annual ACM symposium on Theory of computing, May 1978, pp.\ 216--226, \url{https://doi.org/10.1145/800133.804350}

\bibitem{sperner}
Sperner, E.: Ein Satz \''uber Untermengen einer endlichen Menge. Math. Z \tbf{27}, 544--548 (1928). \href{https://doi.org/10.1007/BF01171114}{DOI 10.1007/BF01171114}

\bibitem{strietz75}
H. Strietz: Finite partition lattices are four-generated. Proc. Lattice Theory Conf. Ulm, 1975, pp. 257--259.

\bibitem{strietz77}
H. Strietz: \"Uber Erzeugendenmengen endlicher Partitionverb\"ande. Studia Sci. Math. Hungarica 12 (1977), 1--17.

\bibitem{takach}
G. Tak\'ach:
Three-generated quasiorder lattices. Discuss. Math. Algebra Stochastic
Methods 16 (1996) 81--98.

\bibitem{totik}
 Totik, V.: Oral communication, somewhen in the nineties.


\bibitem{wang}
Wang, J.: Average-case computational complexity theory.
In: Hemaspaandra and
Selmen (eds.), Complexity Theory Retrospective II, Springer-Verlag, 1997, pages 295--328.  %(his site)
\href{https://www.cs.uml.edu/~wang/acc-forum/avgcomp.pdf}{click her for download}


\bibitem{zadori}
L. Z\'adori:  Generation of finite partition lattices. Lectures in universal algebra (Proc. Colloq. Szeged, 1983), Colloq. Math. Soc. J\'anos Bolyai, Vol. 43, North-Holland, Amsterdam, 1986, pp. 573--586.


\end{thebibliography}

\end{document}





