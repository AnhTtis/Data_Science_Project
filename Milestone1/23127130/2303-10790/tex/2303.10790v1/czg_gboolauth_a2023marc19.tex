%%G. Czedli 2023
\documentclass[reqno]{amsart}
\newcommand \datum {March 19, 2023}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\Boo[1]{\mathsf B_{#1}}
\newcommand\At[1]{\textup{At}(#1)}
\newcommand\Sp[1]{\textup{Sp}(#1)}
\newcommand\LASp[1]{\textup{LASp}(#1)}
\newcommand\Prot {\textup{Prot}}
\newcommand\sProt {{^\ast\textup{Prot}}}
\newcommand\Strat {\textup{Strat}}
\newcommand\ciph[1] {\textup{ciph}(#1)}
%\newcommand\lint[1]{\lfloor #1\rfloor_{\textup{int}}}
\newcommand\lint[1]{\lfloor #1\rfloor}
\newcommand\FS [1] {\textup{FS}_\wedge(#1)}
\newcommand\FL [1] {\textup{FL}(#1)}
\newcommand \Alg   {\mathcal A}
\newcommand \Aslg  {\mathcal A^\star}
\newcommand \Blg   {\mathcal B}
\newcommand \Bslg  {\mathcal B^\ast}
\newcommand \svec [1] {\vec{#1}\kern1.5pt}
\newcommand \pvec [1] {\vec{#1}\kern1.5pt'}
%\newcommand \kepk{{\includegraphics[scale=0.34]{kati2018aug14-85-final}}}
%\newcommand \kbank{{\includegraphics[scale=0.32]{bankb}}}
\newcommand \katibank{{\includegraphics[scale=0.25]{kati-bank}}}

\newcommand \woman {Kati}
\newcommand \nothing[1] {}

%\newcommand \oc [1] {#1^\circ}


\usepackage{amssymb,latexsym}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}

\usepackage[dvipsnames]{xcolor}
\usepackage{enumerate}
\numberwithin{equation}{section}
\theoremstyle{plain}
 \newtheorem{theorem}{Theorem}[section]
  \newtheorem*{theoremn}{Theorem}
 \newtheorem{lemma}[theorem]{Lemma}
 \newtheorem{proposition}[theorem]{Proposition}
 \newtheorem{note}[theorem]{Note}
 \newtheorem{observation}[theorem]{Observation} 
 \newtheorem{fact}[theorem]{Fact}
 \newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
 \newtheorem{definition}[theorem]{Definition}
 \newtheorem{nextpart}{Part (of the proof)}
 \newtheorem{example}[theorem]{Example}
 \newtheorem{remark}[theorem]{Remark}
\theoremstyle{remark}
%\newenvironment{enumeratei}{\begin{enumerate}[\upshape (i)]}%
%                            {\end{enumerate}}   %produces (i), (ii), etc. Cross-reference with \eqref.


\newcommand\Quo[1]{\textup{Quo}(#1)}
\newcommand\Equ[1]{\textup{Equ}(#1)}
\newcommand \filter[1]{\mathord\uparrow\kern0.5pt  #1}
\newcommand \pfilter[1] {\mathord\uparrow_{\kern-1.0pt #1}\kern0.5pt}
\newcommand \FD [1] {\textup{FD}(#1)}
\renewcommand \phi{\varphi}
\newcommand \Nnul {\mathbb N_0}
\newcommand \Nplu {\mathbb N^+}
\newcommand \ideal {\mathord\downarrow\kern0.5pt }
\newcommand \then {\Rightarrow}
\newcommand \tuple [1] {(#1)}
\newcommand \pair [2] {\tuple{#1,#2}}
\newcommand{\tbf}{\textbf}% text bold
\newcommand{\set}[1]{\{#1\}}% set 
\newcommand \red[1]{{\textcolor{red}{#1}\color{black}}}
\newcommand \black[1]{{\textcolor{black}#1}}
\newcommand \magenta [1] {{\color{magenta}#1\color{black}}}
\newcommand \lightgreen [1] {{\color{green!85!magenta}#1}}
\newcommand \green [1] {{\color{green!65!blue}#1\color{black}}}
\newcommand \mrk {{\red{$\clubsuit\clubsuit\clubsuit$ }}}


 
\begin{document}



\title[Authentication and generating Boolean lattices]
{Generating Boolean lattices by few elements and  a protocol for authentication and cryptography based on an NP-complete problem}



%{Generating Boolean lattices by few elements and a related  cryptographic authentication based on an NP-complete problem}

%{The minimum size of a generating set of a Boolean lattice and an authentication and cryptographic protocol based on an NP-complete problem}
%{Minimum-sized generating sets of finite Boolean lattices and an NP-safe authentication and cryptographic protocol based on these lattices}
%{Small generating sets of some large filters of quasiorder lattices}


\author[G.\ Cz\'edli]{G\'abor Cz\'edli}
\email{czedli@math.u-szeged.hu}
\urladdr{http://www.math.u-szeged.hu/~czedli/}
\address{University of Szeged, Bolyai Institute. 
Szeged, Aradi v\'ertan\'uk tere 1, HUNGARY 6720}


\begin{abstract} 
Let $\Sp k$ denote the number of the $\lint{k/2}$-element subsets of a finite $k$-element set. We prove that the least size of a generating subset of the Boolean lattice with $n$ atoms (or the powerset lattice of an $n$-element set) is the least number $k$ such that $n\leq \Sp k$. Based on this fact, we present a secret key protocol for authentication and cryptography, and we prove that the underlying mathematical problem is NP-hard. Finally, as an easy observation, we present a subclass of (the NP-complete) 3\kern0.2pt SAT that is still NP-complete.
\end{abstract}

\thanks{This research was supported by the National Research, Development and Innovation Fund of Hungary, under funding scheme K 138892.}

\subjclass {Primary: 06D99. Secondary: 94A62, 94A60, 68Q25}

% 06D (1980-now) Distributive lattices
% 06D99 (1980-now) None of the above, but in this section

% 94A60 (1980-now) Cryptography [See also 11T71, 14G50, 68P25, 81P94]

% 94A62 (2000-now) Authentication, digital signatures and secret sharing

% 68 (1940-now) Computer science 
% 68Q25 (1980-now) Analysis of algorithms and problem complexity




\keywords{Boolean lattice, generating set, cryptography, smallest generating set, NP-complete, authentication, Vernam cipher.
 \hfill{\red{\tbf{\datum}}}}



\maketitle    

\section{Introduction}
Our goal is to prove Theorems \ref{thm:nleqSpk} and \ref{thmNP}. This paper targets a larger
readership than my lattice theoretic papers in general. Indeed,  those familiar with the concept of a Boolean lattice and that of NP-completeness should find no difficulty in reading the results of the subsequent sections\footnote{but not necessarily the subsequent paragraphs of the current section}.  For reading the proof presented in Section \ref{sec:genBoole}, only a minimal knowledge of lattice theory\footnote{A \emph{lattice} is an algebra $(L;\vee,\wedge)$ and it is also a  poset $(L;\leq)$ in which the two-element subsets have suprema and infima. This paper has nothing to do with ``lattice-based cryptography''.} or universal algebra is required.  
Therefore, there is no concept to introduce at the beginning of the paper. However, the story below could be interesting as it exemplifies how a series of abstract investigations (involving accessible cardinals and infinite quasiorder lattices, which are interesting only for few lattice theorists) can lead to something that could be interesting outside lattice theory and (hopefully) even outside mathematics.

In my perspective, the story started with Z\'adori \cite{zadori}, who improved one of the results in Strietz \cite{strietz75}--\cite{strietz77} and, more importantly for the present topic, gave a new proof of Strietz's result asserting that the lattice $\Equ A$ of all equivalences of a finite set $A$ with size at least 3  has a 4-element generating set. So, to say this result in a concise way, $\Equ A$ is 4-generated. 
In the next step, based on Z\'adori's method, Chajda and Cz\'edli \cite{chajdaczg} proved that the lattice $\Quo A$ of all quasiorders (AKA preorders) of the same set $A$ is 6-generated, in fact, it is 3-generated if we add the unary operation
$\rho\mapsto \rho^{-1}=\set{(y,x): (x,y)\in \rho}$
of forming inverses to the set $\set{\vee,\wedge}$ of lattice operations. But what is more interesting in the 1996 paper \cite{chajdaczg} is that, as opposed to the case of equivalence lattices, even the very first version of the proof for $\Quo A$ did not use the finiteness of $A$ and worked for $|A|=\aleph_0$. (Of course, for an infinite $A$, we consider $\Equ A$ and $\Quo A$ \emph{complete} lattices.) 
Finally, the very first proof, which was very similar to Z\'adori's method, became more involved and the scope of \cite{chajdaczg} included every set $A$ such that $|A|$ is smaller than some member of the sequence $\kappa_0:=\aleph_0$, $\kappa_1:=2^{\kappa_0}$, $\kappa_2:=2^{\kappa_1}$, $\kappa_3:=2^{\kappa_2}$, \dots \ (the sequence is of order type $\omega$, so it is countable).  The experience with quasiorders in \cite{chajdaczg}  showed the way 
\begin{equation}
\text{how to overstep the border between finite sets and infinite sets,}
\label{eq:hsbDbrthxLsmdyfW}
\end{equation}
and we could show in Cz\'edli \cite{CzGEateq} in 1996 the 4-generability of $\Equ A$ for $|A|=\aleph_0$. Still in the nineties, Cz\'edli \cite{CzGEq4,czgeek} and Tak\'ach \cite{takach} proved that if $A$ is an infinite set and there is no inaccessible cardinal $\lambda$ such that $\lambda\leq |A|$, then $\Equ A$ is 4-generated, 
it has even a four-element non-antichain  generating set, and $\Quo A$ is 6-generated (and 3-generated if forming inverses is allowed). Although we knew from Kuratowsky \cite{kuratowski}, see also Levy \cite{levy}, that ZFC has a model in which there is no inaccessible cardinal at all, there was an unsuccessful tedious attempt to remove the assumption that no inaccessible $\lambda$ exists. 
Then I met Vilmos Totik in the Bolyai Institute, and after outlining the set theoretical feature of our method, he pointed out (in a minute or so) that this method cannot work for all cardinal numbers, and he immediately proved his statement. Having no other method at hand, the research of small generating sets of $\Equ A$ and $\Quo A$ for $A$ of arbitrary (even inaccessible)  
cardinals stopped for a while with Cz\'edli \cite{czgeek} in 1999.  

The research started again in 2015, when Dolgos \cite{dolgos}, one of Mikl\'os Mar\'oti's students, proved that $\Quo A$ is 5-generated for $|A|\leq \aleph_0$, and  Kulin \cite{kulin} extended this result to all sets $|A|$ such that there is no inaccessible cardinal $\lambda\leq |A|$. Not much later, Cz\'edli \cite{czg2017fourgen} and Cz\'edli and Kulin \cite{czgkulin} reduced the number of generators, so we learned that for all set $A$ such that 
$|A|\neq 4$ and there is no inaccessible cardinal $\lambda\leq |A|$,  the complete lattice $\Quo A$ is 4-generated. The case $|A|=4$ is still open but the result was optimal for many other sets, as \cite{czg2017fourgen} proved that $\Quo A$ is not 3-generated if $|A|\geq 3$. 
Finding 4-element generating sets that are not antichains is more difficult but, after the early results of Strietz \cite{strietz75}--\cite{strietz75} and Z\'adori \cite{zadori}, some sporadic cases were settled not long ago (in 2020--2021) in  Ahmed and Cz\'edli \cite{delbrinczg} and Cz\'edli and Oluoch \cite{czgoluoch}.

In 2020, a progress opposite to \eqref{eq:hsbDbrthxLsmdyfW} happened. It appeared that the technique developed for infinite sets is appropriate to show that even some direct powers and products of some finite equivalence lattices are 4-generated and (consequently) $\Equ A$ and $\Quo A$ have very many 4-element generating sets if $|A|$ is a large finite number; see Cz\'edli \cite{czgdaugthent} and Cz\'edli and Oluoch  \cite{czgoluoch}. 
As a side effect of the papers written in the nineties and cited in this section, there came to existence a dream: ``if there are enough complications in proving a result by construction, then we might benefit from these complications in cryptography''. Due to this dream and the abundance of the generating sets found in the just mentioned two papers, 
 Cz\'edli \cite{czgdaugthent} in 2021 suggested a protocol for authentication and cryptography based on lattices. 

Quite recently, looking for small generating sets of some filters of quasiorder lattices in Cz\'edli \cite{czgfiltQuo}, a proof required to know the smallest size of a generating set of a finite Boolean lattice; this was the motivation for Section \ref{sec:genBoole} of the present paper. It appeared  that even though not as few as 4, large finite Boolean lattices can be generated by surprisingly few elements. Then we started to apply the 2021 cryptographic protocol from \cite{czgdaugthent} to Boolean lattices; with not much optimism at the beginning, to tell the truth. And then another surprise came: as opposed to the 2021 paper, where complicated lattices were used and no proof accompanied the heuristic ideas why the protocol was reasonable, we can \emph{prove} that the protocol (practically the same protocol but now with Boolean lattices) is based on an NP-hard problem. 

The protocol and the just-mentioned proof are given in Sections \ref{sect:ACprtcl} and \ref{sect:NPh}. Section \ref{sect:prrslt} shows that there are plenty of secret keys for the protocol; the corresponding computer program is given in the Appendix (Section \ref{sect:appDx}). 
Section \ref{sect:NPh} proves that this protocol is based on an NP-hard (in fact, on an NP-complete) problem.
Section \ref{sect:3SAT} is quite short and, for 3SAT, it contains an immediate consequence of Section \ref{sect:NPh}. Note at this point that I am not an expert of Complexity Theory, so the reader may find Sections \ref{sect:NPh} and \ref{sect:3SAT} too detailed. 

Although the present protocol uses finite Boolean lattices, which are very simple structures, and we prove that it is based on an NP-hard problem, we cannot prove (in the time of writing) the same for the 2021 protocol. 
However, the present paper increases our belief that the more involved lattices in  \cite{czgdaugthent} are also good for authentication and cryptography.





\section{Small generating sets of finite Boolean  lattices}\label{sec:genBoole}
For $\Nplu=\set{1,2,3,\dots}$, let 
$\Boo n$ denote the Boolean lattice with $n$ atoms. It consists of $2^n$ many elements. 
For an element $u$ of a lattice $L$, we use the standard notation $\ideal u$ and $\filter u$ for $\set{x\in L: x\leq u}$ and $\set{x\in L: x\geq u}$, respectively. As   $(\Nplu;\leq)$ is also a lattice,   $\ideal n$ for $n\in \Nplu$ will mean $\set{1,2,\dots, n}$.
Note that $\Boo n$ is isomorphic to the powerset lattice $P(\ideal n)=(P(\ideal n);\subseteq)$. 
A subset $Y$ of $\Boo n$ is a \emph{generating set} of $\Boo n$ if the only sublattice of $\Boo n$ that includes $Y$ is $\Boo n$ itself.
Denote the (lower) integer part of $x\in\mathbb R$ by $\lint x$, and let
\begin{equation}
\Sp n:={{n}\choose{\lint{n/2}}}
\end{equation}
%
\begin{equation}\left.
\begin{aligned}
\text{for example, }\Sp{22}= 705\,432\text{ \ }\Sp{23}=1\,352\,078 \cr
\Sp{32}= 601\,080\,390, \text{ \ and \ }\Sp{33}=  1\,166\,803\,110.
\end{aligned}\quad\right\}
\label{eq:nLmgpGNkw}
\end{equation}
%
For $n\in\Nplu$, let $\LASp n$ be the smallest $k\in\Nplu$ such that $n\leq \Sp k$.
Note the rule: $n\leq \Sp k \iff \LASp n\leq k$; this explains the acronym, which comes from ``Left Adjoint of Sp". (The notation $\Sp$ comes from ``Sperner''; see later.)

\begin{theorem}\label{thm:nleqSpk}
For $n,k\in\Nplu$, $\Boo n$ has an at most $k$-element generating set if and only if $n\leq \Sp k$ or, equivalently,  if and only if $\,\LASp n\leq k$. 
\end{theorem}

For example, this theorem together with \eqref{eq:nLmgpGNkw} give that $\Boo{1\,000\,000}$ is $23$-generated but not $22$-generated; similarly, $\Boo{1\,000\,000\,000}$ is $33$-generated but not $32$-generated. 


\begin{proof} Let $\At{\Boo n}$ be the set of atoms of $\Boo n$. 
First, we show that
\begin{equation}
\text{for any generating set }Y\text{ of }\Boo n\text{ and for  }\forall a\in\At{\Boo n}\text{, }a=\bigwedge (Y\cap\filter a). 
\label{eq:ktNrMxtlgRn}
\end{equation}
We can write that $Y=\set{b_1,\dots,b_m}$. As $Y$ generates $\Boo n$,
 there is an $m$-ary lattice term $t$ such that $a=t(b_1,\dots,b_m)$. 
By distributivity, we can assume that $t$ is of a disjunctive normal form, that is, $a$ the join of meets of elements of $Y$. But $a$ is join-irreducible, whereby it is the meet of some elements of $Y$. Let us add  all elements of $Y\cap\filter a$ to this meet as (possibly extra) meetands, this does not destroy anything. Thus, we conclude \eqref{eq:ktNrMxtlgRn}. 

Next, to settle the ``only if'' part of the theorem, we need to prove that for any subset $G$ of $\Boo n$,
\begin{equation}
\text{if $G$ generates $\Boo n$ and $k=|G|$,  then $n\leq \Sp k$.}
\label{eq:BrmpCtznnmKf}
\end{equation}
To show this, let $X$ be a $k$-element set and take the free meet-semilattice $\FS X$ freely generated by $X$. Denote by $M$ the meet-subsemilattice $(\Boo n;\wedge)$ generated by $G$. Take a bijective map $f_0\colon X\to G$. 
The freeness of $\FS X$ allows us to extend $f_0$ to a meet-homomorphism $f\colon\FS X\to M$, which is surjective since $f(X)=G$ generates $M$.  By \eqref{eq:ktNrMxtlgRn}, $\At{\Boo n}\subseteq M$. This together with the surjectivity of $f$ allow us to take an injective map $h\colon\At{\Boo n}\to \FS X$ such that, for all $a\in A$,  $f(g(a))=a$.  If we had that $g(a)\leq g(a')$ for distinct $a,a'\in \At{\Boo n}$, then $g(a)=g(a)\wedge g(a')$ would lead to $a=f(g(a))=f(g(a)\wedge g(a'))= f(g(a))\wedge f(g(a'))=a\wedge a'$, yielding that $a\leq a'$ and contradicting that $a$ and $a'$ are distinct atoms of $\Boo n$. 
%
Therefore $g(a)\parallel g(a')$, that is, $g(\At{\Boo n})$ is an $n$-element antichain in $\FS X$. 
Adding a top element to $\FS X$, we obtain another semilattice,  $\set{1}\cup\FS X$.
We know from the folklore or from McKenzie, McNulty, and Taylor \cite[Page 240, \S4]{mcKmcNT} that $\set{1}\cup\FS X$  is order isomorphic to $\Boo{|X|}=\Boo k$.
So $\Boo k$ has an $n$-element antichain. By Sperner's theorem \cite{sperner}, see also Gr\"atzer \cite[half a page after Thm.\ 401 in p.\ 354]{r:Gr-LTFound}, 
 any antichain in $\Boo k$ has at most $\Sp k$ elements,  implying  \eqref{eq:BrmpCtznnmKf} and the ``only if'' part of the theorem.



Observe that 
\begin{equation}\left.
\parbox{10.6cm}{for any $m\leq n\in\Nplu$,  $\Boo m$ is a homomorphic image of $\Boo n$. Therefore, if $\Boo n$ has an at most $k$-element generating set, then so is $\Boo m$.}\,\,\right\}
\label{eq:wPsrTwgftjG}
\end{equation}
It suffices to show only the first part and only for $m=n-1$. Let 
$a\in \At{\Boo n}$. Then $\filter a\cong \Boo m$. The function $f\colon\At{\Boo n}\to \filter a$  defined by $x\mapsto a\vee x$ is surjective as it is a retraction, and it is a homomorphism by distributivity. Hence, we conclude \eqref{eq:wPsrTwgftjG}.


Next, to show the ``if'' part of the theorem, assume that $n\leq \Sp k$; we are going to show that $\Boo n$ has an at most $k$-element generating set. We can assume that $k\leq n$. 
Based on \eqref{eq:wPsrTwgftjG} and $k\leq \Sp k$,  it suffices to show that $\Boo{\Sp k}$ has an at most $k$-element generating set.  To ease the notation, we can assume that $n=\Sp k$; so we are looking for a $k$-element generating set of $\Boo n$.  Let $A:=\At{\Boo k}$ (the subscript is $k$, not $n$).
As $\Boo k$ is isomorphic to the powerset lattice $(P(\set{1,\dots,k});\cup,\cap)$ and the $\lint{k/2}$-element subsets of $\set{1,\dots,k}$ form an $n=\Sp k$-element antichain in $(P(\set{1,\dots,k});\cup,\cap)$, it follows that $\Boo k$ has an $n$-element antichain $H$. %=\set{h_1,\dots,h_n}$. 
As $(P(H);\cup,\cap)\cong \Boo n$, 
it suffices to find a $k$-element generating set of the powerset lattice $P(H)=(P(H);\cup,\cap)$. 
For each $a\in A=\At{\Boo k}$, we let $X_a:=H\cap\filter a$. Then $X_a\in P(H)$ and $G:=\set{X_a: a\in A}$ is an at most $k$-element\footnote{Actually, $|G|=k$, but we neither show nor use this equality.} subset of $P(H)$.  We are going to show that $G$ generates the powerset lattice $P(H)$. As the set of singleton sets $\set h$ ($h\in H$) clearly generates $P(H)$, it suffices to show that for every $h\in H$, 
\begin{equation}
\set{h}=\bigcap\set{X_a: a\in A\cap \ideal h}.
\label{eq:rZmszltpLrnts}
\end{equation}
For every $a\in A\cap \ideal h$, we have that $h\in H\cap\filter a=X_a$, which shows the ``$\subseteq$'' part of \eqref{eq:rZmszltpLrnts}. 
%
Now assume that $h'\in H$ belongs to the intersection in \eqref{eq:rZmszltpLrnts}. Then $h'\in X_a$ for every atom $a\in A$ such that $a\leq h$.
Writing this in a more useful way, 
\begin{equation*}
(\forall a\in A)\,\,\bigl( a\leq h \then a\leq h'\bigr)\text{, that is, } A\cap\ideal h\subseteq A\cap\ideal {h'}.
%\label{eq:mhszkVkkBldP}
\end{equation*}
Hence, using that each element of $\Boo k$ is the join of all atoms below it, we have that $h=\bigvee(A\cap\ideal h)\leq \bigvee(A\cap\ideal{h'})=h'$. But $h$ and $h'$ belong to the antichain $H$, whereby their comparability gives that $h'=h\in\set{h}$, showing the ``$\supseteq$'' part of \eqref{eq:rZmszltpLrnts}. Therefore, \eqref{eq:rZmszltpLrnts} and the ``if'' part of the theorem hold.
%
The proof of Theorem \ref{thm:nleqSpk} is complete.
\end{proof}



\begin{corollary} If $2\leq k\in \Nplu$ and $n \leq \Sp k$, then the free distributive lattice $\FD k$ has a sublattice isomorphic to $\Boo n$.
\end{corollary}

\begin{proof} As $\Boo m$ is a sublattice of $\Boo n$ for any $m\leq n$, we can assume that $n=\Sp k$. It follows from Theorem \ref{thm:nleqSpk} that we can pick a surjective homomorphism $f\colon\FD k\to \Boo n$. We know from Balbes \cite[Theorem 7.1(i),(iii')]{balbes} that $\Boo n$ is projective in the class of all distributive lattices. Let $h\colon \Boo n\to\Boo n$ be the identity map (defined by $x\mapsto x$ for $x\in\Boo n$). Then, complying with the notation used in 
Balbes \cite[Definition 2.3]{balbes}, the projectivity of $\Boo n$ yields a homomorphism $g\colon \Boo n\to \FD k$ such that\footnote{We compose functions from right to left, that is, $(f g)(x)=f(g(x))$.} $f g=h$. Since the product $h$ is injective, so is $g$. Thus, $g\colon \Boo n\to \FD k$ is an embedding and $g(\Boo n)$ is a required sublattice of $\FD k$. 
\end{proof}




\section{A protocol for authentication and cryptography based on Boolean lattices}\label{sect:ACprtcl}
First, note that the protocol we are going to desribe here will be slightly improved in Section \ref{sect:retro}.

Next, we recall some elementary facts and terminology from the folklore. Authentication will mean proving the sender's identity to the receiver in communication. 
For example, when  \woman{}{\footnote{``\woman{}'' is the  Hungarian variant of ``Cathy'' or ``Kate''.}} gives an instruction like  "transfer 1000 Euros from \woman{}'s account to  X.Y.'s account" online, then 
authentication is necessary to exclude that
an Adversary intercepts the message, changes "X.Y.'s account" to "the Adversary's account", and then pretending to be \woman{}, sends the corrupted message to the Bank.
There are various protocols for authentication in practice and in the vast literature on (mathematical) \emph{public key}  cryptography.

However, \emph{secret key} cryptography is still important, especially when authentication is of high importance. While a public key protocol is good only to convince the receiver that the second, third, etc. messages are sent by the same sender as the first one, the sender can remain anonymous (by using a false name). In several situations, public keys can even allow that right at the first message (and then at all the subsequent ones) an Adversary takes over \woman{}'s role.  Turning our attention to banks again, note that banks in many countries, including Hungary, do not allow anonymous clients, whereby \woman{} has to visit the Bank before any banking. 
At this first visit, \woman{} and the Bank agree upon a \emph{secret key} that only \woman{} and the Bank will know. Later on, they use this secret key for authentication. There are known methods in the practice like using two independent channels, using a temporary random key together with the secret key at each time, etc.\ to protect the communication between \woman{} and the Bank. 

Some authentication protocols used in the practice have disadvantages. (For example, the Adversary can intercept both of the independent channels.) Here we only deal with the model in which
there is only a single channel; typically, 
the whole communication happens online, via the Internet.   Furthermore, the secret key can be used many times in our model in spite the presence of an Adversary in the cyberspace. We assume that the Adversary  intercepts all messages, he tries to extract the secret key from these messages, and even without acquiring the secret key, he does his best to cause harm to \woman{} by modifying the messages that \woman{} sends or receives and sending additional forged messages. However, we exclude that the Adversary intrudes into computers to deploy any virus for phishing or other  malicious activities.%
\footnote{\label{foot:mlCshCk}That is, the Bank and \woman{}'s computers are well protected from the Adversary and they remain intact; they are ``black boxes'' for the Adversary.}. 

Next, we  present a secret key protocol for authentication and cryptography that complies with the guidelines above; in particular, the key can be used many times. Apart from straightforward changes that come from the fact that now we deal only with Boolean lattices rather than with equivalence lattices (which are the same as partition lattices up to isomorphism), the following definition is taken from \cite{czgDEBRauth}.


\begin{definition}[Cz\'edli \cite{czgDEBRauth}]\label{def:protcol} 
Here we define a protocol 
\begin{equation}
\Prot=\Prot(n,k,\vec h,b,\Strat,v)
\label{eq:wDPrthr}
\end{equation}
for authentication and cryptography as follows. Pick an $n\in\Nplu$ like $n=1000$ or some integer of a similar magnitude. Let $k\in \Nplu$ such that $\LASp n<k$; for example, let $k=50>\LASp{1000}=13$ or let it be of a similar magnitude. Unless $n$ is very small, which is not recommended, we can take a $k$ that is much less than $n$; see Section \ref{sect:prrslt}. Pick a vector $\vec h=(h_1,\dots,h_k)$ such that $H = H(\vec h):=\set{h_1,\dots,h_k}$ is a  generating set
of $\Boo n$; we will point out in Remark \ref{rem:mggrDszGrjtvcf} and Section \ref{sect:prrslt} that there are many ways to obtain such an $\vec h$.
Pick a strategy $\Strat$ of selecting a ``not too simple'' $k$-ary lattice term randomly. Pick a small number $v\in \Nplu$ (we recommend that $v\in\set{1,2,\dots,8}$) and a multiple $b\in\Nplu$ of $v$ such that $b\geq 2$ and, say, $b\leq 200$. We call $b$ and $v$ the \emph{block length} and the \emph{Vernam parameter}\footnote{We name this parameter after Vernam as we will use it when the Vernam cipher is applied.}. The Vernam parameter is needed only for sending messages but not for authentication. The variant 
\begin{equation}
\Prot^-:=\Prot(n,k,\vec h,-,\Strat;v)
\label{eq:mMztmPrt}
\end{equation}
also makes sense. It means that whenever a message is sent, then the  block length $b\geq 2$, which is still a multiple of $v$, is tailored to the length of the message.

Now the secret key that \woman{} and the Bank share is $\vec h$; the rest of the ingredients of $\Prot$ or $\Prot^-$, see \eqref{eq:wDPrthr} and \eqref{eq:mMztmPrt}, are known for the Adversary. 

The fact that $\Boo n$ is the $n$-th direct power of the two-element lattice $\Boo 1=\set{0,1}$ allows us to assume that $\Boo n$ consists of $n$-dimensional bit vectors. (Alternatively, we can work with the powerset lattice $P(A)$ of the $n$-element set $A=\At{\Boo n}$ as we know that $P(A)\cong\Boo n$, and the elements of $P(A)$ are naturally stored in our computers as $n$-dimensional bit vectors.)
So all computations with lattice elements are  performed for these bit vectors belonging to $\set{0,1}^n$. 

In case of \emph{authentication}, whenever \woman{} wants to prove her identity to the Bank according to $\Prot$, then 
\woman{} requests a random vector $\vec p=(p_1,\dots,p_b)$ of $k$-ary lattice terms from the Bank. Then 
\begin{equation}
\begin{aligned}
\katibank
\end{aligned}
\label{eq:lrJgfncNpZnkt}
\end{equation}

\nothing{
\begin{equation}
\begin{aligned}
\kepk\kern 3pt
\raisebox{19pt}
{\parbox{7.7cm}{the Bank applies Strat to generate such a random vector $\vec p$, sends $\vec p$ to \woman{},  \woman{} computes  $\vec u:=\vec p(\vec h)=(p_1(\vec h),\dots, p_b(\vec h))$  and sends it to the Bank, and the Bank
checks whether $\vec u$ equals $\vec p(\vec h)$.}}\kern3pt\kbank
\end{aligned}
\label{eq:lrJgfncNpZnkt}
\end{equation} }
It is important that  $\vec p$ above should not have been used previously. 


Next, let $\vec y\in(\set{0,1}^n)^{b/v}$ be a plain (i.e., non-ciphered) text\footnote{As computers store texts as bit vectors, it is not a restriction that $\vec y$ is a bit vector. Adding extra spaces to the end of the text or using $\Prot^-$ rather than $\Prot$ if necessary, we can assume that the total number of bits in $\vec y$ is $n b/v$.} that \woman{} wants to send to the Bank.
Let us write $\vec y$ in the form $\vec y=(\svec y^{1},\svec y^{2},\dots,\svec y^{b/v})$, where each of the $\svec y^{i}$ is a bit vector belonging $\set{0,1}^n=\Boo n$. We define the enciphered message by  
\begin{align}
\ciph{\vec y}:=\Bigl(&p_1(\vec h)+\dots+p_v(\vec h)+\svec y^{(1)},\,\,\, 
p_{v+1}(\vec h)+\dots+p_{2v}(\vec h)+\svec y^{(2)},\,\dots\, ,
\cr
& p_{b-v+1}(\vec h)+\dots+p_b(\vec h)+\svec y^{(1)}\Bigr) \in (\set{0,1}^n)^{b/v}
\label{eq:twStjrgshdmSnD}
\end{align}
 where the addition is 
performed componentwise in the two-element field $\mathbb Z_2=\set{0,1}$ and $\vec p\,$ is a vector formed by $k$ random $n$-ary lattice terms; either \woman{} generates $\vec p$ or she receives it from the Bank. 
Finally,
\begin{equation}\left.
%\begin{aligned}%\raisebox{12pt}\kepkg\,\,%\raisebox{32pt}{\parbox{8.0cm} % 
\parbox{8.0cm} 
{if the Bank generates $\vec p$, then \woman{} sends $\ciph{\vec y}$ to the Bank; otherwise,  she sends the pair $(\vec p, \ciph{\vec y})$.} \,\,\right\}
%\,\,%\includegraphics[scale=0.20]{bank}%\end{aligned}
\label{eq:RszmKlfrptsnP}
\end{equation}
Interchanging their roles, the Bank can send an enciphered message to \woman{} or it can identify itself for \woman{} in the same way.
We have completed Definition \ref{def:protcol}.
\end{definition}



\subsection{Comments, the roles of the parameters, and heuristic considerations}


Let $\FD k$ denote the free distributive lattice on $k$ generators; we note that $|\FD k|\leq 2^{2^k}$; see Kisielewicz \cite{kisz} for  more information, which we do not need here.
Although there are infinitely many $k$-ary lattice terms that determine different term functions in the free lattice  $\FL k$ on $k$ generators,   $k\geq 3$, here we deal only with the \emph{distributive} $\Boo k$. Hence, it suffices to choose $p_1,\dots, p_b$ from an $|\FD k|$-element set of lattice terms. We can even assume (but need not assume at all) that each of 
$p_1,\dots, p_b$ is of a conjunctive normal form or a disjunctive normal form.

The heart of the protocol described in Definition \ref{def:protcol} is that while
we can easily compute  $\vec p(\vec h)$ from $\vec p$ and $\vec h$, it is difficult to compute\footnote
{We do not claim that $\vec p(\vec h)$ and $\vec p$ determine $\vec h$ uniquely. Here and later, ``computing $\vec h$" is understood as ``computing at least one $\vec h$ that satisfies the requirements''.} 
$\vec h$ from $\vec p$ and $\vec p(\vec h)$. 
To enlighten the analogy with cryptographic protocols based on discrete logarithm of base $p$, let us also use the alternative temporary notation $\vec p^{\,\vec h}$ for $\vec p(\vec h)$. Then we obtain $\vec p^{\,\vec h}$ from $\vec p$ and $\vec h$ easily but it is too difficult to compute $\vec h$ from $\vec p$ and  $\vec p^{\,\vec h}$. Actually, this difficulty is at least as big (if not bigger) as computing the discrete logarithm. Indeed, while we do not know whether computing the discrete logarithm is an NP-hard problem, we can prove that computing $\vec h$ from $\vec p$ and $\vec p(\vec h)$ is NP-hard; see Theorem \ref{thmNP} later.

Now we turn our attention to \eqref{eq:lrJgfncNpZnkt}. Without knowing $\vec h$, the Adversary hardly has any better method to obtain $\vec u:=\vec p(\vec h)$ from $\vec p$ than guessing\footnote{Of course, we assume that $\vec p$ has been carefully selected and so it is not too trivial. If, say, $\vec p$ was the meet of all the $k$ variables, then it would induce the constant function and the Adversary's task would be easy.}. The vector $\vec u$ in \eqref{eq:lrJgfncNpZnkt} consists of $b n$ bits\footnote{It consists of $b$ components and these components are $n$-bit vectors, to be more precise.}.
So, since the components of $\vec h$ generate $\Boo n$, there are $2^{b n}$ many possible vectors\footnote{\label{foot:mkSTm}This is where we make use of Theorem \ref{thm:nleqSpk}. Indeed, if Theorem \ref{thm:nleqSpk} and any similar satement failed, then we would need a very large $k$ to ensure that  $\vec p(\vec h)$ takes many values, and the system would be less economic.}.  We stipulate that $b n$ should be large enough; then we can exclude that the Adversary is lucky enough to find the proper $\vec u$ by chance or by listing and trying\footnote{For $b n$ large, this would  not be realistic as the Bank hardly allows too many trials.} all the $2^{b n}$ vectors. (This is practically impossible if  $n=1000$ and $b\geq2$.) So the Adversary cannot rely on guessing.



Thus, with referenc to Footnote \ref{foot:mlCshCk}, there seems to be only one possibility how the protocol can be broken.
Namely, the Adversary has intercepted all or some of the earlier vectors $\vec p$ of lattice terms together with corresponding vectors $\vec p(\vec h)$, see \eqref{eq:lrJgfncNpZnkt}, and he can compute $\vec h$ from the intercepted data. We can assume that he intercepted  only one pair $(\vec p,\vec p(\vec h))$ where $\vec p$ is $b$-dimensional (that is, it has $b$ components), because 
\begin{equation}\left.
\parbox{10.5cm}{
the collection of pairs $(\pvec p,\pvec p(\vec h))$,  $(\pvec p',\pvec p'(\vec h))$,  $(\pvec p'',\pvec p''(\vec h))$, \dots \ with $b'$-, $b''$-, $b'''$- , \dots \ dimensional $\pvec p$, $\pvec p'$, $\pvec p''$, etc.{} is equivalent to having a single pair $(\vec p,\vec p(\vec h))$ with a $(b'+b''+b'''+\dots)$-dimensional $\vec p$.}\,\,\right\}
\label{eq:rltMcdjVsBl}
\end{equation} 

For more about the Adversary's poor chance to acquire $\vec h$, see Theorem \ref{thmNP} later. If the Adversary intercepts a pair $(\vec p,\ciph{\vec y})$, see \eqref{eq:RszmKlfrptsnP}, then unless he guesses\footnote{\label{ftn:lCk}This cannot be excluded since there can be occasions when many people, including the Adversary, send the same $\vec y$ to the Bank; for example, right before the deadline of paying some tax that is the same for many people.} what $\vec y$ is, his chance is even worse. So, 
\begin{equation}\left.
\parbox{6.5cm}{intercepting \eqref{eq:RszmKlfrptsnP} gives no more possibility to the Adversary than intercepting \eqref{eq:lrJgfncNpZnkt}.}\,\,\right\}
\label{eq:ndWbMwhSngrGd}
\end{equation}

Can the Adversary cause harm to \woman{} by intercepting an enciphered message $(\vec p,\ciph{\vec y})$ and send it to the Bank repeatedly? (For example, paying the yearly tax from \woman{}'s account as many times as the balance of her account permits.) Clearly, this cannot happen provided that  either 
\woman{} is not allowed to send the same message again (for example, at least the time up to  milliseconds has to be different)  or the Bank requires that each transaction has to be confirmed according to \eqref{eq:lrJgfncNpZnkt}; remember that the Bank generates a new random $\vec p$ at each case.


Some secret key cryptosystems, including Vernam Cipher, are easily broken if the same secret key is used (many times) repeatedly. The addition in \eqref{eq:twStjrgshdmSnD} indicates that  the Vernam Cipher is included in our system.
Fortunately, \eqref{eq:rltMcdjVsBl}, \eqref{eq:ndWbMwhSngrGd}, and Theorem \ref{thmNP}  imply that our protocol is not vulnerable to repeated use.
In fact, breaking our cryptosystem is NP-hard in a sense\footnote{This means that, from the Adversary's point of view, breaking the worst case is NP-hard. But there is a warning here: we only guess but have not proved that the average case is NP-hard. Furthermore, with very very little probability, there can be lucky cases for the  Adversary.} even if $b=2$, and also for $b>2$.




We have already mentioned that $b n$ should be large. However, the role of $b$ and that of $n$ are quite different. While, in addition to $k$,  the data size of $\vec p(\vec h)$ depends on $b n$, the data size of $\vec p$ depends only on $b$ but not on $n$.
It is reasonable to generate and send not too many random lattice terms. So $b$ should not be too large; even  $b=2$ is sufficient to make the Adversary's job NP-hard.
 

In general, an authentication and cryptographic protocol is not automatically successful just because its underlying problem is NP-hard\footnote{%
For example, it is an issue how to obtain a random term of approximate length $m$.  Polish notation is recommended; for example, 
% TECHNICL EDITOR: do not remove \mathord in the next line!
$\mathord{\vee}x\mathord{\wedge}y z
=x\vee (y\wedge z)$. We can use time-varying weights to select the components of the requested random term. (The weight of a symbol is the probability of selecting it.)   At the beginning, each of $\vee$ and  $\wedge$ has weight $0.5$ while the variables are of weight 0. At early stage, the weights are chosen so that the term should grow (so that the immediate use of the absorbtion laws is excluded). Later, the weights give peference to termination of the process. Even though no exact theoretical argument is available at the time of writing,  experiments with the help of computer will give a reasonable strategy.
}%
. Thus, it would be too 
early to compare our protocol  $\Prot$ or $\Prot^-$ 
to previously known ones. 
At the time of writing (and probably in  many years that will come) we do not know whether NP-hard is really hard (that is, whether NP is different from P).


\begin{remark}\label{rem:dWndktrnglKBnRhb} 
It is highly important that \woman{} should have a very large set of candidate vectors $\vec h$ such that $H(\vec h)$ generates $\Boo n$. Indeed, otherwise the Adversary could try all the possible vectors $\vec h$.  

There is a trivial argument showing that there are very many secret keys $\vec h\in\Boo n^k$ provided that $d:=k-\LASp n$ is not too small.
Indeed, Theorem \ref{thm:nleqSpk} allows us to pick  an $\LASp n$-element generating set $X_0$ of $\Boo n$. (It follows from Sperner \cite{sperner} that there are at most two such sets $X_0$ but we do not need this fact.) There are many ways to pick a $d$-element subset $X_1$ of 
$\Boo n\setminus X_0$. Hence, we obtain many sets $X:=X_0\cup X_1$ and each of them is a $k$-element generating set of $\Boo n$. Each of them can be written in a $k$-dimensional vector in $k!$-many ways. Thus, we obtain very many secret keys $\vec h$.

Out of the many other ways, we mention only the following one. For each $x\in X_0$, pick one of the lattice operations $\vee$ and $\wedge$ and pick a few (like two, three, \dots) elements of $\Boo n$ such the join or meet of these elements is $x$. So these few elements become the joinands or meets of $x$. Doing so for each $x\in X_0$, we obtain joinands and meetands, $k$ elements all together, that clearly generate $\Boo n$. 
\end{remark}

None of the two ways mentioned above is recommended. Indeed, if we went after Remark \ref{rem:dWndktrnglKBnRhb}, then the proof of Theorem \ref{thmNP} would collapse and the Adversary might benefit from this. Fortunately, the following remark is more useful.

\begin{remark}\label{rem:mggrDszGrjtvcf}
In case of reasonably chosen parameters $n$ and $k$, not only the number of suitable secret keys $\vec h$ is large but even the 
probability that the components of a randomly selected vector $\vec h\in \Boo n^k$ generate $\Boo n$ is reasonably high. 
Furthermore, based on the necessary condition \eqref{eq:ktNrMxtlgRn}, which is trivially also a sufficient condition, we decide quite rapidly in $O(n^2k)$ steps whether the components of $\vec h$ generate $\Boo n$ or not. Therefore, after few random  trials, we find an appropriate key secret $\vec h$.
\end{remark}


\section{Computer-assisted evidence}\label{sect:prrslt}
In connection with Remark \ref{rem:dWndktrnglKBnRhb}, now we use a computer program to verify that yes, there are many candidate keys $\vec h$ and a suitable algorithm to pick one.
Actually, we have two computer programs for this purpose; both are available at the author's website. The simpler (but about eight times slower) one of them is given in (the Appendix) Section \ref{sect:appDx}.
Both programs, BooGnFtr and  BooGenEZ,  implement the trivial algorithm based on the sufficient and necessary condition \eqref{eq:ktNrMxtlgRn}.  

\nothing{
Although there are no mathematical  differences among the three programs, called BooGnFtr, BooGenFt, and BooGenEZ, 
their performances are different. 
Using that $\Boo n\cong \Boo 2^n=\set{0,1}^n$, each of the three programs use a $k$-by-$n$ bitmatrix  $H$ to store the $k$ compontents of the required $\vec h$; these components belong to  $\Boo n$. BooGenEZ is the easiest to understand but it is the slowest out of the three programs. The random number generator, which is built in Pascal, uses Mersenne primes and is slow. As a random number consists of several random bits, it is not economic to generate a new random number for each bit separately. Therefore, BooGenFt  uses random bytes, that is, each call of the random number generator produces eight random bits. As a result, BooGenFt is somewhat faster but not significantly more complicated than  BooGenEZ. 
(A note on the name of the programs: in BooGn\raisebox{2pt}{Ftr}, BooGen\raisebox{2pt}{Ft}, and BooGen\raisebox{2pt}{EZ} the raised letters  come from \raisebox{-2pt}Fas\raisebox{-2pt}te\raisebox{-2pt}r, \raisebox{-2pt}Fas\raisebox{-2pt}t, and \raisebox{-2pt}Ea\raisebox{-2pt}Sy.) 
BooGnFtr goes even further: in addition to generate random bytes rathern than random bits, BooGnFtr applies the logical connectives ``and'', ``or'' and ``not'' to bytes rather than to bits. In this way, BooGnFtr performs eight bit operations by just one byte operation. As a result,  BooGnFtr is about eight times faster than BooGenFt and about 8.4 times faster than BooGenEZ, provided $n$ and $k$ are large like $n=1000$ and $k=50$.  (For small $n$ and $k$ like $n=8$ and $k=6$, the complicatedness of BooGnFtr makes it slower than the other two programs.)
}
  
Note that our programs can easily be modified to print the secret keys that they find into text files. Better program languages could lead to somewhat faster programs but this task was neither targeted nor the author is skilled enough for it.

We applied our programs, almost always the fastest one, for several values of $n$ and $k$. 
At each occasion, the program in question tested one  hundred thousand random vectors $\vec h$ of $\Boo n^k$. In the list below, the number of those $\vec h$ that generate $\Boo n$  occur right after ``Generating:''. The list contains the time the program used for computation. For example, 
while  BooGnFtr used 1305.780 seconds (about 22 minutes) to test one hundred thousand vectors $\vec h\in \Boo{1000}^{50}$ and $59\,003$ out of these vectors (about 53 percent of all vectors) generated $\Boo{1000}$, 
the same task for BooGenEZ  took
10965.266 seconds (approximately 183 minutes).

{\footnotesize 
\begin{verbatim}
n=200 k=30 Tested:100000 Generating:  721; BooGnFtr used       65.594 seconds.
n=200 k=40 Tested:100000 Generating:69274; BooGnFtr used      115.380 seconds.
n=200 k=50 Tested:100000 Generating:97751; BooGnFtr used      151.398 seconds.
n=200 k=50 Tested:100000 Generating:97775; BooGenEZ used      630.650 seconds.

n=400 k=30 Tested:100000 Generating:0;     BooGnFtr used      124.538 seconds.
n=400 k=40 Tested:100000 Generating:25262; BooGnFtr used      242.555 seconds.
n=400 k=45 Tested:100000 Generating:69944; BooGnFtr used      323.834 seconds.
n=400 k=50 Tested:100000 Generating:91710; BooGnFtr used      385.859 seconds.
n=400 k=60 Tested:100000 Generating:99475; BooGnFtr used      462.323 seconds.

n=600 k=30 Tested:100000 Generating:    0; BooGnFtr used      184.144 seconds.
n=600 k=40 Tested:100000 Generating: 5352; BooGnFtr used      350.053 seconds.
n=600 k=46 Tested:100000 Generating:55556; BooGnFtr used      576.888 seconds.
n=600 k=50 Tested:100000 Generating:82547; BooGnFtr used      696.786 seconds.
n=600 k=60 Tested:100000 Generating:98879; BooGnFtr used      861.497 seconds.

n=800 k=30 Tested:100000 Generating:     0; BooGnFtr used      229.103 seconds.
n=800 k=40 Tested:100000 Generating:   691; BooGnFtr used      419.691 seconds
n=800 k=50 Tested:100000 Generating: 70923; BooGnFtr used     1000.597 seconds.
n=800 k=60 Tested:100000 Generating: 97995; BooGnFtr used     1387.090 seconds.
n=800 k=70 Tested:100000 Generating: 99883; BooGnFtr used     1621.501 seconds.
n=800 k=80 Tested:100000 Generating: 99998; BooGnFtr used     1909.324 seconds.
n=800 k=90 Tested:100000 Generating:100000; BooGnFtr used     2041.405 seconds.

n=1000 k=40  Tested:100000 Generating:    42;  BooGnFtr used    506.867 seconds.
n=1000 k=50  Tested:100000 Generating: 59003;  BooGnFtr used   1305.780 seconds.
n=1000 k=50  Tested:100000 Generating: 59162;  BooGenEZ used  10965.266 seconds.
n=1000 k=60  Tested:100000 Generating: 96878;  BooGnFtr used   1967.896 seconds.
n=1000 k=70  Tested:100000 Generating: 99823;  BooGnFtr used   2321.272 seconds.
n=1000 k=80  Tested:100000 Generating: 99990;  BooGnFtr used   2647.147 seconds.
n=1000 k=90  Tested:100000 Generating: 99999;  BooGnFtr used   2974.364 seconds.
n=1000 k=100 Tested:100000 Generating:100000;  BooGnFtr used   3265.869 seconds.
\end{verbatim}
}
Note that  testing\footnote{Our program does not check whether a random vector is different from the previous random vectors.}  one hundred thousand random vectors $\vec h$ \emph{cannot prove} in the rigorous mathematical sense that, say,  there are two different $\vec h$ and $\pvec h$ in $\Boo n^k$ such that both $H(\vec h)$ and $H(\pvec h)$ generate $\Boo n$. However, say for $(n,k)=(1000,70)$, given that the program has found more than 99 thousand such vectors out of one hundred thousand vectors, it has a neglectably little probability that $H(\vec h)$ does \emph{not} generate $\Boo{1000}$ for more than half of the vectors belonging to $\Boo{1000}^{70}$. 


\section{The underlying problem is NP-hard}\label{sect:NPh}
In this section, we   prove that
computing $\vec h$ (at least one $\vec h$ to be more precise) from $\vec p$ and $\vec p(\vec h)$  is an NP-hard problem. Actually, it is an NP-complete problem since computing $\vec p(\vec h)$ from $\vec p$ and $\vec h$ can clearly be done in polynomial time.

Before formulating the result of this section, we need to explain in details what the problem and, mainly, what its input size are. The notation used in Definition \ref{def:protcol} is still in effect.
%
We prefer to use bytes rather than bits; up to the factor 8, this makes no essential difference.
The length of a number $s\in \Nnul$ is the number of its decimal digits. (Because each digit is stored in one byte.) The variables are $x_1$, $x_2$, \dots, $x_k$; the length of a variable $x_i$ is $1$ plus the length of $i$. Parentheses, the operation symbols $\vee$ and $\wedge$, $\&$, commas, spaces, and the equality symbol are of length 1 each. Note for later reference that 
\begin{equation} \left.
\parbox{7cm}{the occurrence of spaces increases the length without modifying the mathematical meaning.}\,\,\right\}
\end{equation}
In the input data, we will write lattice terms in the usual form except that we do not lower the subscripts of their variables, for example, 
\begin{equation}
%TECHNICAL EDITOR, this is in \texttt (typewriter) style on purpose,
%DO NOT MODIFY!
\texttt{\color{blue} (((x1\color{red}3$\vee$x14\color{blue}$\vee$x16)\color{red})$\wedge$x2)\color{blue})$\vee$x4}
\label{eq:skkHdNprbvjtl}
\end{equation}
is a lattice term\footnote{The only role of the  coloring here is to help compute the length of the term.}. The length of a lattice term is the sum of the lengths of its constituents, for example, the length of the lattice term given in \eqref{eq:skkHdNprbvjtl}, which contains no space, is 24. If we add the suffix 
%TECHNICAL EDITOR, DO NOT MODIFY \texttt in the line below!
``\texttt{=0}" or ``\texttt{=1}" 
to  \eqref{eq:skkHdNprbvjtl}, then we obtain an \emph{atomic equation} of length 26. Generally, an \emph{atomic equation} is an equation with variables ranging in $\set{0,1}$ on the left side and a constants from $\set{0,1}$ on the right side. 


As the elements of $\Boo n$ are vectors of $\set{0,1}^n$, we define the length of a so-called \emph{vector equation} $p(x_1,$ \dots, $x_k)=u$, where $u\in \set{0,1}^n$ and the variables range in $\set{0,1}^n$, to be  $n$ times the length of the  corresponding atomic equation plus $n$; the ``plus $n$'' is explaned by the need of $n$ copies of the symbol $\&$ that we use to separate the atomic equations.  (It is convenient to put an $\&$ after the last atomic equation.) Let us agree that when we want to emphasize that $\vec p(\vec h)$ is only an element of $\set{0,1}^n$ rather than a complicated expression,
\begin{equation}
\text{we denote }\vec p(\vec h) \text{ by }\vec u.
\label{eq:slcncGrgjT}
\end{equation}



Finally, writing $\vec x$ in place of $\vec h$ in \eqref{eq:lrJgfncNpZnkt}, consider the \emph{input system} or, briefly, \emph{input}
\begin{equation}
(n,k): \quad \vec p(\vec x) = \vec u , 
\label{eq:zkNkJmRvk}
\end{equation}
where $\vec x$ is the unknown. This system will be the input of the algorithm that Theorem \ref{thmNP} is going to deal with. The
\emph{size} of the input system given in \eqref{eq:zkNkJmRvk} is $b$ times the length of a vector equation $p(x_1,\dots, x_n)=u$ plus the length of the ``parameter vector'' $(n,k)$ plus 1; the last summand comes from the length of the colon `:", which we use to separate the ``head''  $(n,k)$ describing the parameters from  the list of vector equations. Denote by $s_{\eqref{eq:zkNkJmRvk}}$ the size of this input system given in  \eqref{eq:zkNkJmRvk}. Clearly, there is a linear function $f_0\colon \Nplu\to\Nplu$ such that we can compute $b$, the number of components of $\vec p$, in at most $f_0(s_{\eqref{eq:zkNkJmRvk}})$ many steps. Therefore, we could include $b$ in the parameter vector occurring in \eqref{eq:zkNkJmRvk} without changing the difficulty of the problem in our point of view. That is, no matter which of $\Prot$ or $\Prot^-$ we deal with. 



We define the data size
\nothing{\footnote{The graph in itself will be an input of algorithm $\Blg$; we write ``data size'' here just to make a distinction from the number of vertices, which is often called the size of a graph.}} of an instance of the \emph{$3$-colorability problem} analogously. The vertices of a simple graph $G$ are nonnegative  integers.
Although the edges are two-element subsets of the vertex set, we write them as pairs $(i,j)$ with $i<j$. When turning $G$ into an input, then we use  commas to separate the vertices  in their list, 
then we put a colon, and then we list the edges without parentheses, and we separate them by semicolons. For example, the four-element circle is given as\nothing{\footnote{A pair here means a two-element subset of the vertex set. Hence, after including, say, the pair $0,1$ in the list, there is no need to include the pair $1,0$.}}
\begin{equation}
%TECHNICAL EDITOR: \texttt below is on purpose,
%DO NOT MODIFY!
\texttt{
\color{blue}0,1,2\color{red},3:0,\color{blue}1;1,2\color{red};2,3;\color{blue}3,0;\color{black}}
\label{eq:tmljSvnrlrMgmrtDz}
\end{equation}  
(the last semicolon is only for convenience). 
The \emph{data size}\nothing{\footnote{We can leave the vertices that do not occur as endpoints of edges
as well as the whole list of vertices from a \eqref{eq:tmljSvnrlrMgmrtDz}-like data, but this modification would not effect computational complexity.}} 
of this graph is $24$.
Let us agree to the convention that 
\begin{equation}
\text{for any vertices $i$ an $j$, we write  $i$ and $j$ with the same number of digits;}
\label{eq:fjBjbszkskphtlJ}
\end{equation}
this is possible by adding leading zero digits to small numbers. It is not hard to see\footnote{Using that there are fewer numbers with few digits than numbers requiring many digits.} that this convention does not influence the computational complexity of the 3-colorability problem. 

After repeating that $\vec u$ in \eqref{eq:zkNkJmRvk} is defined in \eqref{eq:slcncGrgjT} and the unknown in the equation in \eqref{eq:zkNkJmRvk} is $\vec x$, we are in the position to formulate the result of the current section.



\begin{theorem}\label{thmNP} 
For  inputs \eqref{eq:zkNkJmRvk}, the problem of finding a solution of the equation in \eqref{eq:zkNkJmRvk}  is NP-hard. In fact, it is NP-complete. 

Furthermore, the $3$-colorability problem of graphs is reducible to the problem of of finding a solution of the equation in \eqref{eq:zkNkJmRvk} in \emph{linear time}.
\end{theorem}

\begin{proof} Clearly, we can test in polynomial time whether a given $\vec h$ is a solution of  \eqref{eq:zkNkJmRvk} or not. Hence, NP-hardness and NP-completenes in the theorem are equivalent.  
Let us consider the following two conditions.
\begin{itemize}
\item[$(\alpha)$] There is an algorithm $\Alg$ and a polynomial $f$ of degree $d$ such that for any $s\in\Nplu$ and any input \eqref{eq:zkNkJmRvk} of size $s$, $\Alg$ finds a solution $\vec h$ (that is, an $\vec h$ such that $x:=\vec h$ turns the equality true) in at most $f(s)$ steps provided there exists a solution. 
\item[$(\beta)$] There is  an algorithm $\Blg$ and a polynomial $g$ of degree $d$ such that for any $s\in\Nplu$ and for any graph $G$ of data size $s$, $\Blg$ decides in at most $g(s)$ steps whether $G$ is three-colorable or not.
\end{itemize}
We need to show that $(\alpha)$ fails. 
We know from Garey, Johnson, and Stockmeyer \cite{Gareyatal}, see also Dailey \cite[Theorems 3 and 4]{dailey}, that $3$-colorability is an NP-complete problem. In other words, we know that $(\beta)$ fails. Therefore, to complete the proof,  it suffices to show that 
$(\alpha)$ implies $(\beta)$. Actually, we are going to prove that the connection between the two problem is \emph{linear}. Hence, in particular,  the satisfaction of $(\beta)$ for some $d$ implies the satisfaction of $(\alpha)$ with the \emph{same} $d$. Furthermore, this plan automatically takes care of the last sentence of the theorem. 


For the sake of contradiction, assume that $(\alpha)$ holds. So we have an algorithm $\Alg$ and a polynomial $f$ of degree $d$ with the  properties described in $(\alpha)$.


The letters $r$, $w$, and $g$ will denote the colors red, white and green\footnote{These are the colors in the Hungarian flag.}. We say that a graph is \emph{almost $3$-colorable} if, for each of its vertices $i$,  we can label  $i$ by a nonempty subset of $\set{r,w,g}$ such that whenever two vertices are connected by an edge, then the color sets of these two vertices are disjoint. Observe that 
\begin{equation}
\text{a graph is 3-colorable if and only if it is almost 3-colorable.}
\label{eq:nljKfgclvmzmdzgsf}
\end{equation}
Indeed, if a graph is 3-colorable, then we obtain an almost 3-coloring by turning the colors to singleton sets. Conversely, if the graph is almost 3-colorable, the take an almost 3-coloring and, for each vertex $i$, pick a color of the color set of $i$ and make it the color of $i$. Thus, \eqref{eq:nljKfgclvmzmdzgsf} is obviously holds. 


For each vertex $i$ of the input\footnote{Remember, the vertices of $G$ are numbers.} graph  $G$, we consider three variables, $r_i$, $w_i$, and $g_i$. (Of course, we will write $ri$, $wi$ and $gi$ when turning the 3-colorability problem of $G$ into an input of the algorithm $\Alg$, but we  often put the number $i$ into subscript position in the paper.) The permitted values of $r_i$ is 1 (meaning that yes, the vertex $i$ is red) or 0 (meaning that that $i$ is not red). The permitted values of $w_i$ and those of $g_i$ are also 1 and 0 with analogous meanings. For each edge $(i,j)$ (but note that there are no parentheses in the input string), we consider two terms. The first one is
\begin{equation}
 r_i\vee  w_i\vee  g_i \vee  r_j\vee  w_j\vee  g_j,
\label{eq:mklSkdnmRbg}
\end{equation}
which expresses that each endpoint of the edge has at least one color. The second term is more tricky; it is
\begin{equation}
(r_i\wedge r_j)\vee (w_i\wedge w_j)\vee
(g_i\wedge g_j).
\label{eq:ksSrhLjrtDvmGh}
\end{equation}
Originally, both terms belong to Propositional Calculus; however, we also consider them lattice terms. This explains that we did not use negation. We intend to stipulate that, 
\begin{equation}
\text{for all edges $(i,j)$,  \eqref{eq:mklSkdnmRbg} is true (that is, 1) but 
\eqref{eq:ksSrhLjrtDvmGh} is false, that is, 0.} 
\label{eq:nthvzdnKnzWrBht}
\end{equation}
Clearly, this stipulation means that if we define the color set $C_i\subseteq\set{r,w,g}$ of vertex $i$ by the rules $r\in C_i\iff r_i=1$, $w\in C_i\iff w_i=1$, and $g\in C_i\iff g_i=1$, then  
we obtain an almost 3-coloring of our graph $G$. That is,
\begin{equation}
\eqref{eq:nthvzdnKnzWrBht} \text{ has a solution } \iff G \text{  is almost } 3\text{-colorable.}
\label{eq:mWtsFnzkMkr}
\end{equation}
We denote $(r_1,w_1,g_1,r_2,w_2,g_2,\dots, r_n,w_n,g_n)$ by $\pvec x$. Let $p_1(\pvec x)$ denote the conjuntion of all terms \eqref{eq:mklSkdnmRbg} that are associated with the edges of $G$. Similarly, $p_2(\pvec x)$ will stand for the disjunction of the terms \eqref{eq:ksSrhLjrtDvmGh} associated with the edges of $G$.  Observe that \eqref{eq:nthvzdnKnzWrBht} has a solution if and only if the system $\set{p_1(\pvec x) =1,\,\,p_2(\pvec x)=0)}$ has a solution. Combining this fact with \eqref{eq:nljKfgclvmzmdzgsf} and \eqref{eq:mWtsFnzkMkr}, we obtain that 
\begin{equation}
G\text{ is 3-colorable} \iff \text{the sytem }\set{p_1(\pvec x) =1,\,\, p_2(\pvec x)=0} \text{ has a solution.}
\label{eq:kvkszblgbGl}
\end{equation}
It follows from \eqref{eq:fjBjbszkskphtlJ} that the  length of \eqref{eq:mklSkdnmRbg} and that of \eqref{eq:ksSrhLjrtDvmGh} do not depend on which edge $(i,j)$ is considered. Therefore, denoting the data size of $G$ by $s$,
\begin{equation}\left.
\parbox{8.0cm}{there is a constant $c_1>0$ such that the sum of the size of $p_1(\pvec x)$ and the size of $p_2(\pvec x)$ is at most $c_1s$.}\,\,\right\}
\label{eq:nZrtBrndsFrcCnr}
\end{equation}
Let $t$ be the number of the vertices of $G$ of degree at least 1. In other words, $t$ is the number of the endpoints of the edges of $G$; we are not interested in isolated vertices. 
We let $k':=3t$, $b':=2$, $\pvec p:=(p_1,p_2)$, $n':=1$, and $\pvec u:=(1,0)$. It follows from \eqref{eq:nZrtBrndsFrcCnr} that there is a positive 
constant $c_2$, not depending on $G$, such that the length of the 
input system
\begin{equation}
(n',k'): \quad \pvec p(\pvec x)=\pvec u
\label{eq:snsjzbTnPmkv}
\end{equation}
is at most $c_2s$. 

After these preparations, we define an algorithm $\Blg$ as follows. The first task of $\Blg$ is to create the sytem \eqref{eq:snsjzbTnPmkv}. Clearly, there is a constant
$c_3$, not depending on $G$, such that at most $c_3s$ steps is sufficient to obtain \eqref{eq:snsjzbTnPmkv}. Next, after letting a counter $m$ equal $0$, $\Blg$ executes the steps of $\Alg$ with input \eqref{eq:snsjzbTnPmkv} one by one, but after each such step, increases $m$ by $1$ and verifies
whether $\Alg$ has just found a solution and halted  or  $m\geq f(c_2s)$ and $\Alg$ has not found any solution so far.  In the first case when $\Alg$ found a solution,   $G$ is 3-colorable by \eqref{eq:kvkszblgbGl}, so $\Blg$ outputs ``Yes'' and halts. (Note that the solution that $\Alg$ found could lead easily to a 3-coloring of $G$.)
In the second case when $m\geq f(c_2s)$ and $\Alg$ halted,  \eqref{eq:snsjzbTnPmkv} has no solution by $(\alpha)$, $G$ is not 3-colorable by \eqref{eq:kvkszblgbGl}, whereby
$\Blg$ outputs ``no'' and halts. 
So after $c_3s$ steps, an additional step to let $m:=0$, $f(c_2s)$ steps of $\Alg$, $f(c_2s)$ steps to increase $m$, and a final step to output the result, that is, after  $g(s):=c_3s + 2 f(c_2s) +2$ steps, 
$\Blg$ decides whether $G$ is 3-colorable. 
Since it is trivial that the degree of $f$ is at least $1$, the polynomial $g$ is of the same degree as $f$. Thus, $(\beta)$ holds and the proof of Theorem \ref{thmNP} is complete.
\end{proof}




\section{A variant of 3-SAT}\label{sect:3SAT}
Let us recall that a \emph{literal} is a variable or a negated variable, a \emph{clause}
is a disjunction of literals, and a \emph{conjunctive normal form}, CNF for short, is the conjunction of some clauses. In this paper, we consider CNF's as lattice terms; hence the \emph{size} of a CNF is defined as its length. The Boolean satisfiability problem, SAT for short, is the problem that takes a CNF as input and decides whether we can substitute elements of $\Boo 1=\set{0,1}$ for the variables of the CNF such that the value of the CNF becomes 1.  By the Cook-Levin Theorem, see Cook \cite{cook} and Levin \cite{levin}, 
SAT is NP-complete. If we restrict the CNF's to those in which every clause has exactly three literals (equivalently, at most three literals), then we obtain the so-called 3SAT (problem). By Karp \cite{karp},  3SAT is NP-complete, too. Even 3SAT can be restricted further. For example, 
the \emph{not-all-equal $3$-satisfiability}
and the \emph{one-in-three-$3$SAT} problems, which we do not define here,  are still NP-complete; see Schaefer \cite[NP1 and NP2 in page 217]{schaefer}. 
Here we take the opportunity that the previous section offers a short and elementary proof for the following observation. 



\begin{observation}\label{obs:nmsBzlhB} 
Assume that $p$ is a conjunctive normal form such that for each clause $C$ of $p$,
\begin{itemize}
\item either $C$ is the disjunction of three non-negated variables
\item or $C$ is the disjunction of two negated variables.
\end{itemize}
Then it is an NP-complete problem to decide whether  $p$ is satisfiable, that is, whether we can substitute $0$'s and $1$'s for its variables to obtain $1$.
\end{observation}

For example, $p=(x_1\vee x_2\vee x_2)\wedge(\neg x_1\vee \neg x_4)\wedge (\neg x_2\vee \neg x_4)$ is in the scope of Observation \ref{obs:nmsBzlhB} but $p=(\neg x_1\vee \neg x_2\vee \neg x_2)\wedge(x_1\vee  x_4)$ is not.

\begin{proof} We can modify the proof of Theorem \ref{thmNP} as follows.
By de Morgan's laws, the term in \eqref{eq:ksSrhLjrtDvmGh} is false if and only if 
\begin{equation}
(\neg r_i\vee  \neg r_j)\wedge (\neg w_i\vee  \neg w_j)\wedge (\neg g_i\vee  \neg g_j)
\label{eq:szhkhHvmKrNstkSk}
\end{equation}
is true. Let $p$ denote the conjunction we obtain by forming the conjunction of all the terms \eqref{eq:mklSkdnmRbg} and \eqref{eq:szhkhHvmKrNstkSk} that are associated with  the edges of $G$. Then  the proof of Theorem \ref{thmNP} reduces the problem of deciding whether $G$ is 3-colorable to the satisfiability problem of $p$. Since $p$ is of the form required and the 3-colorability problem is NP-complete, we conclude the validity of Observation~\ref{obs:nmsBzlhB}.
\end{proof}
 

\section{Retrospection and an improvement}\label{sect:retro}
As we have wandered a bit far from the initial purpose of finding small generating set in some lattices, Boolean ones in the present paper, let us summarize how Theorem \ref{thm:nleqSpk} contributes to cryptography.
%
As we have already mentioned, see Footnote  \ref{foot:mkSTm}, we need that $H(\vec h)=\set{h_1,\dots,h_k}$ generates a sublattice of $\Boo n$ that is  \emph{large}. 
Indeed, if $H(\vec h)$ generated, say, a ten element sublattice, then the Adversary at every tenth attempt (as an average) could steal \woman's money from the Bank. 
The best (and probably the most economic) way the ensure that the sublattice in question is large is to stipulate that $H(\vec h)$ generates the whole $\Boo n$ but this is not enough in itself, $n$ should be large, too. So we conclude: 
\begin{equation}\text{$n$ should be large and $H(\vec h)$ should generate $\Boo n$.}
\label{eq:nBflchrmBpr}
\end{equation}
The sceptics  may argue that with $k\geq n$ (especially with $k$ being much greater than $n$), it would be quite easy to ensure that $H(\vec h)$ generates $\Boo n$. 
%Indeed, the proof of Theorem \ref{thmNP} works even for $n=2$ provided $k$ can be large. 

However, there is an advantage of having a $k$ that is much smaller than $n$. As $\vec y$ in \eqref{eq:twStjrgshdmSnD} and \eqref{eq:RszmKlfrptsnP} consists of $n\cdot \frac b v$ bits, the larger $n$ the  longer message \woman{} can encipher and send according to  \eqref{eq:RszmKlfrptsnP} while generating and attaching \emph{only few} (that is  $k$)  random terms. 

There is another advantage of the fact, due to Theorem \ref{thm:nleqSpk},  $n$ can be much larger than $k$. As $\Boo n\cong \Boo 1^n=\set{0,1}^n$, the elements of $\Boo n$ are (treated as) $n$-dimensional bit vectors and the calculations are done componentwise.
The point is that  \woman{{} and the Bank do not have the use all components every time. If the message in \eqref{eq:twStjrgshdmSnD} and \eqref{eq:RszmKlfrptsnP} is short or if only authentication is requested according to \eqref{eq:lrJgfncNpZnkt}, then \emph{it suffices to use only a part of the components}\footnote{If  at least two components are used, then the proof of Theorem \ref{thmNP} remains valid for this case.}. So we can improve $\Prot$ and $\Prot^-$  from \eqref{eq:wDPrthr} and \eqref{eq:mMztmPrt} to the following protocols
\begin{align}
\sProt&=\sProt(n,k,\vec h, b,\Strat,v,S)
\label{eq:mjTvlHvpra}\text{ and}\\
\sProt^-&=\sProt^-(n,k,\vec h, - ,\Strat,v,S)
\label{eq:mjTvlHvprb}
\end{align} 
where $S$ is, say, an at least $\lint{n/2}$-element subset of $\set{1,2,\dots, n}$.
Consider $\Boo n$ the powerset lattice $P(\set{1,\dots,n}$ and denote $|S|$ by $n_S$. 
Also, consider $\Boo{{n_S}}$ the powerset lattice $P(S)$. The components $h_1,\dots,h_k$ of $\vec h$ are subsets of $\set{1,\dots,n}$, so we can let $\vec h_S:=(h_1\cap S,\dots, h_k\cap S)$. As the function $P(\set{1,\dots,n})\to P(S)$ defined by $X\mapsto X\cap S$ is a surjective lattice homomorphism and surjective homomorphisms send generating sets to generating sets, the components of $\vec h_S$ generate $P(S)=\Boo{n_S}$. These trivial considerations allow us to agree upon the following. 

\begin{definition}\label{def:PrzjvtdnMbs}
The protocols \eqref{eq:mjTvlHvpra} and \eqref{eq:mjTvlHvprb} are used as
$\Prot(n_S,k,\vec h_S,b,\Strat,v)$ from \eqref{eq:wDPrthr} and $\Prot(n_S,k,\vec h_S,-,\Strat,v)$ from \eqref{eq:mMztmPrt}, respectively; the only difference is that
instead of sending a vector $\vec p$ of lattice terms, both $\vec p$ and  $S$ have to be sent.
\end{definition}

There are at least are $2^{n-1}$ possible subsets $S$ for protocols \eqref{eq:mjTvlHvpra} and \eqref{eq:mjTvlHvprb}. (There are exactly $2^{n-1}$ for $n$ even and  there are slightly more for $n$ odd.)  So, in addition to Theorem \ref{thmNP}, the Adversary  has to face  exponentially many  possible subsets $S$.




\section{Appendix: a Pascal program}\label{sect:appDx}

{\footnotesize 
\begin{verbatim}
program BooGenEZ;  uses sysutils; const lineno=13;
 info:array[1..lineno] of string[80]=(
 ' BooGenEZ, a Dev-Pascal 1.9.2. program for studying the small ',
 ' generating sets of B_n, which is the powerset lattice of ',
 ' an n-element set. (For a faster version, see BooGnFtr.) ',
 ' ',
 ' After asking for n and k, the program generates k-dimensional ',
 ' random vectors with components in B_n and counts those vectors ',
 ' the components of which generate B_n. ',
 ' For the first trial,  n <20  and k < 20 are recommended.',
 ' ',
 ' This is not a professional program: improper inputs lead to',
 ' "runtime error" messages.    So the program is as is.  ',
 '   (C) Gabor Czedli, 2023',
 ' ' );

const nmax=2000; kmax=120; vpldate='March 18'; {see next line, too}
  vpfldatum ='"BooGenEZ" '+vpldate
     +' on k-generation of B_n; (C) Gabor Czedli, 2023';
var H:array[1..kmax,1..nmax] of Boolean; {\vec h consists of its rows}
   n,k,ii,again: integer;  timeused: real;
   nt,reqt,ng:longint; {number of tests, requeste test, generating H's}
   hour0,hour1,min0,min1,sec0,sec1, msec0, msec1:word;

procedure randfill;{forward;} var i,j: integer;
 begin for i:=1 to k do for j:=1 to n do
       if random(2)=1 then H[i,j]:=true else H[i,j]:=false
 end;

procedure inputdata;
 begin Write('Enter n in [2...',nmax,'] :'); readln(n);
   Write('Enter k  in [2...',kmax,'] :'); readln(k);
   Write('Enter the (positive!) number of tests, or enter 0 for halt: ');
   readln(reqt); {requested tests}
  if reqt<=0 then reqt:=MaxLongInt;
  if (n>nmax) or (n<3) then
   begin writeln('n is out of range. Hit <enter> to abandon');
    readln; halt;
   end;
  if  (k>kmax) or (k<3) then
   begin writeln('k is out of range. Hit <enter> to abandon');
     readln; halt;
   end;
 end{inputdata};

function doesHgenerate:boolean;
 var colj,colo,rowi: integer; hope,b:boolean; {colo:column-other}
 begin   colj:=0; {column pointer}
  repeat inc(colj); hope:=false;
   for rowi:=1 to k do hope:=hope or H[rowi,colj];
   if hope then
   for colo:=1 to n do if (hope) and (colo<>colj) then
    begin b:=true;
     for rowi:=1 to k do
        if H[rowi,colj] then b:=b and H[rowi,colo];
     if b then hope:=false;
    end; {for colo}
  until  (not hope) or (colj=n); {inspection done}
  doesHgenerate := hope;
 end; {doesHgenerate}

begin {main} for ii:=1 to  lineno do writeln(info[ii]);
 repeat inputdata; nt:=0; ng:=0; randomize; writeln;
   decodetime(time,hour0,min0,sec0,msec0);    writeln(vpfldatum);
   writeln(  'Computation starts at ',hour0,':',min0,':',sec0,'.',msec0);
  writeln;  again:=1;
  repeat   randfill;  inc(nt);{number of tests}
  if doesHgenerate then inc(ng);
    if nt mod 256=0 then write('. ');
  until nt>=reqt;
  decodetime(time, hour1,min1,sec1,msec1);
   writeln;  write('n=',n,' k=',k,' Tested:',nt,' Generating:',ng);
  decodetime(time, hour1,min1,sec1,msec1);
  timeused:= (3600000*(hour1-hour0)+60000*(min1-min0)
             +1000*(sec1-sec0)+msec1-msec0)/1000;
  writeln(   '; BooGenEZ used', timeused:15:3,' seconds.'); writeln;
  write('Enter 1 to start again, or enter 0 to abandon. ');
  readln(again);   writeln;
 until again <> 1;
 write('Thank you for using this program.   Hit <enter>.');  readln;
end.
\end{verbatim}
}


\begin{thebibliography}{99}

\bibitem{delbrinczg}
D. Ahmed and G. Cz\'edli\footnote{Some preprints are available from arXiv or ResearchGate but, at the time of writing, primarily from the author's homepage.}:
(1+1+2)-generated lattices of quasiorders. Acta Sci. Math. (Szeged) 87 (2021), 415--427.


\bibitem{balbes}
Balbes, R.:
Projective and injective distributive lattices.
Pacific J. Math. \tbf{21}405--420 (1967)

\bibitem{chajdaczg}
I. Chajda and G. Cz\'edli:
How to generate the involution lattice of quasiorders?, Studia Sci. Math. Hungar. 32 (1996), 415--427.


\bibitem{cook}
Cook, S. A.: The complexity of theorem-proving procedures.  
Proceedings of the 3rd Annual ACM Symposium on Theory of Computing,  151--158 (1971)


\bibitem{CzGEateq}
G. Cz\'edli: Lattice generation of small equivalences of a countable set. 
Order 13 (1996), 11--16.


\bibitem{CzGEq4}
G. Cz\'edli: Four-generated large equivalence lattices. Acta Sci. Math. (Szeged) 62 (1996), 47--69.


\bibitem{czgeek}
G. Cz\'edli: (1+1+2)-generated equivalence lattices, J. Algebra, 221 (1999), 439--462.


\bibitem{czg2017fourgen}
G. Cz\'edli:
Four-generated quasiorder lattices and their atoms in a four generated sublattice; Communications in Algebra, 45/9 (2017) 4037--4049.

\bibitem{czgDEBRauth}
Cz\'edli, G.:
Four-generated direct powers of partition lattices and authentication. Publicationes Mathematicae (Debrecen) \tbf{99} (2021), 447--472


\bibitem{czgfiltQuo}
Cz\'edli, G.: Generating some large filters of quasiorder lattices. \href{http://arxiv.org/abs/2302.13911}{arXiv:2302.13911} or (the latest version at the time of writing) \url{https://tinyurl.com/czg-genfquo}

\bibitem{czgkulin}
G. Cz\'edli and J. Kulin:
A concise approach to small generating sets of lattices of quasiorders and transitive relations. Acta Sci. Math. (Szeged) 83 (2017), 3--12


\bibitem{czgoluoch}
 G. Cz\'edli and L. Oluoch:
 Four-element generating sets of partition lattices and their direct products. 
Acta Sci. Math. (Szeged) 86,  405--448 (2020).


\bibitem{czgdaugthent}
G. Cz\'edli: Four-generated direct powers of partition lattices and authentication. Publicationes Mathematicae (Debrecen) 99 (2021), 447--472.

\bibitem{dailey}
Dailey: Discrete Mathematics 30 (1980) 289-293; see Theorems 3--4.  

\bibitem{dolgos}
Dolgos, T.: 
Generating equivalence and quasiorder lattices over finite sets, BSc Theses, University of Szeged, 2015 (in Hungarian)


\bibitem{Gareyatal}
Garey, M.R., Johnson, D. D., Stockmeyer, L.:
Some simplified NP-complete problems. 
STOC '74: Proceedings of the sixth annual ACM symposium on Theory of computing, April 1974,  Pages 47--63.
\url{https://doi.org/10.1145/800119.803884}

\bibitem{r:Gr-LTFound} 
   Gr\"atzer, G.:    Lattice Theory: Foundation.   Birkh\"auser, Basel (2011)


\bibitem{karp}
Karp, R.M. (1972). Reducibility among Combinatorial Problems. In: Miller, R.E., Thatcher, J.W., Bohlinger, J.D. (eds) Complexity of Computer Computations. The IBM Research Symposia Series. Springer, Boston, MA.
%https://doi.org/10.1007/978-1-4684-2001-2_9


\bibitem{kisz}
Kisielewicz, A.: A solution of Dedekind's problem on the number of isotone Boolean functions. J. Reine Angew. Math. \tbf{386} 139--144 (1988) 


\bibitem{kulin}
J. Kulin: 
Quasiorder lattices are five-generated. Discuss. Math. Gen. Algebra Appl. 36
(2016), 59--70.

\bibitem{kuratowski}
K. Kuratowski: Sur l'\'etat actuel de  l'axiomatique de la th\'eorie des ensembles. 
Ann. Soc. Polon. Math. \tbf 3, 146--147, 1925.


\bibitem{levin}
Levin L. A.: Universal Sequential Search Problems. Problemy Peredachi Informatsii \tbf{9}:3, 115--116,  1973; Problems Inform. Transmission, \tbf{9}:3, 265--266 (1973) 
\nothing{https://www.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=ppi&paperid=914&option_lang=eng}


\bibitem{levy}
A. Levy: Basic Set Theory. 
Springer-Verlag, Berlin--Heidelberg--New York, 1979.

\bibitem{mcKmcNT}
 McKenzie, R.N.,  McNulty, G.F.,  Taylor, W.F.:
Algebras, Lattices, Varieties. Vol. 1.
Wadsworth $\&$ Brooks/Cole, Monterey, California, 1987


\bibitem{schaefer}
Schaefer, T. J.: The complexity of satisfiability problems. 
STOC '78: Proceedings of the tenth annual ACM symposium on Theory of computing, May 1978, pp.\ 216--226, \url{https://doi.org/10.1145/800133.804350}

\bibitem{sperner}
Sperner, E.: Ein Satz \''uber Untermengen einer endlichen Menge. Math. Z \tbf{27}, 544--548 (1928). \href{https://doi.org/10.1007/BF01171114}{DOI 10.1007/BF01171114}

\bibitem{strietz75}
H. Strietz: Finite partition lattices are four-generated. Proc. Lattice Theory Conf. Ulm, 1975, pp. 257--259.

\bibitem{strietz77}
H. Strietz: \"Uber Erzeugendenmengen endlicher Partitionverb\"ande. Studia Sci. Math. Hungarica 12 (1977), 1--17.

\bibitem{takach}
G. Tak\'ach:
Three-generated quasiorder lattices. Discuss. Math. Algebra Stochastic
Methods 16 (1996) 81--98.

\bibitem{totik}
 Totik, V.: Oral communication, somewhen in the nineties.

\bibitem{zadori}
L. Z\'adori:  Generation of finite partition lattices. Lectures in universal algebra (Proc. Colloq. Szeged, 1983), Colloq. Math. Soc. J\'anos Bolyai, Vol. 43, North-Holland, Amsterdam, 1986, pp. 573--586.


\end{thebibliography}

\end{document}





