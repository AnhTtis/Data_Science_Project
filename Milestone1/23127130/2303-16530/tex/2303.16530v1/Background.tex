\section{Background}\label{sec:background}

\subsection{Running Example: The Body Sensor Network (BSN)}\label{sec:background:bsn}

Throughout this paper, we use the BSN~\cite{BSN} as our running example. The BSN can be used to monitor and analyze a patient's vital signs to determine if the patient is in an emergency state. If an emergency is detected, an emergency signal is sent to an external agent. 
To monitor the patient, the BSN can be equipped with sensors, such as a pulse sensor, a glucometer, or a thermometer. The \textit{BodyHub} acts as a central unit that requests data from the sensors to process it and evaluate the patient's risk status. 
The BSN is equipped with a scheduler that enables self-adaptive functionality to minimize energy usage while still providing sufficient confidence in the obtained data. 

In previous work~\cite{vogel2023property}, we expressed the requirements of the BSN with the help of PSP as TCTL properties and verified a model of the BSN with observer automata at design-time using the UPPAAL model checker~\cite{behrmann2004tutorial}. 

\subsection{Property Specification Patterns (PSP)}\label{sec:background:psp}

The formalization of requirements as properties expressed in a temporal logic requires expertise in the use of the logic. 
\textit{Property Specification Patterns}~(PSP) have been proposed for qualitative~\cite{DwyerAC99}, real-time~\cite{KonradCheng05, Gruhn06L}, and probabilistic~\cite{Grunske08} requirements, which all have been collected and extended in one unified catalog~\cite{AutiliGLPT15}. 
Such patterns define recurring schemes of requirements that are leveraged to ease the formalization.

Particularly, the catalog by Autili et al.~\cite{AutiliGLPT15} provides a grammar to express properties in Structured English language and mappings to various temporal logics such as LTL and MTL for an automated translation from Structured English to the logics. 
For instance, the timed \textit{Response} pattern is denoted in structured English as ``If $P$ has occurred, then in response $S$ eventually holds between $t_1$ and $t_2$'' while $P$ and $S$ are placeholders for events or states of a concrete system and $t_1$ and $t_2$ are variables defining a time window, in which $S$ should happen. The corresponding property is mapped to MTL as $\square (P \rightarrow \lozenge^{[t_1, t_2]} S)$ with the same placeholders.
Thus, using the grammar and translations to temporal logic, specification is eased and precise semantics of requirements is achieved.


\subsection{Automata-Based Runtime Verification}\label{sec:background:rv}

In general, automata-based approaches are one means to realize runtime verification since an automaton is an operational representation of a property defined declaratively in temporal logic~\cite{falcone2021taxonomy,bauer2011runtime}. 
We name such an automaton \textit{observer}. 
The states of an observer capture information about the past, and the transitions capture possibilities for the future behavior of the system under verification, which constitutes a \textit{past implies future} modality~\cite{falcone2021taxonomy}. Accepting or error states of an observer denote a satisfaction or violation of the property, and the active state represents the current state of the system.
Thus, a runtime verifier can traverse the observer based on system and environmental events to verify the behavior of the running system against the property.
Technically, the observer has to be created for a property expressed in temporal logic and can then be either directly interpreted by a verifier or further compiled down to code for execution within a verifier~\cite{falcone2021taxonomy}. 

In concrete approaches, observers are either generated manually~\cite{UMLObserver,Mallozzi+2019} or automatically from temporal logic~\cite{goldsby2007amoeba,Giannakopoulou+Havelund2001,bauer2011runtime} or other specifications such as sequence diagrams~\cite{Simmonds+2009}.


