\section{Related Work}\label{sec:related}

Many approaches have been proposed to provide evidence about the correct behavior of SAS in face of uncertainties, particularly contributions for quantitative runtime verification~\cite{QoSMoS,calinescu2017engineering,CailliauL19:TAAS, filieri2011run,Solano+2019}.
QoSMoS~\cite{QoSMoS} pioneered the work on quantitative runtime verification of service-based systems to reach quality-of-service requirements by dynamically adapting to uncertainties. ENTRUST~\cite{calinescu2017engineering} systematically engineers trustworthy SAS by combining design-time and runtime modeling and verification to build assurance cases for SAS, dynamically updated after a system reconfiguration. Caillau and Lamsweerde~\cite{CailliauL19:TAAS} proposed an obstacle-driven runtime adaptation where monitored satisfaction rates, obtained via probabilistic assertions, are defined in terms of observed states and behaviors. The goal satisfaction rate then guides adaptation strategies.
Solano et al.~\cite{Solano+2019} proposed a goal-oriented adaptation approach with runtime verification based on reliability and cost formula derived from runtime-efficient model checking principles~\cite{filieri2011run, Calinescu:TSE21} to verify and control SAS. 
However, in all those works changes in requirements require new adaptation cycles to be started.

To incrementally tame requirements uncertainty at runtime, Dâ€™Ippolito et al.~\cite{Dippolito:ICSE14} propose a multi-tier control synthesis for adaptive systems.
Li et al.~\cite{Li:RE2022} extend those principles by proposing an iterative adaptation cycle via a multi-grained requirements relaxation. Compositional means to reduce computational overhead in runtime verification have also been proposed. 
Borda et al. propose the Adaptive CSP language~\cite{Borda:SEAMS2018} to modularly model and compositionally verify self-adaptive cyber-physical systems. 
While these approaches provide more flexibility for requirements changes, they are still limited by not supporting adaptations of individual properties. 

Changing requirements may also comprise evolving requirements. Evolution Requirements (EvoReqs)~\cite{Souza:Evolution13} focus on requirements that cause the evolution of other requirements by executing adaptation strategies in response to failures particularly related to Awareness Requirements (AwReqs)~\cite{silva2011awareness}.
Similar to the FLAGS approach~\cite{baresi2010fuzzy} the granularity of their changes goes into the goal level (a more coarse-grained way) and either delegates the changes to the target system (EvoReq) or deals with change via fuzzy levels of adaptation goals (FLAGS). Whittle et al. presented RELAX~\cite{whittle2010relax}, a requirements specification language specifically suited for SAS. Like FLAGS, they also explore fuzzy logic, but particularly to express system properties that may be relaxed due to uncertainty. 
In~\cite{Inverardi:Runtime2011}, the authors propose an approach to make requirements consistent with their corresponding evolution. Our approach differs from all those works as it focuses on a fine-grained perspective of requirements changes while also managing their change at runtime without requiring a new adaptation cycle to be started. Weyns and Iftikhar have recently provided an extension to ActivFORMS where their approach also takes into account evolution~\cite{activforms}. Similar to our work, they offer basic support for changing adaptation goals and updating the verified models of the feedback loop on-the-fly to meet evolving goals. 
However, we differ by exploring knowledge reuse in the runtime verification while dynamically adapting the property that co-evolves with the PSP-based requirement. 

Finally, integrating structured grammar with runtime verification is not novel. Perez et al.~\cite{perez2022automated} propose a framework where requirements are written in structured natural language and then transformed into monitors to analyze requirements against C code. While Mallozzi et al.~\cite{Mallozzi+2019} create observers from PSP-based requirements manually, Simmonds et al.~\cite{Simmonds+2009} model properties as sequence diagrams based on templates for PSP, from which observers are generated. Despite the notable contribution of those approaches, they are not suited for seamlessly verifying changing requirements at runtime as the property adaptation cannot be performed dynamically.
