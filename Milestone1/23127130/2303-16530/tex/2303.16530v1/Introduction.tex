\section{Introduction}

In a self-adaptive system (SAS), a managing system dynamically controls a managed system so that the managed system satisfies its requirements despite uncertainty concerning the environment, system, and requirements themselves~\cite{weyns2020introduction}. For this purpose, the managing system typically implements a MAPE-K feedback loop~\cite{kephart2003vision}. The monitoring and analysis steps observe the managed system and check whether the system satisfies its requirements. If not, the planning step creates an adaptation plan that the execution step will enact on the managed system to perform self-adaptation. In this context, one means for the analysis step to detect violations of requirements by the managed system is \textit{runtime verification}. 

We consider runtime verification methods that check the current execution of a system represented by a trace against the requirements formalized as \textit{properties} in a temporal logic such as Linear Temporal Logic (LTL) and Metric Temporal Logic (MTL)~\cite{bauer2011runtime,bartocci2018introduction}. 
Such a runtime verification has been already applied to self-adaptive systems to detect violations of properties~\cite{CailliauL19:TAAS,goldsby2007amoeba}. A further line of research focuses on stochastic behavior in self-adaptive systems, for which the violations of properties expressed in a probabilistic temporal logic can be detected by quantitative verification~\cite{Calinescu2012quantitative, calinescu2017using, filieri2011run, Solano+2019}. 

For SAS, we claim that any runtime verification performed by the managing system has to take into account uncertainties of the environment, managed system, and requirements. Particularly, any uncertainty may directly or indirectly cause changes of the requirements. Consequently, the properties under investigation by the runtime verification have to be dynamically adapted to represent the changing requirements. 
For example, in the healthcare domain, a Body Sensor Network (BSN) captures vital signs of patients for detecting emergencies. To determine the accurate health status of a patient, sensors are used. If the actual condition of the patient has deteriorated, new data and additional sensors need to be included.
This example illustrates a requirement change for the BSN, which has to be taken into account by runtime verification.
Moreover, requirements may generally change due to software evolution~\cite{Lehman1980}, which also applies to SAS~\cite{weyns2020introduction}. 

In this context, we advocate that \textit{runtime verification should be able to handle such requirement changes while checking the managed system against the requirements by preserving the knowledge it gathered until then and with minimal delay}. 
For instance, in the BSN, the runtime verification should preserve the knowledge about which of the existing sensors have already provided vital signs at the point in time when a sensor is deployed. Otherwise, the runtime verification would inaccurately require the existing sensors to send vital signs, which, however, they already did. Hence, a re-start of the runtime verification with an updated property could lead to inaccurate results and, thus, a period in which the patient is unassisted.  Thus, we aim for a co-evolution of the runtime verification and requirements, in which the verification seamlessly checks the managed system against  changing requirements. 

This proposal contrasts the state-of-the-art runtime verification approaches for SAS that do not support changing requirements in terms of dynamically adapting the properties~\cite{CailliauL19:TAAS,goldsby2007amoeba,filieri2011run,Calinescu2012quantitative, calinescu2017using, Solano+2019}. Other approaches provide only limited flexibility for requirements changes by relaxing requirements~\cite{Li:RE2022,Dippolito:ICSE14} or representing uncertainty in properties with fuzzy logic~\cite{whittle2010relax,baresi2010fuzzy}, but still without supporting adaptations of properties. 

In this paper, we propose a novel runtime verification technique for SAS that can seamlessly handle requirements changes by dynamically and safely adapting properties that formalize the requirements. Technically, each property is represented by an \textit{observer automaton} (or \textit{observer} for short) that has a dedicated error state denoting a violation of the property. To identify such a violation, the runtime verification traverses the observer in terms of state transitions triggered by monitored events emitted from the managed system or environment.
To cope with a changing requirement, an observer can be dynamically and safely adapted to reflect the changed requirement while the verification is running and the observer is quiescent (cf.~\cite{Kramer:TSE90}).
Thereby, intermediate verification results in terms of progress made in the observer is preserved to achieve a continuous, incremental verification as advocated by Ghezzi in the context of SAS~\cite{ghezzi2012evolution}.

To ease specification of properties, we leverage \textit{Property Specification Patterns} (PSP)~\cite{AutiliGLPT15} that support specifications in structured English (using a grammar) and automated translations to temporal logic. In our work, we rely on future MTL~\cite{MTL}.
Furthermore, we built upon our pattern catalog that provides templates for observers used for model checking real-time systems against Timed Computation Tree Logic (TCTL) properties at design-time~\cite{vogel2023property}. Based on these templates, we define novel templates for observers used for runtime verification concerning MTL properties. 
Thus, given a requirement in Structured English, we automatically generate the MTL property and the corresponding observer by using the translations of Autili et al.~\cite{AutiliGLPT15} and the novel observer templates. Therefore, the semantics of the observers are precisely defined to enable an accurate runtime verification.
To further provide precise semantics of observer adaptations, we propose in this paper \textit{Property Adaptation Patterns}~(PAP) that specify at the level of PSP how an observer should be adapted to accurately reflect changes of a requirement in the observer. For a concrete SAS, these PAP are instantiated to adaptation rules used by a higher-level feedback loop to dynamically adapt the observers used by the lower-level feedback loop for runtime verification. 

We evaluate our runtime verification technique on an Arduino prototype of the Body Sensor Network (BSN)~\cite{BSN} with changing requirements and the Timescales benchmark~\cite{ulus2019timescales}. Results show that our technique can cope with changing requirements while being efficient and correct.

Thus, this paper provides the following contributions:
\begin{enumerate}
    \item[C1)] An observer-based, incremental runtime verification technique that seamlessly copes with changing requirements.
    \item[C2)] A systematic approach using PSP to automatically obtain observers with precise semantics for runtime verification.
    \item[C3)] Property Adaptation Patterns (PAP) to precisely define observer adaptations and their semantics.
    \item[C4)] An implementation of our technique for the Arduino plattform and its evaluation on the BSN system and Timescales benchmark.
\end{enumerate}

The rest of the paper is structured as follows. In Section~\ref{sec:background}, we provide the background on the BSN, PSP, and observers. We discuss our runtime verification technique in Section~\ref{sec:approach}, evaluate it in Section~\ref{sec:evaluation}, and contrast it to related work in Section~\ref{sec:related}. Finally, we conclude our paper in Section~\ref{sec:conclusion}.

