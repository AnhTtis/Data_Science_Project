\section{Runtime Verification of Self-Adaptive Systems with Changing Requirements}\label{sec:approach}

In this section, we discuss our approach to runtime verification of SAS with changing requirements. 
First, we introduce the \textit{Property Specification and Adaptation Patterns} for runtime verification. Then, we detail how our approach uses these patterns in SAS for automata-based runtime verification, where requirements changes imply adaptations of properties and observers. We use the BSN as a running example.

\subsection{Property Specification and Adaptation Patterns}\label{sec:approach:catalog}

In our work, we focus on verifying SAS against properties expressed in MTL. To ease the formalization of requirements as MTL properties, we leverage the \textit{Property Specification Patterns} (PSP) from literature (Section~\ref{sec:background:psp}). We particularly reuse the Structured English Grammar and mapping to MTL formula templates from Autili et al.~\cite{AutiliGLPT15}. Thus, a user formalizes a requirement in structured English, which is automatically translated to an MTL property. 

Additionally, to realize an \textit{automata-based runtime verification}, we need to construct observers for MTL properties (Section~\ref{sec:background:rv}). To automate the construction of observers with PSP, we built upon our PSP catalog that provides observer templates (UPPAAL timed automata) for TCTL properties and focuses on design-time model checking with UPPAAL~\cite{vogel2023property}. However, direct reuse of these observer templates for runtime verification is not feasible, e.g., due to non-determinism in these observers and their focus on design-time model checking. 
Thus, we created new observer templates for MTL properties that are deterministic and focus on
runtime verification. Still, the existing templates have been a solid basis to obtain the new templates. These templates allow us to automatically construct observers for properties expressed in Structured English.

Our novel PSP catalog for runtime verification with its observer templates builds on the mapping from natural language to MTL~\cite{AutiliGLPT15} and observer techniques~\cite{vogel2023property}. Therefore, the catalog offers precise semantics in expressing properties and representing them in observers. 
In particular, we systematically created the observer templates by manually analyzing all possible types of traces that would violate a property, and generalizing these traces to a timed automaton. Thus, such an observer template represents a set of traces, of which some violate the corresponding property. To distinguish violating and satisfying traces, the observer template contains an \textit{error} state that is reached if and only if a trace violates the property.  

Additionally, with our catalog we propose \textit{Property Adaptation Patterns} (PAP) that define at the PSP level how observers should be adapted to represent changes of requirements. Thus, adaptations of properties are accurately reflected in the observers. Technically, PAP are defined by graph transformations (cf.~\cite{Giese+2012}) on observer templates that are instantiated to adaptation rules for concrete observers.
Thus, our catalog does not only provide precise semantics for specifying (using PSP) but also for adapting properties (using PAP).
The PSP/PAP catalog is publicly available\footnote{\url{https://github.com/hub-se/PAP/wiki}} and  detailed in the following sections.


\subsection{Architectural Overview}\label{sec:approach:architecture}

Fig.~\ref{fig:architecture} shows an architectural overview of our approach. We consider a SAS to be split into a managed and managing system operating in an environment. The managing system is split into two layers, each implementing a MAPE-K feedback loop: the \textit{Change Manager} and the \textit{Requirements Manager}.

\begin{figure}
    \centering
    \includegraphics[width=.9\columnwidth]{figures/architecture.png}
    \caption{Architectural Overview.}
    \label{fig:architecture}
    \vspace{-2em}
\end{figure}

\paragraph{Change Manager}
The change manager (shaded in blue in Fig.~\ref{fig:architecture}) adapts the managed system so that the system satisfies its requirements despite uncertainty. Adaptation is needed if requirements are violated. To determine such violations, the change manager performs \textit{automata-based runtime verification} (Section~\ref{sec:background:rv}).
For this purpose, it monitors the managed system and environment. The \textit{Event Monitor} adds events representing changes of the system and environment to the first-in-first-out \textit{Queue}. 
In the \textit{Analyze} step, the \textit{Runtime Verifier} consumes the events from the queue and matches them against the \textit{Observers}, each representing a property.

If a property is violated, adaptation of the managed system is needed so that the \textit{Plan} and \textit{Execute} steps are performed. 
The change manager interacts with the \textit{Requirements Manager} by notifications about property violations. The other way around, the requirements manager initializes the runtime verification by providing observers to the change manager and dynamically adapts these observers if requirements change. 


\paragraph{Requirements Manager}
The requirements manager (top layer shaded in gray in Fig.~\ref{fig:architecture}) is in charge of formalizing requirements given by a human in Structured English to MTL properties and corresponding observers. It uses our \textit{Property Specification Pattern} (PSP) catalog comprising mappings to MTL and observer templates. The generated observers are provided to the change manager for runtime verification. 

At runtime, the requirements manager monitors the change manager, managed system, and environment to identify with the help of a human changes of requirements, for instance, triggered by a human or the change manager notifying about violations of requirements. 
In the \textit{Analyze} and \textit{Plan} steps, the requirements manager and human determine which requirements have changed and how they have changed to adapt the properties and corresponding observers used by the change manager accordingly. To accurately adapt properties and observers for runtime verification, our \textit{Property Adaptation Pattern} (PAP) catalog comprises adaptation templates for each observer template. These adaptation templates are instantiated to adaptation rules that are automatically and safely executed on the change manager's observers to reflect the changed requirement for runtime verification.
Changes of requirements may also mean that new requirements emerge or existing requirements become irrelevant. Thus, the requirements manager has to synthesize new properties and observers that are provided to the change manager or respectively remove existing observers from the change manager. 

We believe that fully automating the requirements manager, especially the analyze and plan steps, is challenging and also possibly not desired. Therefore, our current proposal includes the \textit{human in the loop} who is in charge of decision-making regarding identifying requirements changes and determining how properties/observers need to be adapted to reflect these changes. However, our PSP/PAP catalog supports the human by easing the specification and adaptation of properties with their observers while providing precise semantics for them. Moreover, the execution of dynamic and safe adaptations of properties/observers is performed automatically.

In the following, we detail how runtime verification is initialized and performed, and how properties are adapted.
In general, the system may have multiple requirements and each requirement may be expressed by multiple properties. For readability purposes, we describe in the following section how our approach handles one requirement expressed by one property. 
Nevertheless, our approach works with multiple requirements and multiple properties by deploying multiple independent instances of the \textit{Event Monitor}, including the \textit{Queue}, and the \textit{Runtime Verifier}.

\subsection{Initializing Runtime Verification}\label{subsec:initialzingRV}

Our PSP catalog in the \textit{Requirements Manager} is used when a stakeholder expresses a requirement in Structured English. The catalog then generates an MTL property formalizing the requirement. Moreover, the corresponding observer template is retrieved and instantiated to an observer that represents this property (an example is shown in Fig.~\ref{fig:obs-all}). The resulting observer is eventually provided to the \textit{Change Manager}'s \textit{Knowledge} and used by the \textit{Runtime Verifier} (cf. Fig.~\ref{fig:architecture}).

Conceptually, an observer contains a set of states, one of which is the current state representing the current state of the managed system and environment. Each of the observer's states has a set of outgoing transitions. Such a transition points to another state (the transition's \textit{target}) and may have a guard condition over clocks and an action to reset clocks. 
Additionally, transitions may be labeled with an event type.

After deployment, the runtime verifier sets the observer's current state to the initial state.
Additionally, based on the property, a list of event types relevant to evaluate the property is provided to the change manager's knowledge and used by the event monitor to filter relevant events emitted from the managed system and environment.\footnote{Technically, the managed system and environment do not need to emit events, but the monitor can sense the state of the system and environment and create corresponding events whenever relevant state changes occur.} Filtered events are added to the \textit{Queue}, from where they are processed for runtime verification by the runtime verifier (see Section~\ref{subsec:performingRV}).

\begin{figure}[t!]
    \centering
    \begin{subfigure}{0.5\textwidth}
        \centering
        \includegraphics[width=.9\columnwidth]{figures/observer-template.png}
        \caption{Observer template.}
        \label{fig:obs-template}
    \end{subfigure}%

    \begin{subfigure}{0.5\textwidth}
        \centering
        \includegraphics[width=.9\columnwidth]{figures/observer2.png}
        \caption{Instantiated observer from the template.}
        \label{fig:obs}
    \end{subfigure}%
    \caption{Observer for Timed Response Chain w/ Between scope. }
    \label{fig:obs-all}
    \vspace{-1em}
\end{figure}

\textbf{Example:}
In the BSN, the developer is aware that network congestions may arise. To this end, the change manager adapts the managed system to decrease network usage by reducing the number of scheduler cycles and therefore limiting how often the BodyHub requests data. Nevertheless, the developer wants to specify that in any case, both sensor nodes (thermometer and pulse sensor) shall send data to the BodyHub when the BodyHub requests such data. The developer sets a time limit of $2s$ within which both sensors shall respond. This behavior is expected to be repeated for every scheduler cycle. To formalize this requirement, the developer selects a suitable pattern (\textit{Timed Response Chain} with the \textit{Between} scope) from the PSP catalog and expresses the requirement using the structured English grammar:

\begin{quote}
    Between the scheduler cycle starting and elapsing, if \emph{the BodyHub requests data}, then in response \emph{the thermometer sends} eventually  \emph{within 2s }followed by \emph{the pulse sensor sends} \emph{within 2s}.
\end{quote}

The Timed Response Chain covers requirements that expect an ordered chain of events within a time window in response to a request event. The Between scope further requires that the request and responses together are surrounded by two events, in this case, describing the start and end of a scheduler cycle.
%
The requirements manager uses the PSP catalog to provide the MTL formula template
\begin{equation}
\begin{split}
        & \square (( Q \wedge \lozenge R ) \rightarrow \\ 
        & (P \rightarrow \linebreak (\neg R \mathcal{U}^{[0,t]} (S_1 \wedge \neg R \wedge (\lozenge ^{[0, t]} (S_2 ))  ))) \mathcal{U} R)
\end{split}
\end{equation}
as well as the corresponding observer template shown in Fig.~\ref{fig:obs-template} that both correspond to the selected pattern. Both templates are instantiated and the placeholders $P, Q, R, S_1, S_2$ are replaced with actual values from the Structured English requirement. This results in the following MTL formula:
\begin{equation}\label{eq:req1}
\begin{split}\raisetag{2.8em}
        & \square (( \text{cycle\_starting} \wedge \lozenge \text{cycle\_ending} ) \rightarrow (\text{request} \rightarrow \\
        & (\neg \text{cycle\_ending} \text{ }\mathcal{U}^{[0,2]} (\text{thermometer\_reply} \text{ }\wedge \\ 
        & \neg \text{cycle\_ending} \wedge (\lozenge ^{[0, 2]} (\text{pulse\_reply} ))  ))) \text{ }\mathcal{U}\text{ } \text{cycle\_ending})
\end{split}
\end{equation}
and the observer shown in Fig.~\ref{fig:obs}.
 
In the observer, there are states corresponding to the scheduler cycle not having started (\emph{closed}), the cycle having started (\emph{open}), the BodyHub requesting data (\emph{waiting$_1$}), and the first sensor, but not yet the second sensor sending data (\emph{waiting$_2$}). Additionally, there is an \emph{error}-state that is reached if and only if the scheduler cycle elapses before both sensors send data, or if the time bound of $2s$ elapses. 

The event types that need to be monitored to evaluate the property are: (i) the scheduler cycle starts, (ii) the scheduler cycle ends, (iii) the BodyHub requests data, (iv) the pulse sensor sends, and (v) the thermometer sends.
The observer's current state is set to its initial state, which is \emph{closed}. 

 
\subsection{Performing Runtime Verification}\label{subsec:performingRV}

Once the observer is deployed to the change manager, the \textit{runtime verifier} traverses the observer to verify the managed system against the property encoded in the observer. To this end, it checks if outgoing transitions of the observer's current state are enabled. 
A transition is enabled if its guard condition is evaluated to \textit{true}. In general, our observers only have guard conditions that refer to clock valuations against time bounds. Therefore, an observer has a clock that can be reset when a transition is taken.  
Transitions equipped with a label are only enabled when an event instance of the labeled event type is processed. 
Disabled transitions with a guard condition that are unlabeled may become enabled simply because time progresses. To take such a transition as soon as the guard's valuation changes from \textit{false} to \textit{true}, the runtime verifier analyzes all such transitions starting in the observer's current state upon entering it and determines the amount of time that needs to pass for each transition to become enabled. For the smallest such time, a timer is set that will generate an event that triggers the runtime verifier to force progress in the observer. Therefore, the runtime verifier only needs to access the observer when an event is monitored, either stemming from the managed system or environment, or from an elapsed timer. If the state in the observer is switched due to events from the managed system or environment and before the timer elapses, the timer is discarded. 


To perform runtime verification, the \textit{event monitor} observes the managed system and environment and puts the events determined as relevant in the first-in-first-out event queue, which serves as a buffer of events, maintained by the knowledge component.\footnote{For runtime verification, we assume that monitored events from the managed system and environment have a strict order, that is, one event is monitored after another. Thus, an event is a tuple of an instance of some general event type and a timestamp. A trace is a list of such events.} The \textit{runtime verifier} processes these events from the queue one after the other. For each consumed event, it checks whether any outgoing transition of the observer's current state is enabled. 
If a transition is enabled, it is taken and the observer's current state is set to the transition's target. 
Otherwise, when no transition is enabled, the observer remains in its current state. At this point, the processed event is discarded. 
Upon reaching a new state, again all outgoing transitions are checked. If no transition is enabled, the observer remains in its current state and a timer is set according to the outgoing transitions' guard conditions (if applicable). 
Therefore, while the observer's structure represents the property, its current state represents previously obtained knowledge about the execution of the managed system and its environment until now.

If and only if the observer reaches an error state during the runtime verification, the managed system in its environment violates the property. 
In the change manager, detecting such a violation can act as a stimulus that, among others, triggers it to plan and execute an adaptation of the managed system. The change manager may also notify the requirements manager of the violation.
We designed this observer-based verification technique to be used in an online setting, that is, the verification is performed alongside the running managed system and environment that provide a continuing stream of events. However, the technique can be used without modifications for offline verification when a trace of events is provided later. 

\textbf{Example:}
Suppose the following execution of the BSN regarding the property specified above: 
First, a scheduler cycle starts. The monitor adds the corresponding event to the queue before it is analyzed. For the observer's current state, there is an enabled transition for the monitored event. The transition is taken and the observer progresses to state \emph{open}. $100ms$ later, the \emph{BodyHub requests} data from the sensors. Processing this event, the observer is progressed to state \emph{waiting$_1$} and its clock $c$ is reset. Upon analyzing the current state's outgoing transitions, a timer is set to $2,000ms$. If the thermometer and pulse sensor do not send data in return before the timer elapses, the observer progresses to the \textit{error} state. 
During the BSN's execution, the change manager may perform adaptations in the scheduler, that is, the number of scheduler cycles may be decreased to improve confidence in the obtained data, or increased to reduce energy consumption and network usage. 


\subsection{Adapting the Property During Runtime Verification}\label{sec:approach:pap}
At runtime, the requirements manager monitors the change manager, managed system, and environment to identify and handle requirements changes with the help of a human. 
It can further react to notifications from the change manager that the managed system currently violates the property. 
%
If the requirements manager finds that the previously specified property is no longer adequate, it utilizes the \textit{property adaptation patterns}~(PAP) to systematically adapt the existing property. These PAP extend our PSP catalog to define adaptations of properties and observers at the pattern level (Section~\ref{sec:approach:catalog}). Therefore, they provide precise semantics for such adaptations.

Particularly, the requirements manager selects the PAP that appropriately reflects the requirements change in the property and observer, instantiates the PAP to an adaptation rule, and applies this rule to dynamically adapt the observer deployed in the change manager. 
Thus, the observer representing the requirement seamlessly co-evolves with the requirement, which contrasts discarding and redeploying a new observer in the case of requirements changes.
Therefore, the observer's current state can persist through adaptation, which is beneficial as it reflects information obtained previously about the execution of the managed system and environment until the adaptation. This leverages an incremental verification (cf.~\cite{ghezzi2012evolution}) where previous knowledge is preserved for the runtime verification. 

Nevertheless, enacting an adaptation of the observer has to be synchronized with the runtime verification that uses the same observer so that the adaptation is \textit{safe}. Otherwise, adapting the observer while the runtime verifier traverses the observer and performs state transitions could lead to inconsistencies. To achieve safe adaptations, the observer can only be adapted when it is quiescent (cf.~\cite{Kramer:TSE90}). 
Therefore, the requirements manager adds a dedicated \textit{adaptation event} to the event queue of the change manager. When this event is processed by the runtime verifier, the adaptation of the observer is performed instead of a verification step. After the adaptation, the runtime verifier continues processing the monitored events and performing verification steps. This approach also ensures that all events monitored before the adaptation event are processed with the unchanged observer.
 
Since our observers are based on PSP, both the original and adapted property can be expressed in structured natural language to describe the adaptation. The PAP range from \textit{parameter} (i.e., updating time bounds or replacing event types corresponding to placeholders in MTL formula templates of PSP) to \textit{structural} adaptations (i.e., the structure of the underlying property and observer are adapted, e.g., by adding or removing a response in a response-chain property resulting  in novel or obsolete states in the observer).

In the following, we present five PAP. We outline them in natural language and formalize exemplarily two of them with graph transformations on observers.
For these PAP, we noticed that a seamless adaptation of the observer preserving the already obtained knowledge in contrast to redeployments and restarts of verification processes is beneficial. 
Still, we do not claim that there is no situation in which a redeployment and restart of the observer can be appropriate.

We present the following five PAP: 
a) updating a time guard,
b) updating an event,
c) adding a response to a chain,
d) removing a response from the chain,
and e) splitting the response chain into multiple response properties.
While patterns (a) and (b) cover parametric changes of the requirement, patterns (c), (d), and (e) cover structural changes. 


\paragraph{Updating a Time Guard}
This PAP covers changes of a deadline in a real-time requirement by adapting a property's time guard. 
Such an adaptation is performed by updating the corresponding guards in the observer and all timers. Adapting a time interval might change the valuation of guard conditions, and therefore enable previously disabled transitions. Thus, adapting a time interval might yield an immediate violation of the property. 
This PAP can be applied in this fashion to real-time properties of most patterns from the PSP catalog such as the Response, Existence, Absence, and Recurrence. 

\paragraph{Updating an Event}
This PAP is used to exchange one of the events specified in the property. In the observer template, such an adaptation can be performed by updating the labels of transitions from their old value, such as \textit{P}, to their new values, such as \textit{P'}.
This PAP can be applied to any pattern and observer in our catalog. 


\paragraph{Adding a Response to the Chain}

\begin{figure}[t!]
    \centering
    \begin{subfigure}{0.5\textwidth}
        \centering
        \includegraphics[width=.7\columnwidth]{figures/observer-template-add.png}
        \caption{Graph transformation rule for the PAP.}
        \label{fig:obs-template-add}
    \end{subfigure}%

    \begin{subfigure}{0.5\textwidth}
        \centering
        \includegraphics[width=.9\columnwidth]{figures/observer3.png}
        \caption{Resulting observer after adding a glucose sensor.}
        \label{fig:obs3}
    \end{subfigure}%
    \caption{PAP of adding a response to a response chain.}
    \label{fig:obs-templates}
    \vspace{-2em}
\end{figure}

This PAP is used when an additional response is expected to occur in the chain of responses, which extends the property. 
In essence, the response chain pattern defines a list of responses. The PAP allows the addition of a response to the end of the list, which is defined by the graph transformation rule (cf.~\cite{Giese+2012}) shown in Fig.~\ref{fig:obs-template-add}. The response to be added is defined by the rule's parameter $S_3$. This PAP can be applied to the observer template of the Response Chain pattern shown in Fig.~\ref{fig:obs-template} by matching the black and red elements of the rule in the observer template and afterwards performing the side effects of the rule, that is, removing the red elements (that are further annotated with $--$) and adding the green elements (that are further annotated with $++$) to the observer template. Accordingly, a new state $waiting_3$ is added to the observer template during which the new response $S_3$ is expected after response $S_2$ has occurred to move to state \textit{open}, otherwise to move to the \textit{error} state if the time bound has passed. 

However, the graph transformation rule shown in Fig.~\ref{fig:obs-template-add} is mainly considered as a specification of an observer adaptation at the pattern/template level that guarantees precise semantics of the adaptation according to the PSP. 
Thus, in a SAS, this rule is not applied on an observer template but it is rather itself a template. It will be instantiated for adapting a concrete property and observer. Instantiating and applying the rule to the observer of the BSN shown in Fig.~\ref{fig:obs} results in the observer shown in Fig.~\ref{fig:obs3}. Particularly, this adaptation reflects the requirements change that the BSN has to consider the data sensed and sent as \textit{glucose reply} by the glucose sensor, which have not been considered before. The response \textit{glucose reply} is expected to occur as the last response of the chain.

The observer's current state persists through the adaptation process, that is, the runtime verifier preserves the knowledge of which other responses of the chain have already occurred.  


\paragraph{Removing a Response from the Chain}
This PAP is used when an existing response is not needed anymore in the chain.
It is the counterpart of the previous PAP (adding a response).  
We now consider the removal of a response $S_1$ in the middle of the chain as shown by the graph transformation rule in Fig.~\ref{fig:obs-template-rem}. 
The rule is instantiated and applied similarly to the rule shown in Fig.~\ref{fig:obs-template-add}, but in this case to adapt the observer shown in Fig.~\ref{fig:obs3} to obtain the observer shown in Fig.~\ref{fig:obs2'}. This adaptation reflects the requirements change in the BSN that the thermometer is not needed anymore and therefore, the \textit{thermometer reply} is not expected to happen anymore.  

However, since this adaptation removes a state from the observer, we have to take into account that the state to be removed can be the \textit{current} state of the observer. If this is the case, a new current state has to be determined and set by the adaptation. 
If the current state is $waiting_i$ that should be removed by adaptation, we know that the property's scope is open (scheduler cycle has started), a request has occurred, and all responses prior to $S_i$ have happened.
In the adapted observer, the same information is represented by state $waiting_{i+1}$, since the state $waiting_i$ together with the response $S_i$ have been removed by adaptation. Thus, in the case that the \textit{current} state was removed, the current state of the observer after adaptation is set to $waiting_{i+1}$.

\begin{figure}[t!]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=.7\columnwidth]{figures/observer-template-remove.png}
        \caption{Graph transformation rule for the PAP.}
        \label{fig:obs-template-rem}
    \end{subfigure}%
     
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=.9\columnwidth]{figures/observer2+.png}
        \caption{Resulting observer after removing a thermometer.}
        \label{fig:obs2'}
    \end{subfigure}%
    \caption{PAP of removing a response from the chain.}
    \vspace{-2em}
\end{figure}

\paragraph{Splitting the Response Chain}
In a response chain, the order of expected responses is specified. If a specific order of the responses is no longer required, this PAP splits the chain into multiple, independent responses, that is, multiple response chains with only one response for each chain. Therefore, it generates multiple observers, one for each response, and maintains the information represented by the existing observer by selecting the current state for each of those new observers depending on the current state of the existing observer. 

Consider, for example, a response chain with two responses as shown in Fig.~\ref{fig:obs}. The observer's state \emph{closed} represents that the scope is closed, \emph{open} represents that the scope is open but no response is required because any previous request has already been replied, \emph{error} represents a violation of the property. Each of these three states can also be found in the new observers, where they still represent the same information. Hence, if the existing observer is in any of these states, the new observers will be set to that state as well. 
If the existing observer's current state is $waiting_i$, i.e., any of the states where a request has been sent but not all replies have occurred, the information for the new observers differs according to the response they are representing. Consider, for example, that $waiting_2$ is the current state in the existing observer. This means that the first response has occurred, but not yet the second. Thus, the new observer for the first response should have \emph{open} as the current state, representing that all requests have been addressed by a response, while the other new observer (for the second response) should have \emph{waiting} as its current state because a request has occurred but not yet the corresponding response (i.e., $S_2$). In general, all observers representing properties regarding responses $S_j$ with $j < i$ will have their current state set to \textit{open}, while the remaining observers will be in state \textit{waiting}. 

\smallskip

After an observer adaptation regardless of the PAP that is used, the runtime verifier checks all outgoing transitions of the current state in the observer since any adaptation may enable previously disabled transitions. Additionally, existing timers are discarded and new timers are set accordingly for updated timed guards in the observer. Afterwards the runtime verifier continues with regular verification steps by consuming monitored events from the queue (see Section~\ref{subsec:performingRV}). 
