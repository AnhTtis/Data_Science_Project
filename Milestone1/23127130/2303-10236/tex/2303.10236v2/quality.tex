% !TEX root = main.tex

\section{Assessing Quality of \ac{RL} Projects}
\label{sec:quality}

The development of \ac{RL} projects is occurring mainly in Python. As 
a consequence, we focus the evaluation of our work on the analysis of 
Python-based \ac{RL} projects. 

Our analysis consists of eight code smells related to code 
organization, abstraction, and expression concerns, which gather information about code modularity 
and maintainability. The first five code smells 
are related to object-oriented programming in general, and the last 
three are specific to Python code smells detection~\cite{chen18}. 

  \paragraph*{\textbf{\ac{LM}}} A method or a function that is overly long. This 
impacts the understandability and testability of the code. Long 
methods tend to violate the single responsibility principle, which 
means they have more than one reason to change, using many 
temporary variables and parameters, which makes them more 
error-prone~\cite{lanza07}.

  \paragraph*{\textbf{\ac{LC}}} A class that is overly long. Similar to \ac{LM}, this 
could mean that the class is violating the single responsibility 
principle. This can have a negative impact on the understandability 
and reusability of the functions that the class 
encapsulates~\cite{fowler19}.
 
\paragraph*{\textbf{\ac{LPL}}} 
A method or a function that has a long parameter 
  list. A long parameter list can be inconsistent, difficult to use and 
  understand, and requires continuous changes as more data is 
  needed~\cite{fowler19}.

\paragraph*{\textbf{\ac{LMC}}} 
An expression that is accessing an object using the 
  dot operator through a long sequence of attributes or 
  methods~\cite{brown98}. The presence of this code smell can reveal an 
  unnecessary coupling between classes.  Changes to the intermediate relationships could 
  force undesirable changes on other classes in the chain. %To illustrate this suppose we 
  %have classes \spy{A}, \spy{B}, \spy{C}, and \spy{D}, in which an 
  %instance of \spy{A} needs data from \spy{D}, accessed through 
  %delegations to \spy{B} and \spy{C}, as follows:
  %\begin{python}[frame=none]
   %   a.getB().getC().getD().getData()
  %\end{python}
 

\paragraph*{\textbf{\ac{LSC}}}
A method or a function that is 
  multiply-nested~\cite{fowler19}. This hinders function readability 
  and affects testability. Like before Multiply-nested functions tend 
  to violate the single responsibility principle.

\paragraph*{\textbf{\ac{LTCE}}} 
A ternary conditional expression that is overly 
  long. The ternary operator defines a conditional expression in Python 
  in the form: \spy{X if C else Y}
  This is a concise way of writing short and simple conditional 
  statements. However, if the expression is too long it can be harder 
  to read and locate than a normal \spy{if} statement~\cite{chen18}.
  
\paragraph*{\textbf{\ac{MNC}}} 
A container (\eg set, list, tuple, dictionary) that is 
  multiply-nested. This produces expressions for accessing an object 
  with a long chain of indexed elements. This affects readability and 
  is error-prone when traversing multidimensional arrays~\cite{chen18}.
  
\paragraph*{\textbf{\ac{LLF}}} 
A lambda function that is too long. Lambda is a 
  Python expression used for the creation of anonymous functions at 
  runtime. These functions tend to be harder to read and debug than 
  local ones because they do not have reference names, and are 
  contained in one line. The problems of long lambda functions are 
  related to those of \ac{LM}~\cite{pyguide}.


Taking these metrics into account, we use the quality profile shown in 
\fref{tab:thresholds} as taken from 
the literature~\cite{lanza07, chen18}.

\begin{table}[hptb]
  \centering
  \caption{Thresholds for the metrics used}
  \input{tables/thresholds}
  \label{tab:thresholds}
\end{table}


\endinput


