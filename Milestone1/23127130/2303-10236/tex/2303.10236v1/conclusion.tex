% $Id: conclusion.tex 
% !TEX root = main.tex

%%
\section{Conclusion and Future Work}
\label{sec:conclusion}

This paper presents a code quality analysis of 24 \ac{RL} GitHub 
projects, extracted from popular repositories (20 top \ac{RL} GitHub 
repositories), and developed for the purpose of building an \ac{RL} framework (4 ACME 
examples). We analyze the projects using eight software metrics related 
to the definition, access, and interaction of program entities, as a 
proxy of code quality.

The results show that:
the recurrent code smells for the top 20 \ac{RL} GitHub projects are 
\acl{LM}, \acl{LC}, \acl{MNC}, and \acl{LPL}. The recurrent code 
smells for the ACME examples are \acl{MNC}, \acl{LLF}, \acl{LM}, and 
\acl{LPL}.
We observe that the projects developed for the ACME framework
examples present significantly less code smells than the projects 
developed by \ac{RL} users. This supports our hypothesis that 
\ac{RL} users produce less-quality code, which is more prone 
to errors, and potentially present higher maintainability, 
reusability, and extensibility costs. 
Nonetheless, when looking at the recurrent code smells across all 
repositories, we observe a commonality over code smells related to the 
definition and use of program entities and behavior. This suggests, 
that there is an intrinsic complexity in developing \ac{RL} algorithms that should be addressed.
For example, the presence of \acl{LM} and \acl{LC}, indicates that 
separating the responsibilities of program entities is a difficult 
task. This makes classes' and methods' definition complex, leading to 
code that is harder to understand, reuse, and maintain.
The \acl{MNC} and \acl{LPL} code smells indicate that the basic 
structures used to define \ac{RL} systems (\ie environments, states, 
rewards, and transition vectors) are not appropriate to capture the 
dimensionality of the problem at hand, making \ac{RL} projects hard to 
understand and maintain.

As a future work, the research roadmap laid from this study suggest:
First, the need for specialized software quality analysis metrics and tools to 
support \ac{RL} development. Second, the expression of \ac{RL} problems 
and algorithms is intrinsically complex for the current available 
development tools (\ie programming languages). Therefor the creation of 
more expressive abstractions is required to lower such complexity, and 
increase the maintainability of \ac{RL} projects. 


\endinput


 the number of repositories analyzed could be increased, including the repositories of projects done by experts. Also it would be interesting to analyze the evolution of the repositories to see which code smells are removed between versions, or which new code smells appear. Another interesting thing would be to analyze how many versions take to fix bugs that are product of code smells.