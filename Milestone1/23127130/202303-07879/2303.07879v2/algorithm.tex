

\section{Distributed Algorithm to Obtain NE} \label{sec:algorithms}
\vspace{-0.05in}
In this section, we design a distributed, uncoordinated algorithm that computes consumers' mixed-strategies that lie on NE for the ESG when there does not exist a dominant-strategy for each consumer, i.e., for the consumers in the set $\Sigma_{2,2}$ of Case 2. Note that given their knowledge on the set $\Omega$ (Section \ref{sec:esc}), the consumers can know whether they have a dominant strategy and in such a case they can directly compute it. The proposed distributed iterative algorithm, Algorithm \ref{algorithm}, is based on a best response scheme and requires minimum information exchange among consumers. In particular, there is no need of central coordinator or direct communication channels between consumer pairs since the required information can be just broadcasted from the consumer that has performed the most recent computation to the remaining ones. %The steps of the proposed algorithm are summarized in Algorithm \ref{algorithm} below.

The outer loop represents the algorithm's steps, and the inner loop iterates over all consumers who are randomly ordered in a list $\Sigma$ and at each iteration, they update their strategies. All consumers with a certain type share the same strategy in each algorithm's step. % Thus, although the inner loop iterates over all consumers, it practically computes sequentially the best response of each consumer type to the strategies that have been already been chosen by all other consumer types up to each corresponding iteration.
 Hence, if consumer $i$'s type has already been assigned a probability by another consumer of the same type in a previous iteration of the inner loop, consumer $i$ just retrieves this probability value (line \ref{line:retrievestrategy}), otherwise it computes the best response of its type to the types that have already played (lines \ref{line:PAconstr}-\ref{line:pacomputed}). Although, the inner loop practically computes consumer type strategies, it iterates over all consumers and not over all consumer types so as to allow for distributed operation; otherwise a central entity is needed to compute the consumer type strategies. % belong to each type and communicate them the chosen strategy for their type. 
%%



%%
As we aim to limit information exchange, the chosen strategies are not communicated. Instead the consumers update and broadcast three common variables, which encode this information:

\noindent $1)$ the variable $X_\Sigma$ that is equal to the total current daytime energy demand;\\
$2)$ the vector $EQT$ that indicates which consumer types have played in the previous iterations of an algorithm's step ($EQT(\vartheta)=1$ if type $\vartheta \in \Theta$ has played), and is re-initialized to $\bm{0_M}$ at the beginning of each outer loop;\\
$3)$ the vector $EQP$ that contains the current mixed strategies values for all consumer types and is updated each time a consumer type updates its strategy (line \ref{line:probincrease}).


%Together with $X_\Sigma$, the values of $EQT$ and $EQP$ are also broadcasted by the consumers. %For the ES policy, it represents the total average number of consumers competing for $RES$ up to the current iteration (line \ref{line:PAconstr}).
%%%



Based on the values of these common variables, each consumer type $\vartheta \in \Theta$, in its turn, updates its strategy by minimizing its expected cost of energy (line \ref{line:bestresponse}), given by:

\vspace{-0.1in}
\begin{small}
\begin{align}
    &cost(p_{\vartheta}^{d})  \nonumber =\\& p_{\vartheta}^{d}\big[res_{\vartheta}^{PA}(\mathbf{p})\cdot c^{RES}+(E_{\vartheta}-res_{\vartheta}^{PA}(\mathbf{p})) \cdot\gamma \cdot c^{RES}\big]\nonumber \\ 
    & 
    + (1-p_{\vartheta}^{d}) \cdot U_{\vartheta}\cdot \beta \cdot c^{RES}. \label{eq:personalcost}
\end{align}
\end{small}

A limitation of the best response scheme is that the first consumer that plays at an algorithm's step can freely choose her daytime RES demand. In order to mitigate this effect, we introduce a \textit{capping system} at the inner loop, which multiplies the best response with a parameter $cap\in [0,1]$\footnote{$cap$ can be constant through the algorithm or drawn from a uniform distribution. This will be discussed in the numerical evaluations.} (line \ref{line:cap}), such that the adjusted response is

\vspace{-0.15in}
\begin{small}
\begin{align}\label{eq:cap}
    f^{cap}(p_{\vartheta}^{d}) &= cap \cdot p_{\vartheta}^{d}.
\end{align}
\end{small}
\vspace{-0.1in}

As a result, even after the completion of an algorithm's step, it is possible that the total available RES capacity has not been allocated. In this case, additional outer steps are needed in order to reach an equilibrium state. In practice, the algorithm continues until one of the two following conditions hold: (i) a NE is reached, which means that the players do not wish to change their actions unilaterally with respect to the previous step (line \ref{line:equilibrium}), or (ii) a maximum number of steps ($N_{step}$) is reached.

\begin{small}
\begin{algorithm}[t] 
    \SetAlgoLined
    \textbf{Input} % $x$: Equal to PA or ES depending on the energy allocation policy; 
    $N_{step}$: number of algorithm's steps\\
    \textbf{Output} $EQP$: Vector of NE mixed strategies for each consumer type; \\\
    \textbf{Initialization: \label{line:init}}\\
    $(p^d_{\vartheta}, p^n_{\vartheta}) \gets (0,1), ~\forall \vartheta  \in \Theta$ \;
    $X_\Sigma \gets N \sum_{ \vartheta \in \Sigma_1  } r_{\vartheta} E_{\vartheta}$, ~~$\Sigma \gets \Sigma_{2,2}$ \;
    %If Case 2(c): $X_\Sigma \gets 0$, $\Sigma \gets$ all consumers with types in $\Sigma_2$ \label{line:sigma2}\; 
   % If Case 4:%$\&$ $x=PA$: 
   % $X_\Sigma \gets \sum_{ \vartheta_j \in \Sigma_1 \setminus \{ \vartheta_i \} } r_{\vartheta_j} (N-1)E_{\vartheta_j}$, $\Sigma \gets$ all consumer with types in $\Sigma_2$ \label{line:sigma3}\; 
    %If Case 4 $\&$ $x=ES$: $X_\Sigma \gets \sum_{ \vartheta_j \in \Sigma_1 \setminus \{\vartheta_i\} } r_{\vartheta_j} (N-1)$, $\Sigma \gets$ all consumers with types in $\Sigma_2$ \label{line:sigma4}\;
    %$EQT \gets \mathbf{0}_M$
    $EQP \gets$ vector of size $M$ with zero entries for $\vartheta \in \Sigma$ and unary entries for $\vartheta \in \Sigma_{1}$\;
    \For{$step \gets 1$ \KwTo $N_{step}$ \label{line:external_round}}{
        $EQT \gets \mathbf{0}_M$\;
        $EQP_{old} \gets EQP$\;
        \For{each consumer $i \in \Sigma$}{
            \If{$EQT(\vartheta_i) = 1$}{
            Consumer $i$ retrieves  $p^d_{\vartheta_i}$ from $EQP(\vartheta_i)$\; \label{line:retrievestrategy}}
            \Else{
                %\uIf{$x=PA$}{
                {\small$res_{\vartheta_i}^{PA}(p_{\vartheta_i}^{d})\leftarrow \frac{E_{\vartheta_i}\cdot \mathcal{RE}}{X_\Sigma +(N-1) ~r_{\vartheta_i} p^{d}_{ \vartheta_i} E_{\vartheta_i} + E_{\vartheta_i}}$}\label{line:PAconstr} \;
               {\small$p_{\vartheta_i}^{d,*}\gets \,\underset{p^d_{\vartheta_i}} {\mathrm{arg \min}}\, cost(p_{\vartheta_i}^{d})$}\label{line:bestresponse}, from \eqref{eq:personalcost}\;
                {\small$p_{\vartheta_i}^{d^{cap}} \gets f^{cap}(p_{\vartheta_i}^{d,*})$}, from \eqref{eq:cap} \label{line:cap}\;
                {\small$EQT(\vartheta_i) \gets 1$\label{line:eqtgets1}}, \; {\small$EQP(\vartheta_i) \gets EQP(\vartheta_i)+p_{\vartheta_i}^{d^{cap}}$}\label{line:probincrease}\;
                 \label{line:pacomputed}
                %\uIf{$x=PA$}{
                    $X_\Sigma \gets \,X_\Sigma+ (N-1)~r_{\vartheta_i}~p_{\vartheta_i}^{d^{cap}}~E_{\vartheta_i}$
                }
            }\If{$|EQP- EQP_{old}| \leq tol$ \label{line:equilibrium}}{
                Exit\;
        }
    }
    \caption{Distributed algorithm for NE.}
    \label{algorithm}
\end{algorithm}
\end{small}

Further privacy concerns can be handled by encrypting the values of $EQT$ and $EQP$ at each iteration and appropriately authenticating users that will be able to decrypt only the entries of $EQT$ and $EQP$ that correspond to their type. However, if the first and second consumers to play are of the same type, then the second in row consumer may infer the type of the first one. To avoid this we should enforce that the second consumer type to play does not have the same energy profile as the first one. %, which should be possible in practical cases that are expected to have a large number of consumer types. %Such an encryption could ensure that a consumer is able to read only information with respect to its own profile. However, if the second in row computing consumer type has the same profile as the first one, the profile of the first consumer type is revealed. To avoid this, the first consumer type could choose a set of profiles including its own and impose that the second consumer does not have a profile in this set. This can easily be achieved if the number of consumer types is sufficient, which is a realistic assumption. 
In the special case of $N=M$, broadcasting $EQT$ and $EQP$ is not needed; the computing consumer requires only the current value of $X_\Sigma$.
 
%The optimization problem solved in lines \ref{line:min1}-\ref{line:min2} is a best response one, similarly to the algorithms of \cite{jacquot18}. In addition, in lines \ref{line:PAconstr} and \ref{line:ESconstr}, the algorithm imposes constraints in order to compute probabilities that satisfy the necessary conditions for NE, as obtained by the analysis in Section \ref{sec:uncoordinated_extra_demand}. In line \ref{line:randomization}, we introduce randomization in the choice of $p^{x, *}_{RES, \vartheta_i} $, in order to avoid providing all the chances of competing for RES to the first in row examined consumer profiles. Due to this randomization, in order to ensure efficiency, i.e., competing for all the available RES, we introduce a second loop of iterations (line \ref{line:whileloop}) that terminates when the computed probabilities $Compt\_info\{2\}$ do not change from the previous iteration. Randomization stops after $MI$ iterations, so as to increase the chances that the external iterations (line \ref{line:whileloop}) will terminate. The chances increase due to our assumption that the users' aggregate demand exceeds the RSE capacity (Section \ref{sec:uncoordinated_extra_demand}).

%\begin{proposition}The algorithm terminates at a NE at a maximum of $N_{iter}+2$ external iterations. 
%\end{proposition}
%\begin{proof} In the cases where the algorithm applies consumers aim to opt for RES, each with the maximum possible probability in $[0,1]$. As a result, due to the constraints in lines \ref{line:PAconstr} and \ref{line:ESconstr}, at $iter^*$ at most equal to $MI+1$, the Eq. \eqref{eq:probrelation} or \eqref{eq:probrelationes} (depending on $x$) will be satisfied by the mixed strategies chosen by the algorithm or the mixed strategies will take the closest possible values to those satisfying \eqref{eq:probrelation} or \eqref{eq:probrelationes} due to their projection in $[0,1]$ (line \ref{line:projection}). According to the analysis in Section \ref{sec:uncoordinated_extra_demand}, these probabilities are NE. Due to the constraints imposed by the algorithm, at iteration $iter^*+1$, (obviously, at most equal to $MI+2$), the probabilities in $Compt\_info\{2\}$ cannot change; thus, it will be set $no\_exit=False$ and the algorithm will terminate at a NE. The termination of the algorithm might not happen in an earlier external iteration due to the randomization of line \ref{line:randomization}.
%\end{proof}

Finally, this algorithm schedules consumers' loads in daytime and nighttime intervals once, namely in the beginning of a daytime interval. However, in future work, we intend to study its repetition in a Model Predictive Control fashion over an intra-day time scale with time intervals of several hours, where at each repetition: (i) the consumers reconsider their daily energy demand profiles and exclude already served loads, (ii), the consumers reconsider their risk aversion degrees, and (iii) the forecast $\mathcal{RE}$ of the RES is updated. 