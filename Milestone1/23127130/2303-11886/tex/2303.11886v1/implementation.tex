\section{Implementation}
Most of our implementation is in C++ with some calls to Matlab routines for building the subspace.  All timings reported were performed on a Dell XPS i9-12900HK with a 2.90 GHz processor and 64GB of RAM, equipped with an NVIDIA GeForce 3050Ti graphics card.

\begin{algorithm}[]
   \caption{Subspace Construction : given rest positions $\boldsymbol{X}$, tet indeces $ \boldsymbol{T}$, an elastic energy hessian $\boldsymbol{H}$ a complementarity constraint matrix $\mathcal{J}$, compute a subspace composed of $\mathrm{m}$ skinning weights $\boldsymbol{W}$ and  $\mathrm{r}$ cluster labels $\boldsymbol{l}$ for our tets. \label{alg:skinningSubspace}}

 \SetKwFunction{FcomputeSubspace}{computeSubspace}
  \SetKwProg{Fn}{Function}{:}{}
\Fn{\FcomputeSubspace{$\boldsymbol{X}, \boldsymbol{T}, \boldsymbol{H}, \mathcal{J}, \mathrm{m}, \mathrm{r}$}}{
$\boldsymbol{H}_w \gets \mathrm{weightSpaceHessian}(\boldsymbol{H})$
\\
$\boldsymbol{M}_w \gets  \mathrm{massmatrix(\boldsymbol{X}, \boldsymbol{T})}$
\\
$\boldsymbol{J}_w \gets  \mathrm{weightSpaceConstraint}(\mathcal{J}, \boldsymbol{X})$
\\
$
\mathcal{H} \gets
\begin{bmatrix} 
\boldsymbol{H}_w & \boldsymbol{J}^T_w \\
 \boldsymbol{J}_w & \boldsymbol{0} 
\end{bmatrix}
\; \mathcal{M} \gets 
\begin{bmatrix} 
\boldsymbol{M} & \boldsymbol{0} \\
\boldsymbol{0} & \boldsymbol{0}
\end{bmatrix}
$
\\
$\boldsymbol{W}, \boldsymbol{V} \gets \mathrm{eigs}(\mathcal{H}, \mathcal{M}, \mathrm{m})$
\\
$\boldsymbol{W_t}  \gets \mathrm{averageOntoTets}(\boldsymbol{W} \boldsymbol{V}^{-2}, \boldsymbol{T})$
\\
$\boldsymbol{l}  \gets \mathrm{kmeans}(\boldsymbol{W}_t, \mathrm{r})$
\\
$\boldsymbol{l}  \gets \mathrm{splitComponents}(\boldsymbol{T}, \mathrm{l})$
\\
\KwRet $\boldsymbol{W}, \boldsymbol{l}$
}

 \SetKwFunction{FConstraint}{weightSpaceConstraint}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\FConstraint{$\mathcal{J}, \boldsymbol{X}$}}{
  $\boldsymbol{A} \gets 
[]$
\\
\For{$i\gets0$ \KwTo $\mathrm{dim}$}{
\For{$j \gets0$ \KwTo $\mathrm{dim}+1$}{
$\boldsymbol{A}_{i, j} \gets \mathrm{weightSkinningJacobian}(\boldsymbol{X}, i, j) \quad  \eqref{weight-space-complementary-constraint}$
\\
$\boldsymbol{A} \gets \begin{bmatrix}{} 	\boldsymbol{A}\\ 
	\mathcal{J}^T \boldsymbol{A}_{i, j} 
\end{bmatrix} $
}
}
$\boldsymbol{J}_w \gets \mathrm{removeRedundantRows} (\boldsymbol{A})$  
\\
\KwRet $\boldsymbol{J}_w$
  }
\end{algorithm} 
\begin{algorithm}[]
   \caption{performs one simulation step of our reduced Complementary Dynamics  using a linear Co-Rotated elasticity model \label{alg:simulationStep}}
 \SetKwFunction{FsimulationStep}{simulationStep}
  \SetKwProg{Fn}{Function}{:}{}
\Fn{\FsimulationStep{$\boldsymbol{p},\boldsymbol{z}_{hist}, \boldsymbol{p}_{hist},   \boldsymbol{f}_{ext}$}}{
$\boldsymbol{z} \gets \boldsymbol{0}$
\\
\While{$\mathrm{not\, converged}$}
{ 
$ \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}} \gets \mathrm{localStep}(\boldsymbol{z}, \boldsymbol{p})$
\\
$ \boldsymbol{z}_{next} \gets \mathrm{globalStep}(\boldsymbol{z}, \boldsymbol{p}, \boldsymbol{z}_{hist}, \boldsymbol{p}_{hist}, \boldsymbol{f}_{ext}, \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}})$
\\
$ \boldsymbol{z} \gets  \boldsymbol{z}_{next} $
}
\KwRet $\boldsymbol{z}_{next}$
}

 \SetKwFunction{FlocalStep}{localStep}
  \SetKwProg{Fn}{Function}{:}{}
\Fn{\FlocalStep{$\boldsymbol{z}, \boldsymbol{p}$}}{
$\boldsymbol{\tilde{f}} \gets \staticp{\boldsymbol{G_9K B}} \boldsymbol{z} + \staticp{\boldsymbol{G_9KJ_0}}\dynamicp{\boldsymbol{p}}$
\\
$ \boldsymbol{\tilde{F}} \gets \mathrm{reshape}(\boldsymbol{\tilde{f}}, [\mathrm{r}, \mathrm{dim} , \mathrm{dim} ])$
\\
$\frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{\tilde{F}}} \gets \mathrm{zeros}(\mathrm r, \mathrm{dim}, \mathrm{dim})$
\\
\For{$i\gets0$ \KwTo $\mathrm{r}$}
{
$\boldsymbol{F}_i \gets \boldsymbol{F}[i, :, :]$
\\
$ \boldsymbol{R}_i \gets \mathrm{PolarSVD}(\boldsymbol{F}_i)$
\\
$ \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{\tilde{F}}}[i] \gets -m_{i} \mu_{i} \boldsymbol{R}_{i} + m_{i} \frac{\lambda_i}{2} \boldsymbol{R}_i tr(\boldsymbol{R}_i^T \boldsymbol{F}_i - \boldsymbol{I})$
\\
}
$ \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}} \gets \mathrm{vec}(\frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{\tilde{F}}})$
\\
\KwRet $ \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}}$
}


 \SetKwFunction{FglobalStep}{globalStep}
  \SetKwProg{Fn}{Function}{:}{}
\Fn{\FglobalStep{$\boldsymbol{z},\boldsymbol{z}_{hist}, \boldsymbol{p}, \boldsymbol{p}_{hist},   \boldsymbol{f}_{ext}, \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}})$}}{
$\boldsymbol{f}_{elastic} \gets \staticp{\boldsymbol{B}^T \boldsymbol{LJ}} \dynamicp{\boldsymbol{p}} + (\staticp{\boldsymbol{G_9KB}})^T \frac{\partial \boldsymbol{\tilde{\phi}}}{\partial \boldsymbol{f}}  $
\\
$\boldsymbol{f}_{inertia} \gets \frac{1}{h^2}( \staticp{\boldsymbol{B}^T \boldsymbol{MJ}}\dynamicp{(\boldsymbol{p} - \boldsymbol{p}_{hist})} - \staticp{\boldsymbol{B}^T \boldsymbol{MB}} \dynamicp{\boldsymbol{z}_{hist}}) $
\\
$\boldsymbol{f} \gets  \boldsymbol{f}_{elastic} +  \boldsymbol{f}_{inertia} + \boldsymbol{f}_{ext}$
\\
$\boldsymbol{A} \gets \staticp{\boldsymbol{B}^T\boldsymbol{L}\boldsymbol{B}} + \frac{1}{h^2} \staticp{\boldsymbol{B}^T\boldsymbol{M}\boldsymbol{B}}$
\\
$ d\boldsymbol{z} \gets \boldsymbol{A} d\boldsymbol{z} = - \boldsymbol{f} - \boldsymbol{A}\boldsymbol{z} $
\\
$\alpha \gets \mathrm{lineSearch}(d\boldsymbol{z})$ 
\\
$\boldsymbol{z}_{next} \gets \boldsymbol{z} + \alpha d\boldsymbol{z} $
\\
\KwRet $\boldsymbol{z}_{next}$
}
\end{algorithm} 

\subsection{Subspace Construction}
Algorithm \ref{alg:skinningSubspace} provides pseudocode for the construction of our subspace. We require as input the rest state, an elastic energy Hessian, and a user-defined homogeneous linear equality constraint matrix $\mathcal{J}$, in our case the complementarity constraint matrix.
So far, for conciseness, we have stated that our complementarity  constraint matrix was equal to the rig jacobian $\mathcal{J} = \boldsymbol{J}$. However, as described by \cite{Zhang:CompDynamics:2020}, to make our complementarity constraint sensitive to the mesh resolution, it is also weighed by a mass-matrix.
Additionally the constraint matrix is weighed by a momentum-leaking matrix $\boldsymbol{D}$. This diagonal matrix with entries ranging form $0$ to $1$ specifies where momentum can leak from the rig to the mesh. By default, we compute these diagonal entries from a fast diffusion of the surface to the interior, and renormalize the values to lie between $0$ and $1$, which easily gives us standard \emph{follow-through} and \textit{anticipation} effects \cite{Zhang:CompDynamics:2020}. For additional control, a user can also customize and easily provide their own scalar field designed by a method of their choice. The final complementarity constraint matrix is $\mathcal{J}= \boldsymbol{D} \boldsymbol{M} \boldsymbol{J}$.

For the GEVP solver, we use Matlab's $\mathrm{eigs}$. We also remove redundant rows from our weight space complementarity constraint quickly using Matlab's $\mathrm{rref}$.
\subsection{Simulation Step}
Algorithm \ref{alg:simulationStep} provides an overview for the simulation step of our proposed method.
We color in \staticp{\staticColorName} matrix products that can be computed \emph{once} at the start of the simulation, cached and then called at run-time. We color in \dynamicp{\dynamicColorName} vectors that do not change throughout the multiple iterations of a single local-global solve. Products with these red vectors can be computed once at the start of the timestep step and reused throughout the timestep.
To solve the linear system for the Quasi-Newton search direction, we make use of a precomputed Cholesky Factorization. In the case of vanishing Poisson ratio, where Co-Rotational Elasticity becomes ARAP, we can safely remove the line search.

The individual constituents of these matrices are defined as follows:

\begin{itemize}
\item $\boldsymbol{B}=\Blbs$ is the linear blend skinning Jacobian matrix for our secondary weights $\boldsymbol{W}$, as computed by \refeq{linear-blend-skinning-matmul}. 
\item  $\boldsymbol{G}_{9} \in \mathbb{R}^{9 \numclusters \times 9\numtets}$ is our exploded cluster grouping matrix, computable from our per-cluster labels $\boldsymbol{l}$ and our rest geometry, that performs a mass-weighed averaging of the 9 deformation gradient quantities for all tetrahedra belonging to a cluster. 

\item 
$\boldsymbol{K} \in \mathbb{R}^{9 \numtets \times 3n}$ is a standard vector gradient operator, which maps displacements of vertices to deformation gradients on tetrahedra  \cite{KimDynamicDeformables}.

\item 
$\boldsymbol{L} = \boldsymbol{K}^T \mathcal{U} \boldsymbol{V} \boldsymbol{K} \in \mathbb{R}^{3n \times 3n}$ is the heterogeneous Laplacian operator. ($\mathcal{U}$ and $\boldsymbol{V}$ are $9\numtets \times 9\numtets$ diagonal matrices containing the first Lam\'e parameter and volume respectively for each tetrahedron on their diagonal).

\item 
$\boldsymbol{M} \in \mathbb{R}^{3n \times 3n}$
is the vector mass matrix.

\item 
$\boldsymbol{J} \in \mathbb{R}^{3n \times \dimp}$ is the
rig Jacobian for our \textit{primary} rig.
\end{itemize}

% For large number of clusters and large number of modes, the bottleneck of our approach becomes the matrix multiplication in both the local step and the global step involving $\staticp{\boldsymbol{G_9KB}}$ which is a $9c \times 12m$ matrix. For low number of clusters, but large number of modes, the bottleneck becomes the 
% The local step local step  step can be parallelized for further speedup.

We can leverage the fact that our subspace just performs linear blend skinning to project our low dimensional output $\boldsymbol{z}_{next}$ to the full space entirely on the GPU. We implement this projection step in the vertex shader, where we load the initial skinning weights as vertex attributes, and then pass the updated  $\boldsymbol{z}_{next}$ as a uniform variable each draw call.

% \Otman{
% For long term-storage, to avoid recomputing our subspace, we only need to save to disk 8 matrices : $\staticp{\boldsymbol{W}}$, $\staticp{\boldsymbol{l}}$, $\staticp{\boldsymbol{G_9KB}}$, $\staticp{\boldsymbol{G_9KJ}}$, $\staticp{\boldsymbol{BLJ}}$,
% $\staticp{\boldsymbol{BMJ}}$, $\staticp{\boldsymbol{BLB}}$, $\staticp{\boldsymbol{BMB}}$.
% This  requires the storage of
% $288\mathrm{m}^2 + 12\mathrm{m}\mathrm{c} + 12 \mathrm{r}\mathrm{c} + 9 \mathrm{c}\mathrm{m} + \mathrm{k} + \mathrm{n} \times \mathrm{m}$ floating point entries. 
% }