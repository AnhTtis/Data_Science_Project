
\section{Experiments \& Discussion}
We evaluate the effectiveness of our skinning subspace for deformation by comparing it to a suite of common deformation subspaces.  In our qualitative comparisons, we consider equal dimensional subspaces (e.g. 48 displacement modes = 12 degrees of freedom * 4 skinning eigenmodes). While this puts CPU computation on equal footing, we emphasize that our skinning eigenmodes use significantly less GPU memory in a vertex shader implementation ($12 \times$).

\subsection{Comparison to Modal Derivatives}
Modal derivatives \cite{BarbicJames:RealTimeSTVK} augment the primary displacement subspace with a second set of modes that aim to correct the primary modes as they fall out of date with large deformations. This effectively makes the subspace \emph{quadratic} instead of linear.
% \reffig{spoon-modal-fitting-comparison} stress tests modal derivatives in the low mode regim. We perform a least-squares fitting task on the target deformation of the green spoon and compare their subspace with our skinning eigenmodes.
% Specifically we first bend the spoon about its length, a localized rotation, and observe that both our subspace and modal derivatives provide a strong reconstruction.
% However, if we take that bent reconstruction and simply rotate it about any axis, we find that that their deformation no longer lies in the space of motions spanned by the modal derivatives subspace, whereas our does. This directly follows from the fact that modal derivative subspaces are not closed under rotations, while our skinning eigenmodes are.
Unfortunately, modal derivatives are not closed under rotations. We show how this expresses itself in an elastic simulation in  \reffig{subspace-comparisons}. We compare 3 subspace simulations:  60 displacement modes, 11 displacement modes augmented with 49 modal derivatives, and 10 skinning modes (corresponding to 60 total d.o.f.s in 2D). While modal derivatives greatly enrich the space available to the elasto-dynamics, they provide unintuitively different deformations under rotations.
 By contrast, our subspace allows for the lowest energy at equilibrium, maintains a consistent equilibrium shape (and energy) no matter the orientation.

 \reffig{moray-rotation-equivariance} shows how this shortcoming manifests itself in our use case of fast complementary dynamics.  In this example, a user applies small repeated rotations about the y-axis on a single affine handle controlling the moray eel, mimicking a swiming motion. Rig momentum is allowed to leak from the rig to the eel to induce secondary motion. Then, the user rotated the eel about the z-axis 90 degrees, making the eel swim sideways.  As a user performs this rotation they would expect the resulting simulation to be identical up to a rotation as well, a property our 14 (168 d.o.f.s) skinning modes guarantee.Unfortunately the same cannot be said of a simulation using a modal derivative subspace of slightly greater size than ours.
 In this example, 17 primary modes augmented with a  full set of 153 modal derivatives (for a total of 170 d.o.f.s) were used to construct the modal derivative subspace. Like our skinning eigenmodes, was also constrained to satisfy the complementarity constraint by construction.
 
 Both methods benefit from performing a full-space projection step (to update the visualizion) on the GPU. As a linear blend skinning subspace, we can perform this step at a much smaller memory cost for the vertex shader. For a full space projection step with $k=d(d+1)m$ degrees of freedom, modal derivatives would require $k$-vec4's in vertex shader memory, whereas ours would only require $m$.

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/bar_modal_warping_comparison-1.png}\timestamp{\tsBarModalWarpingComparison}
\caption{ Our skinning subspace (right) can easily represent twisting motions, something displacement modes struggle with, even with localized rotation fitting. 
 \label{fig:modal-fitting-rotation-clusters-comparison}}
\end{figure}


\subsection{Comparison to Sub-Structuring and Modal Warping}
Perhaps the most intuitive way ensuring our subspace is closed under rotations is by warping the subspace manually with a single best fit rotation. This corresponds to a simplified version of both sub-structuring and modal warping \cite{Barbic:2011:RealTimeLargeDefoSubstructuring, KimJamesMultiDomainStitching, ModalWarping}. While this indeed would fix the simulation rotation equivariance problem, it comes at the cost of not being able to represent rotational motion within each sub-structure, as shown didactically in \reffig{modal-fitting-rotation-clusters-comparison}.
Increasing the number of sub-structures  would mitigate this, but still requires the user to warp the subspace associated with each vertex every timestep, a full space operation. 
Accelerating this update at each using the Fast Sandwich Transform (FST) proposed by \cite{KimJamesMultiDomainStitching} is certainly possible for terms \emph{linear} in $\boldsymbol{B}$. However, it requires the reassembly of all linear pre-computed matrices involving $\boldsymbol{B}$, summing the contributions of each of the 9 rotation parameters \textit{for each} new sub-structure. Albeit accelerated compared to a na{\"\i}ve update, the FST update nevertheless becomes the bottleneck of our method, limiting the richness of the overall dynamics we can get for real-time rates. The FST also incurs a memory cost; in 3D, the aforementioned precomputed matrices must be stored separately 9 times \textit{for each} new rotation cluster.  On top of this, the FST would not allow us to efficientily update terms that are non-linear with respect to $\boldsymbol{B}$, such as our system matrix or our Cholesky prefactorization.

% Modal Warping specifically can be seen as an extreme case of sub-structuring, taking the limit as the number of substructures corresponds to the number of vertices, and allowing sub-structures to overlap as dictated by vertex neighborhood.
% Unfortunately, these warped modes have no guarantee on being optimal with respect to the deformed state, and very frequently lead to jarring undesired artifacts as seen in \reffigmodal-fitting-rotation-clusters-comparison}, results which echo those found in the comparisons of
% \citet{RScoords, SubspaceRSDof}. 
By contrast, our skinning subspace can represent twisting motions with a single static subspace computed once in a precomputation phase and \emph{never} updated again.


\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/giraffe_RS_comparison_2-1.png}\timestamp[-0.125cm]{\tsGiraffeRSComparison}
\caption{ Rotation Strain 
  coordinates \cite{RScoords} are not well suited for reconstructing shapes undergoing rotational motion, as is commonly imposed by control rigs. Our subspace can fit this complex localized rotational motion with only 10 skinning modes.
 \label{fig:rs_comparison}} 
\end{figure}


\begin{figure}[!t]
\includegraphics[width=\linewidth,keepaspectratio]{images/stingray_hildebrandt_modes-1.png}
\caption{Adopting  ICCM \cite{Brandt2017CompressedVibrationModesofElasticBodies} allows us to reconstruct the higly localized reference deformation (left) using a least squares fit, a task in which traditional global modes struggle. We build our local modes (bottom) with a sparsity regularization parameter $\eta=100$ and only fit the first 5 modes for each. 
\label{fig:stingray-local-vs-global-modes-1.png}}
\end{figure}


\subsection{Comparison To Rotation Strain Coordinates}
Rotation strain coordinates  \cite{RScoords} fix linearized deformation artifacts that arise out of simulations using linear subspaces by projecting it to an energetically favorable pose.
They decompose the tetrahedron's deformation gradient 
$\boldsymbol{F} = \boldsymbol{r} + \boldsymbol{s} + \boldsymbol{I}$ 
into a symmetric shear part $\boldsymbol{s}$ and antisymmetric linearized rotation part $\boldsymbol{r}$.
The linearized rotation is then projected to a full rotation matrix via an exponential map 
$\boldsymbol{R} = \text{exp}(\boldsymbol{r})$, from which the deformation gradient is reconstructed as 
$\boldsymbol{F}' = \boldsymbol{R}(\boldsymbol{s} + \boldsymbol{I})$. 
The vertex positions $\boldsymbol{x}$ are determined by minimizing 
$|| \boldsymbol{K} \boldsymbol{x} - \boldsymbol{f}'||_{\boldsymbol{M}}$,
where $\boldsymbol{f}' = \text{vec}(\boldsymbol{F}')$.
As \reffig{rs_comparison} shows however, this formulation depends on the input deformation to be composed mainly of shear motions (as a normal displacement subspace would). If a user manipulating a shape through a rig created a rotation on the neck of the giraffe, Rotation Strain coordinates lead to an undesired reconstruction of the shape, 
rendering them less suitable for reconstruction over rig-like motion.
In fact, we can verify that for an input 2D rotational motion about the $z$-axis of $\frac{\pi}{2}$ leads to a target deformation gradient 
% F = 
% 0 -1 0
%  1 0 0 
% 0 0 1   
%
% F - I =
% -1 -1 0
%  1 -1 0 
%  0  0 0
%
% r = 
% 0 -1 0
% 1  0 0
%  0  0 0 
%
% s =
% -1 0 0
% 0 -1 0
% 0 0 0
%
\begin{align}
% \boldsymbol{F}' &= \text{exp}(
% \begin{bmatrix}
% 0 & -1 & 0 \\
% 1 & 0 & 0 \\
% 0 & 0 & 0
% \end{bmatrix}
% ) (\begin{bmatrix}
% -1 & 0 & 0 \\
% 0 & -1 & 0 \\
% 0 & 0 & 0
% \end{bmatrix} + \boldsymbol{I}) \nonumber \\
%  &= 
% \begin{bmatrix}
% \text{sin}(1) & -\text{cos}(1) & 0 \\
% \text{cos}(1) & \text{sin}(1) & 0 \\
% 0 & 0 & 1
% \end{bmatrix}
%  \begin{bmatrix}
% 0 & 0 & 0 \\
% 0 & 0 & 0 \\
% 0 & 0 & 1
% \end{bmatrix} \nonumber \\
\boldsymbol{F}' &=  \begin{bmatrix}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{bmatrix} \nonumber 
\end{align} 
which will act to collapse neighboring vertices to lie solely along the z-axis.
%
Furthermore, the Rotation Strain coordinates position fitting step may undo any constraints enforced in earlier steps, including our complementary constraint. Enforcing such constraints during position fitting would be interesting 
to investigate.
\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/constrained_vs_unconstrained-1.png}\timestamp{\tsConstrainedVsUnconstrained}
\caption{\label{fig:constrained_vs_unconstrained_reduced_cd_sim} Our rig-complementary subspace (right) composed of 14 skinning modes provide richer dynamics than an equal sized unconstrained subspace(left).}
\end{figure}
\subsection{Localized Skinning Subspaces}
Thanks to our generalized eigenvalue formulation, we can greatly benefit from prior work in localizing and sparsifying PCA/Modal analysis subspaces \cite{Nasikun2018, melzi2018localized, compressedModesADMM}. As an example, we can promote sparsity and locality in our modes to by applying the  \emph{iterated convexification for
compressed modes} (ICCM) \citep{Brandt2017CompressedVibrationModesofElasticBodies} algorithm. This amounts to simply adding an L1 regularization term to our minimization in \eqref{gevp-skinning-modes-constrained}. The result is a subspace that can faithfully capture local deformations as shown in
\reffig{stingray-local-vs-global-modes-1.png}. 
The skinning modes' closure under rotation, critical for producing rotation equivariant results, naturally
inherits the locality presented by the skinning weights:
observe that Eq.~\eqref{eq:linear-blend-skinning}
is a superposition of the closure of every mode $b$ in isolation: 
\begin{align}
w_{ib} \left( \boldsymbol{R}\boldsymbol{T}_b\right) \begin{bmatrix} \boldsymbol{x}_{0i} \\ \boldsymbol{1} \end{bmatrix} = \boldsymbol{R} \left(w_{ib} \boldsymbol{T}_b \begin{bmatrix} \boldsymbol{x}_{0i} \\ \boldsymbol{1} \end{bmatrix}\right)\, .
\end{align}


\subsection{Comparison to Coarsening Meshes}
A common approach to accelerating elasto-dynamics for real-time applications is to embed a fine mesh inside a coarse one, solve the elasto-dynamics on the coarse mesh, and then map the final motion back to the fine mesh via the embedding.

This corresponds to a very specific subspace $B_{embed}$; one that is very sparse, highly localized, can represent rotations, and maintains simulation rotation equivariance. 
Unfortunately, its construction from a coarse mesh embedding groups fine scale features that are close in Euclidean space whose motion should not be correlated. This leads to visible embedding artifacts as shown in \reffig{coarsening-meshes}. 
 \
To compare, our subspace couples motion of vertices as measured by the elastic energy.

\subsection{Discussion on Material Sensitivity}
An important feature that distinguishes our skinning weights from those of \citet{1Gilles2011} or \citet{Wang:2015:LinearSubspaceDesign} is that our skinning weights are \emph{material}-aware. We show that this directly leads to richer dynamics when dealing with subspace simulations of heterogeneous materials, as shown in \reffig{heterogeneous-skinning-modes}.

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/corot-subspace-comparison-1.png}
\caption{ Our skinning subspace can easily capture volume-preserving effects for non-zero poisson ratio, and maintains such high quality deformations under any rotations of the rest frame.
 \label{fig:co-rotational-material-example-2D}}
\end{figure}

Because our final  weight space Hessian in \refeq{weight-space-hessian} does not capture any coupling interactions between the dimensions of our simulation, it is invariant to changes in the poisson ratio, which appear in the off-diagonal entries of the full space hessian $\boldsymbol{H}$. Fortunately, our skinning subspace can form non-unform scales and shears, which allow it to excellently capture volume preserving effects with very few skinning modes, as shown in \reffig{co-rotational-material-example-2D}.

\subsection{Importance of Constraining Subspace}
Our formulation greatly benefits from the fact that we can easily impose our complementarity constraint upon the construction of our subspace, something the prior work of \citet{Tycowicz2013, Faure2011} cannot do. 

Without this property, we'd have to impose our constraint at run-time. A user is burdened with having to select a subspace with more degrees of freedom than the constraint set in order to avoid an over-constrained system. To make things worse, the constraints for our primary rig can quickly climb in dimensionality; for a linear blend skinning control rig, every new bone brings with it $d(d+1)$ new columns in our complementarity constraint matrix $\boldsymbol{J}$ in our complementarity constraint.
\reffig{constrained_vs_unconstrained_reduced_cd_sim} shows a primary control rig composed of 14 bones (168 constraints). In order for a simulation to avoid being over-constrained, the user would then have to prescribe over 14 skinning modes (168) degrees of freedom. 
In contrast, our subspace frees the user from this dilemma, and allows the user to pick the dimensionality of the subspace without worrying about the well-posedness of the simulation.

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/crocodile_corotational_vs_arap-1.png}\timestamp{\tsCrocodileCorotVsARAP}
\caption{ We observe volume preserving effects made possible by accommodating co-rotational elasticity.  \label{fig:corotational-vs-arap-dragon-head} }
\end{figure}

\subsection{Evaluating Co-Rotational Elasticity}
We generalize the clustering based local global solver of \citet{Jacobson-12-FAST} to work with a more general material model of Linear Co-Rotational Elasticity \cite{McAdams2011}. We show a simple example in \reffig{co-rotational-material-example-2D} that shows how our subspace simulation with 50 clusters and 10 skinning modes can incorporate smooth volume preserving effects. 

\reffig{corotational-vs-arap-dragon-head} highlights that these volume preserving effects have a noticeable visual impact on the secondary dynamics. 
Unfortunately, such non-linear effects aren't free, a non-zero Poisson's ratio incurs the cost of tacking on a line search at the end of our solver's global step \cite{QuasiNewtonLiu2017}. Evaluating the energy for the line search requires re-computing per-cluster deformation gradients, a $O(rm)$ operation that corresponds to the slowest part in our simulation pipeline for large modes and large clusters. While this does sometimes hinder the speed of our simulation step, we have found that there are large portions of the mode/cluster parameter space that easily accommodate this computational overhead while still providing rich dynamics. 


 \begin{wrapfigure}{r}{5cm}
\includegraphics[width=\linewidth,keepaspectratio]{images/cluster_mode_pareto_front-1.png}
\end{wrapfigure}

\subsection{Mode/Cluster Pareto-Front}
We evaluate how our per-timestep cost changes with the size of our subspace skinning modes and the number of clusters used. The inset highlights the 30 FPS real-time pareto front. For each trial, the same timestep was run 100 times until convergence on an ARAP elasticity model.




 \begin{wrapfigure}{r}{5cm}
\includegraphics[width=\linewidth,keepaspectratio]{images/mode_construction_changing_rig-1.png}
\end{wrapfigure}

\subsection{Computing Our Modes}
Because our weight space Hessian is $n \times n$, compared to the traditional full space $n(d) \times n(d)$ Hessian, solving for our subspace is naturally faster for higher dimensions, as shown in Table \ref{table:mode-computation-timings}. Applying the complementarity constraint on our modes means augmenting the weight space Hessian $\boldsymbol{H}_w$ in our weight computation with our weight-space complementarity constraint $\boldsymbol{J}_w \in \mathbb{R}^{n \times \dimp (d)(d+1)}$. This makes mode computation naturally more computationally expensive for more complicated rigs.  The inset shows how changing the number of rig parameters in a control rig affects how long it takes to compute 10 skinning modes on the elephant mesh.
\begin{table}
\rowcolors{2}{white}{cyan!25}
\begin{tabular}{c|c|c|c}
      \textbf{Mesh} & \textbf{\#Vertices} &\textbf{ Disp.(s)} & \textbf{Ours(s)}  \\
     Elephant & 7842  & 0.782  &\textbf{ 0.135}\\
     Bulldog & 31368  & 6.76  & \textbf{0.830}\\
     XYZ Dragon & 99813  & 62.3 & \textbf{5.14} \\
     King Ghidora & 294033  & 143.4 & \textbf{14.07}  
\end{tabular}
\caption{Computing 10 of our skinning modes (120 d.o.f.s) is much faster than computing 120 displacement modes (120 d.o.f.s) subspace of an equivalent size.
\label{table:mode-computation-timings}}
\end{table}








