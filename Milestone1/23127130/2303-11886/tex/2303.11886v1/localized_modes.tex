\subsubsection{Localized Modes}
Given a locality length scale $r$ and a center of locality $\boldsymbol{c}_i$, we aim to find a set of modes that are entirely located within a specific region of the mesh $\boldsymbol{S}^T (\boldsymbol{c}_i; r) \boldsymbol{b}_i= \boldsymbol{0}$, where $\boldsymbol{S} \in \mathbb{R}^{n \times m}$ is a selection matrix that selects the m-vertices that are \emph{not} within our region of locality.

We treat the locality length scale $r$ as an input user parameter, and the centers of locality as degrees of freedom in our GEVP energy minimization. Enforcing the constraint above into our GEVP:

\begin{align}
\argmin_{\boldsymbol{b}_i, \boldsymbol{c}_i}\,&  \boldsymbol{b}_i^T \boldsymbol{H} \boldsymbol{b}_i \\  \text{s.t.} \quad \boldsymbol{S}(\boldsymbol{c}_i; \boldsymbol{r}) \boldsymbol{b}_i = \boldsymbol{0} \quad  & \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{b}_i = 1 \quad  \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{b}_j = 0  \quad  \forall j \neq i 
\label{eq:gevp-with-locality-minimization}
\end{align}



We minimize the above energy using block coordinate descent.
\paragraph{Global Step}

\begin{align}
\argmin_{\boldsymbol{b}_i}\,&  \boldsymbol{b}_i^T \boldsymbol{H} \boldsymbol{b}_i \nonumber  \\  \text{s.t.} \quad \boldsymbol{b}_i^T {\boldsymbol{S}^{n-1}}  = \boldsymbol{0} \quad  & \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{b}_i = 1 \quad  \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{B} = 0  \nonumber
\end{align}

We can introduce $\boldsymbol{u}_i = \boldsymbol{C}^T\boldsymbol{b}_i$
\begin{align}
\argmin_{\boldsymbol{u}_i}\,&  \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{H} \boldsymbol{C} \boldsymbol{u}_i \nonumber  \\  \text{s.t.} \quad   & \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{M}\boldsymbol{C} \boldsymbol{u}_i = 1 \quad  \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{M} \boldsymbol{B} = \boldsymbol{0}  \nonumber
\end{align}

Enforcing the linear equality constraint via lagrange multipliers:

\begin{align}
\argmin_{\boldsymbol{u}_i, \boldsymbol{\mu}_i}\,&  \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{H} \boldsymbol{C} \boldsymbol{u}_i + \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{M} \boldsymbol{B} \boldsymbol{\mu}_i \nonumber  \\  \text{s.t.} \quad   & \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{M}\boldsymbol{C} \boldsymbol{u}_i = 1 \nonumber
\end{align}

Enforcing the quadratic constraint via Lagrange multipliers:

\begin{align}
\argmin_{\boldsymbol{u}_i, \boldsymbol{\mu}_i, \lambda_i},  \,&  \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{H} \boldsymbol{C} \boldsymbol{u}_i + \boldsymbol{u}_i^T \boldsymbol{C}^T \boldsymbol{M} \boldsymbol{B} \boldsymbol{\mu}_i + \boldsymbol{u}_i^T (\boldsymbol{C}^T \boldsymbol{M}\boldsymbol{C} \boldsymbol{u}_i - 1) \lambda_i \nonumber 
\end{align}

Deriving the KKT optimality conditions:

\begin{align}
2 \boldsymbol{C}^T \boldsymbol{H} \boldsymbol{C} \boldsymbol{u}_i +  \boldsymbol{C}^T \boldsymbol{M} \boldsymbol{B} \boldsymbol{\mu}_i +  2\boldsymbol{C}^T \boldsymbol{M}\boldsymbol{C} \boldsymbol{u}_i \lambda_i 
 = \boldsymbol{0} \nonumber \\
 \boldsymbol{C}^T\boldsymbol{M}   \boldsymbol{B}  \boldsymbol{u}_i = \boldsymbol{0} \\
\boldsymbol{u}_i^T\boldsymbol{C}^T \boldsymbol{M}\boldsymbol{C} \boldsymbol{u}_i = 1
 \nonumber
 \end{align}
 
Which we can rewrite as the constrained GEVP:

\begin{align}
\begin{bmatrix}
\boldsymbol{C^THC} & \boldsymbol{C}^T\boldsymbol{M} \boldsymbol{B} \\
\boldsymbol{B}^T \boldsymbol{M} \boldsymbol{C} & \boldsymbol{0}
\end{bmatrix}
\begin{bmatrix}
\boldsymbol{u}_i  \\
\boldsymbol{\mu}_i  
\end{bmatrix} =
\lambda_i
\begin{bmatrix}
\boldsymbol{C}^T \boldsymbol{M} \boldsymbol{C} &
\boldsymbol{0} \\ \boldsymbol{0} & \boldsymbol{0}
\end{bmatrix}
\begin{bmatrix}
\boldsymbol{u}_i  \\
\boldsymbol{\mu}_i  
\end{bmatrix}
\end{align}

\paragraph{Local Step}

Starting from  Equation \ref{eq:gevp-with-locality-minimization}, we can enforce our locality constraint through Lagrange multipliers:
\begin{align}
\argmin_{ \boldsymbol{c}_i, \boldsymbol{\gamma}_i}\,&  \boldsymbol{b}_i^T \boldsymbol{H} \boldsymbol{b}_i + \boldsymbol{\gamma}^T_i \boldsymbol{S}(\boldsymbol{c}_i; \boldsymbol{r}) \boldsymbol{b}_i \\  \text{s.t.}  \quad  & \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{b}_i = 1 \quad  \boldsymbol{b}_i^T \boldsymbol{M} \boldsymbol{b}_j = 0  \quad  \forall j \neq i 
\end{align}
We then omit all terms that do not depend on our center of locality $\boldsymbol{c}_i$
\begin{align}
\argmin_{ \boldsymbol{c}_i, \boldsymbol{\gamma}_i}\,&  \boldsymbol{\gamma}_i^T \boldsymbol{S}(\boldsymbol{c}_i; \boldsymbol{r}) \boldsymbol{b}_i 
\end{align}
The above optimization problem penalizes non-zero terms that exist outside of our region of locality $\boldsymbol{S}(\boldsymbol{c}_i, r)\boldsymbol{b}_i$.  This is equivalent to maximizing the number of  non-zero terms inside our region of locality.
\begin{align}
\argmax_{ \boldsymbol{c}_i}\,&  \boldsymbol{C}(\boldsymbol{c}_i; \boldsymbol{r}) \boldsymbol{b}_i 
\end{align}
We can leverage the fact that the only possible number of $\boldsymbol{c}_i$ is finite because our problem is discrete. We can find $\boldsymbol{c}_i$ in O(n) time with the right data structure.  \Otman{Get back to this, maybe will omit this section entirely based on the decision we come to}