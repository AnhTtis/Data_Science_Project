
\subsection{Clustering}
% 
\alec{We should separate ``clustered elasticity'' (where we have a moderate contribution for $\nu > 0$) and ``how we make clusters'' (where we don't have much of a contribution and probably we could really improve things)}

We describe a general clustering-based approach to accommodate non-linear elastic energies $E(\boldsymbol{u}^c)$ and to maintain a mesh resolution independent simulation step. We start by presenting our approach very broadly, and show how to apply the methodology specifically to an ARAP elastic energy and a Co-Rotational elastic energy.

We assume an elastic energy that can be decomposed into the sum of a quadratic and a non-linear energy terms, $\Psi$ and $\Phi$ respectively, that are piece-wise constant over each tetrahedron $t \in \mathcal{T}$ in our mesh. 

\begin{equation}
    E(\boldsymbol{u}^c) = \underbrace{\sum_t^\mathcal{T} \Psi_t(\boldsymbol{u}^c)}_{quadratic} + \underbrace{\sum_t^\mathcal{T}  \Phi_t(\boldsymbol{u}^c)}_{non-linear}
\end{equation}

The sum over tetrahedra in the first term can be rewritten in simple matrix vector notation; a sum of quadratics is a quadratic as well. Starting with the general form of a quadratic energy for the first term and plugging in $\boldsymbol{u}^c = \boldsymbol{B} \boldsymbol z$ we can re-express this energy entirely in terms of reduced space operations.

\begin{equation}
\sum_t^\mathcal{T} \Psi_t(\boldsymbol{u}^c)  = \frac{1}{2} \boldsymbol{z}^T  \underbrace{\boldsymbol{B}^T \boldsymbol{\mathcal{H}} \boldsymbol{B}} \boldsymbol{z} + \underbrace{\boldsymbol{B}^T \boldsymbol{\mathcal{J}}^T}\boldsymbol z
\end{equation}

Where $\boldsymbol{\mathcal{H}}$  is a matrix of quadratic coefficients and $\boldsymbol{\mathcal{ J}}$ is a vector of linear coefficients. 

We focus now on the non-linear term, which in general is difficult to express in our reduced space basis. In particular, we can no longer simply rewrite this sum into a pre-computable system matrix $\boldsymbol{\mathcal{H}}$ like we did in the quadratic term. As a result, evaluation of this energy at run-time requires per-tet computation. To avoid this, we introduce a second set of acceleration parameters, tetrahedron \textit{clusters}. 

The intuition is that many tetrahedra will often exhibit similar energy profiles. In such cases we group these similar deforming tets into a \textit{cluster}. Then,  we only compute a single non-linear energy contribution term for each cluster, and simply use the same one for the other tetrahedra belonging to that cluster. Assuming we pick less clusters than there are tetrahedra, our speed-up is \textit{assured}. 


We now rewrite the second non-linear energy term in terms of per-cluster contributions. 

\begin{equation}
\sum_t^\mathcal{T} \Phi_t(\boldsymbol{u}^c)  \approx \sum_c^\mathcal{C} \Phi_c(\boldsymbol{u}^c)
\end{equation}

In order to rewrite our non-linear term as a function of our reduced space coefficients, we need to make one final assumption about the structure of our per-tetrahedron energy. We assume that the per-tetrahedron energy can be fully rewritten in terms of the per-tetrahedron deformation gradient $\Phi_{t}(\boldsymbol{u}^c) = \Phi_{t}(\boldsymbol{u}^c)  = \Phi_{t}(\boldsymbol{F}_t) $ $ \boldsymbol{F}_t \in \mathbb{R}^{ 3 \times 3}$. We can concatenate a list of flattened deformation gradients into a vector $\boldsymbol{\bar{F}} \in \mathbb{R}^{9t\times 1}$ and in turn express it as a simple linear function of our complementary displacement field $\boldsymbol{\bar{F}}  = \boldsymbol{K} \boldsymbol{u}^c + \boldsymbol{H}$ as derived in the Appendix \ref{section:Appendix}.
\Otman{We can relax and generalize this assumption (dependance on F) a bit more though.} 

We introduce the grouping matrix $\boldsymbol{G}_\Sigma \in \mathbb{R}^{\mathcal C \times \mathcal T}$, which sums contributions from individual tetrahedra over all clusters. Equipped with our grouping matrix, we approximate the second non-linear term:


%\begin{align*}
%\Psi (\boldsymbol{u}^c)  &= \frac{1}{2}{\boldsymbol{u}^c}^T \boldsymbol{\mathcal H} \boldsymbol{u}^c - \boldsymbol{\mathcal{J}}^T \boldsymbol{u}^c \\
%\Phi (\boldsymbol{u}^c) &= \frac{1}{2}
%\end{align*}



\subsubsection{Elastic Energy Gradient Evaluation}
Many elastic energies and their gradients rely on integrating per-tetrahedral strain quantities. To facilitate discussion, we assume a linear co-rotational elastic energy \cite{SifakisNotes}, but our clustering scheme could theoretically be used for any energy that is written as a function of per-tetrahedral deformation gradients. 

\begin{align}
E(\boldsymbol{u}^c) &= \int_\Omega \Psi(\boldsymbol F) d\Omega \\
&= \int_\Omega \frac{\mu}{2} ||\boldsymbol F - \boldsymbol R||^2_F +  \frac{\lambda}{2} ( tr(\boldsymbol R^T \boldsymbol F - \boldsymbol I))^2 d\Omega 
\end{align}

Where $\boldsymbol F \in \mathbb{R}^{3x3} = \frac{\partial \boldsymbol x}{\partial \boldsymbol X} = \frac{\partial \boldsymbol u^c}{\partial \boldsymbol X} + \frac{\partial \boldsymbol{u^r}}{\partial \boldsymbol X} + \boldsymbol I$ is the per tetrahedron deformation gradient, measuring how a deformed position $\boldsymbol x$ changes in each direction as we perturb our rest configuration. We assume linear elements, and as a result this deformation gradient is piecewise constant over each tetrahedron. $\boldsymbol R \in \mathbb{R}^{3 \times 3}$ is a per-tetrahedron rotation, obtained commonly via a polar decomposition of $\boldsymbol F$. The first term penalized shear and scaling deformations and the second term penalizes volume change, both done while remaining invariant to rotations. The Lam√© parameters $\mu$ and $\lambda$ allows us to weigh these two elastic properties for our material. We're particularly interested in the gradient of this energy for each tetrahedron.

\begin{align}
\frac{\partial E(\boldsymbol{u}^c)}{\partial \boldsymbol{u}^c} &=  
\int_\Omega \frac{\partial \boldsymbol{F}}{\partial \boldsymbol u^c}^T \frac{\partial \Psi(\boldsymbol{F})}{\partial \boldsymbol{F}}  d\Omega\\
 &=\int_\Omega \frac{\partial \boldsymbol{F}}{\boldsymbol u^c}^T \underbrace{( \mu (\boldsymbol F  - \boldsymbol R) + \lambda tr(\boldsymbol R^T \boldsymbol F - \boldsymbol I)\boldsymbol R)}_{\boldsymbol{\Phi}}  d\Omega
\label{eq:gradient_corot_2}
\end{align} 

We denote the constant per-tetrahedron quantity $\frac{\partial \Psi(\boldsymbol{F})}{\partial \boldsymbol{F}}$ with $\boldsymbol \Phi$ for convenience.  We can efficiently compute all per-tetrahedra deformation gradients $\boldsymbol{F}$ from our displacements and reduced space coefficients through a simple matrix multiplication:
\begin{align}
    \boldsymbol{\bar{F}} &= \boldsymbol{K} \boldsymbol u^c + \boldsymbol{K} \boldsymbol u^r +  \boldsymbol{\bar{I}} \\
     &= \boldsymbol{K} \boldsymbol{B} \boldsymbol z + \boldsymbol{K} \boldsymbol u^r +  \boldsymbol{\bar{I}}
     \label{eq:full_deformation_gradient_from_reduced_coefficients}
\end{align}

Where we introduce $\boldsymbol{\bar{F}} \in \mathbb{R}^{9|T|}$ to denote a list of flattened deformation gradients. $\boldsymbol{\bar{I}} \in \mathbb R^{ 9|T|}$ is a  similar list of flattened identity matrices for each tetrahedron, and the sparse matrix $\boldsymbol{K} \in \mathbb{R}^{9|T| \times 3n}$ maps displacements to their contributions in the deformation gradient and is derived in the appendix \Otman{write this section in the appendix}. 
Splitting up Equation \ref{eq:gradient_corot_2} into the piecewise constant contributions from each tetrahedra, we can write a compact matrix expression to efficiently compute the discrete full space gradient $\boldsymbol{g}$.

\begin{align}
\boldsymbol{g} = \frac{\partial E(\boldsymbol{u}^c)}{\partial \boldsymbol{u}^c} =   \frac{\partial \boldsymbol{\bar{F}}}{\partial \boldsymbol u^c}^T  \boldsymbol{\mathcal{M}}\boldsymbol{\bar{\Phi}} = \boldsymbol{K}^T  \boldsymbol{\mathcal{M}}\boldsymbol{\bar{\Phi}}
\label{eq:discrete_gradient_corot}
\end{align} 

$\boldsymbol{\bar{\Phi}} \in \mathbb{R}^{9|T|}$ denotes another list of flattened per tetrahedra $\boldsymbol \Phi$ and $\boldsymbol{\mathcal{M}} \in \mathbb{R}^{9|T| \times 9|T|}$ is a diagonal matrix containing per-tetrahedra volumes. We now hold all the pieces required to compute the discrete energy gradient $\boldsymbol g$ from our reduced space coefficients $\boldsymbol z$. We first obtain the per tetrahedron deformation gradient $\boldsymbol{\bar{F}}$ using Equation \ref{eq:full_deformation_gradient_from_reduced_coefficients}. Then, for each tetrahedron we perform a polar decomposition on its deformation gradient $\boldsymbol F$ to achieve a corresponding best-fit rotation $\boldsymbol R$. Using these two per-tet quantities, we evaluate a list of $\boldsymbol Phi$, flatten them and stack them into them into $\boldsymbol{\bar{\Phi}}$. Finally, we use Equation \ref{eq:discrete_gradient_corot} to evaluate our final gradient.

While this current approach still has many steps that can be precomputed away, it will ultimately always require the computation of per tetrahedra quantities in $\boldsymbol{\bar{\Phi}}$. Unfortunately, our mesh may have a large number of tetrahedra, preventing even our reduced model from achieving interactive rates as shown in Figure \ref{fig:reduction-time-complexity}. 

\subsubsection{Clustering Methodology}
\alec{This section is way too long. Should be a paragraph.}
We prevent the gradient evaluation from scaling in time with the number of tetrahedra by making use of clustering, with the intuition that tetrahedra exhibiting similar motion could be reasonably approximated to have the same deformation gradient. This would allow us to only have to evaluate a single value of $\boldsymbol{\Phi}$ per \textit{cluster}, where we would obtain a performance boost when the number of clusters is smaller than the number of tetrahedra. 

\begin{wrapfigure}{r}{3.0cm}
\includegraphics[width=\linewidth]{images/cactus-clusters}
\caption{Clusters for the 2D cactus in Fig.~\ref{fig:cactus-modes}.}
\end{wrapfigure}
%
We make use of the very standard kmeans++ \cite{kmeanspp} clustering algorithm, grouping tets with similar features together. As input to this routine, we provide a set of per-tetrahedral features. 
We desire to delegate more clusters to regions of our mesh that will exhibit a lot of secondary motion, and less in regions that show very little motion. Our reduced subspace $\boldsymbol B$ encodes \textit{exactly} that sort of information! Each of its columns represents an energetically favourable deformations that satisfies complementarity. Even better, the columns are already sorted sorted in order of how favourable they are. As a result we make use of our constrained, reduced subspace $\boldsymbol B$ to build our tetrahedral features.

For each tetrahedron, we slice out the rows of $\boldsymbol B$ that belong to the four vertex indices incident on our tetrahedron; there will be 12, seeing as each vertex actually owns 3 rows (one for each of the 3D axes $\{x, y, z\}$). We concatenate the 3 rows for each vertex, then take take the mean over the remaining 4 rows and end up with a single feature vector $f \in \mathbb{R}^3m$.

We take note of \citet{Lipman:2010:BD} and follow the intuition that smaller magnitude modes should contribute more deformation information than high magnitude modes. As a result we divide each modal feature in our subspace vector by it's corresponding eigenvalue. We also find that as a result we get quickly diminishing returns on the number of modes we need to use to build our features, and obtain a very reasonable cluster set with only the first 5 modes as shown in Figure \ref{fig:diminishing_modal_returns}.

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/white.png}
\caption{\Otman{Our clusters using 1 mode, vs, 5 modes, vs 10, vs 100, while also showing how long it took to build them}}
\label{fig:diminishing_modal_returns}
\end{figure}

We compare our subspace features to using Euclidean features, and to using weight-space features as in \citet{Jacobson-12-FAST} in Figure \ref{fig:clustering-features}. Our features results in clusters that are both rig aware and dynamics aware, correctly shying away from regions more heavily influenced by the rig, while also more densely populating regions that are likely to experience secondary motion.

Our kmeans++ routine will output a list of cluster labels, which we can use to build an averaging grouping matrix $\boldsymbol{G}_w \in \mathbb R^{ 9|c| \times 9 |T|}$, which performs a mass weighted averaging of the deformation gradient for each tet in a given cluster. Using this matrix, and our formula for obtaining the deformation gradient of each tet from our displacement, we obtain an efficient way of obtaining this weighted clustered deformation gradient. \Otman{See section in Appendix, which needs to be written}.

\begin{align}
    \boldsymbol{\bar{F}}_{c} = \boldsymbol{G}_w \boldsymbol{\bar{F}} =  \underbrace{\boldsymbol{G}_w\boldsymbol{K} \boldsymbol{B}}_{\boldsymbol H} \boldsymbol{z} + \underbrace{\boldsymbol{K} \boldsymbol{u}^r}_{\boldsymbol {\bar{d}}} + \boldsymbol{\bar{I}}
    \label{eq:clustered_defo_gradient}
\end{align}

Where we introduce $\boldsymbol{\bar{F}} \in \mathbb R^{ 9|T|}$ our list of flattened deformation gradients for each tet, and $\boldsymbol{\bar{{F}}_c} \in \mathbb R^{ 9|c|}$, the same list but for each cluster. $\boldsymbol{H} \in \mathbb{R}^{9|c|\times m}$ is a dense matrix that can be precomputed at the start of the simulation, and $\boldsymbol{\bar{d}} \in \mathbb{R}^{9|c|}$ at the start of each timestep as soon as the rig motion is known.

Once we have our per-cluster deformation gradient, we can easily construct a list of concatenated $\boldsymbol{\bar{\Phi}}_c$. We can then obtain our full space gradient through a slight modification of Equation \ref{eq:discrete_gradient_corot}:

\begin{align}
\boldsymbol{g} = \frac{\partial E(\boldsymbol{u}^c)}{\partial \boldsymbol{u}^c}  = \boldsymbol{K}^T  \boldsymbol{G}_1^T\boldsymbol{\mathcal{M}_c}\boldsymbol{\bar{\Phi}_c}
\label{eq:discrete_gradient_corot_clustered}
\end{align} 
 
 Where we make use of our grouping matrix  $\boldsymbol{G}_1 \in \mathbb R^{ 9|c| \times 9 |T|}$ that sums across tets in each cluster, and $\boldsymbol{\mathcal{M}} \in \mathbb{R}^{9c \times 9c}$ is a diagonal matrix with per-cluster volumes. % Equation \ref{eq:reduced_solve} specifically involves projecting this gradient into our reduced subspace,

\subsubsection{Cluster-induced Null Space}

Running the clustering scheme above with a full simulation can lead to disastrous results, as seen in Figure \ref{fig:null_space_vis}. The clustering seems like it introduces a source of plasticity into the simulation. This is actually because of a null-space that expresses itself in our optimization as plasticity. This occurs because multiple configurations of tetrahedra in our cluster can average out to measure the same deformation gradient. Figure \ref{fig:null_space_vis} shows a didactic example showing a rest configuration with an identity deformation gradient for the cluster, and a deformed configuration that also measures an identity-valued clustered deformation gradient.

We can show the existence of this null-space mathematically by looking at our expression for our clustered deformation gradient in Equation \ref{eq:clustered_defo_gradient}. Each of the 9 entries $ij$ for each of our deformation gradients is uniquely obtained by slicing out the blocks of our matrix multiplication in \ref{eq:clustered_defo_gradient}, $(\boldsymbol{G}_w \boldsymbol K)_{ij} \in \mathbb{R}^{c \times |T|}$.

\begin{align}
    \boldsymbol{\bar{F}_c}_{ij} = (\boldsymbol{G}_w \boldsymbol K)_{ij} \boldsymbol{u^c} + \boldsymbol C 
    \label{eq:null-space-deformation-gradient}
\end{align}
$\boldsymbol{C}$ is a placeholder term absorbing all terms that do not depend on $\boldsymbol u^c$ in Equation \ref{eq:clustered_defo_gradient}. The matrix mapping from our displacements to our deformation gradient entries is a rectangular, undetermined one. In other words, it shows mathematically what we discussed earlier, that there exists multiple solutions that map to the same deformation gradient. All it takes in order to avoid this null-space is for the number of clusters to be equal to the number of degrees of freedom, so that this mapping matrix becomes square. Thankfully, our model reduction based algorithm lets gives us free reign in choosing how many degrees of freedom we want our simulation to have, and so our system can easily sidestep this issue, while maintaining freedom in our choice of modes and cluster configurations.



\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{rough_images/null_space_clustering.jpg}
\caption{Our clustering scheme introduces a null space, which allow non-rest states to erroneously measure zero energy, and introduces artificial plasticity into our simulation. \Otman{Show the plasticity introduction}}
\label{fig:null_space_vis}
\end{figure}


\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{rough_images/clustering-scheme.jpg}
\caption{Clustering an elephant mesh, controlled by a single handle rig (need to show this) with Euclidean space features, weight-space features \cite{Jacobson-12-FAST} and our constrained subspace features. Euclidean features(left) group tets like the trunk and the belly, that are close together in euclidean space but far away semantically. Weight space features (middle) cluster vertices that are controlled by the rig in a similar fashion similarly, because this is a single point affine rig, all vertices share the exact same weight value and so clusters are formed randomly accross the mesh.
Our clustering in B-space groups together semantically intuitive features, vertices that move together in the space of motions irreproducible by the rig.} 
\Otman{Show another example using a LBS rig}
\label{fig:clustering-features}
\end{figure}



\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{rough_images/clustering_incompressibility.jpg}
\caption{Our clustering scheme applied to a standard co-rotational elasticity model (no model reduction applied to this example). We obtain substantial speedups while still reproducing key incompressible deformations.}
\label{fig:clustering-corotational}
\end{figure}

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{rough_images/clusters_timing.jpg}
\caption{An analysis of how our run-time varies with the number of clusters on different meshes. Our method depends linearly on the number of clusters.}
\label{fig:clustering-time-complexity}
\end{figure}



\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{rough_images/pareto-front.jpg}
\label{fig:clustering-time-complexity}
\caption{An analysis of an empirically obtained pareto-front, showing optimal num modes/ numclusters required to obtain real-time (24FPS) modes.}
\end{figure}


%These clusters would better be spent on augmenting the motion around the trunk and rigs, as they correctly are identified with our rig-constrained subspace features (right).}
%Tetrahedra in the torso are clustered together, when in fact they will undergo very little motion. 
