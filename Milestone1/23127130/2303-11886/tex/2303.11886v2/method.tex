
\section{Clustering}
\label{sec:clustering}
For many rich rotational dynamic properties, an elastic energy usually requires the use of per-tetrahedron non-linear operations \cite{KimDynamicDeformables}. Despite our use of a subspace for our displacement degrees of freedom, these energies \emph{still} demand per-tet computation. Our simulations are not yet truly decoupled from the resolution of the mesh.

Many methods in the past sidestep this issue by making use of \emph{cubature} \cite{BarbicJames:RealTimeSTVK,TengArticulatedBodyContact,OptimizingCubature}, where the deformation quantities at each tetrahedra are estimated as a sum of weighed contributions from a sparse set of pre-determined sample tetrahedra. These samples and their interpolation weight are usually obtained through a data-fitting phase. 
% As a result of this formulation, deformation contributions from tetrahedra that are \emph{not} in our set of samples will go entirely ignored. 
We instead opt for a clustering \cite{Jacobson-12-FAST} scheme, which estimates these non-linearities through $r$ clusters of tetrahedra. Instead of requiring training data, we compute our clusters via a deformation prior, obtaining them via a $k$-means clustering \cite{kmeanspp} of our subspace secondary skinning weights $\boldsymbol{W}$.
% Because every tet belongs to one cluster, we guarantee that we never miss deformations from any tetrahedra; clustering allows their contribution to be felt when aggregating per-cluster deformation quantities.
For a mesh with $\numtets$ tetrahedra, we use $\numclusters$ clusters
  to build the grouping matrix $\boldsymbol{G} \in \mathbb{R}^{\numclusters  \times  \numtets}$:
\begin{align}
\boldsymbol{G}_{ij}  =
 \begin{cases}
  \frac{\boldsymbol{V_j}}{\sum_q^{\mathcal{C}_i}{\boldsymbol{V_q}}}  \quad & \text{if} j \in \mathcal{C}_i \\
  0  \quad & \text{otherwise}
 \end{cases}
\end{align}
where $\boldsymbol{V}_j$ is the volume of the $j$-th tetrahedron, while $\mathcal{C}_i$ contains the indices of the tetrahedra belonging to cluster $i$.
This grouping matrix computes cluster quantities via a mass weighed averaging of its member tetrahedra.  We use these grouping matrices whenever we require per-tet evaluations in our solver as outlined in \refsec{local-global-solver}.

We build our clusters via a $k$-means++ \cite{kmeanspp}, using features obtained from our secondary weights. Specifically, we average our vertex weights onto each tetrahedra, then we scale each of our weights $\boldsymbol{w}_i$ by the inverse-squared of its associated eigenvalue $\lambda_i$, obtained in \refeq{gevp-skinning-modes-constrained}. 
\reffig{cluster-vis} shows clustering results for a sample mesh with different rigs. Because our skinning subspace is the only feature we use for building our clusters, our clusters inherit many of the properties of the skinning modes, including being material-sensitive, rig-sensitive. This allows our clusters to provide a higher resolution in parts of the mesh more likely to exhibit secondary motion.
Because our skinning modes can be global, this results in clusters that could also be global. We detect these in a post processing step and \emph{split} clusters into their individual separate components. 

\section{Local-Global Solver}
\label{sec:local-global-solver}
We make use of a simple local-global solver for the minimization of our elastodynamic energy. This solver leverages our reduced space degrees of freedom and our clusters to \emph{never} make use of any full-space operations. This solver allows us to avoid recomputing expensive quadratic energy Hessians each timestep while still accommodating frequently desired elastic non-linearities, such as rotations. 

\subsection{Full-Space Local-Global Solver}
We assume energies that can be decomposed as
% \begin{equation}
%     E(\boldsymbol{u}) = \Psi(\boldsymbol{u}) + \sum^{\mathcal{T}}_t\phi(\boldsymbol{u}_t) \nonumber
% \end{equation}
\begin{equation}
    E(\boldsymbol{u}) = \Psi(\boldsymbol{u}) + \Phi(\boldsymbol{u}) \, , \nonumber
\end{equation}
where $\Psi(\boldsymbol{u})$ is quadratic in $\boldsymbol{u}$   and $\Phi$ is a non-linear in $\boldsymbol{u}$ and piecewize constant over tets. We then need to identify the source of the non-linearities in $\Phi$, $\boldsymbol{R}$, as auxiliary degrees of freedom
% \begin{equation}
%   \boldsymbol{u}, \boldsymbol{R} =  \argmin_{\boldsymbol{u}, \boldsymbol{R}}  \Psi(\boldsymbol{u}) +  \sum^{\mathcal{T}}_{t} \phi(\boldsymbol{u}, \boldsymbol{R}_t) \nonumber
% \end{equation}
\begin{equation}
  \boldsymbol{u}, \boldsymbol{R} =  \argmin_{\boldsymbol{u}, \boldsymbol{R}}  \Psi(\boldsymbol{u}) +  \Phi(\boldsymbol{u}, \boldsymbol{R}) \, . \nonumber
\end{equation}


% Where $\phi_t$ is now at most quadratic in both of its degrees of freedom, $\boldsymbol{u}$ and $\boldsymbol{R}_t$. If it's linear, then the total energy hessian is constant and has no contributions from the non-linearities, allowing us to compute it and prefactorize it once and never again during the simulation. If $\phi_t$ is quadratic, then the non-linearities have a time-varying contribution to the energy hessian. To avoid recomputing the hessian for this case, we need to add a line search to our optimization scheme.

We split elastodynamic optimization into two steps  \cite{ARAPolgaSorkine}. The 
local step optimizes for the non-linear sources $\boldsymbol{R}$ in our energy: 
holding the primary degrees of freedom fixed, \begin{align}
  \boldsymbol{R}_{i} &=  \argmin_{\boldsymbol{R}}  \Phi(\boldsymbol{u}_{i-1}, \boldsymbol{R}) \, .\label{eq:full-space-local-step}
 \end{align}
The global step optimizes for the primary degrees of freedom, holding the auxillary ones fixed:
\begin{align}
  \boldsymbol{u}_{i} &=  \argmin_{\boldsymbol{u}}  \Psi(\boldsymbol{u}) +  \Phi(\boldsymbol{u}, \boldsymbol{R}_{i})\, .
  \label{eq:full-space-global-step}
\end{align}
These two steps are repeated iteratively until convergence..

\begin{figure}
\includegraphics[width=\linewidth,keepaspectratio]{images/subspace-comparison.pdf}\timestamp[-0.125cm]{\tsSubspaceComparison}
\caption{
Simulations making use of displacement modes (left) are not rotation equivariant. Augmenting displacement modes with modal derivatives (middle), helps in representing higher quality deformations, but still create different high energy deformations under rotations. Our skinning modes (right)  allow us to capture both local rotational motion and maintain rotation equivariance \edit{and lead to the lowest energy even without explicitly tracking a rotating frame  \cite{Terzopoulos1988} each timestep (bottom)}. } \label{fig:subspace-comparisons}
\end{figure}

 
\subsection{Hyper-Reduced Local-Global Solver}
To ensure our solver never performs any full space operations, we make use of our subspace $\boldsymbol{u} \approx \boldsymbol{B} \boldsymbol{z}$ and our clusters  $\Phi \approx \tilde{\Phi}$, where the tilde denotes clustered quantities. While before $\boldsymbol{\Phi}$ was piecewise constant over \emph{tets}, it is now piecewise constant over \emph{clusters}, where clustered physical quantities, (like mass, Lam√© parameters, deformation gradients, etc.) have been averaged over all the tets in each cluster. 
Our hyper-reduced energy becomes:
\begin{equation}
    E(\boldsymbol{u}) = \Psi(\boldsymbol{z}) + \tilde{\Phi}(\boldsymbol{z}) \, .\nonumber
\end{equation}
Exposing the per-cluster source of non-linearities as their own auxillary degrees of freedom $\boldsymbol{\tilde{R}}$:
\begin{equation}
    E(\boldsymbol{z}) = \Psi(\boldsymbol{z}) + \tilde{\Phi}(\boldsymbol{z}, \boldsymbol{\tilde{R}}) \nonumber
\end{equation}
Our hyper-reduced local step becomes
\begin{align}
  \boldsymbol{\tilde{R}}_{i} &=  \argmin_{\boldsymbol{\tilde{R}}}  \tilde{\Phi}(\boldsymbol{z}_{i-1}, \boldsymbol{\tilde{R}}) \, ,\label{eq:hyper-reduced-local-step}
\end{align}
\edit{Because the non-linearity is piece-wise constant over clusters, this per-cluster optimization can additionally be solved in parallel over all clusters, providing further acceleration.} 
while the hyper-reduced global step becomes
\begin{align}
  \boldsymbol{z}_{i} &=  \argmin_{\boldsymbol{z}}  \Psi(\boldsymbol{z}) +  \tilde{\Phi}(\boldsymbol{z}, \boldsymbol{\tilde{R}}_{i})\, .
  \label{eq:hyper-reduced-global-step} 
\end{align}

Depending on the specific energy, different optimization schemes need to be adopted for both the local step and the global step. The only criteria we need to maintain on any of these solvers is that they \emph{never} perform any full-space operations. Appendix \refsec{appendix-hyper-reduced-arap-elasticity} and \refsec{appendix-hyper-reduced-corotational-elasticity} show how to implement our reduced local-global solver for elastic energies such as ARAP \cite{ChaoGomElastic} and Linear Co-Rotational Elasticity \cite{McAdams2011}.

