Our formalization is developed on top of the Agda's standard library
v1.7 \cite{agdalib}. Figure \ref{fig:proj} shows a high level view of
the project.  The standard library includes an algebraic hierarchy
going beyond groups; it lacks, however, a formalization of group
actions. The module \agdainline{GroupAction} includes G-Sets,
equivariant functions and constructions like products and co-products.
We also have a \agdainline{Permutation} module which includes the
concepts of finite permutations, cycles, normalization and the
permutation group.  And last, in the module \agdainline{Nominal} we
formalize the concepts of support, nominal set, equivalence between
different notions of support, normalization and again constructions
like products and co-products.

\begin{figure}[ht]
  \centering
  \input{modules-diagram}
  \caption{High level view of the modular organization in the project.}
  \label{fig:proj}
\end{figure} 

\noindent We first present the definition of Group in the standard library in order
to introduce some terminology and concepts:
\begin{minted}{agda}
    record Group c ℓ : Set (suc (c ⊔ ℓ)) where
      field
        Carrier : Set c
        _≈_     : Rel Carrier ℓ
        _∙_     : Op₂ Carrier
        ε       : Carrier
        _⁻¹     : Op₁ Carrier
        isGroup : IsGroup _≈_ _∙_ ε _⁻¹
\end{minted}
\noindent A Group is a \emph{bundle} where the components of its definition
(the carrier set, the unit, the inverse, the composition) are explicitly
mentioned plus a proof, given by \textit{isGroup}, that they satisfy the
axioms. Notice that one of the fields is a relation \textit{_≈_};
that relation should be an equivalence relation over the carrier:
essentially this amounts to say that the \agdainline{Carrier} has
a setoid structure. Setoids allows for greater flexibility
as they enable to work with a notion of equality that is not the 
propositional equality; \agdainline{Func X Y} is the set of functions
between setoids \agdainline{X} and \agdainline{Y} that preserve the
equality; sometimes these functios are called \emph{respectful}.

\paragraph{G-Sets}

Our first definition is the \emph{structure} that collects the equations
required for an action. In the following, we are under a module
parameterized by \mintinline{agda}{G : Group}.
\begin{minted}{agda}
    record IsAction (F : Func (G.setoid ×ₛ X) X) : Set _ where
      _●_ : Carrier G → Carrier X → Carrier X
      g ● x = Func.f F (g , x)
      field
        idₐ : ∀ x → ε ∙ₐ x ≈X x
        compₐ : ∀ g' g x → g' ● g ● x ≈X (g' ∙ g) ● x
\end{minted}
\noindent Notice that the record-type \mintinline{agda}{IsAction} is a 
predicate over respectuful functions from the setoid $G\times X$ to $X$.
The definition of G-Set is straightforward and follows the pattern of the
standard library
\begin{minted}{agda}
    record G-Set : Set _ where
      field
        set : Setoid ℓ₁ ℓ₂
        action : Func (G.setoid ×ₛ set) set
        isAction : IsAction action
\end{minted}
In order to introduce the notion of equivariant function\footnote{We note that
both Choudhury and Paranhos define equivariant functions only for the group of
finite permutations.} we first introduce the predicate
\agdainline{IsEquivariant} stating when \agdainline{H : Func X Y} is equivariant
for respectful functions \agdainline{FX} and \agdainline{FY}.
\begin{minted}{agda}
    IsEquivariant :
     {X : Setoid ℓ₁ ℓ₂} →
     {Y : Setoid ℓ₃ ℓ₄} →
     (FX : Func (G.setoid ×ₛ X) X) →
     (FY : Func (G.setoid ×ₛ Y) Y) →
     (H : Func X Y) → Set (ℓ₁ ⊔ ℓ₄ ⊔ cℓ)
    IsEquivariant {Y = Y} FX FY H = ∀ x g → F.f (g ●X x) ≈Y (g ●Y F.f x)
      where _●X_ = _●_ {F = FX} ; _●Y_ = _●_ {F = FY} ; _≈Y_ = _≈_ Y
            open module F = Func H
\end{minted}
\noindent Now we pack a respectful function between the setoids of G-Sets together with
a proof of it being equivariant.
\begin{minted}{agda}
    record Equivariant (X : G-Set) (Y : G-Set) : Set _ where
      field
        F : Func (set X) (set Y)
        isEquivariant : IsEquivariant (action X) (action Y) F
\end{minted}

In the following snippet we show how to
construct binary products of G-Sets (we use copatterns to define record objects).
\begin{minted}{agda}
    variable X Y : G-Set G
    private
      open module GX = G-Set X ; open module GY = G-Set Y
    G-Set-× : G-Set G
    set G-Set-× = GX.set ×ₛ GY.set
    f (action G-Set-×) (g , (x , y)) = g GX.● x  , g GY.● y
    cong (action G-Set-×) (g=g' , (x=x' , y=y')) =
      Func.cong GX.action (g=g' , x=x') ,  Func.cong GY.action (g=g' , y=y')
    idₐ (isAction (G-Set-×)) (x , y) = GX.idₐ x , GY.idₐ y
    compₐ (isAction (G-Set-×)) g g' (x , y) = GX.compₐ g g' x , GY.compₐ g g' y
\end{minted}
\noindent We now prove that the first projection is equivariant; notice that
\agdainline{G-Set-×} is the product of \agdainline{X} and \agdainline{Y} introduced
with the \agdainline{variable} keyword.
\begin{minted}{agda}
    π₁ : Equivariant G G-Set-× X
    f (F π₁) = proj₁
    cong (F π₁) = proj₁
    isEquivariant π₁ _ _ = refl (set X)
\end{minted}

\paragraph{Permutations}
Now we focus on the module \agdainline{Permutation}. We start by introducing the group $\SymA$
using the definitions of inverses from the standard library; notice that the equivalence 
relation is given by the point-wise (or extensional) equality of functions.
\begin{minted}{agda}
    -- In this context A-setoid is a Setoid (not necessarily decidable).
    A = Carrier A-setoid ; _≈A_ = _≈_ A-setoid
    Perm = Inverse A-setoid A-setoid
    _≈ₚ_ : Rel Perm _
    F ≈ₚ G = (a : A) → f F a ≈A f G a
  
    Sym : Group (ℓ ⊔ ℓ') (ℓ ⊔ ℓ')
    Carrier Sym = Perm
    _≈_ Sym = _≈ₚ_
    _∙_ Sym = _∘ₚ_        -- composition of Perm, from the stdlib
    ε Sym = idₚ A-setoid  -- identity Perm, from the stdlib
    _′ Sym = _⁻¹          -- inverse permutation, from the stdlib
    isGroup Sym = record { ... } -- ommited
\end{minted}

\noindent If we ask the setoid \agdainline{A-setoid} to be decidable, then we can define the swapping
permutation.
\begin{minted}{agda}
    module Perm (A-setoid : DecSetoid ℓ ℓ') where
      open DecSetoid A-setoid renaming (Carrier to A)
      transp : A → A → A → A
      transp a b c with does (c ≟ a)
      ... | true = b
      ... | false with does (c ≟ b)
      ... | true = a
      ... | false = c

      transp-perm : (a b : A) → Perm
      transp-perm a b = record { 
        f = transp a b ; f⁻¹ = transp a b
        ; cong₁ = transp-respects-≈ a b ; cong₂ = transp-respects-≈ a b
        ; inverse = transp-involutive a b , transp-involutive a b
    }
\end{minted}

Our next goal is to define the group $\PermA$ of finite permutations of atoms. As we explained
before, finite permutation can be given by a bijective map, as a composition of transpositions,
or as a composition of disjoint cycles. 

In other works the group of finite permutations is explicitly defined
as lists of pairs, where each pair represents a transposition and the
empty list is the identity permutation: appending a pair $(a,b)$ to a
list $p$ amounts to compose the transposition $\swap a b$ to the
permutation denoted by $p$. Concatenation of lists $p$ and $p'$ also
induces their composition. This choice has the advantage of being
explicit and avoids having alternative expressions for composing
permutations. On the other hand it still allows different
representatives for the same permutation; in fact, $[(a,a)]$,
$[(b,a),(a,b)]$, and $[]$ are all representations of \emph{the}
identity permutation. It is clear that the setoid of finite
permutations should equate those three versions of the identity,
therefore the equivalence relation used is that of inducing the same
permutation.

We started with the following syntactic representation of Finite Permutations, which is close
to that of lists but in terms of $S$-expressions; since we cannot ensure canonicity with lists,
why not to be more liberal also on associativity?
\begin{minted}{agda}
    data FinPerm : Set ℓ where
      Id : FinPerm
      Swap : (a b : A) → FinPerm
      Comp : (p q : FinPerm) → FinPerm
\end{minted}
The permutation associated with a \agdainline{FinPerm} is given by
\begin{minted}{agda}
    ⟦_⟧ : FinPerm → Perm
    ⟦ Id ⟧ = idₚ setoid
    ⟦ Swap a b ⟧ = transp-perm a b
    ⟦ Comp p q ⟧ =  ⟦ q ⟧ ∘ₚ ⟦ p ⟧
\end{minted}
Before introducing our concrete formalization of $\PermA$ let us exploit the fact that we 
have a decidable setoid of atoms to prove that the equivalence of finite permutation is 
also decidable. In order to do that, we define a relation \agdainline{_⊆ₛ_} on
\agdainline{FinPerm}; \agdainline{p ⊆ₛ q} holds when \agdainline{q} coincides with 
\agdainline{p} in the support of the latter. Since we can compute the support of
\agdainline{FinPerm}s and the equality of atoms is decidable, then we can decide 
\agdainline{_⊆ₛ_}.
\begin{minted}{agda}
    _⊆ₛ_ : Rel FinPerm (ℓ ⊔ ℓ')
    p ⊆ₛ q = All (λ a → f ⟦ p ⟧ a ≈ f ⟦ q ⟧ a) (support p)

    ?⊆ₛ : ∀ p q → Dec (p ⊆ₛ q)
    ?⊆ₛ p q = all? (λ a → f ⟦ p ⟧ a ≟ f ⟦ q ⟧ a) (support p)
\end{minted}
Moreover we can prove that the mutual containment is equivalent to denoting the same permutation;
thus we can decide the equality of finite permutations as given by \agdainline{FinPerm}:
\begin{minted}{agda}
    _≈ₛ_ : Rel FinPerm (ℓ ⊔ ℓ')
    p ≈ₛ q = p ⊆ₛ q × q ⊆ₛ p

    ≈ₛ-dec : ∀ p q → Dec (p ≈ₛ q)
    ≈ₛ-dec p q = (?⊆ₛ p q) ×-dec (?⊆ₛ q p)
    -- We omit the proofs of these lemmas.
    ≈ₛ⇒≈ₚ : ∀ p q → p ≈ₛ q → ⟦ p ⟧ ≈ₚ ⟦ q ⟧
    ≈ₚ⇒≈ₛ : ∀ p q → ⟦ p ⟧ ≈ₚ ⟦ q ⟧ → p ⊆ₛ q
    _≟ₚ_ : ∀ p q → Dec (⟦ p ⟧ ≈ₚ ⟦ q ⟧)
\end{minted}
Furthermore we can normalize a \agdainline{FinPerm} to have an equivalent permutation 
where every occuring atom is in its support. 

Let us first revisit the Example \ref{ex:perm} 
now in Agda where we see how to encode a finite permutation as a composition of cycles.
\begin{minted}{agda}
    f : ℕ → ℕ
    f x with x ≤? 5
    ... | yes p = (x + 2) mod 6
    ... | no ¬p = x
\end{minted}
We represent cycles simply as lists of atoms; we certainly could also have used fresh lists to
represent cycles. A composition of cycles is a list of cycles.
\begin{minted}{agda}
    Cycle = List A
    
    cycle₀ cycle₁ : Cycle
    cycle₀ = 1 ∷ 3 ∷ 5 ∷ []
    cycle₁ = 0 ∷ 2 ∷ 4 ∷ []
    f-cycles : List Cycle
    f-cycles = cycle₀ ∷ cycle₁ ∷ []
\end{minted}
Or alternatively, it can also be expressed as a composition of four transpositions:
\begin{minted}{agda}
    f-swaps : FinPerm
    f-swaps = Comp (Comp (Swap 1 3) (Swap 3 5)) (Comp (Swap 0 2) (Swap 2 4))
\end{minted}
In Figure \ref{fig:perms} we show the three representations of finite permutations.
\begin{figure}
  \centering
  \input{permutations-diagram}
  \caption{The mappings between different representations of permutations.}
  \label{fig:perms}
\end{figure} 
The normalization of \agdainline{FinPerm} is simply the composition of the mappings:
\begin{minted}{agda}
    norm : FinPerm → FinPerm
    norm = cycles-to-FP ∘ cycles-from-FP
\end{minted}
The functions \agdainline{cycles-to-FP} maps lists of disjoint cycles to
\agdainline{FinPerm} and \agdainline{cycles-from-FP} goes in the reverse direction,
producing a list of disjoint cycles from a \agdainline{FinPerm} (this is the
composition of the diagonal arrows in Fig.~\ref{fig:perms}).

The correctness of the normalization follows the proof presented in Sec.~\ref{sec:perm}.
Although we do not enforce neither freshness for cycles nor disjointness of cycles we
keep that as an invariant when we compute the cycles in \agdainline{to-cycles}.
\begin{minted}{agda}
    module Thm (p : FinPerm) where
      ats = atoms! p -- Fresh list of the atoms in the support of p.
      -- from-atom-~* is the proof of Lemma 3.
      rel = from-atoms-~* ⟦ p ⟧ ats []* (fp-supp p) (dom⊇atoms! p)
      -- the representation as composition of cycles
      ρs = to-cycles ⟦ p ⟧ (length ats) ats []
      -- This property follows from Lemma 3.
      ∈-dom⇒∈ρs : (_∈-dom ⟦ p ⟧) ⊆ (_∈ concat ρs)
    
      norm-corr : ⟦ p ⟧ ≈ₚ ⟦ norm p ⟧
      norm-corr x with x ∈? concat ρs
      ... | yes x∈at = ~*-out ⟦ p ⟧ rel x∈at      -- Item 3 of Lemma 1.
      ... | no x∉at = trans                       -- f ⟦ p ⟧ x = x = f ⟦ norm p ⟧ x
          (¬∈-dom⇒∉-dom {⟦ p ⟧} (contraposition ∈-dom⇒∈ρs x∉at))
          (~*-out-fresh ⟦ p ⟧ rel x∉at)           -- Item 4 of Lemma 1.
\end{minted}
We also have other correctness result to prove that the \agdainline{FinPerm}
obtained from a \agdainline{Perm} and its support is equivalent to it:
\begin{minted}{agda}
    module Thm’ (F : Perm) {ats : List A} (is-sup : ats is-supp-of F)
      (incl : (_∈ ats) ⊆ (_∈-dom F)) where
    
      ρs = to-cycles p (length ats) ats []
      norm-corr : F ≈ₚ ⟦ cycles-to-FP ρs ⟧
\end{minted}

Let us remark that \agdainline{FinPerm} is just a representation and the set of
finite permutation, \agdainline{PERM}, is the subset of \agdainline{Perm}
corresponding to the image of \agdainline{⟦_⟧}:
\begin{minted}{agda}
    PERM : Set _
    PERM = Σ[ p ∈ Perm ] (Σ[ q ∈ FinPerm ] (p ≈ₚ ⟦ q ⟧))
\end{minted}
A disadvantage of using this encoding is that we need to deal with triples; for instance, the
identity \agdainline{PERM} is represented by \agdainline{Id}.
\begin{minted}{agda}
    ID : PERM
    ID = idₚ setoid , Id , λ _ → refl
\end{minted}
The group $\PermA$ is explicity defined as:
\begin{minted}{agda}
    Perm-A : Group (ℓ ⊔ ℓ') (ℓ ⊔ ℓ')
    Carrier Perm-A = PERM
    _≈G_ Perm-A = _≈ₚ_ on proj₁
    _∙_ Perm-A = _∘P_
    ε Perm-A = ID
    _′ Perm-A = _⁻¹P
    isGroup Perm-A = record { ... }
\end{minted}

We alleviate the burden of working with triples by proving lemmas characterizing the action 
of \agdainline{PERM}s in terms of the finite permutation, for instance for \agdainline{Id}:
\begin{minted}{agda}
    -- In this context the group acting on G-Sets is Perm-A. 
    module Act-Lemmas {X-set : G-Set {ℓ₁ = ℓx} {ℓ₂ = ℓx'}} where
      _≈X_ = Setoid._≈_ set
      id-act : ∀ (π : PERM) (x : X) → proj₁ π ≈ₚ ⟦ Id ⟧ → (π ● x) ≈X x
      id-act π x eq = trans (congˡ {π} {ID} x eq) (idₐ x)
\end{minted}

\paragraph{Nominal Sets}
Remember that a subset $A\subseteq \mathbb{A}$ is a support for $x$ 
if every permutation fixing every element of $A$ fixes $x$, through the
action. A subset of a setoid \agdainline{A} can be defined either as a 
predicate or as pairs (just as in \agdainline{PERM} where the predicate 
is \agdainline{λ p → Σ[ q ∈ FinPerm ] (p ≈ₚ ⟦ q ⟧)}) or as another type, say
\agdainline{B}, together with an injection \agdainline{ι : Injection B A}.
\begin{minted}{agda}
    variable
      X : G-Set 
      P : SetoidPredicate A-setoid
    is-supp : Pred X _
    is-supp x = (π : PERM) → (predicate P ⊆ _∉-dom (proj₁ π)) → (π ● x) ≈X x
\end{minted}
The predicate \agdainline{λ a → f (proj₁ π) a ≈A a} is \agdainline{_∉-dom (proj₁ π)}; therefore, if \agdainline{P a} iff $a\in A$, then 
\agdainline{predicate P ⊆ _∉-dom (proj₁ π)} is a correct 
formalization of $\forall a\in A.\ π\,a=a$. 

Our official definition of support is the following:
\begin{minted}{agda}
    _supports_ : Pred X _
    _supports_ x = ∀ {a b} → a ∉ₛ P → b ∉ₛ P → SWAP a b ● x ≈X x
\end{minted}
Here \agdainline{SWAP} is a \agdainline{PERM}utation equal to 
\agdainline{⟦Swap a b⟧}. We formally proved that both definitions are equivalent, which is stated by the mutual implications:
\begin{minted}[baselinestretch=1]{agda}
    is-supp⊆supports : ∀ x → is-supp x → _supports_ x
    supports⊆is-supp : _supports_ ⊆ is-supp
\end{minted}
Let us note that the second implication uses explicitly the normalization of
finite permutations and its correctness.

In order to define nominal sets we need to choose how to say that a subset is
finite; as explained by Coquand and Spiwak \cite{Coquand2010} there are several
possibilities for this. We choose the easiest one: a predicate is finite if there
is a list that enumerates all the elements satisfying the predicate.
\begin{minted}{agda}
    finite : Pred (SetoidPredicate setoid) _
    finite P = Σ[ as ∈ List Carrier ] (predicate P ⊆ (_∈ as))
\end{minted}
A G-Set is nominal if all the elements of the underlying set are finitely 
supported.
\begin{minted}{agda}
    record Nominal (X : G-Set) : Set _ where
      field
        sup : ∀ x → Σ[ P ∈ SetoidPredicate setoid ] (finite P × P supports x)
\end{minted}

It is easy to prove that various constructions are nominals; for instance
any discrete G-Set is nominal because every element is supported by the empty
predicate \agdainline{⊥ₛ}:
\begin{minted}{agda}
    Δ-nominal : (S : Setoid _ _) → Nominal (Δ S)
    sup (Δ-nominal S) x = ⊥ₛ , ⊥-finite , (λ _ _ → S-refl {x = x})
      where open Setoid S renaming (refl to S-refl)
\end{minted}
We have defined \agdainline{G-Set-⇒ X Y} corresponding to the G-Set
of equivariant functions from \agdainline{X} to \agdainline{Y}; now we can
prove that \agdainline{G-Set-⇒ X Y} is nominal, again with \agdainline{⊥ₛ}
as the support for any \agdainline{F : Equivariant X Y}.
\begin{minted}{agda}
    →-nominal : Nominal (G-Set-⇒ X Y)
    sup (→-nominal) F = ⊥ₛ , ⊥-finite , λ _ _ → supported
      where supported : ∀ {a b} x → f ((SWAP a b) ∙→ F) x ≈Y f F x
\end{minted}