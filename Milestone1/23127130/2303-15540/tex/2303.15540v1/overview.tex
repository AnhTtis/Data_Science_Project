\section{Overview of TDX}
\label{sec:overview}
In this section, we give an overview of \ac{TDX}, discussing its system architecture, memory protection mechanisms, I/O model, attestation, and features that have been planned for the future. Each topic also includes pointers to subsequent sections that provide more technical details.  

\begin{figure}[t!]
\centerline{\includegraphics[width=0.8\textwidth]{figures/TDX_arch_overview.pdf}}
\caption{TDX System Architecture}
\label{fig:tdx_arch_overview}
\end{figure}
\subsection{TDX System Architecture}
\label{sec:overview:architecture}
\autoref{fig:tdx_arch_overview} illustrates the runtime architecture of \ac{TDX}. It is composed of two key components: (1) TDX-enabled processors, which offer architectural functionalities like hardware-assisted virtualization, memory encryption/integrity protection, and the ability to certify \ac{TEE} platforms, (2) \ac{TDX} Module, an Intel-signed and CPU-attested software module that leverages the features of \ac{TDX}-enabled processors to facilitate the construction, execution, and termination of \acp{TD} while enforcing the security guarantees. The \ac{TDX} Module provides two sets of interface functions, host-side interface functions for a \ac{TDX}-enlightened hypervisor and guest-side interface functions for \acp{TD}. It is loaded and executed in the \code{\ac{SEAM} RANGE}, which is a portion of system memory reserved via UEFI/BIOS. The P-SEAM Loader, which also resides in the \code{\ac{SEAM} RANGE}, can install and update the \ac{TDX} Module. More information on the loading process of the \ac{TDX} Module can be found in \S\ref{sec:tdxmodule:load}.

\acf{SEAM} is an extension to the \ac{VMX} architecture and provides two new execution modes: \spec{\ac{SEAM} \ac{VMX} root mode} and \spec{\ac{SEAM} \ac{VMX} non-root mode}. A \ac{TDX}-enlightened hypervisor operates in the traditional \spec{\ac{VMX} root mode} and utilizes the \code{SEAMCALL} instruction to call host-side interface functions (function names start with \code{TDH}) of the \ac{TDX} Module. Upon execution of the \code{SEAMCALL} instruction, the logical processor transitions from the \spec{\ac{VMX} root mode} into \spec{\ac{SEAM} \ac{VMX} root mode} and starts executing code within the \ac{TDX} Module. Once the \ac{TDX} Module has completed its task, it returns to the hypervisor in \spec{\ac{VMX} root mode} by executing the \code{SEAMRET} instruction. On the other hand, \acp{TD} run in the \spec{\ac{SEAM} \ac{VMX} non-root mode}. \acp{TD} can trap into the \ac{TDX} Module either through a \ac{TD} exit or by invoking the \code{TDCALL} instruction. In both cases, the logical processor transitions from the \spec{\ac{SEAM} \ac{VMX} non-root mode} into the \spec{\ac{SEAM} \ac{VMX} root mode} and starts executing in the context of the \ac{TDX} Module. The names of guest-side interface functions handling \code{TDCALLs} start with \code{TDG}. Details about the \ac{TDX} context switches can be found in \S\ref{sec:tdxmodule:context}.

\subsection{TDX Memory Protection}
\label{sec:overview:mem_protect}
\ac{TDX} leverages \ac{VMX} to enforce the memory isolation for \acp{TD}. Similar to legacy \acp{VM}, \acp{TD} are unable to access the memory of other security domains, such as \ac{SMM}, hypervisors, the \ac{TDX} Module, and other \acp{VM}/\acp{TD}. With \ac{VMX}, hypervisors maintain \acp{EPT} to enforce memory isolation. However, since hypervisors are no longer trusted, \ac{TDX} has moved the task of memory management to the \ac{TDX} Module, which controls the address translation of \ac{TD}'s private memory. 

A more intriguing aspect of \ac{TDX}'s security model is its protection of \ac{TD}'s memory from privileged software, corrupted devices, and unprincipled administrators on the host. \ac{TDX} achieves this by implementing \spec{access control} and \spec{cryptographic isolation}. Access control prevents other security domains on the same computer from accessing a \ac{TD}'s data. Cryptographic isolation is utilized to prevent malicious \ac{DMA} devices or adversaries with physical access to the main memory from directly reading or corrupting \ac{TD}'s memory.

\nip{Memory Partitioning.}
With \ac{TDX} enabled, the entire physical memory space is partitioned into two parts: \spec{normal memory} and \spec{secure memory}. The sensitive data of \acp{TD}, including the private memory, virtual CPU state, and its associated metadata, should be stored in secure memory. \acp{TD} can also specify memory regions as shared memory for I/O, which is not protected through \ac{TDX}, and thus belong to normal memory. All other software, which is \emph{not} executing in the SEAM mode, belongs to normal memory and is not allowed to access secure memory, regardless of its privilege level. The memory controller, an architectural component inside the processor, enforces memory access checks.

To make a physical page part of the secure memory, the \spec{\ac{TD} Owner bit} is enabled (\S\ref{sec:memprotect:TD_memory_integrity}). Each \spec{\ac{TD} Owner bit} is associated with a memory segment corresponding to a cache line\footnote{At the time of this writing, the size of the processor's cache line is 64-byte; thus the address of such a memory segment is 64-byte aligned.}. The \spec{\ac{TD} Owner bits} are stored in the \ac{ECC} memory associated with these segments. The \ac{TDX} Module controls the conversion of physical memory pages to secure memory by attaching private \acp{HKID} to their physical addresses. The \ac{HKID} is encoded in the upper bits of the physical address. The set of private \acp{HKID} are controlled by \ac{TDX} and can only be used for \acp{TD} and the \ac{TDX} Module. When the memory controller writes to a physical address with a private \ac{HKID}, it sets the \spec{\ac{TD} Owner bit} to $1$. When it writes to an address that does not have a private \ac{HKID}, it clears the \spec{\ac{TD} Owner bit}. Access control is enforced on each cache line read. The read request passes through the memory controller, which permits only processes executing in \ac{SEAM} mode to read a cache line with a \spec{\ac{TD} Owner bit} set to $1$. Any read request not in the \ac{SEAM} mode receives all zeros when trying to read such a cache line.

When building a \ac{TD}, the (untrusted) hypervisor selects the memory pages from the normal memory to become part of the secure memory. The \ac{TDX} Module gradually moves these pages to the secure memory. It uses them for the metadata (\S\ref{sec:tdxmodule:td_metadata}) and the main memory of each individual \ac{TD}. A TD must explicitly accept these pages before they can be used for its main memory. The \ac{TDX} Module performs sanity checks of the secure memory setup by maintaining a \ac{PAMT}, which is described in more detail in \S\ref{sec:tdxmodule:mem_management}. 

\nip{Memory Confidentiality.}
\label{memoryprotection:mktme}
\ac{TDX} leverages \ac{MKTME} (\S\ref{sec:background:mktme}) for encrypting \ac{TD}'s private memory and its metadata. \ac{MKTME} is responsible for transparent memory encryption and decryption of data passing through the memory controller. The \ac{TDX} Module programs the keys used by the \ac{MKTME} to encrypt specific cache lines when they are written to memory. The keys are associated with the \acp{HKID} embedded in the physical addresses. \ac{MKTME} decodes \acp{HKID} and uses the referenced cryptographic keys to perform the cryptographic operations. 

\ac{MKTME} stores cryptographic keys in its internal memory, never exposing them to the outside. The cryptographic keys can only be referenced by their \acp{HKID}. When building a new TD, the hypervisor selects an unused private \ac{HKID}, and the \ac{TDX} Module requests the processor to generate a new cryptographic key related to this \ac{HKID}. The \ac{TDX} Module binds this key to the \ac{TD}. It guarantees that the memory of each TD is encrypted with a different cryptographic key. 

\ac{MKTME} encrypts memory at the cache line granularity using AES-128 XTS cryptography. Each cache line in the main memory is associated with metadata that encodes its association with secure memory (via a \spec{\ac{TD} Owner bit}) and, optionally, a \ac{MAC} for integrity and authentication checking. The encryption can prevent some physical attacks, like the cold boot attack. Please see \S\ref{sec:memprotect:MKTME} for more details on \ac{MKTME} and \acp{HKID}.

\nip{Memory Integrity.}
\label{sec:overview:mem_integrity}
\ac{TDX} provides two distinct mechanisms for ensuring memory integrity: \spec{\ac{Li}} and \spec{\ac{Ci}}. \ac{Li} protects the integrity against software-level attacks by preventing unauthorized encryption and reads of secure memory. It restricts the use of private \acp{HKID} and reads of secure memory. It checks that only processes running in the \ac{SEAM} mode can encrypt with the private \ac{HKID} and read a cache line whose \spec{\ac{TD} Owner bit} is set to $1$. This functionality does not prevent adversaries with direct access to the main memory from setting arbitrary content of the cache line and \spec{\ac{TD} Owner bit}. This opens up a possibility for rollbacks of individual cache lines. 
\ac{Ci} is an advanced mechanism that addresses the limitations of \ac{Li}, which does not detect malicious direct memory writes or bit flips (\eg via a Rowhammer attack~\cite{rowhammer-ieee-2014}). It prevents an adversary with physical access to the main memory from tampering with the memory content. We provide a more detailed technical discussion of the memory integrity protection in \S\ref{sec:memprotect:TD_memory_integrity}.

\subsection{TDX I/O Model}
According to the \ac{TDX} threat model, hypervisors and peripheral devices are considered untrusted and are prohibited from directly accessing the private memory of \acp{TD}. It is the responsibility of \acp{TD} and their owners to secure I/O data before it leaves the trust boundary. This requires sealing the I/O data buffers and placing them in shared memory, which is identified by the \spec{shared} bit in the \acl{GPA}. Hypervisors or peripheral devices can then move the data in and out of the shared memory. This necessitates modifications to the guest kernel to support this I/O model. Furthermore, all I/O data that is transferred into the \acp{TD} from hypervisors or peripheral devices must be thoroughly examined and validated, as it is no longer considered trustworthy.

In the Linux guest support for \ac{TDX}, all \ac{MMIO} regions and \ac{DMA} buffers have been mapped as shared memory within the \acp{TD}. The Linux guest is enforced to use \spec{SWIOTLB} to allocate and convert \ac{DMA} buffers in unified locations. To protect against malicious inputs from I/O, only a limited number of hardened drivers~\cite{tdxkernelhardening} are allowed within \acp{TD}.

\subsection{TDX Attestation}
\label{sec:overview:attestation}
Remote attestation is a method for verifying the identity and trustworthiness of a \ac{TEE}. The attester can provide proof to a challenger to show that  computations are being executed within protected domains. The challenger validates the evidence by checking the digital signatures and comparing the measurements to reference values.  

On a \ac{TDX}-enabled machine, the attester operates within a \ac{TD} and is responsible for handling remote attestation requests. When a request is received from a challenger, such as a tenant, the attester provides evidence of proper instantiation of the TD through the generation of a \ac{TD} \spec{quote}. This \spec{quote}, which serves as the evidence, is produced by the \ac{TDX} module and signed by the \acl{QE}. It contains measurements of the \ac{TDX}'s \ac{TCB} and the software components loaded in the \ac{TD}. The \spec{quote} also includes a certificate chain anchored by a certificate issued by Intel. Upon receipt of the \spec{quote}, the challenger verifies its authenticity by checking the \spec{quote} and determining if the attester is running on a genuine \ac{TDX}-enabled platform and if the \ac{TD} has the expected software measurements. If the \spec{quote} is successfully validated, the challenger can proceed to establish a secure channel with the attester or release secrets to the attester. We provide a more detailed technical discussion of remote attestation in \S\ref{sec:remote_attestation}.

\subsection{Future Features}
Live migration and \ac{TEE} I/O are crucial features for confidential \acp{VM} but are currently not supported in \ac{TDX} 1.0. However, according to documents~\cite{tdx-migration,tdxio,deviceattestation}, Intel is planning to include the support for live migration in \ac{TDX} 1.5 and TEE I/O in \ac{TDX} 2.0. These plans are still in progress and may subject to change in the future. Here we provide a brief overview of these two features and explain their design. 

\nip{Live Migration.}
Live migration is an essential feature for cloud service providers as it enables them to transfer running \acp{VM} from one physical host to another without any service interruptions. This functionality is important for maintenance tasks such as hardware upgrades, software patches, and load balancing. However, migrating a \ac{TD} is more complex than migrating a traditional \ac{VM} due to the security concerns of confidential computing. Since the hypervisor is considered untrusted, it is not allowed to directly access and transfer the CPU state and private memory of the \ac{TD} from the source to the destination platform. Furthermore, tenants should have the ability to define and enforce migration policies. For instance, if the destination platform does not meet the \ac{TCB} requirements specified in the policy, the migration should be cancelled. 

Intel introduces Service \acp{TD} to expand the trust boundary of the \ac{TDX} Module. Rather than making the \ac{TDX} Module overly complex and bloated, it is more convenient and flexible to add customized and specialized functionalities into a Service \ac{TD}. A Service TD can be bound to regular \acp{TD} via the \ac{TDX} Module with the access privileges to their assets.

\ac{MigTD} is a Service \ac{TD} that is specifically designed for live migration. The entire live migration session is under the control of the \ac{TDX} Module and the \acp{MigTD}. The untrusted hypervisor, which is controlled by the cloud service provider, is only responsible for transferring the encrypted \ac{TD}'s assets over networks. These assets include the \ac{TD}'s metadata, CPU state, and private memory, and are protected by a \ac{MSK} that is only accessible by the \acp{MigTD} and \ac{TDX} Module.

Both the source and destination platforms have a running \ac{MigTD}. \acp{MigTD} are bound to the source \ac{TD} (to be migrated) and the destination \ac{TD} (initially as a \ac{TD} template waiting for migration), respectively. The \acp{MigTD} are responsible for remote attestation between source and destination platforms and evaluate their \ac{TCB} levels based on security policies. Once the platforms are deemed acceptable for migration, a secure channel is established between the two \acp{MigTD}. The source \ac{MigTD} generates a \ac{MSK}, which is shared to the destination \ac{MigTD} through this secure channel. Both \acp{MigTD} program the \ac{MSK} into the corresponding \ac{TDX} Modules. The source \ac{TDX} Module exports and encrypts the \ac{TD}'s assets with the \ac{MSK}, while the destination \ac{TDX} Module decrypts the assets with the same key and imports them into the destination \ac{TD}. It is worth noting that the source and destination \acp{TD} have their \acp{HKID} assigned independently, thus protected with different \ac{TD} private keys.         

\nip{TEE I/O.}
A computer is comprised of various functional components. However, confidential computing has conceptually shattered the unified trust model. As a result, each component, made by different vendors, can no longer trust each other. This creates a serious impediment to efficient I/O, as untrusted devices cannot read and write data in the private memory of \acp{TEE}. To address this issue, Intel has proposed \ac{TEE} I/O in \ac{TDX} 2.0, aiming to extend the trust from a \ac{TD} to external devices. This requires changes to the devices and the \ac{TDX} platform to use a compatible protocol to establish mutual trust and enable secure communication channels. The key principle is that a \ac{TD} and a device should be able to securely exchange and verify their identities and measurements. Additionally, the data paths between a \ac{TD} and a device are not trusted and may be vulnerable to interception by attackers. Therefore, an end-to-end secure channel is necessary to protect the data transmitted between a \ac{TD} and a device. The detailed protocols for \ac{TEE} I/O can be found in the proposals~\cite{tdxio,deviceattestation}.

