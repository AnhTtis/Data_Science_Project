\section{TDX Module}
\label{sec:tdxmodule}
This section provides an in-depth analysis of the \ac{TDX} Module. We first discuss its loading process in \S\ref{sec:tdxmodule:load}, followed by an explanation of the physical and linear memory layout in \S\ref{sec:tdxmodule:address_space}. We then describe the metadata created by the \ac{TDX} Module to manage \acp{TD} in \S\ref{sec:tdxmodule:td_metadata}, and the process of context switching across security domains in \S\ref{sec:tdxmodule:context}. Additionally, we provide details about the \code{keyhole} structure (\S\ref{sec:tdxmodule:keyhole}) and memory management (\S\ref{sec:tdxmodule:mem_management}) of the \ac{TDX} Module.  

\subsection{Loading the TDX Module}
\label{sec:tdxmodule:load}
%
\begin{figure}[t!]
\centerline{\includegraphics[width=0.8\textwidth]{figures/tdx-module-load.pdf}}
\caption{Loading the TDX Module}
\label{fig:tdx_module_load}
\end{figure}
%
\autoref{fig:tdx_module_load} illustrates the two-stage process of loading the \ac{TDX} Module. The process begins with the loading of the Intel Non-Persistent SEAM Loader (NP-SEAM Loader), which is an Intel \ac{ACM}. \acp{ACM} are Intel-signed modules that run within the internal RAM of the processor. The NP-SEAM Loader is authenticated and loaded by the Intel \ac{TXT}~\cite{txtwhitepaper} through the \code{GETSEC[ENTERACCS]} function. The NP-SEAM Loader contains the image of the Intel Persistent SEAM Loader (P-SEAM Loader), which is then verified and loaded by the NP-SEAM Loader. The P-SEAM Loader is then responsible for installing or updating the \ac{TDX} Module. 

It is important to note that both the P-SEAM Loader and the \ac{TDX} Module are loaded in the \code{\ac{SEAM} RANGE}, which is a portion of system memory reserved via UEFI/BIOS. The range's base address and size are specified by the \code{IA32\_SEAMRR\_PHYS\_BASE} and \code{IA32\_SEAMRR\_PHYS\_MASK} \acp{MSR}. This range is partitioned into \code{Module\_Range} for the \ac{TDX} Module and \code{P\_SEAMLDR\_Range} for the P-SEAM Loader. Both modules run in the \spec{\ac{SEAM} \ac{VMX} root mode} and use \code{SEAMCALL}/\code{SEAMRET} to interact with external software. The NP-SEAM Loader, P-SEAM Loader, and \ac{TDX} Module are all provided and signed by Intel, establishing a chain of trust to bootstrap the \ac{TDX} Module. 


The P-SEAM Loader provides a \code{SEAMCALL} interface function \code{seamldr\_install} for loading the \ac{TDX} Module. The \ac{TDX} Module's image is pre-loaded into a memory buffer (not in the \code{\ac{SEAM} RANGE}). The physical addresses of the buffer and a \code{seam\_sigstruct} (signature of the \ac{TDX} Module) are passed as the parameters to the \code{seamldr\_install}. The \code{seam\_sigstruct} contains the hash value and the \ac{SVN} of the \ac{TDX} Module, the number of per-\ac{LP} stack pages, the number of per-\ac{LP} data pages, and the number of global data pages. These numbers are used by \code{seamldr\_install} to determine the physical/linear addresses and the sizes of the \ac{TDX} Module's various memory regions.

The \code{seamldr\_install} must be called on all \acfp{LP} serially. When \code{seamldr\_install} is called on the first \ac{LP}, an \spec{installation session} starts. On each \ac{LP}, \code{seamldr\_install} checks that the \ac{LP} is not already in an installation session (started by another \ac{LP}), and clears the \ac{LP}'s \ac{VMCS} cache. When \code{seamldr\_install} is called on the last LP, it does the following: 
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
\item 
checking the parameters to the \code{seamldr\_install},
\item 
verifying the signature of the \ac{TDX} Module,
\item
checking the \ac{SVN} of the to-be-loaded image and comparing with the resident \ac{TDX} Module,
\item \label{step:tdx_memory_constants}
determining the physical and linear addresses and sizes of the \ac{TDX} Module's various memory regions in the \code{\ac{SEAM} RANGE}: code, data, stack, page table, \code{sysinfo\_table}, \code{keyhole}, and \code{keyhole-edit} (\S\ref{sec:tdxmodule:address_space}),
\item 
mapping the regions' physical addresses to their linear addresses (\S\ref{sec:tdxmodule:address_space}),
\item 
loading the \ac{TDX} Module's binary image into the \code{\ac{SEAM} RANGE}, measuring the image, computing and verifying the \ac{TDX} Module's hash value,
\item 
setting up the \ac{TDX} Module's \code{sysinfo\_table},
\item \label{step:vmcs} 
setting up \spec{\ac{SEAM} Transfer \ac{VMCS}} on each \ac{LP} (\S\ref{sec:seam_vmcs}),
\item
recording the \ac{TDX} Module's hash, \ac{SVN}, in the P-SEAM Loader's data region.
\end{enumerate}

In addition to the \code{SEAMCALL} to install the \ac{TDX} Module, the P-SEAM Loader also provides other interface functions to shut down itself and retrieve the loader's system information. 

\subsection{Memory Layout of the TDX Module}
\label{sec:tdxmodule:address_space}
Here we discuss the physical and linear memory layout for the \ac{TDX} Module, respectively. 

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/tdx_module_mem_pa.pdf}
    \caption{TDX Module Physical Memory Layout}
    \label{fig:tdx_module_pa}
\end{figure}

\nip{Physical Memory Layout.} \autoref{fig:tdx_module_pa} depicts the physical memory layout of the \ac{TDX} Module within the \code{Module\_Range}. The layout starts with a 4\,KB page that holds the \code{sysinfo\_table} of the \ac{TDX} Module. The \code{sysinfo\_table} consists of 2\,KB platform information populated by \code{MCHECK} from the NP-SEAM Loader and the next 2\,KB populated by the P-SEAM Loader with the \ac{TDX} Module's information, such as the \code{\ac{SEAM} RANGE} base address and size, the base linear addresses of the memory regions, number of \acp{LP}, and range of private \acp{HKID}. After the \code{sysinfo\_table}, there is the per-\ac{LP} \ac{VMCS} region. Each \ac{LP} has a 4\,KB \spec{\ac{SEAM} Transfer \ac{VMCS}} (see \S\ref{sec:seam_vmcs}). Following the per-\ac{LP} \ac{VMCS} region, there is the data region, which is partitioned into per-\ac{LP} data region and a global data region. Next, there is the \ac{TDX} Module's 4-level page table, followed by the per-\ac{LP} stack regions, and finally, the code region for the \ac{TDX} Module's executable code. 

\begin{figure}[ht!]
    \centerline{\includegraphics[width=1\textwidth]{figures/tdx_module_mem_la.pdf}}
    \caption{TDX Module Linear Memory Layout}
    \label{fig:tdx_module_la}
\end{figure}

\nip{Linear Memory Layout.} 
The \ac{TDX} Module has its own linear address space and maintains a page table to translate addresses. \autoref{fig:tdx_module_la} illustrates the layout of the \ac{TDX} Module's linear address space, which is established by the P-SEAM Loader through the construction of the \ac{TDX} Module's page table. To prevent memory corruption attacks, the P-SEAM Loader randomizes bits $34$ to $46$ of the linear addresses, which are represented by boxes in \autoref{fig:tdx_module_la}. The linear addresses and the sizes of all regions are recorded in the fields of the \code{sysinfo\_table}. The page table entries for code, stack, data, and \code{sysinfo\_table} can be statically populated in advance and require no changes to the page table at runtime. However, the \code{keyhole} region serves to map data passed from external software dynamically during the execution of the \ac{TDX} Module. This requires the addition of the \code{keyhole-edit} region to allow runtime editing of the page table entries for the \code{keyhole}'s mapping. A detailed discussion of the \code{keyhole} and \code{keyhole-edit} regions can be found in \S\ref{sec:tdxmodule:keyhole}.


\subsection{Platform Initialization}
During the platform initialization, the hypervisor makes a \code{SEAMCALL[TDH.SYS.INIT]} to globally initialize the \ac{TDX} Module. Then, the hypervisor makes a \code{SEAMCALL[TDH.SYS.LP.INIT]} on each \ac{LP} to check and initialize per-\ac{LP} parameters, such as \code{keyholes} (\S\ref{sec:tdxmodule:keyhole}), data regions, and stack regions (\S\ref{sec:tdxmodule:address_space}). 
Next, the hypervisor allocates a global private \ac{HKID} and passes it to the \ac{TDX} Module through a \code{SEAMCALL[TDH.SYS.CONFIG]}, which also initializes the \ac{TDMR} (\S\ref{sec:tdxmodule:mem_management}).
The \code{SEAMCALL[TDH.SYS.KEY.CONFIG]} on each processor package generates a \ac{TDX} global private key and binds the key with this \ac{HKID}. This key is used to encrypt memory that holds \acf{PAMT} and \ac{TDR} (\S\ref{sec:tdxmodule:td_metadata}) of each \ac{TD}. 
Finally, the hypervisor calls \code{SEAMCALL[TDH.SYS.TDMR.INIT]} multiple times to gradually initialize the \ac{PAMT}(\S\ref{sec:tdxmodule:mem_management}) for each \ac{TDMR}. 

\subsection{Metadata for TDs}
\label{sec:tdxmodule:td_metadata}
The \ac{TDX} Module is responsible for managing the entire life-cycle of \acp{TD}. As such, it needs to maintain metadata for each \ac{TD} instance. 
The \ac{TDX} Module ensures that the memory encryption is applied to the metadata to prevent the hypervisor from accessing or modifying it. 

Each \ac{TD}'s metadata consists of the following control structures: \acf{TDR}, \acf{TDCS}, \acf{TDVPS}, and \acf{SEPT}. \autoref{fig:metadata} illustrates the relationships between these control structures.
\begin{figure}[t!]
    \centerline{\includegraphics[width=0.8\textwidth]{figures/metadata.pdf}}
    \caption{Relationship of \ac{TD}'s Metadata}
    \label{fig:metadata}
\end{figure}

\nip{\ac{TDR}.} \ac{TDR} is the initial structure that is created at the inception of a \ac{TD} and is destroyed when the \ac{TD} is terminated. During the entire life-cycle of the \ac{TD}, \code{SEAMCALLs} use the physical address of the corresponding \ac{TDR} to refer to the \ac{TD}. The \ac{TDR} comprises the key information for memory encryption and references to the TDCX pages (physical memory pages for the \ac{TDCS}). As the \ac{TDR} is created before the \ac{TD}'s private key is generated, it is protected with the global private key of the \ac{TDX} Module. The subsequent metadata (\ac{TDCS}, \ac{TDVPS}, and \ac{SEPT}), along with the \ac{TD}'s memory pages, can be associated with the \ac{TDR} through the \emph{owner} attribute in the \ac{PAMT} (\S\ref{sec:tdxmodule:mem_management}).

\nip{\ac{TDCS}.} \ac{TDCS} is a control structure that manages the operations and stores the state at the scope of a \ac{TD}. It is comprised of four continuous TDCX memory pages, each allocated for a specific purpose, such as \ac{TD}'s management structures, \ac{MSR} bitmaps, \ac{SEPT} root page, and a special zero page. \ac{TDCS} is encrypted with the \ac{TD}'s private key, which is generated when the \ac{TDR} is created.

\nip{\ac{TDVPS}.} \ac{TDVPS} is a control structure for each virtual CPU of a \ac{TD}. It is comprised of six memory pages, starting from a TDVPR page that contains references to multiple TDVPX pages. The first TDVPR page holds the fields for \ac{VE} information, virtual CPU management, guest state, and guest \ac{MSR} state. The second page is for the \spec{\ac{TD} Transfer \ac{VMCS}} (\S\ref{sec:td_vmcs}), which controls the \ac{TD}'s entry and exit. The third page is a virtual APIC (VAPIC) page, followed by three pages for guest extension information. Like the \ac{TDCS}, the \ac{TDVPS} is also protected by the \ac{TD}'s private key.

\nip{\ac{SEPT}.} For legacy \acp{VM}, hypervisors manage address translations from \ac{GPA} to \ac{HPA} using \ac{EPT}. However, in \ac{TDX}, guest address translations must be protected from untrusted hypervisors. To achieve this, \ac{TDX} has two types of \ac{EPT}: \spec{\acf{SEPT}} and \spec{Shared \ac{EPT}}. \spec{\acl{SEPT}} is used to translate addresses of a \ac{TD}'s private memory and is protected by the \ac{TD}'s private key. The reference to the \ac{SEPT} and the \ac{SEPT} root page are stored in the \ac{TDCS}. \spec{Shared \ac{EPT}}, on the other hand, is used to translate addresses for memory explicitly shared by the \ac{TD} with a hypervisor, such as in the case of virtualized I/O. It remains under the control of the hypervisor. The guest kernel in the \ac{TD} can determine which memory pages to share by setting the \spec{shared} bit in the \ac{GPA}. Shared memory pages are not encrypted with the \ac{TD}'s private key.

\subsection{Context Switches}
\label{sec:tdxmodule:context}
There are two types of context switches for \ac{TDX}: the first occurs between the hypervisor and the \ac{TDX} Module, while the second occurs between \acp{TD} and the \ac{TDX} Module. We delve into each of these in more detail.


\nip{Hypervisor $\leftrightarrow$ \ac{TDX} Module.}\label{sec:seam_vmcs}
In \ac{TDX}, a hypervisor is prohibited from directly managing \acp{TD}. Instead, it must interact with the \ac{TDX} Module through \code{SEAMCALL} interface functions. When a \code{SEAMCALL} is made, the processor transitions from the \spec{\ac{VMX} root mode} to the \spec{\ac{SEAM} \ac{VMX} root mode}. The \ac{TDX} Module's \spec{\ac{SEAM} Transfer \ac{VMCS}} is loaded. This \spec{\ac{SEAM} Transfer \ac{VMCS}} is set up by the P-SEAM Loader for each \ac{LP} and is stored within the \code{Module\_Range}.

The repurposing of \ac{VMCS} for context switches between the hypervisor and the \ac{TDX} Module may seem confusing initially, as the hypervisor is not a ``guest \ac{VM}'' and the \ac{TDX} Module is not a ``host hypervisor.'' We can disregard the guest/host concept and only view the \spec{\ac{SEAM} Transfer \ac{VMCS}} as a means of switching the execution context between the hypervisor and the \ac{TDX} Module. 

\begin{figure}[t!]
    \centerline{\includegraphics[width=0.7\textwidth]{figures/SEAM_VMCS.pdf}}
    \caption{Per-LP \spec{\ac{SEAM} Transfer \ac{VMCS}} Layout}
    \label{fig:seam_vmcs}
\end{figure}
\autoref{fig:seam_vmcs} depicts the location and layout of the \spec{\ac{SEAM} Transfer \ac{VMCS}} regions in the \code{Module\_Range}, which begins at the \code{SEAMRR\_Base}. The first 4\,KB page in the \code{Module\_Range} is the \code{sysinfo\_table}. Starting from \code{SEAMRR\_Base + 4\,KB}, there is an array of per-\ac{LP} \spec{\ac{SEAM} Transfer \ac{VMCS}} regions. Each region is a 4\,KB page. This array is indexed by the identifier of the \ac{LP}, denoted by \code{LP\_ID}. 

When a \code{SEAMCALL} instruction is executed, the processor searches for the \ac{VMCS} address based on the current \code{LP\_ID}. The address is determined by: \code{SEAMRR\_Base + 4\,KB + (\ac{LP}\_ID $\times$ 4\,KB)}. The \ac{TDX} Module's state is stored in the \emph{host-state area} of the \ac{VMCS}. For instance, the host \code{RIP} is set to the \code{tdx\_seamcall\_entry\_point} of the \ac{TDX} Module, and the host \code{CR3} is set to the physical address of the \ac{TDX} Module's \code{PML4} base. Moreover, the host \code{FS\_BASE} is set to the linear address of the \code{sysinfo\_table} and the host \code{GS\_BASE} is set to the per-LP data region. 

When the \ac{LP} transitions into the \ac{TDX} Module through the \code{SEAMCALL} instruction, the information stored in the \spec{\ac{SEAM} Transfer \ac{VMCS}} is loaded onto the processor. Therefore, the \code{FS\_BASE} and \code{GS\_BASE} now point to the \code{sysinfo\_table} and the local data region of the \ac{TDX} Module, respectively. The \code{CR3} register points to the \ac{TDX} Module's page table, thereby switching \ac{MMU} to operate in the \ac{TDX} Module's linear address space. The \ac{TDX} Module starts to handle the \code{SEAMCALL} and dispatch it to corresponding interface functions. 

\nip{TD $\leftrightarrow$ \ac{TDX} Module.}
\label{sec:td_vmcs}
In traditional virtualization, the hypervisor handles \ac{VM} exits, which are controlled by the \ac{VM}'s \spec{Transfer \ac{VMCS}}. Each \ac{VMCS} is associated with one virtual CPU and stores the virtual CPU state for recovering the guest execution in the next \ac{VM} resume. However, this operation leaks the virtual CPU state as \ac{VMCS} is visible to hypervisors. In \ac{TDX}, synchronous \code{TDCALLs} or asynchronous \ac{TD} exits are designed to trap into the \ac{TDX} Module. This is controlled by the \spec{\ac{TD} Transfer \ac{VMCS}}, which is set up when a virtual CPU of a \ac{TD} is created and is stored in the \ac{TD}'s \ac{TDVPS}. The \ac{TDVPS} is encrypted with the \ac{TD}'s private key (\S\ref{sec:tdxmodule:td_metadata}). Therefore, the \spec{\ac{TD} Transfer \ac{VMCS}} is inaccessible to untrusted hypervisors. When a \ac{TD} calls a \code{TDCALL} or triggers a \ac{TD} exit, the \ac{LP} loads the state of the \ac{TDX} Module stored in the \spec{\ac{TD} Transfer \ac{VMCS}} to switch context.  

In \ac{TDX}, certain \ac{TD} exits cannot be fully handled by the \ac{TDX} Module and instead require a hypervisor to emulate certain operations, such as port I/O, \code{HLT}, \code{CPUID}, and more. However, traditional hypervisors have access to the entire virtual CPU states and memory, exposing more information than necessary to handle these exits. \ac{TDX} addresses this issue by introducing a new mechanism for handling TD exits. All \ac{TD} exits first trap into the \ac{TDX} Module, which injects a \acf{VE} into the \ac{TD} to handle the exit. The \ac{TD}'s guest kernel includes a corresponding \ac{VE} handler that prepares a minimized set of parameters and invokes a \code{TDCALL} to re-enter the \ac{TDX} Module. At this point, the \ac{TDX} Module can safely ask the hypervisor to handle the requests with minimal exposure of sensitive information.

\subsection{Keyholes}
\label{sec:tdxmodule:keyhole}
All memory buffers passed through \code{SEAMCALLs} use their physical addresses as references. The \ac{TDX} Module must map these buffers into its own linear address space to access them. This mapping process is facilitated by the \code{keyhole} and \code{keyhole-edit} regions, which serve as temporary ``leases'' of linear addresses.

The \code{keyhole} region is a reserved linear address range specifically for address mapping. The region is comprised of an array of \code{keyholes}. This array is further divided into $128$-\code{keyhole} segments, with each segment assigned to one \ac{LP}. The \ac{TDX} Module organizes free \code{keyholes} in an LRU list when setting up per-\ac{LP} data structures. Each \code{keyhole} corresponds to a 4\,KB aligned linear address and links to a physical memory page. Since multiple memory buffers can exist within the same memory page, each \code{keyhole} maintains a \emph{reference count} to track the number of referenced buffers in the page. 

When the \ac{TDX} Module is installed by the P-SEAM Loader, all the linear addresses of \code{keyholes} are mapped to an empty physical address. This is achieved by setting all the leaf-level page table entries (PTEs) for the \code{keyhole} region in the \ac{TDX} Module's page table to zero. Simultaneously, the physical addresses of the corresponding PTEs for the \code{keyholes} are mapped to the \code{keyhole-edit} region. This enables the \ac{TDX} Module to locate and modify the \code{keyhole}'s address mappings in its page table during runtime. 


When processing a \code{SEAMCALL} that refers to an external memory buffer with a physical address, the \ac{TDX} Module checks if the buffer's memory page is already mapped by a \code{keyhole}. If so, it increments the \code{keyhole}'s \spec{reference count} and returns the mapped linear address. If not, it selects a free \code{keyhole} from the LRU list and maps the linear address of this \code{keyhole} to the page table by updating the corresponding PTE referenced in the \code{keyhole-edit} region. Once the buffer is mapped, the \ac{TDX} Module can access it using the \code{keyhole}'s linear address. At the end of each \code{SEAMCALL}, the \spec{reference counts} of corresponding \code{keyholes} decrement, and any non-referenced \code{keyholes} return to the LRU list. 

\subsection{Physical Memory Management}
\label{sec:tdxmodule:mem_management}
The \ac{TDX} Module manages physical memory by using a set of \acfp{TDMR} and their control structures, \acfp{PAMT}. \acp{TDMR} are constructed by the hypervisor based on a list of \acp{CMR}, which are the memory regions that can be used for \ac{TD}'s private memory or metadata. These regions are subject to \ac{MKTME} encryption and \ac{TDX} memory integrity protection. This list of \acp{CMR} is prepared by the UEFI/BIOS.

Each \ac{TDMR} is a single range of physical memory that is 1\,GB aligned and has a size that is an integral multiple of 1\,GB, but does not necessarily need to be a power of two. Two \acp{TDMR} cannot overlap. A \ac{TDMR} may contain \spec{reserved areas} that cannot be used by the \ac{TDX} Module. A reserved area is an array of 4\,KB aligned memory pages (each page is 4\,KB). Memory in a \ac{TDMR}, except for the reserved areas, must be convertible. It should be noted that \ac{TDMR} configuration is managed by software without using hardware range registers. 

The \ac{TDX} Module uses \ac{PAMT} to track page attributes of each physical memory page in a \ac{TDMR}. The attributes contain the information about the \spec{page owner}, \spec{page type}, and \spec{page size}. The page attributes allow the \ac{TDX} Module to ensure that a physical memory page in a \ac{TDMR} has a proper type and is only assigned to at most one \ac{TD}. When a page is assigned to a \ac{TD}'s private memory, the \ac{TDX} Module can check whether the page size in the \ac{SEPT} and \ac{PAMT} are consistent.

A \ac{PAMT} is divided into blocks, where each block tracks page addresses within the 1\,GB size range. Each block has three levels to track metadata for pages with sizes 4\,KB, 2\,MB, and 1\,GB, respectively. The first level tracks a single 1\,GB page, the second level tracks $512$ 2\,MB pages, and the third level tracks $512 \times 512$ 4\,KB pages. Given a physical address, the \ac{TDX} Module can perform a \ac{PAMT} hierarchical walk to retrieve its page attributes for a sanity check. 

The \ac{TDX} Module manages the data structure by updating the attributes of each page it uses during runtime. Any operation that requires accessing, removing, or adding a page causes the \ac{TDX} Module to walk through \ac{PAMT} to adjust the page attributes and check corresponding access rights. The memory for \ac{PAMT} is allocated by the hypervisor and is encrypted with the \ac{TDX} Module's global private key.