\section{Building Blocks for \acs{TDX}}
\label{sec:background}
\ac{TDX} relies on a combination of existing Intel technologies, including \acf{VT}, \acf{TME}/\acf{MKTME}, and \acf{SGX}. In this section, we provide an overview of these underpinning technologies and explain how they are used in \ac{TDX}. A summary of these technologies can be found in Table~\ref{tab:summary-technologies-intel}.

\begin{table}[t!]
\caption{Summary of Existing Building Blocks for TDX}
\label{tab:summary-technologies-intel}
\small
\begin{tabular}{l|l}
\hline
\textbf{Technology} & \textbf{Summary} \\ \hline
Intel VT~\cite{vtx} & \begin{tabular}[c]{@{}l@{}}- provides hardware-assisted virtualization for CPU, memory, and I/O\\
- enforces isolation among \acp{VM} via a trusted hypervisor
\end{tabular}\\ \hline
Intel TME & \begin{tabular}[c]{@{}l@{}}- encrypts entire main memory\\ - uses a single and boot-time generated transient key\\ - uses the AES-XTS algorithm with 128-bit keys or 256-bit keys\end{tabular} \\ \hline
Intel MKTME~\cite{mktmewhitepaper} & \begin{tabular}[c]{@{}l@{}}- supports multiple keys for memory encryption\\ - enables memory encryption at the page granularity\end{tabular} \\ \hline
Intel SGX~\cite{mckeen2013innovative} & \begin{tabular}[c]{@{}l@{}}- encloses sensitive code and data of an application within an enclave\\ - protects against memory bus snooping and cold boot attacks with memory encryption\\ - supports local and remote attestation\end{tabular} \\ \hline
\end{tabular}
\end{table}

\subsection{Intel VT}
Intel \ac{VT}~\cite{vtx} is a set of hardware-assisted virtualization features in Intel processors. Using \ac{VT}, \acp{VMM} or hypervisors can achieve better performance, isolation, and security compared to the software-based virtualization. Intel's \ac{VT} portfolio includes, among others, virtualization of CPU, memory, and I/O. 

Processors with \ac{VT}-x technology have a special instruction set, called \ac{VMX}, which enables control of virtualization. Processors with VT-x technology can operate in two modes: \spec{\ac{VMX} root mode} and \spec{\ac{VMX} non-root mode}. The hypervisor runs in \spec{\ac{VMX} root mode} while the guest \acp{VM} run in the \spec{\ac{VMX} non-root mode}. \ac{VT}-x defines two new transitions, \ac{VM} entry and \ac{VM} exit, to switch between the guest and the hypervisor. The \ac{VMCS} is a data structure that stores \ac{VM} and host state information for mode transitions. It also controls which guest operations can cause \ac{VM} exits.

Intel \ac{VT}-x utilizes \ac{EPT} for implementing \ac{SLAT}. Each guest kernel maintains its own page table to translate \ac{GVA} to \ac{GPA}. The hypervisor manages \ac{EPT} to map \ac{GPA} to \ac{HPA}. 

\acp{VM} can use different I/O models, including software-based and hardware-based models, to access I/O devices. Software-based I/O models involve emulated devices or para-virtualized devices, while hardware-based I/O models include direct device assignment, \ac{SR-IOV} devices, and \ac{S-IOV} devices.

Intel \ac{VT} for Directed I/O (\ac{VT}-d) enables the isolation and restriction of device accesses to entities managing the device. It includes I/O device assignment, \ac{DMA} remapping, interrupt remapping, and interrupt posting. With the support of \ac{VT}-d, \acp{VM} can directly access physical I/O memory through virtual-to-physical address translation with the help of the \ac{IOMMU}. \ac{VT}-d also provides flexibility in I/O device assignments to \acp{VM} and eliminates the need for the hypervisor to handle interrupts and \ac{DMA} transfers. Overall, \ac{VT}-d enhances the performance and security of virtualized environments that require direct access to I/O devices.


\nip{\ac{VT} $\Rightarrow$ \ac{TDX}.} \ac{TDX} is a \ac{VM}-based \ac{TEE}. It relies on the \ac{VT} to provide isolation among \acp{TD}. As the hypervisor is no longer trusted in the new threat model, the functionalities of managing \acp{TD} have been enclosed within the \ac{TDX} Module. The \ac{TDX} Module and \acp{TD}  run in the new \spec{\ac{SEAM} \ac{VMX} root/non-root mode} with additional protection. \ac{TDX} still leverages \ac{EPT} to manage \ac{GPA}-to-\ac{HPA} translation. But currently it maintains two \acp{EPT} for each \ac{TD}, a protected one for private (encrypted) memory and another one for shared (unencrypted) memory. We explain in more details the \ac{TDX}'s architecture and the \ac{TDX} Module in \S\ref{sec:overview:architecture} and \S\ref{sec:tdxmodule}. 

It is worth noting that currently nested virtualization is not supported in \ac{TDX} 1.0, which means that running \acp{VM} within a \ac{TD} is not allowed. Attempting to use \ac{VMX} instructions within a \ac{TD} can result in \ac{UD} exceptions. But the TD partitioning architecture specification draft~\cite{tdpartitioning} indicates that nested virtualization will be supported in \ac{TDX} 1.5 in the future.   

\subsection{Intel TME/MKTME}
\label{sec:background:mktme}
\ac{TME} was first introduced with the Intel 11th Generation Core vPro mobile processor. This feature is designed to protect against attackers who have physical access to a computer's memory and attempt to steal data. \ac{TME} encrypts the entire computer's memory using a single transient key. The key is generated at boot-time through a combination of hardware-based random number generators and security measures integrated into the system's chipset. Memory encryption is performed by encryption engines on each memory controller. The encryption process uses the NIST standard AES-XTS algorithm with 128-bit or 256-bit keys.

\ac{MKTME}~\cite{mktmewhitepaper} extends \ac{TME} to support multiple keys and memory encryption at page granularity. For each memory transaction, \ac{MKTME} selects an encryption key to encrypt memory based on the \ac{HKID}. \ac{HKID} occupies a configurable number of bits from the top of the physical address. The \acp{HKID} range is set by the BIOS during system boot. \ac{MKTME} allows for software-provided keys and introduces a new instruction, \code{PCONFIG}, for programming the key and encryption mode associated with a particular \ac{HKID}. These \code{$\langle\ac{HKID}, key\rangle$} tuples are stored in the \ac{KET}, which is held by each \ac{MKTME} encryption engine. The keys in the \ac{KET} never leave the processor and are never exposed to software. \ac{MKTME} can be used in both native and virtualized environments. In the virtualized environments, hypervisors control the memory encryption for different \acp{VM} by attaching \acp{HKID} to \ac{VM}'s physical addresses in \ac{EPT}.  

\nip{\ac{MKTME} $\Rightarrow$ \ac{TDX}.} To use \ac{MKTME} in the virtualized environments, the hypervisor must be trusted to control the memory encryption, which violates the new threat model for confidential computing. Therefore, in \ac{TDX}, the \ac{TDX} Module is responsible for controlling memory encryption for \acp{TD}. The \ac{HKID} space has been partitioned to private \acp{HKID} and shared \acp{HKID}. The private \acp{HKID} can only be used for encrypting private memory of \acp{TD}. The \ac{TDX} Module still leverages \ac{MKTME} to protect \ac{TD}'s memory. More information about how \ac{TDX} uses \ac{MKTME} can be found in \S\ref{sec:overview:mem_protect} and \S\ref{sec:memprotect}.

\subsection{Intel SGX}
Intel introduced \ac{SGX}~\cite{mckeen2013innovative} in 2015 with the 6th Generation Core processors to protect against memory bus snooping and cold boot attacks. It enables developers to partition their applications and protect selected code and data within enclaves. The memory of an enclave can only be accessed by authorized code. \ac{SGX} uses hardware-based memory encryption to protect the enclave's contents. Any unauthorized attempts to access or tamper with the enclave's memory can trigger exceptions.
\ac{SGX} adds 18 new instructions into Intel's \ac{ISA} and enables secure offloading of computations to environments where the underlying host components (such as hosting application, host kernel, \ac{SMM}, and peripheral devices) are untrustworthy. \ac{SGX}'s security ultimately depends on the security of the firmware and microcode that implement its features.


The \ac{EPC} is a special memory region that contains the enclave's code and data, where each page is encrypted using the \ac{MEE}. The \ac{EPCM} stores the page metadata, such as configuration, permissions, and type of each page. 
At boot time, keys are generated and used for decrypting the contents of encrypted pages inside the CPU. The keys are controlled by the \ac{MEE} and never exposed to the outside. Thus, only this particular CPU can decrypt the memory.
The CPU stores these keys internally and prevents access to them by any software. Additionally, privileged software out of enclaves is not allowed to read or write the \ac{EPC} or \ac{EPCM} pages. 


\ac{SGX} offers both local and remote attestation to verify the integrity and authenticity of enclaves. Local attestation is used to establish trust between two enclaves within the same platform, while remote attestation verifies the trustworthiness of an enclave to a third-party entity off the platform.
In local attestation, an enclave can verify another enclave's integrity and the genuineness of the underlying hardware platform. 
To do so, the first enclave generates a \spec{report} and uses the identity information of the second enclave to sign it. The second enclave retrieves its Report Key and verifies the report using this Report Key. 
A third party may want to establish trust with a remotely executed enclave before provisioning it with secrets.
In this scenario, remote attestation is necessary. To perform remote attestation, \ac{SGX} utilizes a special architectural enclave known as the \ac{QE}. The \ac{QE} is developed and signed by Intel. 
The \ac{QE} receives a \spec{report} from another enclave, locally verifies it, and transforms it into a remotely verifiable \spec{quote} by signing it with the Attestation Key. The relying party can send this \spec{quote} to the \ac{IAS}, which verifies the \spec{quote} to identify and assess the trustworthiness of the \ac{SGX} enclave. The \ac{QE}'s role is to provide a secure and trustworthy environment for the transformation of a \spec{report} into a \spec{quote}, and to ensure the \spec{quote} cannot be modified or falsified. Intel also provides \acf{DCAP}~\cite{dcapwhitepaper}, which is a composition of software packages, for datacenters to deploy their own ECDSA attestation infrastructures for \ac{SGX} enclave attestation.


Researchers have used \ac{SGX} to provide secure containers (\eg SCONE~\cite{arnautov2016scone}) and shielded execution for unmodified applications (\eg Haven~\cite{baumann2015shielding}). Graphene~\cite{tsai2017graphene}, an \ac{SGX}-based framework, provides techniques for running unmodified applications as well as dynamic libraries inside \ac{SGX} enclaves. Besides, \ac{SGX} has a wide spectrum of applications ranging from the function encryption system (\eg Iron~\cite{fisch2017iron}), source code partitioning to protect security-sensitive data and functions (\eg Glamdring~\cite{lind2017glamdring}), machine learning~\cite{ohrimenko2016oblivious,gu2018confidential,tramer2018slalom,gu2019reaching}, network security~\cite{beekman2016attestation}, fault-tolerant~\cite{behl2017hybrids}, encrypted data search (\eg HardIDX~\cite{fuhry2017hardidx}), secure databases (\eg EnclaveDB~\cite{priebe2018enclavedb}), secure coordination for distributed system (\eg SecureKeeper~\cite{brenner2016securekeeper}), and secure distributed computations (\eg VC3~\cite{schuster2015vc3}). 
Identifying vulnerabilities of \ac{SGX} is another important line of research. Researchers also have identified a wide range of attack vectors targeting \ac{SGX}, such as controlled-channel attacks~\cite{xu2015controlled, van2017telling, van2017sgx, wang2017leaky}, cache attacks~\cite{moghimi2017cachezoom, gotzfried2017cache, schwarz2017malware, brasser2017software}, branch prediction attacks~\cite{lee2017inferring, evtyushkin2018branchscope}, and speculative execution attacks~\cite{chen2019sgxpectre, koruyeh2018spectre}. 

\nip{\ac{SGX} $\Rightarrow$ \ac{TDX}.} \ac{SGX} and \ac{TDX} protect memory at different granularities. But on the same platform, \ac{TDX} and \ac{SGX} are within the same \ac{TCB}. Thus, they can locally attest each other. \ac{TDX} leverages the remote attestation mechanism provided by \ac{SGX}. The attestation report of a \ac{TDX} platform can be verified and signed within a \acl{QE}. More details about \ac{TDX}'s remote attestation can be found in \S\ref{sec:overview:attestation} and \S\ref{sec:remote_attestation}. 

It is worth noting that at the moment, running an \ac{SGX} enclave within a \ac{TD} is not allowed, as invoking \code{ENCLS}/\code{ENCLV} instructions within a TD can lead to \ac{UD} exceptions.