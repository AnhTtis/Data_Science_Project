\section{Background and related work}

\subsection{Trusted execution environments}
Ubiquitous nature of cloud computing as a de facto large-scale application 
deployment paradigm resulted in a new security challenge -- protecting sensitive 
user data in a large, complex, and potentially untrusted environment of 
a cloud provider. 
To address the growing security concerns, a range of academic~\cite{sanctum} and
industry~\cite{intel-sdm,trustzone} projects proposed the idea of trusted execution
environments~(TEEs) in which the execution of a user program can be shielded from the 
rest of the software and hardware stack of the cloud provider.
TEEs provide isolated environments, or \textit{enclaves}, that ensure 
confidentiality and integrity of the user workload by relying only on the
processor.


Intel SkyLake architecture introduced software guard extensions
(SGX) that implement secure enclave for user-level applications through a 
combination of novel architectural extensions and CPU microcode.
SGX suffered from numerous vulnerabilities~\cite{sgx-attacks:survey},
ranging from access to the secrets inside the enclave to extracting the 
quoting enclave's attestation keys that allowed attackers to forge 
attestation reports~\cite{sgx-attack:foreshadow}.

In 2016, AMD introduced secure encrypted virtualization (SEV), where the
entire virtual machine --- as opposed to just part of an application --- 
was encrypted with an ephemeral key managed by a dedicated co-processor, 
AMD secure processor~(AMD-SP).
AMD-SP takes care of the lifecycle management of the \sev{}
VMs~\cite{spec:amd-sev} and serves as the integrated root-of-trust for the
AMD processor~\cite{wp:amd-sp}.
By using a unique key per VM, \sev{} isolates the guest VMs from the rest
of the host operating system and from other guests.

Intel trust domain extensions~(TDX) introduced their own
version of hardware-isolated encrypted virtual machines called trusted
domains~(TDs).
Intel TDX relies on an SGX-based quoting enclave called the TD-quoting
enclave to perform remote attestation of trusted domains~\cite{spec:intel-tdx}.
Unfortunately, the attestation keys used by the quoting enclave are long-lived, and when
leaked, affect millions of devices.

ARM introduced confidential compute architecture~(CCA) with their Armv9-A
architecture, where the processor provides an isolated hardware execution
environment called \emph{Realms}, for hosting entire VMs in a secure
space~\cite{wp:arm-cca}.
Similar to other TEEs~\cite{wp:amd-sev, spec:intel-tdx} ARM CCA provides
launch measurement for the realms and can do measured boot with their hardware
enforced security~(HES) module specification~\cite{spec:arm-cca-sec-model}
which serves as the root-of-trust~\cite{arm-cca:rss, arm-cca:rss-talk}.

\paragraph{AMD secure encrypted virtualization}

Since 2016, AMD has incrementally added additional protection features to SEV.
\seves{} (SEV encrypted state) protects the register state in the virtual
machine control block (VMCB) with encryption and integrity
protection~\cite{wp:sev-es}.
To communicate and share data with the hypervisor during hypercalls, guest
hypervisor communication block (GHCB) was introduced~\cite{spec:ghcb} that
would remain unencrypted.
Finally, with \snp{} (secure nested paging), AMD
introduced a reverse mapping table (RMP) which performs page validation and
keeps track of page ownership to prevent replay attacks~\cite{wp:sev-snp}.

\paragraph{Virtual machine privilege levels}
To avoid relying on the host infrastructure for running secure services for
the \cvm{}, AMD also introduced virtual machine privilege levels (VMPLs) in
\snp{}.
Similar to protection rings in x86 architecture, VMPLs allow a guest VM
address space to be subdivided into four levels with different privileges
(with \vmpl{0} being the highest privilege level).
Implementing privilege isolated abstraction layers with \vmpl{} allows the
design and deployment of secure services that are completely isolated from
the untrusted host operating system and the guest VM~\cite{wp:sev-snp}.

To standardize the communication between various services offered by the
software running at \vmpl{0} and the guest operating system AMD introduced
a specification called Secure VM service module
(\svsm{})~\cite{spec:sev-svsm}.
The protocol uses registers to pass the arguments and return values.
In the absence of \svsm{} firmware, the entire guest VM can execute under
\vmpl{0} unmodified.
However, with \svsm{}, they run at a lower privilege level,
corresponding to a higher VMPL~(i.e., 1-3), and require interaction with the
\svsm{} for some privileged operations.


\subsection{Integrity}

TEEs ensure confidentiality of the workload but do not 
guarantee integrity.
The trusted platform module~(TPM) is used along with a TEE to implement 
a secure root-of-trust in hardware. 
A TPM measures and records the cryptographic hash of the software during 
the boot process and reliably verifies the same at a later point in time.
TPM is implemented as a cryptographic co-processor chip that is embedded on
the motherboard of a platform.
It provides several cryptographic operations (e.g., encryption, signing,
hashing) and secure storage for small data such as keys.

\paragraph{Measured boot}

Measured boot is the process of recording the measurements of all boot
components during the system initialization process.
Hashes of all components are recorded in a log file that is authenticated
using the TPM.
This authentication works by extending TPM's Platform Configuration Registers (PCRs)
with digests of individual events in the boot log.
A TPM-signed \emph{quote} is used to vouch for the accuracy of the log.

\paragraph{Runtime integrity}

Integrity measurement architecture~(IMA) is a Linux subsystem that implements the idea 
of measured boot after the system is booted, e.g., measures hashes of all kernel extensions
before they are executed~\cite{ima}.
Together with measured boot, IMA enables a remote attestation protocol to ensure the
runtime integrity of the system.
Specifically, it allows an outside observer to ascertain specific
properties of a set of devices/machines.
As an example, one might be interested to ascertain the booted kernel, on a
set of machines in a data center. These properties of interest are
cumulatively called an attestation policy.
To ensure the integrity of the measurements, IMA relies on the TPM, i.e., extends the measurements 
into the TPM PCRs, similar to the measured boot log.

Measured boot and remote attestation are designed to stop an attacker who has control 
over the boot sequence of a system, e.g., an untrusted cloud provider, or an attacker who 
gains administrative privileges and can load malicious kernel extensions, 
or downgrade security critical subsystems to exploitable versions. 
These mechanisms complement a number of security mechanisms aimed to prevent
runtime exploitation of the system through a range of low-level
vulnerabilities~\cite{chen+:apsys11}, e.g., stack
canaries~\cite{cowan+:usenixss98}, address space randomization
(ASLR)~\cite{shacham+:acmccs04}, data execution prevention
(DEP)~\cite{exec-shield}, superuser-mode execution and access
prevention~\cite{smep, smap}, and even control-flow~\cite{intel-sdm} and
code-pointer integrity~\cite{cpi}.



\paragraph{Virtual trusted platform module (vTPM)}


A \vtpm{} is a pure software implementation of a TPM module as defined by
the TPM 2.0 specification~\cite{spec:tpm2.0}.
\vtpm{} enables the virtualization of a hardware root of trust across multiple
entities, i.e., virtual machines, and is aimed at providing functionality
identical to a hardware TPM.
Berger et al.~\cite{vtpm:berger} proposed the first design for virtualizing a
TPM that can be used for providing TPM functionalities to virtual machines.
Their design consists of a \vtpm{} manager and a set of \vtpm{} instances,
where the \vtpm{} manager executes as part of the VMM and takes care of
multiplexing physical hardware across multiple VMs. 
Berger et al. extend the TPM command specification to include support for
creating virtual instances and rely on hardware TPM for establishing trust.


Stumpf et al.~\cite{vtpm:hw-virt} proposed a virtual TPM design by applying
hardware virtualization techniques from Intel VT-x technology.
Their multi-context TPM contains different modes of execution and has a
dedicated TPM control structure for every VM, which would be loaded
by the VMM before invoking the TPM commands.
Several \vtpm{} architectures were proposed over the years: from a
generalized vTPM~\cite{vtpm:gvtpm} to separating \vtpm{} functionalities
across Xen domains with different privileges~\cite{vtpm:xen-libos,
vtpm:xen-doma, vtpm:xen-domb}.
Unfortunately, existing designs either place trust on the host environment (VMM, host
OS) or rely on the hardware TPM for establishing trust.
None of those designs satisfies the security and
confidentiality requirements of confidential computing.
Recent \vtpm{} designs move their implementation inside a TEE such as Intel
SGX~\cite{eTPM, vtpm-for-cloud, svtpm, cocotpm}.
Though this design offers protection from the cloud provider, the state of
the TPM must be securely stored and should be protected against rollback
attacks. Additionally, to avoid substitution attacks, both the vTPM and
the consuming VM must securely identify each other before services can be
provided.



\paragraph{Cloud \vtpm{}s}

Cloud providers that offer \cvm{}s typically provide virtual TPM device that
can serve as a root-of-trust and can also be used for remote
attestation.
Google cloud offers plain \sev{} \cvms{} and measured boot
attestation via a \vtpm{} managed by the
hypervisor~\cite{vtpm:gcp-shielded-vms}.
Microsoft Azure cloud relies on Azure attestation service for attesting
\cvms{}~\cite{vtpm:azure} that generates a token to decrypt the \vtpm{}
state and the disk.
Alibaba cloud offers \vtpm{} support on their elastic compute service
VMs~\cite{vtpm:alibaba}.
Amazon AWS provides Nitro TPM, a virtual TPM implementation conforming to
the TPM 2.0 specification as part of their EC2
offering~\cite{vtpm:aws-nitro}.
Some of these providers use a qemu-backed \vtpm{} that runs on the host,
and requires trust in the cloud provider.
Additionally, there is very limited public knowledge about the design and implementation 
of the above cloud \vtpm{}s what limits understanding of their security guarantees.
In contrast, our work results in an openly available \svtpm{} implementation
that is built on top of other standard opensource components~(i.e., Qemu,
Linux, and Keylime).
As our \svtpm{} relies only on the hardware-protected isolation environment
offered by the AMD-SP hardware, it allows cloud users to leverage our \vtpm{} as 
\svsm{} firmware and hence completely eliminate the need for trusting the cloud provider.

\begin{table*}[!]
  \small
  \caption{Feature comparison of \svtpm{} and other TEE-based \vtpm{}s}
  \vspace{-1em}
\begin{tabular}{cccccc}
  \hline
          & Trust anchor           & Persistent State      & Secure communication & Rollback protection & TPM management \\
  \hline\hline
  SvTPM~\cite{svtpm}    & SGX -\textgreater vTPM & Encrypted (SGX-Seal)   & SSL                  & Yes     & Self-contained            \\
CocoTPM~\cite{cocotpm}   & Self-signed sub-CA     & Encrypted (on disk)   & SSL                  & Yes    & Central             \\
SVSM-vTPM & AMD -\textgreater vTPM & Ephemeral             & Secure by design     & N/A    & Self-contained        \\
\hline
\end{tabular}
\label{table:relwork}
\end{table*}

\paragraph{TEE-based \vtpm{}s}

\autoref{table:relwork} presents a summary of differences between our
\svtpm{} design and other TEE-based \vtpm{}s.
\cocotpm{} proposes a unified architecture for attestation of
\cvms{} where the hypervisor launches a \cvm{} that acts as a \vtpm{}
manager and handles all the \vtpm{} instances~\cite{cocotpm}.
Several other projects rely on running \vtpm{} under isolation provided by
other hardware TEE mechanisms such as Intel SGX~\cite{svtpm, eTPM,
vtpm-for-cloud} and ARM Trustzone~\cite{fTPM}.
SvTPM aims to protect against NVRAM replacement, and rollback
attacks~\cite{svtpm} by running the \vtpm{} inside an SGX enclave for
KVM-based VMs, whereas
eTPM manages several enclave \vtpm{}s in a Xen environment and relies on a
physical TPM to provide root-of-trust~\cite{eTPM}, similar to Berger et
al.~\cite{vtpm:berger}.

To estasblish root of trust, SvTPM relies on Intel SGX datacenter
attestation primitives (DCAP) mechanism whereas \cocotpm{} uses a
self-signed certificate with which they sign the EK.
\svtpm{} establishes a chain of trust by generating an \snp{} attestation
report by passing the $digest(EK_{pub})$ as the user-data along with the
attestation request and thus relying only on the AMD hardware.

Both SvTPM and \cocotpm{} persists the state of the TPM.
SvTPM leverages SGX sealing to tie the persistent state of the TPM to the
appropriate VM whereas \cocotpm{} stores the state encrypted on the host
such that it can only be decrypted by the \cocotpm{}.
In contrast, by implementing an ephemeral \vtpm{}, we completely eliminate
the classes of attacks that come with state protection and endpoint
substitution.

Both \cocotpm{} and SvTPM require modifying parts of the software stack to
implement transport layer security (TLS) for securing the communication
channel between a VM and its \vtpm{}.
However, \svtpm{} implements an interface where both the command request
and response are part of the encrypted VM pages and hence secure by design.

To manage the state machine of the \vtpm{} instance and to maintain
the association betweeen a VM and its \vtpm{}, SvTPM and \cocotpm{} take
different approaches.
SvTPM follows a decentralized model where each \vtpm{} instance is hosted
on a separate SGX enclave whereas 
\cocotpm{} employs a central \vtpm{} manager where multiple \vtpm{}
instances are hosted on the same \cocotpm{} \cvm{}.
Though the \cocotpm{} VM is running inside a \cvm{}, a central design
suffers from several attacks ranging from denial of service to colluding
with other \cvm{}s.
Though it is possible to launch a dedicated \cocotpm{} for every
\cvm{}, it results in wastage of architectural resources as the
number of address space identifiers~(ASIDs) are limited.
In contrast, our \svtpm{} architecture equips each \cvm{} with their own
private \vtpm{} instance by leveraging the \svsm{} architecture that
implements VM privilege levels.
We propose a minimalistic \vtpm{} design that avoids the need to 
support secure communication and management of persistent state.
Also, by having a self-contained design and a simple API interface for
performing remote attestation, we avoid the complexities that are
associated with orchestrating a remote attestation
protocol~\cite{intel-dcap}.


