\section{Related work}


\begin{table*}[!]
  \small
  \caption{Feature comparison of \svtpm{} and other TEE-based \vtpm{}s}
\begin{tabular}{cccccc}
  \hline
          & Trust anchor           & Persistent State      & Secure communication & Rollback protection & TPM management \\
  \hline\hline
SvTPM     & SGX -\textgreater vTPM & Sealed to the enclave & SSL                  & Yes     & Self-contained            \\
CocoTPM   & Self-signed sub-CA     & Encrypted             & SSL                  & Yes    & Central             \\
SVSM-vTPM & AMD -\textgreater vTPM & Ephemeral             & Secure by design     & N/A    & Self-contained        \\
\hline
\end{tabular}
\label{table:relwork}
\end{table*}

\paragraph{Cloud \vtpm{}s}
Cloud providers offering \cvm{}s typically provide virtual TPM device that
would serve as a root-of-trust and could also be used for remote
attestation.
Google cloud only offers plain \sev{} \cvms{} and offers measured boot
attestation via a \vtpm{} managed by the
hypervisor~\cite{vtpm:gcp-shielded-vms}.
Microsoft Azure cloud relies on azure attestation service for attesting
\cvms{}~\cite{vtpm:azure} that generates a token to decrypt the \vtpm{}
state and the disk, hinting that 
Microsoft may have their custom firmware based on \svsm{}
specification~(i.e., inside \vmpl{0}) with a persistent \vtpm{} for attesting
\snp{} VMs.
Alibaba cloud offers \vtpm{} support on their elastic compute service
VMs~\cite{vtpm:alibaba}.
Amazon AWS provides Nitro TPM, a virtual TPM implementation conforming to
the TPM 2.0 specification as part of their EC2
offering~\cite{vtpm:aws-nitro}.
Some of these providers use a qemu-backed \vtpm{} that runs on the host,
which requires trusting the cloud provider.
Also, there is very limited public knowledge on how these cloud \vtpm{}s
are designed and the security guarantees of it.
In contrast, we plan to publish the source code of \svtpm{} implementation
that is built on top of other standard opensource components~(i.e., Qemu,
Linux, and Keylime).
As our \svtpm{} rely only on the hardware-protected isolation environment
offered by the AMD-SP hardware, by bringing their own \svsm{} firmware, a
user can completely eliminate the need for trusting the cloud provider.
\paragraph{TEE-based \vtpm{}s}

\autoref{table:relwork} presents a summary of differences between our
\svtpm{} design and other TEE-based \vtpm{}s.

\cocotpm{} proposes a unified architecture for attestation of
\cvms{} where the hypervisor launches a \cvm{} that acts as a \vtpm{}
manager and handles all the \vtpm{} instances~\cite{cocotpm}.
Several other projects rely on running \vtpm{} under isolation provided by
other hardware TEE mechanisms such as Intel SGX~\cite{svtpm, eTPM,
vtpm-for-cloud} and ARM Trustzone~\cite{fTPM}.
SvTPM aims to protect against NVRAM replacement, and rollback
attacks~\cite{svtpm} by running the \vtpm{} inside an SGX enclave for
KVM-based VMs, whereas
eTPM manages several enclave \vtpm{}s in a Xen environment and relies on a
physical TPM to provide root-of-trust~\cite{eTPM}, similar to Berger et
al.~\cite{vtpm:berger}.

SvTPM relies on Intel SGX datacenter attestation primitives (DCAP)
mechanism to establish the root of trust whereas \cocotpm{} uses a
self-signed certificate with which they sign the EK.
\svtpm{} establishes a chain of trust by generating an \snp{} attestation
report by passing the $digest(EK_{pub})$ as the user-data along with the
attestation request and thus relying only on the AMD hardware.

SvTPM leverages SGX sealing to tie the persistent state to the appropriate
VM whereas cocotpm stores the encrypted persistent state on disk and can
only be decrypted by the \cocotpm{}.
In contrast, by implementing an ephemeral \vtpm{}, we completely eliminate
the classes of attacks that come with state protection.


Both \cocotpm{} and SvTPM require modifying parts of the software stack to
implement transport layer securit (TLS) for securing the communication
channel between a VM and its \vtpm{}.
However, \svtpm{} implements an interface where both the command request
and response are part of the encrypted VM pages and hence secure by design.

Though the \vtpm{} is running under a TEE, a central \vtpm{} manager
suffers from several attacks ranging from denial of service to colluding
with other \cvm{}s.
With \cocotpm{} it is possible to launch a dedicated \cocotpm{} for every
\cvm{}, however, it results in wastage of architectural resources as the
number of address space identifiers~(ASIDs) are limited.
In contrast, our \svtpm{} architecture equips each \cvm{} with their own
private \vtpm{} instance by leveraging the \svsm{} architecture that
implements VM privilege levels.



\paragraph{Trusted execution environments}
Arm introduced confidential compute architecture~(CCA) with their Armv9-A
architecture where the processor provides an isolated hardware execution
environment called \emph{Realms}, for hosting entire VMs in a secure
space~\cite{wp:arm-cca}.
Similar to other TEEs~\cite{wp:amd-sev, spec:intel-tdx} they offer
pre-attestation of realms and can do measured boot with their hardware
enforced security~(HES) module specification~\cite{spec:arm-cca-sec-model}
which serves as the root-of-trust~\cite{arm-cca:rss, arm-cca:rss-talk}.

Intel, with their trust domain extensions~(TDX) introduced their own
version of hardware-isolated encrypted virtual machines called trusted
domains~(TDs).
Intel TDX relies on an SGX-based quoting enclave called the TD-quoting
enclave to perform remote attestation of trusted domains~\cite{spec:intel-tdx}.
However, SGX suffered from numerous vulnerabilities in the
past~\cite{sgx-attacks:survey} where researchers were able to extract the SGX
quoting enclave's attestation keys through micro-architectural side-channel
attacks to forge attestation reports~\cite{sgx-attack:foreshadow}.
The attestation keys used by these quoting enclave are long-lived, and when
leaked, affect millions of devices.
In our design, we do not have any secrets to guard as the attestation keys
are ephemeral.
