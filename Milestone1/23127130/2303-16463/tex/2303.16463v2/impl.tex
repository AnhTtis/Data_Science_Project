\section{Implementation}

We base our implementation on the software stack recommended by AMD
which is publicly available on github~\cite{github:amdese}.
It consists of qemu, open virtual machine firmware (OVMF) and Linux
kernel for both the host and the guest all of which are modified to
support the AMD \snp{} architecture and will eventually be upstreamed.
We make minor modifications to the open-source framework Keylime~\cite{gh:keylime} for
performing remote attestation of VMs that has the SVSM-vTPM in the root of trust.


To implement \svtpm{}, we extend the open-source SVSM
implementation~\cite{github:amdese/linux-svsm} with a minimal C library~(a
stripped-down version of Musl~\cite{musl}), \libssl{}
library~\cite{gh:wolfssl} for cryptographic primitives, and Microsoft's TPM
that provides a software reference implementation of TCG's TPM 2.0
specification~\cite{gh:ms-tpm-ref}.


\subsection{Software TCB}
We add 1500 lines of code to the existing SVSM implementation in
Rust.
To implement \vtpm{}, we utilize third party libraries: a minimal C
library, WolfSSL crypto library and Microsoft's reference TPM
implementation~\cite{gh:ms-tpm-ref}.
The software TCB of our implementation is very similar to that of a
physical TPM consisting of a processor core (e.g., ARM SecureCore) that can
host the software components such as crypto libraries and TPM state
machine.
Also, the APIs we expose is similar to a hardware TPM implementing a CRB
interface.

We measure the \svsm{} code and other third-party crates that are part of
the dependency chain~(i.e., recursive dependencies) as everything is open
source.
We also assume that WolfSSL and Microsoft's TPM implementations are bug-free.
It should be noted that the microsoft reference implementation TPM is
also the code which is running in firmware inside a hardware TPM. For
this reason, we expect our vTPM to have the same security
characteristics as a hardware TPM: state exfiltration is prevented by
the VPML0 SNP security so the only attack vector is via the TPM
command interface.

\begin{figure*}
  \centering
  \includegraphics[scale=0.75]{figures/remote-attestation}
  \caption{Remote attestation of a confidential VM using keylime and \svtpm{}}
  \label{fig:remote-attestation}
  \vspace{-4mm}
\end{figure*}

\subsection{Remote attestation with Keylime}

We use the Keylime package for remote attestation. Keylime is designed to
perform both boot-time and runtime attestation on a fleet of systems,
using the attested nodes' TPM devices as the root of trust~\cite{gh:keylime}.
The Keylime architecture is comprised of three major components: A
Keylime \emph{agent} is installed on every attested node. The agent
announces itself with a Keylime \emph{registrar} when it starts up.
The Keylime \emph{verifier} is in charge of performing attestations on
every node.
\paragraph{Registration protocol}
The purpose of Keylime registration is to record the availability of
the registering agent for attestation and to establish mutual trust
between the agent and the registrar. To this end the agent's
credentials are checked and an attestation key is negotiated between
the agent and the registrar for use for subsequent attestation
challenges.
As shown in ~\autoref{fig:remote-attestation}, the agent initiates the
enrollment process by sending its TPM credentials - i.e., the public
part of its endorsement key (EK) and attestation identity key (AIK),
as well as the EK certificate, and the node's UUID to the
registrar. The registrar verifies that the TPM's identity and
authenticity using the public EK and the EK certificate. Next, the
validity of the AIK is established through the
\emph{MakeCredential/ActivateCredential} function pair by using a
carefully constructed secret that can only survive the registrar to
agent roundtrip when both the TPM, AIK and UUID are authentic.
Identity verification of a normal TPM device involves checking that
the EK certificate correctly signs the public EK, and furthermore that
the EK certificate ($EK_{cert}$) is signed by a trusted root (such as
a manufacturer key or an intermediary key).

\paragraph{Attestation protocol}
Having successfully registered with the \emph{registrar}, the
\emph{agent} is now ready to service attestation challenges. The
Keylime \emph{verifier} initiates the attestation protocol by sending
a TPM quote request to the \emph{agent}, containing a nonce (to guard
against replay attacks) and a PCR mask (list of PCRs).
The \emph{agent} sends back the requested quote signed by the TPM,
using the AIK associated during the registration phase. In addition, a
number of logs (e.g. measured boot log, IMA log) are sent back with
the quote. The \emph{verifier} validates the TPM quote by decrypting
it with the registered AIK; validates the logs by testing them against
the PCRs contained in the quote; and finally checks the contents of
the logs against the attestation policy to render a
trustworthy/untrustworthy verdict.

\paragraph{Protocol changes to handle \svtpm{}s}

Since Keylime is built around interaction with TPM devices, we needed to make
only minor modifications in the code to handle \svtpm{}s. Basically, we only
had to modify how the Keylime verifier checks the authenticity of a TPM device
(function \lstinline{check_ek}).
As mentioned above, a ``normal'' TPM device is authenticated through
its EK certificate, which signs the public EK and in turn is verified
by a manufacturer certificate. Keylime carries a list of acceptable
manufacturer certificates, and any TPM in use by Keylime has to be
signed by one of these.
Our ephemeral \svtpm{}, by its very nature, is not provisioned with an
EK certificate. However, the (ephemeral) public EK is signed by the SEV
attestation report, which we validate by checking it against the
platform manufacturer's signature (i.e., AMD).
In order to minimize the required changes in Keylime, we decided to
simply replace the EK certificate with an SEV attestation report
($Att_{report}$) in our \svtpm{} (that is, we reuse the NVIndex in the
TPM where the EK certificate normally resides). The \emph{agent} reads
and submits the attestation report instead of the EK certificate
during registration. The modified \emph{registrar} validates the
attestation report (ensuring that it is signed by an authentic AMD
platform) instead of the validating the EK certificate~(marked by a
different color in ~\autoref{fig:remote-attestation}).
No other parts of the registration/attestation protocols require
changes for correct Keylime function.
