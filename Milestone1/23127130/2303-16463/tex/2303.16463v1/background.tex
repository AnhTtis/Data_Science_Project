\section{Background}

\subsection{AMD secure encrypted virtualization}
In 2016, AMD introduced secure encrypted virtualization (SEV) where the
entire virtual machine is encrypted with an ephemeral key that is managed
by a dedicated co-processor, AMD secure processor~(AMD-SP).
%
AMD-SP takes care of lifecycle management of the \sev{}
VMs~\cite{spec:amd-sev} and serves as the integrated root-of-trust for the
AMD processor~\cite{wp:amd-sp}.
%
By using a unique key per VM, \sev{} isolates the guest VMs from the rest
of the host operating system and from other guests.

Since 2016, AMD incrementally added additional protection features to SEV.
%
AMD introduced \seves{} (SEV encrypted state) to protect the register
state in the virtual machine control block (VMCB) with encryption and
integrity protection~\cite{wp:sev-es}.
%
To communicate and share data with the hypervisor during hypercalls, a new
structure called guest hypervisor communication block (GHCB) was
introduced~\cite{spec:ghcb} that would remain unencrypted.
%
In their next version, \snp{} (secure nested paging), AMD
introduced a reverse mapping table (RMP) which performs page validation and
keeps track of page ownership to prevent replay attacks~\cite{wp:sev-snp}.

\paragraph{Virtual machine privilege levels}
AMD also introduced virtual machine privilege levels (VMPLs) in
\snp{}.
%
Similar to protection rings in x86 architecture, VMPLs allow a guest VM
address space to be subdivided into four levels with different privileges
(with \vmpl{0} being the highest privilege level).
%
These levels can be used to implement privilege isolated abstraction layers
within a confidential guest virtual machine~\cite{wp:sev-snp}.
%

The introduction of \vmpl{} allows the design and deployment of secure
services that are completely isolated from the untrusted host
operating system and the guest VM.
%
Secure VM service module (\svsm{}) specification~\cite{spec:sev-svsm}
also defines a standard interface for communicating between various
services offered by the software running at \vmpl{0} and the guest
operating system. The protocol uses registers to pass the arguments
and return values.
%
In the absence of \svsm{} firmware, the entire guest VM can execute under
\vmpl{0} unmodified.
%
However, with \svsm{}, they run at a lower privilege level,
corresponding to a higher VMPL~(i.e., 1-3), and require interaction with the
\svsm{} for some privileged operations.

\subsection{Virtual trusted platform module (vTPM)}
A \vtpm{} is a pure software implementation of a TPM module as defined by
the TPM 2.0 specification~\cite{spec:tpm2.0}.
%
\vtpm{} enables virtualization of a hardware root of trust across multiple 
entities, i..e, virtual machines, and is aimed at providing functionality 
identical to a hardware TPM.
%
Berger et al.~\cite{vtpm:berger} proposed the first design for virtualizing a
TPM that can be used for providing TPM functionalities to virtual machines.
%
Their design consists of a \vtpm{} manager and a set of \vtpm{} instances,
where the \vtpm{} manager executes as part of the VMM and takes care of
multiplexing physical hardware across multiple VMs. 
%
Berger et al. extend the TPM command specification to include support for
creating virtual instances and rely on hardware TPM for establishing trust.
%


Stumpf et al.~\cite{vtpm:hw-virt} proposed a virtual TPM design by applying
hardware virtualization techniques from Intel VT-x technology.
%
Their multi-context TPM contains different modes of execution and has a
dedicated TPM control structure (TPMCS) for every VM, which would be loaded
by the VMM before invoking the TPM commands.
%
Several \vtpm{} architectures were proposed over the years: from a
generalized vTPM~\cite{vtpm:gvtpm} to separating \vtpm{} functionalities
across Xen domains with different privileges~\cite{vtpm:xen-libos,
vtpm:xen-doma, vtpm:xen-domb}.
%
However, they were either placing trust on the host environment (VMM, host
OS) or relying on hardware TPM for establishing trust.
%
Unfortunately, none of those designs satisfies the security and
confidentiality requirements of confidential computing.
%
Recent \vtpm{} designs move their implementation inside a TEE such as Intel
SGX~\cite{eTPM, vtpm-for-cloud, svtpm, cocotpm}.
%
Though this design offers protection from the cloud provider, the state of
the TPM must be securely stored and should be protected against rollback
attacks.

\subsection{Runtime integrity}

Modern kernels deploy a number of security mechanisms to prevent 
runtime exploitation of low-level vulnerabilities~\cite{chen+:apsys11},
e.g., stack canaries~\cite{cowan+:usenixss98}, address space randomization
(ASLR)~\cite{shacham+:acmccs04}, data execution prevention
(DEP)~\cite{exec-shield}, superuser-mode execution and access
prevention~\cite{smep, smap}, and even control-flow~\cite{intel-sdm} and
code-pointer integrity~\cite{cpi}.
%
These mechanisms, however, are not designed to stop an attacker who has control 
over the boot sequence of a system, e.g., an untrusted cloud provider, or 
gains administrative privileges and can load malicious kernel extensions, 
or downgrade security critical subsystems to exploitable versions. 
%
To prevent such attacks modern systems rely on a combination of measured boot
and runtime integrity monitoring. 

Measured boot is the process of recording the measurements of all boot
components during the system initialization process.
%
The hash of the components are recorded in a log file that is authenticated
using the Trusted Platform Module (TPM).
%
This authentication works by extending TPM Platform Configuration Registers
with digests of individual events in the boot log.
%
A TPM signed \emph{quote} an be used to vouch for the accuracy of the log.

Integrity measurement architecture~(IMA) is a Linux subsytem that collects
the hashes of files when opened, before it is read or executed~\cite{ima}.
%
To ensure the integrity of these measurements, they are extended into the
TPM PCRs, similar to the measured boot log.
%
Together with measured boot, IMA enables remote attestation to ensure the
runtime integrity of the system.

Remote attestation is a process that proves or ascertains certain
properties of a set of devices/machines to an outside observer. As an
example, one might be interested to ascertain the booted kernel, on a
set of machines in a data center. These properties of interest are
cumulatively called an attestation policy.
