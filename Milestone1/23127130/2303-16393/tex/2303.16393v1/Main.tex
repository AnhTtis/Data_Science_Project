\documentclass[conference]{IEEEtran}
% \IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{float}  % for the tables to be in the right places 
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{pictures/}}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Analyzing the Effects of CI/CD on Open Source Repositories in GitHub and GitLab}

\author{\IEEEauthorblockN{Jeffrey Fairbanks}
\IEEEauthorblockA{\textit{Department of Computer Science} \\
\textit{Boise State University}\\
Boise, Idaho, USA \\
jeffreyfairbanks@u.boisestate.edu}
\and
\IEEEauthorblockN{Akshharaa Tharigonda}
\IEEEauthorblockA{\textit{Department of Computer Science} \\
\textit{Boise State University}\\
Boise, Idaho, USA \\
akshharaatharigo@u.boisestate.edu }

\and
\IEEEauthorblockN{Nasir U. Eisty}
\IEEEauthorblockA{\textit{Department of Computer Science} \\
\textit{Boise State University}\\
Boise, Idaho, USA \\
nasireisty@boisestate.edu }
}
\maketitle

\begin{abstract}

%The effects of Continuous Integration and Delivery (CI/CD) on a project are overwhelmingly seen as positive, with many articles touting the benefits of applying CI/CD pipelines to a development ecosystem. With the addition and use of these pipelines, many respect the project and expect the commit velocity and issue count to reduce within the repository. Although many understand the adoption of CI/CD to be a slow process at first, the assumption lies in the fact of accelerated services and deployments in the long run. This research seeks to provide answers on the effect of commit velocity, issues found within the repository, and note on any major differences that are seen between the two open source repositories GitLab and GitHub, in a formal research environment. Through the collection of over 12,000 repositories and tabulation of every issue and commit within each repository, it was found that while commit velocity does improve through the usage of CI/CD by 141.19\%, the number of issues found within an open source repository also increases by  321.21\%.

Numerous articles emphasize the benefits of implementing Continuous Integration and Delivery (CI/CD) pipelines in software development. These pipelines are expected to improve a project's reputation and decrease the number of commits and issues in the repository. Although CI/CD adoption may be slow initially, it is believed to accelerate service delivery and deployment in the long run. This study aims to investigate the impact of CI/CD on commit velocity and issue counts in two open-source repositories, GitLab and GitHub. By analyzing more than 12,000 repositories and recording every commit and issue, it was discovered that CI/CD enhances commit velocity by 141.19\% but also increases the number of issues by 321.21\%.

\end{abstract}


\begin{IEEEkeywords}
CI/CD, Mining Repositories, Open-Source Software, Software Engineering
\end{IEEEkeywords}

\section{Introduction}

%Resolving issues with code is almost never a straightforward task. Many times there are issues that will arise and test cases that were not initially taken into consideration when the project began. As a result, projects often start with one intention and slowly morph, requiring different inputs and outputs. Keeping track of these changes can be difficult and sometimes make the development process take more resources than initially planned, especially when collaborating with multiple developers. Developing a project while working with a  group of developers is a difficult task that requires efficient communication and an easy way to roll out new code with new test cases. In many projects, conducting small and often testing of code is overlooked as an afterthought; A function that takes place after much of the code is assembled. Unit testing has gained more attraction over the years, allowing for more efficient testing as the code is developed, but is still often only employed after the section of code conducting unit testing is nearing completion.
It's rare for resolving code issues to be a simple task. Unforeseen problems and unanticipated test cases often arise during the project's development. This causes the project to shift its original intentions and require different inputs and outputs. Keeping track of these changes can be challenging, mainly when working with multiple developers, and it may increase the resources needed for the project.

Developing a project with a team of developers requires effective communication and a simple method for implementing new code with new test cases. Unfortunately, in many cases, testing code frequently and in small increments is disregarded until after a significant amount of code has been written. Unit testing has gained popularity in recent years and allows for more efficient testing as code is developed. However, it is often employed only as the code section conducting unit testing is nearing completion.

As testing (both unit and end-to-end) is an integral part of the development life cycle, a newer solution has come to test its validity. The software engineering community widely advocates continuous integration and Continuous Delivery (CI/CD). There are two parts to CI/CD.

CI (Continuous Integration) is a practice that helps many developers integrate code changes into a single project more quickly and easily. Developers use an automated set of tests to validate the code before it's integrated or merged into a project's main branch or a repository that is shared with other developers on the team. This allows development teams to build quickly and test their code continuously, which helps them to avoid problems later on.

On the other hand, CD (Continuous Delivery) is a great way to automate the code changes to the process. It is a better way to deliver changes to development or production environments than traditional methods. Continuous Development can also push rapid and small changes to various environments, allowing for quick rollbacks or changes and avoiding major differences or exceptions. When using and pushing small changes, deploying and testing code that could be troublesome becomes substantially more straightforward. In addition, this method allows for risk mitigation when pushing to a critical production system.

CI/CD is essential in a development pipeline as it enables a faster development cycle, facilitates the identification of imminent issues with the code, and promotes efficient and minimal code changes. By gathering and presenting essential metrics on the benefits of utilizing CI/CD in a development pipeline, developers can enhance their productivity and deliver exceptional products to users. Consequently, our research endeavors to address the following inquiries: 

\textbf{RQ1: Does integrating CI/CD enhance commit velocity?}

\textbf{RQ2: Does integrating CI/CD impact the number of issues reported for the project?}

\textbf{RQ3: Are there any significant variations in CI/CD issues between GitLab and GitHub?}

We designed these inquiries to evaluate the effectiveness of utilizing CI/CD in projects involving developers' teams. Although many articles assert that CI/CD improves commit velocity and streamlines testing and deployment pipelines, limited formal research substantiates these claims~\cite{b25, b26, b27}. Moreover, utilizing CI/CD requires implementing multiple tools and processes that must work together harmoniously. Correctly learning and implementing these tools can be time-consuming and challenging, leading many developers to question their value \cite{b2}.

The primary focus of the third research question is to examine whether there are significant disparities in the utilization of CI/CD between GitLab and GitHub. This metric holds paramount importance as one platform may facilitate commit velocity while the other may impede the advantages of utilizing CI/CD. Similarly, the drawbacks associated with CI/CD, such as the time-consuming setup process, may vary between the two open-source repository platforms. This study aims to investigate these variations and determine if any noteworthy differences exist that could pose challenges in implementing CI/CD.

To answer these inquiries, we collected data from over 12,000 repositories, including those with and without CI/CD. We mined data from open-source repositories on GitLab and GitHub, gathering information on projects with multiple developers and CI/CD workflows using their respective APIs. We analyzed the data and answered our research questions using custom functions found in Google Sheets. Additionally, we utilized the programming language Python and the Google Colab platform to analysis and process the data.

\section{Related work}
Today's development climate is marked by research on CI/CD that focuses on transitioning to a CI/CD pipeline, pinpointing pain points in its usage, or comparing different platforms that use CI/CD (e.g., comparing the use of GitLab versus GitHub) \cite{b28, b29, b30}.

%This research differs from the previous research as this research is focused on understanding the prevalence of CI/CD and how this effects the development velocity and collaboration between developers.  This said, there is one research paper that closely follows how this research will be completed.

%In the research provided by Borle, N.C. et al, \textit{Analyzing The Effects of Test Driven Development In GitHub},  the researchers attempt to answer questions regarding Test Driven Development (TDD) and how it affects the outcomes and effectiveness of the project \cite{b1}. The paper  explores how TDD is practiced in real world development and how TDD projects differ from the projects that do not implement TDD. The researchers look into data from GitHub repositories archived in 2015, and analyze the effects that it had on developer integration and velocity of project management. It is understood that TDD was and is not widely used in development pipelines. However, this research still proves crucial in the implementation of this research paper, as it laid the groundwork for how testing in projects can be analyzed and gives many good metrics to focus on. The research by  Borle, N.C. et al also demonstrates how data collection can be achieved to grab project repositories that contain tests, such as CI/CD. In this research project, however, CI/CD is collected instead of the TDD seen previously.
%Importantly, the research completed by  Borle, N.C. et al, is a baseline for the research that is demonstrated in this paper. With a new look at CI/CD and an updated data set from both GitHub and GitLab, there are new and up-to-date metrics that are useful for many development teams to understand when it comes to implementing CI/CD in development life cycles.

%\subsection{CI/CD}
%In today's work environment, rapidly changing demands require quick Response and improvement. 
%In the past, software development was mainly characterized by large and timely releases.
%As the development cycle began to speed up with more requirements appearing at a faster rate, this led for a change in the development process to handle fast shifting requirements even in the middle of the project.
%Through the adoption of CI/CD the time that the code is in development and transit is reduced. From the moment when the developer commits her code changes
%into a repository until it gets implemented in production, continuous testing should be incorporated that does not impede the overall process. Using and knowing that CI/CD has increased rapidly in recent years, and there is much related work that can be discussed that aids this research process. 
Savor et al.~\cite{b5} identified four critical elements of continuous deployment: small software updates, automatic releases, developer responsibility, and fully automatic deployment. Tools aid in managing these responsibilities by offering insights into code changes, automating repetitive and error-prone tasks, and logging every process action. Their findings suggest that CI/CD should be a continuous and automated process that continuously tests and deploys code to production. Based on this understanding, our research aims to ensure that CI/CD, as used in real-world applications, actually increases development velocity as intended.

In their study, Rangnau et al.~\cite{b3} explore the integration of security tools within CI/CD pipelines. While they assume that CI/CD is widely used today, no formal research supports this claim. Their work contributes to our study by highlighting the shift towards a SaaS (Software as a Service) development model, where multiple users share instances running on cloud infrastructure. This new development environment allows software practitioners to continuously enhance product quality through frequent updates, leading to increased use of CI/CD. Our research examines the validity of this claim by analyzing a real-world and up-to-date dataset.

Nogueira et al.~\cite{b4} demonstrate how Apache Kafka pipelines support integrating and normalizing event logs from multiple sources into data streams that feed process mining algorithms in real-time. They apply this to the complex CI/CD pipeline of a major European e-commerce company, highlighting how these techniques enhance the monitoring and observability of development processes. Their study focuses on a single CI/CD pipeline, whereas our research examines multiple pipelines to investigate whether velocity is improved overall and if development issues are reduced.


%\subsection{Mining GitHub Repositories}



%GitHub is a coding platform that evolved rapidly and helps developers develop, integrate, check in and maintain their projects. It is also used for personal projects, data storage and class projects. There is a vast amount of data present in GitHub. This data is used by the researchers to deduce various conclusions based on their requirements. GitHub acts as an interface to collect the datasets, store repositories, and perform the required analysis/ functions that a developer requires. GitHub also acts to provide history of the project by logging changes in the code, helping developers rollback to old versions if necessary.
	
%The easiest access to data in GitHub is provided by several research projects through the GitHub API (GitHub Application Program Interface). The GitHub API is an interface to interact pragmatically with GitHub. It uses the curl functions to get and post data. There is also an interface that can be used Directly with Python to easily set up scripts to use the GitHub API. 
    
%Several projects used GitHub REST API to get the data. In the work done by Laerte Xavier, Fabio Ferreira, Rodrigo Brito, Rodrigo Brito '\textit{Beyond the Code: Mining Self-Admitted Technical Debt in Issue Tracker Systems}', the issues with the labels related to technical debt are collected from the popular GitHub repositories [8]. Using the GitHub API, the dataset of pull requests and the associated users and the repositories in the GitHub is collected to perform Influence of Social and Technical Factors for Evaluating Contribution in GitHub[6].
  
%In the research work by Laerte Xavier, Fabio Ferreira, Rodrigo Brito, Marco Tulio Valente, '\textit{Analyzing the effects of test driven development in GitHub}', BOA infrastructure is used to collect nearly 256000 Java repositories, their respective URL, commit logs, timestamps etc from a GitHub copy, archived in 2015 to analyse the effects of TDD on the software projects[1]. To obtain the repository issues and the pull requests, GitHub API is used. Boa infrastructure is used to query massive amounts of data from the real-world software projects.
   
%Various tools like GitHub achieve, Gitminer, GHTorrent are used to obtain the data from GitHub. GitHub achieve, by monitoring the GitHub, provides the dataset of the history of events in GitHub[7]. To get the history of the events for the specific repositories, Gitminer is used. For any desired project, Gitminer crawls the API and provided the dataset. GitHub has a large amount of data and this data must be monitored up to date to record the events. This is done by GHTorrent. By monitoring and recording the GitHub events as they occur, GHTorrent provides the mirror of GitHub API[9]. It is used to get the pull requests from the projects when combined with others. GitHub actions can be used to perform CI/CD. The needed components required to perform a CI/CD pipeline in different particular services and the comparisons is provided in "Comparing CI/CD pipelines"[11]
   

%\subsection{Mining GitLab Repositories}

%GitLab is very similar to GitHub. GitLab is open source application that provides the services that allows developers to host their projects on a single repository and has some other features that support the software development life cycle. The various features of GitLab include Managing, sharing, documentation services, bug tracking, CI/CD and a built-in wiki feature. It acts as a single application with powerful collaboration, version control, code review, multi cloud CI/CD that allows you to deploy anywhere and built in security and monitoring right out of the box. Community(CE), an open source version and Enterptice(EE), a commercial version are the two editions of the GitLab in which the development takes place in both repositories and is synchronised.

%Data from GitLab can be collected using GitLab REST API. It provides the easy access using regular API requests. It is used to get the information that is publicly available. GitLab REST API is used to collect the closed issues related to the label technical debt, to study the issue based self-admitted technical debt[8].


%\subsection{Analyzing Open Source Repositories}

%When it comes to analyzing open source repositories, there are a few different approaches that have been taken in the past. Many of the tests that are implemented depend on what form the data from the repository looks like, the size of the data and what metrics are wanted. While there are many tests that are relevant to this research, two main testing methods stand out. Each is discussed in more detail below. 


%\subsubsection{Wilcoxon sign test}


%Developed in 1945 by the statistician Frank Wilcoxon, the signed rank test was one of the first "non parametric" procedures developed. It is considered a non parametric procedure, because there is only two simple assumptions about the underlying distribution of the data, namely that: The random variable X is continuous and that the probability density function of X is symmetric. \cite{b31} This test is used to compare the locations of two populations using two matched samples. In this case, the Wilcoxon Sign Test is used to compare repositories that contain CI/CD and those that do not contain CI/CD. This test is used on smaller test sets that are equal in the amount of data points that are tested together. 

%The first step of the Wilcoxon sign test is to calculate the differences of the repeated measurements and to calculate the absolute differences. \cite{b24}

%\begin{figure}[htbp!]
%    \centering
%    \includegraphics[width=5cm]{pictures/Wilcoxon.png}
%    \caption{Wilcoxon Sign Test Forumula}
%   \label{fig:WilcoxonFormula}
%\end{figure}

%In this research, the Wilcoxon sign test is used on a small subset of the data to give further analysis on the data.


%\subsubsection{GitClear: Finding Commit Velocity}

%GitClear is a developer tool that provides analysis of code and enriches the statistics beyond the lines of code for both GitHub and GitLab. It generates a heat map of the code pinpointing the most crucial work. This is extremely useful for the developers in a team to keep the track of the ups and downs in their respective projects. GitClear uses various features for different measurements.
%The commit difference with GitClear recognizes that the code gets moved, updated, batch find/replaced, and language-specific idioms including keywords, etc. This tool looks beyond additions and deletions. Using these changes, a score is assigned based on cognitive energy. The harder the change, the higher the score. This score is known as Line of Impact or Diff Delta.
%Diff Delta is a measurement that helps everyone on the team to see the development progress clearly by detailing what is happening in their git repositories.
%GitClear uses various techniques to estimate the time consumed in a commit accurately. One of them is using the diff delta value. If ‘A’ is the average diff delta of all commits in a repository in some ‘X’ number of hours invested in that project, then the commit velocity of the repository would be the average diff delta per hour. Along with calculating the Diff Delta, the most multifaceted calculation undertaken by GitClear is the derivation of how much time was taken for each commit authored. \cite{b32}


%\section{Research Questions}
%Over the course of this research project, two main questions were formulated and answered. These research questions seek to find the effects of CI/CD on open software repositories. The effect of CI/CD is generally seen as a positive addition to projects. This research breaks down this sentiment into two main questions, looking to explain with data what is seen in the wild. Each question will be further explored in this section. 

%\subsection{\textbf{\textbf{RQ1: Does integrating CI/CD enhance commit velocity?}}}
%With this research, the addition of CI/CD in open source repositories is explored to demonstrate if faster workflows are achieved when using CI/CD in the pipeline occurs. Many articles such as \textit{Deliver quality software at speed with CI/CD} and \textit{Anatomy of a high-velocity CI/CD pipeline} claim that CI/CD improves the velocity of the project. \cite{b12} \cite{b13}. Not everyone is convinced that CI/CD improves the velocity of the project, however. In articles such as \textit{Is your CI slowing you down?}, authors explain how CI/CD is not always faster to development time. \cite{b14} Another aspect of implementing CI/CD is the understanding that it is not a quick process to set up. Papers such as \textit{Continuous Delivery: Overcoming adoption challenges}, discuss the challenges in creating and implementing a CI/CD pipeline in the first place. \cite{b15} Through this research question, the authors seek to find the data on speed using commit velocity, verses projects that do not implement CI/CD.
% Looking at RQ1, this can be further broken down into another more specific question to better explain and understand the wanted outcome.
    
%\textbf{{RQ1.1: Does the adoption of CI/CD affect the number of issues reported for the project?}} 

%Through these questions, the premise of whether CI/CD improve velocity within the project is further explored. The sub-question focuses on assessing the difference in number of issues found within the repository between projects implementing CI/CD verses those that do not implement CI/CD. Although every project is different, especially in a place where open source repositories are stored for production, development and school work, it is important to collect enough data to get a wide enough view of the number of issues found within projects containing CI/CD and those that do not. 

%The research question aims to understand in the number of commits changes substantially when using CI/CD, verses those project that do not implement these pipelines. By inspecting the number of commits, it is found whether CI/CD handles agile development easily, increasing commit velocity. This research question is more complex in that it may have a few different outcomes. If, for example, there is a high commit number, but low commit velocity, this would be seen as a negative for the process being used (whether that was a project using CI/CD or not). On the other hand, if the commit number is high, but the velocity is also high, this would be seen as a positive for the process being used. There are other combinations of these two, and this research question seeks to answer the over arching question of whether CI/CD improves the velocity of the project. 


%\subsection{\textbf{RQ2: Are there any significant variations in CI/CD issues between GitLab and GitHub?}}
%The second main question of this research paper aims to understand if there are any large differences in the use of CI/CD between GitLab and GitHub. This is an important metric to look at, as one repository may help the contribution of commit velocity, whereas the other may suppress the benefits of using CI/CD. In the same way, the negatives of CI/CD, such as the known issue that setting up CI/CD takes a substantial amount of time, may be higher on one open source repository platform over the other. By taking into account the differences on each platform, the research seeks to understand if there are any notable differences that may lead to issues implementing CI/CD. 


\section{Methodology}
This section discusses the data collection and analysis methodology employed in this research. The study involved mining two primary open-source repositories to obtain information on the usage of CI/CD. Specifically, we investigated the GitHub and GitLab platforms to identify any variations in velocity and CI/CD utilization between them. Despite their apparent similarities, these platforms exhibit distinct differences~\cite{b16} that we aimed to uncover. Therefore, in the following discussion, we will delve into the data collection and analysis process for each platform.


\begin{figure}[htbp!]
    \centering
    \caption{Overview of the Research Methodology}
    \label{fig:overview}
    \includegraphics[width=9cm]{pictures/overview0.png}
\end{figure}
 
Fig.~\ref{fig:overview} depicts the general process we followed for each of the open-source repositories, GitHub and GitLab. The first step involved collecting data and verifying whether each repository had CI/CD capabilities. Once this was established, we cleaned the data and eliminated any duplicate entries, if present. Subsequently, we stored the cleaned data in a database and performed further analysis to address the research questions.



\subsection{Collecting Data from GitHub }

GitHub is an open-source repository for developers to store, collaborate, and manage their code in a centralized location~\cite{b17}. To collect data from GitHub, we primarily utilized the API provided by the platform. We adopted several different approaches while using the API. Initially, we collected information on repositories that implemented CI/CD and then further mined this subset of repositories to gather data on pull requests, issues, and related metadata. To achieve this, we utilized the GitHub API to search the path of each publicly available repository for the file path: ``.github/workflow"~\cite{b18}. Fig.~\ref{fig:githubCollection1} shows an overview of this data collection method. 

This search was conducted to identify projects that contained CI/CD since this file is required to implement CI/CD within a repository. This method was effective until we reached the limit on the number of results. As per the documentation, only 1000 results can be returned for each search~\cite{b19}. Thus, we needed another approach to collect the required CI/CD projects after reaching the limit of 1000 repositories.

\begin{figure}[htbp!]
    \centering
    \caption{GitHub Data Collection Method 1}
    \label{fig:githubCollection1}
    \includegraphics[width=9cm]{pictures/overview1.png}
\end{figure}


To collect data from GitHub, we adopted another approach of scraping a list of developer name/repository name pairs using GitArchive. After compiling a substantial list, we utilized the GitLab API to check each repository for CI/CD. Next, we parsed each repository into a "using CI/CD" or a "not using CI/CD" bucket. To prevent personal or school projects from skewing the data, we pruned each bucket to include only repositories with at least two developers. We also ensured that each repository was active in 2022, thus ensuring the data is current and valuable for this research. This guarantees that the results produced by this research project are relevant and applicable to the current time. Fig.~\ref{fig:githubCollection2} shows an overview of this data collection method.


\begin{figure}[htbp!]
    \centering
    \caption{GitHub Data Collection Method 2}
    \label{fig:githubCollection2}
    \includegraphics[width=9cm]{pictures/overview2.png}
\end{figure}


We used another search method using the GitHub API to collect the remaining data from GitHub. We formulated the search by filtering repositories by language (e.g., python, java) and sorting them based on the number of stars. This method proved highly effective, as we observed a strong correlation between the number of stars and the implementation of CI/CD pipelines in the project repositories. The more stars a repository had, the more likely it was to have implemented CI/CD. This search method enriched our dataset significantly, boosting our confidence in the quality of the data collected. Fig.~\ref{fig:githubCollection3} provides an overview of this data collection approach.


\begin{figure}[htbp!]
    \centering
    \caption{GitHub Data Collection Method 3}
    \label{fig:githubCollection3}
    \includegraphics[width=9cm]{pictures/overview3.png}
\end{figure}


We conducted a deduplication process on all the collected repositories to ensure that each repository was collected only once and categorized correctly based on whether it implemented CI/CD. Then, we ran a validation function on each repository to ensure it was in the appropriate bucket. This step was important to ensure the accuracy and integrity of the data. After the deduplication process, it was confirmed that each repository was in the correct category and that there were no duplicates. 

%\subsection{Issues With GitHub Data Collection}
\textbf{Issues With GitHub Data Collection.} The primary challenges encountered during the GitHub data collection were related to the hourly rate limit imposed by the API when searching for repositories. This limitation was not ideal and prolonged the data collection process significantly. Another issue was that each API query could only return up to 1000 results, meaning multiple searches had to be conducted for each bucket, "using CI/CD" and "not using CI/CD." This led to considerable time being spent validating and de-duplicating the data.


\subsection{Collecting Data from GitLab }
The process of collecting data from GitLab differed significantly from collecting data from GitHub. Initially, we attempted to utilize GitLab's own resources for data collection~\cite{b22}. However, we found that it took approximately 5 minutes to collect data from a single repository, which was deemed too time-consuming for the project's timeline. Consequently, we refined our approach by using a python wrapper instead of the API natively~\cite{b23}. Although the wrapper did not support global searching of a specific file, we devised a workaround. We used the python GitLab API wrapper to search for keywords found in the repository name across GitLab. Therefore, we searched for relevant data using keywords such as 'ci', 'cd', 'git', and 'workflow'. Fig.~\ref{fig:gitlabCollection} provides an overview of this data collection approach.


\begin{figure}[htbp!]
    \centering
    \caption{GitLab Data Collection Method}
    \label{fig:gitlabCollection}
    \includegraphics[width=9cm]{pictures/overview4.png}
\end{figure}

The method we used for data collection was not optimal in returning results. We had to spend a considerable amount of time to ensure that the collected data met the research's standards. We invested a significant amount of time ensuring that the repositories had multiple developers, were categorized correctly based on their use of CI/CD and that only unique entries were collected. This time investment was critical to ensure that we collected high-quality data. Although we attempted other implementations, this approach proved to be the only reliable way to collect the required amount of data at scale within the research's timeline.

\textbf{Issues With GitLab Data Collection.} The process of gathering data from GitLab is significantly more arduous, particularly in terms of searching for relevant information, which consumes a considerable amount of time. In comparison to collecting data from GitHub, obtaining GitLab data takes considerably longer. Despite the need to employ multiple methods to collect GitHub data, it is still roughly three times faster than gathering GitLab data. The disparity in speed is largely due to GitLab's requirement to perform an API search for each issue and timestamp on commits individually, as opposed to GitHub, which can retrieve all necessary information with a single API call. Consequently, the API call-intensive process imposed by GitLab restricts the number of repositories that can be collected in a day and incurs significant waiting time as the API replenishes requests. 

An additional problem encountered when searching for repositories on GitLab is that the API lacks the comprehensive functionality offered by GitHub's API. Compared to GitHub, the GitLab API is less user-friendly and has fewer resources available to facilitate the search for repositories on the platform. In addition, unlike GitHub, the GitLab API does not support the search for file paths, highly-rated projects, language-based projects, or projects that use CI/CD. Consequently, a new approach was necessary to gather data on projects utilizing CI/CD on GitLab. 

While searching for a new data collection method, we discovered that many researchers began by scraping repository URLs and then enriching the data using the GitPy tool to create a temporary local clone of the project. The logs required for the research were extracted from the local clone, and the project was then deleted~\cite{b20}. Another method we found during our search involved crawling GitLab to collect the required data~\cite{b21}. However, neither of these methods was ideal for collecting large amounts of data. Consequently, we decided to develop a new data collection method from scratch, as described above. 


\subsection{The Data Set}

We collected data throughout this research, which comprises about 12,000 repositories. For GitHub data, there were at least 3000 repositories in each category; for GitLab data, roughly 1300 repositories were in each category. The collected data enabled us to analyze to answer the research questions. However, in this section, we will demonstrate the data to provide the reader with insight into the collected data. Table~\ref{tab:number_of_repositories} represents the number of repositories with and without CI/CD.


\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{Number of Repositories}
\label{tab:number_of_repositories}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{GitHub}    &  3223   &  6007  \\ \hline
\textbf{GitLab}    &  1357   &  1356  \\ \hline
\end{tabular}
\end{table}


We collected a few attributes associated with each repository. We cataloged each repository based on its file path in GitHub or GitLab. Additionally, we stored the number of active or retired issues within the lifespan of each repository. We collected the issues to analyze whether CI/CD creates an environment where fewer issues are created. Furthermore, we collected the average time between commits. We calculated the commit velocity of the repository by determining the mean between the time of each commit, and we calculated each commit to obtain an accurate measure. As shown in Table~\ref{tab:data_layout}, we designed the layout of our collected data. We further parsed the data above to enable calculations to take place. We subsequently analyzed the data using various statistical measures, and we describe the results in the next section.


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.5}
\caption{Layout of the Data}
\label{tab:data_layout}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Repository Name} & \textbf{Issues} & \textbf{Commit Velocity} \\ \hline
  requilence/integram/  &  64  &  639:10:58  \\ \hline
  bueltge/WordPress-Admin-Style/ &  2  &  494:15:37  \\ \hline
 apache/airflow/ &  863   &  4:09:41  \\ \hline
  openwdl/wdl/  &  65   &  872:34:25  \\ \hline
  microg/android\_packages\_apps\_UnifiedNlp/ &  97  &  580:26:51  \\ \hline
 Froxlor/Froclor/ &  32  &  4:10:46 \\ \hline
   cloudson/gitql/   &  4   &  251:57:46 \\ \hline
  repoze/repoze.workflow/ &  4   &  1679:15:44 \\ \hline
 john30/ebusd/ &  60   &  39:40:22 \\ \hline
   KSP-CKAN/NetKAN/   &  27   &  24:42:51  \\ \hline
  snarfed/bridgey/ &  95  &  31:35:57  \\ \hline
\end{tabular}
\end{table}

\section{Results}

In this section, we will present and discuss the findings of this study. We used the research questions to guide the discussion and discovered several notable outcomes through this study. Finally, we will discuss the points collected between using CI/CD on GitHub and GitLab. 

First, we conducted an analysis of the GitHub collection data to find the mean, median, and standard deviation within the dataset. Initially, we focused on finding the distribution of issues between the projects that utilized CI/CD and those that did not implement the process. After collecting and resourcing the open-source repositories, we conducted a more detailed analysis of each metric within the repository.



% \begin{table}[H] 
% \centering
% %\vspace{5pt}
% \caption{Github CI/CD Number of Issues Breakdown}
% \label{tab:github_issues}
% \begin{tabular}{|p{.80cm}|p{.80cm}|p{1.1cm}|p{1cm}|p{1.25cm}|p{.75cm}|p{.90cm}|}
% \hline
% \textbf{GitHub CI/CD Issues} & \textbf{GitHub NO CI/CD Issues} & \textbf{Difference} & \textbf{Absolute Difference} & \textbf{Rank of the Absolute Difference} & \textbf{Positive Ranks} & \textbf{Negative Ranks} \\ \hline
%   301 &  11  & 290 & 290 & 2729.5 & 2729.5 &   \\ \hline
%   9 &  90  & -81 & 81 & 2061 &  & 2061  \\ \hline
%   1 &  270  & -269 & 269 & 2702 &  & 2702  \\ \hline
%   0 &  651  & -651 & 651 & 2966.5 &  & 2966.5  \\ \hline
%   1 &  1225 & -1224 & 1224 & 3066 &  & 3066  \\ \hline
%   64 &  138  & -74 & 74 & 2000 &  &  2000 \\ \hline
%   2 &  122 & -120 & 120 & 2332.5 &  &  2332.5 \\ \hline
%   863 &  484  & 379 & 379 & 2826.5 & 2826.5 &   \\ \hline
%   65 &  1157  & -1092 & 1092 & 3050 &  & 3050  \\ \hline
%   97 &  5  & 92 & 92 & 2168 & 2168 &   \\ \hline
%   32 &  4  & 28 & 28 & 1223.5 & 1223.5 &   \\ \hline
%   4 &  50 & -46 & 46 & 1603.5 &  & 1603.5  \\ \hline
%   4 &  57 & -53 & 53 & 1714 &  &  1714 \\ \hline
%   60 &  44  & 16 & 16 & 839.5 & 839.5 &   \\ \hline
%   27 &  60  & -33 & 33 & 1348.5 &  & 1348.5  \\ \hline
%   95 &  191  & -96 & 96 & 2202.5 &  &  2202.5 \\ \hline
% \end{tabular}
% \end{table}


\subsection{Repository Issues Analysis}

After analyzing the data on a macro level, we took a much more micro approach to find the small details hiding within the data set. We used this micro approach to mine the repository data, giving us a better look at the distribution of the number of issues found in projects that use CI/CD and those that do not use CI/CD. We analyzed the entire data set and formulated the mean, standard deviation, and median of the number of issues within it as shown in Table~\ref{tab:GitHub_Repository_Issues}.

\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{GitHub Repository Issues}
\label{tab:GitHub_Repository_Issues}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  175.38   &  52.33  \\ \hline
\textbf{Median}    &  29   &  25 \\ \hline
\textbf{Standard Deviation}    &  549.97   &  90.55  \\ \hline
\textbf{Count}    &  3223   &  3223 \\ \hline
\end{tabular}
\end{table}

%One can see and understand how the data was analyzed by taking in the entire data set and formulating the mean, standard deviation, and Median of the number of issues within the data set. %In the figure below, a small subsection of data was extracted to demonstrate this analysis. 

% \begin{table}[H]
% \centering
% %\vspace{5pt}
% \caption{GitHub Example Issues from the Dataset}
% \label{tab:GitHub_Example_Issues}
% \begin{tabular}{|c|c|}
% \hline
% \textbf{GitHub CI/CD issues} & \textbf{GitHub CI/CD issues} \\ \hline
% 65 &  4   \\ \hline
% 7 &  61  \\ \hline
% 44 & 13   \\ \hline
% 30 & 17   \\ \hline
% 264 & 182   \\ \hline
% 137 &  41   \\ \hline
% 198&  25  \\ \hline
% 3 &  1 \\ \hline
% 2 &  31 \\ \hline
% 97 &  12 \\ \hline
% \end{tabular}
% \end{table}


Throughout this study, we also collected and analyzed GitLab data. We demonstrate the results of the distribution between the number of issues for each in regard to CI/CD usage in Table~\ref{tab:GITLAB_REPOSITORY_ISSUES}. 


\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{GitLab Repository Issues}
\label{tab:GITLAB_REPOSITORY_ISSUES}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  52.04   &  17.56  \\ \hline
\textbf{Median}    &  12  &  3 \\ \hline
\textbf{Standard Deviation}    &  477.56   &  189.81  \\ \hline
\textbf{Count}    &  1357   &  1357 \\ \hline
\end{tabular}
\end{table}


Upon examining the data, it is evident that repositories without CI/CD processes have a lower number of issues. This conclusion is drawn from the lower mean of issues found within the repository, combined with a standard deviation that is significantly lower than that of the repositories containing CI/CD. Therefore, we can conclude that, on average, repositories without CI/CD have fewer issues compared to those with CI/CD in the development process.


% \begin{table}[H]
% \centering
% %\vspace{5pt}
% \caption{GitHub Repository Data}
% \label{tab:GitHubRepositoryData}
% \begin{tabular}{|c|c|c|}
% \hline
%  &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
% \textbf{Mean}    &  175.38   &  52.33  \\ \hline
% \textbf{Standard Deviation}    &  549.97   &  90.55  \\ \hline
% \end{tabular}
% \end{table}

% \begin{table}[H]
% \centering
% %\vspace{5pt}
% \caption{GitLab Repository Data}
% \label{tab:GitLabRepositoryData}
% \begin{tabular}{|c|c|c|}
% \hline
%  &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
% \textbf{Mean}    &  52.04   &  17.68 \\ \hline
% \textbf{Standard Deviation}    &  477.56   &  189.81  \\ \hline
% \end{tabular}
% \end{table}

%The conclusion can be drawn that the number of issues found within a repository is on average lower when CI/CD is not in effect within the development process


\subsection{Repository Commit Velocity}
After analyzing the number of issues in repositories from both GitHub and GitLab, we further investigated the commit velocity between the two platforms. It is worth noting that the mean and median values presented in Tables~\ref{tab:{GitHubRepositoryCommitVelocity}} and \ref{tab:{GitLabRepositoryCommitVelocity}} are calculated in hours. Upon examining the GitLab data, it becomes apparent that the commit velocity shows a similar trend to what we observed on GitHub. On average, the commit velocity is significantly lower when CI/CD is used in the pipeline, compared to when it is not used.

\begin{table}[H]
\centering
%%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{ GitHub Repository Commit Velocity}
\label{tab:{GitHubRepositoryCommitVelocity}}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  16.51   &  27.11  \\ \hline
\textbf{Median}    &  18:39:28  &  487:37:01 \\ \hline
\textbf{Standard Deviation}    &  52.05   &  31.92  \\ \hline
\textbf{Count}    &  3223   &  3223 \\ \hline
\end{tabular}
\end{table}



%Looking at the values for GitLab, they tell a similar story to those seen in GitHub. The commit velocity is very clearly on average lower when CI/CD is used, versus when it is not used in the pipeline. 

\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{ GitLab Repository Commit Velocity}
\label{tab:{GitLabRepositoryCommitVelocity}}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  22.01   &  25.70  \\ \hline
\textbf{Median}    &  32:39:15  &  120:57:14 \\ \hline
\textbf{Standard Deviation}    &  88.57   &  60.21 \\ \hline
\textbf{Count}    &  1356   &  1356 \\ \hline
\end{tabular}
\end{table}



Upon analyzing the commit velocity data from both GitHub and GitLab, we observed that the projects using CI/CD have a faster commit velocity compared to those that do not use CI/CD. This trend is demonstrated in Tables~\ref{tab:GitHubCommitVelocityMetrics} and \ref{tab:GitLabCommitVelocityMetricss}, as expected. 



\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{GitHub Commit Velocity Metrics}
\label{tab:GitHubCommitVelocityMetrics}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  16.51 Hrs   &  27.11 Hrs\\ \hline
\textbf{Standard Deviation}    &  52.05    &  31.92 \\ \hline
\textbf{Median}    &  18 Hrs   &  487 Hrs  \\ \hline
\end{tabular}
\end{table}




\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{GitLab Commit Velocity Metrics}
\label{tab:GitLabCommitVelocityMetricss}
\begin{tabular}{|c|c|c|}
\hline
 &   \textbf{CI/CD} &   \textbf{NO CI/CD} \\ \hline
\textbf{Mean}    &  22.01 Hrs   &  25.7 Hrs\\ \hline
\textbf{Standard Deviation}    &  88.57    &  60.21 \\ \hline
\textbf{Median}    &  32 Hrs   &  120 Hrs  \\ \hline
\end{tabular}
\end{table}

The most significant finding regarding the use of CI/CD and commit velocity is the median time between commits. On average, when using CI/CD in their pipelines, the median commit velocity is significantly lower compared to those that do not use CI/CD. Based on this analysis, we can conclude that implementing CI/CD results in an increase in commit velocity. 

\section{Discussion}

Through the implementation of this research, a clear outcome has been achieved and the research question are ready to be answered. Each of the questions will lead the discussion in this section of the paper. 

\subsection{\textbf{RQ1: Does integrating CI/CD enhance commit velocity?}}

The data clearly shows that implementing CI/CD increases the commit velocity on average, which is the primary goal of CI/CD. On average, the implementation of CI/CD results in a significant improvement in commit velocity of 141.19\%, as shown in Table~\ref{tab:CommitVelocitydifferencebetweenGitHubandGitLab}.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\caption{Commit Velocity difference between GitHub and GitLab}
\label{tab:CommitVelocitydifferencebetweenGitHubandGitLab}
\begin{tabular}{|c|c|c|}
\hline
\textbf{}  & \textbf{CI/CD} & \textbf{No CI/CD}   \\ \hline
 \textbf{GitHub}  & 16.51 Hours & 27.11 Hours   \\ \hline
\textbf{GitLab}    &  22.01 & 26.7 \\ \hline
\multicolumn{3}{|c|}{Velocity Increase with CI/CD: 141.19 \%} \\ \hline
\end{tabular}
\end{table}




%Through the implementation of CI/CD, on average the commit velocity is improved by 141.19\%.


\subsection{\textbf{RQ2: Does integrating CI/CD impact the number of issues reported for the project?}}

In delving deeper into RQ2, as previously discussed, the use of CI/CD has an impact on the number of issues found within the project repository. Our research and analysis revealed that when CI/CD is utilized, there are generally more issues created within the repository. Although CI/CD improves and accelerates commit velocity, it is interesting to note that the number of issues within the repository would increase. However, this is not surprising as the pipeline may naturally create errors as it executes. As the project is continually deployed, the likelihood of issues increases with more commits made. The swiftness of these commits may contribute to more issues found within the repository. On average, as shown in Table~\ref{tab:IssuesdifferencebetweenGitHubandGitLab} implementing CI/CD results in a significant increase in the number of issues found within the code repository by 321.21\%.

\begin{table}[H]
\centering
%\vspace{5pt}
\renewcommand{\arraystretch}{1.3}
\caption{Difference in the Number of Issues Between GitHub and GitLab}
\label{tab:IssuesdifferencebetweenGitHubandGitLab}
\begin{tabular}{|c|c|c|}
\hline
\textbf{}  & \textbf{CI/CD} & \textbf{No CI/CD}   \\ \hline
 \textbf{GitHub Avg Issues}  & 135.38 & 57.33   \\ \hline
\textbf{GitLab Avg Issues}    &  52.04 & 17.68 \\ \hline
\multicolumn{3}{|c|}{Issues Increase with CI/CD: 321.21 \%} \\ \hline
\end{tabular}
\end{table}


%Through the implementation of CI/CD, on average the number of issues found within the code repository is on average increased by by 321.21\%.


\subsection{\textbf{RQ3: Are there any significant variations in CI/CD issues between GitLab and GitHub?}}

This research question evaluates the usefulness of GitLab compared to GitHub based on the findings of this study. Our research indicates that GitHub provides more benefits than GitLab regarding commit velocity and issues found within the repository. In addition, the analysis reveals that GitHub has a higher commit velocity compared to GitLab.

When considering this question, it is also noteworthy to mention the difference in data collection between GitLab and GitHub. GitLab provides fewer tools for analyzing data within the repository compared to GitHub, which offers a more extensive suite of tools to facilitate data collection and analysis.

Finally, it is worth noting that on GitHub, a higher number of stars on a project indicates a higher likelihood of the project implementing CI/CD pipelines within the repository. However, this trend was not as evident with GitLab. The number of projects using CI/CD versus those not using CI/CD did not show a significant difference based on the number of stars on the project.

\section{Threats to Validity}

During this research project, there were several potential threats to the validity of the study. Firstly, the time taken to collect repositories resulted in a small margin being collected. Although we collected more than 12,000 repositories, this is a small number when compared to the millions of users who use these open-source repository services daily.

The main limiting factor of this project was the amount of analysis done on the data. Although the analysis presented in this paper is sufficient to yield clear and accurate outcomes, it would have been beneficial to have more time to conduct additional analysis and delve deeper into the data set. Unfortunately, additional time was not available to conduct further experiments, which could have enhanced the implications and reach of this research.

\section{Conclusion}

Many developers consider implementing CI/CD within their project pipeline because it is widely discussed. According to this study, implementing CI/CD has increased commit velocity. However, using CI/CD also significantly increases the number of issues that arise within a project. Therefore, developers must balance the benefits of faster commit velocity against the potential downsides of introducing more issues into the code base when implementing CI/CD. In the future, we would like to expand our dataset with more repositories in both sources and provide more in-depth generalized insights into our research questions. 


\begin{thebibliography}{00}
\bibitem{b1} Borle, N.C., Feghhi, M., Stroulia, E. et al. Analyzing the effects of test driven development in GitHub. Empir Software Eng 23, 1931–1958 (2018). https://doi.org/10.1007/s10664-017-9576-3
\bibitem{b2} Rossel, Sander (October 2017). Continuous Integration, Delivery, and Deployment. Packt Publishing. ISBN 978-1-78728-661-0.
\bibitem{b3}Rangnau, Thorsten \& Buijtenen, Remco \& Fransen, Frank \& Turkmen, Fatih. (2020). Continuous Security Testing: A Case Study on Integrating Dynamic Security Testing Tools in CI/CD Pipelines. 145-154. 10.1109/EDOC49727.2020.00026. 

\bibitem{b4} Nogueira, Ana Filipa \& Zenha-Rela, Mário. (2021). Monitoring a CI/CD Workflow Using Process Mining. SN Computer Science. 2. 10.1007/s42979-021-00830-2. 
\bibitem{b5} T. Savor, M. Douglas, M. Gentili, L. Williams, K. Beck, and M. Stumm, “Continuous deployment at Facebook and OANDA,” in Proceedings of the 38th International Conference on Software Engineering Companion - ICSE ’16. Austin, Texas: ACM Press, 2016, pp. 21–30.
\bibitem{b6} Tsay J, Dabbish L, Herbsleb J (2014) Influence of social and technical factors for evaluating contribution in github. In: Proceedings of the 36th international conference on software engineering, ICSE 2014
\bibitem{b7} Grigorik I (2012) The Github archive., http://www.githubarchive.org/
\bibitem{b8}Laerte Xavier, Fabio Ferreira, Rodrigo Brito, Rodrigo Brito(2020). Beyond the Code: Mining Self-Admitted Technical Debt in Issue Tracker Systems
\bibitem{b9}Georgios Gousios; Diomidis Spinellis (2012). GHTorrent: Github's data from a firehose
\bibitem{b10} Bird C, Rigby PC, Barr ET, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: 6th IEEE International working conference on mining software repositories, 2009. MSR’09. IEEE, pp 1–10

\bibitem{b11}Comparing different CI/CD pipelines - theseus. (n.d.).www.theseus.fi
Opinnaytetyo\_Joni\_Virtanen.pdf


\bibitem{b12} Clark, L. (2019). Deliver quality software at speed with CI/CD. ComputerWeekly.com.


\bibitem{b13} Zaworski, R. J. (2021, November 30). Anatomy of a high-velocity CI/CD pipeline. Medium. Retrieved December 10, 2022, from https://medium.com/developing-koan/anatomy-of-a-high-velocity-ci-cd-pipeline-43a1ae3b798b

\bibitem{b14} InstaCI. (2021, January 30). Is your CI slowing you down? Medium. www.instaci.medium.com/is-your-ci-slowing-you-down-afe3de1bc865 

\bibitem{b15} Continuous delivery: Overcoming adoption challenges. Journal of Systems and Software. Retrieved December 10, 2022, from https://www.sciencedirect.com/science/article/pii/S0164121217300353 

\bibitem{b16}GitLab. (n.d.). Retrieved December 10, 2022, from https://about.gitlab.com/devops-tools/github-vs-gitlab/ 

\bibitem{b17}GitHub's products. GitHub Docs. (n.d.). Retrieved December 10, 2022, from https://docs.github.com/en/get-started/learning-about-github/githubs-products 
\bibitem{b18}Search. GitHub Docs. (n.d.). Retrieved December 10, 2022, from https://docs.github.com/en/rest/search 

\bibitem{b19}Search. GitHub Docs. (n.d.). Retrieved December 10, 2022, from https://docs.github.com/en/rest/search

\bibitem{b20}Amores, D. A. S. (2022, February 2). Estudo Geral. Mining GitLab repositories for software development activities. Retrieved December 10, 2022, from https://estudogeral.sib.uc.pt/handle/10316/97983 

\bibitem{b21}Hadisfr. (n.d.). Hadisfr/gitlab\_crawler: A gitlab.com network crawler: Codes of "An analysis of gitlab's users and projects networks", IST2020, doi: 10.1109/ist50524.2020.9345844. GitHub. Retrieved December 10, 2022, from https://github.com/hadisfr/gitlab\_crawler 

\bibitem{b22}Instance-level CI/CD variables API. GitLab. (n.d.). Retrieved December 10, 2022, from https://docs.gitlab.com/ee/api/instance\_level\_ci\_variables.html

\bibitem{b23}Gitlab. python. (n.d.). Retrieved December 10, 2022, from https://python-gitlab.readthedocs.io/en/stable/index.html 

\bibitem{b24}How to conduct the Wilcoxon Sign Test. Statistics Solutions. (2021, May 5). Retrieved December 10, 2022, from https://www.statisticssolutions.com/free-resources/directory-of-statistical-analyses/how-to-conduct-the-wilcox-sign-test/ 

\bibitem{b25}Benefits of Continuous Integration Delivery: CI/CD benefits. katalon.com. Retrieved December 10, 2022, from https://katalon.com/resources-center/blog/benefits-continuous-integration-delivery

\bibitem{b26}Roddewig, S. (2022, February 8). CI/CD: What is it why is it important for devops? HubSpot Blog. Retrieved December 10, 2022, from https://blog.hubspot.com/website/cicd 

\bibitem{b27}What are the benefits of CI/CD?: Teamcity CI/CD guide. JetBrains. (n.d.). Retrieved December 10, 2022, from https://www.jetbrains.com/teamcity/ci-cd-guide/benefits-of-ci-cd/ 

\bibitem{b28}Google. Setting up a CI/CD pipeline for your data-processing workflow. Retrieved December 10, 2022, from https://cloud.google.com/architecture/cicd-pipeline-for-data-processing 

\bibitem{b29} continuous delivery: Overcoming adoption challenges - researchgate. (n.d.). Retrieved December 10, 2022, from \\
www.researchgate.net/publication/313874428\_Continuous\_Delivery  \\
\_Overcoming\_Adoption\_Challenges

\bibitem{b30}A comparison study of managed CI/CD solutions. (n.d.). Retrieved December 10, 2022, from https://git.cubieserver.de/jh/cs-e4000-seminar/raw/commit/a9b2cba6ec2c187f7a9b34c1f4a9ab8dc5097f71/ \\
presentation/presentation\_slides\_2020-04-24.pdf 

\bibitem{b31} How gitclear estimates time used (minutes, hour, days) per commit. GitClear. Retrieved December 10, 2022, from https://www.gitclear.com/help/estimating\_time\_used\_per\_commit 

\end{thebibliography}
%\vspace{12pt}
\end{document}

