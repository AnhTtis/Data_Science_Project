\section{From AAF to Action Languages}
\label{sec:translation}
   
   This section presents our first contribution: a formalisation of acyclic AAF into the action language introduced above. Section~\ref{sec:contextTranslation} presents the definition of the argumentative context~$\kappa$, Section~\ref{sec:semanticsTranslation} provides the modified definitions of the action language semantics, and Section~\ref{sec:ASP} briefly sketches the structure of the ASP implementation.
   %, and Section~\ref{sec:formalProp} presents some formal properties of the transformation.
    
    In contrast to AAF, we propose to take into account the order of enunciation of arguments. Instead of having only a couple~$(A,R)$, the input is a couple~$(\Delta,R)$, where $\Delta$ is a dialogue, i.e. a sequence of statements in natural language: 
    \begin{definition}[dialogue $\Delta$]\label{def:dialogue}
        A \emph{dialogue} is~${\Delta = \{(a,o) \mid a\in A, o \in \mathbb{N} \}}$, 
        where each argument~$a$ is associated to its order of enunciation,~$o$.
    \end{definition}
        
    \subsection{Instantiating the Context}
    \label{sec:contextTranslation}

        In order to formalise an AAF in the action language described in Section~\ref{sec:Action_language}, let us first define the variables necessary to describe the world, i.e. the AAF. These variables correspond to the fluents $\mathbb{F}$. As introduced in Section~\ref{sec:AAF}, there are two elements to consider: the arguments and the attack relation. First, to describe an argument~$x$, we create two fluents: $p_x \in\mathbb{F}$ and $a_x\in\mathbb{F}$ expressing whether the argument is present in the graph and whether it is acceptable. Regarding~$R$, we use the fluent $cA_{y,x}\in\mathbb{F}$ to model that~$y$ can attack argument~$x$. As we only deal with acyclic AAF, $\nexists (x_1,\dots,x_n)\in A$ such that~$\left(cA_{x_1,x_2},\dots, cA_{x_{n-1},x_n}, cA_{x_n,x_1}\right)\in\mathbb{F}$. We call this property acyclicity of the fluents~$cA$. 
        
        In an AAF, the only deliberate action is to enunciate an argument, which leads to ${\mathbb{A} = \{enunciate_x \mid x \in A \}}$. For this action to be possible, argument $x$ must not have already been said. $x$ then becomes present and acceptable by default. This choice is justified by the fact that its acceptability is evaluated in the next state before it has an impact on the rest of the graph. Formally:
        \begin{align*}
            &pre(enunciate_x)\equiv\neg p_x\\
            &e\ff(enunciate_x)\equiv p_x\wedge a_x
        \end{align*}
    
        Before enunciating the next argument, we choose to update the acceptability of all other arguments present after the enunciation of a new argument. This defines a state which we call \emph{argumentative state}.
        \begin{definition}[argumentative state]\label{def:admissible_state}
            A state~$S(t)$ is an \emph{argumentative state} if:\\ 
            i) $\forall x,y, \left[S(t)\models a_x\wedge p_y\wedge cA_{y,x}\Rightarrow S(t)\models\neg a_y\right]$;\\
            ii) $\forall x, \left[S(t)\models p_x \wedge \left(\bigwedge_y \neg a_y\vee\neg cA_{y,x}\right) \Rightarrow S(t)\models a_x\right]$.
        \end{definition}

        After an argument is enunciated, we want updates to be triggered automatically. We represent them with two exogenous events: ${makesUnacc_{y,x}\in\mathbb{U}}$ and ${makesAcc_x\in\mathbb{U}}$. 
        %For the record, 
        An argument is acceptable only if it is unattacked or attacked only by unacceptable arguments. Hence, it is enough for one of the attackers to be acceptable to make the attacked argument unacceptable. The two cases are considered:
        
        \textit{Acceptability update:} Suppose that an argument $y$ just enunciated can attack argument $x$, and that $x$ and $y$ are acceptable. Then, $x$ being attacked by an acceptable argument~$y$, it becomes unacceptable. Formally, the exogenous event $makesUnacc_{y,x}$ can be written as:
            \begin{align*}
                tri(makesUnacc_{y,x})\equiv &a_x\wedge a_y\wedge cA_{y,x}\\
                e\ff(makesUnacc_{y,x})\equiv &\neg a_x
            \end{align*}
            
        This definition also allows dealing with cases where a new argument~$z$ 
        %would have made
        makes an attacker $y$ of $x$ acceptable again. In this case, $x$ becomes unacceptable.
        
        \textit{Non-acceptability update:} Suppose that argument~$x$ is not acceptable and that an argument~$z$ has just been enunciated. This argument has no direct link with~$x$ but may 
        %have impacted
        impact the acceptability of some attackers of~$x$. We therefore check whether all the arguments that 
        %could
        can attack $x$ are acceptable or not. If none of them are indeed acceptable, then~$x$ becomes acceptable again. In the action language, this is expressed by the exogenous event $makesAcc_x$:
            \begin{align*}
                tri(makesAcc_x) \equiv &p_x\wedge\neg a_x\wedge \left(\bigwedge_{y} \neg cA_{y,x} \vee \neg a_y \right)\\
                e\ff(makesAcc_x)\equiv &a_x
            \end{align*}
            
        Finally, when an argument~$x$ is enunciated, it must be checked that it has not become unacceptable because of an argument~$y$ already present before it makes other arguments unacceptable. This is reflected in the following priority rule:
            \begin{align*}
                makesUnacc_{y,x} \succ_{\mathbb{E}} makesUnacc_{x,z}
            \end{align*}
            
        Note that adding an argument to the graph can only directly impact the other arguments by making them unacceptable. For this reason, it is not necessary to establish a priority rule of the form~$makesUnacc_{y,x} \succ_{\mathbb{E}} makesAcc_{z}$ as this situation is already addressed by the previous rule.
            
        \textbf{Remark --} In the above transformation, we do not distinguish between the notions of potential and real attack, because such a difference disappears in the equations. Indeed, let us consider a fluent ${att_{y,x}\in\mathbb{F}}$ translating the fact that argument~$y$ actually attacks argument~$x$. Let us define the exogenous event $isAttacking_{y,x}\in\mathbb{U}$ as:
        \begin{align*}
            tri(isAttacking_{y,x})\equiv &p_x\wedge p_y\wedge cA_{y,x}\\
            e\ff(isAttacking_{y,x})\equiv &att_{y,x}
        \end{align*}
        From this definition, an argument~$y$ attacks an argument~$x$ if both are present and~$y$ can attack~$x$. However, for this attack to be taken into account, the attacker~$y$ must be acceptable. We obtain conditions of the form $a_y \wedge att_{y,x}$, i.e. $a_y \wedge p_y\wedge cA_{y,x}$. However, an argument cannot be acceptable without being present, i.e. $a_y \wedge p_y \equiv a_y$. Thus, taking this new fluent into account, we would have: $tri(makesUnacc_{y,x}) \equiv  a_y \wedge a_x \wedge att_{y,x} = a_y \wedge a_x\wedge cA_{y,x}$. The same precondition applies as without the introduction of $isAttacking \text{ and } att$. Therefore, we 
        %have decided to
        use only~$cA$.
    
    \subsection{Semantics Adapted to AAF}
    \label{sec:semanticsTranslation}
    
        Having an adapted~$\kappa$ for the argumentative framework, we propose to modify the action language semantics to produce traces that are representative of the reality. For this purpose, arguments will be stated from argumentative states step by step in the order determined by the dialogue~$\Delta$.
        
        The current form of scenario~$\sigma$ is not ideal for this task. Indeed, it implies that we need to know in advance how many steps each chain of admissibility update events will take to plan at which time the next argument should be stated. To solve this issue we introduce a set of ranked actions~$\varsigma\subseteq\mathbb{A}\times\mathbb{N}$ which is called \emph{sequence}. The input to obtain unique traces will no longer be the scenario~$\sigma$ but the sequence~$\varsigma$. These modifications require changes to Definitions~\ref{def:semantics} and~\ref{def:traces}.
        
        \begin{definition}[argumentative setting $\chi$]\label{def:arg_setting}
            The \emph{argumentative setting} of the action language, denoted by~$\chi$, is the couple~$(\varsigma,\kappa)$ with~$\varsigma$ a sequence and~$\kappa$ a context.
        \end{definition}
        
        Definition~\ref{def:semantics_arg} is the result obtained after modifying Definition~\ref{def:semantics}. Conditions 2.d and 2.e are added and~$\forall e\in \mathbb{E}$ is replaced by~$\forall e\in \mathbb{U}$ in condition 2.c. These modifications respectively express that an action in the sequence can be triggered only if no exogenous event is triggered at the same time point, and that event sets in the event trace cannot be empty. Conditions 1, 2.a, 2.b, and 3 remain unchanged. So the triggering of exogenous events remains unchanged.
        
        \begin{definition}[valid execution in an argumentative context]\label{def:semantics_arg}
            Given an argumentative context~$\kappa$, a sequence $E(-1),S(0),E(0),\dots,E(N),S(N+1)$ is a \emph{valid execution} w.r.t. $\kappa$ if, in addition to conditions 1, 2.a, 2.b, and 3 of Definition~\ref{def:semantics}, the following conditions are satisfied~$\forall t\in\mathbb{T}$: 
            \begin{enumerate}
                \item[2] $E(t)\subseteq\mathbb{E}$ satisfies:
                \begin{enumerate}
                    \item[2.c] $\forall e\in \mathbb{U}$ such that $S(t) \models tri(e)$,\\
                    $e \in E(t)$ or ${\exists e'\in E(t), ~e'\succ_{\mathbb{E}}e}$;
                    \item[2.d] If $\exists e\in E(t)\cap\mathbb{A}$, then $\forall e'\in\mathbb{U}$, $S(t)\not\models tri(e')$; %or~$e\succ_\mathbb{E}e'$;
                    \item[2.e] $E(t)\not=\varnothing$.
                \end{enumerate}
            \end{enumerate}
        \end{definition}
        
        In Definition~\ref{def:traces} traces were defined as extracts of a valid execution given~$\kappa$ and additional conditions related to~$\sigma$. Instead of defining directly traces, Definition~\ref{def:traces_arg} corresponds to a valid execution given~$\chi=(\varsigma,\kappa)$. Traces are simply extracts from such valid executions. 
        %The modifications include: replacing the scenario~$\sigma$ by the sequence~$\varsigma$; specifying that the only actions that can be in the event trace are those in~$\varsigma$; specifying that an action in the sequence can be triggered only if all actions with an inferior rank have happened; and specifying that two actions with the same rank must happen at the same time in the event trace.
        
        \begin{definition}[valid execution given~$\chi$]\label{def:traces_arg}
            Given an argumentative setting $\chi=(\varsigma,\kappa)$, a valid execution w.r.t.~$\kappa$, is \emph{valid w.r.t. to~$\chi$} if:
            \begin{enumerate}
                \item ${\forall t\in\mathbb{T}}$, ${E(t)\subset\left(\left\{a,\exists o\in\mathbb{N}, (a,o)\in\varsigma\right\}\cup\mathbb{U}\right)}$;
                \item ${\forall \left(\left(e,o\right),\left(e',o'\right)\right)\in\varsigma^2}$ such that $o<o'$,\\
                $\exists t,t'$ such that $e\in E(t) \mbox{ and }  e'\in E(t') \mbox{ and } t<t'$;
                \item ${\forall \left(\left(e,o\right),\left(e',o'\right)\right)\in\varsigma^2}$ such that $o=o'$,\\
                $\exists t$ such that $(e,e')\in E(t)^2$.
            \end{enumerate}
        \end{definition}
    
        Given a valid execution given~$\chi$, its \emph{event trace}~$\tau_{\chi}^e$ is its sequence of events $E(-1),E(0),\dots,E(N)$, its \emph{state trace}~$\tau_{\chi}^s$ is its sequence of states $S(0),S(1),\dots,S(N+1)$.
        
    \subsection{ASP Implementation}
    \label{sec:ASP}
        
        We propose an adapted implementation in ASP based on the sound and complete one described in~\cite{sarmiento_action_2023}. The ASP program~$\pi_{con}(\kappa)$ and~$\pi_{seq}(\varsigma)$ are obtained by the translation of the context~$\kappa$ and the sequence $\varsigma$ respectively. $\pi_{\mathbb{A}}$ is obtained by the translation of the action language semantics introduced in Section~\ref{sec:Modele} and modified in Section~\ref{sec:semanticsTranslation}.  $\pi_{\mathbb{C}}$ is obtained by the translation of the causal relations definitions introduced by~\cite{sarmiento_action_2022-1}. %\cite{sarmiento_action_2023} propose a sound and complete translation. 
        The entire program $\Pi(\chi)  = \pi_{sce}(\varsigma)\cup\pi_{con}(\kappa)\cup\pi_{\mathbb{A}}\cup\pi_{\mathbb{C}}$ is  available\footnote{\url{https://gitlab.lip6.fr/sarmiento/kr\_2023.git}}.
        
       % \begin{definition}[actual causality program $\Pi(\chi)$]\label{def:program}
        %    Given a scenario~$\pi_{seq}(\varsigma)$, a context~$\pi_{con}(\kappa)$, an action language semantics~$\pi_{\mathbb{A}}$, and causal relations definitions~$\pi_{\mathbb{C}}$, the \emph{actual causality program} is $\Pi(\chi) = \pi_{sce}(\varsigma)\cup\pi_{con}(\kappa)\cup\pi_{\mathbb{A}}\cup\pi_{\mathbb{C}}$.
        %\end{definition}
        
    
\section{Formal Properties}
    \label{sec:formalProp}
    
   
    This section establishes  formal properties of the proposed transformation. First, we prove that a notion of temporality is captured by the transformation. Then we prove its soundness and completeness. Finally, we introduce the propositions that pave the way to the discussion of Section~\ref{sec:discussion}.
    
    \subsection{Preliminary Property on a Valid Execution}
        
        We start by showing that, although valid executions given~$\kappa$ are not unique, valid executions given~$\chi$ are, and thus are the corresponding traces~$\tau_{\chi}^e$ and~$\tau_{\chi}^s$. 
        
        \begin{proposition}\label{prop:unicity_valid_execution}
            Given an argumentative setting $\chi=(\varsigma,\kappa)$, the traces $\tau_{\chi}^e$ and~$\tau_{\chi}^s$ are unique.
        \end{proposition}
        
        \begin{proof}
        %on n'abrège pas en principe... Let's -> Let us, etc.
            Let us prove by contradiction the unicity of valid executions given~$\chi$. Let~$\chi=(\varsigma,\kappa)$ be the argumentative setting and $\epsilon$, $\epsilon'$ two valid executions given~$\chi$. By way of a reductio ad absurdum, we suppose that~$\epsilon\neq\epsilon'$.
            
            According to Definition~\ref{def:semantics}, $S(t+1)$ is derived from~$S(t)$ and the events in~$E(t)$, and similarly for $S'$. Hence, given that~$\kappa$ is common to~$\epsilon$ and~$\epsilon'$, $E(-1)=E'(-1)$ and $S(0)=S'(0)$, the first discrepancy between $\epsilon$, and $\epsilon'$ is not to be found in a set of states, but in a set of events, which is not empty as the executions are valid.
            Let $t_0$ be the minimal date at which a difference between~$\epsilon$ and~$\epsilon'$ is observed. We have~$E(t_0)\neq E'(t_0)$, $\forall t<t_0$, $E(t)=E'(t)$, and~$\forall t\leq t_0$, $S(t)=S'(t)$. Thus, $\forall e\in\mathbb{E}$, $S(t_0)\models pre(e)\Leftrightarrow S'(t_0)\models pre(e)$. Without loss of generality, let us consider an event~$e_0$ such that $e_0\not\in E(t_0)$ and~$e_0\in E'(t_0)$. Two cases can occur, $e_0\in\mathbb{U}$ or~$e_0\in\mathbb{A}$.
            
            i) Let us first show by contradiction that~$e_0\not\in\mathbb{U}$. Let us suppose~$e_0\in\mathbb{U}$. As~$e_0\in E'(t_0)$ and~$S(t_0)=S'(t_0)$, $S(t_0)\models tri(e_0)$. Then from 2.c in Definition~\ref{def:semantics_arg}, $e_0\not\in E(t_0)$ implies $\exists e\in E(t_0)$ such that~${e\succ_\mathbb{E}e_0}$. Then from 2.b applied to~$E'(t_0)$, we get ${e\not\in E'(t_0)}$. Now, either $e\in\mathbb{A}$ or $e\in\mathbb{U}$. If~$e\in\mathbb{A}$, as $e\in E(t_0)$, condition 2.d would imply that~$S'(t_0)\not\models tri(e_0)$ which contradicts our assumption. In the second case, if~$e\in\mathbb{U}$, then~$e\in E(t_0)$ and~$e\not\in E'(t_0)$ because of the same reasons behind~${e_0\not\in E(t_0)}$ and~${e_0\in E'(t_0)}$. If we apply the same reasoning to~$e$, we get~$\exists e'\in\mathbb{U}$ such that $e'\in E(t_0)$, $e'\not\in E'(t_0)$, and~$e'\succ_\mathbb{E}e$. This reasoning can be repeated again on~$e'$ and so on. As $\mathbb{U}$ is finite, either the chain will be broken, or an event will be used a second time. The first case means~$\exists \tilde{e}\in\mathbb{U}$ such that $\tilde{e}\not\in E(t_0)$ and~$\tilde{e}\in E'(t_0)$ is false, which makes all the chain false. In the second case, by transitivity we get~$\tilde{e}\succ_\mathbb{E}\tilde{e}$. This leads to a contradiction as~$\succ_\mathbb{E}$ is a strict partial order. Thus, $e_0\in\mathbb{U}$ is not possible. 
            
            ii) As from (i)~$e_0\in\mathbb{A}$, by condition 1. in Definition~\ref{def:traces_arg}, ${e_0\in E'(t_0)}$ implies ${e_0\in\left\{a,\exists o\in\mathbb{N}, (a,o)\in\varsigma\right\}}$. $\varsigma$ being the same for~$\epsilon$ and~$\epsilon'$, the rank~$o_0\in\mathbb{N}$ associated to~$e_0$ is the same. Hence, given that~$\forall t<t_0$, $\epsilon(t)=\epsilon'(t)$ and~$e_0\in E'(t_0)$, $e_0\not\in E'(t)$ implies $e_0\not\in E(t)$.
            %any permutation in the order of actions---given~$\left(\left(e,o\right),\left(e',o'\right)\right)\in\varsigma^2$ and~$o<o'$, $\exists t'$ such that~$e\in E(t')\wedge e'\in E(t)\wedge t<t'$---or any omission of action---given~$\left(e,o\right)\in\varsigma^2$, $\nexists t', e\in E(t')$---leads to a contradiction with condition 2. in Definition~\ref{def:traces_arg}. 
            The only possibility left is the procrastination of actions. In the case where~$\nexists (e,o_0)\in\varsigma$ such that~$e\in E(t_0)$, $E(t_0)=\varnothing$ which is in contradiction with condition 2.e in Definition~\ref{def:semantics_arg}. Otherwise, we have a contradiction with condition 3. in Definition~\ref{def:traces_arg}. Thus, $e_0\in\mathbb{A}$ is not possible.\\
            Since the assumption of the existence of~$t_0$ leads to a contradiction for all above cases, we have no alternative but to reject the existence of a minimal daten$t_0$ at which a difference between~$\epsilon$ and~$\epsilon'$ is observed, and thus to reject that $\epsilon\neq\epsilon'$. The unicity of traces is accordingly established.
            %$\bullet$ Additionally, according to Definition~\ref{def:semantics}, we know that~$S(t+1)$ and~$S'(t+1)$ are generated from~$(S(t), E(t))$ and~$(S'(t), E'(t))$ respectively. From the above, we can deduce that~$S(t+1) = S'(t+1)$. Hence, given that~$E(-1)=E'(-1)$ and $S(0)=S'(0)$, $\epsilon=\epsilon'$.
        \end{proof}
    
        From now on, when reference is made to events and states, they will be those from the unique~$\tau_{\chi}^e$ and~$\tau_{\chi}^s$, respectively. Thus, the set of all events which actually occurred at time point~$t$ is~$E^{\chi}(t)=\tau_{\chi}^e(t)$. Following the same reasoning, the actual state at time point~$t$ is~$S^{\chi}(t)=\tau_{\chi}^s(t)$.
        
    \subsection{Soundness and Completeness}
        
        In this section, we establish the soundness and completeness of our transformation. For that, we first introduce the notion of associated graph as follows:
        
        \begin{definition}\label{def:associated_graph}
            Given a state~$S^\chi(t)$, $AF' = (A',R')$, where $A' = \{ x \mid S^\chi(t)\models p_x\}$ and $R' = \{ (y,x) \mid S^\chi(t)\models cA_{y,x}\}$, is called the \emph{associated graph} of~$S^\chi(t)$.
        \end{definition}
        
        From the acyclicity property of the fluent~$cA$, the associated graph is acyclic.
        
        Now, we focus on the notion of acceptability. We first characterise argumentative states using $tri$.
        
        \begin{lemma}\label{lem:equiv_tri_arg_state}
            Let~$S^\chi(t)$ be a state. The two following propositions are equivalent:
            
            $\bullet \; \forall e\in\mathbb{U}$, $S^\chi(t)\not\models tri(e)$
            
            $\bullet \; S^\chi(t)$ is an argumentative state as defined in Def.~\ref{def:admissible_state}.
        \end{lemma}
         
        \begin{proof}
            In our context, $\mathbb{U} = \{makesAcc,makesUnacc\}$. We  prove that  $S^\chi(t)\not\models tri(makesAcc_{x})$ is equivalent to (ii) of Definition~\ref{def:admissible_state} and $S^\chi(t)\not\models tri(makesUnacc_{y,x})$ is equivalent to (i) of Definition~\ref{def:admissible_state}: for any~$x, y$
            
            \noindent $ \bullet$ $\neg tri(makesAcc_{x}) =\neg (p_x \wedge \neg a_x \wedge (\bigwedge_y \neg a_y\vee\neg cA_{y,x}))$\\ $= \neg (p_x \wedge (\bigwedge_y \neg a_y\vee\neg cA_{y,x})) \vee a_x$\\ $= p_x \wedge (\bigwedge_y \neg a_y\vee\neg cA_{y,x}) \Rightarrow a_x$, which leads to the desired equivalence with (ii) in Definition~\ref{def:admissible_state}.
            
             \noindent $ \bullet$$ \neg tri(makesUnacc_{y,x}) =  \neg (a_x \wedge a_y \wedge cA_{y,x})$ \\$=  \neg (a_x \wedge p_y \wedge a_y \wedge cA_{y,x}) \mbox{ as $a_y$ implies $p_y$}\\
             =  \neg (a_x \wedge p_y \wedge cA_{y,x}) \vee \neg a_y$\\$=  a_x \wedge p_y \wedge cA_{y,x} \Rightarrow \neg a_y $, which leads to the desired equivalence with (i) in Definition~\ref{def:admissible_state}.
        \end{proof}
        
        An argumentative state can therefore be seen as a state where nothing happens until a voluntary action is made. Now we prove that it is always possible to reach such a state from an argumentative state in which an $x$ is enunciated.
        
        \begin{proposition}\label{prop:arg_state_necess}
            Given an argumentative state~$S^\chi(t)$ and ${x\in A}$, if $enunciate_x\in E^\chi(t)$, then~$\exists t'\in\mathbb{T}$, $t<t'$ such that~$S^\chi(t')$ is an argumentative state.
        \end{proposition}
        
        \begin{proof}
            Given an argumentative state~$S^\chi(t)$  and $x \in A$ such that $enunciate_x \in E(t)$, let us prove that $\exists t'\in\mathbb{T}$, ${t < t'}$ such that no trigger is a logical consequence of $S^{\chi}(t')$, which leads to the desired result using Lemma~\ref{lem:equiv_tri_arg_state}. 
            
            As $\mathbb{U}$ and $\{S^{\chi}(t)\models cA_{y,x}\mid (x,y) \in A^2\}$ are finite sets, there is a finite number of possible triggering for $E^{\chi}(t)$. Moreover, as there is a finite number of arguments, there is a finite number of paths in the associated graph. The graph being acyclic, each path length is finite. Therefore, there is a finite maximum number of sets of events~($M$) and so $\exists t' \leq (t + M + 1)$ such that~${\forall e \in \mathbb{U}, S^{\chi}(t') \nvDash tri(e)}$. 
        \end{proof}
        
        Finally, this proposition allows us to prove that an acceptable argument in the argumentative state is acceptable in the associated graph and vice-versa, 
        %Finally, 
        as the triggering rules have been made in order to model how acceptability is computed.
        % and an argumentative state is a state where no more triggers can happen. 
        We first prove a useful lemma.
        %is an acceptable argument in the argumentative state acceptable in the associated graph and vice-versa?
%        \mj{pas fan des questions dans les articles scientifiques}
        
        \begin{lemma}\label{lem:equiv_cond_ii}
            Given an argumentative state~$S^\chi(t)$, for any~$x$,\\
            $S^\chi(t) \models p_x \wedge \neg a_x \Leftrightarrow S^\chi(t) \models \exists y, p_x \wedge a_y \wedge cA_{y,x}$.
        \end{lemma}
        
        \begin{proof}
            $[\Rightarrow]:$ For any~$x$ such that $S^\chi(t) \models p_x \wedge \neg a_x$, (ii) of Definition~\ref{def:admissible_state} implies that $S^\chi (t) \models \neg p_x \vee (\bigvee_y a_y \wedge cA_{y,x})$. Therefore, as $S^\chi(t) \models p_x, S^\chi(t) \models \exists y, p_x \wedge a_y \wedge cA_{y,x}$.
            
            $[\Leftarrow]:$ 
            % Let us prove it by contradiction. \mj{bon, je crois que j'ai cassé des trucs, désolée, je ne comprends pas cette preuve}
            % %\mj{c'est une preuve par contraposée, pas contradiction - c'est pareil en anglais, non ? Ah ok, merci ! je en savais pas ! je ne suis pas completement sure non plus...}
            % Consider $x$ such that $S^\chi(t) \models \neg p_x \vee a_x$ then, as $S^\chi(t) \models p_x$, $S^\chi(t)\models a_x$. Therefore, $S^\chi(t) \models a_x \wedge (\exists y,p_x \wedge a_y \wedge cA_{y,x})$. 
            % Hence, $S^\chi(t) \models tri(makesUnacc_{y,x})$. This is not possible as  $S^\chi(t)$ is an argumentative state. 
            %\Isa{en fait je me demande si dans ce sens ce n'est pas trivial... On a tout de suite $S^\chi(t) \models p_x$ (puisque $\models$ une conjonction qui contient $p_x$)} \mj{il faut montrer le non $a_x$, mais oui, c'est censé être trivial, c'est bien ce qu'on veut} \Isa{avec ii de la def 7 ? je regarde ça... zut c'est dans l'autre sens... c'est i en echangeant les roles de x et y je crois !}
            %\Yann{Nouvelle tentative :} 
            Let us prove it by contraposition: let  $x_0$ be such that $S^\chi(t) \models \neg p_{x_0} \vee a_{x_0}$. If $S^\chi(t) \models \neg p_{x_0}$, then $x_0$ is such that $S^\chi(t) \models \forall y, \neg p_{x_0} \vee \neg a_y \vee \neg cA_{y,x_0}$, which ends the proof. Otherwise, $S^\chi(t) \models p_{x_0} \wedge a_{x_0}$. If $S^\chi(t) \models p_{x_0}\wedge (\exists y, a_y \wedge cA_{y,x_0})$ then 
            %as $S^\chi(t) \models p_{x_0} \wedge a_{x_0}$, $S^\chi(t) \models a_{x_0} \wedge p_{x_0}\wedge (\exists y, a_y \wedge cA_{y,x_0}$ i.e 
            $S^\chi (t) \models tri(makesUnacc_{y,x_0})$, which is not possible as $S^\chi(t)$ is argumentative. Thus both cases lead to a contradiction.%\\ 
            %Therefore, we get in both cases that $S^\chi(t) \models \neg p_{x_0} \vee a_{x_0} \Rightarrow S^\chi(t) \models \forall y, \neg p_{x_0} \vee \neg a_y \vee \neg cA_{y,x_0}$.
        \end{proof}
        
        The next proposition establishes the correspondence between acceptability in argumentation and argumentative states.
        
        \begin{proposition}\label{pro:associated_graph}
            Given an argumentative state~$S^\chi(t)$ and its associated graph~${AF=(A,R)}$ according to Definition~\ref{def:associated_graph}, then for any~$x$, $x\in A$ acceptable by $A \iff S^\chi(t)\models a_x$.
        \end{proposition}
        
        \begin{proof}
            $[\Rightarrow] :$ Let $x_0 \in A$ such that $x_0$ is acceptable by A, let us prove that~$S^\chi(t)\models a_{x_0}$.
            
            Let us suppose that~$S^\chi(t)\models \neg a_{x_0}$. Moreover, by construction of AF $S^{\chi}(t)\models p_{x_0}$. $S^{\chi}(t)$ is an argumentative state so according to Lemma~\ref{lem:equiv_cond_ii} $S^{\chi}(t)\models p_{x_0}\wedge\neg a_{x_0} \Leftrightarrow S^{\chi}(t) \models \exists y, p_{x_0} \wedge a_y \wedge cA_{y,{x_0}}$. (i) of Definition~\ref{def:admissible_state} applied to~$a_y$ says that $\forall z, S^{\chi}(t) \models a_y \wedge p_z \wedge cA_{z,y} \Rightarrow S^{\chi}(t)\models \neg a_z$. As there is a finite number of arguments, it is possible to repeat the process we applied for ${x_0}$ on $z$ until one of the two scenarios:
            
            $\bullet$ $S^{\chi}(t) \models \nexists y , p_{z} \wedge a_y \wedge cA_{y,z}$. This leads to trigger the exogenous event $makesAcc_{z}$ which is not possible as $S^{\chi}(t)$ is an argumentative state according to Lemma~\ref{lem:equiv_tri_arg_state}.
            
            $\bullet$ $\forall z,S^{\chi}(t) \models a_y \wedge p_z \wedge cA_{z,y} \Rightarrow S^{\chi}(t)\models\neg a_z$ where $p_z \wedge cA_{z,y}$ is false. Then in $AF$, $Att_y = \emptyset$. Therefore, $y$ is acceptable which contradicts that ${x_0}$ is acceptable.
            
            So, $S^\chi(t)\models a_{x_0}$.
            
           $[\Leftarrow]:$ Let ${x_0} \in A$ such that $S^\chi(t)\models a_{x_0}$. Let us prove that ${x_0}$ is acceptable by $A$.
            
            As $S^\chi(t)\models a_{x_0}$ and $ S^{\chi}(t)$ is argumentative, we have that $ \forall y, S^{\chi}(t) \models  a_{x_0} \wedge p_y \wedge cA_{y,{x_0}} \Rightarrow S^\chi(t)\models \neg a_y$. Then, for any~$y$ satisfying the premise, by definition of $AF$, $({x_0},y) \in A^2$ and $(y,{x_0}) \in R$.
            
            If such a~$y$ is acceptable by $A$, then according to $[\Rightarrow]$, $S^\chi(t)\models a_y$. In that case, $ S^{\chi}(t) \models tri(makesUnacc_{y,{x_0}})$ which contradicts the fact that $ S^{\chi}(t)$ is an argumentative state.
            
            So, as $\forall y\in Att_x$, $y$ is not acceptable by $A$, ${x_0}$ is acceptable by~$A$.
        \end{proof}
        
        We proved that there is an equivalence between an argumentative state and its associated graph. Now, from a dialogue and the attack relation, the traces are generated as well as an AAF. From that point, we establish the existence of a state whose associated graph is equal to the initial AAF. Such a state is called the \emph{final argumentative state} and is defined as an argumentative state~$S^{\chi}(t)$ such that~$\forall x\in A$, $\exists t'\in\mathbb{T}$ such that $t'<t$ and~$enunciate_x\in E^\chi(t')$.
        
        \begin{theorem}[Soundness and Completeness]\label{th:sound_complete}
            Given a dialogue~$\Delta$ and a set of attack~$R$, given the argumentative setting~$\chi$, the associated argumentative graph~$AF'$ of the final argumentative state~$S^{\chi}(t)$, and~${AF=(A,R)}$ obtained from~$(\Delta,R)$, it holds that $AF'=AF$.
        \end{theorem}
        
        \begin{proof}
            As $AF'$ is associated to a final argumentative state,~$\forall x\in A$, $\exists t'\in\mathbb{T}$ such that $t'<t$ and~${enunciate_x\in E^\chi(t')}$. Now, $eff(enunciate_x) = p_x \wedge a_x$. So, $A' = A$.
            
            Moreover, by construction of $cA_{y,x}$ and $R'$, $R=R'$. So $AF = AF'$.
            
            Finally, from Proposition~\ref{pro:associated_graph} as $S^{\chi}(t)$ is argumentative, $\forall x \in A=A', S^{\chi}(t)\models a_x \Leftrightarrow x$ is acceptable by $A$.
        \end{proof}
        
    \subsection{On Temporality and Causality}
    
            The preliminary Proposition~\ref{prop:unicity_valid_execution} highlights the fact that temporality is captured by the proposed transformation. Indeed, given an order of enunciation, as expressed by sequence~$\varsigma$, 
        there exists a unique trace of states corresponding to a unique way to traverse a graph. When only given a context~$\kappa$, this unicity property does not hold. This section  
        shows that this temporality does not impact the final argumentative state  but impacts the causal relations.
        %studies how this temporality impacts both the final argumentative state and the causal relations.
        
        \begin{proposition}\label{prop:indep_order}
            Let~$\varsigma$ and~$\varsigma'$ be sequences such that~$\varsigma'$ is a permutation of the ranks of~$\varsigma$. Given the final argumentative states~$S^{\varsigma,\kappa}(t)$, $S^{\varsigma',\kappa}(t')$, belonging to~$\tau_{\varsigma,\kappa}^s$ and~$\tau_{\varsigma',\kappa}^s$, with $(t,t')\in\mathbb{T}\times\mathbb{T'}$, $S^{\varsigma,\kappa}(t)=S^{\varsigma',\kappa}(t')$. 
%            $(t,t')\in\mathbb{T}\times\mathbb{T'}$, and two final argumentative states~$S^{\varsigma,\kappa}(t)$, $S^{\varsigma',\kappa}(t')$%\footnote{Where, as $(a,o)\in\varsigma$, $\rho\left(\varsigma\right)\overset{\mathrm{def}}{=}(a,\rho(o))$.} 
            %belonging to~$\tau_{\varsigma,\kappa}^s$ and~$\tau_{\varsigma',\kappa}^s$, respectively,
        \end{proposition}
        
        \begin{proof}
            Let us call $AF$ and $AF'$, the associated graphs of  the final argumentative states $S^{\varsigma,\kappa}(t)$ and $S^{\varsigma',\kappa}(t')$, respectively. Given that they have the same actions in the sequence, then $A = A'$. They also share the same context so $R = R'$. Therefore $AF = AF'$.
            
            Now, according to Proposition~\ref{pro:associated_graph}, $x \in A$ acceptable by $A \Leftrightarrow S^{\varsigma,\kappa}(t)\models a_x$. So $\forall x, S^{\varsigma,\kappa}(t)\models a_x \Leftrightarrow \forall x, S^{\varsigma',\kappa}(t')\models a_x$.
        \end{proof}
        
        This property implies that the final argumentative state does not depend on~$\varsigma$, but only on the set of arguments it contains: no matter the order in which arguments are enunciated, the final argumentative state is always the same. This immediately leads to the following unicity corollary:  
        
        \begin{corollary}\label{cor:unique_arg_state}
            Given an~${AF=(A,R)}$, $\exists! S^\chi(t)$ final argumentative state which associated argumentative graph is~${AF=(A,R)}$.
        \end{corollary}
        
        %\mj{en effet, preuve immédiate : virée !}
       % \begin{proof}
        %    Can be immediately derived from the fact that the final argumentative state does not depend on~$\varsigma$ but only on $A$ (see Proposition~\ref{prop:indep_order}),  that the associated argumentative graph of the final argumentative state~$AF'=AF$ (see Theorem~\ref{th:sound_complete}), and that the trace $\tau_{\chi}^s$ is unique (see Proposition~\ref{prop:unicity_valid_execution}).
        %\end{proof}
        
        Proposition~\ref{prop:indep_order} and its corollary are in accordance with AAF. The relevance of temporality integration comes from the intermediate states, as illustrated in the next section, and from the causal relations that can be derived from it:
        %Then does adding temporality really matter in the end?
        %\mj{pas fan des qusetions dans les articles}
        
        \begin{proposition}\label{prop:dep_ordre_causes}
            Causal relations depend on the sequence~$\varsigma$.
        \end{proposition}
        
        \begin{proof}
        This proposition is proved by example, commented in details in the next section that illustrated the effect of considering Example~\ref{ex:IRM_ou_radio}, and a modification thereof in Example~\ref{ex:IRM_ou_radio_modif}.
            Let $\Pi(\chi)$ be the program obtained given~$\kappa,\varsigma$ of Example~\ref{ex:IRM_ou_radio}, as described in Section~\ref{sec:ASP}, and let $\Pi(\chi')$ be the program similarly obtained given~$\kappa,\varsigma'$ of Example~\ref{ex:IRM_ou_radio_modif}. Given the NESS-cause definition in~\cite{sarmiento_action_2023}, ${\Pi(\chi)\models ness(o(enunciate_d,4),h(neg(a_c),31))}$, where occurrence of events $(e,t)\in\mathbb{E}\times\mathbb{T}$ are represented by the predicate $o(e,t)$ and the truthfulness of $\mathcal{P}$ formulas $(\psi,t)\in\mathbb{F}\times\mathbb{T}$ by the predicate $h(\psi,t)$, but $\nexists t,t'\in\mathbb{T}^2$, ${\Pi(\chi')\models ness(o(enunciate_d,t),h(neg(a_c),t'))}$.
        \end{proof}
    
        %The order on enunciation does really matter, at least for the causal relations between arguments. We will discuss more about its impact in the next section.
        
        %We will now describe the Answer Set Programming~(ASP) implementation by~\cite{sarmiento_action_2023}. The ASP program~$\pi_{con}(\kappa)$ is obtained by the translation of the context~$\kappa\stackrel{def}{=}(\mathbb{E},\mathbb{F},pre,tri,e\ff,S(0),\succ_{\mathbb{E}},\mathbb{T})$. The set~$\mathbb{T}$ is represented by \texttt{time(0..N)}. Each fluent~$f\in\mathbb{F}$ is represented by a predicate \texttt{fluent(f)} and each fluent~${f\in S(0)}$ is represented by a predicate \texttt{initially(f)}. Each action and exogenous event in~$\mathbb{E}$ is respectively translated as \texttt{action(a\_name,a\_pre,a\_eff)} and \texttt{auto(u\_name,u\_tri,u\_eff)}, where \texttt{a\_name}~$\in\mathbb{A}$, \texttt{u\_name}~$\in\mathbb{U}$, \texttt{a\_pre} is a goal descriptor (GD) allowing us to identify the preconditions of events as~$pre$, \texttt{u\_tri} is a goal descriptor allowing us to identify the triggering conditions of exogenous events as~$tri$, and \texttt{a\_eff} and \texttt{u\_eff} are goal descriptors allowing us to identify the effects of events as $e\ff$. The predicates \texttt{conj(GD)}, \texttt{disj(GD)}, and \texttt{in(GD,GD\_L)} allow constructing formulas of~$\mathcal{P}$. The predicates \texttt{conj(GD)} and \texttt{in(GD,GD\_L)} allow constructing formulas of~$\mathcal{E}$. Finally, the priority relation~${e\succ_{\mathbb{E}}e'}$ where~$(e,e')\in\mathbb{E}^2$ is represented by the predicate \texttt{priority(e,e')}.
        
        %The ASP program~$\pi_{sce}(\sigma)$ is obtained by the translation of the scenario~$\sigma\subseteq\mathbb{A}\times\mathbb{T}$. In this translation, each couple of timed actions~$(a,t)\in\sigma$ is represented by a predicate \texttt{performs(a,t)}.
        %The ASP program~$\pi_{\mathbb{A}}$ is obtained by the translation of the action language semantics introduced in Section \ref{sec:Modele}. The ASP program~$\pi_{\mathbb{C}}$ is obtained by the translation of the causal relations definitions introduced by~\cite{sarmiento_action_2022-1}. \cite{sarmiento_action_2023} proved this translation to be sound and complete. Both $\pi_{\mathbb{A}}$ and $\pi_{\mathbb{C}}$ are independent of the domain. For interested readers, both translations are detailed in~\cite{sarmiento_action_2023}.
        
        %In this translation, each couple of ranked actions $(a,o)\in\varsigma$ is represented by a predicate \texttt{performs(a,o)}. The ASP program obtained by the translation of the context~$\pi_{con}(\kappa)$ uses the same predicates as those introduced in Section \ref{sec:ASP}. The entire program $\Pi(\chi)$ of Definition \ref{def:program}---with~$\pi_{sce}(\varsigma)$ and $\pi_{con}(\kappa)$ adapted to our example, and~$\pi_{\mathbb{A}}$ adapted to the new semantics---is made available\footnote{\textbf{Lien Git à mettre}}.