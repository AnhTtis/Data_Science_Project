\section{Validation}
\label{sec:validation}

\begin{comment}
How to show that the model is working correctly (in terms of functionality as well as performance modeling)?
\begin{itemize}
\item Rely on traffic generator baseline studies (with read only hits, read only misses kind of patterns), and show that we get expected results
\item Comparison of performance between the model and Intel Cascade lake results (will be difficult to do in full-form, but we might be able to think of some related experiments to present the point)
\end{itemize}
\end{comment}

In this section, we present the validation of our DRAM cache model in \gem.
Any simulation model needs to be functionally correct, as well as provide accurate performance statistics.
To ensure functional validation,
% We performed following actions for the functional validation of the implemented model:
%\item We successfully ran a collection of benchmarks\footnote{Bubblesort, Dhrystone, FloatMM, IntMM, miniAMR, miniGMG, Oscar, Perm, Quicksort, RealMM, RSBench, Towers, %Treesort, XSBench} in the \textit{SE (system call emulation)} mode of \gem~and compared the output of these benchmarks with the reference output.
% \begin{itemize}
we successfully performed Linux kernel boot tests in \gem{} full system mode, and
we ran some commonly used HPC class benchmarks in \gem{} full-system mode, which are presented in Section~\ref{sec:realBench} of this paper.

The evaluation of the accuracy of the performance model is generally not straightforward. Still, reasonable confidence can be established in the performance model by relying on the evaluation of performance numbers in controlled experiments.
We performed a comparison of the effective memory bandwidth observed with \gem's default memory controller (\textit{DMC}) and the unified DRAM cache controller (\textit{UDCC}).
We rely on a synthetic read memory traffic pattern such that (nearly) \textit{all requests will be hits in the DRAM cache} in the case of a system where we use \textit{UDCC}.
We use both a linear and a random traffic pattern.
Figure~\ref{fig:valid} provides both controllers' read bandwidth and compares these numbers to the theoretical peak bandwidth possible with the DDR4 device used in this experiment.
As expected, we observe that the bandwidth attained by \textit{DMC} and \textit{UDCC} is very close.
The scheduling policy implemented in both controllers (details in Section~\ref{sec:sched}) can explain the slight difference.
The effective bandwidth in both cases is less than the theoretical peak bandwidth.

The access amplification (total number of memory accesses divided by the demand requests) can be significant in DRAM caches, especially in the case of writes.
We compare the access amplification of our model with that of the actual hardware.
We use the access amplification numbers presented by Hildebrand et al.~\cite{hildebrand2021case} on an Intel Cascade Lake system.
We calculate the access amplification values for \textit{UDCC} by dividing the effective bandwidth (seen by the LLC) by the sum of the average bandwidth of DRAM and NVRAM devices for a particular run.
The comparison of the two access amplification values is shown in Figure~\ref{fig:valid2}.
Our results match the actual hardware in all cases with only one exception.
The reason for smaller access amplification for write misses is that our implementation slightly optimizes the write requests.
In actual hardware, on a write miss in DRAM cache, the block is first allocated by reading it from NVRAM and then writing it into DRAM. The actual data is then written into the DRAM. We merge these two DRAM writes, and thus, our implementation leads to one less access for a write miss compared to the actual hardware.

Finally, we manually stepped through the operations of different kinds of accesses (reads/writes and hits/misses) to ensure they behaved as expected.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/bwcomp.pdf}
  \vspace{-1ex}
  \caption{Read bandwidth comparison between \gem~default memory controller (\textit{DMC}), unified DRAM cache controller (\textit{UDCC}), and the theoretical peak bandwidth on DDR4. In case of \textit{UDCC}, all accesses hit in the DRAM cache. Two different traffic patterns (linear, random) are used. Read buffer size in \textit{MC}, and \textit{ORB} size in \textit{UDCC} is 256 entries.}
  \label{fig:valid}
\end{figure}

 \begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/accAmpl.pdf}
  \vspace{-1ex}
  \caption{Access amplification observed with \textit{UDCC} in \gem{} and on the real hardware (Hildebrand et al.~\cite{hildebrand2021case}).}
  \label{fig:valid2}
\end{figure}
