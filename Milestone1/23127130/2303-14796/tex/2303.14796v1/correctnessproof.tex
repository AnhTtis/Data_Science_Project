\subsection{Hyper Linear Temporal Logic (HyperLTL)}
\begin{comment}
    
\textit{Linear Temporal Logic (LTL)} is a language for specifying trace properties, that is, properties of sequences of sets of atomic propositions. Besides the standard boolean operators, LTL also includes modal operators, namely

\begin{itemize}
    \item the next-operator $\LTLnext$. $\LTLnext \varphi$ states that the formula $\varphi$ should hold in the next timestep.
    \item the eventually-operator $\LTLeventually$. $\LTLeventually \varphi$ states that $\varphi$ should hold at some timepoint in the future.
    \item the until-operator $\LTLuntil$. $\varphi \LTLuntil \psi$ states that the formula $\psi$ must hold eventually and, until this is the case, $\varphi$ must hold.
    \item the globally-operator $\LTLglobally$. $\LTLglobally \varphi$ states that $\varphi$ must hold from now on and forever.
\end{itemize}

We only treat the next-operator and the until-operator as native and derive the other operators.

\begin{definition}
    An \textbf{LTL Formula} is defined by the grammar
    \begin{align*}
        \varphi ::= a \mid \neg \varphi \mid \varphi \wedge \varphi \mid \LTLnext \varphi \mid \varphi \LTLuntil \varphi && \text{where } a \in AP
    \end{align*}
    The operators $\vee, \LTLeventually, \LTLglobally$ can be derived using the equations $\varphi \vee \psi = \neg (\neg \varphi \wedge \neg \psi)$, $\LTLeventually \varphi = true \LTLuntil \varphi$, $\LTLglobally \varphi = \neg \LTLeventually \neg \varphi$.
\end{definition}


\begin{definition}
    The \textbf{satisfaction of an LTL formula} with respect to a trace $s \in (2^{AP})^\omega$ and a time point $t$ is recursively defined by
\begin{align*}
    &t, s \lmodels a &&\Leftrightarrow a \in s_t \\
    &t, s \lmodels \neg \varphi &&\Leftrightarrow \neg (t, s \lmodels \varphi) \\
    &t, s \lmodels \varphi \wedge \psi &&\Leftrightarrow t, s \lmodels \varphi \wedge t, s \lmodels \psi \\
    &t, s \lmodels \LTLnext \varphi &&\Leftrightarrow t + 1, s \lmodels \varphi \\
    &t, s \lmodels \varphi\LTLuntil\psi &&\Leftrightarrow \exists t' \geq t.~ t', s \lmodels \psi \wedge \forall  t \leq t'' < t'.~ t'', s \lmodels \varphi
\end{align*}
We define $s \lmodels \varphi$ as $0, s \lmodels \varphi$
\end{definition}

It is well known that it is possible to translate an LTL formula into an equivalent Büchi automaton that accepts exactly the traces satisfying the LTL formula \cite{LTL_Buechi_Tut}. However, if the formula is of size $n$, the Büchi automaton might have up to $2^{\mathcal{O}(n)}$ states. The classical translation algorithm has been improved, making it faster in practice and reducing the size of the automaton \cite{LTL_Buechi, LTL_Buechi2}.

\textit{HyperLTL} \cite{HyperLTL} extends LTL with explicit trace quantification. An LTL formula has to hold for all traces of the system, so this is an implicit universal quantification. Within an HyperLTL formula, we can use multiple (different) quantifiers and thereby relate multiple traces. Every atomic proposition is now attached to a trace variable.
In the following, let $\Pi$ be a set of trace variables.
\end{comment}
Let AP be a finite set of atomic propositions and let $\Pi$ be a finite set of trace variables. Then, a {HyperLTL formula} is defined by the grammar
    \begin{align*}
        \varphi ::= a_\pi \mid \neg \varphi \mid \varphi \wedge \varphi \mid \LTLnext \varphi \mid \varphi \LTLuntil \varphi \mid \forall \pi.~ \varphi \mid \exists \pi.~ \varphi
    \end{align*}

\noindent where $a \in AP$ and $\pi \in \Pi$. 

The satisfaction of a HyperLTL formula is defined with respect to a mapping $m: \Pi \rightarrow (2^{AP})^\omega$ of trace variables to traces. For treating the quantifiers, we need the notion of extending such a mapping for a new trace variable. We define
\begin{align*}
    m[\pi \rightarrow s] (\pi) &= s \\
    m[\pi \rightarrow s] (\pi') &= m(\pi') &&\text{for } \pi \neq \pi'
\end{align*}

    The satisfaction of a HyperLTL formula with respect to a set of traces $Z \subseteq {2^{AP}}^\omega$, a mapping of trace variables to traces $m: \TraceVs \rightarrow {2^{AP}}^\omega$ and a time point $t$ is recursively defined by 
    \begin{align*}
        &Z, t, m \lmodels a_{\pi} &&\Leftrightarrow a \in m(\pi)_t \\
        &Z, t, m \lmodels \neg \varphi &&\Leftrightarrow \neg (Z, t, m \lmodels \varphi) \\
        &Z, t, m \lmodels \varphi \wedge \psi &&\Leftrightarrow Z, t, m \lmodels \varphi \wedge Z, t, m \models \psi \\
        &Z, t, m \lmodels \LTLnext \varphi &&\Leftrightarrow Z, t + 1, m \lmodels \varphi \\
        &Z, t, m \lmodels \varphi\LTLuntil\psi &&\Leftrightarrow \exists t' \geq t.~ Z, t', m \lmodels \psi \wedge \forall t \leq t'' < t'.~ Z, t'', m \lmodels \varphi \\
        &Z, t, m \lmodels \forall \pi.~\varphi &&\Leftrightarrow \forall s \in Z.~m[\pi \rightarrow s] \lmodels \varphi \\
        &Z, t, m \lmodels \exists \pi.~\varphi &&\Leftrightarrow \exists s \in Z.~m[\pi \rightarrow s] \lmodels \varphi
    \end{align*}
    We define $Z \lmodels \varphi$ as $Z, 0, \emptyset \lmodels \varphi$.

For the sepcial case in which there is only one trace quantifier, and this is a universal quantifier, we are in the fragment of LTL. 
\subsection{Similiarity of LTL and TSL}

The following lemma states an important relation between (Hyper)TSL and LTL. The LTL semantics is defined with respect to a sequence of subsets of atomic propositions, while the semantics of a TSL-formula or quantifier-free HyperTSL formula is defined with respect to a (hyper-)computation. A crucial observation for this thesis is that we can `translate' between the two -- a (hyper-)computation defines a sequence of predicate and update term subsets. For each time point, the subset contains exactly the predicate and update terms that are true now.

\begin{definition} \label{def:TSL_LTL}
    Let $\HComput \in \HAssigns^\omega, \PredSet \subseteq \HPredTerms, \USet \subseteq \HUpdTerms$. We define
    \begin{align*}
        \UPredSeq(\HComput, \PredSet, \USet)_t &= \{\HPredTerm \in \PredSet \mid t, \emptyset, \HComput \models \HPredTerm\} \cup \{\Upd{c}{\HFuncTerm{}} \in \USet \mid t, \emptyset, \HComput \models \Upd{c}{\FuncTerm{}}\} \\
        \UPredSeq(\HComput, \PredSet, \USet) &= \UPredSeq(\HComput, \PredSet, \USet)_0 ~\UPredSeq(\HComput, \PredSet, \USet)_1 ~\UPredSeq(\HComput, \PredSet, \USet)_2 \dots
    \end{align*}

    If $\PredSet$ and $\USet$ are clear from the context, we also omit these arguments.
\end{definition}

\begin{lemma} \label{lem:TSL_LTL}
    Let $t \in \mathbb{N}$. Let $\varphi$ be a HyperTSL-formula without quantifiers. Let $\PredSet \subseteq \HPredTerms, \USet \subseteq \HUpdTerms$ be the sets of predicate and update terms appearing in $\varphi$, respectively. Then
    \begin{align*}
        t, \UPredSeq(\HComput) \lmodels \varphi \Leftrightarrow t, \emptyset, \HComput \models \varphi
    \end{align*}
\end{lemma}
\begin{proof} (Lemma \ref{lem:TSL_LTL})
    Proof by structural induction over $\varphi$.
    \begin{itemize}
        \item Case $\varphi = \HPredTerm$
        \begin{align*}
            t, \UPredSeq(\HComput) \lmodels \HPredTerm \Leftrightarrow \HPredTerm \in \UPredSeq(\HComput)_t \Leftrightarrow t, \emptyset, \HComput \models \HPredTerm
        \end{align*}
        \item Case $\varphi = \Upd{c_\pi}{\HFuncTerm{}}$
        \begin{align*}
            t, \UPredSeq(\HComput) \lmodels \Upd{c_\pi}{\HFuncTerm{}} \Leftrightarrow \HPredTerm \in \UPredSeq(\HComput)_t \Leftrightarrow t, \emptyset, \HComput \models \Upd{c_\pi}{\HFuncTerm{}}
        \end{align*}
        \item Case $\varphi = \neg \psi$
        \begin{align*}
            t, \UPredSeq(\HComput) \lmodels \neg \psi \Leftrightarrow \neg(t, \UPredSeq(\HComput) \lmodels \psi) \Leftrightarrow \neg(t, \emptyset, \HComput \models \psi) \Leftrightarrow t, \emptyset, \HComput \models \neg \psi
        \end{align*}
        \item Case $\varphi = \psi \wedge \psi'$
        \begin{align*}
            & &&t, \UPredSeq(\HComput) \lmodels \psi \wedge \psi' \\
            &\Leftrightarrow &&t, \UPredSeq(\HComput) \lmodels \psi \wedge t, \UPredSeq(\HComput) \lmodels \psi' \\
            &\Leftrightarrow &&t, \emptyset, \HComput \models \psi \wedge t, \emptyset, \HComput \models \psi' \\
            &\Leftrightarrow &&t, \emptyset, \HComput \models \psi \wedge \psi'
        \end{align*}
        \item Case $\varphi = \LTLnext \psi$
        \begin{align*}
            t, \UPredSeq(\HComput) \lmodels \LTLnext \psi \Leftrightarrow t+1, \UPredSeq(\HComput) \lmodels \psi \Leftrightarrow t+1, \emptyset, \HComput \models \psi \Leftrightarrow t, \emptyset, \HComput \models \LTLnext \psi
        \end{align*}
        \item Case $\varphi = \psi \LTLuntil \psi'$
        \begin{align*}
            & &&t, \UPredSeq(\HComput) \lmodels \psi \LTLuntil \psi'\\
            & \Leftrightarrow &&\exists t' \geq t.~ t', \UPredSeq(\HComput) \lmodels \psi' \wedge \forall t \leq t'' < t'.~t'', \UPredSeq(\HComput) \lmodels \psi \\
            &\Leftrightarrow &&\exists t' \geq t.~ t', Z, \HComput \models \psi' \wedge \forall t \leq t'' < t'.~t'', Z, \HComput \models \psi \\
            &\Leftrightarrow &&t, \emptyset, \HComput \models \psi \LTLuntil \psi'
        \end{align*}       
    \end{itemize} 
    \vspace{-0.5cm}
\end{proof}

\subsection{Proof of Theorem \ref{thm:k_feasible}} \label{sec:k_feasible_proof}
\begin{proof}
    $\Rightarrow$
    Let $q_0, q_1, q_2 \dots \in Q^\omega$ be a run of $P$ on the $k$-feasible trace $\PTrace$. Then, for every $j \in \mathbb{N}$, $$e_j = ((q_j,\PTrace_{j},q_{j+1} \dots ,\PTrace_{j+k-2},q_{j+k-1}), \PTrace_{j+k-1}, (q_{j+1},\PTrace_{j+1}, \dots, q_{j+k-1},\PTrace_{j+k-1},q_{j+k}))$$ is a transition of $P_k$. Moreover, for every $k' < k$,
    $$ e_{k'} = ((q_0,s_0,q_1\dots ,\PTrace_{k'-1},q_{k'}), \PTrace_{k'}, (q_0, \PTrace_0, \dots ,q_{k'},\PTrace_{k'},q_{k'+1})) $$
    is also a transition of $P_k$. Thus, $q_0, q_1, \dots$ is accepted by $P_k$.

    $\Leftarrow$ 
    Let $\PTrace$ be a trace of $P$ accepted by $P_k$. Then, there exist states of $P$ $q_0, q_1 \dots$ such that for every $j \in \mathbb{N}$, $e_j$ from above is a transition of $P_k$. Thus, by the definition of $P_k$ for every $j$, $\PTrace_j \dots \PTrace_{j+k-1}$ is feasible. Thus, $\PTrace$ is $k$-feasible.
    \qed 
\end{proof}

\subsection{Proof of Theorem \ref{thm:BuechiProdModelChecking}} \label{sec:buechi_corr}

The main idea of the correctness proof is a construction that, given a computation $\Comput$ that matches a program trace $\PTrace$, constructs a computation matching the combined trace $\combine{\PTrace}{\UPredSeq(\Comput)}$ and vice versa ($\UPredSeq$ was defined in Definition \ref{def:TSL_LTL}). This gives us the necessary feasibility proofs. To do so, we define two operations, $\widetilde{(-)}$ and $(-)_{|\PTrace}$ that `nearly' invert each other: we have that $(\widetilde{\Comput})_{|\PTrace} = \Comput$ and if $\matches{\Comput}{\combine{\PTrace}{X}}$ for some $X$, we also have that $\widetilde{\Comput_{|\PTrace}} = \Comput$. In Lemma \ref{lem:corr1} we show that if $\matches{\Comput}{\combine{\PTrace}{X}}$ for some $X$, then $\matches{\Comput_{|\PTrace}}{\PTrace}$. In Lemma \ref{lem:corr2} we show that then, we also have that $X=\UPredSeq(\Comput_{|\PTrace})$. Lemma \ref{lem:corr3} states the other direction: if $\matches{\Comput}{\PTrace}$, then also $\matches{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}$. Those three lemmata give us the feasibility proofs needed for the algorithm's correctness. Lemma \ref{lem:TSL_LTL} then gives the equivalence between the violation of the TSL-formula by $\Comput$ and the sequence $\UPredSeq(\Comput)$ being accepted by $A_{\neg \varphi}$, needed for reasoning about the existence of a trace $\combine{\PTrace}{\UPredSeq(\Comput)}$ in the Büchi program product.

We start with definining the operation $\widetilde{(-)}$. Let $\PTrace \in \Stmt^\omega$ and $\matches{\Comput}{\PTrace}$. We need to extend this computation to one that matches $\combine{\PTrace}{\UPredSeq(\Comput)}$. For every time point $t$, we need to introduce computation steps that match $\combine{\PTrace_t}{\UPredSeq(\Comput)_t} =$ \\
$ \mathit{save\_values}_{{\UPredSeq(\Comput)_t}};~ \PTrace_t;~\mathit{new\_inputs};~\mathit{check\_preds}_{{\UPredSeq(\Comput)_t}};~ \mathit{check\_updates}_{{\UPredSeq(\Comput)_t}}$. While executing $\mathit{save\_values}_{{\UPredSeq(\Comput)_t}}$, the values of the temporary variables are changed as required by the statements $tmp_j := \FuncTerm{j}$. When the actual statement $\PTrace_t$ is executed, the computation changes to $\Comput_t$, but still with the `old' input values and extended with values for the temporal variables. Next, when executing $\mathit{new\_inputs}$, we stepwise change the input values to those in $\Comput_t$.  Then, the assertions are executed and the computation cannot change anymore. 

In the following, we also need the notion of extending an assignment: we define $a[c \mapsto v](c) = v$ and $a[c \mapsto v](c') = a(c')$ for $c \neq c'$.

Let $\USet \subseteq \UpdTerms$ be in the following the set of update terms, and $\PredSet \subseteq \PredTerms$ the set of predicate terms appearing in the formula $\varphi$. 

\begin{definition} \label{def:adaptedComput}
    Let $\Inputs = \{i_1, \dots i_n\}$ be the set of inputs and \\ $\USet = \{\Upd{c_1}{\FuncTerm{1}}, \dots ,\Upd{c_m}{\FuncTerm{m}}\}$. Given a computation $\Comput$, we define the \textbf{adapted computation} $\widetilde{\Comput}$ as follows.
    \begin{align*}
        \Assign^{\mathit{tmp}_1}_t &:= \Comput_{t-1} [\mathit{tmp}_1 \mapsto \Eval(\FuncTerm{1}, \Comput_{t-1})] \\
        \Assign^{\mathit{tmp}_j}_t &:= \Assign^{\mathit{tmp}_{j-1}} [\mathit{tmp}_j \mapsto \Eval(\FuncTerm{j}, \Comput_{t-1})] &&\text{for } 1 < j \leq m\\
        \Assign_t &:= \Comput_t[\mathit{tmp}_1 \mapsto \Eval(\FuncTerm{1}, \Comput_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\FuncTerm{m}, \Comput_{t-1}),\\
        &~~~~~~~~i_1 \mapsto \Comput_{t-1}(i_1),~ \dots,~i_n \mapsto \Comput_{t-1}(i_n) ] \\
        \Assign^{i_1}_t &:= \Assign_t [i_1 \mapsto \Comput_t(i_1)] \\
        \Assign^{i_j}_t &:= \Assign^{i_{j-1}} [i_j \mapsto \Comput_t(i_j)] &&\text{for } 1 < j \leq n\\
        \widetilde{\Comput_t} &:= a^{\mathit{tmp}_1}_t \dots a^{\mathit{tmp}_m}_t~a_t~a^{i_1}_t~\dots~a^{i_n}_t~a^{i_n}_t~a^{i_n}_t \\
        \widetilde{\Comput} &:= \widetilde{\Comput_0}~ \widetilde{\Comput_1}\dots 
    \end{align*}
\end{definition}

Note that this is the only possibility to adapt a computation $\matches{\Comput}{\sigma}$ such that the result \textit{could} match $\combine{\sigma}{X}$ for any $X$.

Also note that $a_t^{i_n} = \Comput_t [tmp_1 \mapsto \Eval(\FuncTerm{1}, \Comput_{t-1}), \dots , tmp_m \mapsto \Eval(\FuncTerm{m}, \Comput_{t-1})]$.

We can also define the left inverse of this operation: reducing a computation that matches $\combine{\PTrace}{X}$ to a computation that matches $\PTrace$.

\begin{definition}
    Let $\PTrace \in \Stmt^\omega, X \in \mathcal{P}(\PredTerms \cup \UpdTerms)^\omega$ and $\matches{\Comput}{\combine{\PTrace}{X}}$. We define the \textbf{reduced computation} $\Comput_{|\sigma}$ as follows.
    \begin{align*}
        \iota(j) &:= (|\Inputs| + |\USet| + 3) \cdot (j+1) -3 \\
        \Comput_{|\PTrace}(U) &:= (\Comput_{\iota(0)})_{| (\Inputs \cup \Cells)}~(\Comput_{\iota(1)})_{| (\Inputs \cup \Cells)} \dots
    \end{align*}
    where $a_{| (\Inputs \cup \Cells)}$ means restricting the domain of the assignment to the original inputs and cells, thus excluding the temporal variables $tmp_1, tmp_2 \dots$
\end{definition}

Note that if $\matches{\Comput}{\combine{\PTrace}{X}}$, we also have that $\Comput = \widetilde{\Comput_{|\PTrace}}$, as this is the \textit{only} computation that could potentially match $\combine{\PTrace}{X}$ and equals $\Comput_{|\PTrace}$ when restricted to~$\PTrace$. 

\begin{lemma} \label{lem:corr1}
    If $\matches{\Comput}{\combine{\PTrace}{X}}$, then $\matches{\Comput_{|\PTrace}}{\sigma}$.
\end{lemma}
\begin{proof}
    We have to show that $\forall t \in \mathbb{N}.~\matchest{\Comput_{|\PTrace}}{\PTrace}{t}$

    Recall that $\Comput = \widetilde{\Comput_{|\PTrace}}$ and
    \begin{align*}
        \widetilde{(\Comput_{|\PTrace})_t} = a^{tmp_1}_t \dots a^{tmp_m}_t~a_t~a^{i_1}_t~\dots~a^{i_n}_t~a^{i_n}_t~a^{i_n}_t
    \end{align*}

    \begin{itemize}
        \item Case $\PTrace_t = \mathit{assert}(\PredTerm)$ \\
        We know that $\matchest{\Comput}{\combine{\PTrace}{X}}{\iota(t)-|\Inputs|}$. The corresponding statement is $\sigma_j$, thus
        \begin{align*}
            \Eval(\PredTerm, \Comput_{\iota(t)-|\Inputs|-1}) = true ~~~\wedge \forall c \in \Cells^*.~\Comput_{\iota(t)-|\Inputs|}(c) = \Comput_{\iota(t)-|\Inputs|-1}(c)
        \end{align*} 
        Moreover, $(\Comput_{\iota(t)-|\Inputs|-1}) = a_t^{tmp_m}$. This equals $(\Comput_{|\PTrace})_{t-1}$ extended with values for the temporary variables. As $\PredTerm$ does not contain the temporal variables, this means that $\Eval(\PredTerm, ((\Comput_{|\PTrace})_{t-1})_{|(\Inputs \cup \Cells)})$ is also true. It remains to show that             
        \begin{align*}
            \forall c \in \Cells.~(\Comput_{\iota(t-1)})_{|(\Inputs \cup \Cells)} (c) = (\Comput_{\iota(t)})_{|(\Inputs \cup \Cells)} (c)
        \end{align*}
        This is true as the only cells changed in $\Comput_{\iota(t-1)} \dots \Comput_{\iota(t)-|\Inputs|-1}$ and in $\Comput_{\iota(t) - |\Inputs|},\dots \Comput_{\iota(t)}$ are cells from $\Cells^* \backslash \Cells$.
        \item The two remaining cases are analogous.
    \end{itemize}
    \vspace{-0.5cm}
\end{proof}

\begin{lemma} \label{lem:corr2}
    If $\matches{\Comput}{combine(\PTrace, X)}$, then $X = \UPredSeq(\Comput_{|\PTrace})$.
\end{lemma}
\begin{proof}
    We prove $\forall t.~ X_t = \UPredSeq(\Comput_{|\PTrace})_t$.
    We know that $\matchest{\Comput}{\combine{\PTrace}{X}}{\iota(t)+1}$. The corresponding statement is $\mathit{check\_preds}_{X_t}$. Set $h = \left(\bigwedge_{\PredTerm \in {X_t}} \PredTerm \wedge \bigwedge_{\PredTerm \in \PredSet \backslash {X_t}} \neg \PredTerm \right)$. This means that 
    \begin{align*}
        \Eval(h, \Comput_{\iota(t)+1}) = true ~~~\wedge \forall c \in \Cells^*.~\Comput_{\iota(t)+1}(c) = \Comput_{\iota(t)}(c)
    \end{align*}
    This implies that $true = \Eval((h, \Comput_{\iota(t)})_{|(\Inputs \cup \Cells)}) = \Eval(h, (\Comput_{|\PTrace})_t)$. Therefore, for all $\PredTerm \in \PredSet$
    \begin{align*}
        \PredTerm \in \UPredSeq(\Comput_{|\PTrace})_t \Leftrightarrow t, \Comput_{|\PTrace} \models \PredTerm \Leftrightarrow \Eval(\PredTerm, \Comput_{\iota(t)}) = true \Leftrightarrow \PredTerm \in {X_t}
    \end{align*} 

    For the update terms, we know that $\matchest{\Comput}{\combine{\PTrace}{X}}{\iota(t)+2}$. The corresponding statement is $\mathit{check\_updates}_{X_t}.$ Set $h=\left( \bigwedge_{\Upd{c_j}{\FuncTerm{j}} \in \USet}
    \begin{cases}
        c_j = tmp_j &\text{if } \Upd{c_j}{\FuncTerm{j}} \in X_t\\
        c_j \neq tmp_j &\text{else} 
    \end{cases}        
        \right)$ As before, we know that $\Eval(h, (\Comput_{|\PTrace})_t) = true$. Moreover, we know that for each $j$, $(\Comput_{|\PTrace})_t (tmp_j) = \Eval(\FuncTerm{j}, (\Comput_{|\PTrace})_{t-1})$ by definition \ref{def:adaptedComput} Therefore, for every $\Upd{c_j}{\FuncTerm{j}} \in \USet,$
        \begin{align*}
            \Upd{c_j}{\FuncTerm{j}} \in \UPredSeq(\Comput_{|\PTrace})_t &\Leftrightarrow t, \Comput_{|\PTrace} \models \Upd{c_j}{\FuncTerm{j}} \\ 
            &\Leftrightarrow \Eval({\FuncTerm{j}}, \Comput_{\iota(t-1)}) = \Eval(c_j, \Comput_{\iota(t)}) \\
            &\Leftrightarrow \Eval(c_j = tmp_j, \Comput_{\iota(t)}) = true \\
            &\Leftrightarrow \Upd{c_j}{\FuncTerm{j}} \in X_t
        \end{align*}
\end{proof}

\begin{lemma} \label{lem:corr3}
    If $\matches{\Comput}{\PTrace}$, then $\matches{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}$
\end{lemma}
\begin{proof}
    We have to show that for all $t$, $\matchest{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}{t}$. This is clear for all time steps except for those of kind $\mathit{check\_preds}$ or $\mathit{check\_updates}$ by the definition of $\widetilde{\Comput}$.

    First consider $\mathit{check\_preds}$. We need to show that $\forall t$, $\matchest{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}{\iota(t)+1}$. This boils down to
    \begin{align*}
        \Eval\left( \left(\bigwedge_{\PredTerm \in {\UPredSeq(\Comput)_t}} \PredTerm \wedge \bigwedge_{\PredTerm \in \PredSet \backslash {\UPredSeq(\Comput)_t}} \neg \PredTerm \right), \widetilde{\Comput}_{\iota(t)} \right) = true
    \end{align*}
    As the temporary variables $\mathit{tmp}_1, \mathit{tmp}_2 \dots $ are not used in any $\PredTerm \in \PredSet$, this is by definition \ref{def:adaptedComput} equivalent to
    \begin{align*}
        \forall \PredTerm \in \PredSet.~\PredTerm \in \UPredSeq(\Comput)_t \Leftrightarrow \Eval(\PredTerm, \Comput_t) = true
    \end{align*}
    This is true by the definition of $\UPredSeq(\Comput)_t$.

    Now consider $\mathit{check\_updates}$. We need to show that $\forall t$, $\matchest{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}{\iota(t)+2}$. This boils down to
    \begin{align*}
        \Eval\left(\left( \bigwedge_{\Upd{c_j}{\FuncTerm{j}} \in \USet}
        \begin{cases}
            c_j = \mathit{tmp}_j &\text{if } \Upd{c_j}{\FuncTerm{j}} \in \UPredSeq(\Comput)_t\\
            c_j \neq \mathit{tmp}_j &\text{else} 
        \end{cases}        
            \right), \widetilde{\Comput}_{\iota(t)} \right) = true
    \end{align*}
    Which is equivalent to 
    \begin{align*}
        \forall \Upd{c_j}{\FuncTerm{j}} \in \USet.~ \Eval(c_j = \mathit{tmp}_j, \widetilde{\Comput}_{\iota(t)}) = true \Leftrightarrow \Upd{c_j}{\FuncTerm{j}} \in \UPredSeq(\Comput)_t
    \end{align*}
    We know that $\widetilde{\Comput}_{\iota(t)}(\mathit{tmp}_j) = \Eval(\FuncTerm{j}, \Comput_{t-1})$. Thus this is equivalent to 
    \begin{align*}
        \forall \Upd{c_j}{\FuncTerm{j}} \in \USet.~ \Eval(\FuncTerm{j}, \Comput_{t-1}) = \Comput_{t}(c) \Leftrightarrow \Upd{c_j}{\FuncTerm{j}} \in \UPredSeq(\Comput)_t
    \end{align*}
    which is again true by the definition of $\UPredSeq(\Comput)_t$.
\end{proof}

Now, we have all the lemmas needed to prove Theorem \ref{thm:BuechiProdModelChecking}
\begin{proof} (Theorem \ref{thm:BuechiProdModelChecking}) \\
    $\Rightarrow$
    Assume that $P \BuechiProd A_{\neg \varphi}$ has a feasible trace. Then, this is a trace $\combine{\PTrace}{X}$ for some $\PTrace \in \mathcal{L}(P)$ and $X \in \mathcal{L}(A_{\neg \varphi})$. Moreover, $\matches{\Comput}{\combine{\PTrace}{X}}$ for some $\Comput \in \Assigns^\omega$. By Lemma \ref{lem:corr2}, we know that $X=\UPredSeq(\Comput)$ and by Lemma \ref{lem:corr1} we know that $\matches{\Comput}{\PTrace}$. By the correctness of $A_\varphi$, we know that $\UPredSeq(\Comput) \lmodels \neg \varphi$, which by Lemma \ref{lem:TSL_LTL} means that $\Comput \models \neg \varphi$. Thus $\Comput$ is a counterexample that proves that $P$ does not satisfy $\varphi$.

    $\Leftarrow$
    Assume that $P$ does not satisfy $\varphi$. Then, there is a trace $\PTrace \in \mathcal{L}(P)$ and a computation $\Comput$ such that $\matches{\Comput}{\PTrace}$ and $\Comput \models \neg \varphi$. This means by Lemma \ref{lem:TSL_LTL} that $\UPredSeq(\Comput) \lmodels \neg \varphi$, so $\UPredSeq(\Comput)$ is accepted by $A_{\neg \varphi}$. Then, $\combine{\PTrace}{\UPredSeq(\Comput)}$ is a trace of $P \BuechiProd A_{\neg \varphi}$. By Lemma \ref{lem:corr3}, $\matches{\widetilde{\Comput}}{\combine{\PTrace}{\UPredSeq(\Comput)}}$, so this is also a feasible trace.
\end{proof}


\subsection{Proof of Theorems \ref{thm:BuechiProdModelCheckingAFH} and \ref{thm:BuechiProdModelCheckingAFH2}} \label{sec:BuechiProd_corr2}
 As the two theorems are dual, it suffices to give the proof for Theorem \ref{thm:BuechiProdModelCheckingAFH}.
 
The proof is analogous to the proof of Theorem \ref{thm:BuechiProdModelChecking}, but we have to deal with multiple traces and thus even more indices now. We give it here for completeness.

Given $n$ program traces $\PTrace_{\pi_1}, \dots \PTrace_{\pi_n}$, we define $\PTrace_j = ({(\PTrace_{\pi_1})_{\pi_1}}_j; {(\PTrace_{\pi_2})_{\pi_2}}_j; \dots {(\PTrace_{\pi_n})_{\pi_n}}_j)$ and $\PTrace = \PTrace_1 \PTrace_2 \dots$. Let $\matches{\Comput_{\pi_1}}{\PTrace_{\pi_1}} \wedge \dots \wedge \matches{\Comput_{\pi_n}}{\PTrace_{\pi_n}}$. Let $\HComput = \ExtComput{\emptyset}{\pi_1}{\Comput_{\pi_1}} \dots \ExtComput{}{\pi_n}{\Comput_{\pi_n}}$. Those computations are extendable to a computation that matches $\combine{\PTrace}{\UPredSeq(\HComput)}$ For every time point $t$, we need to introduce the computation steps that match $\combine{\PTrace_t}{X_t} = \mathit{save\_values};~\PTrace_t;~\mathit{new\_inputs};~\mathit{check\_preds}_{X_t};~ \mathit{check\_updates}_{X_t}$. While executing $\mathit{save\_values}$, the values of the relevant temporary variables are changed as required by the statements $tmp_j := \HFuncTerm{j}$. After the actual statements $\PTrace_t$ are executed, the computation changes to $\HComput_t$, but still with the `old' inputs and extended with values for the temporal variables. Next, when executing $\mathit{new\_inputs}$, we stepwise change the input values to those in $\HComput_t$. Then, the assertions are executed and the computation cannot change anymore. 

In the following, we also need the notion of extending a hyper-assignment: we define $\HAssign[c \mapsto v](c) = v$ and $\HAssign[c \mapsto v](c') = \HAssign(c')$ for $c \neq c'$.

Let $\USet \subseteq \HUpdTerms$ be in the following the set of update terms and $\PredSet \subseteq \HPredTerms$ the predicate terms appearing in the formula $\varphi$.

\begin{definition} \label{def:hadaptedComput}
    Let $\Inputs \times \TraceVs = \{i_1, \dots i_k\}$ be the set of inputs and $\USet = \{\Upd{c_1}{\HFuncTerm{1}}, \dots ,\Upd{c_m}{\HFuncTerm{m}}\}$. Given computations $\Comput_{\pi_1} \dots \Comput_{\pi_n}$, let $\HComput = \ExtComput{\emptyset}{\pi_1}{\PTrace_{\pi_1}} \dots \ExtComput{}{\pi_n}{\PTrace_{\pi_n}}$. We define the \textbf{adapted computation} $\widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})}$.
    \begin{align*}
        \HAssign^{\mathit{tmp}_1}_t &:= \HComput_{t-1} [\mathit{tmp}_1 \mapsto \Eval(\FuncTerm{1},\HComput_{t-1})] \\
        \HAssign^{\mathit{tmp}_j}_t &:= \HAssign^{\mathit{tmp}_{j-1}} [\mathit{tmp}_j \mapsto \Eval(\FuncTerm{j},\HComput_{t-1})] ~~~~~~~~~~~~~~~~~~~\text{for } 1 < j \leq m\\
        \HAssign^{\pi_j}_t &= (\HComput_{t-1}\ExtComput{}{\pi_1}{\Comput_{\pi_1}} \dots \ExtComput{}{\pi_j}{\Comput_{\pi_j}})_t
         [i_1 \mapsto \Comput_{t-1}(i_1),~\dots~,i_k \mapsto \Comput_{t-1}(i_k), \\
         &~~~~\mathit{tmp}_1 \mapsto \Eval(\FuncTerm{1},\HComput_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\FuncTerm{m},\HComput_{t-1})] \\
         \HAssign^{i_1}_t &:= \HAssign_t^{\pi_n} [i_1 \mapsto \HComput_t(i_1)] \\
        \HAssign^{i_j}_t &:= \HAssign^{i_{j-1}} [i_j \mapsto \HComput_t(i_j)] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\text{for } 1 < j \leq k\\
         \widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})^t} &:= \HAssign^{\mathit{tmp}_1}_t \dots \HAssign^{\mathit{tmp}_n}_t ~\HAssign^{\pi_1}_t \dots \HAssign^{\pi_n}_t~\HAssign^{i_1}_t~\dots~\HAssign^{i_k}_t~\HAssign^{i_k}_t~\HAssign^{i_k}_t \\
         \widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})} &:= \widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})^0}~ \widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})^1}\dots 
    \end{align*}
\end{definition}

Note that this is the only possibility to extend the computations $\matches{\Comput_{\pi_1}}{\PTrace_{\pi_1}}, \dots, \matches{\Comput_{\pi_n}}{\PTrace_{\pi_n}}$ to a computation that potentially matches $\combine{\PTrace}{X}$ for any $X$.

We can also define the left inverse of this operation: reducing a computation that matches $\combine{\PTrace}{X}$ to computations that match $\PTrace_{\pi_1}, \dots , \PTrace_{\pi_n}$ as follows.

\begin{definition}
    Let $1 \leq j \leq n, \PTrace \in \Stmt^\omega, X \in \mathcal{P}(\HPredTerms \cup \HUpdTerms)^\omega$ and $\matches{\HComput}{\combine{\PTrace}{X}}$.
    We define the index of the computation step of $(\PTrace_{\pi_{j}})_t$ in $\combine{\PTrace}{X}$
    \begin{align*}
        \iota(t) &:= (|\Inputs \times \TraceVs| + |\USet| + n + 2) \cdot (t+1) - 3
    \end{align*}
    We define the \textbf{reduced computation} $\Comput_{|\pi_j}$.
    \begin{align*}
        \Comput_{|\pi_j} &:= (\Comput_{\iota(0)})_{| (\Inputs \cup \Cells)_{\pi_j}} ~(\Comput_{\iota(1)})_{| (\Inputs \cup \Cells)_{\pi_j}} \dots
    \end{align*}
    where $\HAssign_{| (\Inputs \cup \Cells)_{\pi_j}}$ means restricting the domain of the assignment to the cells and inputs labeled with $\pi_j$, thus excluding the temporal variables $tmp_1, tmp_2 \dots$ and the variables from other traces. Moreover, the cells and inputs are again renamed from $c_{\pi_j}$ to $c$ or $i_{\pi_j}$ to $i$.
\end{definition}

Note that if $\matches{\HComput}{\combine{\PTrace}{X}}$, we also have that $\HComput$ is the adapted computation of $(\HComput_{|\pi_1}, \dots ,\HComput_{|\pi_n})$ as this is the \textit{only} computation that could match $\combine{\PTrace}{X}$ and equals $\Comput_{|\pi_j}$ when restricted to $\pi_j$. 

\begin{lemma} \label{lem:hcorr1}
    If $\matches{\HComput}{\combine{\PTrace}{X}}$ and $\PTrace = ((\PTrace_{\pi_1})_{\pi_1}, \dots ,(\PTrace_{\pi_n})_{\pi_n})$, then $\matches{\HComput_{|\pi_j}}{\PTrace_{\pi_j}}$ for every $1 \leq j \leq n$.
\end{lemma}
\begin{proof}
    We show that $\forall t \in \mathbb{N}. ~\matchest{\HComput_{|\pi_j}}{\PTrace_{\pi_j}}{t}$.

    Recall that $\HComput$ is the adapted computation of $(\HComput_{|\pi_1}, \dots ,\HComput_{|\pi_n})$ .

    \begin{itemize}
        \item Case $\PTrace_{t} = \mathit{assert}(\PredTerm)$ \\
        We know that $\matchest{\HComput}{\combine{\PTrace}{X}}{\iota(t) - |\Inputs \times \TraceVs| - (n-j)}$, and  thus
        \begin{align*}
            &\Eval(\HPredTerm, \HComput_{\iota(t)-|\Inputs \times \TraceVs|-(n-j)-1}) = true~~ \wedge \\ &\forall c \in \Cells^*.~\HComput_{\iota(t)-|\Inputs \times \TraceVs| - (n-j)}(c) = \HComput_{\iota(t)-|\Inputs \times \TraceVs|(n-j)-1}(c)
        \end{align*} 
        Moreover, $(\HComput_{\iota(t)-|\Inputs \times \TraceVs|-(n-j)-1})$ equals $\HAssign^{tmp_m}_t$ if $j=0$ and else $\HAssign^{\pi_{j-1}}_t$, which both equals $(\HComput_{|\pi_j})_{t-1}$ when restricted to the inputs and variables from $\pi_j$. $\PredTerm$ does not contain variables from other traces or temporary variables, thus $\Eval(\PredTerm, (\HComput_{|\pi_j})_{t-1})$ is also true. It remains to show that             
        \begin{align*}
            \forall c \in \Cells.~((\HComput)_{\iota(t-1)})_{|(\Inputs \cup \Cells)_{\pi_j}} (c) = ((\HComput)_{\iota(t)})_{|(\Inputs \cup \Cells)_{\pi_j}} (c)
        \end{align*}
        This is also true as the only cells changed in $\HComput_{\iota(t-1)} \dots \HComput_{\iota(t)-|\Inputs \times \TraceVs|-(n-j)-1}$ and in $\HComput_{\iota(t)-(n-j)-|\Inputs \times \TraceVs|}, \dots \HComput_{\iota(t)}$ are cells from $\Cells^* \backslash \Cells$ or cells from other traces.
        \item The two remaining cases are analogous.
    \end{itemize}
\end{proof}

\newcommand{\longseq}{\UPredSeq(\emptyset \ExtComput{}{\pi_1}{\HComput_{|\pi_1}} \dots \ExtComput{}{\pi_n}{\HComput_{|\pi_n}} )}


\begin{lemma} \label{lem:hcorr2}
    If $\matches{\HComput}{combine(\PTrace, X)}$, then $X = \longseq$ 
\end{lemma}
\begin{proof}
    Set $\HComput' = \emptyset \ExtComput{}{\pi_1}{\HComput_{|\pi_1}} \dots \ExtComput{}{\pi_n}{\HComput_{|\pi_n}}$. We prove $\forall t.~ X_t = \UPredSeq(\HComput')_t$.
    We know that $\matchest{\HComput}{\combine{\PTrace}{X}}{\iota(t)+1}$. The corresponding statement is $check\_preds_{X_t}$. Set $h = \left(\bigwedge_{\PredTerm \in {X_t}} \HPredTerm \wedge \bigwedge_{\HPredTerm \in \PredSet \backslash {X_t}} \neg \PredTerm \right)$. This means that 
    \begin{align*}
        \Eval(h, \HComput_{\iota(t)+1}) = true ~~~\wedge \forall c \in \Cells^*.~\Comput_{\iota(t)+1}(c) = \HComput_{\iota(t)}(c)
    \end{align*}

    Recall that $\HComput_{\iota(t)+1}$ is by Definition \ref{def:hadaptedComput} equal to
    \begin{align*}
        &(\HComput'_{t-1}\ExtComput{}{\pi_1}{\HComput'_{\pi_1}} \dots \ExtComput{}{\pi_j}{\HComput'_{\pi_n}})_t~
         [\mathit{tmp}_1 \mapsto \Eval(\HFuncTerm{1}, \HComput'_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\HFuncTerm{m}, \HComput'_{t-1})] \\
         &=  \HComput'_t~
         [\mathit{tmp}_1 \mapsto \Eval(\HFuncTerm{1}, \HComput'_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\HFuncTerm{m}, \HComput'_{t-1})]
    \end{align*}
    $h$ does not contain the temporal variables, so this implies that $\Eval(h, \HComput'_t) = true$. Therefore, for all $\PredTerm \in P$
    \begin{align*}
        \PredTerm \in \UPredSeq(\HComput')_t \Leftrightarrow t, \HComput' \models \PredTerm \Leftrightarrow \Eval(\PredTerm, \Comput'_t) = true \Leftrightarrow \PredTerm \in {X_t}
    \end{align*} 
    The last equivalence holds by the definition of $h$.

    For the update terms, we know that $\matchest{\Comput}{\combine{\PTrace}{X}}{\iota(t)+2}$. The corresponding statement is $\mathit{check\_updates}_{X_t}$. Set $h=\left( \bigwedge_{\Upd{c_j}{\HFuncTerm{j}} \in \USet}
    \begin{cases}
        c_j = \mathit{tmp}_j &\text{if } \Upd{c_j}{\HFuncTerm{j}} \in X_t\\
        c_j \neq \mathit{tmp}_j &\text{else} 
    \end{cases}        
        \right)$ As before, we know that $\Eval(h, \HComput'_t) = true$. Moreover, we know that for each $j$, $\HComput_{\iota(t)+1} (\mathit{tmp}_j) = \Eval(\HFuncTerm{j},\HComput'_{t-1})$ again by Definition \ref{def:hadaptedComput} Therefore, for every $\Upd{c_j}{\HFuncTerm{j}} \in \USet,$
        \begin{align*}
            \Upd{c_j}{\HFuncTerm{j}} \in \UPredSeq(\HComput')_t &\Leftrightarrow t, \HComput' \models \Upd{c_j}{\HFuncTerm{j}} \\ 
            &\Leftrightarrow \Eval({\HFuncTerm{j}}, \HComput'_{t-1}) = \Eval(c_j, \HComput'_t) \\
            &\Leftrightarrow \Eval(c_j = tmp_j, \HComput'_t) = true \\
            &\Leftrightarrow \Upd{c_j}{\HFuncTerm{j}} \in X_t
        \end{align*}
        The last equivalence is again true by the definition of $h$.
\end{proof}

\begin{lemma} \label{lem:hcorr3}
    If $\matches{\Comput_{\pi_1}}{\PTrace_{\pi_1}} \wedge \dots \wedge \matches{\Comput_{\pi_n}}{\PTrace_{\pi_n}}$, then $\matches{\widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})}}{\combine{\PTrace}{\UPredSeq(\HComput')}$, where $\HComput' = \ExtComput{\emptyset}{\pi_1}{\Comput_{\pi_1}} \dots \ExtComput{}{\pi_n}{\Comput_{\pi_n}}}$
\end{lemma}
\begin{proof}
    Set $\HComput = \widetilde{(\Comput_{\pi_1}, \dots ,\Comput_{\pi_n})}$. We have to show that for all $t$, $\matchest{\HComput}{\combine{\PTrace}{\UPredSeq(\HComput')}}{t}$. This is clear for all time steps except for those of kind $\mathit{check\_preds}$ or $\mathit{check\_updates}$ by the definition of $\HComput$.

    First consider $\mathit{check\_preds}$. We need to show that $\forall t$, $\matchest{\HComput}{\combine{\PTrace}{\UPredSeq(\HComput')}}{\iota(t)+1}$. This boils down to
    \begin{align*}
        \Eval\left( \left(\bigwedge_{\HPredTerm \in {\UPredSeq(\HComput')_t}} \HPredTerm \wedge \bigwedge_{\HPredTerm \in \PredSet \backslash {\UPredSeq(\HComput')_t}} \neg \HPredTerm \right), \HComput_{\iota(t)+1} \right) = true
    \end{align*}

    Recall that $\HComput_{\iota(t)+1}$ is by Definition \ref{def:hadaptedComput} equal to
    \begin{align*}
        &(\HComput'_{t-1}\ExtComput{}{\pi_1}{\HComput'_{\pi_1}} \dots \ExtComput{}{\pi_j}{\HComput'_{\pi_n}})_t~
         [\mathit{tmp}_1 \mapsto \Eval(\HFuncTerm{1},\HComput'_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\HFuncTerm{m}, \HComput_{t-1})] \\
         &= \HComput'_t~ [\mathit{tmp}_1 \mapsto \Eval(\HFuncTerm{1},\HComput'_{t-1}), \dots , \mathit{tmp}_m \mapsto \Eval(\HFuncTerm{m}, \HComput_{t-1})] 
    \end{align*}

    Thus, as the temporary variables are not used in $\HPredTerm$, this is equivalent to
    \begin{align*}
        \forall \HPredTerm \in \PredSet.~\HPredTerm \in \UPredSeq(\Comput')_t \Leftrightarrow \Eval((\HPredTerm), \Comput'_t ) = true
    \end{align*}
    This is true by the definition of $\UPredSeq(\Comput)_t$.

    Now consider $\mathit{check\_updates}$. We need to show that $\forall t$, $\matchest{\HComput}{\combine{\PTrace}{\UPredSeq(\HComput')}}{\iota(t)+2}$. This boils down to
    \begin{align*}
        \Eval\left(\left( \bigwedge_{\Upd{c_j}{\HFuncTerm{j}} \in \USet}
        \begin{cases}
            c_j = \mathit{tmp}_j &\text{if } \Upd{c_j}{\HFuncTerm{j}} \in \UPredSeq(\HComput')_t\\
            c_j \neq \mathit{tmp}_j &\text{else} 
        \end{cases}        
            \right), \HComput_{\iota(t)+2} \right) = true
    \end{align*}
    Which is again equivalent to 
    \begin{align*}
        \forall \Upd{c_j}{\FuncTerm{j}} \in \USet.~ \Eval(c_j = \mathit{tmp}_j, \HComput_{\iota(t)+2}) = true \Leftrightarrow \Upd{c_j}{\FuncTerm{j}} \in \UPredSeq(\HComput')_t
    \end{align*}
    We know that $\HComput_{\iota(t)+2}(\mathit{tmp}_j) = \HComput'_{t-1}(\FuncTerm{j})$. Thus this is equivalent to 
    \begin{align*}
        \forall \Upd{c_j}{\HFuncTerm{j}} \in \USet.~ \Eval(\HFuncTerm{j}, \HComput'_{t-1}) = \HComput'_{t}(c) \Leftrightarrow \Upd{c_j}{\HFuncTerm{j}} \in \UPredSeq(\HComput')_t
    \end{align*}
    Which is again true by the definition of $\UPredSeq(\HComput')_t$.
\end{proof}

Now, we have all the lemmas needed to prove Theorem \ref{thm:BuechiProdModelCheckingAFH}
\begin{proof} (Theorem \ref{thm:BuechiProdModelCheckingAFH}) \\
    $\Rightarrow$
    Assume that $P^n \BuechiProd A_{\neg \varphi}$ has a feasible trace. Then, this is a trace $\combine{\PTrace}{X}$ for some $\PTrace \in \mathcal{L}(P^n)$ and $X \in \mathcal{L}(A_{\neg \varphi})$. We know that $\PTrace_t = ({(\PTrace_{\pi_1})_{\pi_1}}_t; \dots ;{(\PTrace_{\pi_n})_{\pi_n}}_t)$. Moreover, $\matches{\HComput}{\combine{\PTrace}{X}}$ for some $\HComput \in \HAssigns^\omega$. By Lemma \ref{lem:hcorr1}, we know that $\matches{\HComput_{|\pi_1}}{\PTrace_{\pi_1}} \wedge \dots \wedge \matches{\HComput_{|\pi_n}}{\PTrace_{\pi_n}}$. Set $\HComput' = \ExtComput{\emptyset}{\pi_1}{\HComput_{|\pi_1}} \dots \ExtComput{}{\pi_n}{\HComput_{|\pi_n}}$. By Lemma \ref{lem:hcorr2}, we know that $X=\UPredSeq(\HComput')$. By the correctness of $A_\psi$ this means that $\UPredSeq(\HComput') \lmodels \neg \varphi$ which by Lemma \ref{lem:TSL_LTL} means that $\HComput' \models \neg \varphi$. Thus, $\HComput_{|\pi_1} \dots \HComput_{|\pi_n}$ are feasible counterexample traces proving that $\forall \pi_1.~ \dots \forall \pi_n.~ \psi$ does not hold.

    $\Leftarrow$
    Assume that $P$ does not satisfy $\varphi$. Then, there are trace $\PTrace_{\pi_1}, \dots \PTrace_{\pi_n} \in \mathcal{L}(P)$ and computations $\Comput_{\pi_1}, \dots \Comput_{\pi_n}$ such that $\matches{\Comput_{\pi_1}}{\PTrace_{\pi_1}} \wedge \dots \wedge \matches{\Comput_{\pi_n}}{\PTrace_{\pi_n}}$ and \\ $\HComput' = \ExtComput{\emptyset}{\pi_1}{\Comput_{\pi_1}} \dots \ExtComput{}{\pi_n}{\Comput_{\pi_n}} \models \neg \varphi$. This means by Lemma \ref{lem:TSL_LTL} that $\UPredSeq(\HComput') \lmodels \neg \varphi$, so $\UPredSeq(\HComput')$ is accepted by $A_{\neg \varphi}$. Set $\PTrace_t = ({(\PTrace_{\pi_1})_{\pi_1}}_t; \dots ;~{(\PTrace_{\pi_n})_{\pi_n}}_t)$ and $\PTrace = \PTrace_0 \PTrace_1 \dots$. Then, $\combine{\PTrace}{\UPredSeq(\Comput)}$ is a trace of $P \BuechiProd A_{\neg \varphi}$. By Lemma \ref{lem:hcorr3}, $\matches{\widetilde{(\Comput_{\pi_1}, \dots, \Comput_{\pi_n})}}{\combine{\PTrace}{\UPredSeq(\Comput')}}$, so this is also a feasible trace.

\end{proof}

\subsection{Proof of Theorem \ref{thm:corr_AE}} \label{sec:corr_AE}

We now prove Theorem \ref{thm:corr_AE}. To do that, we need the following lemma: recall that for a program execution $\sigma_{\pi}$, $(\sigma_{\pi})_{\pi}$ means renaming every cell $c$ in $\sigma_\pi$ to $c_\pi$ and every input $i$ to $i_\pi$.

\begin{lemma} \label{lem:splittrace}
    Let $\PTrace \in \Stmt^\omega$ be feasible and $\PTrace_t = (((\PTrace_{\pi_1})_{\pi_1})_t, \dots , ((\PTrace_{\pi_n})_{\pi_n})_t )$ for some $\sigma_{\pi_1}, \dots \sigma_{\pi_n}$. Then $\PTrace_{\pi_1}, \dots, \PTrace_{\pi_n}$ are also all feasible.
\end{lemma}
\begin{proof}
    As $\PTrace$ is feasible, we know that $\matches{\HComput}{\PTrace}$ for some $\HComput$. For all $1 \leq j \leq n$, we define $\Comput_{\pi_j}$ by
    \begin{align*}
        (\Comput_{\pi_j})_t &= (\HComput_{t \cdot n + j - 1})_{|(\Inputs \cup \Cells)_{\pi_j}} \\
        \Comput_{\pi_j} &= (\Comput_{\pi_j})_0~(\Comput_{\pi_j})_1 \dots
    \end{align*}
    where $\HAssign_{| (\Inputs \cup \Cells)_{\pi_j}}$ as before means restricting the domain of the assignment to the cells and inputs labeled with $\pi_j$, thus excluding the variables from other traces. Moreover, the cells and inputs are again renamed from $c_{\pi_j}$ to $c$ or $i_{\pi_j}$ to $i$. $t \cdot m + j - 1$ is the index of $(\PTrace_{\pi_j})_t$ in $\PTrace$.
    
    We show that for all time points $t$, $\matchest{\Comput_{\pi_j}}{\PTrace_{\pi_j}}{t}$
    \begin{itemize}
        \item Case $(\Comput_{\pi_j})_t = \mathit{assert}(\PredTerm)$ \\
                We know that $\matchest{\HComput}{\PTrace}{t \cdot m + j - 1}$ and thus 
                \begin{align*}
                    \Eval(\HPredTerm, \HComput_{t \cdot m + j - 1}) = true \wedge \forall c \in \Cells \times \TraceVs.~\HComput_{t \cdot m + j - 1}(c) = \HComput_{t \cdot m + j - 2}.
                \end{align*}
                Moreover $\Eval(\PredTerm, (\Comput_{\pi_j})_t)$ is also true as $\PredTerm$ does not contain variables from other traces. It remains to show that 
                \begin{align*}
                    \forall c \in \Cells.~((\Comput_{\pi_j})_t)(c) = (\Comput_{\pi_j})_{t-1}(c)
                \end{align*}

                This is also true as the only cells changed in $\HComput_{(t-1) \cdot m + j - 1}, \dots \HComput_{t \cdot m + j - 2}$ are cells from other traces.
        \item The remaining two cases are analogous.
    \end{itemize}
\end{proof}

We now prove Theorem \ref{thm:corr_AE}
\begin{proof}
    Assume that $P^m \backslash (P^n \BuechiProd A_\psi)_{k, C(k')}^\forall$ has a feasible trace $\PTrace$ with $\matches{\HComput}{\PTrace}$. By Lemma \ref{lem:splittrace}, this means that $\matches{\Comput_{\pi_1}}{\PTrace_{\pi_1}} \wedge \dots \wedge \matches{\Comput_{\pi_m}}{\PTrace_{\pi_m}}$. It suffices to show that $\emptyset \ExtComput{}{\pi_1}{\Comput_1} \dots \ExtComput{}{\pi_m}{\Comput_m} \nmodels \exists \pi_{m+1}.~ \dots \exists \pi_n.~\psi$ as this implies that $\Comput_1, \dots \Comput_m$ are a counterexample proving that $P$ does not satifsfy $\varphi$.

    Proof by contradiction. Assume that $\emptyset \ExtComput{}{\pi_1}{\Comput_1} \dots \ExtComput{}{\pi_m}{\Comput_m} \models \exists \pi_{m+1}.~ \dots \exists \pi_n.~\psi$. Then, there are traces $\PTrace_{\pi_{m+1}}, \dots \PTrace_{\pi_n}$ and computations $\Comput_{\pi_{m+1}} \dots \Comput_{\pi_n}$ such that $\matches{\Comput_{\pi_{m+1}}}{\PTrace_{\pi_{m+1}}} \wedge \dots \wedge \matches{\Comput_{\pi_n}}{\PTrace_{\pi_n}}$ and $\HComput' = \emptyset \ExtComput{}{\pi_1}{\Comput_{\pi_1}} \dots \ExtComput{}{\pi_n}{\Comput_{\pi_n}} \models \psi$.\\ Set $\PTrace'_t = ({(\PTrace_{\pi_1})_{\pi_1}}_t; \dots ;{(\PTrace_{\pi_n})_{\pi_n}}_t)$ and $\PTrace' = \PTrace'_0~\PTrace'_1 \dots$. Now, by Lemma \ref{lem:TSL_LTL} and the correctness of $A_\psi$, we know that $\UPredSeq(\HComput')$ is accepted by $A_\psi$, thus $\combine{\PTrace'}{ \UPredSeq(\HComput')}$ is accepted by $P^n \BuechiProd A_{\psi}$. Moreover, by Lemma \ref{lem:hcorr2}, we know that $\combine{\PTrace'}{\UPredSeq(\HComput')}$ is also feasible, so it is also $k$-feasible and thus accepted by $(P^n \BuechiProd A_\psi)_k$. Moreover, does not end with an infeasible cycle and is thus also accepted by $(P^n \BuechiProd A_\psi)_{k, C(k')}$  But this means that $\PTrace$ is accepted by $(P^n \BuechiProd A_\psi)^\forall_{k, C(k')}$. and thus not by $P^m \backslash (P^n \BuechiProd A_\psi)^\forall_{k, C(k')}$. Contradiction.
\end{proof}