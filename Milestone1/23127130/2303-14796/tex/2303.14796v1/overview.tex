%\subsubsection{Overview}
%We now elaborate more on our algorithm and the adaptation of the algorithm of~\cite{FairnessModTheory} to our setting. 
Following \cite{SoftwareModelCheckingAutomata}, we represent our system as a symbolic automaton labeled with program statements. 
Not every trace of such an automaton is also a valid program execution: for example, a trace $\mathit{assert}(n = 0)~; n --;~ (\mathit{assert}(n = 0))^\omega$ \footnote{The superscript $\omega$ denotes an infinite repetition of the program statement.} cannot be a program execution, as the second assertion will always fail. Such a trace is called \textit{infeasible}. In contrast, in a feasible trace, all assertions can, in theory, succeed.
As a first step, we tackle TSL model checking (Sec.~\ref{sec:tslMC}) by constructing a program automaton whose feasible accepted traces correspond to program executions that violate the TSL specification. To do so, we adapt the algorithm of~\cite{FairnessModTheory}, which constructs such an automaton for LTL, combining the given program automaton and an automaton for the 
negated specification.
% To finally test whether a feasible trace exists, we apply the partial algorithm of \cite{FairnessModTheory}.

 We then extend this algorithm for HyperTSL(T) formulas without quantifier alternation (Sec.~\ref{sec:altfree}) by applying \textit{self-composition}, a technique commonly used for the verification of hyperproperties \cite{SelfComposition1, SelfComposition2, SelfComposition3}. %The program automaton is composed with itself $n$ times, where $n$ is the number of quantifiers, and a trace of the resulted automaton corresponds to $n$ traces of the original system.

Next, in Sec.~\ref{sec:hyperMC}, we further extend this algorithm to finding counterexamples for $\forall^*\exists^*$-HyperTSL(T) specifications (and, dually, witnesses for $\exists^*\forall^*$ formulas). 
We construct an automaton that {over-approximates} the combinations of program executions that satisfy the existential part of the formula. If some program execution is not included in the over-approximation, this execution is a counterexample proving that the program violates the specification.

More concretely, for a HyperTSL(T) formula $\forall^m\exists^n \psi $, we construct the product of the automaton for $\psi$ and the $n$-fold self-composition of the program automaton. Every feasible trace of this product corresponds to a choice of executions for the variables $\pi_1, \dots, \pi_n$ such that $\psi$ is satisfied. Next, we remove (some) spurious witnesses by removing infeasible traces. We consider two types of infeasibility: \textit{$k$-infeasibility}, that is, a local inconsistency in a trace appearing within $k$ consecutive timesteps; and infeasibility that is not local, and is the result of some \textit{infeasible accepting cycles} in the automaton.
In the next step, we project the automaton to the universally quantified traces, obtaining an over-approximation of the trace combinations satisfying the existential part of the formula.
Finally, all that remains to check is whether the over-approximation includes all combinations of feasible traces.

Lastly, in Sec.~\ref{sec:HyperExamples}, we demonstrate our algorithm for two examples, including generalized noninterference.