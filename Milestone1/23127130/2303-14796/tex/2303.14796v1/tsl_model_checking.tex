\label{infinitestuff}


\section{Büchi Product Programs and TSL Model Checking}\label{sec:tslMC}
We now describe how we model the system and specification as Büchi automata, adapting the automata of~\cite{FairnessModTheory} to the setting of TSL. Then, we introduce our model checking algorithm for TSL(T). 
In Sec~\ref{sec:hyperMC} we build on this algorithm to propose an algorithm for HyperTSL(T) model checking. 

We use a symbolic representation of the system (see, for example,~\cite{SoftwareModelCheckingAutomata}), where transitions are labeled with program statements, and all states are accepting. 


\begin{definition}\label{def:grammar} Let $c \in \Cells, \PredTerm \in \PredTerms$ and $\FuncTerm{} \in \FuncTerms$. We define the set of \emph{(basic) program statements} 
as  
\begin{align*}
    s_0 &::= \mathit{assert}(\PredTerm)~|~c:= \FuncTerm{}~|~c:=* \\
    s &::= s_0~|~s;s
\end{align*}
We call statements of the type $s_0$ \emph{basic program statements}, denoted by $\BStmt$; statements of type $s$ are denoted by $\Stmt$. 
The assignment $c:= *$ means that any value could be assigned to $c$.

%\begin{align*}
 %    &s_0 ::= assert(\PredTerm)~|~c:= \FuncTerm{}~|~c:=* \\
 %&s ~::= s_0~|~s;s
 %\end{align*}
\end{definition}

 % - for example, if $c$ is chosen as a random number. 

A \textit{program automaton} $\aut{P}$ is a 
Büchi automaton with $\Sigma = \Stmt$, that is,
$\aut{P} = (\Stmt, Q, q_0, \delta, F)$ and  $\delta \subseteq Q \times \Stmt \times Q$. 
%where $Q$ is a set of program locations; $q_0 \in Q$ is the initial location; $\delta \subseteq Q \times \Stmt \times Q$ is the transition relation; and $F \subseteq Q$ is the set of accepting states. 
When modeling the system we only need basic statements, thus we have $\Stmt = \BStmt$; and $F = Q$ as all states are accepting. See Fig.~\ref{fig:first_system_example} for  an illustration.

Using a program automaton, one can model \verb|if| statements, \verb|while| loops, and non-deterministic choices. However, not every trace of the program automaton corresponds to a program execution. For example, the trace $(n := \mathit{input}_1);\mathit{assert} (n > 0);\mathit{assert}(n < 0);~\mathit{assert}(true)^\omega$ does not -- the second assertion will always fail. Such a trace is called \textit{infeasible}. 
We call a trace \textit{feasible} if it corresponds to a program execution where all the assertions may succeed. We now define this formally.

\begin{definition} \label{def:matches}
    A computation $\Comput$ \emph{matches} a trace $\PTrace \in \BStmt^\omega$ at time point $t$, denoted by $\matchest{\Comput}{\PTrace}{t}$, if the following holds:
    \begin{align*}
        % \begin{cases}
            &\text{if } \PTrace_t = \mathit{assert}(\tau_P):&& \Eval(\PredTerm, \Comput_{t-1}) = true ~\text{ and }~ \forall c \in \Cells.~\Comput_t(c) = \Comput_{t-1}(c)  \\
            &\text{if }\PTrace_t = c:= \FuncTerm{}:&& \Eval(\FuncTerm{}, \Comput_{t-1}) = \Comput_t(c)  ~\text{ and }~ \forall c' \in \Cells \backslash \{c\}.~\Comput_t(c') = \Comput_{t-1}(c')  \\
            &\text{if } \PTrace_t = c := *: && \forall c \in \Cells\backslash\{c\}.~\Comput_t(c) = \Comput_{t-1}(c)
        % \end{cases}
    \end{align*}
    where $\Comput_{-1}$ is the initial assignment.
    A computation $\Comput$ matches a trace $\PTrace \in \BStmt^\omega$, denoted by $\matches{\Comput}{\PTrace}$, if $\forall t \in \mathbb{N}.~\matchest{\Comput}{\PTrace}{t}$.

\end{definition}

\begin{definition}
    A program automaton $\aut{P}$ over $\BStmt$ satisfies a TSL(T)-formula $\varphi$, if for all traces $\PTrace$ of $P$ we have
 $   \forall \Comput \in \Assigns^\omega.~\matches{\Comput}{\PTrace} \Rightarrow \Comput \models \varphi$.
\end{definition}

We now present an algorithm to check whether a program automaton $\aut{P}$ satisfies a TSL(T) formula. It is an adaption of the automaton-based LTL software model checking approach by~\cite{FairnessModTheory}, where the basic idea is to first translate the negated specification $\varphi$ into an automaton $\aut{A}_{\neg \varphi}$, and then combine $\aut{A}_{\neg \varphi}$ and $\aut{P}$ to a new automaton, namely the \textit{Büchi program product}. The program satisfies the specification iff the Büchi program product accepts no feasible trace.

In \cite{FairnessModTheory}, the Büchi program product is constructed similarly to the standard product automata construction. To ensure that the result is again a program automaton, the transitions are not labeled with pairs $(s, \edgel) \in \BStmt \times 2^{AP}$, but with the program statement $(s;~ \mathit{assert}(\edgel))$. A feasible accepted trace of the Büchi program product then corresponds to a counterexample proving that the program violates the specification. In the following, we discuss how we adapt the construction of the Büchi program product for TSL(T) such that this property -- a feasible trace corresponds to a counterexample -- remains true for TSL(T). %Moreover, we want to construct the TSL Büchi program product in such a way that we can use the same algorithm as in \cite{FairnessModTheory} for testing if there is a feasible accepted trace.

Let $\varphi$ be a TSL(T) specification. 
For the construction of $\aut{A}_{\neg \varphi}$, we treat all update and predicate terms as atomic propositions, resulting in an LTL formula $\neg\varphi_{\textit{LTL}}$, which is translated to a Büchi automaton.\footnote{For the translation of LTL formulas to Büchi automata, see, for example,~\cite{LTL_Buechi, LTL_Buechi2, LTL_Buechi_Tut}.} 
 For our version of the Büchi program product, we need to merge a transition label $s$ from $\aut{P}$
 with a transition label $\edgel$ from $\aut{A}_{\neg\varphi_{\textit{LTL}}}$ into a single program statement such that the assertion of the combined statement succeeds iff $\edgel$ holds for the statement $s$. Note that $\edgel$ is a set of update and predicate terms. For the update terms $\Upd{c}{\FuncTerm{}}$ we cannot just use an assertion to check if they are true, as we need to `save' the value of $\FuncTerm{}$ before the statement $s$ is executed.

Our setting differs from~\cite{FairnessModTheory} also in the fact that their program statements~do not reason over input streams. We model the behavior of input streams by using fresh memory cells that are assigned a new value at every time step.  
In the following, we define a function $\mathit{combine} $ that combines a program statement $s$ and a transition label $\edgel$ to a new program statement as described above.
%Now, we combine $A_{\neg \varphi}$ with the program automaton to create the Büchi program product, whose feasible traces correspond to feasible traces of the program automaton that do not satisfy the TSL formula. The construction is similar to that of a product automaton, but is defined in such a way that the Büchi program product is again a program automaton. To achieve that, 
\begin{definition}
Let $\USet = \{\Upd{c_1}{\FuncTerm{1}}, \dots, \Upd{c_n}{\FuncTerm{n}}\}$ be the set of update terms appearing in $\varphi$, let $\PredSet$ be the set of predicate terms appearing in $\varphi$. Let $\edgel \subseteq (\USet \cup \PredSet)$ be a transition label of $\aut{A}_{\neg \varphi}$.  Let $(tmp_j)_{j \in \mathbb{N}}$ be a family of fresh cells. Let $\Inputs = \{i_1, \dots i_m \}$. We define the function $\mathit{combine} : \Stmt \times \mathcal{P}(\PredTerms \cup \UpdTerms) \rightarrow \Stmt$ as follows. The result of $\combine{s}{\edgel}$ is composed of the program statements in $\mathit{save\_values}_\edgel, s, \mathit{new\_inputs}, \mathit{check\_preds}_\edgel$ and $\mathit{check\_updates}_\edgel$. Then we have: 
\begin{align*}
    \mathit{save\_values} &:= \mathit{tmp}_1 := \FuncTerm{1};~\dots ;\mathit{tmp}_n := \FuncTerm{n} \\
    \mathit{new\_inputs} &:= i_1 := *;~\dots~; i_m := *\\
    \mathit{check\_preds}_\edgel &:= assert \left(\bigwedge_{\PredTerm \in \edgel} \PredTerm \wedge \bigwedge_{\PredTerm \in \PredSet \backslash \edgel} \neg \PredTerm \right) \\
    \mathit{check\_updates}_\edgel &:= assert \left( \bigwedge_{\Upd{c_j}{\FuncTerm{j}} \in \USet}
    \begin{cases}
        c_j = \mathit{tmp}_j &\text{if } \Upd{c_j}{\FuncTerm{j}} \in \edgel\\
        c_j \neq \mathit{tmp}_j &\text{else} 
    \end{cases}        
        \right) \\
    \combine{s}{\edgel} &:= \mathit{save\_values};~s;~\mathit{new\_inputs};~\mathit{check\_preds}_\edgel;~\mathit{check\_updates}_\edgel
\end{align*}
\end{definition}

We can extend this definition to combining traces instead of single transition labels. 
%a program trace and a predicate trace by applying it per timepoint. 
This leads to a function $\mathit{combine} : \Stmt^\omega \times \mathcal{P}(\PredTerms \cup \UpdTerms)^\omega \rightarrow \Stmt^\omega$.
Note that the result of $\mathit{combine}$ is again a program statement in $\Stmt$ (or a trace $\Stmt^\omega$) over the new set of cells $\Cells \cup \Inputs \cup (tmp_j)_{j \in \mathbb{N}}$, which we call $\Cells^*$.

\begin{example}
    Let $\Inputs = \{i\}$. Then the result of $\combine{n := 42}{ \{ \Upd{n}{n + 7}, n > 0\}} $ is $\mathit{tmp}_0 := n + 7;~n := 42;~i := *;~ \mathit{assert} (n > 0);~ \mathit{assert} (n = \mathit{tmp}_0)$.
\end{example}

As $\mathit{combine}$ leads to composed program statements, we now need to extend the definition of feasibility to all traces. To do so, we define a function $\mathit{flatten}: \Stmt^\omega \rightarrow {\Stmt_0}^\omega$ that takes a sequence of program statements and transforms it into a sequence of basic program statements by converting a composed program statement into multiple basic program statements.

\begin{definition}
    A trace $\PTrace \in \Stmt^\omega$ \emph{matches} a computation $\Comput$, denoted by $\matches{\Comput}{\PTrace}$ if $\matches{\Comput}{\flatten{\PTrace}}$.
    A trace $\PTrace$ is \emph{feasible} if there is a computation $\Comput$ such that $\matches{\Comput}{\PTrace}$.
\end{definition}

\begin{definition}{\textbf{(Combined Product)}} 
    Let $\aut{P} = (Stmt, Q, q_0, \delta, Q)$ be a program automaton and $\aut{A} = (\mathcal{P}(\PredTerms \cup \UpdTerms), Q', q_0', \delta',F')$ be a Büchi automaton (for example, the automaton $\aut{A}_{\neg \varphi_{LTL}}$). The combined product $\aut{P} \BuechiProd \aut{A}$ is an automaton $\aut{B} = (Stmt, Q \times Q', (q_0, q_0'), \delta_B, F_{B})$, where 
    \begin{align*}
        F_{B} &= \{(q, q') \mid q \in Q \wedge q' \in F'\} \\
        \delta_B &= \{((p, q), \combine{s}{\edgel}, (p', q'))~|~(p, s, p') \in \delta \wedge (q, \edgel, q') \in \delta'\}
    \end{align*}
\begin{comment}  
\begin{itemize}
    \item $\delta_B = \{((p, q), \combine{s}{\edgel}, (p', q'))~|~(p, s, p') \in \delta \wedge (q, \edgel, q') \in \delta'\}$, and
    \item $ F_{B} = \{(q, q') \mid q \in Q \wedge q' \in F'\}$
\end{itemize}
\end{comment}
\end{definition}

\begin{theorem} \label{thm:BuechiProdModelChecking}
    Let $\aut{P}$ be a program automaton over $\BStmt$. Let $\varphi$ be a TSL(T) formula. Then $\aut{P}$ satisfies $\varphi$ if and only if $\aut{P} \BuechiProd \aut{A}_{\neg \varphi_{LTL}}$ has no feasible trace.
\end{theorem}

\begin{proof}[sketch]
    If $\matches{\Comput}{\sigma}$ is a counterexample, we can construct a computation $\tilde\Comput$ that matches the corresponding combined trace in $\aut{P} \BuechiProd \aut{A}_{\neg \varphi_{LTL}}$, and vice versa. The formal construction is given in App.~\ref{sec:buechi_corr}. 
\end{proof}


%The main idea of the proof is a construction that, given a computation that matches a program trace and violates $\varphi$, constructs a computation matching the combined trace and vice versa. For more details, see App. \ref{sec:buechi_corr}.

We can now apply Thm. \ref{thm:BuechiProdModelChecking} to solve the model checking problem by testing whether $\aut{P} \BuechiProd \aut{A}_{\neg \varphi_{LTL}}$ does not accept any feasible trace, using the feasibility check in~\cite{FairnessModTheory} as a black box. 
%After generating the combined product, we can use the algorithm of~\cite{FairnessModTheory}, which tests if a feasible trace exists. 
The algorithm of~\cite{FairnessModTheory} is based on counterexample-guided abstraction refinement (CEGAR \cite{CEGAR}). Accepted traces are checked for feasibility.  
%when a trace that is accepted by the automaton is found, the trace is checked for feasibility. 
First, finite prefixes of the trace are checked using an SMT-solver. If they are feasible, a ranking function synthesizer is used to check whether the whole trace eventually terminates. If the trace is feasible, it serves as a counterexample. If not, the automaton is refined such that it now does not include the spurious counterexample trace anymore, and the process is repeated. For more details, we refer to \cite{FairnessModTheory}. 
The limitations of SMT-solvers and ranking function synthesizers also limit the functions and predicates that can be used in both the program and in the TSL(T) formula. 


\section{HyperTSL(T) Model Checking}
We now turn to the model checking problem of HyperTSL(T). We start with alternation-free formulas and continue with $\forall^*\exists^*$ formulas. 

\subsection{Alternation-free HyperTSL(T)}\label{sec:altfree}

In this section, we apply the technique of self-composition to extend the algorithm of Sec.~\ref{sec:tslMC} to alternation-free HyperTSL(T).
%, similarily to Section \ref{sec:FiniteHyper}, but now for a program automaton. 
%Self-composition is a technique commonly used for the verification of hyperproperties \cite{SelfComposition1, SelfComposition2, SelfComposition3}.
%\subsection{The Algorithm}
First, we define what it means for a program automaton to satisfy a HyperTSL(T) formula.

\begin{definition}
    Let $\aut{P}$ be a program automaton over $\BStmt$, let $\varphi$ be a HyperTSL(T) formula and let $Z=\{\Comput \in \Assigns^\omega ~|~ \exists \PTrace.~\matches{\Comput}{\PTrace} \text{ and } \PTrace \text{ is a trace of }\aut{P} \}$. 
    We say that $\aut{P}$ \emph{satisfies} $\varphi$ if $Z \models \varphi$.
\end{definition}

\begin{definition}
    Let $\aut{P} = (\Stmt, Q, q_0, \delta, Q)$ be a program automaton. The \emph{$n$-fold self-composition} of $\aut{P}$ is $\aut{P}^n = (\Stmt', Q^n, q_0^n, \delta^n, Q^n)$, where $\Stmt'$ are program statements over the set of inputs $\Inputs \times \TraceVs$ and the set of cells $\Cells \times \TraceVs$ and where $Q^n = Q \times \dots \times Q$,  $q_0^n = (q_0, \dots , q_0)$ and
    \begin{align*}
        \delta^n = &\{((q_1, \dots, q_n), ((s_1)_{\pi_1}; \dots; (s_n)_{\pi_n}), (q_1', \dots, q_n')) \\
        & \quad \mid \forall 1 \leq i \leq n.~ (q_i, s_i, q_i') \in~\delta\}
    \end{align*}
where $(s)_{\pi}$ renames every cell $c$ used in $s$ to $c_{\pi}$ and every input $i$ to $i_{\pi}$.
\end{definition}

\begin{theorem} \label{thm:BuechiProdModelCheckingAFH}
    A program automaton $\aut{P}$ over $\BStmt$ satisfies a universal HyperTSL(T) formula $\varphi = \forall \pi_1.~ \dots \forall \pi_n.~\psi$ iff $\aut{P}^n \BuechiProd \aut{A}_{\neg \psi_{LTL}}$ has no feasible trace.
\end{theorem}

\begin{theorem} \label{thm:BuechiProdModelCheckingAFH2}
    A program automaton $P$ over $\BStmt$ satisfies an existential HyperTSL(T) formula $\varphi = \exists \pi_1.~ \dots \exists \pi_n.~\psi$ iff $\aut{P}^n \BuechiProd \aut{A}_{\psi_{LTL}}$ has some feasible trace.
\end{theorem}

\noindent The proofs of are analogous to the proof of Thm.~\ref{thm:BuechiProdModelChecking} and are provided in~App.~\ref{sec:BuechiProd_corr2}.