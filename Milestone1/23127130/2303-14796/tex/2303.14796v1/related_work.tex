\subsubsection{Related Work}
Temporal stream logic extends linear temporal logic \cite{LTL} and was originally designed for synthesis \cite{TSL}. For synthesis, the logic has been successfully applied to synthesize the FPGA game `Syntroids' \cite{Syntroids}, and to synthesize smart contracts \cite{TSLSmartContracts}. To advance smart contract synthesis, TSL has been extended to HyperTSL in \cite{HyperTSL}. %, thereby adding the possibility to relate multiple program executions. 
The above works use a version TSL that leaves functions and predicates uninterpreted. While this choice is very well suited for the purpose of synthesis, for model checking it makes more sense to use the interpretation of the program at hand. % having interpreted predicates is more desirable for other purposes like model checking. 
TSL was extended with theories in~\cite{TSLDec}, which also analyzed the satisfiability problem of the logic. %Our definition differs slightly from theirs: Finkbeiner et al. define the satisfaction of an update term by syntactic comparison of the current program statement and the update term. Thus, for example, the program statement $c := c + 1$ would satisfy the update term $\Upd{c}{c+1}$ while the statement $c := c + 2 - 1$ would not. In model checking, we usually do not want to reason about the syntax of a program, thus in this thesis, we interpret update terms based on the current and the previous value assignment, as done in \cite{TSL(T)}.
Neither TSL nor HyperTSL model checking has been studied so far (with or without interpreted theories).
%As TSL can encode programs, a satisfiability checker can also be used for model checking. However, an algorithm explicitly designed for model checking is likely to be more efficient. The reason for that is that encoding the program in the formula and then translating the formula to an automaton already leads to an automaton with a size exponential in the size of the program. \\

For LTL, the model checking problem for infinite-state models has been extensively studied, examples are~\cite{L2SIA-WFR, IC3, IC3SoftwareModelChecking, FairnessModTheory, DBLP:journals/jar/FrenkelGS19}.
Our work builds on the automata-based LTL software model checking algorithm from \cite{FairnessModTheory}.
There are also various algorithms for verifying universal hyperproperties on programs, for example, algorithms based on type theory \cite{RelationalCorrectnessProofs, RelationalCorrectnessProofs2}.
Major related work is \cite{RavensPaper}, which (in contrast to our approach) requires on predicate abstractions to model check software against $\forall^*\exists^*$ HyperLTL specifications.
They can also handle asynchronous hyperproperties, which is currently beyond our scope.
Another proposal for the verification of $\forall\exists$ hyperproperties on software is~\cite{FunctionalHyperproperties}. Here, generalized constrained horn clauses are used to verify functional specifications. The approach is not applicable to reactive, non-terminating programs.
Recently, it was also proposed to apply model checkers for TLA (a logic capable of expressing software systems as well as their properties) to verify $\forall^*\exists^*$ hyperproperties~\cite{DBLP:conf/csfw/LamportS21}.

Beyond the scope of software model checking, the verification of hyperproperties has been studied for various system models and classes of hyperproperties.
There exist model checking algorithms for $\omega$-regular properties~\cite{HyperLTLModelChecking,DBLP:conf/vmcai/Finkbeiner21} and asynchronous hyperproperties~\cite{DBLP:conf/cav/BaumeisterCBFS21, DBLP:conf/concur/BozzelliPS22} in finite-state Kripke structures, as well as timed systems~\cite{DBLP:conf/time/HoZ019}, real-valued~\cite{DBLP:conf/memocode/NguyenKJDJ17} and probabilistic hyperproperties~\cite{DBLP:conf/spin/AroraHLLP22,DBLP:conf/atva/DimitrovaFT20,DBLP:conf/fm/DobeABB21} (some of which study combinations of the above).

% (e.g., finite-state Kripke structures~\cite{}, timed systems~\cite{DBLP:conf/time/HoZ019}, or real-valued systems~\cite{}) and classes of hyperproperties (e.g., probabilistic~\cite{} or asynchronous properties~\cite{}).

% Model checking hyperproperties in the context of timed or real-valued systems poses similar challenges as software model checking since the underlying system is infinite as well~\cite{DBLP:conf/spin/AroraHLLP22,DBLP:conf/time/HoZ019,DBLP:conf/memocode/NguyenKJDJ17}.
% Decidability for $\forall^*\exists^*$ properties
% % have hardly been studied in such settings as their model checking problem is usually undecidable in general.
% % Decidability has been obtained for 
% % Here, solutions for $\forall^*\exists^*$ properties mostly focused on 
% has mostly been obtained by determining subproblems for which finite-state (i.e., complementation-based) model checking algorithms become applicable, e.g., by restricting the timing behavior in the model~\cite{DBLP:conf/time/HoZ019}.

% The challenge of model checking hyperproperties in the presence of an infinite state space also arises when arguing over real-time systems. The problem becomes quickly undecidable ~\cite{}
 
 %However, this algorithm relies on a given abstraction and does not specify how to check the result for feasibility or refine the abstraction. Thus, it can only be applied for software model checking if a suitable abstraction of the program is available. Our approach, on the other hand, handles infeasible traces and refines the symbolic representation while trying to prove correctness. 

 %For LTL and HyperLTL, the model checking problem has been extensively studied both on finite and infinite-state models \cite{HyperLTLModelChecking, IC3, VerifyingHyperliveness, RavensPaper, IC3SoftwareModelChecking, L2SIA-WFR, FairnessModTheory, DBLP:journals/jar/FrenkelGS19}. %In this thesis, we rely on the fact that TSL extends LTL in order to extend LTL model-checking algorithms to TSL. 

	%already very useful, however, there is no known algorithm for model checking yet. Thus, we will first discuss known work related to TSL, and then present examples for LTL- model checking algorithms that are especially relevant for this thesis.

%	\textbf{Finite-State Model Checking.} For a finite-state system, the model checking problem for LTL is well-known to be decidable. The classical approach is based on Büchi-automata: the negated property is translated into an automaton \cite{LTL_Buechi, LTL_Buechi2, LTL_Buechi_Tut}, then it is examined whether the intersection of the language of the automaton and the traces of the model is empty. This approach was adapted for hyperproperties, developing model checking algorithms for HyperLTL \cite{HyperLTL, HyperLTLModelChecking, VerifyingHyperliveness}. We show in Chapter \ref{finitestuff} that for a finite-state system, (Hyper)TSL model checking is reducible to (Hyper)LTL model checking. Moreover, the LTL to Büchi automaton translation is used as the basis for all TSL model checking algorithms in this thesis. %The HyperLTL model checking algorithms from \cite{HyperLTL} and \cite{HyperLTLModelChecking} however, if the formula has quantifier alternations, involve the computationally expensive complementation of the system that is not feasible in practice. Therefore, a game-based semi-algorithm has been developed \cite{VerifyingHyperliveness}, that does not involve complementation but might not always succeed. 
	
 %	\textbf{Self-Compositon.} Self-composition is a technique often used for the verification of hyperproperties, both in finite and infinite-state systems \cite{SelfComposition1, SelfComposition2, SelfComposition3}, exploiting the fact that the model checking problem for universal or existential hyperproperties can be reduced to a simple model checking problem in the composed system -- each trace of the composed system corresponds to an interleaving of multiple traces in the original system. We use self-composition both for finite and infinite-state systems in Chapters \ref{finitestuff} and \ref{infinitestuff}.

	%\textbf{Software Model Checking.} The software model checking problem is already undecidable for LTL \cite{LTLDec}. There are many approaches for partially solving the problem, like semi-algorithms that might diverge or return "unknown" if they can not determine the solution \cite{FairnessModTheory, IC3SoftwareModelChecking, L2SIA-WFR, VerificationAsProgramAnalysis}. Most of these approaches use counterexample guided abstraction refinement (CEGAR) \cite{CEGAR}. The program is first abstracted to a finite-state model in a sound but incomplete manner, for example as a Büchi automaton, having program statements as its alphabet \cite{SoftwareModelCheckingAutomata} or based on automatically inferred predicates \cite{PredicateAbstraction}. Then, if in the abstraction an execution is found that does not fulfill the property, this execution is checked for \textit{feasibility}, i.e. it is examined whether it corresponds to an execution of the original system. If not, the abstraction is refined. The problem of determining whether a given execution is feasible also is undecidable. In general, the construction of a ranking function is necessary - a proof that such a sequence must eventually terminate. Many algorithms have been developed for termination-proving \cite{Termination1, Termination2, Termination3, Termination4, Termination5}. They are often able to prove or disprove termination despite the general undecidability of the problem, but they are still very inefficient. For tackling this issue, the automata-based LTL software model checking algorithm from \cite{FairnessModTheory}, which is the algorithm we extend for (Hyper)TSL in this thesis, exploits the fact that proving the infeasibility of a finite prefix of the sequence is mostly easier - first, some prefixes of the sequence are checked for feasibility by using SMT-solvers, then, only if they are feasible, a ranking function is synthesized.

	%However, there exist more recent approaches for LTL software model checking that are even more successful in practice. Many of them are based on the observation that model checking algorithms for safety properties are already well-studied and work well in practice. The most known algorithm is called \verb|IC3| \cite{IC3} and has been extended for software model checking \cite{IC3SoftwareModelChecking}. Reducing the model checking problem of a liveness property to that of a safety propery in another system leads to good model checking results \cite{IC3SoftwareModelChecking, LivenessToSafety_firstorder, L2SIA-WFR}. This approach is called \textit{liveness-to-safety}. It would be interesting to examine whether such an approach can also be extended to TSL.

	%The model used does not have to be a program. It can also be described using \textit{Symbolic Transition Systems}, where the transition relation is described as a formula. A finite abstraction of the program can then be defined using \textit{Predicate Abstraction}\cite{PredicateAbstraction}, where the description of an abstract state space with a finite set of predicates makes algorithms for finite model checking applicable. In \cite{L2SIA-WFR}, this approach is combined with the liveness-to-safety translation. An initial predicate abstraction is iteratively refined using a CEGAR-loop, by checking whether the abstract counterexample corresponds to a real counterexample, and interpolating new predicates if not. By also including ranking function synthesis in this step, the algorithm is further enhanced.

	%Another algorithm proposed in \cite{VerificationAsProgramAnalysis} generates a program that encodes the search for a proof for the LTL property. The model checking is then done by any algorithm for program analysis, examining whether the generated program will terminate.

	