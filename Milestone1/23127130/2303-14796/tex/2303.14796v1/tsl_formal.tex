\label{ch:TSL}

%\section{(Hyper-) Temporal Stream Logic + Theories}
\subsection{Temporal Stream Logic Modulo Theories TSL(T)}\label{prelim:tsl}
Temporal Stream Logic (TSL) \cite{TSL} extends Linear Temporal Logic (LTL) \cite{LTL} 
by replacing Boolean atomic propositions with predicates over memory cells and inputs, and with \textit{update terms} that specify how the value of a cell should change. 

We present the formal definition of TSL modulo theories -- TSL(T), based on the definition of~\cite{TSLDec}, which extends the definition~\cite{TSL}. The definition we present is due to~\cite{TSL(T)} and it slightly differs from the definition of~\cite{TSLDec}; The satisfaction of an update term is not defined by syntactic comparison, but relative to the current and previous values of cells and inputs. This definition suites the setting of model checking, where a concrete model is given. 


TSL(T) is defined based on a set of \textit{values} $\Values$ with $\mathit{true}, \mathit{false}\in \Values$, a set of inputs $\Inputs$ and a set of memory cells $\Cells$.  Update terms and predicates are interpreted with respect to a given theory. A \emph{theory} is a tuple $(\FuncSymbs, \FEval)$, where $\FuncSymbs$ is a set of function symbols; $\FuncSymbs_n$ is the set of functions of arity $n$; %, each one with an arity $n$; 
and $\FEval: \left( \bigcup_{n\in\mathbb{N}} \FuncSymbs_n \times \Values^n \right) \rightarrow \Values$ is the interpretation function, evaluating a function with arity $n$.
For our purposes, we assume that every theory $(\FuncTerms, \FEval)$ contains at least $\{=, \vee, \neg\}$ with their usual interpretations. 
%the equals-predicate, disjunction and negation. 
% Next, we formally present how function terms, predicate terms and how TSL(T) formulas are constructed using function symbols, cells and inputs

A \emph{function term} $\FuncTerm{}$ is defined by the grammar
    \begin{align*}
       \FuncTerm{} ::= c~|~i~|~f (\FuncTerm{},~\FuncTerm{},~\dots~\FuncTerm{})
   \end{align*}
    where $c \in \Cells, i \in \Inputs, f \in \FuncSymbs$, and the number of elements in $f$ matches its arity. An \emph{assignment} $\Assign : (\Inputs \cup \Cells) \rightarrow \Values$ is a function assigning values to inputs and cells. We denote the set of all assignments by $\Assigns$.
Given a concrete assignment, we can compute the value of a function term.

The \emph{evaluation function} $\Eval: \FuncTerms \times \Assigns \rightarrow \Values$ is defined as
% $\Eval(c, \Assign) =  \Assign(c)$ for $c \in \Cells$;  $\Eval(i, \Assign) =  \Assign(i)$ for $i \in \Cells$; and for $ f \in \mathbb{F}$ we have
    \begin{align*}
       \Eval(c, \Assign) &=  \Assign(c) &&\text{for } c \in \Cells \\
       \Eval(i, \Assign) &= \Assign(i) &&\text{for } i \in \Inputs \\
     \Eval(f~(\FuncTerm{1}, \FuncTerm{2}, \dots ,\FuncTerm{n}), a) &= \FEval(f, (\Eval(\FuncTerm{1}), \Eval(\FuncTerm{2}), \dots , \Eval(\FuncTerm{n}) )) && \text{for } f \in \mathbb{F}      
    \end{align*}

A \emph{predicate term} $\PredTerm$ is a function term only evaluating to \emph{true} or \emph{false}.
    %\vspace{-0.3cm}
    %\begin{align*}
    %\forall \Assign \in \Assigns.~ \Eval(\PredTerm, \Assign) = true \vee \Eval(\PredTerm, \Assign) = %false
    %\end{align*}
    We denote the set of all predicate terms by $\PredTerms$.
    
 For $c \in \Cells$ and $\FuncTerm{} \in \FuncTerms$, $\Upd{c}{\FuncTerm{}}$ is called an \emph{update term}.
 Intuitively, the update term $\Upd{c}{\FuncTerm{}}$ states that $c$ should be updated to the value of $\FuncTerm{}$. If in the previous time step $\FuncTerm{}$ evaluated to $v \in \Values$, then in the current time step $c$ should have value $v$. The set of all update terms is $\UpdTerms$.
TSL formulas are constructed as follows, for 
$c \in \Cells, \PredTerm \in \PredTerms, \FuncTerm{} \in\FuncTerms$. %A TSL(T) formula is defined by the grammar:
$$\varphi ::= \PredTerm~|~\Upd{c}{\FuncTerm{}}~|~\neg \varphi~|~\varphi\wedge\varphi~|~\LTLnext \varphi~|~\varphi\LTLuntil\varphi~$$
The usual operators $\vee, \LTLeventually$ (``eventually"), and $\LTLglobally$ (``globally") can be derived using the equations
$\varphi \vee \psi = \neg (\neg \varphi \wedge \neg \psi),~\LTLeventually \varphi = \mathit{true}\,\LTLuntil\varphi$ and $\LTLglobally \varphi = \neg \LTLeventually \neg \varphi$. 

Assume a fixed initial variable assignment $\Comput_{-1}$ (e.g., setting all values to zero). The satisfaction of a TSL(T) formula with respect to a \textit{computation} $\Comput \in \Assigns^\omega$ and a time point $t$ is defined as follows, where we define $\Comput \models \varphi$ as $0, \Comput \models \varphi$. 
\begin{align*}
    &t, \Comput \models \PredTerm &&\Leftrightarrow \Eval(\PredTerm,\Comput_t) = \mathit{true} \\
    &t, \Comput \models \Upd{c}{\FuncTerm{}} &&\Leftrightarrow \Eval(\FuncTerm{}, \Comput_{t-1}) = \Comput_t(c) \\
    &t, \Comput \models \neg \varphi &&\Leftrightarrow \neg (t, \Comput \models \varphi) \\
    &t, \Comput \models \varphi \wedge \psi &&\Leftrightarrow t, \Comput \models \varphi \text{ and } t, \Comput \models \psi \\
    &t, \Comput \models \LTLnext \varphi &&\Leftrightarrow t + 1, \Comput \models \varphi \\
    &t, \Comput \models \varphi\LTLuntil\psi &&\Leftrightarrow \exists t' \geq t.~ t', \Comput \models \psi \text{ and } \forall  t \leq t'' < t'.~ t'', \Comput \models \varphi
\end{align*}


\section{HyperTSL Modulo Theories} \label{sec:HyperTSL} 
In this section, we introduce HyperTSL(T), HyperTSL with theories, which enables us to interpret predicates and functions depending on the program at hand.
In~\cite{HyperTSL}, two versions of HyperTSL are introduced: HyperTSL and HyperTSL$_{rel}$. The former is a conservative extension of TSL to hyperproperties, meaning that predicates only reason about a single trace.
In HyperTSL$_{rel}$, predicates may relate multiple traces, which opens the door to expressing properties like noninterference in infinite domains.
% which does not allow relating multiple traces within one predicate; and HyperTSL$_{rel}$, which allowes it. Many important security properties, noninterference among them, are only expressible using HyperTSL$_{rel}$. %Nevertheless, the authors of \cite{HyperTSL} focused on the more restrictive version to be able to handle the synthesis problem. 
Here, we build on HyperTSL$_{rel}$, allowing, in addition,  update terms ranging over multiple traces. %(and not only predicate terms). %as this version is more suitable for model checking. 
 Furthermore, we extend the originally uninterpreted functions and predicates with an interpretation over theories. We denote this logic by HyperTSL(T).
 
The syntax of HyperTSL(T) is that of TSL(T), with the addition that cells and inputs are now each assigned to a trace variable that represents a computation. For example, $c_{\pi}$ now refers to the memory cell $c$ in the computation represented by the trace $\pi$. Formally, let $\TraceVs$ be a set of trace variables. We define a \textit{hyper-function term} $\HFuncTerm{} \in \HFuncTerms$ as a function term using $(\Inputs \times \TraceVs)$ as the set of inputs and $(\Cells \times \TraceVs)$ as the set of cells.
\begin{definition}
    A \emph{hyper-function term} $\HFuncTerm{}$ is defined by the  grammar 
    $$
        \HFuncTerm{} ::= c_\pi~|~i_\pi~|~f (\HFuncTerm{},~\HFuncTerm{},~\dots~\HFuncTerm{})
    $$
    where $c_\pi \in \Cells \times \TraceVs, i_\pi \in \Inputs \times \TraceVs, f \in \FuncSymbs$, and the number of the elements in the tuple matches the function arity. We denote by $\HFuncTerms$  the set of all hyper-function terms.
\end{definition}

Analogously, we define \textit{hyper-predicate terms} $\HPredTerm \in \HPredTerms$ as hyper-function terms evaluating to \emph{true} or \emph{false}; \textit{hyper-assignments} $\HAssigns = (\Inputs \cup \Cells) \times \TraceVs \rightarrow \Values$ as functions mapping cells and inputs of each trace to their current values; \textit{hyper-computations} $\HComput \in \HAssigns^{\omega}$ as hyper-assignment sequences. See Fig. \ref{fig:first_system_example} for an~example.

\begin{figure}[t]
\begin{minipage}{0.35\textwidth}
\input{TSL_Kripke_structure.tex}
\label{fig:first_system_example}
\end{minipage}%
\begin{minipage}{0.65\textwidth}
\begin{align*}
&\pi := (c=0)~ (c=1)^\omega,~
\pi' := ((c=0)~ (c=1)~ (c=2))^\omega \\
&\HAssign_1: \{c_\pi \mapsto 0, c_{\pi'} \mapsto 0\}, \HAssign_2 : \{c_\pi \mapsto 1, c_{\pi'} \mapsto 1\} \\
&\HAssign_3: \{c_\pi \mapsto 1, c_{\pi'} \mapsto 2\}, \HAssign_4 : \{c_\pi \mapsto 1, c_{\pi'} \mapsto 0\} \\
\end{align*}
\end{minipage}
\caption{Left: A program automaton. Right: two traces $\pi$ and $\pi'$ of the program automaton. We interpret each trace as a computation. When executing both traces simultaneously, every time point has a corresponding hyper-assignment that assigns values to $c_{\pi}$ and $c_{\pi'}$. Those for the first four time steps are shown on the right. Together, they define the hyper-computation $\HComput := \HAssign_1(\HAssign_2~\HAssign_3~\HAssign_4)^\omega$, matching $\pi$ and $\pi'$.}
\end{figure}

\begin{definition}
     Let  $c_\pi \in \Cells \times \TraceVs, \HPredTerm \in \HPredTerms, \HFuncTerm{} \in \HFuncTerms$. A \emph{HyperTSL(T) formula} is defined by the following grammar:
\begin{align*}
    \varphi &::= \psi~|~\forall \pi.~ \varphi~|~\exists \pi.~\varphi \\
    \psi &::= \HPredTerm~|~\Upd{c_\pi}{\HFuncTerm{}}~|~\neg \psi~| ~\psi\wedge\psi~|~\LTLnext \psi~|~\psi\LTLuntil\psi~
\end{align*}
\end{definition}
To define the semantics of HyperTSL(T), we need the ability to extend a hyper-computation to new trace variables, one for each path quantifier. 
Let $\HComput\in\HAssigns^\omega$ be a hyper-computation, and let
$\pi, \pi' \in \TraceVs, \Comput \in \Assigns^{\omega} $ and $ x \in (\Inputs \cup \Cells)$. We define the extension of $\HComput$ by $\pi$ using the computation $\Comput$ as $ \ExtComput{\HComput}{\pi}{\Comput}~(x_{\pi'})= \HComput(x_{\pi'}) $ for $ \pi' \neq \pi$, and $\ExtComput{\HComput}{\pi}{\Comput}~(x_\pi)= \Comput(x_\pi)$ for $\pi$. 


\begin{definition}
    The \emph{satisfaction of a HyperTSL(T)-Formula} w.r.t. a hyper- computation $\HComput \in \HAssigns^\omega$, a set of computations $\Computs$ and a time point $t$ is defined by
    \begin{align*}
        &t, Z, \HComput \models \forall \pi.~\varphi &&\Leftrightarrow \forall \Comput \in \Computs.~t,~Z,~\ExtComput{\HComput}{\pi}{\Comput} \models \varphi \\
        &t, Z, \HComput \models \exists \pi.~\varphi &&\Leftrightarrow \exists \Comput \in \Computs.~t,~Z,~\ExtComput{\HComput}{\pi}{\Comput} \models \varphi \\
    \end{align*}
    The cases that do not involve path quantification are analogous to those of TSL(T) as defined in Sec.~\ref{prelim:tsl}. We define $Z \models \varphi$ as $0, Z, \emptyset^\omega \models \varphi$.
\end{definition}