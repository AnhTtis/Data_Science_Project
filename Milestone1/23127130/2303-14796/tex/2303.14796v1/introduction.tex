\section{Introduction}\label{sec:intro}
Hyperproperties~\cite{DBLP:journals/jcs/ClarksonS10} generalize trace properties~\cite{as85} to system properties, i.e., properties that reason about a system in its entirety and not just about individual execution traces.
% and not just based on individual executions. 
% Hyperproperties have been shown to be a powerful tool for expressing and reasoning about 
Hyperproperties comprise many important properties that are not expressible as trace properties, e.g.,
% They constitute a unifying reasoning framework for
information flow policies~\cite{DBLP:journals/jcs/ClarksonS10}, sensitivity and robustness of cyber-physical systems, and linearizability in distributed computing~\cite{bss18}.
For software systems, typical hyperproperties are program refinement or fairness conditions such as symmetry.

For the specification of hyperproperties, Linear Temporal Logic \cite{LTL} (LTL) has been extended with trace quantification, resulting in Hyper Linear Temporal Logic \cite{HyperLTL} (HyperLTL). 
There exist several model checking algorithms for HyperLTL~\cite{HyperLTL, HyperLTLModelChecking, VerifyingHyperliveness}, but they are designed for finite-state systems and are therefore not directly applicable to software. Existing algorithms for software verification of temporal hyperproperties (e.g.,~\cite{RelationalCorrectnessProofs, RelationalCorrectnessProofs2}) are, with the exception of \cite{RavensPaper}, limited to universal hyperproperties, i.e., properties without quantifier alternation.

In this paper, we develop algorithms for model checking software systems against $\forall^*\exists^*$ hyperproperties.
Our approach is complementary to the recently proposed approach of \cite{RavensPaper}. They require to be given a finite-state abstraction of the system, based on which they can both prove and disprove $\forall^*\exists^*$ hyperproperties. We do not require abstractions and instead provide sound but necessarily incomplete approximations to detect counterexamples of the specification.
% To do so, we employ a feasibility analysis. 

% While many hyperproperties are expressible using universal quantifiers only, some especially important ones require a combination of both. 
The class of $\forall^*\exists^*$ hyperproperties contains many important hyperproperties like program refinement or \emph{generalized noninterference}~\cite{noninference}.
% One example is \textit{Generalized noninterference} \cite{noninference}, 
Generalized noninterference states that it is impossible to infer the value of a high-security input by observing the low-security outputs.
Unlike \textit{noninterference}, it does not require the system to be deterministic.
Generalized noninterference can be expressed as $\varphi_{gni} = \forall \pi\exists \pi'.\LTLglobally (i_{\pi'} = \lambda \wedge c_{\pi} = c_{\pi'})$.
The formula states that replacing the value of the high-security input $i$ with some dummy value $\lambda$ does not change the observable output $c$.

The above formula can only be expressed in HyperLTL if $i$ and $c$ range over a finite domain.
This is a real limitation in the context of software model checking, where variables usually range over infinite domains like integers or strings.
To overcome this limitation, our specifications build on Hyper Temporal Stream Logic (HyperTSL)~\cite{HyperTSL}.
HyperTSL replaces HyperLTL's atomic propositions with memory cells together with predicates and update terms over these cells. Update terms use functions to describe how the value of a cell changes from the previous to the current step.
This makes the logic especially suited for specifying software properties.

HyperTSL was originally designed for the synthesis of software systems, which is why all predicates and functions are uninterpreted.
In the context of model checking, we have a concrete system at hand, so we should interpret functions and predicates according to that system. 
We therefore introduce HyperTSL(T) -- HyperTSL with interpreted theories -- as basis for our algorithms.


\paragraph{Overview}\input{overview.tex}
    
\paragraph{Contributions.}
We present an automata-based algorithm for software model checking of $\forall^*\exists^*$-hyperproperties. We summarize our contributions as follows. 
\begin{itemize}
    \item We extend HyperTSL with theories, a version of HyperTSL that is suitable for model checking.
    \item  We adapt the approach of~\cite{FairnessModTheory} to TSL(T) and alternation-free HyperTSL(T), and thereby suggest the first model checking algorithm for both TSL(T) and HyperTSL(T). 
    \item We further extend the algorithm for disproving $\forall^*\exists^*$ hyperproperties and proving $\exists^*\forall^*$ hyperproperties using a feasibility analysis. 
\end{itemize}