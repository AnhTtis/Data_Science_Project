\subsection{ $\forall^* \exists^*$ HyperTSL(T)}\label{sec:hyperMC}

In this section, we present a sound but necessarily incomplete algorithm for finding counterexamples for $\forall^* \exists^*$ HyperTSL(T) formulas.\footnote{Note that the algorithms of Sec.~\ref{sec:tslMC} and Sec.~\ref{sec:altfree} are also incomplete, due to the feasibility test. However, the incompleteness of the algorithm we provide in this section is inherent to the quantifier alternation of the formula.}
%there is also for HyperLTL no such algorithm yet, thus this also gives the first software model checking algorithm for finding counterexamples for $\forall^* \exists^*$ HyperLTL formulas. 
Such an algorithm %that finds counterexamples for the $\forall^* \exists^*$ fragment 
can also provide witnesses $\exists^* \forall^*$ formulas. As HyperTSL(T) is built on top of HyperLTL, we combine ideas from finite-state HyperLTL model checking~\cite{HyperLTLModelChecking}
with the algorithms of Sec.~\ref{sec:tslMC} and Sec.~\ref{sec:altfree}.

Let $\varphi = \forall^m \exists^n. \psi$. For HyperLTL model checking, \cite{HyperLTLModelChecking} first constructs an automaton containing the system traces satisfying $\psi_\exists := \exists ^n. \psi$, and then applies complementation to extract counterexamples for the $\forall\exists$ specification.
Consider the automaton $\aut{P}^n \BuechiProd \aut{A}_{\psi_{LTL}}$ from Sec.~\ref{sec:tslMC}, whose feasible traces correspond to the system traces satisfying $\psi_\exists$. If we would be able to remove all infeasible traces, we could apply the finite-state HyperLTL model checking construction.
Unfortunately, removing all infeasibilities is impossible in general, as the result would be a finite-state system describing exactly an infinite-state system. Therefore, the main idea of this section is to remove parts of the infeasible traces from $\aut{P}^n \BuechiProd \aut{A}_{\psi_{LTL}}$, constructing an over-approximation of the system traces satisfying $\psi_\exists$. 
A counterexample disproving $\varphi$ is then a combination of system traces that is not contained in the over-approximation. 

We propose two techniques for removing infeasibility. The first technique removes \textit{k-infeasibility} from the automaton, that is, a local inconsistency in a trace, occurring within $k$ consecutive time steps. When choosing $k$, there is a tradeoff: if $k$ is larger, more counterexamples can be identified, but the automaton construction gets exponentially larger. 

The second technique removes \textit{infeasible accepting cycles} from the automaton. It might not be possible to remove all of them, thus we bound the number of iterations. We present an example and then elaborate on these two methods. 


\begin{example}
    The trace $t_1$ below is 3-infeasible, because regardless of the value of $n$ prior to the second time step, the assertion in the fourth time step will fail.
    %\begin{align*}
     $$   t_1 = (n--;~ \mathit{assert}(n >= 0))~ (n:= 1;~ \mathit{assert} (n >= 0))~ (n--;~ \mathit{assert} (n >= 0))^\omega $$
    %\end{align*}
    In contrast, the trace 
    $t_2 = (n := *)~(n--;~ \mathit{assert} (n >= 0))^\omega$
    is not $k$-infeasible for any $k$, because the value of $n$ can always be large enough to pass the first $k$ assertions. Still, the trace is infeasible because $n$ cannot decrease forever without dropping below zero. If such a trace is accepted by an automaton, $n--;~\mathit{assert} (n >= 0)$ corresponds to an infeasible accepting cycle.    
\end{example}

\subsubsection{Removing $k$-infeasibility} 
 To remove $k$-infeasibility from an automaton, we  construct a new program automaton that `remembers' the $k-1$ previous statements. The states of the new automaton correspond to paths of length $k$ in the original automaton. We add a transition labeled with $l$ between two states $p$ and $q$ if we can extend the trace represented by $p$ with $l$ such that the resulting trace is $k$-feasible. Formally, we get: 


\begin{definition}
    Let $k \in \mathbb{N}$, $\PTrace \in \Stmt^\omega$. We say that $\PTrace$ is \emph{$k$-infeasible} if there exists $j \in \mathbb{N}$ such that $\PTrace_j \PTrace_{j+1} \dots \PTrace_{j+k-1}; \mathit{assert}(true)^\omega$ is infeasible for all possible initial assignments $\Comput_{-1}$. We then also call the subsequence $\PTrace_{j}\PTrace_{j+1}\dots \PTrace_{j+k-1}$ infeasible.
    If a trace is not $k$-infeasible, we call it $k$-feasible.\footnote{Whether a subsequence $\PTrace_j\PTrace_{j+1} \dots \PTrace_{j+k-1}$ is a witness of k-infeasibility can be checked using an SMT-solver, e.g, \cite{Z3, SMT1, SMT2, SMT3}.}
\end{definition}



\begin{definition}
    Let $\aut{P} = (\Stmt, Q, q_0, \delta, F)$ be a program automaton. Let $k \in \mathbb{N}$. We define $\aut{P}$ without $k$-infeasibility, as $\aut{P}_k = (\Stmt, Q', q_0, \delta', F')$ where
    \begin{align*}
        Q' :=& \{(q_1,s_1,q_2 \dots ,s_{k-1},q_k) \mid (q_1, s_1, q_2) \in \delta \wedge \dots \wedge (q_{k-1}, s_{k-1}, q_k) \in \delta \}~ \cup \\
        &\{(q_0, s_0,q_1 \dots ,s_{k' - 1}, q_{k'}) \mid k' < k-1 \wedge (q_0, s_0, q_1) \in \delta \wedge \dots \\
        & \phantom{(q_0, s_0,q_1 \dots ,s_{k' - 1}, q_{k'}) \mid} \quad \wedge (q_{k'-1}, s_{k'-1}, q_{k'}) \in \delta  \} \\
        \delta' :=& \{((q_1,s_1,q_2\dots ,s_{k-1},q_k), s_k, (q_2,s_2, \dots ,q_k,s_k,q_{k+1})) \in Q' \times \Stmt \times Q' \\ &\quad \mid s_1 \dots s_k \text{ feasible} \}~\cup \\
        &\{((q_0,s_0,q_1\dots ,s_{k'-1},q_{k'}), s_{k'}, (q_0, s_0, \dots ,q_{k'},s_{k'},q_{k'+1})) \in Q' \times \Stmt \times Q' \\ &\quad \mid k' < k-1 \wedge s_0 \dots s_{k'} \text{ feasible} \} \\
        F' :=& \{(q_1,s_1,q_2 \dots ,s_{k-1},q_k) \in Q' \mid q_k \in F \}~\cup \\
        & \{(q_0, s_0,q_1 \dots ,s_{k' - 1}, q_{k'}) \in Q' \mid k' < k-1 \wedge q_{k'} \in F\}
    \end{align*}
\end{definition}

\begin{theorem} \label{thm:k_feasible}
   $\aut{P}_k$ accepts exactly the $k$-feasible traces of~$\aut{P}$.
\end{theorem}
The proof follows directly from the construction above, see App.~\ref{sec:k_feasible_proof} for details. 

\subsubsection{Removing Infeasible Accepting Cycles} 
For removing infeasible accepting cycles, we first enumerate all simple cycles of the automaton (using, e.g.,~\cite{CycleFinding}), adding also cycles induced by self-loops. For each cycle $\varrho$ that contains at least one accepting state, we test its feasibility: first, using an SMT-solver to test if $\varrho$ is locally infeasible; then, using a ranking function synthesizer (e.g., \cite{Termination1, Termination2, Termination3}) to test if $\varrho^\omega$ is infeasible. If we successfully prove infeasibility, we refine the model, using the methods from \cite{SoftwareModelCheckingAutomata, TerminationRefinement}. This refinement is formalized in the following.


\begin{definition}
    Let $\aut{P}=(\Stmt, Q, q_0, \delta, F)$ be a program automaton. Let $\varrho = (q_1, s_1, q_2)(q_2, s_2, q_3)\dots(q_n, s_n, q_1)$ be a sequence of transitions of $\aut{P}$. We say that~$\varrho$ is an \emph{infeasible accepting cycle} if there is a $1 \leq j \leq n$ with $q_j \in F$ and $(s_1 s_2 \dots s_{n-1})^\omega$ is infeasible for all possible initial assignments $\Comput_{-1}$.
\end{definition}

\begin{definition}
    Let $\aut{P}$ be a program automaton and $C \subseteq (Q \times \Stmt \times Q)^\omega$ be a set of infeasible accepting cycles of $\aut{P}$.
    Furthermore, let
    $$\varrho = (q_1, s_1, q_2)(q_2, s_2, q_3)\dots(q_{n-1}, s_{n-1}, q_n) \in~C.$$
    The automaton $\aut{A}_\varrho$ for $\varrho$ is $ \aut{A}_\varrho = (\Stmt, Q=\{q_0, q_1, \dots q_n\}, q_0, \delta, Q \backslash \{q_0 \}) $ where 
   \begin{align*}
        \delta ~=~ &\{(q_0, s, q_0) \mid s \in \Stmt \} \\
        & \cup \{(q_j, s_j, q_{j+1}) \mid 1 \leq j < n \} \cup \{(q_0, s_1, q_2), (q_n, s_n, q_1)\}.
   \end{align*}
    \end{definition}
   Then, $\aut{A}_\varrho$ accepts exactly the traces that end with $\varrho^\omega$, without any restriction on the prefix. See Fig. \ref{fig:aut_infeasible_cycle} for an example. To exclude the traces of $\aut{A}_\varrho$ from $\aut{P}$, we define
    $
        \aut{P}_C := \aut{P} \backslash \left( \bigcup_{\varrho \in C} \aut{A}_\varrho \right)
    $.\footnote{For two automata $\aut{A}_1, \aut{A}_2$ we use $\aut{A}_1 \backslash \aut{A}_2$ to denote the intersection of $\aut{A}_1$ with the complement of $\aut{A}_2$, resulting in the language $\aut{L}(\aut{A}_1) \setminus\aut{L}(\aut{A}_2)$. }
    This construction can be repeated to exclude infeasible accepted cycles that are newly created in $\aut{P}_C$. We denote the result of iterating this process $k'$ times by~$\aut{P}_{C(k')}$.

\subsubsection{Finding Counterexamples for $\forall^* \exists^*$ HyperTSL(T)-Formulas} 
Consider now a HyperTSL(T) formula $\varphi = \forall^{1\cdots m}\exists ^{m+1\cdots n}.\psi$ and a program automaton $\aut{P}$.
\begin{wrapfigure}{r}{0.5\textwidth}
    \vspace{-1cm}
    \input{aut_infeasible_cycle.tex}
    \vspace{-5mm}
    \caption{Automaton $\aut{A}_{\varrho}$ for the infeasible cycle
    $\varrho = (q_1,~n--,~q_2)(q_2,~ assert(n>0),~ q_1)$. Label $*$ denotes an edge for every (relevant) statement.}
    \label{fig:aut_infeasible_cycle}
    \vspace{-1cm}
\end{wrapfigure}
For finding a counterexample, we first construct the combined product $\aut{P}^n \BuechiProd \aut{A}_\psi$. 
Each feasible accepted trace of $\aut{P}^n \BuechiProd \aut{A}_\psi$ corresponds to a combination of $n$ feasible program traces that satisfy $\psi$. Next, we eliminate $k$-infeasibility and remove $k'$-times infeasible accepting cycles from the combined product, resulting in the automaton $(\aut{P}^n \BuechiProd \aut{A}_\psi)_{k, C(k')}$. Using this modified combined product, we obtain an over-approximation of the program execution combinations satisfying the existential part of the specification.
 Each trace of the combined product is a combination of $n$ program executions and a predicate/update term sequence. We then project the $m$ universally quantified program executions from a feasible trace, obtaining a tuple of $m$ program executions that satisfy the existential part of the formula. Applying this projection to all traces of $(\aut{P}^n \BuechiProd \aut{A}_\psi)_{k, C(k')}$ leads to an over-approximation of the program executions satisfying the existential part of the specification. Formally:

\begin{definition}
    Let $\aut{P}$ be a program automaton, let $m\leq n \in \mathbb{N}$, and let $\aut{A}_\psi$ be the automaton for the formula $\psi$. Let $(\aut{P}^n \BuechiProd \aut{A})_{k, C(k')} = (\Stmt, Q, q_0, \delta, F)$. We define the \emph{projected automaton} $(\aut{P}^m \BuechiProd \aut{A})_{k, C(k')}^\forall = (\Stmt, Q, q_0, \delta^\forall, F)$ where
    %\begin{align*}
 $   \delta^\forall = \{(q, (s_1; \dots ;~s_m), q') \mid \exists s_{m+1}, \dots s_n, \edgel.~ (q, \combine{s_1; \dots ;~s_n}{\edgel},q') \in \delta \} $.
 %\footnote{Recall that $s_1;s_2$ refers to a sequence of statements, as given in Def.~\ref{def:grammar}. For more details on the universal projection we refer the reader to\cite{DBLP:conf/fsttcs/FinkbeinerP22}.}
    %\end{align*}
\end{definition}
The notation $s_1;s_2$ refers to a sequence of statements, as given in Def.~\ref{def:grammar}. For more details on the universal projection we refer the reader to\cite{DBLP:conf/fsttcs/FinkbeinerP22}.

Now, it only remains to check whether the over-approximation contains all tuples of $m$ feasible program executions. If not, a counterexample is found. This boils down to testing if $\aut{P}^m \backslash (\aut{P}^n \BuechiProd \aut{A}_\psi)_{k, C(k')}^\forall$ has some feasible trace.
 Thm.~\ref{thm:corr_AE} states the soundness of our algorithm. See App.~\ref{sec:corr_AE} for its proof. 

\begin{theorem} \label{thm:corr_AE}
    Let $\varphi = \forall^{1\cdots m}\exists ^{m+1\cdots n}. \psi $ be a HyperTSL(T) formula. If the automaton $\aut{P}^m \backslash (\aut{P}^n \BuechiProd \aut{A}_\psi)_{k, C(k')}^\forall$ has a feasible trace, then $\aut{P}$ does not satisfy $\varphi$.
\end{theorem}




\section{Demonstration of the Algorithm} \label{sec:HyperExamples}

In this section, we apply the algorithm of Sec.~\ref{sec:hyperMC} to two simple examples, demonstrating that removing some infeasibilities can already be sufficient for identifying counterexamples.

\subsubsection{Generalized Noninterference}
Recall the formula $\varphi_{gni} = \forall \pi.~\exists \pi'.~\LTLglobally(i_{\pi'} = \lambda \wedge c_\pi = c_{\pi'})$ introduced in Sec.~\ref{sec:intro}, specifying generalized noninterference. 
We model-check $\varphi_{gni}$ on the program automaton $\aut{P}$ of Fig.~\ref{fig:gni_example_2} (left), setting $\lambda = 0$.
The program $\aut{P}$ violates $\varphi_{gni}$ since for the trace $(assert (i < 0)~ c:=0)^\omega$ there is no other trace where on which $c$ is equal, but $i=0$.
%$P^2$ is shown in Fig.~\ref{fig:gni_example_2}. 

\begin{figure}[t]
\begin{minipage}{0.25\textwidth}
\input{gni_example_1.tex}
\end{minipage}%
\hfill
\begin{minipage}{0.74\textwidth}
\input{gni_example_2.tex}
\end{minipage}
\caption{Left: The program automaton $\aut{P}$ used in the first example. Right: The program automaton $\aut{P}^2$. For brevity, we use $A$ for $assert$ and join consecutive assertions. }
\label{fig:gni_example_2}
\end{figure}

The automaton for $\psi = \LTLglobally(i_{\pi'} = 0 \wedge c_\pi = c_{\pi'})$ consists of a single accepting state with the self-loop labeled with $\PredTerm = (i_{\pi'} = 0 \wedge c_{\pi} = c_{\pi'})$. For this example, it suffices to choose $k=1$. To detect $1$-inconsistencies we construct $\aut{P}^2$ (Fig~\ref{fig:gni_example_2}, right). Then, $(\aut{P}^2 \BuechiProd \aut{A}_{\psi})_k$ is the combined product with all
 $1$-inconsistent 
 \begin{wrapfigure}{r}{0.5\textwidth}
\vspace{-3mm}
\input{gni_example_4.tex}
\caption{program automaton $(\aut{P}^2 \BuechiProd \aut{A}_{\psi})_k^\forall$}
\label{fig:gni_example_4}
\vspace{-3mm}
\end{wrapfigure}
 transitions removed (see Fig.~\ref{fig:gni_example_3} for the combined product). 


\begin{figure}[t]
\input{gni_example_3.tex}
\caption{The combined product $(\aut{P}^2 \BuechiProd \aut{A}_{\psi})$}
\label{fig:gni_example_3}
\end{figure}

The automaton $(\aut{P}^2 \BuechiProd \aut{A}_{\psi})_k^\forall$ is shown in Fig.~\ref{fig:gni_example_4}. 
It does not contain the trace $\sigma = \mathit{assert}(i < 0)~(c:=0)^\omega$ which is a feasible trace of $\aut{P}$. Therefore, $\sigma$ is a feasible trace accepted by $\aut{P}\backslash (\aut{P}^2 \BuechiProd \aut{A}_{\psi})_k^\forall$ and is a counterexample proving that $\aut{P}$ does not satisfy generalized noninterference -- there is no feasible trace that agrees on the value of the cell $c$ but has always $i=0$. %For this example, it is not necessary to remove infeasible cycles.

\subsubsection{The Need of Removing Cycles} 

We now present an example in which removing $k$-infeasibility is not sufficient, but removing infeasible accepting cycles leads to a counterexample. Consider the specification
$
    \varphi = \forall \pi\exists \pi'.\LTLglobally (p_\pi \neq p_{\pi'} \wedge n_\pi < n_{\pi'})
$
and the program automaton $\aut{P}_{cy}$ of Fig. \ref{fig:cycle_example_1}.
The formula $\varphi$ states that for every trace $\pi$, there is another trace $\pi'$ which differs from $\pi$ on $p$, but in which $n$ is always greater. The trace $\pi = (n:= *); (p := *); \mathit{assert}(p = 0); (n--)^\omega$ is a counterexample for $\varphi$ in $\aut{P}_{cy}$  as any trace $\pi'$ which differs on $p$ will decrease its $n$ by $2$ in every time step, and thus $n_{\pi'}$ will eventually drop below $n_\pi$.




\begin{figure}[t]
\begin{minipage}{0.19\textwidth}
\input{cycle_example_1.tex}
\end{minipage}%
\hfill
\begin{minipage}{0.79\textwidth}
\input{cycle_example_2.tex}
\end{minipage}
\caption{Left: The program automaton $\aut{P}_{cy}$, Right: The program automaton $\aut{P}_{cy}^2$.}
\label{fig:cycle_example_1}
\end{figure}


The automaton 
$\aut{P}_{cy}^2$ is shown in Fig. \ref{fig:cycle_example_1}.
In the combined product, the structure of the automaton stays the same, and $\mathit{assert}(p_\pi \neq p_{\pi'} \wedge n_\pi < n_\pi')$ is added to every state. 
Removing local $k$-infeasibilities is not sufficient here; assume $k =1$. The only $1$-infeasible transition is the transition from $q_2q_2$ to $q_3q_3$, and this does not eliminate the counterexample $\pi$. Greater $k$'s do not work as well, as the remaining traces of the combined product are not $k$~infeasible for any~$k$. 


However, the self-loop at $q_3q_4$ is an infeasible accepting cycle -- the sequence \\ $(n_\pi--;~ n_{\pi'} := n_{\pi'} - 2;~ \mathit{assert} (n_{\pi} < n_{\pi'}))^\omega$ must eventually terminate. We choose $k'=1$ removing all traces ending with this cycle. Next, we project the automaton to the universal part. The trace $\pi$ is not accepted by the automaton $(\aut{P}^2 \BuechiProd \aut{A}_\psi)^\forall_{1, C(1)}$. But since $\pi$ is in $\aut{P}$ and feasible, it is identified as a counterexample.