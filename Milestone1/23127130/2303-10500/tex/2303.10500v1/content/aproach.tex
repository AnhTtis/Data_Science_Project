\section{A confidentiality-preserving approach}
\label{sec:conf}
In this paper, we present an approach for tracking and orchestrating business processes through smart contracts, conceptually in a very similar way to \cite{caterpillar},\cite{chorchain},\cite{multichain},\cite{flexchain},\cite{lorikeet},\cite{Mercenne_Brousmiche_Hamida_2018}, and \cite{Abid_Cheikhrouhou_Jmaiel_2020}, but instead of storing the process state on-chain, we apply cryptographic state commitments and accept new commitments carrying state commitment update proposals on the presentation of proper Zero-Knowledge Proofs (ZKPs). Our approach aims at rendering process state and data information undiscoverable from the smart contract state -- to parties not involved in the execution of the process instance.

ZKPs are cryptographic methods to prove that various statements are true -- without revealing any additional information about the statement. Quoting the ZKProof Community Reference (\cite{ZKProofCommunity}, p1), \emph{''A zero-knowledge proof makes it possible to prove a statement is true while preserving the confidentiality of secret information. This makes sense when the veracity of the statement is not obvious on its own, but the prover knows relevant secret information (or has a skill, like super computation ability) that enables producing proofs. The notion of secrecy is used here in the sense of prohibited leakage, but a ZKP makes sense even if the 'secret' (or any portion of it) is known apriori by the verifier(s)''}. 

In this work, we rely on zk-SNARKs, a family of \textit{noninteractive} (''single-shot'' message passing from prover to verifier), and \textit{succinct} (small and cheaply verifiable proofs) ZKPs. We use the ZoKrates toolkit as a ZKP front-end \cite{zokrates}, which currently supports the Groth16 \cite{Groth_2016} and GM17 \cite{Groth_Maller_2017} schemes.

\subsection{The zero-knowledge WorkFlow (zkWF) protocol}
Our approach relies on two key conceptual components: our zkWF (''zero knowledge WorkFlow'') protocol and what we call ''zkWF programs''.

\medskip
\noindent
\begin{tikzpicture}
    \node[text width = \textwidth/2-0.5cm,align=justify, draw, rectangle,] {The \textbf{zkWF protocol} is a hash commitment style protocol that allows the participants of a business process to follow and step the execution of a business process, governed by a smart contract. Meanwhile, the state and trace of the process execution remain hidden from external parties.};
\end{tikzpicture}

\noindent
\input{content/tikz-figure/overview}

Figure \ref{fig:basic_update} presents a high-level overview of the protocol. The protocol requires to have a smart contract deployed on a blockchain for each process instance. This smart contract contains a hash commitment of the current state and an encrypted version of the state.

During process execution, the collaborating parties can send messages to each other by off-chain means. These are captured in the underlying process specification as intermediate message throw and capture events; the commitment scheme includes commitments to the message hashes.

When a participant wishes to update the state stored in the smart contract (hash commitment and state ciphertext) -- that is, to ''step the process'' --, it has to create a ZKP that the state transition they propose is valid. This new state includes the hash of the message they sent beforehand if the step involves message sending. When the execution arrives at a point where a participant receives a message in the next stage of the execution, the receiving party checks the hash and only accepts if the hashes match.

Participant authorization is tied to proving EdDSA private key ownership in the ZKPs; the public keys of the participants are defined over the underlying process model as a parameterization. Additionally, we require the participants to have a common means for encrypting and decrypting stored state ciphertexts (this aspect is not constrained by the protocol).

This scheme enables adapting the protocol to different distributed ledgers in a straightforward way (we provide an implementation for Ethereum and Hyperledger Fabric); as well as masking updater identity on pseudonymizing platforms (such as Ethereum) by facilitating the use of single-use transaction source addresses. While the updates themselves and the contract state are unintelligible to parties outside the collaboration, statistical and model trace analyses of the update sequences may still be a threat; our mitigation is the inclusion of a ''fake'' update transaction variant (no actual state update), which all participants are authorized to use freely.

\subsection{zkWF programs}
zkWF programs serve as a bridge between process specification and proof computation/verification. These programs are generated from a representative subset of the BPMN specification, with extensions for cryptographic checks, as detailed later.

\medskip
\noindent
\begin{tikzpicture}
    \node[text width = \textwidth/2-0.5cm,align=justify, draw, rectangle,]{A \textbf{zkWF program} is a ZoKrates program that, for a given BPMN model instance (parameterized model), can decide whether a given actor is authorized to execute a state transition in a given execution state. The ZoKrates program can be used to generate the zero-knowledge proofs and the proof verification code used by the \textbf{zkWF protocol} participants and zkWF smart contracts.};
\end{tikzpicture}

\subsection{Toolchain overview}
We have created a prototype of an end-to-end toolchain to support the proposed approach, as depicted in figure \ref{fig:vezerabra}, from modelling through code synthesis to deployment and operation. The figure also delineates the newly created software components (and those with novel generators).

In the \textit{modelling phase}, a BPMN model is annotated with metadata for process instantiation, and our Kotlin-based interpreter and translator creates the corresponding zkWF program.

In the \textit{synthesis phase}, the ZoKrates toolkit is used to set up the \textit{prover key} and \textit{verifier key} (note that ZoKrates supports \textit{multi-party ceremonies}) and generates the verifier smart contract in Solidity. We created novel support for generating verifier code for Hyperledger Fabric \cite{hyperledger_fabric}. We also created the (necessarily application-specific) code generation facilities for the state commitment management part of the smart contracts for both platforms.

For the deployment phase, we created automation facilities for deployment to Ethereum (and other blockchains using a compatible RPC API); and an SDK and GUI application for the client side. Here we integrate the ZoKrates toolkit as a proof generator.

\noindent
\input{content/tikz-figure/vezer}

\subsection{Adversarial model and security goals}
A \textit{participant} of a \textit{business process instance} is a party who has a private EdDSA key necessary to enact certain state changes in the process instance, as encoded in the underlying BPMN model instance with public key annotations on model elements. All other parties are deemed \textit{process external}. 

We assume that the underlying process model is public knowledge, but the set of public keys serving as parameterization for a process instance is shared only between the participants. We also assume no private key compromises.

We assume full integrity for the blockchain (no successful attack on the consensus) but also the full observability of transactions targeting the process manager smart contract and the smart contract state sequence by process external parties. For the sake of simplicity, we assume deterministic transaction finality for the blockchain (largely equivalent to ''waiting for a few blocks'' for treating transactions as blockchain-included under probabilistic finality models). We treat the blockchain as \textit{fair} -- any transaction submitted by a participant is included in a block in a reasonable time, irrespective of concurrent transaction proposal load.

Our \textit{integrity goals} are the following.
\begin{itemize}
    \item Process external parties should not be able to influence the smart contract state commitment and stored encrypted state.
    \item Participants should be able to influence the smart contract state commitment and stored encrypted state only when they are authorized by their private key(s). Accepted state commitment updates should always conform to the execution semantics of the underlying process model.
    \item Should a participant successfully submit an encrypted state not conforming to the accompanying commitment, it has to be evident to all participants in a non-repudiable way.
\end{itemize}

The first two integrity goals largely carry over from the earlier cited state of the art; the third is a reasonable relaxation in view of a currently still missing ZKP capability, as explained later.

Our \textit{availability goal} is that no process external party should be able to influence the update capability of the authorized participants.

Lastly, our \textit{confidentiality goal} is that no external party should be able to determine the process state either fully or partially (beyond the fact that it exists and that it has been started) without collusion with at least one participant.


%is key-authorized process state changes to be possible only in terms of the smart contract state commitment and stored encrypted state. 
%Note that this goal carries over from the existing state of the art.

%Our \textit{availability goal} is no process external party to stop

%In this paper, we assume the following properties may apply for a given attacker:


%\begin{itemize}
%\item An attacker knows the corresponding BPMN model for a given smart contract instance
%\item A malicious participant may also be an attacker
%\end{itemize}

%Our approach aims at ensuring the following security guarantees.
%\todo{Ezeket befelyezni}
%\begin{itemize}  
% \item Parties not participating cannot modify the state stored on the blockchain
% \item Parties not participating cannot read or guess the current state of the business process execution based on the data stored in the smart contract. 
%\item No party can make an illegal move during the orchestration.
%\item Messages between the participants can be verified.
%\item Participants can identify which party made a given move 
%\end{itemize}