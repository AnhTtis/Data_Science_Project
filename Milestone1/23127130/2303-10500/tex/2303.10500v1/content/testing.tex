\section{Testing}
To make sure this method of executing business processes is correct, We propose a few ways of challenging it.
\subsection{Test cases}
Our first method of testing our approach is by defining test cases and seeing if they can be used in our tool.
\subsubsection{Simple \& corner cases}
These test cases were designed to ensure that every supported element works. We also wanted to know how the program reacts to corner cases where the model syntax is correct but the semantics are questionable.

\paragraph{Kép kell ide?}

\subsubsection{Representative test}
As a Representative test, We wanted to use a complex, real-world example BPMN model. The goal is to see how the program reacts to more oversized state objects (e.g., more executable events, messages, etc.).

\paragraph{Kép kell ide?}

\subsubsection{Testing framework}
\label{testing_frame}
To run these tests We designed a testing framework. This framework can run individual test scenarios (i.g. separate steps) and run them as a batch.

The framework also has a GUI and CLI interface. The GUI can be accessed from WFGUI. The CLI interface is designed to work without user interaction. This makes it easy to integrate as a CI/CD pipeline.

\subsection{Future ideas for testing}
\label{more_tests}
An apparent insufficiency of the current approach is that it is not formally proven that the accepted language of the zkWF program conforms to formal specifications of BPMN model and execution semantics. 

This will be certainly a worthwhile area of future research. In addition to classic approaches, in this specific context, due to the relative simplicity of the involved components, it seems to be feasible to create a joint executable model of the smart contract, the prover, the communication protocol and lastly, an executable specification of BPMN semantics. This approach may be feasible even in the form of direct bytecode level model checking of an imperative language as Java (using, e.g., Java PathFinder for analysis). Then, operational semantics conformance can become checkable at least on a model-by-model basis.