\section{zkWF protocol design}
\label{protocol}
The zkWF protocol largely follows the general ''proofs over commitments and proposed commitment updates'' pattern customary in blockchain applications of ZKPs (as depicted in Figure \ref{fig:basic_update}). The \textit{process manager smart contract} component is fairly simple: on the one hand, it stores and updates commitments, and on the other hand, it checks ZKPs over the new commitments proposed in incoming blockchain transactions. Specifically, the process manager smart contract stores the following data (using the notations introduced earlier):

%\subsubsection{Process manager smart contract design}
%\label{smartcontract}
%This smart contract contains the logic that is executed on the blockchain. It is responsible for the integrity of the business process execution. It must not contain the current state in plain text. It is designed to be relatively simple since most of the computation is off-chain. Figure \ref{fig:sc_design} shows the overall design of this smart contract.

%The process manager smart contract stores the following data:
\begin{itemize}
	\item $\hcurr =\textit{hash}(\scurr || \rcurr)$ %- the hash of the current state and some randomness
	\item $\Ccurr=\textit{enc}(\scurr)$ %- the ciphertext of the current state and the randomness used in the hashing encrypted with a common, predefined key (each participant should have this key)
	\item $\Scurr=\textit{sig}(h_{prev}||\hcurr)$ %-  the previous states' and the current states' hashes concatenated, signed by the last acting participant.
\end{itemize}

\smallskip

\noindent where $enc$ denotes encryption with the group encryption key and method (see Section \ref{sec:conf}). %and $sig$ denotes signing by the party who proposed the second hash commitment in the concatenation (i.e, $\hcurr$). 
Update request transactions of the smart contract carry the following arguments:

%A participant can update these variables with a function. This function has the following arguments but may have others:
\begin{itemize}
    \item $\hnew=\textit{hash}(\snew || \rnew)$ %- the hash of the new state and some randomness 
    \item $\Cnew=\textit{enc}(\snew)$ %- the ciphertext of the new state and the randomness used in the hashing encrypted with a common, predefined key (each participant should have this key)
    \item $\Snew=\textit{sig}(\hcurr||\hnew)$ %- a signature from the last acting participant of the process
    %\item $\proof$ - a valid proof generated by the corresponding zkWF program.
    \item $p(\hcurr,\Snew,\hnew)$
\end{itemize}

\smallskip

\noindent The last argument is a ZKP of the correspondence of $\hcurr$, $\Snew$ and $\hnew$, under the pre-agreed zkWF program. The process manager smart contract checks the validity of this proof, before accepting the smart contract state change carried by the other arguments.