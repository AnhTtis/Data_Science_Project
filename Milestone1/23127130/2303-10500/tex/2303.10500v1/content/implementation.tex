\section{Implementation and testing}
%This section describes how we implemented the zkWF programs and how we integrated the zwWF protocol to our tool.
%\subsection{zkWF implementation}
%This section describes how the zkWF program was implemented in ZoKrates.
%\subsubsection{ZKP framework}
The ZoKrates toolkit is a central component in our framework; the current implementation uses version {0.7.13}\footnote{See \url{https://github.com/Zokrates/ZoKrates/releases}}. Although the state of the art is changing very rapidly, ZoKrates is the noninteractive ZKP toolkit which has the richest programming language from the point of view of our purposes and is mature enough at the same time.

%To implement zkWF programs, We chose Zokrates because this seemed like the most advanced solution at the time of writing. It also makes it easy to generate a verifier smart contract which would be tedious to write manually. We used ZoKrates version \href{URL}{0.7.13} at the time. It is the latest version as of writing this.

\subsection{Code generation}
Our code generator, implementing the transformation logic denoted on Figure \ref{fig:vezerabra}, is a custom development in Kotlin. This component generates a zkWF program from a BPMN model (serialized in XML the standard way), relying on a set of ZoKrates template files. First, the model is encoded, as we outlined earlier; then, it generates the code for calculating the state hashes, checking the variable write permissions, ensuring exclusive gateway paths, and verifying message sending. Distribution and validation of the resulting zkWF program among the process participants are not covered by the framework.

As mentioned earlier, in addition to generating zkWF programs, we also support the generation of process manager smart contracts for EVM-based blockchains (via Solidity code generation with a language version {0.8.0} target) as well as for Hyperledger Fabric. Solidity smart contracts are derived from the verifier smart contracts ZoKrates generates for zkWF programs.

In Fabric, smart contracts -- ''chaincodes'' -- run in containers and can be developed is classic programming languages, as Java, JavaScript and Go. Consequently, we opted to create a custom chaincode container, where a Java-based chaincode receives smart contract invocations and uses a container-resident copy of the ZoKrates toolkit for proof verification. The structure of the solution and its support of the zkWF protocol are the same as in the case of Solidity.

%\section{Smart contract implementation}
%To make our approach less dependent on one technology, We implemented the process manager smart contract for two distributed ledger systems: Ethereum and Hyperledger Fabric.
%\subsection{EVM}
%The process manager smart contract (see section \ref{smartcontract}) is implemented in Solidity version 0.8.0. It is derived from a Verifier smart contract generated by ZoKrates.

%\subsection{Hyperledger Fabric}
%\label{fabric_verifier}
%ZoKrates can only generate smart contract verifiers in Solidity. Fortunately,  Hyperledger Fabric chaincodes run in standard docker containers and are written in traditional programming languages like Java. This means we can use the ZoKrates by executing the commands in the container with a ProcessBuilder class.

%The rest of the smart contract implementation is analogue to the Solidity one.

\subsection{Client side}
We created a simple participant-side SDK, which wraps ZoKrates (for proof generation) and incorporates the Web3J wallet library. For testing and demonstration purposes, we also created a TornadoFX-based desktop GUI application (WFGUI, standing for ''WorkFlow GUI''). The GUI supports all key participant-side actions: monitoring a process manager smart contract for changes, retrieving state, creating process step proposals, computing their witnesses and proofs, and submitting update proposals according to the zkWF protocol. 

WFGUI also incorporates a process modeller for our BPMN subset with our extensions through an embedding of bpmn-js\footnote{See \url{https://bpmn.io/toolkit/bpmn-js/}}; supports testing through preassembled smart contract call sequences, which use different keys for different participants; and supports process manager smart contract deployment to Ethereum-based blockchains.
%We made a GUI application called WFGUI (WorkFlow GUI) to fully integrate my approach into a tool. We implemented it in Kotlin (as with the rest of the parts) with the TornadoFX library (Kotlin wrapper for JavaFX).

%The GUI itself is separated into three different tabs. One for modelling, one for testing, and the last for deploying and operating.

\subsection{Testing}
We assembled a suite of \textit{simple test cases} and known important \textit{''corner cases''}, based on the test suites accompanying the tools we referred to in section \ref{sec:procorch}. These can be found in the code repository.

BPMN model size and complexity influence zkWF program size and complexity, which, in turn, determine proof computation times and on-chain verification costs. Consequently, to demonstrate the practical feasibility of our approach, as a \textit{representative test case}, we used an anonymized version of a car leasing process model we created in the ''Digitisation, artificial intelligence
and data age workgroup'' of the ongoing BME-MNB cooperation project. (MNB is the Hungarian National Bank.) The process involves four participants -- client, dealer, leasing company, and commercial bank -- and the model has 68 vertices and 69 edges. The representative process model is included in the repository, where a demonstrational video is also available.

Not only is this process model representative, we argue that real-life use cases will not necessarily involve much larger models. Significantly larger models are usually transformed into hierarchical process models in the practice -- and, while in this paper we have not addressed this question yet, there is a clear path from the current solution towards a set of process manager smart contracts, which collectively manage the state commitments of a process hierarchy and remain efficient from the point of view of proof generation and verification costs.

The test cases are executed by a custom test scenario runner framework, which has a CLI interface (for CI/CD pipeline integration) in addition to its integration into WFGUI. 


%\begin{figure*}
%  \includegraphics[width=\textwidth,keepaspectratio]{img/leasing.png}
%  \caption{Leasing model}
%\end{figure*}


%To make sure this method of executing business processes is correct, We propose a few ways of challenging it.
%\subsection{Test cases}
%Our first method of testing our approach is by defining test cases and seeing if they can be used in our tool.
%\subsubsection{Simple \& corner cases}
%These test cases were designed to ensure that every supported element works. We also wanted to know how the program reacts to corner cases where the model syntax is correct but the semantics are questionable.
%\subsubsection{Representative test}
%As a Representative test, We wanted to use a complex, real-world example BPMN model. The goal is to see how the program reacts to more oversized state objects (e.g., more executable events, messages, etc.).

%\subsubsection{Testing framework}
%\label{testing_frame}
%To run these tests We designed a testing framework. This framework can run individual test scenarios (i.g. separate steps) and run them as a batch.

%The framework also has a GUI and CLI interface. The GUI can be accessed from WFGUI. The CLI interface is designed to work without user interaction. This makes it easy to integrate as a CI/CD pipeline.
