\section{zkWF programs and their construction}
%We first introduce our mapping logic of BPMN models to zkWF programs. As zkWF programs represent process \textit{instances}, we also describe our state representation approach. This is one of the key contributions of our work; the state commitment scheme of the zkWF protocol is built on this basis.

%\subsection{zkWF program design}
%The zkWF program construction is a central contribution of this paper. It is generated for each BPMN model and used to generate zero-knowledge proofs.

Informally, a zkWF program is the vehicle with which process participants prove that no ''illegal'' moves -- in terms of the agreed-upon rules and current state of the process -- are being proposed as a business process step. It is a program shared by the participants for a given process instance and used for creating ZKPs about the state updates they submit to the process manager smart contract.

As a ZoKrates program, a zkWF program has public as well as private inputs, and an output. Private inputs are only visible to the prover. Public inputs are visible to the prover as well as the verifier, and they are necessary to verify proofs (in our context, the process manager smart contract performs the proof verification). %Outputs are similar to public inputs, but the user does not supply these; they are the results of the executed program with some private and public inputs.

In general terms, the computation happens against a current public process state commitment, stored by the managing smart contract, which is the hash of the current process state, salted by some randomness. This ensures that parties outside the collaboration can't easily guess states from their hash commitments. The computation also relies on the knowledge of the current state and the randomness used for salting the commitment of the current state -- these are shared between the collaborating parties in an encrypted form through the smart contract. 

However, due to computational limitations, the congruence of this cipertext to the public state commitment is not a part of the ZKP scheme. For this reason, part of the public input (also tracked by the smart contract) is a \textit{signature commitment}: the current hash commitment and the \textit{previous} hash commitment signed by the last acting party (using their application-level EdDSA identity).

Should a participant erroneously or maliciously commit a ciphertext which does not hash to the stated, proven and accepted commitment, this signature ensures that the offending participant can be irrepudiably identified by the other collaborating parties. The zkWF program contains the public keys of the participants for the purposes of the collaboration, thus, proofs are able to imply that a signature commitment was done with the same public key that authorized a party to make an authorized state update. The identity of the party who made the update can be recovered from the participant-tied public keys (known to the collaborators) and the signature commitment. A number of mitigative and corrective schemes are possible for such cases, but these fall outside the scope of the current paper. Further details on the state commitment management protocol are given in section \ref{protocol}.

\subsection{zkWF computation model}
\input{content/tikz-figure/zkwf_program_design}

Figure \ref{fig:zkwfProgram} illustrates the basic computational approach. Hashing is used heavily; from the selection of hashing algorithms in the standard library of ZoKrates, we currently use SHA-256. The \textit{private} inputs of zkWF programs are as follows.

\begin{itemize}
	\item $\scurr$ - the current state of the process
	\item $\rcurr$ - randomness for hashing $\scurr$ (32 bits)
	\item ${\snew}$ - the updated (''stepped'') process state
	\item $\rnew$ - new randomness, for hashing $\snew$
	\item $\pk$ - public EdDSA key of the participant
	\item $\sk$ - private EdDSA key of the participant
\end{itemize}

\smallskip

\noindent In turn, the \textit{public} inputs of the program are as follows. The symbol $\Vert$ denotes concatenation.
\begin{itemize}
	\item $\hcurr =\textit{hash}(\scurr || \rcurr)$
        \item $\Snew=\textit{sig}(\hcurr||\hnew)$	
        %\item $\Snew$ - ($\hcurr \Vert \hnew$), signed by the currently\todo{Cross-check, hogy nem ostobas√°g-e a last acting helyett currently actinget mondani.} acting participant.
\end{itemize}

\smallskip

\noindent $hash$ denotes hashing, $sig$ denotes signing by the party who is proposing the new hash commitment in the concatenation. Based on these inputs, with reference to Figure \ref{fig:zkwfProgram}, the computation can be broken down into the following major phases.

\begin{enumerate}
    \item \textit{''Checking the hash''}. Checking the group-shared secret current state and randomness against the public hash commitment to ensure ongoing integrity. %The zkWF program also checks the signature on the concatenation of the current and proposed commitments.
    \item \textit{''Checking vector update validity''}. Checking that no illegal state transition is being proposed through $\snew$ at the \textit{application logic} level (as specified by the BPMN model).
    \item \textit{''Authorization''}. %The zkWF program also ingests the participant's public and private key pair ($\pk$ and $\sk$) as a private input. These are used to 
    Checking the new signature commitment given as a public input (based on $pk$ and $sk$) %, to ensure that the participant has the correct key pair, to be signed by the acting participant 
    and checking the authorization of the participant for the business process step.
    \item The program outputs the hash of the new state $\hnew=\textit{hash}(\snew||\rnew)$.
\end{enumerate}

Most aspects of the computational model are straightforward; for further details, the reader is kindly referred to the full report and the implementation. We only expand on some important aspects of the BPMN model encoding and the logic for checking BPMN state change validity.

%The hash of the current state ($\hcurr$) should be supplied by the process manager smart contract to the zkWF program. This ensures the integrity of the current state.

%and generates a zero-knowledge proof.

%\subsection{State representation}

%\subsubsection{Proving scheme}
%\label{scheme}
%The zkWF program needs to prove that
%\begin{itemize}
%	\item hashing the current state and the randomness results in the hash given as public input,
%	\item the proposed state update is valid in the BPMN process,
%	\item the pubic key provided is authorized for this task
%	\item and the participant own the corresponding  private key.
%\end{itemize}

\subsection{BPMN model encoding}
\label{encoding}
The BPMN logic is fundamentally carried over into the zkWF program through a precomputed $P$ array. Additionally, to check whether the right paths are proposed for exclusive gateways, the expressions on the sequence flows after the gateways are also encoded in the program as assertions. Message passing and variable write permission checks are addressed similarly.

%Messages can only be sent in the proper intermediate message throw event and Messages cannot be sent before they were sent. Similarly, variables can only be written when permission is given to the activity currently performed.


%\subsection{ZKP framework}
%To implement zkWF programs, We chose Zokrates 
%(see \ref{zokrates}) 
%because this seemed like the most advanced solution at the time of writing. It also makes it easy to generate a verifier smart contract which would be tedious to write manually. We used ZoKrates version \href{URL}{0.7.13} at the time. It is the latest version at the time of writing.

%It is necessary to mention this here because the prover method relies heavily on this toolkit.
%\subsection{Tracking BPMN execution with a zkWF program}

\subsection{BPMN state change validity check}
%We have introduced the inputs and outputs of the zkWF programs; described the core approach for encoding BPMN models; and specified the ZKP framework to use. 

%In this section, we discuss the main steps of zkWF programs, as also identified on Figure \ref{fig:zkwfProgram}. 

%\subsubsection{Checking the supplied hash}
%\label{checking_hash}
%The hash of the current state and its corresponding randomness must be the hash present in the smart contract. This step ensures the integrity of the business process execution.

%\subsubsection{Proving that a state vector update is valid}
%\label{method}
%This proving process step ensures that a proposed step is valid in the BPMN model.

The zkWF program compares $v_{current}$ and $v_{new}$ from $s_{current}$ and $s_{new}$. If the two are the same, the ''change'' is accepted (as a ''step'' under the fake update mechanism). Four or more differences (pairwise comparisons at the same indices) in the vectors are considered invalid. Otherwise, we construct a $3\times3$ matrix $A$ with the initial value

\begin{align}
A = \begin{bmatrix}
		0 & -1 \\ 0 & -1 \\ 0 & -1
\end{bmatrix}
\end{align}

Then, for the $j$-th difference ($j \in 0\ldots 2$) at position $i \in [0,|T|[$ in the vectors, we apply the following updates to $A$:

\begin{itemize} 
        \item $v_{current}[i] = 1 \And v_{new}[i] = 2 \Rightarrow A[j] \leftarrow [-1,i]$
        \item $v_{current}[i] = 0 \And v_{new}[i] = 1 \Rightarrow A[j] \leftarrow [1,i]$
        \item $v_{current}[i] = 0 \And v_{new}[i] = 2 \Rightarrow A[j] \leftarrow [1,i]$
\end{itemize}

Any other combination of $v_{current}$ and $v_{new}$ values is immediately considered invalid. After matrix $A$ is constructed, we compare each element in the array $P$ to matrix $A$. If we find an element in $P$ that contains every row in matrix $A$ (in any order), the vector change is considered valid. 

%It constructs a new matrix $A$ in the following way:
%\begin{enumerate}
%	\item At first,take matrix $A$ as $\begin{bmatrix}
%		0 & -1 \\ 0 & -1 \\ 0 & -1
%	\end{bmatrix}$ (no changes) and $j=0$ as a counter
%	\item Compare every $v_{old}[i]$ and $v_{new}[i]$, where $i\in [0,T[$ 
%	\begin{itemize} 
%			\item If $v_{old}[i] = 1$ and $v_{new}[i] = 2$, replace $A[j]$ with $[-1,i]$
%			\item If $v_{old}[i] = 0$ and $v_{new}[i] = 1$, replace $A[j]$ with $[1,i]$
%			\item If $v_{old}[i] = 0$ and $v_{new}[i] = 2$, replace $A[j]$ with $[1,i]$ 
%			\item If none of the above are true, but $v_{old}[i] \neq v_{new}[i]$ , replace $A[j]$ with $[-1,-1]$ (invalid change) 
%			\item If $v_{old}[i] \neq v_{new}[i]$ then increase $j$ by one
%		\end{itemize}
%\end{enumerate}

%Zero changes are also considered valid. This makes it easy to generate "fake" state changes: the process state in the smart-contract changes, but in reality, the state vector does not. This can be useful to mask the current state of the process execution. %See section \ref{hashing_reason} for more details.

%Four or more changes in the process state are considered invalid. % The reason behind it is described in section \ref{paralhell}.

%\paragraph{Problem with parallel gateway ends}
Parallel gateway ends induce an additional check. Before a parallel gateway end, two active tasks can exist with two different participants. Because of this, one task can be marked as ''completed'' without marking the task after the parallel gateway as ''active''. After both tasks before the parallel gateway are marked as ''completed'', the executable event on the other end of the gateway must be marked as ''active'' to continue the token flow.

%\paragraph{Variable write permission}
%\label{variable_permission}
The state change validity check also includes checking write permissions for global variables and contrasts the evaluation of arithmetic expressions with the proposed path for exclusive gateways.
%The program must ensure that the global variables can only change in the tasks that have the write permissions for that specific variable. This is done in our custom BPMN attributes described in section \ref{bpmn_attr}.

%\paragraph{Exclusive gateway validation}
%\label{exclusive_assert}
%After the state's task vectors are validated, We need to ensure that the right path was chosen after the start of an exclusive gateway. This is why the arithmetic expression on the chosen edge is evaluated. 

%\paragraph{Message validation}
%\label{message_hash}
Finally, the message-handling validation logic involves two major checking aspects. On the one hand, each time a participant wants to mark a Message Throw event as ''completed'', a message hash has to be uploaded. We assume the actual message to be passed off-chain. On the other hand, each time a participant wants to mark a Message Catch event as ''completed'', we need to make sure that the corresponding Message Throw event is also marked as completed (likely by another participant). Contrasting the received message with the hash value has to be done by the receiver; if this fails, we assume that the corresponding steps are codified in the process logic.

%\paragraph{Pseudo code}
%\todo{ref} includes detailed pseudo-code for the state change validity check.

%\subsubsection{Authorisation}
%\label{authorisation}
%To authorize a participant, the program proves that the participant has the private key, which corresponds to the task's specified public key. 

%The program also proves that the signature supplied as public input can be decrypted with that public key. The signed message has to be the hash of the previous state (with the randomness) and the hash of the new, proposed state (with a new random number). This signature is then stored in the smart contract.

%An EdDSa implementation is available in the Zokrates standard library. It can verify that a party has a private key with a corresponding public key and verify signatures.