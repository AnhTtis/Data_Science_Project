\section{A confidentiality-preserving approach}
\label{sec:conf}
The fundamental difference of our approach from \cite{caterpillar,chorchain,multichain,flexchain,lorikeet,Mercenne_Brousmiche_Hamida_2018,Abid_Cheikhrouhou_Jmaiel_2020} is that instead of storing the process state on-chain in an easily interpretable form in an orchestrator smart contract, we store encrypted states and cryptographic state commitments and accept update proposals on the presentation of ZKPs over the current and proposed commitment. The approach relies on two key conceptual components: our zkWF (''zero knowledge WorkFlow'') protocol and what we call ''zkWF programs''.

\subsection{The zero-knowledge WorkFlow (zkWF) protocol}
\label{subsec:prot}
The zkWF protocol is a hash commitment style protocol that allows the participants of a business process to follow and step the execution of a business process. Figure \ref{fig:basic_update} presents a high-level overview.

%\input{content/tikz-figure/overview}
\begin{figure}
\centering
\includegraphics[width=0.75\columnwidth]{img/4_PDFsam_TiKZ.pdf}
    \caption{Overview of the zkWF protocol}
    \label{fig:basic_update}
\end{figure}

During process execution, the collaborating parties can send messages to each other by off-chain means. These are captured in the underlying process specification as intermediate message throw and capture events; our commitment scheme includes commitments to the message hashes. When a participant wishes to update the state stored in the smart contract -- that is, to ''step the process'' --, it has to create a ZKP that the proposed state transition is valid. This new state includes the hash of the message they sent beforehand if the step involves message sending. When the execution arrives at a point where a participant receives a message in the next stage of the execution, the receiving party checks the hash and only accepts if the hashes match.

Participant authentication is tied to proving private key ownership in the ZKPs. The public keys are defined over the participant group-shared process model as a parameterization. These are cooperation-private, ''application-level'' key pairs; on pseudonymizing platforms, such as Ethereum, updater identity can and should be masked by using independent, single-use transaction source addresses (i.e., public keys).
%On pseudonymizing platforms, such as Ethereum, it also facilitates masking updater identity as single-use transaction source addresses (i.e., public keys) can be used independently of the cooperation-private keypair used ''at the application level''.

Additionally, we require the participants to have a common means for encrypting and decrypting stored state ciphertexts. The protocol does not constrain the encryption used.

The protocol can be realized straightforwardly on a wide range of DLTs; we provide an implementation for Ethereum and Hyperledger Fabric ~\cite{hyperledger_fabric}.  While the updates and the contract state are unintelligible to parties outside the collaboration, statistical and model trace analyses of the update sequences are still a threat. We enable mitigations by including a ''fake'' update transaction variant (no actual state update), which all participants are authorized to use.

\subsection{zkWF programs}
zkWF programs are generated from BPMN specifications and serve as a bridge between process definition and proof computation/verification. A zkWF program is a ZoKrates program that, for a given BPMN model instance (parameterized model), can decide whether a given actor is authorized to execute a state transition in a given execution state. We use the zkWF program to generate the zero-knowledge proofs and proof verification code for the orchestrator smart contract.

\subsection{Workflow and toolchain}
We created an end-to-end toolchain prototype for our approach, as depicted in Figure~\ref{fig:vezerabra}. The figure also identifies the newly created software components and the artefacts with novel generators.

In the \textit{modeling phase}, a BPMN model is annotated with metadata for process instantiation, and our Kotlin-based interpreter-translator creates the corresponding zkWF program.

In the \textit{synthesis phase}, the ZoKrates toolkit is used to set up the \textit{prover key} and \textit{verifier key} and generates the verifier smart contract in Solidity. We created novel support for generating verifier code for Hyperledger Fabric in Java. We also created the code generation facilities for both platforms' state commitment management part of the smart contracts.

Some secret values used when creating zk-SNARK prover and verifier keys are considered ''toxic waste'': an adversary can use them to break the scheme, e.g., forge fake proofs. Thus, security relies on the waste having been deleted. The risk associated with the waste can be mitigated by using a reliable party for the key generation or performing so-called multi-party trusted setup ceremonies, where a (large) group of actors assembles the keys. In this case, security requires only at least one of them actually to delete the waste. Such ceremonies tend to be complicated and thus can pose a problem for by-program setup. Universal schemes also exist (e.g.,~\cite{cryptoeprint:2019/1047}), where the results of a single program-agnostic ceremony can be used to derive program-specific keys publicly and securely. Choosing the right approach requires deployment-specific risk analysis; ZoKrates supports all the above.%, and consequently, our implementation does, too. We do note that currently, we require a setup for each process instance.

For the \textit{deployment phase}, we created automation facilities for deployment to Ethereum (and other blockchains using a compatible RPC API); and an SDK and GUI application for the client side. Here, we integrate the ZoKrates toolkit as a proof generator.

\noindent
\input{content/tikz-figure/vezer}

%is key-authorized process state changes to be possible only in terms of the smart contract state commitment and stored encrypted state. 
%Note that this goal carries over from the existing state of the art.

%Our \textit{availability goal} is no process external party to stop

%In this paper, we assume the following properties may apply for a given attacker:


%\begin{itemize}
%\item An attacker knows the corresponding BPMN model for a given smart contract instance
%\item A malicious participant may also be an attacker
%\end{itemize}

%Our approach aims at ensuring the following security guarantees.
%\todo{Ezeket befelyezni}
%\begin{itemize}  
% \item Parties not participating cannot modify the state stored on the blockchain
% \item Parties not participating cannot read or guess the current state of the business process execution based on the data stored in the smart contract. 
%\item No party can make an illegal move during the orchestration.
%\item Messages between the participants can be verified.
%\item Participants can identify which party made a given move 
%\end{itemize}