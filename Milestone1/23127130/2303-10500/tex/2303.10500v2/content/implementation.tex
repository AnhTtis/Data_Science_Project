\section{Implementation, testing and performance}
%This section describes how we implemented the zkWF programs and how we integrated the zwWF protocol to our tool.
%\subsection{zkWF implementation}
%This section describes how the zkWF program was implemented in ZoKrates.
%\subsubsection{ZKP framework}
The ZoKrates toolkit is a central component in our framework; the current implementation uses version {0.7.13}\footnote{See \url{https://github.com/Zokrates/ZoKrates/releases}}. ZoKrates was the ZKP toolkit with the best-fitting programming language and scheme support during our research. %Although this still holds, the state of the art advances rapidly\footnote{A not peer-reviewed, but regularly maintained and curated overview can be found at: \url{https://github.com/matter-labs/awesome-zero-knowledge-proofs}}; we expect that in the future, we will have to reevaluate the available frameworks for our purposes.

%To implement zkWF programs, We chose Zokrates because this seemed like the most advanced solution at the time of writing. It also makes it easy to generate a verifier smart contract which would be tedious to write manually. We used ZoKrates version \href{URL}{0.7.13} at the time. It is the latest version as of writing this.

\subsection{Code generation}
Our code generator, implementing the transformation logic denoted on Figure~\ref{fig:zkwfProgram}, is a custom development in Kotlin. This component generates a zkWF program from an XML-serialized BPMN model, relying on ZoKrates template files. First, the model is encoded, as we outlined earlier; then, it generates the code for the described stages of computation and checks.% code for calculating the state hashes, checking the variable write permissions, ensuring exclusive gateway paths, and verifying message sending. %Distribution and validation of the resulting zkWF program among the process participants are not covered by the framework. 
 We also generate the orchestrator smart contracts for EVM-based blockchains (Solidity version {0.8.0}) and Hyperledger Fabric (Java ''chaincode''). %Solidity smart contracts are derived from the verifier smart contracts ZoKrates generates for zkWF programs; Fabric ones do not have a precursor. In Fabric, smart contracts -- ''chaincodes'' -- run in Docker containers. We created a custom chaincode container, where the chaincode and the ZoKrates toolkit (for proof verification) are bundled together.

%\section{Smart contract implementation}
%To make our approach less dependent on one technology, We implemented the process manager smart contract for two distributed ledger systems: Ethereum and Hyperledger Fabric.
%\subsection{EVM}
%The process manager smart contract (see section \ref{smartcontract}) is implemented in Solidity version 0.8.0. It is derived from a Verifier smart contract generated by ZoKrates.

%\subsection{Hyperledger Fabric}
%\label{fabric_verifier}
%ZoKrates can only generate smart contract verifiers in Solidity. Fortunately,  Hyperledger Fabric chaincodes run in standard docker containers and are written in traditional programming languages like Java. This means we can use the ZoKrates by executing the commands in the container with a ProcessBuilder class.

%The rest of the smart contract implementation is analogue to the Solidity one.

\subsection{Client side}
We created a simple participant-side SDK, which wraps ZoKrates and incorporates the Web3J wallet library. We also created a TornadoFX-based desktop GUI application (''WorkFlow GUI'') for testing and demonstration purposes. The GUI supports all key participant-side actions: monitoring a process manager smart contract for changes, retrieving state, creating process step proposals, computing their witnesses and proofs, and submitting update proposals.

WFGUI also incorporates a process modeller for our BPMN subset and extensions through an embedding of bpmn-js\footnote{See \url{https://bpmn.io/toolkit/bpmn-js/}}; supports testing through preassembled smart contract call sequences; and supports process manager smart contract deployment to Ethereum-based blockchains. A demonstrational video is available in our repository.
%We made a GUI application called WFGUI (WorkFlow GUI) to fully integrate my approach into a tool. We implemented it in Kotlin (as with the rest of the parts) with the TornadoFX library (Kotlin wrapper for JavaFX).

%The GUI itself is separated into three different tabs. One for modelling, one for testing, and the last for deploying and operating.

\subsection{Functional testing}
We assembled a suite of \textit{simple test cases}, %and known important \textit{''corner cases''}
based on the test model suites of the tools cited in Section \ref{sec:procorch}. BPMN model size and complexity influence zkWF program size and complexity, which, in turn, determine proof computation times and on-chain verification costs. To evaluate the practical feasibility of our approach, the leasing model from Section \ref{sec:motiv} was used as our \textit{representative test case}.  %in the practice -- and, while in this paper we have not addressed this question yet, there is a clear path from the current solution towards a set of process manager smart contracts, which collectively manage the state commitments of a process hierarchy and remain efficient from the point of view of proof generation and verification costs.

%The test cases are executed by a custom test scenario runner framework, which has a CLI interface (for CI/CD pipeline integration) in addition to its integration into WFGUI. 


%\begin{figure*}
%  \includegraphics[width=\textwidth,keepaspectratio]{img/leasing.png}
%  \caption{Leasing model}
%\end{figure*}


%To make sure this method of executing business processes is correct, We propose a few ways of challenging it.
%\subsection{Test cases}
%Our first method of testing our approach is by defining test cases and seeing if they can be used in our tool.
%\subsubsection{Simple \& corner cases}
%These test cases were designed to ensure that every supported element works. We also wanted to know how the program reacts to corner cases where the model syntax is correct but the semantics are questionable.
%\subsubsection{Representative test}
%As a Representative test, We wanted to use a complex, real-world example BPMN model. The goal is to see how the program reacts to more oversized state objects (e.g., more executable events, messages, etc.).

%\subsubsection{Testing framework}
%\label{testing_frame}
%To run these tests We designed a testing framework. This framework can run individual test scenarios (i.g. separate steps) and run them as a batch.

%The framework also has a GUI and CLI interface. The GUI can be accessed from WFGUI. The CLI interface is designed to work without user interaction. This makes it easy to integrate as a CI/CD pipeline.
