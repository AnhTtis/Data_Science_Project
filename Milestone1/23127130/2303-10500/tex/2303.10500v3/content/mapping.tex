\section{zkWF program and protocol design}
\label{sec:design}
%We first introduce our mapping logic of BPMN models to zkWF programs. As zkWF programs represent process \textit{instances}, we also describe our state representation approach. This is one of the key contributions of our work; the state commitment scheme of the zkWF protocol is built on this basis.

%\subsection{zkWF program design}
%The zkWF program construction is a central contribution of this paper. It is generated for each BPMN model and used to generate zero-knowledge proofs.

A zkWF program is a ZoKrates program shared among the participants, with which process participants prove that a business process state transition they propose is allowed. In ZKP terms, the participants are the \textit{provers}, and the orchestrator smart contract is the \textit{verifier}. %The smart contract stores cryptographic state commitments and an encrypted version of the state and manages their updates.

ZoKrates programs have public as well as private inputs, and an output. Private inputs are only visible to the prover; public inputs are visible to the prover and the verifier, and they are necessary to verify proofs. In our case, the current commitment and the proposed one act as public inputs. Private inputs are more varied; only some are shared across the participants (e.g., the cleartext of the current state).%, and some are specific to the individual participants.

%zkWF programs have public as well as private inputs, and an output. Private inputs are only visible to the respective prover. Public inputs are visible to the prover as well as the verifier, and they are necessary to verify proofs.  %Outputs are similar to public inputs, but the user does not supply these; they are the results of the executed program with some private and public inputs.

%In general terms, the computation happens against a current public process state commitment, stored by the managing smart contract, which is the hash of the current process state, salted by some randomness. This ensures that parties outside the collaboration can't easily guess states from their hash commitments. The computation also relies on the knowledge of the current state and the randomness used for salting the commitment of the current state -- these are shared between the collaborating parties in an encrypted form through the smart contract. 

The key current deficiency of our scheme is that our proofs do not include showing the congruence of the on-chain stored state ciphertexts and the public state (hash) commitments. Combining established encryption algorithms with zk-SNARKs is hard; advances are being made (see, e.g., \cite{cryptoeprint:2019/1270}), but these haven't appeared in any of the leading zk-SNARK frameworks yet as vetted and reusable ''gadgets''.%, in stark contrast to other primitives, e.g., hash and signature algorithms.

We apply the following measures to this deficiency. An additional part of our public input (and blockchain-stored data) will be a \textit{signature commitment}: the current hash commitment and the \textit{previous} hash commitment signed by the last acting party (using their application-level cryptographic identity). Should a participant erroneously or maliciously commit a ciphertext that does not hash to the stated, proven and accepted commitment, this signature ensures that the offending participant can be irrepudiably identified by the other collaborating parties. 

Although several partially mitigative and corrective schemes can be built on this measure, we introduce the weakening assumption that the irrepudiable identifiability of participants halting execution this way is a sufficient disincentive.

\subsection{zkWF computation model}
%\input{content/tikz-figure/zkwf_program_design}
\begin{figure}
\centering
\includegraphics[width=0.7\columnwidth]{img/pdf_TiKZ.pdf}
\caption{The basic computation model of zkWF programs}
\label{fig:zkwfProgram}
\end{figure}

Figure \ref{fig:zkwfProgram} illustrates the structure of the generated zkWF programs. For hashing, we use SHA-256; application-level signing uses the EdDSA implementation from the ZoKrates standard library (both widely used, NIST-standard algorithms). The \textit{private} inputs of zkWF programs are as follows.

\begin{itemize}
	\item $\scurr$ - the current state of the process (subsec. \ref{subsec:staterep})
	\item $\rcurr$ - random salt for hashing $\scurr$ (32 bits)
	\item ${\snew}$ - the updated (''stepped'') process state
	\item $\rnew$ - new randomness, for hashing $\snew$
	\item $\pk$ - public EdDSA key of the participant (subsec. \ref{subsec:prot})
	\item $\sk$ - private EdDSA key of the participant
\end{itemize}

\smallskip

\noindent The \textit{public} inputs ($\Vert$ denotes concatenation):
\begin{itemize}
	\item $\hcurr =\textit{hash}(\scurr || \rcurr)$
        \item $\Snew=\textit{sig}(\hcurr||\hnew)$	
        %\item $\Snew$ - ($\hcurr \Vert \hnew$), signed by the currently\todo{Cross-check, hogy nem ostobas√°g-e a last acting helyett currently actinget mondani.} acting participant.
\end{itemize}

\smallskip

\noindent $sig$ denotes signing by the party proposing the new hash commitment in the concatenation. Given these inputs, the following steps are performed.

\begin{enumerate}
    \item Checking the group-shared secret current state and randomness against the public hash commitment to ensure ongoing integrity. %The zkWF program also checks the signature on the concatenation of the current and proposed commitments.
    \item Checking that no illegal state transition is being proposed through $\snew$ at the \textit{process logic} level.
    \item Checking the new signature commitment given as a public input (based on $pk$ and $sk$) %, to ensure that the participant has the correct key pair, to be signed by the acting participant 
    and checking the authorization of the participant for the business process step.
    \item The program outputs the hash of the new state.
\end{enumerate}

Most aspects of the computational model are straightforward; we only expand on the important details of BPMN model encoding and the state change validity checking logic.

%The hash of the current state ($\hcurr$) should be supplied by the process manager smart contract to the zkWF program. This ensures the integrity of the current state.

%and generates a zero-knowledge proof.

%\subsection{State representation}

%\subsubsection{Proving scheme}
%\label{scheme}
%The zkWF program needs to prove that
%\begin{itemize}
%	\item hashing the current state and the randomness results in the hash given as public input,
%	\item the proposed state update is valid in the BPMN process,
%	\item the pubic key provided is authorized for this task
%	\item and the participant own the corresponding  private key.
%\end{itemize}

%\subsection{BPMN model encoding}
%The BPMN model logic is carried over into the zkWF program by a precomputed $P$ array (subsec. \ref{subsec:parray}). Additionally, to check whether the right paths are proposed for exclusive gateways, the expressions on the sequence flows after the gateways are also encoded in the program as assertions. Message passing and variable write permission checks are addressed similarly.

%Messages can only be sent in the proper intermediate message throw event and Messages cannot be sent before they were sent. Similarly, variables can only be written when permission is given to the activity currently performed.


%\subsection{ZKP framework}
%To implement zkWF programs, We chose Zokrates 
%(see \ref{zokrates}) 
%because this seemed like the most advanced solution at the time of writing. It also makes it easy to generate a verifier smart contract which would be tedious to write manually. We used ZoKrates version \href{URL}{0.7.13} at the time. It is the latest version at the time of writing.

%It is necessary to mention this here because the prover method relies heavily on this toolkit.
%\subsection{Tracking BPMN execution with a zkWF program}

\subsection{BPMN model encoding and state change validation}
\label{subsec:encode}
The BPMN model logic is carried over into the zkWF program by a precomputed $P$ array (Section \ref{subsec:parray}). To check whether the correct paths are proposed for exclusive gateways, the expressions on the sequence flows after the gateways are also encoded in the program as assertions. Message passing and variable write permission checks are addressed similarly.

%We have introduced the inputs and outputs of the zkWF programs; described the core approach for encoding BPMN models; and specified the ZKP framework to use. 

%In this section, we discuss the main steps of zkWF programs, as also identified on Figure \ref{fig:zkwfProgram}. 

%\subsubsection{Checking the supplied hash}
%\label{checking_hash}
%The hash of the current state and its corresponding randomness must be the hash present in the smart contract. This step ensures the integrity of the business process execution.

%\subsubsection{Proving that a state vector update is valid}
%\label{method}
%This proving process step ensures that a proposed step is valid in the BPMN model.

Regarding the executable element state vector, the program compares $v_{current}$ and $v_{new}$ from $s_{current}$ and $s_{new}$. If the two are the same, the ''change'' is accepted (as a ''step'' under our fake update mechanism). Four or more differences (pairwise comparisons at the same indices) in the vectors are considered invalid. Otherwise, we construct a $3\times3$ matrix $A$ with the initial value

\begin{align}
A = \begin{bmatrix}
		0 & -1 \\ 0 & -1 \\ 0 & -1
\end{bmatrix}
\end{align}

Then, for the $j$-th difference ($j \in 0\ldots 2$) at position $i \in 0 \ldots |T|-1$ in the vectors, we apply the following updates:

\begin{itemize} 
        \item $v_{current}[i] = 1 \And v_{new}[i] = 2 \Rightarrow A[j] \leftarrow [-1,i]$
        \item $v_{current}[i] = 0 \And v_{new}[i] = 1 \Rightarrow A[j] \leftarrow [1,i]$
        \item $v_{current}[i] = 0 \And v_{new}[i] = 2 \Rightarrow A[j] \leftarrow [1,i]$
\end{itemize}

Any other combination of $v_{current}$ and $v_{new}$ values is invalid. If $P$ contains an element with the rows of $A$, then token passing-wise, the proposed state change is valid, as we essentially decoded the activity token marking changes ($\pm1$) from the activity state changes: 0 - Inactive $\rightarrow$ 1 - Active $\rightarrow$ 2 - Completed.

%It constructs a new matrix $A$ in the following way:
%\begin{enumerate}
%	\item At first,take matrix $A$ as $\begin{bmatrix}
%		0 & -1 \\ 0 & -1 \\ 0 & -1
%	\end{bmatrix}$ (no changes) and $j=0$ as a counter
%	\item Compare every $v_{old}[i]$ and $v_{new}[i]$, where $i\in [0,T[$ 
%	\begin{itemize} 
%			\item If $v_{old}[i] = 1$ and $v_{new}[i] = 2$, replace $A[j]$ with $[-1,i]$
%			\item If $v_{old}[i] = 0$ and $v_{new}[i] = 1$, replace $A[j]$ with $[1,i]$
%			\item If $v_{old}[i] = 0$ and $v_{new}[i] = 2$, replace $A[j]$ with $[1,i]$ 
%			\item If none of the above are true, but $v_{old}[i] \neq v_{new}[i]$ , replace $A[j]$ with $[-1,-1]$ (invalid change) 
%			\item If $v_{old}[i] \neq v_{new}[i]$ then increase $j$ by one
%		\end{itemize}
%\end{enumerate}

%Zero changes are also considered valid. This makes it easy to generate "fake" state changes: the process state in the smart-contract changes, but in reality, the state vector does not. This can be useful to mask the current state of the process execution. %See section \ref{hashing_reason} for more details.

%Four or more changes in the process state are considered invalid. % The reason behind it is described in section \ref{paralhell}.

%\paragraph{Problem with parallel gateway ends}
Parallel gateway ends (''joins'') induce an additional check: a transition from a state where \textit{not both activities before the gateway are completed} to one where \textit{both are} also requires that the activity after the gateway gets activated. State change validation also includes checking write permissions for global variables and contrasts the evaluation of arithmetic expressions with the proposed path for exclusive gateways.

%\paragraph{Variable write permission}
%\label{variable_permission}

%The program must ensure that the global variables can only change in the tasks that have the write permissions for that specific variable. This is done in our custom BPMN attributes described in section \ref{bpmn_attr}.

%\paragraph{Exclusive gateway validation}
%\label{exclusive_assert}
%After the state's task vectors are validated, We need to ensure that the right path was chosen after the start of an exclusive gateway. This is why the arithmetic expression on the chosen edge is evaluated. 

%\paragraph{Message validation}
%\label{message_hash}
Finally, the message-handling validation logic involves two major validation aspects. First, a message hash must be provided when a participant wants to mark a Message Throw event as ''completed''. We assume the actual message to be passed off-chain. Second, when a participant wants to mark a Message Catch event as ''completed'', we must ensure that the corresponding Message Throw event is also marked as completed. The receiver contrasts the message with the hash value; if this fails, we assume that the further steps are either captured in the process logic or the sender and receiver coordinate corrective transmission off-chain. %Contrasting the received message with the hash value has to be done by the receiver; if this fails, we assume that the corresponding steps are either captured in the process logic or the sender and receiver coordinate corrective transmission off-chain.

%\paragraph{Pseudo code}
%\todo{ref} includes detailed pseudo-code for the state change validity check.

%\subsubsection{Authorisation}
%\label{authorisation}
%To authorize a participant, the program proves that the participant has the private key, which corresponds to the task's specified public key. 

%The program also proves that the signature supplied as public input can be decrypted with that public key. The signed message has to be the hash of the previous state (with the randomness) and the hash of the new, proposed state (with a new random number). This signature is then stored in the smart contract.

%An EdDSa implementation is available in the Zokrates standard library. It can verify that a party has a private key with a corresponding public key and verify signatures.
