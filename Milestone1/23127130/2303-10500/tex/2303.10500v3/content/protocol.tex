\subsection{The zkWF protocol}
\label{protocol}
%The zkWF protocol largely follows the general ''proofs over commitments and proposed commitment updates'' pattern customary in blockchain applications of ZKPs (as depicted in Figure \ref{fig:basic_update}). The \textit{process manager smart contract} component is fairly simple: on the one hand, it stores and updates commitments, and on the other hand, it checks ZKPs over the new commitments proposed in incoming blockchain transactions. Specifically, the process manager smart contract stores the following data (using the notations introduced earlier):

The protocol flows through the orchestrator smart contract and is simple in light of the earlier sections. The smart contract state contains the following elements:

%\subsubsection{Process manager smart contract design}
%\label{smartcontract}
%This smart contract contains the logic that is executed on the blockchain. It is responsible for the integrity of the business process execution. It must not contain the current state in plain text. It is designed to be relatively simple since most of the computation is off-chain. Figure \ref{fig:sc_design} shows the overall design of this smart contract.

%The process manager smart contract stores the following data:
\begin{itemize}
	\item $\hcurr =\textit{hash}(\scurr || \rcurr)$ %- the hash of the current state and some randomness
	\item $\Ccurr=\textit{enc}(\scurr,\rcurr)$ %- the ciphertext of the current state and the randomness used in the hashing encrypted with a common, predefined key (each participant should have this key)
	\item $\Scurr=\textit{sig}(h_{prev}||\hcurr)$ %-  the previous states' and the current states' hashes concatenated, signed by the last acting participant.
\end{itemize}

\smallskip

\noindent where $enc$ denotes encryption with the group encryption key and method (see Section \ref{sec:conf}). %and $sig$ denotes signing by the party who proposed the second hash commitment in the concatenation (i.e, $\hcurr$). 
Update request transactions of the smart contract carry the following arguments:

%A participant can update these variables with a function. This function has the following arguments but may have others:
\begin{itemize}
    \item $\hnew=\textit{hash}(\snew || \rnew)$ %- the hash of the new state and some randomness 
    \item $\Cnew=\textit{enc}(\snew,\rnew)$ %- the ciphertext of the new state and the randomness used in the hashing encrypted with a common, predefined key (each participant should have this key)
    \item $\Snew=\textit{sig}(\hcurr||\hnew)$ %- a signature from the last acting participant of the process
    %\item $\proof$ - a valid proof generated by the corresponding zkWF program.
    \item $p(\hcurr,\Snew,\hnew)$
\end{itemize}

\smallskip

\noindent The last argument is a ZKP of the correspondence of $\hcurr$, $\Snew$ and $\hnew$, under the shared zkWF program. The orchestrator smart contract checks the validity of this proof before accepting the smart contract state change carried by the other arguments.

\subsection{Side-channel attack protections}
%Public BPMN models enable side-channel attacks with a potentially high probability of success. 
Public BPMN models facilitate side-channel attacks on confidentiality. Our work until now aimed to ensure that the trace steps of the BPMN finite automaton remain unintelligible to the external observer; however, the number and timings of transitions still carry information. Most BPMN models are simple enough to infer a usable probability distribution of possible states and traces from just these observations.

Constant-time execution and delay randomization are two apparent protection options, though both introduce artificial delays. Consider a constant-time token passing ring schedule with dummy operations as our already established scheme. For $n$ participants, we determine a suitable time quantum $t$ with which it is acceptable to wait for $(n-1)t$ to delay the ''posting'' of any state change. During process execution, at the beginning of the $i$-th epoch, participant $i \mod n$ checks whether it needs to send a state update transaction. If yes, it does; if not, it issues a ''fake update'' transaction. After terminating the process, a long fake update stream is advisable. As long as enough participants meet their fake update obligations and adhere to their epochs, external observers only see a heartbeat-like stream of uninterpretable transactions and can determine even the time of termination only with low probability.

\section{Security properties}
The presented approach addresses the security requirements defined in Section~\ref{subsec:prob} as discussed in this section.
\subsection{Integrity}
Property I1 holds in the sense that we carefully implement a strict subset of BPMN semantics, but we acknowledge that future work should create an explicit proof of conformance. I2 holds due to application-level cryptographic authentication; I3 due to cryptographic authentication and the very simple sub-logic of enabling activities and message operations.
\subsection{Availability}
A1 holds due to I2 and the blockchain fairness assumption -- which is mild for high-throughput public and cross-organizational blockchains. A2 holds only under the disincentive assumption of Section~\ref{sec:design}. However, the assumption is not strong for domains with a credible threat of legal or regulatory action (e.g., finance). A participant can also perform a denial of service attack with a constant stream of malicious fake updates. The disincentive assumption applies here, too, but fake update regimen-dependent defences can also be introduced in the smart contract (e.g., epoch schedule enforcement). A3 holds due to a smart contract accounting for state and trace and the blockchain platform assumptions.
\subsection{Confidentiality}
The C1 guarantee has two layers. At the platform level, all transactions can originate from single-use addresses on pseudonymizing platforms -- e.g., Ethereum. In Hyperledger Fabric, the Identity Mixer protocol suite for transactor anonymization and unlinkability can be used similarly. At the application level, transaction payloads and smart contract states contain only hashed, signed and encrypted data. Hashing is straightforward; for the signed content, note that EdDSA signatures do not provide a way to recover the signerâ€™s public key from the signature or to determine whether the same key was used to sign two different messages. For the encrypted state, if not a single, group-shared secret is used, an application should choose an encryption scheme where the participant keys cannot be recovered.

C2 depends on external data and transaction uninterpretability, which flows from the cryptographic measures, and transaction unlinkability, which also relies on the measures for C1. It also requires sufficient side-channel protection, for which we have at least one strong (not necessarily efficient) option.