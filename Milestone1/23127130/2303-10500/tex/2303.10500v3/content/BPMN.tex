\section{BPMN subset and execution semantics}
%\todo{Intro, subset, extensions}
This paper targets the Basic Modeling Elements of BPMN 2.0 \cite[p.~28]{bpmn}, the core subset of the specification, with the restrictions that regarding events, we interpret only message throw and catch ones (among participants) and do not support sub-processes and data objects. We argue that this element set is already sufficient for practical applications. Statistical evidence~\cite{Muehlen2013} shows that the usage frequency of the 50 constructs in the BPMN specification follows a Zipfian distribution; we cover elements used at least in $\sim25\%$ of the models in~\cite{Muehlen2013}. This is also the empirically established ''Common Core of BPMN'' in~\cite{Muehlen2013} with the addition of messaging between participants. Our earlier example showcases the supported element set (except for ''exclusive gateways'' for process variable-based choice paths and ''lanes'' for further subdividing pools).

%Currently, we support a limited but representative set of elements from the BPMN specification, as summarized by table \ref{tab:sup_elem}. Notably, in addition to the Basic Modeling Elements of BPMN 2.0 (see \cite{bpmn}, p28), we also support message throw and catch events, which are of particular importance in collaborative settings. The table denotes those elements as ''stateful'' which have non-instantaneous execution semantics (as declared by the BPMN specification), and these will determine the structure of our execution state vector. In the context of this paper, we will refer to these elements as the ''executable'' ones in the BPMN subset we address.

%Some of the element types are considered executable. Others are there to control the execution flow. Executable elements' (like that of activities) state is tracked by this tool. The currently supported elements can be seen in table \ref{tab:sup_elem}.

%We wanted to support at least the Basic Modeling Elements of BPMN 2.0\footnote{See Business Process Model and Notation, v2.0 \cite{bpmn}, page 28.}  to prioritize common components. We have also taken into account making modeling collaborations more executable. This is why We also included Message flows and Intermediate Message events. We chose these elements because these are the ones that are necessary and sufficient to model most of the relevant use cases.

\subsection{BPMN extensions and structural constraints}
%\label{bpmn_attr}
We introduce two extended attributes for BPMN elements. \texttt{zkp:publicKey} separates the tasks of different participants by attaching a participant-specific public key to a pool, a lane, or a \textit{participant-executable element} (activities, message throws and catches). %Applying this attribute to an element directly or indirectly (e.g. through inclusion in a pool) is mandatory; the intended usage is to equip either pools or lanes with public keys. 
\texttt{zkp:variables} applies to \textit{activities} and declares process instance global variables, and that that activity may write the variable (reads are allowed for all activities). These variables can be used in boolean expressions for exclusive gateways.

Some constraints apply to the structure of the BPMN models, which are currently admissible in our scheme.

\begin{itemize}
    \item Gateways must be binary (two incoming/outgoing edges).
    \item Activities are \textit{atomic}; i.e., subprocesses are not supported.
    \item The model must be acyclic (no loops).
\end{itemize}

We plan to eliminate these constraints in the future; the required modifications of the state representation and the zkWF program construction are largely incremental.

\subsection{State representation}
\label{subsec:staterep}
Our notion of process instance execution state encompasses the following aspects (for the specific encoding in zkWF programs, please refer to the report and the implementation).

\begin{itemize}
\item A vector $v$ of the current state of executable elements
\item The current values of \textit{global variables}
\item Hashes of the messages already sent in the process
\end{itemize}

Let $M=(\vertices,\edges,\executables)$ be a process model, where $\vertices$ is the set of non-flow model elements, $\edges$ is the set of model edges (flows), and $\executables\subset\vertices$ is the set of all executable elements in the business process. Then, $v$ is a vector of $|T|$ size and $\forall v_i \in v$ can have one of the following three values:

\begin{itemize}
    \item 0 (Inactive) -- The element has not been reached yet
    \item 1 (Active) -- The element is ready to be executed or is being executed by a participant
    \item 2 (Completed) -- The execution of the element has been completed
\end{itemize}

This state set is a subset of those in the standard activity lifecycle \cite[p.~428]{bpmn} and serves as a reasonable simplification, as the main focus of the work described here is exploring the confidential execution aspect. Note that correctly implementing the full lifecycle is a significant software engineering effort, even in the centralized setting. Also, BPMN users tend to apply a similar simplified view during modeling, as the more sophisticated state aspects require experience and limit the ease of model understanding. %The major exception is the ''Ready'' state between Inactive and Active, which we folded into our Active state due to not being required under our system model -- there seems to be limited value in a participant declaring that she has started performing a task.

\subsection{Capturing token passing semantics}
\label{subsec:parray}
BPMN 2.0 models have straightforward, token flow-based standard execution semantics: start events create tokens that move around as execution progresses. Parallel gateways split and join tokens. To support a different ZKP use case, \cite{toots_msc} introduces a technique for representing valid BPMN execution state changes by enumerating the possible composite token marking deltas of the elements upon stepping the process. Specifically, \cite{toots_msc} introduces an array $P$, where each element of $P$ is a list of token change and element identifier pairs. We construct a similar $P$ array under the token passing semantics and embed it into the zkWF program to enable checking whether a proposed state update is valid from the BPMN execution logic point of view. Our $P$ array to describe one-step token marking changes for a model $M$ consists of 3-tuples with elements from the set $\mathcal{N}$: 

\begin{align}
    \mathcal{N}&=(+1, -1\}\times T)\cup \{(0,-1)\}
\end{align}

For $T$, we apply a simple integer encoding; the $-1$ in the ''no-token-change'' pair second set is a don't care placeholder. Especially under our binary gateway condition, which is currently necessary to ensure reasonable proof computation times, it is straightforward to enumerate the admissible changes based on the BPMN model. For example, let's consider activities $a,b,c \in T$. $a$ continues in a parallel gateway, which proceeds to $b$ and $c$. When $a$ transitions from ''Active'' to ''Completed'' and $b$ and $c$ from ''Inactive'' to ''Active'', the following token marking change happens: $((-1,a),(+1,b),(+1,c)) \in \mathcal{N}$. The complete logic can be found in the referenced report.

%Initially, we create a token for every start event and pass it to the first executable element connected to it. Each executable element has one incoming and one outgoing edge. When an executable event has a token, it is marked as ''active''. After completing the execution of the element, the element is marked as ''completed'', and we pass its token to the next executable element -- based on the token holder element's outgoing edge. This approach can be modelled as adding a token ($+1$) when we mark an executable event as ''active'', and we subtract this token ($-1$) when we mark the event as ''done''.

%Gateways change the token flow differently. Parallel gateways can split a token on one end and merge them back together on the other end. Exclusive gateways can have many outgoing edges, but only one can be taken based on its assigned expression. A default outgoing edge can also be set, as described in the BPMN specification. End events can have multiple incoming edges but no outgoing edges. They mark the end of a token flow.

%To limit the size of our version of array $P$ (necessary to ensure reasonable proof computation times), in our approach, a single step of a model can induce only three token changes at most. (Hence the structural restriction on parallel gateways.) Thus, the array $P$ describing one-step token marking changes for a model $M$ consists of 3-tuples with elements from the set $\mathcal{N}$: 

%\begin{align}
%    \mathcal{N}&=(+1, -1\}\times T)\cup \{(0,-1)\}
%\end{align}

%For $T$, we apply a simple integer encoding; the $-1$ in the ''no-token-change'' pair is a don't care placeholder.

%In general, $n\in\mathcal{N}$ is a pair of numbers describing a possible token change. The first component of the pair shows if the token is increased or decreased ($+1$ or $-1$). The second component $i$ marks the token change for the executable event $T[i]$.

%Since not every step consists of three token changes, $n$ can also be an "empty" token change. This is used as a placeholder and is marked as $(0,-1)$.

%Then, $P[i]$ shows how the process state can change in step $i$.

%\subsection{Limitations of BPMN models}
%\label{bpmn_limit}
%As We described in the previous section, "special" BPMN models are needed for the program to work.
%\begin{itemize}
    %\item The model must be a collaboration: It must have at least one pool.
    %\item It only supports a limited subset of the BPMN specification.
    %See section \ref{bpmn_elements}.
    %\item All tasks should have a public key assigned to them. This should be done at the pool/lane level, not individually.
    %\item A parallel gateway can only have two outgoing (and one incoming) edges OR two incoming (and one outgoing) edges. 
    %The reason behind it is described in section \ref{paralhell}. 
    %\item A gateway must be followed by an executable event.
%\end{itemize}