\section{Introduction} \label{sec:introduction}

The burgeoning computational power of off-the-shelf processing units has enabled the use of model predictive control (MPC) for applications that involve increasingly complex systems, need to comply with constraints and need to account for several, sometimes conflicting, performance objectives. However, development and implementation of nonlinear MPC (NMPC) comes with a high engineering cost, and the availability of flexible, easy-to-use tools for rapid prototyping and deployment of NMPC solvers is insufficient. This has limited the wide adoption of NMPC, e.g., for complex and fast mechatronic applications.

%The research to date has focused on the development of the combination of efficient solvers for the optimal control problems (OCP) underpinning MPC, and software tools that facilitate the use of such solvers. Furthermore, automatic code generation has become an essential feature for allowing efficient computations and the deployment of MPC in embedded systems. The main drawback of the aforenamed tools, however, is that they restrict the user to specific numerical optimization methods and solvers, limiting the flexibility required by practitioners while prototyping, e.g., what solvers perform better for a specific underlying OCP. In addition, extending these tools towards interfacing additional optimization methods or solvers is not straightforward.

Central to an MPC control scheme is the repeated online numerical solution of a parametric optimal control problem (OCP). Important exceptions such as \codename{GRAMPC} \citep{grampc} notwithstanding, most efficient solvers rely on a direct transcription method to transform the OCP into a nonlinear program (NLP).
In recent years, a rich landscape of efficient quadratic programming (QP) solver implementations has emerged. They are valuable as a subroutine in 
% a
an important 
class of NLP solvers, as well as directly in linear MPC, and real-time iteration schemes for NMPC.

No combination of OCP method, NLP solver and QP solver is applicable, let alone optimal, across a wide range of control applications.
This situation has given rise to a rich solver landscape\footnote{See 
% the \href{https://github.com/meco-group/dynamic_optimization_inventory}{dynamic optimization inventory}
\url{https://github.com/meco-group/dynamic_optimization_inventory}
% \url{https://cutt.ly/meco-dynamic_optimization_inventory}
}.
Some of these solvers are akin to a framework: offering some degree of vertical integration, i.e., going all the way from high-level easy-to-use OCP modeling down to low-level efficient deployable code.
%
Examples of efficient frameworks are: \codename{AutoGenU} \citep{autogenu}, providing an environment to formulate, solve, simulate and code generate MPC within \codename{Jupyter} notebooks, featuring a generalized minimal residual method implemented in \codename{C++} --- \codename{OpEn} \citep{OpEn2020}, focusing on embedded nonconvex optimization using the proximal averaged Newton-type method for optimal control (\codename{PANOC}) and the augmented Lagrangian method, implemented in \codename{Rust} and providing interfaces to \codename{Python} and \codename{MATLAB} --- \codename{Acados} \citep{ACADOS} and \codename{MATMPC} \citep{MATMPC}, offering SQP-type methods with \codename{Simulink} integration --- \codename{ParNMPC} \citep{ParNMPC}, offering an interior point solver with parallelization capabilities in \codename{MATLAB} --- \codename{MATLAB} MPC toolbox \citep{MPCmatlab}, offering a graphical interface and tight integration with \codename{Simulink}.

The main drawback of existing frameworks is that they are monolithic rather than modular: they restrict the user to a single or limited set of numerical algorithms, conflicting with the need of practitioners to prototype, e.g. figuring out the best solver and settings combination for a specific OCP. Furthermore, each provides a specific way to model OCPs and to communicate with the generated solution, which makes switching between frameworks, for testing and prototyping, a cumbersome process. Lastly, a lack of high-level modeling means that the user is burdened with writing in canonical forms and supplying derivatives.
%In addition, extending these tools towards interfacing additional optimization methods or solvers is not straightforward.

To address the aforementioned issues, we present \codename{IMPACT}, 
an open-source toolchain that aims to facilitate the workflow of specification, prototyping and deployment of NMPC. It offers vertical integration, while providing modularity, with minimal runtime overhead.
%
The main features of \impact are described as follows:
\begin{itemize}
\item It provides a unified high-level application programming interface (API) to model OCPs.
\item It is cross-lingual (written in \codename{Python} and provides auto-generated\footnote{See
\url{https://gitlab.kuleuven.be/meco-software/python_matlab}
% \url{https://cutt.ly/meco-python_matlab}
} \codename{MATLAB} bindings) and cross-platform.
\item It offers a range of direct transcriptions methods that 
are
% can be readily 
paired to state-of-the-art QP/NLP solvers via \casadi plugins such as \codename{HPIPM} \citep{HPIPM},
% \footnote{\label{qp_solver}QP solvers are the 
% % algorithmic 
% core of linear MPC.
% %(good software:, mention dense, generic sparse, blockdense )
% } \citep{HPIPM}, 
\codename{PROX-QP} \citep{ProxQP},
% \footref{qp_solver} \citep{ProxQP},
\codename{IPOPT} \citep{ipopt},
% \footnote{\label{nlp_solver}NLP solvers are used when using nonlinear models, objective or constraints, and may use QP solvers internally.} 
% \citep{ipopt}, 
\codename{FSLP} \citep{Kiessling2022CDC}.
% \footref{nlp_solver} \citep{Kiessling2022CDC}, 
% \footref{nlp_solver} 
\item It offers alternatives to built-in direct transcription by interfacing OCP solvers/frameworks via \codename{Rockit} plugins -- at the moment \codename{Acados}, \codename{GRAMPC} and \codename{FATROP} \citep{FatropIcra}.
\item It exports problem-specific MPC libraries with a unified \codename{C} API, useful for rapid prototyping and deployment on simulated and real environments.
\item It exports a problem-specific \codename{Simulink} block making use of the exported MPC library.
%\item It proposes a standard way of defining system models within YAML files for their use in optimization and MPC frameworks.
\end{itemize}
\impact is released under the LGPLv3 license and its source code is available at \url{https://gitlab.kuleuven.be/meco-software/impact}. It is built on top of the powerful tools for optimization and optimal control \casadi \citep{casadi} and \codename{Rockit} \citep{rockit}.

The remainder of this paper is organized as follows. Section \ref{sec:preliminaries} presents preliminary concepts on the formulation and transcription of the OCP underpinning MPC. In Section \ref{sec:toolchain_overview}, details on the overall structure and workflow of \impact are given. An application example using \impact is described in Section \ref{sec:case}. Finally, we close the paper with conclusions and future work remarks. 


% OCP/MPC framework \footnote{\label{ocp_framework}OCP/MPC frameworks make use of QP and NLP solvers, are limited in implemented algorithms, and vary in degree of vertical integration (monolitic vs modular).}
% , rockit-style modeling?, AD offloaded to the user?, callable from simulink, state estimation tools). Even in the direct transcription family (ss, ms, collocation, splines) there are a lot of combinations with 1 and 2 that are untried, let alone easily testable by practitioners}

%rockit based, all available solver in Rockit are available in IMPACT too(including state of the art in-house developed solvers ref(David SLP, Fatrop)))
%Provides a C application programming interface (API)
%
%
%Flexible (C/Python/Matlab), Extensible (solver plugins), Composition (builds on top of solid background)

% Drawbacks of the other tools: Not being flexible enough, nor extensible enough...

%\codename{OPTIPLAN} \citep{optiplan} is a toolbox that allows the user to formulate, solve and simulate MPC. It interfaces multiple solvers for nonlinear, mixed integer, quadratic and linear programs, i.e., \codename{fmincon}, \codename{GUROBI}, \codename{CPLEX}, and \codename{quadprog}, respectively. However, \codename{OPTIPLAN} is tailored for specific formulations of OCPs with obstacle avoidance constraints, does not feature automatic code generation, and is not maintained since 2017.

% We propose a web application were the user can program, visualize, simulate and deploy .... $\rightarrow$ the steps required to set up and deploy the OCPs are reduced $\rightarrow$ this web application represents a front-end of the model predictive control toolchain for constraint-based task specification of robot motions (Tasho).

%\subsection{Outline}

% \codename{Robotoc} \citep{ROBOTOC}


%  Recently, several code generation tools have been developed that produce highly efficient library-free optimization algorithms.
%\codename{$\mu$AO-MPC} \citep{muAOMPC}

%Given the ... of Simulink, several ... have focused on developing tools not only for ... but that provide an interface to Simulink for rapid prototyping.



%A systematic understanding of how X contributes to Y is still lacking.



% También diferenciar entre codegen y C API, codegen es sólo hacer más eficiente la implementación, y C API es comunicar todo en C, es más poderoso

% y de los diagramas me dijo que dos, uno user orinted y otro de los componentes


% CarSim-Matlab/Simulink co-simulations \citep{Wang_2019}




% \subsection{Related Work}


%\subsection{Contributions}


% This paper is organized as follows. Preliminary concepts on optimal control problems and robot dynamics are introduced in Section \ref{sec:preliminaries}. Section \ref{sec:architecture} gives an overview of the application's architecture and its different building blocks and features.
% Section \ref{sec:workflow} explains the workflow on how to define an OCP using the toolchain and the interactions between the components. Section \ref{sec:results} presents first a simple example deploying an OCP in simulation, followed by a demonstration of the toolchain's capabilities in a pick-and-place lab setup. Concluding remarks and further exploration opportunities are detailed in Section \ref{sec:conclusions}.