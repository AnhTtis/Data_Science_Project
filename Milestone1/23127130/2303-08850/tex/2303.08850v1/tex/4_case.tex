\section{Application Example Using IMPACT} \label{sec:case}

This section demonstrates the use and deployment of MPC using \codename{IMPACT}. We control the point-to-point motion (angular position) of a DC motor using a Speedgoat SN7233 real-time target machine. The control scheme estimates a constant disturbance that represents unmodeled dynamics -- e.g., input disturbances and static friction --, counteracts its effect, and achieves offset-free positioning.

\subsection{System Description}
The hardware has two components: the DC motor and the real-time target machine that executes the MPC algorithm and interfaces with the motor driver and a rotary encoder. 

% % \subsubsection{DC motor system}
The shaft of the DC motor is connected to a load and the rotary encoder, which provides a measurement $\mathbf{y}$ of the angular position of the rotor $\theta \in \mathbb{R}$. The motor has a driver that receives an analog voltage $v_{\mathrm{motor}} \in [-10,10]$
from the digital-to-analog converter (DAC) of the Speedgoat. 
% The encoder has $4096\ [\mathrm{pulses/rev}]$ and, therefore, a resolution of $0.0015\ [\mathrm{rad}]$. 
% --------------------------------------------------
% A second order linear model of the motor has been experimentally identified. This model contains one integrator and one real pole which models the linear motor friction. %We identified a second order linear model using data from a multisine excitation using 
% The \codename{LCtoolbox} \citep{Maarten2018LCToolbox} is used for this process.%, its characteristics and the procedure is described in \cite{Maarten2018LCToolbox}. The numerical values are
% % \begin{equation}
% % \label{eq:Statespacemodel}
% %     \begin{bmatrix}
% %         \dot{\mathrm{x}}_1\\
% %         \dot{\mathrm{x}}_2 
% %     \end{bmatrix}=
% %     \begin{bmatrix}
% %         0 & 1 \\
% %         0 & -9.215
% %     \end{bmatrix}
% %     \begin{bmatrix}
% %         \mathrm{x}_1\\
% %         \mathrm{x}_2 
% %     \end{bmatrix}+
% %     \begin{bmatrix}
% %         0\\
% %         442.9
% %     \end{bmatrix}\mathrm{u}
% % \end{equation}
% % \begin{equation*}
% %     \begin{bmatrix}
% %         \mathrm{y}
% %     \end{bmatrix}=
% %     \begin{bmatrix}
% %         1 & 0 
% %     \end{bmatrix}
% %     \begin{bmatrix}
% %         \mathrm{x}_1\\
% %         \mathrm{x}_2 
% %     \end{bmatrix}
% % \end{equation*}
%
% The model has the state space structure where $\mathbf{x} := [\theta, \dot{\theta}]^T \in \mathbb{R}^2$ are the states, angular position and velocity, $\mathbf{u} := v_{\mathrm{motor}}$ is the input voltage and $\mathbf{y} := \theta$ is the measurement of the angular position. This model does not consider the static friction component, hence by controlling the position, we have a model-plant mismatch.  
% \subsubsection{DC motor system}
%
%
For a state vector $\mathbf{x} := [\theta, \dot{\theta}]^T \in \mathbb{R}^2$ and a control input $\mathbf{u} := v_{\mathrm{motor}}$, a second order linear model for the motor 
\begin{equation} \label{eq:dynamics_motor}
    \dot{\mathbf{x}} = A\mathbf{x} + B\mathbf{u}
\end{equation}
has been experimentally identified using the \codename{LCtoolbox} \citep{Maarten2018LCToolbox}. This model contains one integrator and one real pole which models the linear motor friction, but does not consider the static friction component. 
% Hence, there is a model-plant mismatch.  

% \subsubsection{Real-time target machine}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.36\textwidth]{figures/connectionScheme.png}
    \vspace{-3ex}
    \caption{
    Overview of the system.
    % Connection scheme between real-time target machine an motor system.
    }
    \label{fig:connectionScheme}
    % \vspace{-2ex}
\end{figure}
The Speedgoat SN7233 is a real-time target machine, programmed via \codename{Simulink}, that allows the deployment of controllers on, e.g., multi-core CPUs, FPGAs and PLCs, and facilitates rapid controller prototyping and hardware-in-the-loop simulations through a smooth integration with \codename{Simulink Real-Time}. 
% It is scalable and expandable making it cover a wide range of case scenarios.
%An Intel i7 CPU with clock speeds up to $4.2 \ [\mathrm{GHz}]$ processes the calculations. 
The target runs the MPC algorithm -- based on an \impact \codename{Simulink} block --, applies an analog voltage $v_{\mathrm{motor}}$ to the motor, and reads the digital signals from the rotary encoder, as depicted in Fig. \ref{fig:connectionScheme}. 
% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.37\textwidth]{figures/connectionScheme.png}
%     \vspace{-3ex}
%     \caption{Connection scheme between real-time target machine an motor system.}
%     \label{fig:connectionScheme}
%     % \vspace{-2ex}
% \end{figure}

\subsection{Problem Definition} \label{sec:problem_definition}
% We define an offset-free MPC strategy to track an angular reference while counteracting the effect of the model-plant mismatch and a constant voltage disturbance applied to the system input. 
% \subsubsection{Offset-free MPC}
% This methodology resides in two main changes with respect to the traditional MPC. The first one is the model augmentation with a disturbance model for the estimation process, with this, the states and disturbances are estimated. The second one is an additional problem that, based on the disturbance estimated, finds a modification of the states and input references which makes the system follow the reference fixing disturbance effects, this problem is called the steady state problem \citep{rawlings2017model}. 

% The estimation process is made each sample time, therefore we need a discretized system model with the form $  \mathbf{x}_{k+1} = \boldsymbol{A}\mathbf{x}_k+\boldsymbol{B}\mathbf{u}_k, \ \mathbf{y}_k=\boldsymbol{C}\mathbf{x}_k $, then, the augmentation for estimation is
% \begin{equation}
%     \label{eq:augmentedmodel}
%     \begin{bmatrix}
%         \hat{\mathbf{x}}_{k+1}\\
%         \hat{\mathbf{d}}_{k+1}
%     \end{bmatrix}=
%     \begin{bmatrix}
%         \boldsymbol{A} & \boldsymbol{B}_d\\
%         \boldsymbol{0} & \boldsymbol{A}_d
%     \end{bmatrix}
%     \begin{bmatrix}
%         \hat{\mathbf{x}}_k\\
%         \hat{\mathbf{d}}_k
%     \end{bmatrix}+
%     \begin{bmatrix}
%         \boldsymbol{B}\\
%         \boldsymbol{0}
%     \end{bmatrix}\mathbf{u}_k
% \end{equation}
% \begin{equation*}
%     \hat{\mathbf{y}}_{k}=\begin{bmatrix}
%         \boldsymbol{C} & \boldsymbol{C}_d
%     \end{bmatrix}\begin{bmatrix}
%         \hat{\mathbf{x}}_{k}\\
%         \hat{\mathbf{d}}_{k}
%     \end{bmatrix}
% \end{equation*}
% where $\hat{\mathbf{x}}_{k}$, $\hat{\mathbf{d}}_k$, $ \hat{\mathbf{y}}_k$ are states, disturbance and output estimations at discrete time $k$. $\boldsymbol{A}_d$ represents the disturbance model, the values of $\boldsymbol{B}_d$ and $\boldsymbol{C}_d$ are design parameters. In this example, we consider an input single constant disturbance, therefore $\boldsymbol{A}_d=1$ and $\boldsymbol{C}_d=0$, additionally, with $\boldsymbol{B}_d=\boldsymbol{B}$ the disturbance estimation has same units as the input, volts in this case. Kalman filter is the observer used to perform the estimation process. \\

% The steady state problem here is a simplified version of the general one. We find the states and input taking into account the disturbance estimation such that the system follows the reference in steady state. Then, this problem is described by the following set of algebraic equations  
% \begin{equation}
%     \label{eq:steadystateproblem}
%     \begin{bmatrix}
%         \boldsymbol{I}-\boldsymbol{A} & -\boldsymbol{B} \\
%         \boldsymbol{C} & \boldsymbol{0}
%     \end{bmatrix}\begin{bmatrix}
%         \mathbf{x}_s \\
%         \mathbf{u}_s
%     \end{bmatrix}= \begin{bmatrix}
%         \boldsymbol{B}_d\hat{\mathbf{d}}_k \\
%         \mathbf{y}_r-\boldsymbol{C}_d\hat{\mathbf{d}}_k
%     \end{bmatrix}
% \end{equation}
% where $\mathbf{x}_s$ and $\mathbf{u}_s$ are the states and input that make the unaugmented system follow the reference $\mathbf{y}_r$ in the presence of a disturbance $\hat{\mathbf{d}}_k$. 
% %Now the deviation variables are the differences between system and steady state variables $ \tilde{\boldsymbol{x}}_k= \boldsymbol{x}_k-\boldsymbol{x}_s, \ \tilde{\boldsymbol{u}}_k= \boldsymbol{u}_k-\boldsymbol{u}_s $, therefore, the goal is minimize the deviation variables. Note that as the system model is linear, the dynamics holds for deviation variables.    
%------------------------------------------
To achieve an accurate positioning of the rotor, i.e., counteracting the effect of the model-plant mismatch and a constant input disturbance $\mathbf{d} \in \mathbb{R}$, we define an offset-free MPC \citep[Section 1.5]{rawlings2017model}.
%
In addition to the solution of OCP \eqref{eq:ocp},
% underpinning an MPC, 
this methodology involves (i) augmenting the system dynamics within the estimation algorithm with the dynamics of $\mathbf{d}$, and (ii) solving an optimization problem -- the steady-state problem or target selector -- that sets references for $\{\mathbf{x},\mathbf{u}\}$ in the OCP \eqref{eq:ocp} based on the estimated states and disturbance, to compensate the disturbance effects while tracking a reference. 
% An overview of the offset-free MPC implemented for this application is presented in Fig. 
The offset-free MPC structure is synthesized in Fig. \ref{fig:offsetfree-diagram}. 
% The differences with respect to a standard MPC implementation are highlighted in blue. 
% The scheme represents nearly how the \codename{Simulink} implementation looks.
\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.37\textwidth]{figures/offsetfreediagram.png}
    \vspace{-1.5ex}
    \caption{Diagram of an offset-free MPC implementation, with differences with respect to traditional MPC in blue, and physical connections to the motor in green.
    % . The differences from traditional MPC are shown in blue. In the plant, the green dotted lines represent the physical connection between the Speedgoat target and the motor.
    }
    \label{fig:offsetfree-diagram}
\end{figure}

Before presenting details on the definition of OCP \eqref{eq:ocp} for this application, let us describe the estimator and steady-state problem. The estimator -- i.e., a Kalman filter -- outputs an estimate
$\hat{\bar{\mathbf{x}}}_k$ 
of an augmented state vector $\bar{\mathbf{x}}_k := \begin{bmatrix}\mathbf{x}_k^\top & \mathbf{d}_k \end{bmatrix}^\top$ whose dynamics are based on a discretized representation of \eqref{eq:dynamics_motor} and the assumption of a constant disturbance. 
%
The steady-state problem corresponds to an optimization problem that considers the reference $\mathbf{y}_r$ and the estimated disturbance $\hat{\mathbf{d}}$ to define set-points $\{\mathbf{x}_s,\mathbf{u}_s\}$ for $\{\mathbf{x},\mathbf{u}\}$ in OCP \eqref{eq:ocp}.
For this example, the solution of such problem can be found analytically as the solution of a system of linear equations. %
% $(I - A)\mathbf{x}_{s} - B\mathbf{u}_{s} = \hat{\mathbf{d}}_k$, $C\mathbf{x}_{s} = \mathbf{y}_{r}$, where $C$ is defined by $\mathbf{y} = C\mathbf{x}$.
%
The reader is referred to 
% Section 1.5 in 
\cite{rawlings2017model} for more details on this formulation.

%------------------------------------------
Instead of minimizing the output error $\mathbf{y} - \mathbf{y}_r$, OCP \eqref{eq:ocp} aims to minimize the deviation between the 
% steady state variables 
set-points
$\{\mathbf{x}_s, \mathbf{u}_s\}$ and the system variables $\{\mathbf{x}, \mathbf{u}\}$. Therefore, the objective \eqref{eq:ocp_objective} is defined by
$V(\cdot) := \lVert\mathbf{x}(t)-\mathbf{x}_s\rVert_{Q}^2+\lVert\mathbf{u}(t)-\mathbf{u}_s\rVert_{R}^2$ and $V_{\mathrm{f}}(\cdot) := \lVert\mathbf{x}(t_f)-\mathbf{x}_s\rVert_{Q_\mathrm{f}}^2$, where $Q$, $R$, $Q_\mathrm{f} \succeq 0$ are weight matrices.
% and $\lVert \cdot \rVert_W$ denotes the $W$-weighted $\ell_2$-norm.
% The weight matrices $Q$, $R$, $Q_\mathrm{f} \succ 0$ are defined within the parameters $\mathbf{p}$. %$\sqrt{a^TAa}$
%
In the boundary constraint \eqref{eq:ocp_init}, $\mathbf{x}_{\mathrm{meas}} = \hat{\mathbf{x}}$,
% is the current estimation of the states $\hat{\mathbf{x}}$,
i.e., excluding the estimated disturbance.
% , given by the Kalman filter using (\ref{eq:augmentedmodel}).
The dynamics \eqref{eq:ocp_dynamics} are described by the ODE \eqref{eq:dynamics_motor}. Since the system does not feature algebraic equations, \eqref{eq:ocp_algebraic} is omitted.
Boundary constraints \eqref{eq:ocp_path} are given by the lower and upper bounds on $v_{\mathrm{motor}}$, such that $-10 \leq \mathbf{u}(t) \leq 10\ \forall t \in [t_0, t_\mathrm{f}]$.

% With all components defined, the offset-free MPC structure is synthesized in the diagram of Fig. \ref{fig:offsetfree-diagram}. In blue color, the differences with respect to normal MPC are highlighted, the scheme represents nearly how looks like the Simulink implementation.
% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.45\textwidth]{figures/offsetfree-diagram.eps}
%     \caption{Offset-free MPC diagram, in blue color the differences from normal MPC are shown. In the plant, the green dotted lines represent the physical connection between Speedgoat target and the motor, it  is not visible in the Simulink implementation.}
%     \label{fig:offsetfree-diagram}
% \end{figure}

%OCP: \textcolor{blue}{No need for writing the full OCP. Just refer to OCP \eqref{eq:ocp} and specify the functions that you use. For instance: in this example the state $\mathbf{x} \in \mathbb{R}^{4}$ is ..., the function $V(\cdot) = $  ...., we have three instances of $v$ in the general equality constraints \eqref{eq:ocp_equality}, which are set terminal constraint to ... and are defined as follows... }

\subsection{Implementation Details}
%----------------------------------------------------------
% In this section, we finalize the implementation of this example. We should go through the workflow procedure outlined in section \ref{sec:workflow}, the \impact block is configured and created, then the blocks connections are made, and the controller is code generated and deployed in the speedgoat target.   

% We start instantiating an MPC object defining the prediction horizon $T=50/300\approx 0.1666 [\mathrm{s}]$. Then the system model is loaded through a yalm file describing the ODE equation. Next, three parameters are defined, current state, xs and us. They collect the state estimates values and the solution of the steady state problem (\ref{eq:steadystateproblem}). Then the cost function, equality constraint for the initial state, and input inequality constraint, they represent the OCP. Note that the dynamics constraints are not explicitly defined, the toolchain takes it automatically from the model described. Now the SQP solver is selected for this example. The transcription method chosen is multiple shooting with $N=50$ discretization points, this defines the sample time for the controller execution $T_s=T/N=1/300=3.333[\mathrm{ms}]$, it's equivalent to a sampling frequency $f_s=300 \ [\mathrm{Hz}]$. Also, 4th-order Runge Kutta is configured to discretize the system dynamics. Finally, the initial values for parameters are set as zeros in our example, and then we call the export function to generate the Simulink block result.
%----------------------------------------------------------
To implement the \impact \codename{Simulink} block that solves OCP \eqref{eq:ocp} we follow the workflow outlined in Section \ref{sec:workflow}. We use $N = 50$,
% discretization points, 
% a sampling time 
$\delta_t = 3.33\ [\mathrm{ms}]$ and 
% a horizon 
$T = 166.66\ [\mathrm{ms}]$.
Model \eqref{eq:dynamics_motor} is defined in a YAML file and loaded to the MPC object. Five parameters are defined, namely, $\mathbf{x}_{\mathrm{meas}}$, $\mathbf{x}_s$, $\mathbf{u}_s$, $Q$, $R$ and $Q_{\mathrm{f}}$. The objective and constraints of OCP \eqref{eq:ocp} are defined as in Section \ref{sec:problem_definition}. 
We use 
% the SQP solver of \codename{CasADi}, 
the active set-based QP solver \codename{QRQP} \citep{qrqp} in \codename{CasADi}
% to solve the QP sub-problems within the SQP method,
and multiple shooting as transcription method with a 4th-order Runge-Kutta integrator for system discretization. The MPC solver is exported to generate the 
% \impact 
\codename{Simulink} block. This block is loaded into a \codename{Simulink} model where the estimator and the steady-state problem are implemented, and where the Speedgoat input/output blocks are loaded. The \impact block is connected to the other blocks as in Fig. \ref{fig:offsetfree-diagram} to close the loop.
%
% Finally, the initial values for parameters are set as zeros in our example, and then we call the export function to generate the Simulink block result.
%
% Now it only remains to connect the feedback loop between blocks in Simulink as shown in Fig. \ref{fig:offsetfree-diagram}. 
% The reference $\mathbf{y}_r =$
% $2 [\mathrm{rad}]$ pulse between $3$ and $5\ [\mathrm{s}]$, and 
% $-3\ [\mathrm{rad}]$ between $8$ and $10\ [\mathrm{s}]$, and zero otherwise. 
The reference is 
% set as 
$\mathbf{y}_r(t) = -3\ [\mathrm{rad}]$, $\forall t \in [1, 3]$, and zero otherwise. 
% We apply 
% a disturbance of 
While $\mathbf{d} = 0.5\ [\mathrm{V}]$ $\forall t \geq 8$.
% The disturbance is $0.5[v]$ step at second $15$.

%In this example the MPC scheme is executed with sample frequency of $f_s=350 \ [\mathrm{Hz}]$, it means, the optimal control problem solution and additional calculations should be executed in a period smaller than $T_s=2.9 \ [\mathrm{ms}]$  

%Code (maybe code is not needed since we are showing some code in the workflow)?? description of the workflow used for this example

%... we use a 4th order Runge-Kutta integrator and the multiple shooting method to discretize and transcribe the OCP into an NLP ...

\subsection{Results}
Once the \codename{Simulink} model has been set, we call the real time execution operation of \codename{Simulink Real-Time}, which code-generates it by using the \codename{Simulink} coder and then executes it in the Speedgoat. The results of the offset-free MPC implementation are compared against a traditional MPC implementation, i.e., without disturbance estimation and execution of the steady-state problem.
%
% The results obtained from the deployment of the controller are presented in this . The traditional MPC and the offset-free version were implemented, the results for the angular position and voltage are compared.   
%
Fig. \ref{fig:1_posvolt2} shows the evolution of the angular position $\theta$ and the voltage input $\mathbf{u}$ with both implementations. Here, the offset-free MPC can follow the reference with zero offset, while the traditional MPC deviates from the reference before (due to the effects of model-plant mismatch) and after the application of the disturbance at 
% $t = 8\ [\mathrm{s}]$. 
$t = 8$.
% The input constraints are satisfied with both MPC implementations.
% , a flat voltage at the maximum can be observed in the inset.
% The voltage at second $10$ in Fig.\ref{fig:1_posvolt} reveals that the input constraints of $\pm 10[\mathrm{v}]$ were active and the \impact block addressed it adequately.

% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.43\textwidth]{figures/1_position.eps}
%     \caption{Angular position $\theta$ of the load in the DC motor}
%     \label{fig:1_step}
% \end{figure}

% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.43\textwidth]{figures/1_posvolt.eps}
%     \caption{Angular position $\theta$, and motor input voltage }
%     \label{fig:1_posvolt}
% \end{figure}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.40\textwidth]{figures/posvolt.png}
    \vspace{-1.5ex}
    \caption{
    % Angular position $\theta$, and motor input voltage.
    Evolution of the angular position $\theta$ and the voltage input $\mathbf{u}$ during the application execution.
    }
    \label{fig:1_posvolt2}
\end{figure}

% Fig. \ref{fig:compare} shows a comparison between disturbance estimation, position and input voltage after the disturbance is applied at $t = 8\ [\mathrm{s}]$. Because of the static friction, when the system applies a voltage and the load position does not change, the methodology estimates an opposite force that keeps the load in that position. The force increases until the voltage is enough to move the load, then the contrary effects happens and the disturbance estimation and voltage oscillate. The position $\theta$ ends up one resolution step above or under the reference $\mathbf{y}_r$, it is considered offset-free.    

% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.48\textwidth]{figures/compare.eps}
%     \caption{Comparison between disturbance estimation, angular position and input voltage after disturbance application}
%     \label{fig:compare}
% \end{figure}

% \begin{figure}[htpb]
%     \centering
%     \includegraphics[width=0.48\textwidth]{figures/compare2.eps}
%     \caption{Comparison between disturbance estimation, angular position and input voltage after disturbance application}
%     \label{fig:compare2}
% \end{figure}
\impact eased MPC specification, testing and deployment, allowing to quickly prototype the problem and test several solvers by using the generated artifacts. In addition, the \impact \codename{Simulink} block could be easily integrated within larger models for simulation or deployment on real hardware.
%
% The use of \impact eases the specification, testing and deployment of (N)MPC. The practitioner is able to quickly prototype the problem by using the generated artifacts. In particular, when using the \codename{Simulink} block, the MPC solvers generated with \impact are easily integrated within larger models for simulation or directly for deployment on real hardware.
%
Although this example features a linear system, \impact allows the definition of systems represented by both linear or nonlinear equations.
%
Other tested applications with \impact include the deployment of NMPC in a Speedgoat target and a Beckhoff TwinCAT Embedded PC for a point-to-point motion application with a parallel SCARA robot. In the future, \impact will be tested in a DSpace Controller board, and extended to be used in FPGAs and GPUs.
