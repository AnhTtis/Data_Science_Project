\section{Toolchain Description} \label{sec:toolchain_overview}

This section presents an overview of the structure
%and the workflow 
of the \impact toolchain. First, a description of the fundamental dependencies of the toolchain is given. Next, the elements of the toolchain, and a workflow from MPC specification to deployment are presented. Finally, 
the use of 
the unified API to communicate with the MPC solvers is detailed.


\subsection{Fundamental Dependencies}

\label{sec:dependencies}

%\textcolor{red}{IMPACT: overview (could be described in Matlab or Python)(deployment is in C or Simulink, computationally efficient), back end (rockit) ,model definition (yaml file), problem formulation, solver instantiation, code generation (C and Simulink block, already tested real time platforms as speedgoat and beckhoff), it can be used in any platform which interprets C code}
%
% \impact is written in \codename{Python}, with \codename{MATLAB} bindings. 
The fundamental software dependencies required for installing and using \impact are: \codename{CasADi}, \codename{Rockit}, and the \codename{Python} modules \codename{pyyaml} and \codename{lxml}.

\impact relies on \codename{CasADi}
to handle 
% variables and 
expressions that model 
% functions in 
the objective and constraints as expression graphs, and to allow the saving/loading of functions and algorithms and their transfer across \codename{Python} and \codename{MATLAB}.

If instructed by the user, \impact relies on \codename{Rockit} to perform a chosen OCP transcription method. At the moment, multiple-shooting, single-shooting, direct collocation, and a B-spline method are supported.
Derivatives of the resulting NLP objective and constraints are obtained through \codename{CasADi}'s sparsity-exploiting algorithmic differentiation (AD), optionally made more efficient by \codename{C}-code generation.

\codename{Rockit} further provides interfaces to third-party OCP frameworks such as \codename{GRAMPC}, \codename{Acados} and \codename{FATROP}. Initially meant for offline usage, these interfaces are being refactored to use the \codename{CasADi} codegen \codename{C} API, such that they can be embedded in \codename{CasADi} expressions and are compatible with \codename{C}-code generation.
%
Lastly, \codename{Rockit} relies on \codename{CasADi} for importing functional mock-up units (FMU) for input/output representations of systems.
% and its importer of functional mock-up units (FMU) for input/output representations of systems.
% \impact relies on the nonlinear optimization and algorithmic differentiation framework \casadi \textcolor{blue}{\impact relies on symbolic framework of \casadi to model and mapping all type of variable and expressions involved in the OCP. When the transcription OCP to NLP uses a \casadi method, its algorithmic differentiation framework to compute the derivatives of such expressions as needed by the solvers. } for handling the variables and expressions that define OCP \eqref{eq:ocp}, and to compute the derivatives of such expressions as needed by the solvers. Moreover, it leverages \codename{CasADi}'s capabilities for \codename{C}-code generation and serialization of functions and solvers, and for importing functional mock-up units (FMU) for input/output representations of systems.
% As mentioned in Section \ref{sec:introduction}, multiple state-of-the-art solvers are made available to \impact through \codename{CasADi}.

% The dependency of \impact on \casadi and \codename{Rockit}, and the inherent modularity that such dependencies represent, allow the direct and transparent availability of new solvers in \impact whenever an interface to such solvers is added to either \casadi or \codename{Rockit}.
%
The libraries \codename{pyyaml} and \codename{lxml} are used within \impact to handle YAML and XML files required in the process of loading system models and generating \codename{Simulink} blocks when exporting the solution, respectively.


\subsection{Structure of the \codename{IMPACT} toolchain} \label{sec:structure}

A graphical illustration of the overall structure of the \impact toolchain is shown in Fig. \ref{fig:structure}. 
%
\begin{figure}[htpb]
\centering
\includegraphics[width=0.33\textwidth]{figures/IMPACTstructure.png}
\vspace{-1.5ex}
\caption{Overview architecture of the \impact toolchain showing the interaction between modules.}
\label{fig:structure}
%\vspace{-2mm}
\end{figure}
%
% As already mentioned in Section \ref{sec:dependencies}, 
\casadi and \codename{Rockit} play a vital role within \impact by providing essential capabilities to the toolchain regarding, e.g., expression handling,
% OCP transcription, 
and interfacing third-party solvers. In fact, the dependency of \impact on \casadi and \codename{Rockit}, and the inherent modularity that such dependencies represent, allow the direct and transparent availability of new solvers in \impact whenever an interface to such solvers is added to either \casadi or \codename{Rockit}.

Apart from 
% such dependencies, 
\casadi and \codename{Rockit}, 
\impact is composed by the MPC class, which is instantiated by the user to use all the functionalities of \codename{IMPACT}. This class is divided into five sub-modules, which are described as follows.



\textit{1) Model definition:} \impact provides the user with two ways of defining (nonlinear) system models to be used within the OCP definition: (i) manually defining state and control variables in addition to differential and algebraic equations, as done in \codename{Rockit} or (ii) using YAML files -- i.e., which are human-readable files for data serialization -- by using the \lstinline[style=pythoninline]{add_model()} method of the MPC class. 
By using YAML files, we aim to standardize the definition of models based on ODEs or DAEs
for their use in any software tool that is compatible with YAML. 
This model representation allows the use of both inline definition of equations and external serialized \casadi functions, i.e., \lstinline[style=pythoninline]{*.casadi} files, as shown respectively in the two YAML snippets of a pendulum system that follow.
%
% We present a code-snippet that shows the declaration of three variables {\lstinline[columns=fixed]{q}}, {\lstinline[columns=fixed]{qd}}, and {\lstinline{qdd}}  within the P2P task. Along with \lstinline{name} and \lstinline{mid}, the declaration takes as arguments (i) the \lstinline{type} and (ii) a \lstinline{shape} which sets the two-dimensional size of the variable.

\vspace{-4ex}
\begin{minipage}[t]{.54\linewidth}
     \begin{lstlisting}[language=yaml]
equations:
  inline:
    ode:
      phi: dphi
      dphi: L*cos(phi)*sin(phi)...
differential_states: 
  - name: phi
  - name: dphi
controls: 
  - name: F
constants:
  inline:
    L: 2
            \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.44\linewidth}
      \begin{lstlisting}[language=yaml]
equations:
  external:
    type: casadi_serialized
    file_name: ode.casadi
differential_states: 
  - name: phi
  - name: dphi
controls: 
  - name: F
            \end{lstlisting}
\end{minipage}

\vspace{-2ex}

% \begin{minipage}[t]{.54\linewidth}
%     \begin{minted}
%     [
%     % frame=lines,
%     % framesep=2mm,
%     % baselinestretch=1.2,
%     % bgcolor=backcolour,
%     fontsize=\tiny,
%     % linenos
%     ]
%     {yaml}
% equations:
%   inline:
%     ode:
%       phi: dphi
%       dphi: L*cos(phi)*sin(phi) ...
% differential_states: 
%   - name: phi
%   - name: dphi
% controls: 
%   - name: F
% constants:
%   inline:
%     L: 2
%     \end{minted}
% \end{minipage}\hfill
% \begin{minipage}[t]{.44\linewidth}
%     \begin{minted}
%     [
%     % frame=lines,
%     % framesep=1mm,
%     % baselinestretch=1.2,
%     % bgcolor=backcolour,
%     fontsize=\tiny,
%     % linenos
%     ]
%     {yaml}
% equations:
%   external:
%     type: casadi_serialized
%     file_name: ode.casadi
% differential_states: 
%   - name: phi
%   - name: dphi
% controls: 
%   - name: F

  
%     \end{minted}
% \end{minipage}

% % \begin{figure}[htpb]
% % \centering
% \begin{minipage}[t]{.35\linewidth}
%     \begin{minted}
%     [
%     % frame=lines,
%     % framesep=2mm,
%     % baselinestretch=1.2,
%     bgcolor=backcolour,
%     fontsize=\scriptsize,
%     % linenos
%     ]
%     {yaml}
% equations:
%   inline:
%     ode:
%       pos: m*dpos
% differential_states: 
%   - name: pos
% controls: 
%   - name: dpos
% constants:
%   inline:
%     m: 1
%     \end{minted}
% \end{minipage}\hfill
% \begin{minipage}[t]{.60\linewidth}
%     \begin{minted}
%     [
%     % frame=lines,
%     framesep=2mm,
%     % baselinestretch=1.2,
%     bgcolor=backcolour,
%     fontsize=\scriptsize,
%     % linenos
%     ]
%     {yaml}
% equations:
%   external:
%     type: casadi_serialized
%     file_name: point_equations.casadi
% differential_states: 
%   - name: pos
% controls: 
%   - name: dpos
  
  
  
%     \end{minted}
% \end{minipage}
% % %\vspace{-3mm}
% % \caption{Overview architecture of the \impact toolchain showing the dependencies and the interaction between modules.}
% % \label{fig:structure}
% % %\vspace{-2mm}
% % \end{figure}
% \begin{rem}
% The model defined within \impact can be linear or nonlinear.
% \end{rem}

\textit{2) FMU handler:} This module allows the user to load FMUs -- an industry standard to define containers that represent black-box (input/output) models -- as \casadi functions to be used within the OCP definition. By calling the \lstinline[style=pythoninline]{add_simulink_fmu()} method of the MPC class, the FMU is wrapped into a \codename{C++} file, which is then compiled and loaded back as a \casadi external function. When the FMU provides derivatives (forward derivatives per FMI standard 2.0), these can be used. Otherwise, \casadi uses finite differences. In a further stage, FMU handling should be absorbed into the YAML file approach.

\textit{3) MPC specification:} This module inherits the functionality of the OCP class of \codename{Rockit} to enable the specification of the OCPs underpinning MPC. With the OCP class, \codename{Rockit} allows the definition of (multi-stage) OCPs by (i) managing symbolic variables for system states $\mathbf{x}$, system inputs $\mathbf{u}$, and algebraic states $\mathbf{z}$, (ii) associating dynamics to $\mathbf{x}$ and algebraic equations to $\mathbf{z}$ as in \eqref{eq:ocp_dynamics} and \eqref{eq:ocp_algebraic}, (iii) composing the objective function \eqref{eq:ocp_objective} by adding functions evaluated at different instants within the OCP horizon, and (iv) setting path or boundary constraints to expressions or variables as in \eqref{eq:ocp_init} and \eqref{eq:ocp_path}. When choosing a third-party OCP plugin, restrictions on the problem specification may apply.
% Moreover, \codename{Rockit} provides direct methods such as multiple-shooting, single-shooting, direct collocation and B-splines to transcribe the defined OCP \eqref{eq:ocp} into an NLP \eqref{eq:nlp} that can be solved by any of the solvers interfaced by \codename{CasADi}, or external methods interfacing third-party optimization frameworks to transcribe the OCP into specific structures required by such tools, as already explained in Section \ref{sec:preliminaries}.
%
The MPC specification is also used for result post-processing capabilities which allow the user, for instance, to retrieve the values of specific variables or expressions in the OCP solution, or to interpolate the solution on a refined grid of integration points.

\textit{4) Code serialization:} This module allows the serialization of the expression graph created by \casadi to define the MPC solver. This allows to save an MPC solver instantiation (including the functions that define the OCP) into a 
% \lstinline[style=pythoninline]{.casadi} 
file that can be then loaded from \codename{Python}, \codename{MATLAB} or \codename{C++}. This module relies on the \lstinline[style=pythoninline]{save()} and \lstinline[style=pythoninline]{load()} methods of the MPC class.
In a similar fashion, instances of the \codename{IMPACT} Python module can also be saved and loaded.

\textit{5) Code export:} %This module inherits the functionality of the OCP class of \codename{Rockit},
%
By calling the \lstinline[style=pythoninline]{export()} method of the MPC class, the user generates multiple artifacts that allow the prototyping and deployment of a solver within an MPC implementation.
% Specifically, 
The main artifacts depicted in Figure \ref{fig:workflow} are (i) an \impact library callable through the \impact \codename{C} API, (ii) a numerical backend library containing a concrete low-level problem formulation coupled to a solver that is either included as fully self-contained \codename{C} code, linked in with a dependency on the \codename{C++} \casadi runtime library and chosen solver plugin such as \codename{IPOPT}, or linked in as third-party dependencies such as \codename{OSQP} or \codename{GRAMPC}, and (iii) an MPC-ready \impact \codename{Simulink} block. 
%
%
% Conversely, the \impact \codename{C} API is an interface that makes the MPC specification agnostic to the solver being code-generated or not. It creates a dependency on the \codename{C++} \casadi runtime library and the NLP solver itself. This interface is accompanied by \codename{Python} bindings to make the \impact \codename{C} API callable from \codename{Python} as well.
%The \impact \codename{C} API is an interface that makes the MPC specification agnostic to the solver being code-generated or not. 
%It creates a dependency on the \codename{C++} \casadi runtime library and the NLP solver.

The \impact library is accompanied by \codename{Python} bindings. More details can be found in Section \ref{sec:C_API}.

Self-contained \codename{C} code
% , also referred as generated \codename{C}-code, 
is dependency-free and requires only a \codename{C} compiler to be deployed in any compatible target. It requires every element of the MPC solver instantiation to be compatible with code-generation -- e.g., if the user selects \codename{IPOPT}, which cannot be code-generated, no self-contained \codename{C} code of the MPC solver can be generated.
% . For instance, \codename{IPOPT} cannot be code-generated and, therefore, no self-contained \codename{C} code of the MPC solver can be generated if the user selects \codename{IPOPT} as nonlinear solver.

The 
% MPC-ready 
\impact \codename{Simulink} block is based on a code-generated custom \codename{C} S-function. \impact generates a \lstinline[style=pythoninline]{.slx} container based on the \codename{C} API  and linked to the generated \codename{C} files, and can be directly used within a \codename{Simulink} model. \codename{Simulink} has become a de-facto tool for simulation and prototyping of control systems. This artifact allows \impact users to easily prototype their designed MPC with no extra steps. Moreover, if the linked \codename{C} file is self-contained, the generated \codename{Simulink} block would be compatible with the \codename{Simulink} coder. This way, the MPC-ready \impact \codename{Simulink} block could be code-generated as part of a larger \codename{Simulink} model and deployed into real-time targets without additional engineering effort.
Compatibility with \codename{Simulink} coder is also expected when third-party dependencies are open-source and \codename{C} based, but this worflow has not yet been validated.

The three artifacts include \casadi functions for the MPC solver (with parametric and hot-start inputs), forward simulation of the system dynamics, DAEs, performance objective, among others. In addition, they output statistics of the solution such as solution time, status, optimality of the solution and number of iterations. These provide the user with a great deal of flexibility to implement and prototype the MPC solution within a simulated or real control loop. Note that once the artifacts are generated, the only values that can be modified within the problem are the parameters $\mathbf{p}$.

% {\color{red}
% https://groups.google.com/g/casadi-users/c/rnBC_a2WULk/m/slpyu-QGAgAJ
% Both methods end up looking like a mex-file, but the dependencies (libraries) of that mex-file are much different.

% Method 1 works with true code-generation: you get a dependency on self-contained C code.
% There is a reasonable chance this will work on your embedded system as-is.

% Method 2 does not involve code-generation: you get a dependency on the CasADi runtime (a library of C++ code) and a dependency on Ipopt (a library involving C++ and Fortran).
% This will work effectly on your desktop, but getting this to run on dSpace could give you a real headache.
% It would involve making source builds of casadi and Ipopt for your embedded target. Check it your target has support for C++ and Fortran.
% If not, you'd probably need some llvm magic to make that happen.}


 
%rockit based, all available solver in Rockit are available in IMPACT too(including state of the art in-house developed solvers ref(David SLP, Fatrop)))
%Provides a C application programming interface (API)
%
%
%Flexible (C/Python/Matlab), Extensible (solver plugins), Composition (builds on top of solid background)





\subsection{Toolchain Workflow}
\label{sec:workflow}
This section has given details on the architecture of \impact and its dependencies. It is now necessary to explain the workflow proposed within \impact for the user to specify an MPC, prototype its solution, and deploy it. A general overview of the workflow is presented in Fig. \ref{fig:workflow}.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.43\textwidth]{figures/IMPACTworkflow.png}
\vspace{-1.5ex}
\caption{Overview of the workflow of the \impact toolchain.}
\label{fig:workflow}
% \vspace{-5ex}
\end{figure}

The workflow in the \impact toolbox is described as follows by means of a simple example involving the control of a pendulum. A description of each step is provided followed by the code snippet associated with it. 

First of all, the user must import the \impact module and instantiate an object of the MPC class. The argument \lstinline[style=pythoninline]{T=2.0} sets the prediction horizon $T$ to a fixed value. However, $T$ could be considered as a decision variable within a free time problem by passing \lstinline[style=pythoninline]{T=FreeTime(2.0)} as argument, where \lstinline[style=pythoninline]{2.0} is an initial guess for this variable.
{
\vspace{-0.5ex}
\begin{lstlisting}[style=pythonstyle]
from impact import *
mpc = MPC(T=2.0)
\end{lstlisting}
\vspace{-1ex}
}
Afterwards, the system model should be declared. As mentioned in Section \ref{sec:structure}, this can be done by manually writing the ODE or DAE -- i.e., using instances of states and inputs within the MPC class --, or by loading a YAML file, which is the option shown in the code snippet below.
{
\vspace{-2ex}
\begin{lstlisting}[style=pythonstyle]
pendulum = mpc.add_model('pendulum','pendulum.yaml')
\end{lstlisting}
\vspace{-1.5ex}
}

% Once the system model has been defined, the user can instantiate the elements of the vector of parameters $\mathbf{p}$. In the example, these are the current state (\lstinline[style=pythoninline]{x_current}), a desired final state (\lstinline[style=pythoninline]{x_final}), and the weights (\lstinline[style=pythoninline]{weights}) to be used in the objective function.
Once the model has been defined, the user can instantiate the elements of the vector of parameters $\mathbf{p}$, such as the current state (\lstinline[style=pythoninline]{x_0}), a desired final state (\lstinline[style=pythoninline]{x_f}), and the weights (\lstinline[style=pythoninline]{Wt}) to be used in the objective.
{
\vspace{-0.5ex}
\begin{lstlisting}[style=pythonstyle]
x_0 = mpc.parameter('x_0',pendulum.nx)
x_f = mpc.parameter('x_f',pendulum.nx)
Wt  = mpc.parameter('Wt',2)
\end{lstlisting}
\vspace{-1.5ex}
}

In a high-level way, the objective and constraints are then defined 
% within the MPC specification environment 
by using the methods \lstinline[style=pythoninline]{mpc.add_objective()} and \lstinline[style=pythoninline]{mpc.subject_to()} directly using state and control names. Note that, by using \lstinline[style=pythoninline]{mpc.at_t0()} or \lstinline[style=pythoninline]{mpc.at_tf()} the user can specify boundary constraints.
\begin{lstlisting}[style=pythonstyle]
# Objective 
mpc.add_objective(mpc.integral(Wt[0]*pendulum.F**2 + Wt[1]*pendulum.dphi**2))
# Boundary constraints
mpc.subject_to(mpc.at_t0(pendulum.x) == x_0)
mpc.subject_to(mpc.at_tf(pendulum.x) == x_f)
# Path constraints
mpc.subject_to(-2 <= (pendulum.F <= 2 ))
\end{lstlisting}
\vspace{-1.5ex}
The nonlinear optimization solver to be used is defined by means of the \lstinline[style=pythoninline]{mpc.solver()} method, for which the user provides several 
% solver 
options depending on the selected solver. In this case, the SQP method of \casadi has been selected.
\begin{lstlisting}[style=pythonstyle]
mpc.solver('sqpmethod',options={...})
\end{lstlisting}
\vspace{-1.5ex}
The transcription method is defined either by using a direct method provided by \codename{Rockit} or an external method provided by a plugin to an optimization tool such as \codename{GRAMPC}. Here, \lstinline[style=pythoninline]{N} corresponds to the number of discretization points $N$, while \lstinline[style=pythoninline]{intg='rk'} sets a $4$th-order Runge Kutta integrator to discretize the system dynamics.
\begin{lstlisting}[style=pythonstyle]
# Direct method, option 1
method = MultipleShooting(N=40,intg='rk')
# External method, option 2
method = external_method('grampc',N=40,grampc_options=...)
# Actually set the selected method within the MPC environment
mpc.method(method)
\end{lstlisting}
\vspace{-1.5ex}
The user can now set the values of the parameters $\mathbf{p}$ and execute the solver directly in \codename{Python}.
\begin{lstlisting}[style=pythonstyle]
mpc.set_value(x_0, [0.5,0,0,0]) # Set parameters
mpc.set_value(x_f, [0,0,0,0])
mpc.set_value(Wf, [1,1]))
solution = mpc.solve() # Solve the OCP
\end{lstlisting}
Finally, the user can generate the three artifacts explained in Section \ref{sec:structure} by executing the following code.
\begin{lstlisting}[style=pythonstyle]
mpc.export("pendulum")
\end{lstlisting}
\vspace{-1.5ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The workflow in the IMPACT toolbox is described as follows by means of a simple example involving the control of a pendulum. A code snippet A description of each step is provided followed by the code snippet associated with it. 
% {
% % \vspace{-3ex}
% \begin{minted}[bgcolor=backcolour,fontsize=\scriptsize]{python3}
% from impact import *
% # Instantiate MPC object
% mpc = MPC(T=2.0)
% # Define model
% pendulum = mpc.add_model('pendulum','pendulum.yaml')
% # Define parameters
% x_current = mpc.parameter('x_current',pendulum.nx)
% x_final   = mpc.parameter('x_final',pendulum.nx)
% weights   = mpc.parameter('weights',2)
% # Define objective 
% mpc.add_objective(mpc.integral(weights[0]*pendulum.F**2 
%                              + weights[1]*cart_pendulum.pos**2))
% # Boundary constraints
% mpc.subject_to(mpc.at_t0(pendulum.x) == x_current)
% mpc.subject_to(mpc.at_tf(pendulum.x) == x_final)
% # Path constraints
% mpc.subject_to(-2 <= (pendulum.F <= 2 ))
% mpc.subject_to(-2 <= (pendulum.pos <= 2))
% # Set solver
% mpc.solver('sqpmethod',options={...})
% # Direct method, option 1
% method = MultipleShooting(N=40,intg='rk')
% # External method, option 2
% method = external_method('grampc',N=40,grampc_options=...)
% # Actually set the selected method within the MPC environment
% mpc.method(method)
% # Set parameter values
% mpc.set_value(x_current, [0.5,0,0,0])
% mpc.set_value(x_final, [0,0,0,0])
% mpc.set_value(weights, [1,1]))
% # Solve the OCP
% solution = mpc.solve()
% # Export code
% mpc.export("pendulum")
% \end{minted}
% }

% First of all, the user must import the \impact library and instantiate an object of the MPC class. The argument \lstinline[style=pythoninline]{T=2.0} sets the prediction horizon $T$ to a fixed value. However, $T$ could be considered as a decision variable within a free time problem by passing \lstinline[style=pythoninline]{T=FreeTime(2.0)} as argument, where \lstinline[style=pythoninline]{2.0} is an initial guess for this variable.

% Afterwards, the system model should be declared. As mentioned in Section \ref{sec:structure}, this can be done by manually writing the ODE or DAE --i.e., using instances of states and inputs within the MPC class--, or by loading a YAML file, which is the option shown in the code snippet.

% Once the system model has been defined, the user can instantiate the elements of the vector of parameters $\mathbf{p}$. In the example, these are the current state (\lstinline[style=pythoninline]{x_current}), a desired final state (\lstinline[style=pythoninline]{x_final}), and the weights (\lstinline[style=pythoninline]{weights}) to be used in the objective function.

% The objective and constraints are then defined within the MPC specification environment by using the methods \lstinline[style=pythoninline]{mpc.add_objective()} and \lstinline[style=pythoninline]{mpc.subject_to()}. Note that, by using \lstinline[style=pythoninline]{mpc.at_t0()} or \lstinline[style=pythoninline]{mpc.at_tf()} the user can specify boundary constraints.

% The nonlinear optimization solver to be used is defined by means of the \lstinline[style=pythoninline]{mpc.solver()} method, for which the user can provide several solver options depending on the selected solver. In this case, the SQP method of \casadi has been selected.

% The transcription method is defined either by using a direct method provided by \codename{Rockit} or an external method provided by a plugin to an optimization tool such as \codename{GRAMPC}. Here, \lstinline[style=pythoninline]{N} corresponds to the number of discretization points $N$, while \lstinline[style=pythoninline]{intg='rk'} sets a $4$th-order Runge Kutta integrator to discretize the system dynamics.

% The user can now set the values of the parameters and execute the solver directly in \codename{Python}.

% Finally, the user can export the code into the three artifacts explained in Section \ref{sec:structure}.

% This export command generates the files:
% \begin{itemize}
%     \item serialized function: \lstinline[style=pythoninline]{pendulum.casadi}
%     \item \codename{C} API: \lstinline[style=pythoninline]{pendulum.c}, \lstinline[style=pythoninline]{pendulum.h}
%     \item self-contained \codename{C}-code: \lstinline[style=pythoninline]{pendulum_codegen.c}, \lstinline[style=pythoninline]{pendulum_codegen.h} 
%     \item \lstinline[style=pythoninline]{library_pendulum.slx}, \lstinline[style=pythoninline]{pendulum_s_function_level2.c}
%     \item \lstinline[style=pythoninline]{impact.py}
% \end{itemize}

%
For rapid prototyping of the exported code the user can: (i) run the generated \texttt{hello\_world} examples in \codename{C} or \codename{Python} which use the \codename{C} API, or (ii) use the generated \codename{Simulink} block from the generated \lstinline[style=pythoninline]{.slx} file in a \codename{Simulink} model. Since we are using the SQP method of \codename{CasADi}, which is compatible with code-generation, in this example we could deploy the code-generated code or the \codename{Simulink} block in a real-time target architecture.

% probably I overlooked it, but is there a description of the things available to analyse the solving time, optimality, etc.... 


\subsection{\codename{IMPACT} \codename{C} API}
\label{sec:C_API}

The \codename{IMPACT} \codename{C} API defines a unified API to use the MPC solver exported by \codename{IMPACT}. It represents the core artifact of the code export functionality and is a layer of abstraction that makes the implementation agnostic to the content of the generated MPC solver, e.g., self-contained \codename{C} code with \codename{C} solver, \codename{C++} code that still depends on \codename{CasADi} and/or third-party solvers. 
% In addition, 
It provides rich functions to set the inputs of the MPC solver (parameters) and get the values of variables from the optimized solution.
For the sake of completeness, we present below a minimum example of the use of the \impact \codename{C} API 
% \textcolor{red}{from \codename{Python}} 
for the pendulum example presented in Section \ref{sec:workflow}.
% \begin{minted}[
%     % bgcolor=backcolour,
%     fontsize=\tiny]{python3}
% from impact import Impact
% # Load the generated artifact
% impact = Impact("pendulum",src_dir="..")
% # Example - Set a parameter
% impact.set("x_0", impact.ALL, 0, impact.FULL, x_meas)
% # Solve a single OCP
% impact.solve()
% # Get solution trajectory
% x_opt = impact.get("x_opt", impact.ALL, impact.EVERYWHERE, impact.FULL)
% \end{minted}
%
% Here, the exported artifact named \lstinline[style=pythoninline]{"pendulum"} is loaded. By using the \lstinline[style=Cinline]{set()} method, 
% the parameter \lstinline[style=pythoninline]{"x_0"} is set with a value \lstinline[style=pythoninline]{x_meas}. 
% % a value \lstinline[style=pythoninline]{x_meas} is assigned to parameter \lstinline[style=pythoninline]{"x_current"}.
% The second argument \lstinline[style=pythoninline]{impact.ALL} tells \impact that all the elements of the specified parameter are set. The user can use \lstinline[style=pythoninline]{"pendulum.phi"} instead of \lstinline[style=pythoninline]{impact.ALL} to set the parameter corresponding to the angle \lstinline[style=pythoninline]{phi}, for instance.
% The third argument \lstinline[style=pythoninline]{0} defines the time instance within the horizon for which the parameter is set. 
% Another option would be \lstinline[style=pythoninline]{impact.EVERYWHERE}, which sets 
% % Here, \lstinline[style=pythoninline]{impact.EVERYWHERE} would set
% the parameter for the whole horizon. The fourth argument represents a flag for data ordering, such as \lstinline[style=pythoninline]{impact.FULL}, \lstinline[style=pythoninline]{impact.ROW_MINOR}, or \lstinline[style=pythoninline]{impact.COLUMN_MAJOR}.
% The \lstinline[style=pythoninline]{solve()} method executes the MPC solver. Finally, the optimal solution is retrieved from the artifact using the \lstinline[style=pythoninline]{get()} method, with the arguments following the same logic as in \lstinline[style=Cinline]{set()}. 
% This example shows the solution of one OCP. 
% To implement MPC, the \lstinline[style=Cinline]{set()}, \lstinline[style=pythoninline]{solve()} and \lstinline[style=pythoninline]{get()} functions are executed within a loop.
% % While this example solves one OCP, an MPC implementation would require \lstinline[style=Cinline]{set()}, \lstinline[style=pythoninline]{solve()} and \lstinline[style=pythoninline]{get()} to be executed within a loop.
%
% \bigskip
%
% \begin{minted}[
%     % bgcolor=backcolour,
%     fontsize=\tiny]{c}
% // Create the artifact structure
% impact_struct* m = impact_initialize();
% // measure states in x_meas variable
% app_measure_state(x_meas);
% //  Example - Set a parameter
% impact_set(m, "x_current", IMPACT_ALL, 0, x_meas, IMPACT_FULL);
% // Solve a single OCP
% impact_solve(m);
% // Get input solution trajectory
% impact_get(m, "u_opt", IMPACT_ALL, IMPACT_EVERYWHERE, U, IMPACT_FULL);
% // send input solution to u
% app_send_control(u);
% \end{minted}
% \begin{minted}[
%     % bgcolor=backcolour,
%     fontsize=\tiny]{c}
% impact_struct* m = impact_initialize();
% impact_set(m, "x_0", IMPACT_ALL, 0, x_meas, IMPACT_FULL); // Set a parameter
% impact_solve(m); // Solve a single OCP
% // Get optimal input for first time instance
% impact_get(m, "u_opt", IMPACT_ALL, 0, U, IMPACT_FULL);
% \end{minted}
\begin{lstlisting}[style=Cstyle]
impact_struct* m = impact_initialize();
impact_set(m, "x_0", IMPACT_ALL, 0, x_meas, IMPACT_FULL); // Set a parameter
impact_solve(m); // Solve a single OCP
// Get optimal input for first time instance
impact_get(m, "u_opt", IMPACT_ALL, 0, U, IMPACT_FULL);
\end{lstlisting}
\vspace{-1.5ex}
Here, \lstinline[style=Cinline]{impact_initialize()} instantiates the exported \impact library and returns a pointer \lstinline[style=Cinline]{m} to it.
% The \lstinline[style=Cinline]{app_measure_state()} function reads the states in the variable \lstinline[style=Cinline]{x_meas}
By using the \lstinline[style=Cinline]{impact_set()} method, the parameter \lstinline[style=Cinline]{x_0} is set with a user-defined value \lstinline[style=Cinline]{x_meas}. %which should be previously defined by the user.
% in the structure \lstinline[style=Cinline]{m}. 
The third argument \lstinline[style=Cinline]{IMPACT_ALL} tells \impact that all the elements of the specified parameter are set. The user can use \lstinline[style=Cinline]{"pendulum.phi"} instead of \lstinline[style=Cinline]{IMPACT_ALL} to set the parameter corresponding to the angle \lstinline[style=Cinline]{phi}, for instance.
The fourth argument \lstinline[style=Cinline]{0} defines the time instance within the horizon for which the parameter is set. 
Another option is \lstinline[style=Cinline]{IMPACT_EVERYWHERE}, which sets the parameter for the whole horizon. The sixth argument combines flags representing repetition (\lstinline[style=Cinline]{IMPACT_FULL}, \lstinline[style=Cinline]{IMPACT_HREP}) and data ordering (\lstinline[style=Cinline]{IMPACT_ROW_MINOR},  \lstinline[style=Cinline]{IMPACT_COLUMN_MAJOR}).
The \lstinline[style=Cinline]{impact_solve()} function executes the MPC solver. Then, an element of the solution -- i.e., the optimal control input \lstinline[style=Cinline]{u_opt} -- is retrieved and assigned to a variable \lstinline[style=Cinline]{U} by using \lstinline[style=Cinline]{impact_get()}, with the arguments mirroring \lstinline[style=Cinline]{impact_set()}. 
% Finally, the \lstinline[style=Cinline]{app_send_control()} function assigns the control value to the variable \lstinline[style=Cinline]{u}.
This example shows the solution of one OCP. 
% To implement MPC, the \lstinline[style=Cinline]{app_measure_state()}, \lstinline[style=Cinline]{impact_set()}, \lstinline[style=Cinline]{impact_solve()}, \lstinline[style=Cinline]{impact_get()} and \lstinline[style=Cinline]{app_send_control()} functions are executed within a loop.
To implement (N)MPC, the \lstinline[style=Cinline]{impact_set()}, \lstinline[style=Cinline]{impact_solve()}, and \lstinline[style=Cinline]{impact_get()} methods are executed in a loop. More methods are defined in the API, e.g., to retrieve statistics and perform debugging.


%impact C API stuff needs to be corrected 
% you present it as something optional 
% it is central to the export functionality 
% S Function depends on it (fix arrows in figure) 
% impact C API is always there 
% it's a wall behind which anything can be hidden e.g. generated c code with c solver, c++ code that still depends on casadi, third party solvers