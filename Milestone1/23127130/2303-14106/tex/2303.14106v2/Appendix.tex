\section{Appendix}

Section~\ref{sec:background} gives a brief overview on the main concepts of asynchronous circuits used in this work.
Sections~\ref{sec:ring} and~\ref{sec:multi} demonstrate the applicability of our approach to circuits different than the linear pipeline.

\subsection{Asynchronous circuits: overview on concepts used in this work}\label{sec:background}

\paragraph{QDI circuit}
Asynchronous circuits, unlike their synchronous counterparts, are not governed by a rigid time grid that centrally determines the communication between any two entities. Alternatively, data transfer follows a closed-loop control provided by a local handshake process that specifies when new data is available for sending and recognizes when old data has been processed. \emph{Delay-insensitive (DI)} circuits offer the ultimate timing flexibility by automatically adapting to gate and wire delays. Very few circuits, however, can actually be designed following the DI delay model, since such circuits can provably be constructed only from inverters (1 input) and Muller C-elements (MCEs, 2 inputs) when restricted to single-output gates \cite{martin1990limitations,Manohar2017theorem}. By adding the \emph{isochronic fork} constraint, one obtains the class of \emph{quasi delay-insensitive (QDI)} circuits, which is only lightly-constrained with respect to timing and provides sufficient expressivity. This timing assumption requires the delays of the individual paths of an isochronic fork to be about equal, assuring that a signal arrives at all ends of the fork at about the same time~\cite{beerel2010designer,martin1986compiling}.

\paragraph{Muller C-element}
The MCE is a fundamental building block in QDI circuits, as it can be seen as the simplest form of storage element, and it is crucially used in the so called \emph{completion detection (CD)} units. It can also serve as a control unit in some QDI buffer templates. The MCE can be considered as an AND gate with hysteresis. In case of matching inputs, it sets the output to this corresponding value; when inputs don't match, the output retains its previous logic level.

\paragraph{QDI pipeline}
In a QDI pipeline, data is issued by a source and travels through sequential stages of latches, which are sometimes separated by logic function units, until it reaches the sink (in absence of logic functions, the pipeline acts as a data queue). Figure~\ref{fig:stage} shows the components of one such stage. When new data is detected at the input side, the buffer captures it only when an acknowledgement from the next stage is received, indicating that old data has been stored. The CD then signals the receipt of this new data item by issuing an acknowledgment signal to its previous stage, closing the control loop.

Since there is no explicit request signal in the QDI design style, data must be encoded using a so-called DI code. The encoding depends on the communication protocol in use. The \emph{return-to-zero (RTZ)}, or \emph{4-phase}, protocol is commonly used along with the \emph{dual-rail} encoding scheme, where one data bit is encoded on two wires, namely the \emph{true} and \emph{false} rails: Any two data items are separated by a \emph{spacer}. This spacer is encoded by logic ‘0’ on all rails and carries no information. Only one rail for each bit can be set to logic ‘1’ at a time; having both rails set to ‘1’ violates the protocol and is considered \emph{illegal}. The CD indicates validity and completeness of a data item or a spacer, issuing the appropriate \emph{ack} to the other stage. The CD is made up of a simple OR gate in the case of a single bit, and employs additional logic for higher bit-widths, as shown in Figure~\ref{fig:CD}.


\begin{figure}
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figs/Latch_components.pdf}
        % first figure itself
        \caption{QDI pipeline stage with latch components}
        \label{fig:stage}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figs/CD_internal.pdf} 
        % second figure itself
        \caption{The internal structure of a multi-bit CD using OR gates and MCEs}
        \label{fig:CD}
    \end{minipage}
\end{figure}


\subsection{Comparison of fault-tolerance for Muller pipeline rings}\label{sec:ring}

Another common asynchronous pipeline
construct is rings. We interpret the pipeline operation to implement a 4-phase QDI protocol in the following. Shown in Figure~\ref{fig:muller3_ring}, is a 3-stage Muller pipeline where one \emph{data token}, one \emph{spacer}, and one \emph{bubble} keep rotating. Note that when using the term \emph{token} on its own, it encompasses a data token along with a spacer, so 1 token means one of each.
It is possible to also interpret a token to follow the 2-phase communication protocol, and in this case we would double this count.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\columnwidth]{figs/muller3_ring.pdf}
    \caption{Ring 3-stage pipeline. The delays are set to 1 ({\tt INV}) and 5 ({\tt MCE}).}
    \label{fig:muller3_ring}
\end{figure}

In order to study the resilience of a Muller ring w.r.t. the activity inside the pipeline, 
we need to vary its \emph{occupancy}, i.e., the number of data items revolving in it \cite{gill2008performance}. We need at least one bubble in the ring, regardless of how many stages constitute it. When the number of data items in the ring is small, the other stages of the pipeline will be filled with \emph{holes}. When there is more holes than data, the pipeline is said to be \emph{data-limited}; when there is more data than holes, it is said to be \emph{hole-limited} \cite{gill2008performance}. These operation modes correspond to the token-limited and bubble-limited modes, respectively, in the linear Muller pipeline.

We use our tool to study the effect of varying the ring occupancy, by building the ring with a different number of stages and changing the token count. As this is a Muller pipeline, each C-element needs alternating input sequences to be able to transition from $0$ to $1$ every stage.

In order to keep the pipeline running and avoid deadlock, the process of correctly initializing the stages of the ring is crucial. As previously mentioned, there must be at least one bubble in the pipeline. For each combination of tokens and stages, we calculate the number of bubbles needed and we fill the pipeline in the following manner:
\begin{itemize}
    \item If the number of bubbles is much larger than the number of tokens, we start by filling the pipeline with bubbles, and insert tokens equally paced from one another.
    \item If the number of bubbles is much lower than the number of tokens, we start by inserting tokens, and spread the bubbles in between.
    \item If there is only one bubble, it doesn't matter where it is inserted. Same if there is only one token.
    \item A token is always inserted as a data token and a spacer that are not separated by a bubble.
\end{itemize}

The results for these settings are shown in Figure~\ref{fig:muller-ring-sweepTokens}. The first point of each line (from the left) represents the maximum number of tokens allowed for the corresponding number of stages (recall that this count represents, in fact, a data token and a spacer). The top left region represents the bubble-limited operation mode, where one can clearly see that $P(\text{fail})$ gets higher. 
The increasing number of stages also seems to play a role in this trend. From what we have previously observed 
 we can conjecture that this is because an idle (waiting) stage (MCE) has the highest fault probability, while one that processes a token/transition is more resilient. By adding stages while keeping the number of tokens constant, we add idle stages -- consequently $P(\text{fail})$ increases.

As we move to the edges of the token-limited region where the number of bubbles largely exceeds the number of tokens,  $P(\text{fail})$ converges to a steady percentage of approximately 45\%. 


\begin{figure}
    \centering
    \includegraphics[width=0.7\columnwidth]{figs/muller-ring-sweepTokens.png}
    \caption{Influence of number of tokens and stages on the probability to fail $P(\text{fail})$. Ring pipeline with varying number of stages and tokens. Delays as follows: 1 (INV), 5 (MCE). $T=500$. A token encompasses a data token along with a spacer, so 1 token means one of each, following the 4-phase communication protocol. In the case of a 2-phase protocol, this token count is doubled.}
    \label{fig:muller-ring-sweepTokens}
\end{figure}

Finally, we compare throughput and probability to fail as a function of the same ring pipeline with a varying number of (4-phase) tokens.
It has been previously observed \cite{williams1987self,gill2008performance} that the throughput as a function of tokens behaves as a canopy plot: it is low for small numbers of tokens (token-limited), high in the middle, and low for large numbers of tokens (bubble-limited).
Figure \ref{fig:canopy} compares this behavior with the failure probability as determined by our tool for execution prefixes of length $T = 200$.
While the canopy diagram suggests that 4 and 5 tokens yield optimum throughput, the failure probability favors a lower token count. So for maximum performance the better choice would be 4 tokens.
This result is not general and seems to depend on the design choices, but the general strategy should be to also consider $P(\text{fail})$ in the system design.

\begin{figure}
    \centering
    \includegraphics[width=0.7\columnwidth]{figs/canopy.png}
    \caption{Influence of number of tokens on the probability to fail $P(\text{fail})$ and the throughput (in 4-phase tokens per {\tt INV} delay passing {\tt MCE1}). Ring pipeline with 20 stages and varying number of tokens. Delays as follows: 1 (INV), 5 (MCE). $T=200$. A token encompasses a data token along with a spacer (4-phase; for 2-phase interpretation multiply by factor 2).}
    \label{fig:canopy}
\end{figure}


\subsection{Multi-bit QDI designs}\label{sec:multi}

To demonstrate the ability of our tool to handle larger, multi-bit designs,
  we ran the algorithm to determine susceptible windows on execution prefixes
  of duration $T=500$.
As circuits under test we used 4-bit and 8-bit versions of the previously analyzed
  linear and ring pipeline.
Our tool reported the following values for $P(\text{fail})$:
(i) the 3-stage linear pipeline with 4-bit resulted in $0.22$ and with 8-bit in $0.10$.
(ii) the 3-stage ring pipeline with 4-bit resulted in $0.22$ and with 8-bit in $0.16$.
The observed decrease of $P(\text{fail})$ for higher pipeline width is as expected from literature: while the last rail to switch is the most critical one (it triggers the completion detector), the faster bits are less critical and hence contribute to lowering the overall fault probability -- with growing impact for increasing bit number.

All results were obtained within minutes on a MacBook Pro (M2, 2022) with 24~GB RAM.