%\documentclass[main.tex]{subfiles}
\label{sec:model}
%\begin{document}

Following the work by Martin \cite{martin1986compiling}, we model a circuit as a set of production rules.
We extend the model by delays and propagation of non-Boolean values.
We start by definitions of signal values and production rules in our context. 

\paragraph{Signal and signal values}
Signals are from a finite alphabet $S$.
Signals have values that may change over time.
We extend the values a signal may attain from the classical Boolean values $\IB = \{0,1\}$ to the three-valued set $\BX = \{0,\meta,1\}$, where $\meta$ is a potentially non-binary value.
Examples for non-binary values are glitches, oscillations, metastable values, etc.
A signal that has value $\meta$ may, however, be $0$ or $1$.

We will make use of logical operations like $\wedge$ and $\neg$ on the extended domain $\BX$.
If not stated otherwise, we resort to the semantics of the 3-valued Kleene logic, introduced by Goto for these operations; see \cite{brzozowski2001algebras}.
In short, using the classical algebraic interpretation of Boolean formulas on $\{0,1\} \subset \IR$ where, $\neg a \equiv 1 - a$, $a \wedge b \equiv \min(a,b)$, and $a \vee b \equiv \max(a,b)$, one obtains the Kleene semantics by the correspondence $\meta \equiv 1/2$.
For example, one obtains, $1 \wedge \meta = \meta$ and $1 \vee \meta = 1$.

\paragraph{Production rules}
A production rule is a guarded Boolean action with delay.
It is of the form
\begin{align}
G \rightarrow s=1 \ [d] \quad\text{ or }\quad G \rightarrow s=0 \ [d]\enspace,
\end{align}
where the guard $G$ is a logical predicate on signals, $s$ is a signal, and $d \in (0,\infty)$ is the propagation delay.
Intuitively, a production rule with guard $G$,
 action $s = b$, where $b \in \{0,1\}$,
 and delay $d$ sets signal $s$'s value to $b$ upon predicate $G$ being true for $d$ time.

\paragraph{Circuit}
A circuit is specified by:
\begin{itemize}
\item Finite, disjoint sets of input, local, and output signals, denoted by $\calI$, $\calL$, and $\calO$.

\item Initial values for all local and output signals.
  We write $s(0)$ for the initial value of signal $s \in \calL \cup \calO$.

\item A set of production rules $R$ whose guards are predicates on the circuit's signals and whose actions involve only local and output signals.
We require that (i) for each signal $s$, there is at most one production rule that sets $s$ to $1$, and at most one that sets $s$ to $0$,
and (ii) guards of production rules that set a signal $s$ are mutually exclusive for all signal values from $\IB$. 
\end{itemize}

Similarly to Martin \cite{martin1986compiling} we use production rules to model gates: actions that set a value to $1$ correspond to the pull-up stack of a gate and actions that set a value to $0$ to the pull-down stack.
Any meaningful circuit will further have the properties that any local and output signal appears in a production rule that sets it to $0$ and one that sets it to $1$; if not the signal will remain at its initial value for all times.
Further, as already demanded in the last bullet above, the guards of these opposing production rules will not both evaluate to true for any choice of signal values; if not, the pull-up and pull-down stack of this gate will drive the gate's output at the same time.


\paragraph{Signal trace}
A signal trace for signal $s \in S$ is a function $v_s: \IR_0^+ \to \BX$
  mapping the time $t$ to the value of $s$ at time $t$.
By slight abuse of notation we write $s(t)$ for $v_s(t)$.
We restrict signal traces to contain only finitely many value-changes in each finite time interval.

\paragraph{Execution}
It remains to define how a circuit, with a given input, switches signal values.
For that purpose fix a circuit, input signal traces for all its inputs $I$, and a time $T > 0$ until which the execution is to be generated.

Intuitively an \emph{execution induced by the circuit and the input signal traces} is inductively generated via applying the production rules to the current signal values.
If a guard of a production rule is true, its action is scheduled to take place after the rule's delay.

Care has to be taken to handle instability of guards.
If a guard that results in a scheduled action on a signal, but whose action has not yet been applied, becomes false, we remove the scheduled action and instead set the signal to $\meta$ after a small delay $\varepsilon > 0$.
An $\varepsilon$ smaller than the rule's delay
accounts for the fact that non-binary outputs can propagate faster than full-swing transitions.
The signal's value $\meta$ is then propagated accordingly throughout the circuit.
Indeed we will let $\varepsilon \to 0$ in later sections to account for the
  worst case behavior of gates.

Formally, the \emph{execution prefix until time $T$, induced by the circuit and the input signal traces}, is a signal trace prefix until time $T$ for each local and output signal obtained as follows:
\begin{enumerate}
\item Initially, all signals are set to their initial values as specified by the circuit.
Further, the current time $t = 0$, and the set of scheduled actions is empty.

\item Handle unstable guards:
\begin{itemize}
\item For each production rule whose action $s = b$, with $b \in \IB$, currently being scheduled: if the rule's guard evaluates to $0$ or $\meta$, and $s(t) \neq b$ (we say the guard is unstable), then remove the event from the scheduled events and set $s = \meta$. \emph{(generate-$\meta$)}
\end{itemize}

\item Apply actions:
\begin{itemize}
\item For each action $s = v$, with $v \in \BX$, scheduled for time $t$, set $s(t) = v$ and remove the action from the scheduled actions.
\end{itemize}

\item Schedule actions:
\begin{itemize}
\item For each production rule: if its guard evaluates to $1$, schedule the rule's action $s = b$ to take place after the rule's delay $d$, i.e., at time $t + d$ (unless $s(t) = b$ already).

\item For each production rule: if its guard evaluates to $\meta$ and the rule's action is $s = b$ with $s(t) \neq b$, schedule the action $s = \meta$ for time $t + \varepsilon$ (unless $s(t) = \meta$ already). \emph{(propagate-$\meta$)}
\end{itemize}

\item Advance time $t$ to the nearest future time at which an action is scheduled or an input signal switches value.
If $t \geq T$, return the local and output signal traces until time $T$; otherwise continue with step 2.
\end{enumerate}

One observes that an execution prefix until time $T' > T$ is an extension of an execution prefix until time $T$: for each local and output signal $s$, the signal values in both prefixes are identical within $[0,T]$.
We may thus speak of the execution as the limit of execution prefixes until times $T \to \infty$.

\subsection{Example}
As an example let us consider the circuit with input signal $i$, no local signals, and output signal $o$.
As initial value we choose $o(0) = 1$.
The circuit comprises of a single inverter with input $i$, output $o$, and delay $1.0$, i.e., the circuit's production rules are:
\begin{align}
i &\rightarrow o=0 \ [1.0] \label{eq:Rd}\\
\neg i &\rightarrow o=1 \ [1.0]\enspace \label{eq:Ru}.
\end{align}

We consider three input traces: (a) Initially $i(0) = 0$, then $i$
  transitions to $1$ at time $1$ where it remains.
  (b) Prefix like (a), but the input transitions back to $0$ at time $1.5$.
  (c) Like (b), but with value $\meta$ during times $[1,1.5)$.
  
The execution prefixes until time $T = 4$ induced by the above
  circuit and the input signal traces (a), (b), and (c) are depicted
  in Figure~\ref{fig:ex}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\columnwidth]{figs/trace-inv.pdf}
    ~
    \includegraphics[width=0.3\columnwidth]{figs/trace-inv-glitch.pdf}
    ~
    \includegraphics[width=0.3\columnwidth]{figs/trace-inv-glitch-prop.pdf}
    \caption{Execution prefixes until time $T=4$ of an inverter with input {\tt i} and output {\tt o}. 
    Signal value $\meta$ is depicted as a value of $0.5$ and marked red.
    The propagation delay $\varepsilon$ for signal value $\meta$ is set to $0.1$. Left: input signal trace (a). Middle: input signal trace (b). Right: input signal trace (c).}
    \label{fig:ex}
\end{figure}

In the example, input traces~(a) and (b) result in the guard of rule~\eqref{eq:Rd}
  becoming true at time $1$.
Accordingly, an action to set $o = 0$ is scheduled for time $1 + d = 2$.
While in input trace~(a), the guard remains true until time $2$,
  and thus $o$ is set to $0$ at time $2$,
  in input trace~(b), the guard is falsified at time~$1.5$,
  resulting in the action being canceled and $o$ is set to $\meta$ at time~$1.5$ (generate-X in the algorithm).
  
For input trace~(b), we have that the guard of rule~\eqref{eq:Ru} becomes
  true at time $1.5$.
Accordingly the action $o = 1$ is scheduled for time $1.5 + d = 2.5$.
Since the guard remains true until time $2.5$, the action is applied
  resulting in $o(2.5) = 1$.

Finally, input trace (c) demonstrates the algorithmic rule propagate-X in step 5: the $\meta$ value at the input is propagated with propagation delay $\varepsilon = 0.1$ to the output.
Resetting the output to $1$ at time $2.5$ occurs as for input trace (b).


%\end{document}