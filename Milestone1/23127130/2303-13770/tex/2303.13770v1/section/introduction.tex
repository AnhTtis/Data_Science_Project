Smart contracts are programs deployed on a blockchain~\cite{zheng2020overview}. Due to the decentralized and trusted authorities guaranteed by blockchain technology, smart contracts are widely used to develop decentralized applications (DApps) in a variety of domains such as games, government, and finance~\cite{buterin2014next}. However, smart contracts are also restricted by the immutability of blockchain~\cite{hofmann2017immutability}. That is, a contract cannot be patched once deployed. A vulnerable contract could be leveraged by malicious attackers and result in serious problems, e.g., financial loss. Therefore, it is important to ensure the correctness of a contract before deploying it. This is a challenging task in practice for contract developers.

A number of vulnerabilities have been discovered for smart contracts from real-world attacks or through theoretical analysis~\cite{ji2020deposafe, ma2021pluto, ferreira2020aegis}. For example, 37 types of vulnerabilities are recorded in the SWC registry~\cite{SWC}, and the NCC Group~\cite{NCC} lists the top ten vulnerabilities, e.g., reentrancy and time manipulation. To enable developers to recognize and fix vulnerabilities, many approaches have been proposed to detect vulnerabilities in contracts~\cite{zhuang2020smart, bunz2020zether, ma2021pluto}. Reentrancy is a vulnerability that has been extensively studied by existing research as it could lead to huge financial loss, e.g., the DAO attack~\cite{mehar2019understanding} caused a loss of around 150 million dollars.

Existing reentrancy detection approaches mainly focus on the \emph{call.value()}\footnote{This is a typical ether transfer function in Solidity. The function may have different forms in different versions of Solidity. In this paper, we use call.value() for simplicity.} operations in smart contracts. In Section~\ref{background}, we explain a reentrancy issue using an example (see Fig.~\ref{fig:Reexp}). The reentrancy is caused by the delayed update of the state variable \emph{userbalance} behind the call to \emph{call.value()}. Reentrancy detection approaches aim to discover the payments that could be repeatedly incurred by external calls using various techniques such as symbolic execution~\cite{baldoni2018survey}, fuzzing~\cite{li2018fuzzing}, and neural networks~\cite{zhuang2020smart}. Two recent empirical studies~\cite{durieux2020empirical, xue2020cross} conducted two years ago revealed that there can be many false positives detected by the approaches at that time. The contracts used in these studies are written in Solidity version $\leq$0.6.0. In the past two years, the Solidity language has gone through several versions with significant changes~\cite{soliditydocs}. Inspired by these studies, a number of approaches have been upgraded or newly proposed. However, there has been no large-scale study on the performance of state-of-the-art reentrancy detection approaches on the contracts developed in Solidity version $>$0.6.0. Moreover, it has not yet been confirmed whether existing approaches could detect other reentrancy issues in spite of those related to \emph{call.value()}, as such reentrancy issues seem to be able to be detected by the official IDE, Remix~\cite{Remix}.

In this work, we conduct a large-scale empirical study on the capability of existing approaches in detecting reentrancy from smart contracts. We collect the verified Solidity code of all 230,548 contracts from Etherscan~\cite{Etherscan} (a leading block explorer and analytics platform for Ethereum) on October 13, 2021, and select five well-known or recent tools such as Mythril~\cite{mueller2018smashing} and Sailfish~\cite{bose2022sailfish} that can locate the possibly defective functions with reentrancy issues in contracts. After filtering duplicate contracts with the same bytecode, we obtain 139,424 contracts without duplication. Then, we use the tools to analyze the contracts, which results in 21,212 reentrant contracts. Next, we manually examine the defective functions of the reentrant contracts by recruiting 50 participants (including 27 undergraduates, 21 masters, and two PhDs). From the examination results, we build a set of 34 true positive contracts with reentrancy and a set of 21,178 false positive contracts without reentrancy. We also analyze the causes of the true and false positives. Using the two sets of contracts, we evaluate the tools. Furthermore, we test the tools on the contracts with reentrancy attacks reported in the past two years and also verify the true positive reentrant contracts using Remix. The results are as follows: 1) more than 99.8\% of the reentrant contracts detected by the tools are false positives with eight types of causes; 2) the true positive reentrant contracts are all related to \emph{call.value()}, 58.8\% of which can be discovered by Remix; and 3) the tools fail to detect reentrancy issues from the recently attacked contracts. Based on the results, we conclude that existing works on reentrancy detection have poor performance and may be outdated, and researchers should shift their attention from \emph{call.value()} to focus on discovering and detecting new reentrancy patterns. 

The main contributions of this work are outlined below:

\begin{itemize}
    \item We study the capability of five well-known or recent reentrancy detection tools on 139,424 smart contracts.
    \item We manually examine 21,212 reentrant contracts detected by the tools and build a set of 34 true positive contracts with reentrancy and a set of 21,178 false positive contracts without reentrancy. We further summarize eight types of causes that lead to false positives and find that all of the true positives are caused by \emph{call.value()}.
    \item We evaluate the tools based on the two manually built sets of true and false positive reentrant contracts. Moreover, we verify the true positives using Remix and test the tools on the contracts with recent reentrancy attacks. Based on the results, we provide insightful guidelines for researchers.
    \item We release our experimental data at GitHub~\cite{EData}, including the 230,548 contracts, the detection results of the tools, and the two sets of true and false positive contracts, to provide a benchmark for researchers to conduct future work on reentrancy detection.
\end{itemize}

The rest of the paper is organized as follows. Section~\ref{background} introduces smart contracts and reentrancy vulnerability. Section~\ref{meth} describes our research methodology. Section~\ref{res} presents the results. Section~\ref{dis} discusses the results and describes two additional tests. Section~\ref{threats} analyzes the threats to validity of our study. Section~\ref{relw} reviews the related work. Section~\ref{con} concludes the paper and discusses future work.