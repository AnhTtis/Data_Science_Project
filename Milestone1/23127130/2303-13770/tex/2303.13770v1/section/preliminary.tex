\begin{figure}
	\centering
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1,escapechar=\%]
contract SimpleDAO {
    mapping (address => uint) public userbalance;
    ...
    function withdraw(uint amount) public{
        if (userbalance[msg.sender]>= amount) {
            require(msg.sender.call.value(amount)());
            userbalance[msg.sender]-=amount;
        }
    }  
}
	\end{lstlisting}
	\caption{Simple example of reentrancy}
	\label{fig:Reexp}
\end{figure}

\subsection{Smart Contracts}
Smart contracts are programs running on a blockchain. In general, smart contracts are written in Solidity~\cite{soliditydocs}, one of the most popular languages for smart contracts. The Solidity code of a smart contract is compiled into bytecode and then deployed on blockchain. In addition, the compilation process generates the application binary interface (ABI) to facilitate subsequent calls and analysis of smart contracts.

\subsection{Reentrancy}
From the 150 million USD DAO attack in 2016 to the 80 million USD Fei Protocol attack in 2022, the reentrancy vulnerability has caused huge financial loss. In this section, we describe how a reentrancy attack could happen with a simplified version of the DAO smart contract, as shown in Fig.~\ref{fig:Reexp}. The example contract is developed for asset management. It uses the variable \textit{userbalance} (line 2) to record the balance of each user and allows users to call the \textit{withdraw()} function (line 4) to withdraw their balance. In \textit{withdraw} function, the contract first checks if the caller (represented by the address variable \textit{msg.sender}) has enough balance (line 5); then, it transfers the requested \textit{amount} of ether to the caller and subtracts the \emph{amount} from the caller's balance recorded in the variable \textit{userbalance}. However, Solidity introduces a special mechanism named the ``fallback function''. Users can write their own code in the fallback function and the function will be executed if the contract receives ether from other addresses. In the example case, the ether transfer function \textit{call.value()} (line 6) will automatically call the fallback function of the caller contract and thus the caller can take over the control flow. Attackers can deploy malicious code in the fallback function to repetitively invoke the \textit{withdraw()} function. Note that in the second invocation of \textit{withdraw()}, line 7 has not been executed since the invocation begins at the \textit{call.value()} function in line 6, and thus the \emph{userbalance} has not been changed at this time. As a consequence, the condition check (line 5) of the second invocation is passed and the victim contract will transfer ether to the caller repeatedly until the balance of the contract is drained.