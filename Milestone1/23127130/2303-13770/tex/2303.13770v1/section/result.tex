In this section, we present and discuss the results of the analytical procedure described in Section~\ref{meth}.

\subsection{Automated Analysis Results} \label{sec: result-of-tool}
Table~\ref{tab: output-of-tools} presents the automated analysis results of the five tools on our dataset. For each tool, the first column (RE) is the number of reentrant contracts reported by the tool, and the second column (Analyzed) is the number of contracts successfully analyzed by the tool. 

\textbf{Analysis Scope.} Solidity is a new and frequently updated language; the new features, along with the frequent updates, limit the scope of analysis of vulnerability detection tools. In particular, the versions of Solidity above 0.5.0 have major changes in their grammar~\cite{soliditydocs}, so that the analysis scope of some tools (e.g., Oyente, Securify(V1), and Securify(V2)) is limited in specific versions. Accordingly, we divide our dataset (139,424 smart contracts) into five parts, as shown in Table~\ref{tab: output-of-tools}.

Oyente and Securify(V1) fail to analyze most of the smart contracts above version 0.5.0, and Securify(V2) can only analyze smart contracts above version 0.5.8. Sailfish fails to analyze smart contracts with a version above 0.7.0. Note that there are a few smart contracts above version 0.5.0 that can be successfully analyzed by Oyente, which might be because the contracts do not use the new features of the later versions. This phenomenon also appears with Sailfish, Securify(V1) and Securify(V2). In particular, the analysis scopes of Mythril and Smartian are less affected by the version of a smart contract, being able to successfully analyze most of the smart contracts in our dataset. In addition to the limitation of versions, the other reason for analysis to fail is that the analysis does not successfully terminate when an external timeout is reached, in which case we kill the process. Consequently, there are 15,778, 1,891, and 2,522 contracts that have no results exported by the tools Mythril, Securify(V1), and Securify(V2). The successful analysis rates of the tested tools show a decreasing trend when applied to higher versions of Solidity, which is ranging from 97\% ($\frac{66,170}{68,196}$) in \textless 0.5 to 60\% ($\frac{8,683}{14,714}$) in 0.8+.

In order to analyze as many contracts as possible, we combine the automated analysis results of all tools for manual checking. However, there still exist 16,209 smart contracts that fail to be analyzed by any tool.

\textbf{Reported Reentrancy Rate.} As listed in Table~\ref{tab: output-of-tools}, the five tools report a total of 21,212 reentrant contracts. The reported rate, i.e., $\frac{\#reported\_reentrant\_contracts}{\#successfully\_analyzed\_contracts}$, varies by tool. Mythril successfully analyzes 81,346 contracts and 19\% are reported as reentrancy issues. These 15,500 issues occupy 78\% of all reported reentrancy issues. Smartian successfully analyzes the greatest number of smart contracts but reports the smallest number of reentrancy issues. There are only 22 reported reentrancy issues in 100,245 contracts that are successfully detected by Smartian. This is likely because the patterns used to detect reentrancy are different. These patterns are decisive for vulnerability detection tools. In the next section, we summarize and propose some effective patterns for vulnerability detection tools to detect reentrancy issues.

\textbf{Reported Reentrancy Distribution.} From Table~\ref{tab: output-of-tools}, we find that the reported reentrancy rate decreases as the version of Solidity updates, ranging from 22.6\% ($\frac{14,967}{66,170}$) in \textless 0.5 to 1.4\% ($\frac{125}{8,683}$) in 0.8+. There may be three reasons for this: 1) the developers' awareness of preventing reentrancy issues is strengthened, as many companies have been victims of the reentrancy vulnerability and several related works have been proposed for detecting it; 2) codebases for preventing reentrancy have been proposed and are widely used, such as the \textit{ReentrancyGuard} proposed by openzepplin~\cite{reentrancyguard}; and 3) the new types of reentrancy are hard for existing tools to detect. In the next section, we conclude and discuss some new types of reentrancy that may enable developers to write safer contracts or propose more effective vulnerability detection tools.

\subsection{Precision of Tools}

\begin{table}[t]
	\centering
	\caption{The number of reentrant contracts reported (Reported Num.) by five tools, and the number of true positives (TP Num.).}
	\begin{tabular}{c|c|c}
		\hline
		\textbf{Tool} & \textbf{TP Num.} & \textbf{Reported Num.} \\
		\hline
		\textbf{Oyente} & 25 & 513 \\
		\textbf{Mythril} & 26 & 15,500 \\
		\textbf{Securify(V1)} & 15 & 2,387 \\
		\textbf{Securify(V2)} & 3 & 2,492 \\
		\textbf{Smartian} & 7 & 22 \\
		\textbf{Sailfish} & 19 & 2,289 \\
		\hline
		\textbf{Total} & 34 & 21,212 \\
		\hline
	\end{tabular}
	\label{tab:precision}
\end{table}

According to the manual examination, we evaluate the precision of the detection tools. As shown in Table~\ref{tab:precision}, all tools have very low precision in revealing reentrancy vulnerabilities. Smartian achieves the highest precision, i.e., 31.8\%, among these tools. However, Smartian only reports 22 contracts with reentrancy, of which seven contracts are true positives. In general, the precision of the tools is poor for real-world applications in detecting reentrancy vulnerabilities.

\subsection{False Positives of Tools}
\label{subsec: FPofTools}
In this subsection, we summarize the common reasons for the false positives of the tested tools. 

\subsubsection{Permission control}
Symbolic execution-based tools, e.g., Oyente and Mythril, usually use a specific pattern to detect vulnerabilities. However, they fail to consider the user's permission when checking a control flow path. There are three ways that could lead to permission control-based false positives, i.e., identify control, address control, and reentrancy lock (a defense mechanism against reentrancy).

\noindent {\bf 1. Identity Control:} The first type of false positive is caused by the ignorance with regard to identity control of the contract caller. Fig.~\ref{fig:ACmodifier} shows a code snippet of a real-world smart contract that is falsely detected to have reentrancy vulnerability by Oyente and Mythril. The ether transfer function \emph{call.value()} in line 8 of the contract is detected to lead to reentrancy vulnerability. The function execution enables the caller to transfer the amount of \textit{\_value} ether to the address \textit{\_to}. Malicious users could attack this smart contract from the fallback function in the smart contract deployed at the \textit{\_to} address if they can call the example function. However, this function is not callable from arbitrary addresses due to the \textit{onlyOwner} modifier at line 1, which allows only the contract owner to execute the function. Therefore, the function can not be reentered by other malicious smart contracts.

\begin{figure}
	\centering
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	modifier onlyOwner{
	    require(msg.sender == owner);
	    _;
	}
	...
	function execute( address _to, uint _value, bytes _data) external onlyOwner {
	    ...
	    _to.call.value(_value)(data);
	}
	\end{lstlisting}
	\caption{Code example: Identify control based permission control}
	\label{fig:ACmodifier}
\end{figure}

\noindent {\bf 2. Address Control:}
The code snippet in Fig.~\ref{fig:ACaddress} shows a case of false positive type, which is caused by the limited access control of the contract address. This contract is detected to have reentrancy vulnerability in the \textit{register()} function. There is an external call in line 6, where the function calls the \textit{transferFrom()} function from the contract in the address \textit{dai}. However, when we look into the address variable, it can be seen that the address \textit{dai} is assigned with a hard code address in line 2 and line 3, which cannot be modified by other functions. Therefore, the smart contract corresponding to the address \textit{dai} is the smart contract recorded in the address on Ethereum. As a result, the external call in line 6 can not be reentered by other malicious smart contracts.

\begin{figure}
	\centering
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	contract DaiSavingsEscrow{
	    address private daiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
	    IERC20 public dai = IERC20(daiAddress);
    	function register(...) public {
        	...
        	dai.transferFrom(msg.sender, vault, payment);
        	...
        }
    }
	\end{lstlisting}
	\caption{Code example: Address based permission control}
	\label{fig:ACaddress}
\end{figure}

\noindent {\bf 3. Reentrancy Lock:}
Fig.~\ref{fig:AClock} demonstrates another case of a false positive caused by reentrancy lock. The function in line 15 is detected to have a reentrancy vulnerability based on the external call in line 17. It seems that a smart contract corresponding to the \textit{Token} address could deploy malicious code to reenter the \textit{withdraw()} function to obtain additional profit. However, the function is actually safe against reentrancy attacks due to the modifier \textit{nonReentrant}. This modifier is declared in line 6, where the modifier checks the state of a variable \textit{\_notEntered} before the execution of the function and sets it to be ``false'' (line 7 and 8). If the check fails, the \textit{require} statement will stop the execution of this transaction and roll back to the state before the transaction executes. The ``\_'' in line 9 is a placeholder for the body of the function and line 10 will only be executed after the execution of the function body is finished. Note that before the execution of line 10, the value of variable \textit{\_notEntered} is ``false'' during the execution of the function body. As a result, if any external smart contract tries to reenter \textit{withdraw()} for the second time before finishing the first execution, the check statement in line 7 will fail and the transaction will be stopped immediately. Therefore, the smart contract is safe against reentrancy attacks.

\begin{figure}
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
contract ReentrancyGuard {
    bool private _notEntered;
    constructor () internal {
        _notEntered = true;
    }
	modifier nonReentrant() {
    	require(_notEntered);
    	_notEntered = false;
    	_;
    	_notEntered = true;
    }
}
contract GovernanceVesting is ReentrancyGuard {
    ...
	function withdraw() public nonReentrant {
    	...
    	IERC20(Token).transfer(governanceAddress, governanceFunds);
    	Withdrawn = true;
    }
}
	\end{lstlisting}
	\caption{Code example: Reentrancy lock based permission control}
	\label{fig:AClock}
\end{figure}

\subsubsection{No State Change After External Call}
If a function could be executed by external calls several times in a single transaction, the contract is regarded as reentrant contract by the previous reentrancy detection tools. However, in some situations, the external calls may not involve financial acts and no state will be changed after the external call. For example, Fig.~\ref{fig:NoStateChange} declares a function \textit{getTokenBal()} to inquire the balance of address \textit{who} in the token contract \textit{tokenAddr} (line 9). However, the state of the contract (i.e., ether balance, storage variable, etc.) will not be changed after the external call of the \textit{balanceOf()} function. Therefore, even if a malicious token \emph{t} reenters this function, it cannot affect the execution of the smart contract.

\begin{figure}
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	contract ForeignToken {
    	function balanceOf(address _owner) constant public returns (uint256);
    	...
    }
	contract Bitcash {
    	...
    	function getTokenBal(address tokenAddr, address who) constant public returns (uint){
        	ForeignToken t = ForeignToken(tokenAddr);
        	uint bal = t.balanceOf(who);
        	return bal;
        }
    }
	\end{lstlisting}
	\caption{Code example: No state change after external call}
	\label{fig:NoStateChange}
\end{figure}

\subsubsection{Change State Variable without Financial Risk}
Some smart contracts may change state variables after the external call, making them potentially vulnerable to reentrancy attacks. However, not all state changes lead to reentrancy vulnerability. Take the function in Fig.~\ref{fig:NoFinancialRisk} as an example. The code in line 3 defines an external call to address `\textit{token}', and then the code in line 4 assigns it to a state variable \textit{tokens}. There is no following code in the function, and this function is not called in any other functions in the contract\footnote{The full Solidity code of the contract can be found in https://etherscan.io/address/0x046ec9bb312c51425f7a00b2ab7525afe7db52e6}. Reentering this function in line 3 will not cause financial risk because the \textit{transferFrom()} function is to transfer tokens from the first parameter (\textit{msg.sender} in this case) to the second parameter (\textit{this} smart contract in the case). Thus, \textit{transferFrom()} is for the function caller to transfer tokens to this smart contract, and reentering this function only increases the balance of this smart contract. In this case, no financial risk exists in the contract.

\begin{figure}
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	function depositToken(address token, uint amount) {
    	...
    	if (!Token(token).transferFrom(msg.sender, this, amount)) throw;
    	tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);
    }
	\end{lstlisting}
	\caption{Code example: Change state variable without financial risk}
	\label{fig:NoFinancialRisk}
\end{figure}

\begin{table*}[t]
	\centering
	\caption{Cause analysis results of the false positives detected by five tools. The last column `Total' is the union of the false positives reported by the tools.}
	\begin{tabular}{l|cccccc|c}
		\hline
		\textbf{Cause Type} & \textbf{Oyente} & \textbf{Mythril} & \textbf{Securify(V1)} & \textbf{Securify(V2)} & \textbf{Smartian} & \textbf{Sailfish} & \textbf{Total} \\
		\hline
		Permission Control (Identity Control)                             & 6   & 152  & 12   & 12    & 8     & 1  & 178  \\
		Permission Control (Address Control)                    & 2   & 16  & 2     & 14    & 2     & 3  & 32\\
		Permission Control (Reentrancy Lock)                       & 0   & 2   & 0     & 6     & 0     & 0  &6\\
		No State Change After External Call             & 2  & 99   & 2     & 14    & 1     & 0  & 117  \\
		Change State Variable without Financial Risk    & 6  & 12   & 8     & 21    & 1     & 3  & 44   \\
		Special Transfer Value                          & 0  & 4    & 0     & 7     & 2     & 1  & 12   \\
		Reentrancy by Transfer/Send                     & 0  & 1    & 0     & 8     & 1     & 0  & 10  \\
		Non-callable Function                           & 2  & 7    & 25    & 1     & 0     & 1  & 33  \\
		\hline
	\end{tabular}
	\label{tab:falsePositiveTools}
\end{table*}

\subsubsection{Special Transfer Value}
This type of false positive is caused by the ignorance of parameter semantics in the ether transfer function. For example, the function in Fig.~\ref{fig:SpecialValue} is detected to be reentrant due to the ether transfer function in line 5. However, the amount parameter is \textit{msg.value}, which means the ether transferred to the external address \textit{wethToken} is the ether amount received by the function \textit{tradeEthVsDAI}. In this sense, reentering this function would not cause financial loss since it does not affect the balance of the smart contract.

\begin{figure}
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	function tradeEthVsDAI(uint numTakeOrders, uint numTraverseOrders, bool isEthToDai, uint srcAmount) public payable {
    	...
    	if (isEthToDai) {
        	require(msg.value == srcAmount);
        	wethToken.deposit.value(msg.value)();
        	...
    	} else ...
    }
	\end{lstlisting}
	\caption{Code Example: Special Transfer Value}
	\label{fig:SpecialValue}
\end{figure}

\subsubsection{Reentrancy by transfer/send}
The gas system is a special mechanism introduced by Ethereum to limit the resource consumption of smart contracts. Once the smart contract runs out of gas, the execution will be terminated and all states will be rolled back. Unlike the \emph{call.value()} function, \textit{transfer()} and \textit{send()} will change the maximum gas limitation to 2,300 units when the recipient is a contract. For the \textit{transfer()} function in Fig. \ref{fig:ReenTransfer}, the 2,300 gas limits is insufficient for a call to contract or a write operation to any storage variable, which means that the attackers cannot raise reentrancy attack.

\begin{figure}
	\begin{lstlisting}[language=Solidity,mathescape, firstnumber=1]
	function _withdraw(address from,address payable to,address token,uint256 amount) internal {    
	    ...
    	if(token == address(0)) {  
    	    to.transfer(amount);
    	} else ...
    }  
	\end{lstlisting}
	\caption{Code example: Reentrancy by transfer/send}
	\label{fig:ReenTransfer}
\end{figure}

\subsubsection{Non-callable Function}
There are two types of bytecode in Ethereum: runtime bytecode and creation bytecode. Creation bytecode contains the information that will never be executed after the contract is deployed on a blockchain, e.g., the constructor function. However, Mythril fails to identify this situation. When the source code is used as the input, Mythril simply compiles the source code to creation bytecode and uses it for vulnerability detection. This gap between creation bytecode and runtime bytecode results in a type of false positive located in the constructor function. Since this type of function will not be recorded on the blockchain, it will never be called and be attacked by malicious attackers. Besides, as shown in Fig.~\ref{fig:ReenTransfer}, the "internal" functions are not available to be called by other contracts, which are also reported as reentrant contracts by some tools.

\subsection{Distribution of False Positives in Each Tool}
According to the sampled false positives, we present the distribution of the false positives reported by each tool in Table~\ref{tab:falsePositiveTools}. We have the following observations: 1) The false positives related to \textit{Permission Control} occupy the most, i.e., 55\% ($\frac{178+32+6}{392}$). This is because there are several ways to deal with the permission of the contracts, which are hard for analyzers to handle. 2) The tools report two types of false positives, \textit{No State Change After External Call} and \textit{Change State Variable without Financial Risk}, which occupy 41\% ($\frac{117+44}{392}$). These two types relate to the functions in other contracts, which increases the difficulty of analysis. As for other types of false positives (i.e., \textit{Special Transfer Value}, \textit{Reentrancy by Transfer/Send} and \textit{Non-callable Function}), they occupy 14\% ($\frac{12+10+33}{392}$) of the false positives.
