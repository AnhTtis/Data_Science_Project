\section{Introduction}
\label{sec:Introduction}

% Related work
%{{{

% FPGA

% FPGA placement
% Placement is one of the most time-consuming and critical steps in the FPGA design flow
% It has a great impact on the design closure.
% Modern placement needs to process millions of instances.
% With recent architecture advances, additional design constraints are imposed to placement as well.
% All these new trends lead to increasingly challenging placement tasks.
% Recent architecture advances and increases of design complexity have led to more and more challenges in FPGA placement.
% Recent architecture advances of large-scale FPGAs have significantly increased the design complexity complicated design tasks.
% Besides, in persuit of higher performance, extra placement constraints will also be imposed during the placement phase
% so as to enable the convergent reult in subsequent routing and timing analysis phases.
% All of these make the placement task even more challenging.
% Placement is one of the most time-consuming and critical steps in the FPGA design flow
% It has a great impact on the design closure.
% Modern placement needs to process millions of instances.
% With recent architecture advances, additional design constraints are imposed to placement as well.
% All these new trends lead to increasingly challenging placement tasks.
% Recent architecture advances and increases of design complexity have led to more and more challenges in FPGA placement.
% Besides, in persuit of higher performance, extra placement constraints (e.g., timing, clock routing, chain alignment, etc.) will also be imposed during the placement phase.
% Recent architecture advances of large-scale FPGAs have significantly increased the design complexity complicated design tasks, so as to enable the convergent reult in subsequent routing and timing analysis phases.
% All of these make the placement task even more challenging.
Placement is a critical step in the FPGA design flow, with a great impact on
routability and timing closure.
%
In the literature, three types of FPGA placement have been investigated: 1)
partitioning-based, 2) simulated annealing (SA), and 3) analytical
approaches~\cite{PLACE_2008_Lee, PLACE_PIEEE2015_Markov}.
%
Partitioning-based approaches such as \cite{PLACE_TCAD2005_Maidee} usually have
good scalability, but often fail to achieve high-quality results.
%
% On the other hand, the widely used academic tool VPR~\cite{PLACE_FPL1997_Betz}
% can achieve good results on small designs with an SA-based approach, but
% suffers from poor scalability on large designs.
SA-based approaches like the widely-adopted academic tool
\texttt{VPR}\cite{PLACE_TCAD2005_Maidee} can achieve good results on small
designs, but suffer from poor scalability on large designs.
%
Recent studies have shown that analytical approaches~\cite{PLACE_DAC2015_ShengYen,
PLACE_TCAD2018_Li, PLACE_ICCAD2016_Pui_RippleFPGA,
PLACE_ICCAD2016_Ryan,PLACE_TCAD2019_Li_UTPLACEF_DL,
PLACE_TODAES2018_Li_UTPlaceF2, PLACE_FPGA2019_Li,
PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_ICCAD21_Liang_AMFPlacer,
PLACE_TCAD2021_Meng, PLACE_ICCAD2017_Kuo_NTUfplace, PLACE_TCAD2020_Chen}
can achieve the best trade-off between quality and runtime. 
%
Thus modern FPGA placers mainly adopt analytical approaches in academia and
industry.

% Challenge: heterogeneity, timing and clock
Modern FPGA placement has two major challenges: 1) the heterogeneity of FPGA
architecture, 2) the various constraints (e.g., timing, clock routing, chain
alignment, etc.) imposed by advanced circuit
designs~\cite{BENCH_ISPD2016_PLACE, BENCH_ISPD2017_PLACE,
PLACE_ICCAD2013_Contest, PLACE_PIEEE2015_Markov}.
%
The heterogeneity of the FPGA architecture comes from the variety of instance
types, the imbalance of resource distribution, and the asymmetric slice
compatibility from the SLICEL-SLICEM heterogeneity~\cite{DI_ULTRASCALE_CLB}.
%
The diversity of instance sizes and the inconsecutive site compatibility challenge
the modern FPGA placement algorithms, which are mainly based on continuous
optimization \cite{PLACE_PIEEE2015_Markov, PLACE_TCAD2021_Meng}.

% with various placement constraints imposed by advanced circuit designs and the conservative margin reservation for upcoming steps,
Furthermore, solving the highly heterogeneous FPGA placement problem while
satisfying advanced constraints has become more
challenging~\cite{PLACE_PIEEE2015_Markov}.
%
i)
% With the continuous instance and wire size shrinking in modern FPGAs,
% wire-induced delays are becoming the primary source of overall circuit delay
% \cite{PLACE_DAC2019_Martin, PLACE_DATE2021_Lin, PLACE_FPGA2000_Marquardt}.
Wire-induced delays are becoming the primary source of overall circuit delay
\cite{PLACE_DAC2019_Martin, PLACE_DATE2021_Lin, PLACE_FPGA2000_Marquardt}.
%
% Traditional placers that only address wirelength are no longer adequate for
% timing closure, especially for large-scale FPGA
% designs~\cite{PLACE_ICCAD2013_Contest}. To tackle this issue, timing-driven
% placement is leveraged to solve the complex timing constraints while
% preserving the desired performance.
Timing-driven placement is required to meet the aggressive timing constraints.
%
% However, due to the significant delay with the programmable switches and
% hierarchical routing architecture in modern FPGAs, the wire delays are highly
% non-linear and non-monotone with respect to the geometric position. 
%
% The great challenge in getting the timing optimization orientation in
% analytical approaches makes timing-driven placement more different then ever.
However, the nonlinear and nonmonotonic wire delays
% (with respect to geometric positions)
impose unique challenges to timing optimization in FPGA
placement.
%
ii) Modern FPGA adopts complicated clock architectures to achieve low clocking
skew and high performance~\cite{BENCH_ISPD2016_PLACE, BENCH_ISPD2017_PLACE}.
%
Such a clock architecture introduces complicated clock routing constraints,
increasing the challenges in FPGA placement.
%
Therefore, clock-aware FPGA placement is required to accommodate the needs of
modern FPGA design flows.
%
iii) Modern FPGA needs to align the cascaded instances like CARRY into an aligned chain at the placement stage to boost performance.
%
Such a chain alignment requirement induces large placement blocks and
tends to degrade the quality of the solution.


% Modern FPGA placement has two major challenges:
% 1) the heterogeneity of FPGA architecture
% and 2) the strict clock routing constraints.
% The heterogeneity of FPGA architecture comes from a variety of instance types and asymmetric slice compatibility from SLICEL-SLICEM heterogeneity.
%the discontinuous site compatibility for each instance type
%and the diversity of instance sizes.
%Such discontinuity challenges the modern analytical placement, which is mainly based on continuous optimization.
%Therefore, the non-convex objective for the heterogeneous
%architecture and the continuous optimization behavior of a nonlinear analytical placers can lead to
%the sub-optimal solution space.
% Such heterogeneity results in discrete mathematical problems,
% challenging the analytical placement algorithms, usually based on continuous optimization.
% Besides, modern FPGA adopts complicated clock architectures to achieve low clocking skew and high performance.
%The clock network is designed as a mash-like structure
%connecting the clock sources and sinks like FFs and DSPs.
%For example, large FPGAs like \emph{Xilinx UltraScale} \cite{DI_ULTRASCALE, DI_ULTRASCALE_CLB} divide the layout into tiles of regions,
%and pre-allocate the clock tracks across each region to lower the clocking skew.
% Such a clock architecture introduces complicated clock routing constraints,
% increasing the challenges in FPGA placement.
%which have to be handled during FPGA placement.
% Therefore, clock-aware FPGA placement is required to accommodate the needs of modern FPGA design flows.
% Besides, the complicated clock architectures to achieve low clocking skew impose challenging clock routing constraints on FPGA placement,
% lowering the solution quality of placement algorithms.


% Related work: SLICEL-SLICEM, Timing Optimization, Clock Optimzation

% whose efficiency and quality has been demonstrated on the large-scale ISPD 2016/2017 FPGA placement contest.
% The basic idea is to gradually spread instances in the layout to minimize wirelength and overlaps.
%In recent years, several analytical FPGA placers are proposed for wirelength-driven optimization.
%Among them, quadratic placers like
%\cite{PLACE_DAC2015_ShengYen, PLACE_TCAD2018_Li, PLACE_ICCAD2016_Pui_RippleFPGA, PLACE_ICCAD2016_Ryan,PLACE_TCAD2019_Li_UTPLACEF_DL}
%can produce generally good and stable results within reasonable runtime,
%while the nonlinear placement algorithms~\cite{PLACE_TCAD2014_Hsu, PLACE_TCAD2008_Chen,PLACE_TCAD2021_Meng}
%can outperform the cutting-edge quadratic placement algorithms with even better solution quality.
% \tabRef{tab:FPGAPlacers} summarizes features of the published state-of-the-art
% FPGA placers. Recent academic studies develop quadratic programming-based
% algorithms~\cite{
% PLACE_DAC2015_ShengYen, PLACE_TCAD2018_Li,
% PLACE_ICCAD2016_Pui_RippleFPGA,
% PLACE_ICCAD2016_Ryan,PLACE_TCAD2019_Li_UTPLACEF_DL,
% PLACE_TODAES2018_Li_UTPlaceF2, PLACE_FPGA2019_Li,
% PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_ICCAD21_Liang_AMFPlacer} and nonlinear
% optimization-based algorithms~\cite{PLACE_TCAD2021_Meng,
% PLACE_ICCAD2017_Kuo_NTUfplace, PLACE_TCAD2020_Chen} for wirelength and
% routability optimization. Among them, the current state-of-the-art solution
% quality is achieved by nonlinear placers such as
% \texttt{elfPlace}~\cite{PLACE_TCAD2021_Meng} and
% \texttt{NTUfplace}~\cite{PLACE_TCAD2020_Chen}. They propose to spread instances
% by minimizing the potential energy in a multi-electrostatic system
% \cite{PLACE_TCAD2021_Meng} or a hand-crafted mathematical field system
% \cite{PLACE_TCAD2020_Chen}.
% However, most existing FPGA placers only consider a simplified FPGA
% architecture with a subset of instance types, i.e., \{LUT, FF, BRAM, DSP\},
% ignoring the SLICEL-SLICEM heterogeneity 
% \cite{PLACE_TCAD2018_Li,
% PLACE_ICCAD2016_Pui_RippleFPGA,
% PLACE_ICCAD2016_Ryan,PLACE_TCAD2019_Li_UTPLACEF_DL, PLACE_TCAD2021_Meng,
% PLACE_TODAES2018_Li_UTPlaceF2, PLACE_FPGA2019_Li,
% PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_ICCAD2017_Kuo_NTUfplace,
% PLACE_TCAD2020_Chen}. Among these placers, only a few consider the
% widely-adopted clock routing constraints in real architectures
% \cite{PLACE_TODAES2018_Li_UTPlaceF2, PLACE_FPGA2019_Li,
% PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_ICCAD2017_Kuo_NTUfplace,
% PLACE_TCAD2020_Chen}.
%proposes a multi-electrostatic formulation to eliminate instance overlaps
%proposes a multi-electrostatics-based placement
%algorithm derived from \cite{PLACE_TODAES2015_Lu, PLACE_TCAD2018_Cheng}.
%It models the instance distribution as the charge distribution in electrostatic systems
%to obtain a global view of the distribution.
%It eventually demonstrates the state-of-the-art routed wirelength with competitive efficiency.

% Related work: clock-driven placement

%Despite the previous wirelength-driven FPGA placement,
%only limited work in the literature has explored clock feasibility for FPGA.
%\texttt{UTPlaceF 2.0}~\cite{PLACE_TODAES2018_Li_UTPlaceF2} presents an iterative minimum-cost flow-based clock network
%planning as well as a clock-aware packing to produce clock-feasible results.
%Li \emph{et al}~\cite{PLACE_FPGA2019_Li} propose a Lagrangian relaxation-based clock tree construction technique to
%accurately model the clock routing demands during FPGA placement.
%\texttt{RippleFPGA}~\cite{PLACE_ICCAD2017_Pui_RippleFPGA} introduces a two-step displacement-driven legalization technique
%to greedily remove the clock constraint violations.
%\texttt{NUTfplace}~\cite{PLACE_ICCAD2017_Kuo_NTUfplace, PLACE_TCAD2020_Chen} incorporates
%a nonlinear placement algorithm with a quadratic clock fence region function to eliminate clock violations.
%However, no work has investigated the clock-awareness in the electrostatics-based
%placement yet \cite{PLACE_TCAD2018_Cheng, PLACE_TCAD2021_Meng},
%which has the potential to substantially improve the solution quality
%due to its global view in solving the kernel placement problem.
%%However, none of these works adopt the electrostatics-based approach, which has demonstrated the state-of-the-art results in wirelengh-driven placement \cite{PLACE_TCAD2018_Cheng, PLACE_TCAD2021_Meng}.
%%Therefore, there is potential to improve the quality of clock-constrained FPGA placement by adapting the electrostatics-based method. Further more, none of these placers utilize the parallelism that the GPU provides, also leaving room for the lowering of runtime.

\begin{figure}[tb]
    \centering
    \subfloat[]{\includegraphics[height=0.4\columnwidth]{figs/fpga_arch_2.pdf}\label{fig:fpga_arch}} \hfill
    \subfloat[]{\includegraphics[height=0.4\columnwidth]{figs/cc_constraints_2.pdf}\label{fig:cr_con}} \\
    \vspace{-.1in}
    \subfloat[]{\includegraphics[width=0.75\columnwidth]{figs/CLB_slice.pdf}\label{fig:CLB_slice}}
    \caption{
      % (a) A simplified columnar FPGA architecture depiction for \emph{Xilinx UltraScale},
      % with a $2 \times 2$ clock regions and half columns (dash line).
      (a) An example of a simplified vertical FPGA architecture depiction showing a $2 \times 2$ clock region and half columns (dash lines) for \emph{Xilinx UltraScale}.
      % (b) An example on how to calculate the clock demand. Different colors represent different clocks, and the numbers represent the clock demand of each CR.
      (b) An example of how the clock demand can be calculated. The different colors represent different clocks, and the numbers represent the clock demand of each CR.
      % (c) An illustration of CLB slices classified into SLICEL and SLICEM with asymmetric compatibility.
      % LUT blocks in a SLICEL can be configured to LUTs. All LUT blocks in a SLICEM can only be configured to \emph{one} mode: LUT, distributed RAM, or SHIFT.
      % No mixing between LUTs, distributed RAMs, and SHIFTs in a CLB is allowed.
      (c) An illustration of CLB slices classified into SLICEL and SLICEM with asymmetric compatibility. 
        In a SLICEL, LUT blocks can be configured to be LUTs.
        A SLICEM can only be configured in \textit{one} of the following modes: LUT, distributed RAM, or SHIFT.     
        There is no mixing of LUTs, distributed RAMs, and SHIFTs in a CLB. 
      %Each LUTM block can be configured to operate as one instance of LUT, distributed RAM, or SHIFT.
      %Note that if a SLICEM is configured to distributed RAM or SHIFT, we cannot use it as LUTs any more; vice versa.
    }
    \vspace{-.2in}
\end{figure}

% Contributions
% In this paper,
% we tackle the heterogeneous FPGA placement considering both SLICEL-SLICEM heterogeneity and clock feasibility based on a new multi-electrostatic formulation.
% We handle a comprehensive set of instance types, i.e., \{LUT, FF, BRAM, DSP, distributed RAM, SHIFT, CARRY\}, which are commonly used in FPGA design \cite{DI_ULTRASCALE_CLB}.
%we tackle the clock feasibility challenges in electrostatics-based FPGA placement.
%We propose a clock-aware placement framework with GPU acceleration leveraging the multi-electrostatics formulation.
%We adopt a uniform non-linear optimization paradigm considering wirelength,
%routability and clock feasibility during global placement phase from the perspective of \emph{Lagrangian relaxation}.
% Our major contributions are summarized as follows.
% \begin{itemize}
% \item We propose a new multi-electrostatic formulation to handle asymmetric slice compatibility from SLICEL-SLICEM heterogeneity as well as techniques to handle carry chains.
% \item We propose a nested \emph{Lagrangian relaxation}-based technique for wirelength, routability, and clock
% optimization
%     with a dynamically-adjusted preconditioning technique to stabilize the convergence.
% %\item We propose a holistic way to handle the discrete clock constraints including a \emph{branch-and-bound} based clock assignment and a quadratic penalization technique to eliminate clock violations.
% \item We propose a quadratic penalization technique to eliminate violations of the discrete clock constraints.
% \end{itemize}
% Experiments on \emph{ISPD 2017 contest benchmarks}~\cite{BENCH_ISPD2017_PLACE} demonstrate 14.2\%, 11.7\%, 9.6\%, and 7.9\% improvement in routed wirelength,
% compared to the latest cutting-edge FPGA placers~\cite{PLACE_TODAES2018_Li_UTPlaceF2, PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_FPGA2019_Li, PLACE_TCAD2020_Chen}, respectively.
% Further experiments on \emph{industrial} benchmarks demonstrate that the proposed techniques can bring 19.3\%, 10.7\%, and 6.6\%  wirelength improvement with better stability.
% Our placer also support GPU acceleration and can achieve 1.5--6$\times$ speedup over baselines.

% The rest of the paper is organized as follows.
% \secRef{sec:Preliminary} introduces the preliminary knowledge of the FPGA architecture and modern FPGA placement.
% \secRef{sec:Algorithm} describes the core placement algorithms.
% \secRef{sec:Results} shows the experimental results, followed by the conclusion in \secRef{sec:Conclusion}.

In this work, we propose a state-of-the-art placement framework considering
SLICEL-SLCIEM heterogeneity and the co-optimation with wirelength, routability,
clock feasibility, and timing optimization.
%
We handle a comprehensive set of instance types, i.e, \{ LUT, FF, BRAM,
distributed RAM, SHIFT, CARRY \}, and cope with SLICEL-SLCIEM heterogeneity
based on a multi-electrostatic system.
%
We propose a uniform non-linear optimization paradigm taking wirelength,
routability, clock feasibility, and timing optimization into consideration from
the perspective of \textit{nested Lagrangian method}.
%
The main contributions of this work are summarized as follows.
%
\begin{itemize}
%
\item We adopt an effective SLICEL-SLICEM heterogeneity model based on the
division and assembly of electrostatic-based density formulation. 
%
\item We develop a dynamically adjusted preconditioning and carry chain
  alignment technique to stabilize the optimization convergence and enable better
    final placement results. 
%
\item We cope with the time violation by an effective timing-criticality-based
  net weighting scheme, and incorporate the timing optimization into a continuous
    optimization algorithm. 
%
\item To achieve effective clock routing violation elimination, we adopt a
  instance-to-clock-region mapping considering the resource capacity of the clock
    regions and perturbation to the placement, and propose a quadratic clock
    penalty function in a continuous global placement engine with minor quality
    degradation.
%
\item Putting the aforementioned techniques together, we put forward a nested
  Lagrangian relaxation framework incorporating the optimization objectives of
    wirelength, routability, timing, and clock feasibility.
%
\end{itemize}
%
Experiments on \textit{ISPD 2017 contest benchmarks} demonstrate 14.2\%,
11.7\%, 9.6\%, and 7.9\% improvement in routed wirelength, compared to the
recent cutting-edge FPGA placers~\cite{PLACE_TODAES2018_Li_UTPlaceF2,
PLACE_ICCAD2017_Pui_RippleFPGA, PLACE_FPGA2019_Li, PLACE_TCAD2020_Chen},
respectively. 
Our placer also supports GPU acceleration and gains 1.45-6.58$\times$ speedup over the baselines.
Further experiments on \textit{industrial} benchmarks demonstrate that the
proposed algorithms can achieve 23.6\% better WNS, 22.5\% better TNS with about 2\% routed wirelength degradation compared with the conference version.
%

The rest of the paper is organized as follows.
%
\secRef{sec:Preliminary} introduces the preliminary knowledge of the FPGA
architecture and modern FPGA placement.
%
\secRef{sec:Algorithm} details the core placement algorithms.
%
\secRef{sec:Results} shows the experimental results, followed by the conclusion
in \secRef{sec:Conclusion}.

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table*}[tb]
\caption{Features of the published state-of-the-art FPGA placers.}
\label{tab:FPGAPlacers}
  \resizebox{1.0\textwidth}{!}{
\begin{tabular}{|cc|cccccc|ccccc|}
\hline
\multicolumn{2}{|c|}{Placer}                                                                                                                                                    
  & \begin{tabular}[c]{@{}c@{}}\texttt{RippleFPGA}\\ \cite{TCAD18_RippleFPGA_Chen}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{GPlace}\\ \cite{PLACE_ICCAD2016_Ryan}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{UTPlaceF}\\ \cite{PLACE_TCAD2018_Li}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{elfPlace}\\ \cite{PLACE_TCAD2021_Meng}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{FTPlace}\\ \cite{PLACE_DAC2019_Martin}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{GPlace}\\ \texttt{3.0} \cite{TODAES18_GPlace3_Abuowaimer}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{RippleFPGA}\\ \texttt{Clock-Aware} \cite{PLACE_ICCAD2017_Pui_RippleFPGA}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{UTPlaceF}\\ \texttt{{2.0}}\&\texttt{2.X} \cite{PLACE_TODAES2018_Li_UTPlaceF2, PLACE_FPGA2019_Li}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}\texttt{NTUfPlace}\\ \cite{PLACE_TCAD2020_Chen}\end{tabular}
  & \begin{tabular}[c]{@{}c@{}}Lin \textit{et al.}\\ \cite{PLACE_DATE2021_Lin}\end{tabular}
  & Ours         \\ \hline
\multicolumn{2}{|c|}{Clock Constraints}                                                                                                                                         & $\times$     & $\times$     & $\times$     & $\times$     & $\times$     & $\times$                                              & $\checkmark$                                                     & $\checkmark$                                                & $\checkmark$ & $\checkmark$ & $\checkmark$ \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Resources\\ Supported\end{tabular}}} & \begin{tabular}[c]{@{}c@{}}LUT, FF, \\ BRAM, DSP\end{tabular}            & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$                                         & $\checkmark$                                                     & $\checkmark$                                                & $\checkmark$ & $\checkmark$ & $\checkmark$ \\ \cline{2-13} 
\multicolumn{1}{|c|}{}                                                                               & \begin{tabular}[c]{@{}c@{}}CARRY, SHIFT, \\ Distributed RAM\end{tabular} & $\times$     & $\times$     & $\times$     & $\times$     & $\times$     & $\times$                                             & $\times$                                                         & $\times$                                                    & $\times$     & $\times$     & $\checkmark$ \\ \hline
\multicolumn{2}{|c|}{Timing Optimization}                                                                                                                                       & $\times$     & $\times$     & $\times$     & $\times$     & $\checkmark$ & $\times$                                             & $\times$                                                         & $\times$                                                    & $\times$     & $\checkmark$ & $\checkmark$ \\ \hline
\multicolumn{2}{|c|}{GPU-Acceleration}                                                                                                                                          & $\times$     & $\times$     & $\times$     & $\checkmark$ & $\times$     & $\times$                                             & $\times$                                                         & $\times$                                                    & $\times$     & $\times$     & $\checkmark$ \\ \hline
\multicolumn{2}{|c|}{Algorithm Category}                                                                                                                                        & Quadratic    & Quadratic    & Quadratic    & Nolinear     & Quadratic    & Quadratic                                            & Quadratic                                                        & Quadratic                                                   & Nonlinear    & Nonlinear    & Nonlinear    \\ \hline
\end{tabular}}
\end{table*}

