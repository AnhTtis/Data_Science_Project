\section{Introduction}
Quantum Signal Processing (QSP) is a novel technique to devise quantum algorithms developed by Low, Yoder, and Chuang~\cite{lowMethodologyResonantEquiangular2016, lowOptimalHamiltonianSimulation2017, lowHamiltonianSimulationQubitization2019} where, roughly speaking, one can transform some entry of a unitary matrix using a polynomial $P(x)$, i.e.,
\begin{align*}
    \bra{0} U \ket{0} = a \Rightarrow \bra{0} Q(U) \ket{0} = P(a),
\end{align*}
where $Q$ is a construction of a circuit that calls $U$ $n$~times if $n$ is the degree of $P$. Low et al.~\cite{lowMethodologyResonantEquiangular2016} proved that the class of polynomials realizable using their construction is quite general. Originally, this technique was used to tackle the Hamiltonian-simulation problem, where nearly-optimal complexities could be achieved for a huge class of Hamiltonians~\cite{lowHamiltonianSimulationUniform2017, lowHamiltonianSimulationQubitization2019}, even requiring a single copy of the initial state (so-called fully coherent simulation~\cite{martynEfficientFullyCoherentQuantum2022}). The QSP construction was extended to two similar techniques: the first is called Quantum Eigenvalue Transform (QET), where the polynomial transformation $P(x)$ induced by the QSP could be applied to all the eigenvalues of an arbitrary block-encoded square matrix $A$ (essentially implementing $P(A)$) by using, again, $n$ calls to $U$~\cite{lowHamiltonianSimulationUniform2017, haahProductDecompositionPeriodic2019}. The second, introduced by Gilyen~\cite{gilyenQuantumSingularValue2019a, gilyenQuantumSingularValue2019c}, was about transforming the \emph{singular values} of a block-encoded matrix $A$. The latter extension, which is the most general one, was also shown to reproduce most of famous quantum algorithms present in the literature, such as Grover's and Shor's algorithms~\cite{groverFastQuantumMechanical1996a, shorPolynomialTimeAlgorithmsPrime1997}, but also the HHL algorithm for solving linear systems~\cite{harrowQuantumAlgorithmSolving2009}, general amplitude-amplification schemes and the phase-estimation procedure~\cite{nielsenQuantumComputationQuantum2010b}. Moreover, works by Haah~\cite{haahProductDecompositionPeriodic2019} and Chao et al.~\cite{chaoFindingAnglesQuantum2020}, which had the goal to overcome some technical problems of the QSP (namely, classical computation of the phase sequence needed in the construction), introduced novel formalisms that are relevant for the present work (see Appendix~\ref{apx:haah-construction} for a brief introduction).

Starting from Section~\ref{sec:phase-extraction-problem}, we present a different problem, called \emph{phase extraction}, in which one basically wants to construct a (block-encoded) Hermitian matrix $H$ (or some real function of it) using copies of $U = e^{i \pi H}$ and its inverse or, in other words, to transform eigenphases to (real) amplitudes. We show a general construction, using QET and Fourier series, to approximate any (sufficiently smooth) function of the phases with Laurent polynomials that can be directly implemented with Haah's formalism~\cite{haahProductDecompositionPeriodic2019}.

In Section~\ref{sec:prop-sampling} we proceed by showing a natural application of the phase extraction problem to \emph{proportional sampling}, a problem of interest in machine learning where one wants to sample some element $x$ of a given set with a probability that is proportional to the value given by some oracle $c(x)$. We devise an algorithm using the phase-extraction procedure to construct a quantum state where the amplitude of each element is the square root of its sampling probability, so that a measurement in the computational basis will induce our desired probability distribution. If we omit the measurement, we can consider this algorithm as a way to prepare a quantum state with a specific shape defined through the oracle, and this can be relevant in the topic of quantum state preparation. We close this section by proving that, in some instances, the algorithm achieves an almost quadratic speed-up.

As a final step, in Section~\ref{sec:inductive-smoothening} we show how further speed-up can be achieved `for free' if we carefully choose the function to approximate in the phase-extraction subroutine. In its final form, our algorithm does not (directly) depend on the dimensionality $N$ of our Hilbert space. In contrast to previous algorithms for quantum state preparation~\cite{knillApproximationQuantumCircuits1995, mottonenTransformationQuantumStates2004a, araujoDivideandconquerAlgorithmQuantum2021, zhangQuantumStatePreparation2022}, which require $\Theta(N)$ depth or width, our proposed solution may take as low as $\bigO(\log N)$ depth for some instances, and always $\bigO(\log N)$ qubits.