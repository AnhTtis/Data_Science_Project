We are now ready to present the algorithm for fixed-point counting, keeping in mind that we want first to use the formula from Section \ref{sec:mod}.\ref{sub:char} to compute the character table of the monoid and further to compute the Cartan matrix of the monoid. In the cases we are interested in, we use the formalism of character computing, since, as stated in the Lemma below, computing the characters of so called \emph{combinatorial modules} is actually counting fixed points.

\begin{lemme}\label{lem:fixed_is_char}
	Let $M, M'$ be two finite monoids and $(V, B)$ a finite dimensional $\kbf M-\module-\kbf M'$ space equipped with a basis $B$. If the actions of $M, M'$ on $(V, B)$ are \emph{combinatorial}, meaning for any $(m, b, m') \in M \times B \times M', mbm' \in (B \cup \{0\})$, then:
	\[\chi_{\kbf M \otimes \kbf M'^{op}}^V = |\{b \in B \sepp mbm' = b\}|.\]
\end{lemme}

\begin{proof}
	In the basis $B$, the matrix of the linear map $x \mapsto mxm'$ is a $\{0,1\}$-matrix, with for every $b \in B$ exactly one 1 in the $b$-th column, that 1 being on the $b$-th row if $mbm'=b$. Thus, the trace counts the number of fixed points.
\end{proof}

Note that we have already defined a structure of combinatorial $\kbf M-\module-\kbf G_e$ on $(\kbf\lc(e), \lc(e))$ for any idempotent $e$.
In the same way, $\kbf J$ for a $\jc$-class $J$, can be equipped with a structure of $\kbf M-\module-\kbf M$ by setting for every $(m, j) \in M\times J$:
\[m\cdot j = \left\{\begin{aligned}
						& mj \textrm{ if } mj \in J\\
						& 0 \textrm{ otherwise}
					\end{aligned}\right.
\textrm{ and }
j\cdot m = \left\{\begin{aligned}
						& jm \textrm{ if } jm \in J\\
						& 0 \textrm{ otherwise}
				  \end{aligned}\right..\]
As before, this is well defined: firstly because the actions on the left and on the right commute (because the monoid's law is associative by assumption) and secondly because either $m \leql m'$ or $m \leqr m'$ imply $m \leqj m'$ so, as in Section \ref{sec:mod}.\ref{sub:modules}, if $ml$ or $lm$ has "fallen to 0", it can't "climb back up" to $J$. 

This structure makes $(\kbf J, J)$ into a combinatorial module and we may apply our fixed points counting methods to compute its character.

\begin{algo}[Computing the bicharacter of a $\jc$-class]\label{algo:j_class}
	Keeping the assumptions and notations of the previous Paragraph \ref{sub:hypo}, we get from Corollary \ref{cor:pt_fix_counting} an algorithm to compute the bicharacter of $\kbf J$ as a $\kbf M-\module-\kbf M$:
%	\begin{enumerate}
%		\item a set $C_M$ of character equivalency classes representatives is given,
%		\item the decompositions of $J$ as an union of $\rc$-classes and as an union of $\lc$-classes are given,
%		\item an $\hc$-class $H \subset J$ and an element $a \in H$ are given,
%		\item for each $\rc$-class $R \subset J$, we can compute a left Green pair $(\lambda_R, \lambda'_R)$ for $(\rc(H), R)$ and for each $\lc$-class $L \subset J$, we can compute a right Green pair $(\rho_R, \rho'_R)$ for $(\lc(H), L)$,
%		\item given an element and a Green class, we can decide if this element belongs to the class,
%		\item we can compute the product of two elements in $M$,
%		\item we can compute $h\mul{H} \in \Gamma(H)$ given $h \in {}_M\stab(H)$ and $\mul{H}k$ given $k\in \stab_M(H) \in \Gamma'(H)$,
%		\item we can identify the conjugacy class of an element in $\Gamma'(H)$, compute the cardinality of its centralizer and we can compute a set $C$ of conjugacy classes representatives of $\Gamma'(H)$,
%		\item we can compute $\tau_a$ defined in Proposition \ref{prop:bij_cano_conj},
%	\end{enumerate}
	\begin{itemize}
		\item Input : A $\jc$-class $J$, a set of representatives of the character equivalency classes $C_M$.
		\item Output : A matrix $(|\{m \in J \sepp hmk=m\}|)_{(h, k) \in C_M^2}$
	\end{itemize}
	\begin{enumerate}
		\item Preparations:
		\begin{enumerate}
			\item Choose $a \in J$ and define $H = \hc(a)$. 
			\item Compute Green pairs $(\lambda_R, \lambda_R')$ (respectively $(\rho_L, \rho_L')$) for $(\rc(a), R)$ (resp.  $(\lc(a), L)$) for all $\rc$-class $R \subset J$ (resp. $\lc$-class $L \subset J$).
			\item Compute the set $C$ of conjugacy classes of $\Gamma'(H)$.
		\end{enumerate}
		\item For each character equivalency representative $h \in C_M$, initialize $r_J(h)$ and $l_J(h)$ to both be $(0)_{\bar{g}\in C}$.
		\begin{enumerate}
			\item For each $\rc$-class $R \subset J$, test if $h\lambda_Ra\in R$. If so, denoting by $\bar{g} $ the conjugacy class of $\tau_a((\lambda_R'h\lambda_R)\mul{H})$ in $\Gamma'(H)$, increment $r_J(h)$ by $|C_{\Gamma'(H)}(g)|$ at position $\bar{g}$.
			\item For each $\lc$-class $L \subset J$, test if $a\rho_Rh\in L$. If so, denoting by $\bar{g} $ the conjugacy class of $\mul{H}(\rho_L'h\rho_L)$ in $\Gamma'(H)$, increment $r_J(h)$ by $1$ at position $\bar{g}$.
		\end{enumerate}
		\item Compute the matrix $\chi = (r_J(h)\cdot l_J(k))_{(h, k) \in C_M^2}$ using the previously computed vectors and return $\chi$.
	\end{enumerate}
\end{algo}

\begin{lined}
	\begin{ex}\label{ex:aperiodic_bichar}
		An \emph{aperiodic} monoid is a monoid where all $\hc$-classes are singletons. Let us apply the algorithm we just described in the case of a $\jc$-class $J$ with trivial $\hc$-classes.
		Several simplifications occur : first, we don't need to check for the conjugacy class, as there is only one. Secondly, the conjugacy class has cardinality one.
		Consider the vectors $r_J = (|S_{\rc}(h)|)_{h \in C_M}$ and $r_J = (|S_{\lc}(h)|)_{h \in C_M}$ with $S_{\lc}(h)$ and $S_{\rc}(h)$ defined as in Corollary \ref{cor:pt_fix_counting}. The bicharacter is simply the matrix product of $r_j^T$ with $l_J$. The particular case of this algorithm for aperiodic monoid is described in \cite[Section .1]{Thiery.CartanMatrixMonoid}
	\end{ex}
\end{lined}

\begin{algo}[Computing the bicharacter of $\kbf M$]\label{algo:M_char}
	If we consider $(\kbf M, M)$ as a combinatorial $\kbf M-\module-\kbf M$, we immediately have that:
	\[\chi_{\kbf M \otimes \kbf M'^{op}}^{\kbf M} = \sum_{J \in \jc}\chi_{\kbf M \otimes \kbf M'^{op}}^{\kbf J}\]
	and we can therefore compute the bicharacter of the whole monoid $M$: we first compute a set $C_M$ of representatives of the character equivalency classes and we the iterate Algorithm \ref{algo:j_class} over all $\jc$-classes and sum the results. 
%	However, we need to slightly change our assumptions on what we are able to compute compared to the previous example:
%	\begin{enumerate}
%		\item the monoid $M$ is given,
%		\item we can compute a set $C_M$ of character equivalency classes representatives,
%		\item we can compute the decomposition of $M$ in $\jc$-classes and the decomposition of each $\jc$-class $J$ as an union of $\rc$-classes and as an union of $\lc$-classes,
%		\item we can compute an $\hc$-class $H \subset J$ and an element $a \in H$ given a $\jc$-class $J$,
%		\item we keep assumptions 4 to 9 of Algorithm \ref{algo:j_class}
%	\end{enumerate}
	
	
%	\begin{itemize}
%	\item Input : The monoid $M$.
%	\item Output : A matrix $(|\{m \in M \sepp hmk=m\}|)_{(h, k) \in C_M^2}$.
%	\end{itemize}
%	\begin{enumerate}
%		\item Initialize $\chi = (0)_{(h, k) \in C_M^2}$
%		\item For each $\jc$-class $J$:
%		\begin{enumerate}
%			\item Compute $\chi_J$, the result of Algorithm \ref{algo:j_class} applied to $J$.
%			\item $\chi$ becomes $\chi + \chi_J$
%		\end{enumerate}
%		\item Return $\chi$.
%	\end{enumerate}
\end{algo}

The final useful example is the case of counting fixed points in a single regular $\lc$-class, for the purpose of computing the character table of the monoid.

\begin{algo}[Computing the bicharacter of an $\lc$-class]\label{algo:l_class}
	Let $e$ be an idempotent en let $L = \lc(e)$. In this example $\kbf L$ is still a combinatorial module, but it has the particularity, compared with the other two examples, that the monoids on the left and right are not the same. However, as the maximal subgroup at $e$, $G_e$, is a subsemigroup of $M$, the same results apply at no extra costs. 
%	Still, we have to, again, make some adjustments to our suppositions:
%	\begin{enumerate}
%		\item a set $C_M$ of character equivalency classes representatives is given,
%		\item the decompositions of $L$ as an union of $\hc$-classes is given,
%		\item we can compute $H_e = \hc(e),$
%		\item for each $\hc$-class $H \subset J$, we can compute a left Green pair $(\lambda_H, \lambda'_H)$ with respect to $(\rc(H_e), \rc(H))$,
%		\item given an element and a Green class, we can decide if this element belongs to the class,
%		\item we can compute the product of two elements in $M$,
%		\item we can identify the conjugacy class of an element in $G_e$, compute the cardinality of its centralizer and we can compute a set $C$ of conjugacy classes representatives of $G_e$. \todo{un exemple pour montrer comment tout collapse en un truc plus simple dans le cas r√©gulier}
%	\end{enumerate}
	
	We can simply adapt the algorithm of Algorithm \ref{algo:j_class}. Since an element of $C_{G_e}$ acts "as itself" on the right, we don't need to keep track of the action of the right with a vector $r_L$ as we did previously.
	\begin{enumerate}
		\item Initialize $\chi$ to $(0)_{(h,k)\in C_M\times C}$
		\item For each $h \in C_M$, for each $\hc$-class $H$, test if $h\lambda_Ha\in H$. If so, denoting by $k$ the conjugacy class of $\lambda_H'h\lambda_H$ in $G_e$, increment $\chi$ by $|C_{G_e}(h)|$ at position $(h, k)$.
		\item Return $\chi$
	\end{enumerate}
\end{algo}