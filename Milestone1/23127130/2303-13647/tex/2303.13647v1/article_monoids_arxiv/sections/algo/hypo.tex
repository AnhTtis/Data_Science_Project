In this section we discuss the computational hypotheses necessary for the algorithms in the next section. 
This section is based on the work \cite{east2019computing} in which East, Egry-Nagy, Mitchell and PÃ©resse provide efficient algorithms for all basic computational questions on finite semigroups (which include monoids). Although we limit our scope to the case of transformation monoids, methods described \cite{east2019computing} allow the algorithms described below to be applied to other interesting classes of monoids. Moreover, they can theoretically be applied to any finite monoid using a Cayley embedding in a full transformation monoid. In general however, this is very inefficient and not feasible in practice.

Following the authors of \cite{east2019computing}, we make the following fundamental assumptions that we can compute:  
\begin{itemize}
	\item Assumption I : a product of two elements of the monoid.
	\item Assumption II : the image and kernel of a transformation (note that we do not explicitly use this assumption, but that it is necessary for the algorithms of \cite{east2019computing} that we do use).
	\item Assumption III : Green pairs.
	\item Assumption IV : Given $h \in {}_M\stab(H)$ compute the corresponding element in $\Gamma(H)$ (understood as a permutation group of the image common to all elements of $H$ as seen in Example \ref{ex:schu_as_symm}), and similarly on the right.
\end{itemize}

Not only do we directly need to be able to do these computations for our own algorithm, but they are also prerequisite for the algorithms from \cite{east2019computing}. As such, we refer to the top of Section 5.2 of \cite{east2019computing} on how to realize these computations in the case of transformation monoids.

We, again, refer to \cite{east2019computing} for the specific algorithms meeting our computational prerequisites.
\begin{itemize}
	\item Computing the \schu groups: \cite[Algorithm 4]{east2019computing}
	\item Checking membership of an element in a Green class: \cite[Algorithms 7 \& 8]{east2019computing}.
	\item Finding idempotents: \cite[Algorithm 10]{east2019computing}. This algorithm also allows for finding the regular $\jc$-classes.
	\item Decomposing the monoid in $\rc, \lc$ and $\jc$-classes : \cite[Algorithm 11]{east2019computing} and its discussion. Note that by storing this decomposition, we can, given an element of the monoid, find the classes that contain it.
	\item Obtaining a representative of a Green class: this is given by the data structure representing the Green classes described at the top of \cite[Section 5.4]{east2019computing}.
\end{itemize}

Finally, we require the following points that, although they are not described in \cite{east2019computing}, are easily obtained from it.

\begin{itemize}
	\item Computing a set $C_M$ of character equivalency representatives: given Proposition \ref{prop:char_equiv}, this can be done in four steps:
	\begin{enumerate}
		\item compute a set $\mathcal{E}$ of idempotent representatives of the regular $\jc$-classes,
		\item compute $\Gamma(\hc(e))$ for each $e \in \mathcal{E}$,
		\item compute a set $C_e$ of representatives of the conjugacy classes of $\Gamma(\hc(e))$ for each $e \in \mathcal{E}$, using for instance the procedure described in \cite{hulpke2000conjugacy},
		\item for each $e \in \mathcal{E}$ and $c \in C_e$ compute the corresponding element of $\hc(e)$ as in Example \ref{ex:iso_idem}. 
	\end{enumerate}
	\item Computing $\tau_a$ as in Proposition \ref{prop:bij_cano_conj} :  given $g \in \Gamma(H)$, $\tau_a(g)$ is simply, seen as an element of $\symm(\ker a)$ :
	\[a\inv\{i\} \mapsto (g\cdot a)\inv\{g\cdot a(i)\},\]
	which can be computed in $O(n)$. Note that this is a special case of the application described in \cite[Proposition 3.11 (a)]{east2019computing}
	\item Testing that two elements $g, g'$ in $\Gamma'(\hc(a))$ are conjugated : $\Gamma'(H)$ is represented as a subgroup of $\symm(\ker a)$ and known procedures, such as the one described in \cite{butler1994inductive}, can be used.
	\item Computing the cardinality of a conjugacy class of a \schu group: for instance, the computer algebra system GAP uses the method described in \cite{hulpke2000conjugacy}.
\end{itemize}