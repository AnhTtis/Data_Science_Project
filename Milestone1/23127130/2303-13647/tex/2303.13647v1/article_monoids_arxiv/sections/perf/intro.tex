
%\todo{Rename the section to complexity and practical performance (or
%complexity and benchmarks}

%\todo{Everywhere: give names to the algorithms (not just ``our
%algorithm''). At least by mean of Algorithm X.Y}

Despite concentrating on transformation monoids, monoids being as diverse as they are, a meaningful analysis of the complexities of the above algorithms is difficult to do in terms of elementary parameters such as the rank (\emph{i.e.} the cardinality of the set acted upon), the number of generators or even the cardinality. Using only these parameters, we would have to make so many simplifying assumptions as to lose all meaning in our analysis.

Indeed, for our algorithms, the relevant metrics tends to be related to the Green-class structure and are the number of $\lc$ and $\rc$-classes in a $\jc$-class, the cardinality of the $\hc$-classes of a $\jc$-class as well as the number of conjugacy classes in its \schu groups, the number of generalized conjugacy classes, etc. In some sense, these metrics vary a lot: two transformation monoids acting on the same number of points with the same number of generators can have vastly different Green structures. 
Given this hurdle, it seems that the most meaningful level of analysis in terms of complexity is at the level of the $\jc$-class, where these parameters are a constant, rather than on the level of the whole monoid where we do not have any good monoid-wide estimate of how these useful metrics average out on all (regular) $\jc$-classes. Thus, in the following subsections, we will comment in any depth on the time complexity only for Algorithm \ref{algo:j_class} and for the solving of the equation system from Proposition \ref{prop:equations}.

Although a theoretical complexity of our algorithms is hard to precisely provide on the monoid-wide level, the real test of viability is to see if the algorithm effectively terminates in practice on typical examples. Thus, we provide benchmarks (for time and memory usage) for the computation of the three main objects of our discussion: the bicharacter, the character table and the Cartan Matrix.
We would like to know what is the typical performance on a "randomly chosen finite monoid". 
However, the question of taking a "generic" transformation monoid acting on a set number of points is a subject in itself, and outside the scope of this paper. 
Thus we chose to use two families of test cases: firstly the full transformation monoids and secondly random monoids generated by $m$ elements picked uniformly at random in $T_n$ and denoted by $R(m, n)$.
The full transformation monoids constitute a interesting test case in the sense that they are as big as possible. However, they are also highly structured and many computer algebra systems, including GAP, are smart enough to detect that the \schu groups are actually symmetric groups and thus use some non general algorithms that could not be used on typical finite monoids. This may introduce bias in our measurements on the full transformations monoids (and indeed probably does given Figure \ref{fig:plot_bichar}), hence why we separate the measure made on them from those made on the $R(m,n)$ monoids.

%Experimentally we note that the resources in time and memory used by two transformation monoids of the same rank with the same number of generators can differ by up to an order of magnitude. 

The measurements provided for these new algorithms (as well as the computation results presented hereafter) all come from an implementation using the computer algebra system GAP.
All performance measures are realized on a laptop equipped with an Intel Core i7-10850H @ 2.7GHz (on one core) and 16 GB memory. The measures on random monoids presented in this section are realized on monoids of the form $R(m,n)$, with $(m, n) \in \{(4,3), (5,3), (5,4), (6,5), (7,6), (9,8)\}$ (with $(9,8)$ excluded in the character table and Cartan matrices benchmarks) with 10 randomly chosen test cases for each $(m, n)$ in this set. Every appearance of $R(m, n)$ for a specific pair $(m, n)$ refers to the same monoid.
Our specific implementation, as well as the test cases used and the raw data, are publicly available on our git repository\footnote{\url{github.com/ZoltanCoccyx/monoid-character-table}}.

