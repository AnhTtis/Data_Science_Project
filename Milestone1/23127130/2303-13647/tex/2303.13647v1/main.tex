\pdfoutput=1
\documentclass{article}
\usepackage{pack}
\usepackage[backend = bibtex, sorting = none]{biblatex}
\addbibresource{biblio.bib}

\usepackage{lineno}
%\linenumbers

\title{Computing character tables and Cartan matrices of finite monoids with fixed point counting.}

\author{Balthazar Charles\footnote{LISN, Université Paris-Saclay, 6 Rue Noetzlin, Gif-sur-Yvette, 91190, France}}
\date{}

\begin{document}
	
	%\begin{frontmatter}
		
		\maketitle
						
		\begin{abstract}
			%% Text of abstract
			In this paper we present an algorithm for efficiently counting fixed points in a finite monoid $M$ under a conjugacy-like action. We then prove a formula for the character table of $M$ in terms of fixed points and radical, which allows for the effective computation of the character table of $M$ over a field of null characteristic, as well as its Cartan matrix, using a formula from [Thiéry '12], again in terms of fixed points. We discuss the implementation details of the resulting algorithms and provide benchmarks of their performances.
		\end{abstract}
		
	%\end{frontmatter}
	
	\section*{Introduction}
	
	\input{./sections/intro.tex}
	
	\section{Combinatorics of fixed point counting.}
	\input{./sections/combi/gen_def.tex}
	
	\subsection{Green structure and \schu groups}\label{sec:green}
	\input{./sections/combi/green.tex}
	
	\subsection{Counting fixed points}\label{sec:fixed}
	\input{./sections/combi/fixed_pts.tex}
	
	\section{Modules: character table and Cartan matrix}\label{sec:mod}
	\input{./sections/modules/intro.tex}

	\subsection{On modules}\label{sub:modules}
	\input{./sections/modules/modules.tex}
	
	\subsection{On characters}\label{sub:char}
	\input{./sections/modules/characters.tex}
	
 	\subsection{One step beyond: The Cartan matrix}
	\input{./sections/modules/cartan.tex}
	
	\section{Some explicit computations}\label{sec:Algos}
	\input{./sections/algo/intro.tex}
	
	\subsection{Computational hypotheses}\label{sub:hypo}
	\input{./sections/algo/hypo.tex}
	
	\subsection{Combinatorial bicharacter computing: 3 applications.}\label{sub:algos}
	\input{./sections/algo/3algos.tex}

	\subsection{Computing $N_e(\kbf L)$}
	\input{./sections/algo/ne.tex}
	
	\section{Performances, computational complexity and benchmarks}\label{sec:perf}
	In this section, we discuss performances in terms of complexity whenever we can, and in terms of benchmarks for timings and memory usage. In the next paragraph, we discuss the challenges in measuring performances and the subsequent choices made. Given these considerations, in the three paragraphs following, we discuss the computationnal performances of our three main objects of interest: the combinatorial bicharacter (\emph{i.e.} fixed-point counting), the character table and finally the Cartan matrix.
	
	\subsection{Discussion and Challenges}\label{sub:challenges}
	\input{./sections/perf/intro.tex}
	
	\subsection{Fixed point counting}\label{sub:perf_count}
	\input{./sections/perf/counting.tex}
	
	\subsection{Character table}\label{sub:perf_table}
	\input{./sections/perf/table.tex}
	
	\subsection{Cartan matrix}\label{sub:perf_cartan}
	\input{./sections/perf/cartan.tex}
	
	\section*{Conclusion and perspectives}

	The methods presented in this paper provide a new tool for the computational exploration of finite monoids representation theory. We give a method to compute the character table of a finite monoid in the general case as well as a method for the computation of the Cartan matrix. In the latter case, although general algorithms for any finite dimensional algebra already exist, by specializing to monoid algebras, we achieve vastly shorter computation times, thus making the question tractable for bigger monoids. Although we have presented the methods in details only for transformation monoids, the underlying formulas are true in general for finite monoids, and it remains computationally applicable whenever wherever the hypotheses of Section \ref{sec:Algos} are verified. We also invite the reader the consult and test our impementation, available on our github repository\footnote{github.com/ZoltanCoccyx/monoid-character-table}. As this paper is inspired by the combinatorial research on monoid representation theory which have seen renewed activity in recent years we hope that providing this effective tool will allows for the observation of new phenomena.
	
	This work has two natural continuations: improving and expanding.
	For the improvement part, we have noted that by far the most inefficient part of our algorithm is the computation of the radical of the $\lc$-classes, which happens to be the only point where linear algebra is necessary and combinatorics are seemingly not enough. 
	We can ask whether this step could be replaced by a combinatorial computation. 
	Some experiments show that, even in relatively small and very regular cases ($T_5$ for instance) the basis we find for the radical by solving the equation system described in Proposition \ref{prop:equations} does not have easily understandable structure, once the common denominator of the coefficients is eliminated. It therefore seem unlikely to us that a general method for computing the radical of an entirely combinatorial nature exists, although we remain optimistic that in very regular cases (again, $T_n$), the issue lies with us not finding the method rather than it not existing.
	More modestly, in a general context, we could try to exploit further the structure of the equations that define the radical to reduce the size of the system, which is a major bottleneck.

	Another improvement, although perhaps less impactful, could be made by exploiting redundancy: it can happen that two $\lc$-classes $L_1, L_2$ of a submonoid $M$ of $T_n$ are contained in the same $\lc$-class $L$ of $T_n$. Thus, in step $2-b$ of Algorithm \ref{algo:j_class} (for instance), instead of visiting each $\lc$ of $M$, we could visit each $\lc$ of $T_n$ that contain an $\lc$-class of $M$ and count them with some multiplicity. Although this probably would not lead to great improvements in efficiency, this has the advantage of making, in some sense, $T_n$ the worst case scenario, allowing for a finer complexity analysis.
	
	As for extending this work, the natural path seem to adapt these methods for fields of finite characteristic. At this point it appears to us that this question is tractable as the theory remains essentially the same, although it is somewhat difficult to implement in practice. The main hurdle arise, again, when computing the radical of an $\lc$-class: an equivalent of Proposition \ref{prop:rad_is_ne} would have to take into account the role of the radical of the maximal subgroup algebra, which can be non-trivial in positive characteristic. This would translate in needing to effectively compute this radical. Although algorithms are available (for instance in GAP), this is a theoretically difficult and computationally expensive problem, considerably reducing the maximum size of a tractable problem. While modular representation theory is known to be a difficult subject in groups it seems that, again, the situation is not much more complicated for monoids than it is for groups as it is standard practice to reduce monoid theoretic questions to group theoretic ones. Treating modular group representation theory as a black box coming with already existing algorithms (much as we did here for null characteristic group representation theory as a matter of fact), we hope to be able to provide a modular version of our algorithms along with an implementation in the near future.
	
	\section*{Acknowledgements}
	The research work devoted to this project was funded by a PhD grant from the French \emph{Ministère de la recherche et de l'enseignement supérieur}, in the form of a \emph{Contrat Doctoral Spécifique Normalien} attributed for a PhD in the STIC (\emph{Sciences et Technologies de l'Information et de la Communication}) doctoral school of Paris-Saclay University, in the LISN (\emph{Laboratoire Interdisciplinaire des Sciences du Numérique}) under the supervision of Pr. Nicolas Thiéry.
	
	\clearpage
	
	%\bibliographystyle{abbrv}
	
	%\bibliography{biblio}
	\printbibliography
	
\end{document}
