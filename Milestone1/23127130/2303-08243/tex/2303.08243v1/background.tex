\subsection{Vision-based Planning}

% The egocentric perception space depicts the local environment around the robot. Gaps constructed based on PGap provide a sparse structural representation of the egocentric free region. It efficiently bridges perception and local planning.

% There are multiple ways to synthesize trajectory in the local planning. One is integrating the path based on the potential field (PGap and harmonic field). However, this approach is safety guaranteed for ideal point mass robot with holonomic kinematic. Near identity method can consider nonholonomic kinematic, but not evaluate safety. Bezier based trajectory synthesis has the possibility to handle both.

Vision-based navigation in unknown environments has become popular nowadays. Perception acts as the first module in navigation frameworks. It is important to efficiently and accurately describe environments for safe path planning and control. Perception can be generally categorized into allocentric and ego-centric approaches \cite{Smith2020}. Within the human's neural hierarchy, ego-centric processing usually happens before allocentric estimation. It needs fewer memory resources and is computationally efficient in depicting the local region. 

Gap is one of the ego-centric methods that can model locally free space and leverage line-of-sight visibility. Although there is no formal definition of the ``gap", it is usually a segment of 1D laserscan measurement, and consists of starting and ending points to represent the collision-free region \cite{followthegap,CG,TCG,SG,AG,pgap,SmEtAl[2020]egoTEB}. Path planning with gaps should be able to improve safety and passibility. Especially, {\pGap} local planner \cite{pgap} proves safety guarantee for point-mass holonomic robot models. It includes radial extension and projection operator to enhance safety for nonholonomic mobile robots. However, the closed-form proof does not hold. 

After modeling environments, the next step is planning a collision-free path within the perception space. Dijkstraâ€™s algorithm, A$^\star$, D$^\star$, D$^\star$ Lite, and AD$^\star$ \cite{dijkstra,Astar,Dstar,DstarLite,LIKHACHEV20081613} are graph search planning methods in costmaps. PRM, RRT, and RRT-X \cite{prm,lazyPRM,rrt,Otte2014RRTXRM} are sample-based planners that search for collision-free paths in the workspace. These are generally used as global planers. Reactive policies such as EB, DWA, TEB and egoTEB \cite{eb,DWA,TEB,SmEtAl[2020]egoTEB} generate local plans to avoid obstacles and approach to goals. 

In addition, artificial potential field (APF) offers fast computation for obstacle avoidance \cite{APF1985,APF_numerical,APF_newfunction, APFSimAnnel, APFRegression}. {\pGap} local planner \cite{pgap} uses APF to synthesize safety guaranteed paths for point-mass holonomic models.
Also, B\'{e}zier curve is a well-known technique to generate smooth trajectories for different robot models \cite{Choi2008PathPB,ELHOSENY2018339,s21072460,Zheng2020BezierTraj,HASSANI2018305,BryceUAVBezier}. 
Our recent work, B\'{e}zier Gap \cite{bgap}, leverages the property of B\'{e}zier curve to synthesize safe trajectories for holonomic quadrupedal robots. However, there is no safety guarantee for nonholonomic models in planning. Consequently, it motivates the research to leverage the advantages of gaps and B\'{e}zier curves for nonholonomic path planning.

\subsection{Nonlinear Model Predictive Control}

Model predictive control (MPC) is a receding-horizon controller that can be used for both generating or tracking trajectories\cite{mpc-book}. For the latter, trajectories are typically generated by a different module that uses a simplified model of the system to allow for fast trajectory generation. In particular, \cite{mpc-wheeled,mpcTEB} demonstrates the efficacy of NMPC for path and trajectory tracking for nonholonomic robots, supporting the utility of NMPC for local planning. Further, enforcing safety constraints in a MPC fashion leads to unconservative safe trajectories. 

% \subsection{\toedit{Control Barrier Function}}
% \TODO{Ahmad}
\subsection{Safety and Control}
% Traditionally, safety is enforced as a hard constraint in optimal control settings \cite{Xiao2021}. However, depending on the complexity of the constraints system, optimal control problems can easily become challenging to solve numerically within the time allotted for real-time control.

In recent years, safety in control systems has been incorporated via invariant set theory analysis. To ensure safety for a particular set, e.g., free space set $\freeSpace$ in navigation applications, one needs to prove that $\mathcal{F}$ is an invariant set. The safe set is typically represented by the zero sublevel set of a continuously differentiable implicit function, termed barrier function, $h(\tPose):\Real^n\rightarrow\Real$.
\begin{align}
    \mathcal{F} &= \setof{\tPose\in\Real^n}{h(\tPose)\geq 0} \\ 
    \partial\mathcal{F} &= \setof{\tPose\in\Real^n}{h(\tPose)= 0}
\end{align}
where, $\partial\mathcal{F}$ denotes the boundary of the set.

Further, for controlled systems, the control barrier function (CBF) is introduced, for which the control action of the system must render the safe set invariant. The traditional implementation of CBF-based control takes place at the last tier of the control system hierarchy in the form of a point-wise optimization problem that seeks to synthesize safe control actions by satisfying the CBF constraint while minimally deviating from the base controller output \cite{AA17TP}. If the system dynamics are control affine, the aforementioned optimization problem will take the form of a quadratic program (QP).
\begin{equation}  \eqlabel{cbf-qp}
\begin{aligned}
    \min_{\tControl} \quad &\norm{\tControl-\tControl_r}^2\\
    \text{s.t.} \quad & \nabla h^T(\tPose)f(\tPose) + \nabla h^T(\tPose)g(\tPose)\tControl \geq -\gamma h(\tPose)\\
                \quad & \tControl_{min} \leq \tControl_i \leq \tControl_{max}, \, \forall i=1,\cdots,m
\end{aligned}
\end{equation}
where, $\tControl_r\in \Real^m$ is the output of the base controller, $f(\tPose):\Real^n\rightarrow \Real^n$ and $g(\tPose):\Real^n\rightarrow\Real^{n\times m}$ are the system dynamics matrices, $\gamma$ tunable positive parameter, and $\tControl_{min}$ and $\tControl_{max}$ are actuation limits.

However, CBF-based full safe trajectory synthesis has been investigated in \cite{HM22ET} and \cite{JZ21KS}. In the former, the CBF constraint is elevated into a state differential equation facilitating the utilization of traditional control techniques, e.g., LQR and pole placement. In the latter, a discrete form of the CBF constraint in \eqref{cbf-qp} is added to a discrete NMPC formulation. But the resulting safe trajectories are similar to those obtained from discrete NMPC with BF constraint with inflation of the boundaries. As a result, in this work, the {\keyhole} will be added as a discrete position constraint in NMPC formulation for trajectory tracking, as will be discussed in the next section.

To guarantee the existence of solutions to CBF-QP in \eqref{cbf-qp}, $h(\tPose)$ must be a valid CBF, which is usually difficult to certify and can only be done offline. Sum-of-squares is one technique to solve for the polynomial coefficients of $h(\tPose)$ \cite{AAsos}. Similarly, Hamilton Jacobi (HJ) based reachability analysis can be used to generate a safe backward-reachable-set, which can be used as a CBF \cite{SB17CT,MC18CT}. Since both of those methods require offline computation, it is difficult to deploy them in changing environments, although some techniques have been proposed to synthesize safe trajectories from a library of offline-computed reachable sets \cite{Kousik2020,FasTrack}.

% \subsubsection{Mapping velocity commands of CBF-QP}
% Since the domain of the barrier function will be the position of the robot (excluding orientation), a single integrator model is assumed for the robot in CBF-QP. The reference control command is the instantaneous translational velocity of the robot, i.e., $u_r=[v\cos\theta,v\sin\theta]^T$. The calculated safe velocity commands by CBF-QP, $u=[\dot{x}_s,\dot{y}_s]^T$, are mapped to the robot commands using \eqref{w-qp} and \eqref{v-qp}. $\Delta\theta$ is the angle difference between the vectors $u_r$ and $u$ and is added to the current rotation rate to correct the angle difference. $k_{\omega}$ is a positive tunable parameter. The translational velocity is damped down proportionally to the ratio of $\Delta\theta$ to a maximum angle $\theta_{max}$. If $\Delta\theta\geq\theta_{max}$, the robot will only rotate. 
% \begin{align}
%     \omega &= \omega_r + k_{\omega}\Delta\theta \eqlabel{w-qp} \\ 
%     v      &= \max\left(0,1-\frac{\abs{\Delta\theta}}{\theta_{max}}\right)\abs{u} \eqlabel{v-qp}
% \end{align}
