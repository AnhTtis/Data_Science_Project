
\begin{figure}[t]
  \vspace*{0.065in}
  \centering
  \scalebox{0.75}{
  \begin{tikzpicture}[inner sep=0pt,outer sep=0pt]
    \node[anchor=south west] at ($(0, 0)$)
    	{{\input{figs/bezier_path}}};
  \end{tikzpicture}%
  }
  \caption{B\'{e}zier trajectory synthesis. $\pose(0)$ is the robot origin. $\eleInd{\cpf}{1}$ and $\eleInd{\cpf}{2}$ are the second and third control points for the first cubic B\'{e}zier curve. Blue lines $\gapSide_l$ and $\gapSide_r$ are left and right gap sides. Red circle is the largest circular free space in egocircle. $\point_l$ and $\point_r$ are the left and right intersection points of $\gapCirc$ and gap sides. Local waypoint $\goal$ is inside the inflated safe region $\infFreeSpace$ to guarantee safety. $\circPt$ is the goal biased point on $\infGapCirc$. Dashed lines show the B\'{e}zier polygons. The combination of brown and cyan paths is the final synthesized path. \label{fig:bezier_safe}}
  % \vspace*{-1.5em}
\end{figure}


This section introduces a gap-based local planning policy to guarantee safe navigation for nonholonomic mobile robots, so called {\saferGap}. It incorporates line-of-sight visibility from gap detection to construct collision free space. Then safety and passibility are maintained during the design of path planning and motion control. 

\subsection{Joined B\'{e}zier Path Planning \label{sec:bp}}

In our previous work \cite{pgap,bgap}, gap-based perception space and B\'{e}zier-based trajectory synthesis are demonstrated to have good navigation performance. However, safety is only guaranteed for the holonomic robot model. We propose to synthesize smooth and safe paths from gaps based on joined B\'{e}zier curves. 
Gap depicts the open region between two obstacles by considering robot's line-of-sight visibility, as shown in Fig.~\ref{fig:bezier_safe}. It is generated from egocircle and follows the same procedure in \cite{pgap}. The egocircle \cite{Smith2020} is an ego-centric 1D array that contains spatial and temporal information of the environment. 

\subsubsection{Collision-free space generation}
Similar to \cite{bgap}, a collision-free space $\freeSpace$ is geometrically constructed for each gap. However, triangle regions constructed in \cite{bgap} are too compact when one side of the robot is close to an obstacle; thus, a richer polygonal space should be created. The largest circular collision-free space $\gapCirc$ within egocircle $\egoCirc$ is found, e.g., red circle in Fig.~\ref{fig:bezier_safe}. Two gap points, $\lgap$ and $\rgap$, are initially connected to the tangent points of $\gapCirc$. The raw gap sides are formulated. To be noticed, the tangent point corresponding to $\lgap$ always has smaller polar angle than $\rgap$ in the robot local frame. If raw gap sides are obstructed by other obstacles, inward rotations are applied about $\lgap$ (clockwise) and $\rgap$ (counter clockwise) until there is no obstruction. The maximum rotation can push the tangent point to the center of $\gapCirc$, which constructs a minimum collision free space $\freeSpace$, which is the same as \cite{bgap}. After rotation, the gap sides, $\gapSide_l$ and $\gapSide_r$ are finalized. We define the intersections between $\gapSide$ and $\gapCirc$ are $\point_l$ and $\point_r$. Two gap points and two intersected points formulate a collision free polygon $\gapPoly$. The full collision free space $\freeSpace$ is 
\begin{equation}
    \freeSpace = \gapPoly \cup \gapCirc
\end{equation}
Considering robot geometry, $\freeSpace$ is inflated as $\infFreeSpace$ in Fig.~\ref{fig:bezier_safe}. The inflation size is a function of robot radius. Intersected points after inflation are denoted as $\inflate{\point_{l}}$ and $\inflate{\point_{r}}$. Inflated gap circle is $\infGapCirc$. Any path $\bPath$ within the inflated collision free space $\bPath \in \infFreeSpace$ can guarantee safety for the full robot geometry.

% In order to generate smooth and safe paths for nonholonomic robots, joined B\'{e}zier curves are described. The first segment is a cubic B\'{e}zier curve parameterized by $u$ inside $\infGapCirc$,
\subsubsection{Joined B\'{e}zier curves}
The first segment is a cubic B\'{e}zier curve parameterized by $u$ inside $\infGapCirc$,
\begin{equation} \label{eq:cb}
\begin{aligned}
  \bezierCurve_1(u) &= \sum_{i=0}^{n=3} \binom{n}{i} (1-u)^{n-i} u^i \eleInd{\cpf}{i} \\
  \binom{n}{i} &= \frac{n!}{i!(n-i)!}, \; 0 \leq u \leq 1
\end{aligned}
\end{equation}
where $\eleInd{\cpf}{i}$ is the $i$th control point of $\bezierCurve_1$.

Since the gap is detected in robot local frame, robot center is used as the first control point $\eleInd{\cpf}{0} = \pose(0)$. An intermediate point $\circPt$ is defined on the arc between $\inflate{\point_l}$ and $\inflate{\point_r}$, and served as the last control point $\eleInd{\cpf}{3}$. The other two control points are designed from initial orientation $\theta(0)$, linear velocity $\nu(0)$, and acceleration $\acc(0)$ of the nonholonomic robot. $\eleInd{\cpf}{1}-\eleInd{\cpf}{0}$ is co-linear with the unit orientation vector $\orient(0)=[cos(\theta(0)),sin(\theta(0))]$. Curve velocities and accelerations are obtained from the first and second derivatives of cubic B\'{e}zier curve, 
\begin{align}
 \dot{\bezierCurve_1}(u) &= 3 \sum_{i=0}^{2} \binom{2}{i} (1-u)^{2-i} u^i (\eleInd{\cpf}{i+1}-\eleInd{\cpf}{i})  \\
  \dot{\bezierCurve_1}(0)&=3(\eleInd{\cpf}{1}-\eleInd{\cpf}{0}) \\
  % \ddot{\bezierCurve_1}(u) &= 6 (1-u) (\eleInd{\cpf}{2}-2\eleInd{\cpf}{1}+\eleInd{\cpf}{0}) + 6u (\eleInd{\cpf}{3}-2\eleInd{\cpf}{2}+\eleInd{\cpf}{1}) \nonumber \\
  \ddot{\bezierCurve_1}(u) &= 6 \sum_{i=0}^{1} \binom{1}{i} (1-u)^{1-i} u^i (\eleInd{\cpf}{i+2}-2\eleInd{\cpf}{i+1}+\eleInd{\cpf}{i})  \\
  \ddot{\bezierCurve_1}(0)&=6(\eleInd{\cpf}{2}-2\eleInd{\cpf}{1}+\eleInd{\cpf}{0}).
\end{align}

The curve parameter $u \in [0,1]$ should be scaled to time $t \in [0,\timeScaleF]$ and $t = \timeScaleF u$. The final time $\timeScaleF$ is estimated by $||\circPt-\pose(0)||/\nu_d$, where $\nu_d$ is the robot desired linear velocity. Then the scaled B\'{e}zier path $\scale{\bezierCurve}_1(t)=\bezierCurve_1(t/\timeScaleF)$, and
\begin{align}
    \dot{\scale{\bezierCurve}_1}(t) &= \frac{1}{\timeScaleF} \dot{\bezierCurve_1}(\frac{t}{\timeScaleF}) \\
    \ddot{\scale{\bezierCurve}_1}(t) &= \frac{1}{\timeScaleF^2} \ddot{\bezierCurve_1}(\frac{t}{\timeScaleF}).
\end{align}

Set $||\dot{\scale{\bezierCurve}_1}(0)||=\nu(0)$, which needs $||\eleInd{\cpf}{1}-\eleInd{\cpf}{0}||=\timeScaleF \nu(0)/3$. Then set $\ddot{\scale{\bezierCurve}_1}(0)=\acc(0)$, all control points for the first B\'{e}zier path segment $\bezierCurve_1(u), u \in [0,1]$ are uniquely defined
\begin{equation}
\begin{aligned}
    \eleInd{\cpf}{0} &= \pose(0) \\
    \eleInd{\cpf}{1} &= \pose(0) + \frac{\timeScaleF \nu(0)}{3}\orient(0) \\
    \eleInd{\cpf}{2} &= \frac{\timeScaleF^2}{6} \acc(0) - \eleInd{\cpf}{0} + 2 \eleInd{\cpf}{1} \\
    \eleInd{\cpf}{3} &= \circPt
\end{aligned}
\end{equation}

The second path segment is generated from a quadratic B\'{e}zier curve
\begin{equation} 
  \bezierCurve_2(u) = (1 - u)^2 \eleInd{\cps}{0} + 2(1 - u)u \eleInd{\cps}{1} + u^2 \eleInd{\cps}{2}.
\end{equation}
where $\eleInd{\cps}{0}=\circPt$. 

G1 continuity maintains a smooth connection between B\'{e}zier curves. Therefore, the direction vector $\directVec$ should satisfy the equality:
\begin{equation} 
  \directVec = \frac{\eleInd{\cps}{1}-\eleInd{\cps}{0}}{||\eleInd{\cps}{1}-\eleInd{\cps}{0}||} = \frac{\eleInd{\cpf}{3}-\eleInd{\cpf}{2}}{||\eleInd{\cpf}{3}-\eleInd{\cpf}{2}||}
\end{equation}
The magnitude of $\eleInd{\cps}{1}-\eleInd{\cps}{0}$ is calculated by desired linear velocity $\nu_d$. With quadratic B\'{e}zier curve and similar scale mechanism,
\begin{align}
  \dot{\bezierCurve_2}(u) &= 2(1-u)(\eleInd{\cps}{1} - \eleInd{\cps}{0}) + 2u(\eleInd{\cps}{2} - \eleInd{\cps}{1}) \\
  \dot{\bezierCurve_2}(0) &= 2(\eleInd{\cps}{1} - \eleInd{\cps}{0}) \\
  \dot{\scale{\bezierCurve}_2}(t) &= \frac{1}{\timeScaleS} \dot{\bezierCurve_2}(\frac{t}{\timeScaleS})
\end{align}
where $\timeScaleS=||\goal-\circPt||/\nu_d$. 

Similarly, set $||\dot{\scale{\bezierCurve}_2}(0)||=\nu_d$, which requires $||\eleInd{\cps}{1}-\eleInd{\cps}{0}||=\timeScaleS \nu_d / 2$. When $\circPt$ is close to $\inflate{\gapSide_l}$ or $\inflate{\gapSide_r}$, $\eleInd{\cps}{1}$ is possible to be outside of the inflated gap sides after scaling. A length scale number $\lambda \in (0,1]$ is calculated to bound $\eleInd{\cps}{1}$ inside $\infFreeSpace$. All control points for the second B\'{e}zier path segment $\bezierCurve_2(u)$ are constrained
\begin{equation}
\begin{aligned}
    \eleInd{\cps}{0} &= \circPt \\
    \eleInd{\cps}{1} &= \circPt + \lambda \frac{\timeScaleS \nu_d}{2}\directVec \\
    \eleInd{\cps}{2} &= \goal \\
\end{aligned}
\end{equation}

Local waypoint $\goal$ candidates are initially found based on global plans and then bounded by $\infFreeSpace$. The intermediate point $\circPt$ starts with the middle point of the arc, then is biased by the relative position between $\pose(0)$ and $\goal$ to synthesize smoother paths. If $\goal$ is within $\infGapCirc$, only first B\'{e}zier segment is computed. The final B\'{e}zier-based path is 
\begin{equation}
    \bPath(u) = \begin{cases}
        \bezierCurve_1(u), & \goal \in \gapCirc \\
        \bezierCurve_1(u) \cup \bezierCurve_2(u), & \text{otherwise}
    \end{cases}
\end{equation}

From the above design, the first B\'{e}zier polygon for $\bezierCurve_1(u)$ is always within $\infGapCirc$. The second B\'{e}zier polygon is within the convex region $\inflate{\gapPoly}$.
Therefore, the joined B\'{e}zier path is inside the inflated collision free space, $\bPath(u) \subseteq \infFreeSpace$. Safety and passibility are achieved for nonholonomic robots.
It only takes $\leq 2ms$ to generate path for each gap (on Intel i7-8700). The full path planning time depends on the number of detected gaps. A set of new paths are synthesized in every planning loop.


\subsubsection{Path scoring}
A scoring function is computed for each joined B\'{e}zier path to choose the best executed one $\bPath^*$. This function is an improved version from \cite{pgap} by adding an orientation cost. The path has lower deviation from robot's orientation is preferable, since nonholonomic robots cannot suddenly turn backwards. It is also helpful to pick the correct path when the final goal point is on the other side of walls.
\begin{multline*}
    \nonumber 
    J(\bPath) = \sum_{\tPose \in \bPath} 
        C(\dist(\tPose,\egoCirc)) + w_1||\tPose_\text{end} - \pose^*|| 
       + w_2 |\theta_\text{end} - \theta(0)| 
\end{multline*}
\vspace{-1.em}
\begin{eqnarray}
  \nonumber 
  \small{\text{where} \quad
    C(d) = \begin{cases}
      c_{\text{obs}} e^{-w_2 (d - \rIns)}, & d > \rIns \\
      0, & d > r_{\text{max}}\\
      \infty, \text{otherwise}
    \end{cases}}
\end{eqnarray}
$\dist(\tPose,\egoCirc)$ is the distance from path pose $\tPose=[\text{x}_1, \text{x}_2, \theta]^T$ to the nearest point on egocircle $\egoCirc$. $||\tPose_\text{end} - \pose^*||$ measures the distance between the end pose of $\bPath$ and the local goal $\pose^*$ from a global plan. $|\theta_\text{end} - \theta(0)|$ is the angle difference between end pose and initial pose. $\rIns$ and $r_{\text{max}}$ are proportional to the robot radius to control the safe distance. $w_1$, $w_2$ and $c_{\text{obs}}$ are tunable weights. Each time, every best path $\bPath^*_i$ compares with the previous executed path $\bPath^*_{i-1}$ to decide whether switching to the new path.
One example is shown in Fig.~\ref{fig:bezier_path}. The best path (red) is selected from a set of B\'{e}zier path candidates.

\begin{figure}[t]
 \vspace*{0.065in}
  \centering
  \scalebox{0.75}{
  \begin{tikzpicture}[inner sep=0pt,outer sep=0pt]
    \node[anchor=south west] at ($(0, 0)$)
    	{{\includegraphics[height=2.8in]{figs/b_path2_comp.png}}};
  \end{tikzpicture}%
  }
  \caption{Joined B\'{e}zier paths for all gaps. Blue is egocircle $\egoCirc$. Yellow are 5 detected gaps. Green points are local waypoints $\goal$. Black paths are the synthesized B\'{e}zier paths $\bPath$. Red path is the selected $\bPath^*$ based on the scoring equation. \label{fig:bezier_path}}
  \vspace*{-1.5em}
\end{figure}