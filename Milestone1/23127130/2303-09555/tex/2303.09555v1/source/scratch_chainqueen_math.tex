%\newcommand{\D}{\mathrm{d}}
\newcommand{\D}[1]{\frac{\partial L}{\partial {{#1}}}}
\newcommand{\pd}[2]{\frac{\partial{#1}}{\partial{#2}}}
%\newcommand{\chain}[2]{\D{#1}\cdot\pd{#1}{#2}}
\newcommand{\chain}[2]{\D{#1} \pd{#1}{#2}}
\newcommand{\dep}{\leftarrow}
\newcommand{\rdep}{\rightarrow}
\newcommand{\ttau}{\boldsymbol{\tau}}
\newcommand{\Dinv}{\frac{4}{\Delta x^2}}
\newcommand{\ePpn}{\PP_p^n & = & \PP_p^n(\FF_p^n, E_p, \nu_p)+\FF_p\sig_{pa}^n}
\newcommand{\emin}{m_i^{n} & = & \sum_p N(\xx_i-\xx_p^n)m_p}
\newcommand{\eppin}{\pp_i^{n} & = & \sum_p N(\xx_i- \xx_p^n) \left[m_p\vv_p^n+\left(-\Dinv\Delta t V_p^0\PP_p^n\FF_p^{nT} + m_p \CC_p^n\right)(\xx_i-\xx_p^n)\right]}
\newcommand{\evvin}{\vv_i^{n} & = & \frac{1}{m_i^n}\pp_i^n}
\newcommand{\evvpnn}{\vv_p^{n+1} & = & \sum_i N(\xx_i- \xx_p^n)\vv_i^n}
\newcommand{\eCCpnn}{\CC_p^{n+1} & = &\frac{4}{\Delta x^2} \sum_i N(\xx_i- \xx_p^n)\vv_i^n(\xx_i-\xx_p^n)^T}
\newcommand{\eFFpnn}{\FF_p^{n+1} & = & (\II + \Delta t \CC_p^{n+1})\FF_p^n}
\newcommand{\exxpnn}{\xx_p^{n+1} & = & \xx_p^n + \Delta t \vv_p^{n+1}}

\item \textbf{Particle-to-grid transfer (P2G).}
Particles transfer mass $m_p$, momentum $(m\vv)_p^n$, and stress-contributed impulse to their neighbouring grid nodes, using the Affine Particle-in-Cell method (APIC)~\cite{jiang2015} and moving least squares force discretization~\cite{hu2018moving}, weighted by a compact B-spline kernel $N$: ($\GG_p^n$ below is a temporary tensor)
\small
\begin{eqnarray}
%\ePpn \\
\emin,\\
\GG_p^n&=&-\Dinv\Delta t V_p^0\PP_p^n\FF_p^{nT} + m_p \CC_p^n,\\
\small\pp_i^{n} & = & \sum_p N(\xx_i- \xx_p^n) \left[m_p\vv_p^n+\GG_p^n(\xx_i-\xx_p^n)\right].
\end{eqnarray}
\normalsize
\vspace{-8pt}
\item \textbf{Grid operations.} Grid momentum is normalized into grid velocity after division by grid mass: \begin{eqnarray}\label{eqn:grid}
\evvin.
\end{eqnarray}
Note that neighbouring particles interact with each other through their shared grid nodes, and collisions are handled automatically. Here we omit boundary conditions and gravity for simplicity.
\item \textbf{Grid-to-particle transfer (G2P).} Particles gather updated velocity $\vv_p^{n+1}$, local velocity field gradients $\CC_p^{n+1}$ and position $\xx_p^{n+1}$. The constitutive model properties (e.g. deformation gradients $\FF_p^{n+1}$) are updated.

\small
\begin{eqnarray}
\evvpnn, \\
\eCCpnn, \\
\eFFpnn, \\
\exxpnn.
\end{eqnarray}
\normalsize

\end{enumerate}

\paragraph{Bonudary conditions (Contact models)} ChainQueen adopts four commonly used MPM boundary conditions from computer graphics~\cite{stomakhin2013material}. These boundary contidions happen on the grid, after Eqn. \ref{eqn:grid}. Denoting the grid node velocity as $\vv$ and local boundary normal as $\nn$, the four boundary conditions are
\begin{enumerate}
    \item[\textbf{Sticky}] Directly set the grid node velocity to $\mathbf{0}$. I.e., $\vv \leftarrow \mathbf{0}$.
    \item[\textbf{Slip}] Set the normal component of the grid node velocity to $0$. I.e., $\vv \leftarrow \vv - (\vv \cdot \nn)\nn$.
    \item[\textbf{Separate}] If the velocity is moving away from the boundary $(\vv \cdot \nn > 0)$ then do nothing. Otherwise use \textbf{Slip}. This can be considered as a special case (coefficient of friction $=0$) of \textbf{Friction}.
    \item[\textbf{Friction}] If the velocity is moving away from the boundary $(\vv \cdot \nn > 0)$ then do nothing. Otherwise apply Coulomb's law of friction to compute the new tangential and normal components of velocity after collision and friction.
\end{enumerate}

\subsection{Material Models}
We extend ChainQueen's original material model, which was simply fixed corotated material, in order to further support Neohookean materials as well.  We emphasize that other material models can be simply, modularly added as an option in ChainQueen, so long as they are differentiable.

\aes{The difference between Neohookean, corotated, and linear materials has been well studied and documented \cite{bonet1997nonlinear, liu2017quasi, smith2018stable}, especially in the static load case.  We direct the reader to the accompanying video, for a simple example of material model choice on a nearly incompressible oscillating actuator, demonstrating a modest, but not insignificant effect that choice of material model can have on a soft robot's dynamical response.  The (wall-time) difference in the computational cost of the Neohookean and corotated models is negligible.}

\paragraph{Fixed Corotated}  The fixed corotated material model~\cite{stomakhin2012energetically} is defined as having first Piola-Kirchoff Stress function $\PP$:

\begin{align}
\PP(\FF) = 2 \mu (\FF-\RR) + \lambda (J-1)J \FF^{-T}
\end{align}

\noindent where $J = \det(\FF)$, and $\lambda$ and $\mu$ are the first and second Lam\'e parameters, determined by the material's Young's modulus and Poisson's ratio.  Here, $\mathbf{R}$ is the rotational component of $\FF$, computable \emph{via} the (differentiable) polar decomposition.

\paragraph{Neohookean}  The Neohookean material \aes{model} is especially popular in modeling nonlinear rubbers and silicones.  The Neohookean elastic stress tensor is defined as:

\begin{align}
    \PP(\FF) = \mu(\FF - \FF^{-T}) + \lambda \log(J) \FF^{-T}
\end{align}

Although this energy model possesses a pole at $J=0$, this corresponds to the situation where the material is compressed to a singularity.  \aes{While instability caused by this singularity can happen in practice in general, it rarely occurs in the types of systems explored here, and never happened in any of our experiments.}  \footnote{Note that in MPM the update of $J$ (i.e. $\textbf{det}(F)$) is multiplicative instead of additive; getting $J \le 0$ \aes{is rare in our domain.  Inversions are still a serious topic of investigation for many other applications in MPM and MPM at large.}}

\paragraph{Incompressible materials}
\label{sec:incompressible}
Materials may be made approximately incompressible by adding a stress, as described by Bonet and Wood \cite{bonet1997nonlinear}.  In this scenario, an additional incompressibility stress tensor is added to the original stress tensor: $\PP = \PP_{elastic} + \PP_{inc}$:

\begin{align}
    \PP_{inc}(\FF) = \frac{E}{3 (2 - 2 \nu)} p (J - 1)^{p-1} J \FF^{-T}
\end{align}

\noindent where $p$ is a parameter $ \geq 2$.  The larger $p$ is chosen, the more strongly incompressibility will be enforced.  The ability to simulate incompressible materials is included in our ChainQueen extensions.

\subsection{Actuation Models}
\label{sec:actuation}
Designed to model real-world soft robots, our extended ChainQueen implementation supports two common actuation models found in soft robots.  The first, aimed at modeling fluidic actuators, is a stress-based actuation model.  The second, which we present here and aimed at modeling cable-based actuation, is a force-based actuation model.  These models are physically based and do not inject any net fictitious forces or pressures to the system (thus respecting Newton's third law).  We modify the classical MLS-MPM formulation with two additional steps in order to account for application of the actuation.

In order to model stress-based (including fluidic) actuators, we have designed an actuation model that stretches a given particle $p$ with an additional cauchy stress:
\begin{align}
\AA_p=\FF_p\sig_{pa}^{}\FF_p^T
\end{align}

Here, $\sig_{pa}=\text{diag}(a_x, a_y, a_z)$.  This equation corresponds to the stress in material space.  Particles corresponding to a given actuator are assigned at robot design time; each actuator thus affects many corresponding particles applying the same stress.  Note that this formulation naturally allows for both isotropic and anisotropic pressure actuators, useful for modeling directionally constrained actuators (\emph{e.g.} Sun et al \cite{sun2016miniature}).  Already, this model is well-suited for modeling stress-based actuators (\emph{e.g.} Hara et al \cite{hara2004artificial}) and pneumatic actuators (\emph{e.g.} Marchese et al\cite{marchese2015recipe}).  This model is similarly well-suited to simulating hydraulic actuators, modeling the actuator's particles as incompressible, as previously described in Section \ref{sec:incompressible}.

In order to model force-based actuators, such as cable-driven actuators, we simply integrate these forces when updating our particle velocity, creating an additional summable velocity term, $\mathbf{v}_{act}$:

\begin{align}
    \mathbf{v}_{act} = \mathbf{f}_{act} dt \aes{ / m}
\end{align}

\aes{Velocities, forces, and masses here refer to particle states.}  Here, $\mathbf{f}_{act}$ is computed as some user-defined force model.  We detail one such model here, which also provides a concrete example of how actuation signals can be applied. 
