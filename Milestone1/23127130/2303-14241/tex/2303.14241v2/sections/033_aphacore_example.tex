\spara{An Example of AlphaCore.}
To better illustrate the differences between the traditional graph-$k$-core and {\textsf AlphaCore} decomposition methods, we showcase an example in Figure \ref{fig:running_example}.  %We are interested in the inner core that captures only the most important traders of a financial network.  
In the case of graph-$k$-core, the innermost core is the 3-core, whereas the {\textsf InnerCore} of {\textsf AlphaCore} would be the core of $\alpha$ $>$ 0.75.  Note that the 3-core consists of nodes that trade frequently with themselves, but their trade volumes with themselves are not that significant compared to other transactions which exist in the network.  In certain analyses of financial networks such as anomalous address detection, being able to filter out these negligible transactions and their participating nodes, while still capturing more meaningful ones, significantly improves the accuracy and scalability of subsequent computations on the decomposed network core.  On the other hand, the {\textsf AlphaCore} of $\alpha$ $>$ 0.75 is able to capture both the nodes that participate in the largest transactions which occur in the example network, while filtering the negligible transactions and their participating nodes.  
We point out that the main limitation with graph-$k$-core is that it only considers node degrees, whereas {\textsf AlphaCore} is flexible and can consider any combination of node features as outlined in Table 1, without requiring to specify any feature weighting parameters to perform effectively on a particular task.  
Therefore, in networks where edge weights fall under a broad range and they are meaningful distinguishing factors, we recommend {\textsf AlphaCore} over the traditional graph-$k$-core decomposition.

\subsection{Problem Definition}
\label{sec:prob}
Given a  weighted, directed, multi-graph {representation of a blockchain transaction network} over successive timestamps, where $G_t(\V_t,\E_t, w_t)$ denotes the graph at timestamp $t$, $\V_t$ its set of nodes (traders \footnote{{While a
trader can own multiple addresses, a typical trader has a main address that
holds the bulk of the assets. With our {\textsf InnerCore} approach, we are interested in capturing these main
addresses (i.e., nodes) and the respective traders.}}, exchanges, liquidity pools, etc.), and $\E_t$ multiset of edges (i.e., transactions) representing {the amount of asset transferred between two nodes},  {\bf (i)} detect the node set $S_t \subseteq \V_t$ at time $t$ such that the behavior of nodes in $S_t$ can %be used to 
characterize the future success of the underlying asset at $t^\prime>t$, and {\bf (ii)} categorize nodes' behavior in terms of the future health and success of the underlying asset. 
%{We define traders as externally owned addresses ({\textsf EoA}s).}



\noindent\textbf{E-crime Detection vs. Prediction.} In blockchain space, predictions can only go so far, as we are unable to anticipate malicious transactions that originate from the external world. At most, what we can do is to detect e-crime transactions among the vast number of transactions taking place. This detection process is highly valuable because when a significant crime occurs, we have access to public graphs of the affected assets. However, the sheer volume of addresses and transactions makes qualitative analysis impractical. This is where blockchain data analytics tools come into play, aiming to narrow down the search space by providing a ranking of maliciousness to addresses and transactions.