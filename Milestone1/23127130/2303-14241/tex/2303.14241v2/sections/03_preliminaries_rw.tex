\section{Background and Problem}
\label{sec:prelim}
We discuss preliminaries on blockchain and stablecoins (\S \ref{sec:block}, \S \ref{sec:stable}), followed by one key technique {\textsf AlphaCore} decomposition based on data depth (\S \ref{sec:alpha}). We introduce our problem in \S \ref{sec:prob}.
%
%\vspace{-2mm}
\subsection{Blockchain and Smart Contracts}
\label{sec:block}
A blockchain is an immutable public ledger that records transactions in discrete data structures called blocks. The earliest blockchains are cryptocurrencies such as Bitcoin and Litecoin where a transaction is a transfer of coins.
%
The Ethereum project \citep{wood2014ethereum} was created in July 2015 to provide smart contract functionality on a blockchain. Smart contracts are Turing complete software codes, replicated across a blockchain network, ensuring deterministic code execution and can be verified publicly. 
%
Smart contracts have implemented mechanisms to trade digital assets, known as tokens \citep{victor2019measuring}. Similar to cryptocurrencies, a token is transferred publicly between accounts (addresses), and may have an associated value in fiat currency which is arbitrated by token demand and supply in the real world.

\smallskip 

{\noindent\textbf{Blockchain Transaction Network vs. Mining Network.} In blockchain transaction networks, the nodes represent individual participating addresses within the network, while the edges signify the actual transactions involving transfer of assets between these addresses. On the other hand, in blockchain mining networks, nodes are computational entities that play a crucial role in maintaining blockchain integrity by validating and appending transactions to the ledger through a consensus mechanism. We focus on blockchain transaction networks, where edges are directed and weighted. An edge weight corresponds to the numerical value associated with the edge incident to a node. For instance, in a blockchain token transcation network, the numerical value denotes the amount of token sent from one address
to another.}

%
%\vspace{-2mm}

\subsection{Stablecoins}
\label{sec:stable}
A stablecoin is a smart contract-based asset whose price is protected against volatility by i) collateralizing the stablecoin with one or more offline real-life assets (e.g., USD, gold), ii) using a dual coin, or by iii) employing algorithmic trading mechanisms \citep{moin2019classification,LI2024103747}. 

In the \textit{pegged asset mechanism}, an increase in the price is countered by creating more stablecoins (i.e., coin minting) and selling them to traders at the pegged price. The \textit{dual coin mechanism} operates by having a management coin, referred to as the dual coin, to oversee a stablecoin. The traders of the dual coin participate in decision making through voting and receive benefits from the stablecoin's transactions. In the event that the stablecoin's price rises, some of the dual coin will be sold to purchase and decrease the supply of the stablecoin. Conflicting demand and supply dynamics of the two coins are assumed to stabilize the stablecoin's price.  However, traders may lose faith in the stablecoin to such a degree that they might also not buy the dual coin, however cheap it becomes.
Stablecoins that are based on \textit{algorithmic} trading do not require collateral for stability. They achieve stability through the utilization of a blockchain-based algorithm that adjusts the supply of tokens automatically in response to changes in demand.

{It is worth noting that for an Ethereum token such as the UST {(TerraUSD)} stablecoin, there can be at most $k$ tokens issued within this network, with the value of $k$ being set by the project owner, subject to the condition that it must be $\leq (2^{256}-1)$ (due to Ethereum virtual machine operating on 256 bit words). Furthermore, each of these $k$ tokens can be subdivided into a maximum of $10^{18}$ subunits (an Ethereum protocol specified value). Therefore, the total subunit capacity for a token within the system is $k\times 10^{18}$ subunits.}

 %
%\vspace{-2mm}
\subsection{Data Depth-based Core Decomposition}
\label{sec:alpha}
Core decomposition \citep{Malliaros20} is a central technique used in network science to determine the significance of nodes and to find community structures in a wide range of applications such as biology~\citep{luo2009core}, social networks~\citep{al2017identification}, and visualization~\citep{zhang2012extracting}.
One of the best-known representatives of core decomposition algorithms, graph-$k$-core~\citep{seidman1983network,BatageljZ11}, finds the maximal subgraph where each node has at least $k$ neighbors in that subgraph.
Although the graph-$k$-core algorithm demonstrates high utility for the analysis of graph structural properties, it does not account for important graph information such as the direction of edges, edge weights, and node features.

 
To address these limitations, modifications to graph-$k$-core have been proposed, %to tackle task-specific graphs, 
e.g., graph-$k$-core in weighted and directed graphs, generalized $k$-core \citep{al2017identification,Zhou0HY0021,LiaoLJHXC22,batagelj2002Generalized,Garas_2012,GiatsidisTV11}. Different from them, \\ {\textsf AlphaCore}~\citep{victor2021alphacore} is a recent core decomposition algorithm that combines multiple node properties using the statistical methodology of data depth ~\citep{mosler2012multivariate}. The key idea of data depth is to offer a center-outward ordering of all observations by assigning a numeric score in $(0,1]$ to each data point with respect to its position within a cloud of a multivariate probability distribution. Using such a data depth function designed for directed and weighted graphs, {\textsf AlphaCore} maps a node with multiple features to a single numeric score, while preserving its relative importance with respect to other nodes.   

%As the {\textsf AlphaCore} decomposition unfolds, the data depth values are repeatedly updated through the calculation of node property functions and the application of data depth to the resulting values.

Consider a directed and weighted multigraph, $G(\V,\E,w)$, where $\V$ represents the set of nodes and $\E$ is a multiset of edges. The weight of each edge is designated by the weight function $w : \E \rightarrow \mathbb{R}^+$. In accordance with the generalized core definitions introduced in~\citet{batagelj2002Generalized}, a node property function can assign a real value to each node $v \in \V$, based on edge properties such as weight and node features.  A node $v$ can be represented by its feature vector $\textbf{x}\in \mathbb{R}^d$, where $d$ features have been computed for the node $v$.


\begin{definition}[Mahalanobis depth to the origin (MhDO)]
Let $\textbf{x}\in \mathbb{R}^d$ be an observed data point, then Mahalanobis (MhD) depth of $\textbf{x}$ in respect to a $d$-variate probability distribution $F$ with mean vector $\mu_F \in \mathbb{R}^d$ and covariance matrix $\Sigma_F \in \mathbb{R}^{d\times d}$ is given by
 \begin{equation}
MhDO_F(\textbf{x})=\bigl(1+\textbf{x}^\top\Sigma^{-1}_F\textbf{x}\bigr)^{-1},
 \end{equation}
 $\Sigma_F$ is the covariance matrix of $F$. The Mahalanobis data depth to origin (MhDO) measures the degree of ``outlyingness" of point $\textbf{x}$ (in this context, the node property column vector) in relation to origin $\mathbf{0}$.
 \label{def:mhdo}
 \end{definition}
As the {\textsf AlphaCore} decomposition unfolds, the core value $\alpha$ of a node is established using a data depth threshold $ \epsilon\in [0,1]$ that is applied to remove neighboring high-depth nodes iteratively. Nodes with high property values, such as large edge weights, generally have a low depth, while nodes with low property values often have a high depth, such as most blockchain nodes that trade small amounts of tokens. However, node property values are not the only factor that determines depth; the community structure around the node also plays a role. Nodes are considered to be in the $\alpha = (1-\epsilon)$-core if their depth, relative to themselves, is no more than $\epsilon$.

\smallskip 

\noindent\textbf{Why Data Depth?} Data depth provides a more precise identification of crucial nodes compared to state-of-the-art core decomposition algorithms and acts as a combination of centrality measure and core decomposition~\citep{victor2021alphacore}. Unlike traditional decomposition algorithms, a depth-based decomposition does not require the specification of multiple feature weighting parameters to perform effectively on a particular task. %We provide a running example in the Appendix.  

\begin{figure}
    \centering \includegraphics[width=1\linewidth]{figs/running_example.png}
    \vspace{-3mm}
    \caption{\small A running example to compare between the graph-$k$-core and {\textsf AlphaCore} decomposition methods. The Coreness of nodes according to graph-$k$-core decomposition is shown with different node colors, whereas {\textsf AlphaCore} is run with in-strength and out-strength as node features with a step size of 0.25. Different {\textsf AlphaCore}s are shown using dotted boundaries. \label{fig:running_example}}
    % \vspace{-5mm}
\end{figure}
%
%\vspace{-2mm}

\input{sections/033_aphacore_example}

%Our focus is also on detection rather than prediction, emphasizing the importance of identifying and addressing malicious activities within blockchains. 

%To resolve above problems, we identify nodes in the innermost core, as well as characterize three-node motifs in these innermost cores from our transaction networks.
%In our experiments, we demonstrate that nodes in the innermost core are more useful, compared to other notions of important nodes, in characterizing and predicting the future success of the blockchain assets. 
 

 

 

 