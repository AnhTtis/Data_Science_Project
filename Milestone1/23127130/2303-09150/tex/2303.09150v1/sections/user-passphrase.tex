\section{Understanding Passphrase generation in the wild}
\label{sec:usegen}
Passphrases can be generated by users or by computers (\emph{system-generated}). System-generated passphrases, %
uses an algorithm and generates pseudorandom passphrases based on a training corpus or wordlist. In this section, we will examine different in-use passphrase 
and analyze their properties. 




\subsection{User passphrases}
\label{ssec:userpp}

To examine the class of user passphrases, we need to have a dataset compromising user passphrases. Unfortunately, unlike passwords, where data breaches are not uncommon, %
resulting in public dataets~\cite{fouriq}, there is no public dataset of passphrases available. So, we leverage a simple idea: password leak databases often contain long passwords that could potentially be passphrases without a proper delimiter. Thus we devise a segmentation algorithm to identify passphrases from password leak datasets and construct the first user-chosen, in-use passphrase dataset. %


\paragraph{Identifying user passphrase from leaked password data.} 
We leverage a compilation of prior password data breaches that surfaced in 2018 by 4iQ security firm~\cite{fouriq,pal2019beyond,li2019protocols}. \changed{The leaked dataset contains nearly 1.4~billion email-password pairs and has been used in prior works~\cite{pal2019beyond,sahin2021don,li2019protocols}}.

For our study, we only consider passwords that contain 20 or more ASCII characters (which is roughly 4 words given that the average length of an English word is 4.8~characters~\cite{Norvig}). There were 5.7~million such unique passwords.   Then, we filtered this list by removing passwords that are potentially hash values~\cite{pal2019beyond} --- containing only hexadecimal characters or follows popular hash formats~\cite{hashcat} --- or emails --- containing  `@' symbol in prefix and `.' in suffix and passwords less than nine English letters in them.   %
Then we segment passwords using segmentation algorithms. Segmentation algorithm tries to split the passwords into a sequence of meaningful words. We tried a hybrid segmention approach (combining two segmentation approaches) for segmenting passwords and effectively detecting user-generated passphrases (details in Appendix~\ref{sec:segmenting-pws}).

We found~$\nppws$ unique passphrases using our algorithm. %
The most frequent passphrase was used by 258 users, whereas 99.5\% of passphrases were used by only six or less users. %
We show the top three most used passphrases as well as three randomly sampled passphrases from the ones used by only one user in the top row of~\figref{fig:ex-passphrases}. We inserted `\textsf{-}' marks to show the segmentation. Finally, for checking the coverage of our method, we take 100 random passwords which are more than 20 characters but discarded by our algorithm.  we found 18 passwords that could be considered as passphrases but our algorithm failed to detect them. %
So our passphrase detection algorithm might miss out on passphrases that are heavily modified; but %
by construction, we have zero false-positives. We put more details on our method in Appendix~\ref{sec:inusepassphrase}. We will use these user generated passphrases (we will call it \userpp dataset) to empirically establish the guessability and memorability users achieve when they are choosing the passphrases themselves. \changed{We compared this passphrase dataset with leaked real-world password dataset to check for ecological validity. We found that linguistic properties of our dataset are inline with previous work on passphrases and frequency distribution of the passphrase dataset mirrors that of the original breached password dataset, hinting at ecological validity of our passphrase dataset. Detailed results are in Appendix~\ref{sec:ecolofical_passphrase}. }








\vspace{-1em}

\subsection{System-generated passphrases in use}
\label{ssec:systempp}

We focus on password managers to understand the in-use system-generated passphrase generation algorithms. We surveyed 13 popular password managers, such as LastPass, 1Password, KeePass~\cite{surveyList}. Among these, we found that three password managers provide a passphrases generation functionality: 1Password~\cite{1pass} and Enpass~\cite{enpass} use \dice, whereas Keepass~\cite{keepass} uses a template-based version of \dice (which we call \mmap) as their internal algorithm to generate passphrases for users. 
We describe \dice and \mmap below. %

\vspace{1mm}
\noindent \textbf{\dice .} The most commonly used system passphrase generation algorithm is \dice (called \dice from now on)~\cite{reinholddiceware, shay2012correct}, which relies on randomly choosing words from a dictionary and combining them to make a passphrase until the required length of passphrases is reached. Although \dice is highly secure, users find it very hard to remember the passphrases, i.e., the memorability of the passphrases is very low \cite{shay2012correct}. An in-use approach to improve upon the memorability of \dice passphrases is the \textit{template based \dice}~\cite{mmapCode} or \mmap.

\vspace{1mm}
\noindent \textbf{\mmap .}  This algorithm has a dictionary of English words segregated based on various parts of speech tags and has 27 syntactic templates for the English language, whose components are the tags, embedded within the algorithm \cite{mmapCode}. The idea of using syntactic templates has handled the issue of memorability very well. %
However, this approach has compromised on the security of the passphrases (\secref{ssec:guesseval}) and sacrificed the extensibility to generate arbitrary length strong passphrases as we will see next while evaluating the property of these passphrases. 

\subsection{Properties of in-use passphrases}
\label{ssec:langmodel}

In this section, we first demonstrate one defining characteristic of User passphrase is that it is closer to natural language than system-generated ones. \mmap is somewhat between \dice and \userpp in terms of being close to natural languages. %


\vspace{1mm}
\noindent \textbf{Linguistic properties.} We randomly sampled 3000 passphrases of similar length distribution from each system (dataset for \userpp) and compute their perplexity~\cite{brown-1992-perplexity} using GPT-2 model~\cite{radford2019language}. Lower perplexity indicates closer to natural language text. We noted that \userpp passphrases have a very low perplexity value similar to a natural language corpus, signifying a key reason for their memorability. On the other hand, the passphrases from \mmap is a close second in their resemblance to natural language, almost comparable to user passphrases, which indicates an improvement over the passphrases generated by \dice that performed poorly in this aspect. Details are in Appendix~\ref{sec:perplexity}.






\vspace{1mm}
\noindent \textbf{Issue with \mmap}: Although \mmap improved upon \dice, it comes with a compromise in security. On further investigation, we note two major shortcomings for \mmap. First, \mmap is not scalable as the information required by the system are all internally encoded within the algorithm \cite{mmapCode}. Any extension will potentially require a linguist to create new syntax rules and contextual wordlists (assuming it's possible for large passphrases). 
    Second, and more importantly, the security of the passphrases does not scale well with length. %
    We note that the guess ranks of these passphrases gets saturated around length 8---guess rank of 8-word passphrase is nearly the same as that as of 13-word. The potential reason is the constraint imposed by the underlying hardcoded and extremely limited syntax rule patterns of \mmap (Appendix~\ref{sec:mmap-shortcoming}). %
    

With these insights, we aim to improve the state of the art by balancing security and memorability of the passphrases. To that end, we design a novel constrained Markov Model-based optimization technique in~\secref{ssec:genmodel} for generating passphrases.












