\section{Our Approach}\label{sec:approach}
This section provides an overview of the visual analytics approach and introduces the two employed models.

\subsection{Approach Overview}

Based on the design requirements elaborated in \autoref{sec:domain}, we propose a visual analytics approach (see \autoref{fig:workflow}), which enables users to analyze health insurance records at multiple levels to drill down into the data of interest, locate suspicious fraudulent groups, and find patient-level evidence to verify collusive fraud. Our approach consists of three stages: (1) co-visit network overview, (2) suspicious groups identification, and (3) suspicious patients examination.

\begin{figure*}[ht!]
    \centering % avoid the use of \begin{center}...\end{center} and use \centering instead (more compact)
    \includegraphics[width=2\columnwidth]{figures/fraudauditor-approach-3.pdf}
    \caption{The three-stage approach that can help users identify, examine, and verify suspicious groups of collusive fraud in health insurance.}
    \label{fig:workflow}
\end{figure*}

\textbf{Co-visit network overview.} In the first stage, users seek a general understanding of the data by checking the attribute distributions (\textbf{R1}, \autoref{fig:workflow}-a). According to data distribution and domain knowledge, users then filter patients for analysis (\textbf{R2}, \autoref{fig:workflow}-a). %, which helps to improve audit efficiency and reduce the interference of irrelevant data. 
Next, users check connections between the filtered patients interactively (\textbf{R3}, \autoref{fig:workflow}-b). Collusive behaviors can be disclosed by time gaps of visits or the number of co-visits. Users are supported to specify the definition of complicit behaviors by setting thresholds for time gaps and the co-visits number. 
%This stage provides an overview of patients from multiple perspectives to enable analysts to filter patients by relevant attributes (\textbf{R1, R2}) for group detection.

\textbf{Suspicious groups identification.} In the second stage, our system employs a group mining method (see \autoref{sec:sgm}) to detect complicit groups according to the user-specified definition (\textbf{R4}). %Based on user-constructed connections between patients, a suspicious group detection models that take into account the strength of the connections is used to identify fraudulent groups that have frequent visits in the same place and within short intervals (\textbf{R4}).
Then, our system provides multiple selection strategies to help users locate target groups from the list of detected groups (\textbf{R5}). Feasible strategies are multi-attribute filtering (\autoref{fig:workflow}-c), group comparison, and group ranking (\autoref{fig:workflow}-d). Users can also add neighboring patients or groups to optimize detection results (\autoref{fig:workflow}-e).
% Based on user settings of the auto-detection parameters, such as detecting groups that visit the same medical institution within two-hour interval for more than five times  (\textbf{R3}), \textit{FraudAuditor} then auto-detects and visualizes groups for analysis (\textbf{R4}). \textit{FraudAuditor} visualizes groups in coordinated views to enable examination and analysis of the characteristics of groups, such as attribute distributions on a group level and group similarities (\textbf{R4}).

\textbf{Suspicious patients examination.} In the third stage, our system calculates the similarity of the prescribed diseases and drugs between each pair of patients in a group (see \autoref{sec: dds}). According to the similarity, users can assess the likelihood of collusive fraud (\textbf{R6}, \autoref{fig:workflow}-f). Patients with a low likelihood can be excluded interactively. Next, users can investigate the rest patients by inspecting their visit behaviors at different time granularities (\textbf{R7}, \autoref{fig:workflow}-g). Our system allows users to quickly understand the time periods and frequency of co-visits among them. 
%Our system supports users to investigate patient visit behavior from different time granularity through tailored visit event visualization and to quickly identify the time period and frequency of suspicious behavior through co-visit links.
We also provide contextual information, including disease, drug, and fee, to help users reason and annotate whether the suspicious behavior is collusive fraud (\textbf{R7}, \autoref{fig:workflow}-h).
%  Analysts can select target groups from the group comparison module to explore individual patients. The patient examination module depicts patients' disease and drug similarities and the distribution of other attributes, such as patients' visiting frequencies of various medical institutions, for comparison and analysis (\textbf{R5}). Analysts can select patients of interest to further explore their historical records in a timeline (\textbf{R6}). The timeline provides the individual visiting histories as well as the aggregated visiting histories of all selected patients.
% Additionally, \textit{FraudAuditor} records analysts reasoning process through interaction logs and enables annotation on top of the charts.

\subsection{Suspicious Group Mining}
\label{sec:sgm}
\rc{To detect suspicious groups with spatio-temporal connections and group action characteristics (see \autoref{sec:pro})}, we propose a suspicious group mining method to detect collusive fraud in health insurance (\textbf{R4}). Our method first builds a co-visit network to represent the spatio-temporal relationship among patients. Based on the co-visit network, the method uses a modularity optimization-based community detection algorithm to mine suspicious groups. For clarity of description, we have listed the notations in \autoref{tab:notations}. See Algorithm~\autoref{alg:sgm} for the pseudo-code.

\begin{table}[htb]
  \centering
  \caption{Notation Definitions.}
  \label{tab:notations}
  \small
  \begin{tabular}{p{0.15\linewidth} p{0.75\linewidth}   }
  \toprule
  \textbf{Notation}  & \textbf{Description}  \\ 
  \midrule
      $\mathbf{P}$ & The patients set \\
      $m$ & The number of patients \\
      $\mathbf{V}$ & The visits set \\
      $n$ & The number of visits \\
      $t_i$ & The time of visit $v_i$ \\
      $\theta_1$ & The maximum time gap for a co-visit \\
      $\theta_2$ & The minimum number of co-visits \\
      $\mathbf{CV}(p_i,p_j)$ & The co-visit behaviors between patient $p_i$ and $p_j$\\
      $w(v_i,v_j)$ & The weight of a co-visit about visit $v_i$ and $v_j$ \\
      $w(p_i, p_j)$ & The weight of co-visits between patient $p_i$ and $p_j$ \\
      $\mathbf{W}$ & The weight between patients \\
      $\mathbf{D}$ & The diseases set \\
      $\mathbf{C}$ & The number of visits for each disease in $\mathbf{D}$ \\
      $w(d_i)$ &  The contribution of disease $d_i$ to the similarity of patients $p_i$ and $p_j$ \\
      $c_i$ &  The number of visits of disease $d_i$ \\
      $sim(p_i, p_j)$ &  The similarity of patient $p_i$ and $p_j$ \\
  \bottomrule
  \end{tabular}
\end{table}

\textbf{Co-visit network construction}. Patients in a collusive fraud group frequently visit the same medical institution within relatively short time periods. Considering such a characteristic, we construct a co-visit network $\mathbf{G}$ among patients to summarize the co-visit behaviors and detect collusive fraud. A node in the network represents a patient. An edge between two patients records the co-visit behaviors between the two patients. \rc{If the medical institutions of the two corresponding visits of two patients are the same, and the time gap is less than a threshold $\theta_1$ (the default is 1 hour, which can be adjusted to 6, 12, or 24 hours), it is considered a co-visit.} For patients $p_i$ and $p_j$, their co-visit behaviors are represented as
$\mathbf{CV}(p_i, p_j) = \{(v_{i1}, v_{j1}), \cdots, (v_{is}, v_{js})\}$ and $s$ is the total number of visits they made together. 

\textbf{Edge weight calculation}. The edge weight indicates the likelihood that the two patients belong to the same group. We calculated the weights of the edge $w(p_i, p_j)$ based on the number of co-visits and the visiting time gap. 
% We then build a community detection algorithm based on the weighted network.
As shown in the \autoref{eq:1}, the weight of a co-visit is inversely proportional to the visit time gap. To avoid the impact of occasional visits with a small time gap on the weight, \rc{inspired by the ReLU activation function, we set the cutoff time to 10 minutes based on expert experience, and weights less than that interval are considered to be the same.}
%maximum time gap threshold $\theta_1$ (default as 1 hour). The time gaps less than $\theta_1$ are modified as $\theta_1$.

% \begin{equation} \label{eq:1}
%     w(v_i, v_j) = \frac{1}{max(\theta_1, |t_i - t_j|)}
% \end{equation}

\rc{
\begin{equation} \label{eq:1}
    w(v_i, v_j)=\left\{
    \begin{array}{rcl}
        \frac{1}{max(10 \, \rm minutes, |t_i - t_j|)} &  & {|t_i - t_j| \leq \theta_1} \\
        0                                             &  & {otherwise}
    \end{array} \right.
\end{equation}
}

The edge weight $w(p_i, p_j)$ between two patients is the total of their co-visit weights, defined as \autoref{eq:2}.
An adjustable threshold $\theta_2$ (default as 4) for the minimum number of co-visits is set here to avoid random factors. The co-visit weight being less than the threshold indicates the low probability of both belonging to the same group.

\begin{equation} \label{eq:2}
    w(p_i, p_j)=\left\{
    \begin{array}{rcl}
        \sum_{z=1}^{|\mathbf{CV}(p_i, p_j)|} w(v_{iz}, v_{jz}) &  & {|\mathbf{CV}(p_i, p_j)| \geq \theta_2} \\
        0                                             &  & {otherwise}
    \end{array} \right.
\end{equation}

\textbf{Community detection}. \rc{In order to mine suspicious groups from the co-visit network, we use Louvain~\cite{blondel2008fast}, an community detection algorithm based on modularity optimization. The algorithm is applicable to weighted graphs and supports the exclusion of non-community nodes, which can yield clear detection results since most patients in the healthcare scenario are normal.}
%Not all community detection algorithms can be applied to weighted graphs. For example, the Newman-Girvan algorithm~\cite{girvan2002community} based on the betweenness centrality does not consider edge weights. Thus, it is not applicable in the health insurance scenario, where fraudulent groups are rare, and most of the patients are normal. After the survey and experiments, we choose the Louvain algorithm~\cite{blondel2008fast} based on modularity optimization, which supports weighted graphs and can exclude communities with smaller granularity, which makes the detection results clearer.


\begin{algorithm}[]
    \caption{Suspicious Group Mining}
    \small
    \label{alg:sgm}
    {{
                \begin{algorithmic}[1]
                    \Require
                    $\mathbf{P}$: the patient set;
                    $\mathbf{V}$: the visit records;
                    $\mathbf{W}$: the weight between patients;
                    $\theta_1$: the maximum time gap;
                    $\theta_2$: the minimum co-visit times.
                    \Ensure
                    $\mathbf{G}$: the co-visit network;
                    $\mathbf{SG}$: the suspicious groups.
                    \State $\mathbf{CV} \gets$ extract co-visit behavior from $\mathbf{V}$
                    \State $\mathbf{W} \gets \mathbf{0}$
                    \For{each patient pair $(p_i, p_j)$}
                    \State $w(p_i, p_j) \gets 0$
                    \If {$|\mathbf{CV}(p_i, p_j)| \geq \theta_2$}
                    \For{each co-visit ($v_{ik}, v_{jk}$) in $\mathbf{CV}(p_i, p_j)$}
                    \State $w(v_{ik}, v_{jk}) = \mathbbm{1}(|t_i - t_j| \le \theta_1)\frac{1}{max(10 \, \rm minutes, |t_i - t_j|)}$
                    \State $w(p_i, p_j) \mathrel{+}= w(v_{ik}, v_{jk})$
                    \EndFor
                    \EndIf
                    \EndFor
                    \State $\mathbf{G} \gets (\mathbf{P}, \mathbf{CV}, \mathbf{W})$
                    \State $\mathbf{SG} \gets \Call{cdlib.algorithms.louvain}{\mathbf{G}, \mathbf{W}}$ %// \textit{Calculates the community using louvain algorithm.}
                    \State \Return {$\mathbf{G}, \mathbf{SG}$}
                \end{algorithmic}}}
\end{algorithm}

\subsection{Disease and Drug Similarity} \label{sec: dds}

To verify collusive fraud groups, we need to calculate the similarity among patients based on their prescribed diseases and corresponding drugs (\textbf{R6}). At first, we tried to calculate the similarity according to the string texts of diseases and drugs, but the results were not satisfactory. For example, such a calculation would lead to the headache being similar to the stomachache and not similar to the stroke, when in fact both headaches and strokes are brain disorders with a closer relationship. Later, we found that either diseases or drugs have hierarchical encoding, which can reflect the similarity information. The ICD10~\footnote{\url{https://en.wikipedia.org/wiki/ICD-10}} coding of diseases and the standard coding of drugs~\footnote{\url{https://code.nhsa.gov.cn/toDetail.html?infoId=5546&CatalogId=2}} encode diseases and drugs hierarchically by large, medium, and small class.
For example, diseases J11 (influenza) and J18 (pneumonia) are similar, but they are very different from M54 (back pain).

Hence, we propose a nearest-match-based similarity calculation method that considers the disease/drug codes and the number of visits for the corresponding diseases. For each disease/drug, we need to find the most similar one in another \rc{patient's disease/drug set, so it is not affected by the specific order of visits}. Assume that a patient has been prescribed several diseases $\mathbf{D} = \{d_1, d_2, \cdots, d_l \}$. The corresponding numbers of visits for each disease are $\mathbf{C} = \{c_1, c_2, \cdots, c_l\}$. 
%To calculate disease similarity between two patients $p_i$ and $p_j$, we first grouped the diseases of the two patients according to the first letter of the disease codes $\mathbf{D}=\{\mathbf{D_a}, \mathbf{D_b}, \cdots, \mathbf{D_z} \}$.

As is shown in \autoref{fig:algorithm}, from the first letter of $p_i$'s and $p_j$'s diseases, we can see that both of them have been treated for diseases beginning with ``K''. However, $p_i$'s E10 (i.e., Type 1 diabetes), and $p_j$'s M54 (i.e., back pain) are not shared with each other. Thus, E10 and M54 contribute no disease similarity. Next, according to the code of the second letter, the disease set beginning with K can be divided into three medium-class sets: K0, K1, and K2. The K02 disease of $p_j$ does not correspond to the remained diseases of $p_i$, while the remaining diseases are further calculated according to the letters of the third letter until the diseases of the two patients in the set are exactly the same. The closer the two diseases are, the greater their contribution to the calculation of similarity. Therefore, the weight of each disease is determined by the longest prefix of the set in which it last stays, having

\begin{equation}
    w(d_i)= \frac{\text{the length of the prefix letter}}{\text{the total length of the coded letter}}.
\end{equation}

\begin{figure}[h]
    \centering % avoid the use of \begin{center}...\end{center} and use \centering instead (more compact)
    % width=0.5\textwidth
    \includegraphics[width=\columnwidth]{figures/algorithm-v2.pdf}
    \caption{An example of disease weight calculation.}
    \label{fig:algorithm}
\end{figure}

For example, the weight of disease K02 is 1/3$\approx$0.33, K12 is 2/3$\approx$0.66, and K13 is 1.00. The same goes for drugs. The number of medical visits for diseases/drugs also reflects their similarity. The similarity between two patients is calculated as follows:

\rc{
\begin{equation}
    sim(p_i, p_j) = \dfrac{\sum w(d_k^{p_i}) \cdot c_k^{p_i} + \sum w(d_k^{p_j}) \cdot c_k^{p_j}}{\sum c_k^{p_i} + \sum c_k^{p_j}}.
\end{equation}
}

%We use the hierarchical clustering method to sort the patients by their similarities in the matrix.

% First, we calculated the distance matrix between patients $dist(p_i, p_j) = 1-sim (p_i, p_j)$.
% To generate patient clusters, we first treated each patient as a cluster. The distance between two clusters was defined as the maximum distance between two patients from the two clusters. The method merges the two clusters closest to each other iteratively until one cluster remains.
% By setting the distance threshold(in practice, we set it to half of the maximum distance), we could get various numbers of clusters and the patient numbers of each cluster, and rearrange the order of patients in the matrix accordingly.

% 先注释掉伪代码
\begin{comment}
The algorithm pseudocode is as follows:

\begin{algorithm}[]
    \caption{Disease and Drug Similarity}
    \small
    \label{alg:ddsm}
    {{
                \begin{algorithmic}[1]
                    \Require
                    % $D$ and $C$ for two patients $p_1$ and $p_2$
                    $D_{p_1}, D_{p_2}$: the disease set for two patients;
                    $C$: the number of visits for each disease.
                    \Ensure
                    $sim$: similarity between two patients $p_1$ and $p_2$.
                    \State $sim \gets 0$
                    \State $s \gets 0$
                    \For{each disease $d_i$ in $D_{p_1}$($D_{p_2}$)}
                    \State $d_j \gets$ the most similar disease in $D_{p_2}$($D_{p_1}$)
                    \State $w(d_i) \gets$ the weight of $d_i$ // \textit{Based on the calculation described above, consider the longest prefixes of $d_i$ and $d_j$.}
                    \State $sim \gets sim + w(d_i) * c_i$
                    \State $sim \gets s + c_i$
                    \EndFor
                    \State $sim \gets \dfrac{sim}{s}$
                    \State \Return{$sim$}
                \end{algorithmic}}}
\end{algorithm}
\end{comment}