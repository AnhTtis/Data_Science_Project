\section{Deferred Proofs}
\label{sec:appendix}

\setcounter{lemma}{6}
\begin{lemma}
    \label{lem:invariantLinkNoGenAppendix}
    If $P1$--$P5$ hold in step $t$, and a tile is placed at some $\lp_i \in \links$ with $\lp_{i} \notin \gen$, then $P1$--$P5$ hold in step $t^{+}$.
\end{lemma}

\begin{proof}
    There are two cases: (1) the agent enters \coat{} at $\lp_{i+2}$ and moves $\rhr{}$ twice, i.e., $\lp_{i+1} \in \links \cap \gen$, or (2) it enters \coat{} at $\lp_{i+1}$.
    In case (1), $\lp_i$ consumes $\lp_{i+1}$ by \cref{cor:generatorSize}, as $\lp_{i}$ must be contained in a connected component of $\be(\lp_{i+1})$ of size one.
    In both cases $\lp_i \notin \lp^+$ since it is occupied in step $t^+$.
    Together with \cref{lem:enterCoat}, it follows that only the last link of $\lp$ (and second last link in case (1)) is consumed and no link is generated.
    This implies that $P1$--$P4$ hold in step $t^+$, since the sub-path of $\lp$ from $\start$ to $\lp_{i-1}$ does not change from step $t$ to $t^+$.

    If the connected component $\be(\lp_i,\lp_{i-1})$ of $\tri(\be(\lp_{i}))$ that contains $\lp_{i-1}$ has size one, then $\lp_i$ consumes $\lp_{i-1}$ by $P4$ such that $\suc^+(\lp_{i-1}) = \lp_{i-1}$ and $P5$ holds.
    Otherwise, for any $\lp_j \in \be(\lp_i,\lp_{i-1})$ with $j \neq i-1$ it holds that $j > i$ by $P3$, and thereby $\lp_j \notin \links$ by $P1$.
    Together with the lemma's assumption $\lp_i \notin \gen$ follows that $\lp_j \notin \links^+$, especially $\suc(\lp_i^+) \notin \links$.
    Hence, $P5$ holds in step $t^+$.
    \qed
\end{proof}


\begin{figure}[!b]
    \centering
    \begin{minipage}[t][][b]{.63\textwidth}
        \begin{subfigure}[c]{0.5\linewidth}
            \includegraphics[width=\linewidth]{invariantGen}
            \subcaption{step $t$}
            \label{fig:invariantGen1}
        \end{subfigure}%
        \begin{subfigure}[c]{0.5\linewidth}
            \includegraphics[width=\linewidth]{invariantGen2}
            \subcaption{step $t^+$}
            \label{fig:invariantGen2}
        \end{subfigure}
        \captionof{figure}{Local configuration in the proof of \cref{lem:invariantGenAppendix}. Note that while $\lp_{i-1}$ is depicted as a link (circular, red), it may be the node $\start{}$ instead.}
        \label{fig:coatingLayerGraphasd}
    \end{minipage}%
    \hfill
    \begin{minipage}[t][][b]{.315\textwidth}
        \centering
        \captionsetup[subfigure]{labelformat=empty}
        \begin{subfigure}[c]{\linewidth}
            \includegraphics[width=\linewidth]{invariantGen3}
            \subcaption{}
            \label{fig:invariantGen3}
        \end{subfigure}
        \captionof{figure}{Local configuration after a tile is placed at $u_1$ with $\noCheck = true$.}
        \label{fig:boundaryasd}
    \end{minipage}
\end{figure}

\setcounter{lemma}{7}
\begin{lemma}
    \label{lem:invariantGenAppendix}
    If $P1$--$P5$ hold in step $t$, and a tile is placed at some $\lp_i \in \links \cap \gen$ with $\lp_{i-1} \in \links \cup \{\start{}\}$, then $P1$--$P5$ hold in step $t^{+}$.
\end{lemma}


\begin{proof}
    Since a tile is placed at a generator, by \cref{lem:enterCoat} the agent enters phase \coat{} at $\lp_{i+2}$ such that $\lp_{i+1}, \lp_i \in \links \cap \gen$.
    It follows that the neighborhood of $\lp_i$ and $\lp_{i+1}$ is the same as depicted in \cref{fig:noCheck1}.
    However, since $\lp_{i-1} \in \links \cup \{\start{}\}$, the neighborhood of $\anchor(\lp_i)$ differs.
    If $\anchor(\lp_i)$ has only one occupied neighbor, then the proof reduces to the proof of \cref{lem:invariantNoCheck} except that $\noCheck$ is not set to $true$ and $P2$ holds directly in step $t^+$.
    Therefore, we must only consider the case $|\bo(\anchor(\lp_i))| = 2$ which is precisely depicted in \cref{fig:invariantGen1} apart from rotation.
    %\cref{fig:noCheck} precisely depicts the neighborhoods of $\anchor(\lp_i), \lp_{i}$ and $\lp_{i+1}$ in that case.

    First, assume that $\lp_{i-1} = \start{}$.
    By \cref{lem:enterCoat}, $\lp_{i+2}$ is the first node $v \in \lp$ with $v\notin \links \cup \{\start{}\}$.
    Hence, $\lp_i$ and $\lp_{i+1}$ are the only existing links.
    Let $v$ be the node generated by $\lp_i$ and $w$ the node in $\be(\lp_i)$ that is not $\lp_{i+1}, \lp_i-1$ or $v$.
    As can be seen in \cref{fig:invariantGen1}, $\lp_i$ consumes $\lp_{i+1}$, it generates $v$, and by \cref{lem:generatorSharedOccupied} cannot generate $w$.
    Then in step $t^+$ (see \ref{fig:invariantGen2}), $\lp^+$ is given by $\lp^+ = (\start{},v,w,...)$ with $\links^+ = \{v\}$ and $\suc(w) = w \notin \links^+$ such that $P1$--$P5$ hold.
    
    Second, assume that $\lp_{i-1} \neq \start{}$, i.e., by the lemma's assumption $\lp_{i-1} \in \links$.
    Note that $\be(\lp_{i-1})$ and $\bo(\lp_{i-1})$ both contain a connected component of size at least two.
    Since $\lp_{i-1}$ is empty, it holds that $|B(\lp_{i-1})| \leq 6$, and since $\lp_{i-1}$ is a link, $\be(\lp_{i-1})$ and $\bo(\lp_{i-1})$ must each contain another component of size one.
    Especially, $\bo(\lp_{i-1})$ contains no connected component of size larger than two.
    
    In the proof of \cref{lem:invariantNoCheck}, we showed that apart from rotation there is only one local configuration in which a tile is placed with $\noCheck = true$.
    For ease of reference, the configuration after the tile is placed is depicted in \cref{fig:invariantGen3} with new labeling on the nodes.
    Let $u_1$ be the node at which a tile is placed with $\noCheck = true$ in that case, and $u_2$ the node from which the agent moves to $u_1$ before placing the tile.
    As can be seen in \cref{fig:invariantGen3}, $\bo(u_2)$ contains a connected component of size at least three.
    By contraposition, $\anchor(\lp_i)$ must have been placed with $\noCheck = false$ since we showed that $\bo(\lp_{i-1})$ cannot contains a connected component of size larger than two.
    In that case, the proof again reduces to the proof of \cref{lem:invariantNoCheck} as described above.
    \qed
\end{proof}


\setcounter{lemma}{9}
\begin{lemma}
    \label{lem:emulationAppendix}
    A finite-state agent can emulate \cref{alg:algorithm} on $\tri^*$ in $\O(\Delta^2n^2)$ steps while moving and placing tiles of at most $2^{2\Delta}$ types on $\tri$.
\end{lemma}

\begin{proof}
    Let $F^* \subset L^*$ be the set of virtual nodes $v^*_f$ that correspond to some face $f$ of $\tri$ in the construction of $\tri^*$.
    Since $\tri^*(L^* \setminus F^*)$ is a subdivision of $\tri$, it can be embedded in the same 3D surface as $\tri$ using vectors that are collinear to vectors in the embedding of $\tri$.
    Thereby, we can use the same fixed order on vectors from the construction of $\tri^*$ that is represented by $\pi$.

    In the following, we define for each node $u \in L$ a bit-sequence $x(u) = (x_1,...,x_{2\Delta})$ that encodes the occupation of all nodes $v^* \in L^*$ with $\mathcal{R}(v^*) = u$, where a $0$ encodes an empty, and a $1$ encodes an occupied virtual node.
    By the construction of $\tri^*$, there are at most $2 \Delta$ nodes $v^*$ with $\mathcal{R}(v^*) = u$ such that $2 \Delta$ bits suffice.
    The order of bits in $x(u)$ is uniquely given by $\pi$ where the first $\Delta$ bits encode virtual nodes that correspond to edges of $\tri$, and the following bits encode virtual nodes that correspond to faces of $\tri$.
    There is no bit for the virtual node $v^*_u \in L^*$ since it is initially occupied and remains occupied until termination by following \cref{alg:algorithm}.
    In fact, $\mathcal{R}$ is undefined for $v^*_u \in L^*$.

    Consider an agent $r$ on $\tri$ that utilizes $k = 2^{2\Delta}$ types of passive tiles.
    Each tile type uniquely describes a bit-sequence of length $\log(k) = 2\Delta$ such that $r$ emulates an agent $r^*$ on $\tri^*$ with initial configuration $C^{0*}$ as follows:
    If $r^*$ moves from $v^*$ to $w^*$, then $r$ moves from $\mathcal{R}(v^*)$ to $\mathcal{R}(w^*)$ (if $\mathcal{R}(v^*) \neq \mathcal{R}(w^*)$).
    If $r^*$ places a tile at $v^*$ and $\mathcal{R}(v^*)$ is empty, then $r$ places a tile at $\mathcal{R}(v^*)$ that corresponds to the bit-sequence $x$ in which only $v^*$ is encoded as occupied, otherwise $r$ incorporates the occupation of $v^*$ by changing the tile type.
    If $r^*$ gathers material and $r$ carries no material, then $r$ also gathers material.

    By \cref{thm:algorithm} and \cref{lem:virtualGraph}, $r^*$ solves the coating problem on $\tri^*$.
    Since $\mathcal{R}$ is surjective and any node $\mathcal{R}(v^*) \in L$ is occupied, if $v^*\in L^*$ is occupied, the emulation solves the coating problem on $\tri$ in $\O(|L^*|^2) = \O(\Delta n)$ steps.
    \qed
\end{proof}