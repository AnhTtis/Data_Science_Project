
Software bills of materials (SBOM) hold the promise of becoming the backbone of reliability and security analyses for software supply chains. But what are the challenges and opportunities for engineering SBOMs? In this paper, we deep-dive into the production of SBOMs for Java applications and
study how 6 tools perform on producing SBOMs for complex open source projects.
Our novel study consolidates the foundations of SBOM concepts and reveals  key open challenges for the accurate production and usage of software bills of materials.




In the context of highly sensitive environments, like military, the software development is carried out with security as the top-most priority. These environments also disable internet connectivity to emulate a close-world ecosystem in order to prevent any kind of external interference. Formally, this practice is called air-gapped software builds. An SBOM with information not only about dependencies, but also about the external tools can be useful to implement such practices.





When protecting a software application from potential cyber attacks, security engineers need to consider a number of risks and threats.
The large number of software components being reused in an application has turned into a major threat in recent years \cite{gkortzis2021software}.
This is not surprising as modern software development involves implementing a majority of features by incorporating third-party components via so-called package managers (e.g., Maven in Java, NPM in Javascript).
The phenomenon of critically relying on external software suppliers has been dubbed the software supply chain problem \cite{cox2019surviving}. It is both a security and a reliability problem.
On the one hand, malicious actors can infect a target application from within a reused component \cite{ladisa2022taxonomy}. On the other hand, entire software systems may crash because of a bug somewhere deep in the software supply chain \cite{rezk2021ghost}.











\paragraph{External References}
The CycloneDX specification provides a way to document metadata information about the software under analysis.
It outlines 16 types of external references that may be included.
For example, an SBOM could provide information about the \texttt{issue-tracker}, \texttt{chat}, or \texttt{build-system} of a component. \cyclonedxmavenplugin fetches website, build-system, distribution, issue-tracker, mailing-list, and vcs if available from maven.
This information is extracted from the maven build.

\todo{why is that useful? \cdxgen and \depscan only fetch 1 external reference that is of type other for the study subject only.} 

We note that the version control system and the issue tracker information is essential because it helps to trace the provenance of bugs and vulnerabilities. To that extent, \todo{XXXX is better but can be improved by doing YYYYY}



% already said
From \autoref{fig:sbomProducerResults} we observe that the precision and recall of transitive dependencies for \jbom is low.
In \autoref{tab:sbom-tools} we mentioned that dependency hierarchy information is not preserved. 
This is because relationships are specified by unique identifiers of the dependency, and version is required to create such an identifier. Yet, \jbom fails at resolving the correct versions for the dependencies.
For example, \jbom reports \texttt{org.apache.maven.plugin-testing:\linebreak[4]maven-plugin-testing-harness:3.3.0} as a false positive direct dependency among many others.
However, this is one of the transitive dependencies of \texttt{spoon}. 
This reduces the precision and recall for transitive dependencies.

Another anomaly that we observed was in the resolution of \texttt{com.infradna.tool:\linebreak[4]bridge-method-annotation} by \jbom for \texttt{spoon}. It resolves two versions of this dependency, and both of them are ambiguous. First, the version is wrong because the tool fails to resolve maven properties. Second, the version is called \texttt{annotation/pom}, which is not a valid version for this dependency. On further investigation, we notice that this version has been fetched after scanning a jar file which contains a pom file inside META-INF even though the jar file belongs to test resources of the study subject.

% \openrewrite reports a false positive transitive dependency called \texttt{javax.enterprise:\linebreak[4]cdi-api:1.2}. However, a more in-depth look revealed that this dependency is indeed a transitive dependency of \texttt{INRIA/spoon}. We could not find reasons for why ground truth would ignore this dependency.

On the opposite end of the graph is \buildinfogo. It performs the best among all producers. However, the producer fails to perform as well on some study subjects because it does not fetch the test scoped dependencies. Moreover, \buildinfogo also misses a compile scoped direct dependency \texttt{com.github.javaparser:\linebreak[4]javaparser-symbol-solver-core} in \texttt{javaparser}. This direct dependency is part of a module in the project which is not published on maven central, and hence \buildinfogo cannot fetch its dependencies.

The first extreme case is of \jbom. We noticed earlier that it misses all the transitive dependencies. However, for study subject \texttt{tika}, it detects transitive dependencies with 20.83\% precision and 1.53\% recall. This is because some dependencies in this list are also direct dependency to \texttt{tika} itself.

% what's the most meaningful choice?

% what's the impact on producer difficulty?

- significant regarding the production of SBOMs
- information varies 
- before the build phase -> there is not much information about comiled files
- after -> lot of information is lost as deblaodting shading
- good timing
- information is absent so is it a bug or just that

\todo{paragraph unclear: what's the main takeaway}These different steps are significant regarding the production of SBOMs, since the information about the software supply chain varies at these different stages. For example, the Maven build resolves dependencies and removes duplicates, hence the list of dependencies  is different before or after the build. Outside the build, there is little information about what tools are used to test, compile, package. Consequently, a producer that focuses only on source code cannot include these external tools in the SBOM.

% TODO ground and reorder with examples from the result section
To be of practical value, SBOMs should be produced at different build lifecycle stages: from the verification and compilation of the original sources at the first stages of development process to the deployment of the final software artifact.
SBOMs should be dynamically enriched and updated as the software evolves~\cite{xia2023}.
However, ensuring the integrity of the SBOMs along this process is specially challenging if the code is modified during the build process. 
Code analysis techniques used at build time to generate or remove code at different stages could break the SBOM dependency-integrity checking (e.g., when dynamically generating Java class files or debloating dependencies~\cite{depclean}).
Therefore, SBOMs generation should specify at which stage of the software development each component is checked, whether it has been used for its development, build or distribution.
For example, test scoped dependencies are not deployed in the bundled package but are necessary for the early stage of the build and are indeed significant from a security standpoint. 
These dependencies, as well as any upstream component that participates in software development, build or distribution is considered to be of security relevance and therefore be part of the SBOMs. 


In contrast to other approaches measuring the quality of SBOMs like SBOM-Benchmark\footnote{\url{https://sbombenchmark.dev/\#sbom-benchmarked}} we focus on the correctness and completeness of the dependency tree.
SBOM benchmark focuses on the quality of the correctness of the format.
They check if the SBOM has the correct format, required fields, and the fields like licenses are in the correct SPDX format.
This work differs from ours, as they do not check the correctness of the dependencies contained in the SBOM.
