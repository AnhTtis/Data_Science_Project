%https://www.computer.org/digital-library/magazines/sp/cfp-secure-supply-chain
%https://en.wikipedia.org/wiki/Closing_credits
\documentclass{IEEEcsmag}
% \usepackage[colorlinks,urlcolor=blue,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage[]{hyperref}
\usepackage{listings}
\expandafter\def\expandafter\UrlBreaks\expandafter{\UrlBreaks\do\/\do\*\do\-\do\~\do\'\do\"\do\-}
\usepackage{booktabs}
\usepackage{numprint}
\npstyleenglish  % To ensure decimal separators etc are in the standard format for english text

\usepackage{multirow}
\usepackage{xspace}
\usepackage[frozencache,cachedir=minted-output-user]{minted}
\usepackage{pifont}
\usepackage{bera}% optional: just to have a nice mono-spaced font
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{makecell}
\tikzset{
    cross/.pic = {
    \draw[rotate = 45] (-#1,0) -- (#1,0);
    \draw[rotate = 45] (0,-#1) -- (0, #1);
    }
}
\usemintedstyle{vs}
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\DeclareRobustCommand\redDot{\tikz \fill[red] (1ex,1ex) circle (0.5ex);}
\DeclareRobustCommand\blueDot{\tikz    \draw (0.25,.25) pic[blue] {cross=2pt};}
% \newcommand{\TODO}[1]{\textcolor{red}{#1}\GenericWarning{}{LaTeX Warning: TODO: #1}}\newcommand\todo\TODO
\usepackage{silence}
\WarningFilter{xcolor}{Incompatible color definition}
% This is a hack to keep the warnings readable dont copy this blindly.
\providecommand*{\listingautorefname}{Listing}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\setcounter{secnumdepth}{6}

% SBOM producers
\newcommand{\cyclonedxmavenplugin}{\texttt{CycloneDX-Maven-Plugin}\xspace}
\newcommand{\cdxgen}{\texttt{CycloneDX-Generator}\xspace}
\newcommand{\jbom}{\texttt{jbom}\xspace}
\newcommand{\buildinfogo}{\texttt{Build-Info-Go}\xspace}
\newcommand{\depscan}{\texttt{Depscan}\xspace}
\newcommand{\openrewrite}{\texttt{OpenRewrite}\xspace}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}


\jvol{XX}
\jnum{XX}
\paper{8}
\jmonth{March}
\jname{   }
\jtitle{  }
\pubyear{2023}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}


\setcounter{secnumdepth}{0}

\begin{document}

\sptitle{}

\title{Challenges of Producing Software Bill Of Materials for Java}

%\title{A Comprehensive Study Into Software Bill Of Materials in the Java Ecosystem}

\author{Musard Balliu,
Benoit Baudry,
Sofia Bobadilla,
Mathias Ekstedt,
Martin Monperrus,
Javier Ron,
Aman Sharma,
Gabriel Skoglund,
CÃ©sar Soto-Valero,
Martin Wittlinger}
\affil{  }

\markboth{ }{  }

\begin{abstract}\looseness-1
Software bills of materials (SBOM) promise to become the backbone of software supply chain hardening. We deep-dive into 6 tools and the accuracy of the SBOMs they produce for complex open-source Java projects. Our novel insights reveal some hard challenges for the accurate production and usage of SBOMs.

\end{abstract}

\maketitle


\section{Introduction}

% security and reuse

Modern software development involves implementing a majority of features by incorporating third-party components via so-called package managers (e.g., Maven in Java, NPM in Javascript).
As a consequence, software applications are  composed of hundreds of third-party dependencies, which form their software supply chain  \cite{cox2019surviving}. 
The large number of dependencies in an application has turned into a major challenge for both security and reliability \cite{gkortzis2021software}.
On the one hand, malicious actors can infect a target application from within a reused component \cite{ladisa2022taxonomy}. On the other hand, entire software systems may crash because of a bug somewhere deep in the software supply chain \cite{rezk2021ghost}.


% intro SBOM
The Software Bill of Materials (SBOM) has recently emerged as a key building block to enable principled engineering of software supply chains. This takes the well-known concept of `bill of materials' for manufacturing physical goods into the digital world.
An SBOM primarily aims at precisely capturing the whole list of  dependencies that make up the software supply chain of an application. 

% SBOM and security
Accurate SBOM is essential for software supply chain management \cite{harutyunyan2020managing}, vulnerability tracking, detection of build tampering \cite{nikitin2017chainiac}, and in general, high software integrity. 
Software developers can leverage the SBOM to identify vulnerable software components in a timely manner.  This is usually done by matching software component versions against vulnerability databases and reporting a warning whenever a vulnerable component is part of an application.
For example, in 2021, a serious vulnerability present in the popular Java logging component Log4J was discovered.
This component was extensively used by many open-source projects, and consequently this vulnerability impacted a great proportion of the Java ecosystem~\cite{log4j}.
Had all open-source Java projects published an SBOM, it would have been easy to precisely identify the vulnerable applications.

% problem statement / dificulties of SBOMs
The software supply chain of modern applications includes hundreds of components, and manually producing SBOMs is not a viable option. 
Yet, the full automation of SBOM production is a process which poses several challenges \cite{sbom_formats}.
First, the SBOM must elicit all direct dependencies, which are explicitly declared by the application's developers in a build configuration file, as well as the transitive dependencies that come from the transitive closure of dependencies.
Tracking down every single dependency that is being used is hard because of large composite architectures, and package managers that support sophisticated resolution mechanisms.
Tracking down the exact version of a binary dependency in an SBOM is even harder as this requires the mapping of binary components to source code repositories. 
Second, while package managers can build a comprehensive list of all dependencies, SBOMs are meant to include  extra information about the software supply chain, such as checksums for all dependencies and data about third-party tools used in the build. Finally, the SBOM aims at being both human readable for auditing and legal cases, as well as being machine readable for automatic verification. 
These challenges open an exciting area for research and innovation, as witnessed by the recent emergence of many SBOM tools  supported by diverse open-source communities, start-ups, and big tech companies alike.
From a research perspective, there is a crucial need for laying down systematic foundations of what SBOMs are, and the challenges related to their engineering.



% SBOM in Java
This article presents an in-depth study of SBOM producers in the Java ecosystem. 
Our focus on Java is motivated as follows. 
First, it is one of the top-3 languages in the world by most notable metrics. Second, its very mature ecosystem of third-party dependencies, mainly through Maven, is critical in government services, financial services \cite{SotoValeroMB22}, medical infrastructure and enterprise software systems \cite{MassacciP21}.
Third, SBOM production is intrinsically related to programming language specifics, as it must capture each and every aspect of dependency resolution, compilation, linking, and packaging, all being unique for a given software stack.


%https://duckduckgo.com/?t=ffab&q=snyk+redhat&atb=v45-1&ia=web


% contributions
For our study, we create a curated selection of 6 mature and actively maintained SBOM producers. We execute each producer on a set of 26 mature and active open-source Java projects.
We observe significant variations in the quality of SBOMs generated by these SBOM producers. All of them capture a different set of dependencies for the same project, and most of them miss a large part of the transitive dependency tree. Based on further manual analysis, we illuminate urgent challenges and opportunities to consolidate the state-of-the-art of SBOM production, in order to support thorough security and reliability analyses for software supply chains.

\section{Software Bill of Materials}

\begin{figure*}
    \centering    \centerline{\includegraphics[width=\textwidth]{img/fig1.pdf}}
    \caption{Overview of 
    the methodology to study CycloneDX SBOM production for Java.}
    \label{fig:THEfigure}
\end{figure*}

% Terminology
% - component: We keep this one
% - dependency
% - package: we never use package and we use "component" instead \todo{aman}
% - library: we remove either "dependency" of "third-party component"
% add correct writing of cycloneDX everywhere in the paper
% tool -> producer
% We use component and dependencies ONLY
\subsection{SBOM Standards}

\begin{listing}
\begin{minted}[autogobble,
               frame=single,
               framesep=2mm,
               linenos=false,
               xleftmargin=0pt,
               tabsize=1,
               fontsize=\scriptsize,
               breaklines,
               breakanywhere]{json}
{ "bomFormat" : "CycloneDX",
  "specVersion" : "1.4",
  "metadata" : { 
    "timestamp" : "2023-02-20T16:14:42Z",
    "tools" : [
      { "name" : "CycloneDX Maven plugin",
        "version" : "2.7.5" }
    ],
    "component" : {
      "group" : "org.asynchttpclient",
      "name" : "async-http-client-project",
      "version" : "2.12.3",
      "hashes" : [ { "alg" : "SHA-512",
          "content" : "e5435852...7b3e6173"}, ... ]
      "licenses" : [...],
      "externalReferences" : [ {
        "url" : "http://github.com/AsyncHttpClient/async-http-client" }
      ],
      "bom-ref" : "pkg:maven/org.asynchttpclient/async-http-client-project@2.12.3?type=pom"
    }
  },
  "components" : [
    { "group" : "com.sun.activation",
      "name" : "jakarta.activation",
      "version" : "1.2.2",
      "bom-ref" : "pkg:maven/com.sun.activation/jakarta.activation@1.2.2?type=jar"
    } ...
  ],
  "dependencies" : [ {
      "ref" : "pkg:maven/org.asynchttpclient/async-http-client-project@2.12.3?type=pom",
      "dependsOn" : [
        "pkg:maven/com.sun.activation/jakarta.activation@1.2.2?type=jar"
        ....
      ]
    } ... ] }
\end{minted}
\caption{Excerpt of a CycloneDX SBOM for the Java project \texttt{async-http-client}.}
\label{lst:spec}
\end{listing}


In 2021, the United States National Telecommunications and Information Administration~(NTIA) set out to identify a minimal set of requirements for SBOMs~\cite{NTIA21}. These requirements outline which data fields should be present, how SBOMs should support automation and which practices and processes should be employed when creating, distributing, and using SBOMs. 
The NTIA concluded that three existing formats meet the requirements: CycloneDX, Software Package Data Exchange (SPDX), and Software Identification (SWID) tags.

CycloneDX aims to be a standard for bills of materials for both software, hardware, software as a service, and operations. It has a strong security focus, originating from the Open Worldwide Application Security Project (OWASP).
SPDX is a data exchange format for information about the contents of software components, initially created  to support tracking and managing of open-source licenses, but later expanded to cover dependency relations and vulnerabilities. SWID tags are designed to accompany a software product through its life cycle, providing unique identification and metadata. 

In this paper, we focus on the most notable standard in this area: CycloneDX. It is the latest standard for SBOMs and is explicitly designed to provide a bill of materials, whereas SPDX and SWID were initially created to solve other issues relating to software licensing and distribution, and have only subsequently been repurposed as SBOMs~\cite{sbom_formats}.

\autoref{lst:spec} shows an excerpt of a CycloneDX SBOM for the Java component \texttt{async-http-client}. This particular example contains three root elements -- \texttt{metadata}, \texttt{components}, and \texttt{dependencies} -- following the CycloneDX standard. The \texttt{metadata} element records information about the tool which produced the SBOM and the project on which the producer was executed. The \texttt{components} element is a list that includes information about each dependency found in the project.  
Each component's item may also contain hashes to help identifying its exact version, which can be used to ensure build integrity. The \texttt{dependencies} element is a list that records the relationship between all of the previously-listed dependencies. In the example, \texttt{jakarta.activation} is  a direct dependency of the analyzed project. 

We remark  that \autoref{lst:spec}  is a simplified SBOM for the sake of clarity. In practice, an SBOM will contain much more data. The full CycloneDX SBOM of \texttt{async-http-client} describes 110 dependencies and provides 8 hashes generated through different algorithms for each component (full-fledged real SBOM: \url{https://bit.ly/3lfTdpz}).
Furthermore, the SBOM standards allow recording additional elements such as references to external resources (e.g., the issue tracker), vulnerabilities, and code signatures.

\subsection{SBOMs and the Java ecosystem}
Given the importance of Java in enterprise and government IT, the production of Java SBOM is an active area.
The challenges are multiple:
1) reverse-engineering complex dependency resolution mechanisms is difficult,
2) constructing SBOMs for complex multi-modules and multi-services Java applications requires  navigating huge code bases to parse intricate build scripts.

\section{Methodology to Study SBOM Producers}

\rowcolors{2}{gray!25}{white}
\begin{table*}\centering
\scriptsize
\begin{tabular}{l l || l c c c c}
\toprule
SBOM producer & Version & Production step & Checksums & Hierarchy & Deterministic & Scope \\
\midrule
\href{https://github.com/jfrog/build-info-go}{\buildinfogo} & 1.8.7 & Maven compile phase & \cmark~(3) & \cmark & \xmark & \xmark\,~(0)  \\
\href{https://github.com/CycloneDX/cdxgen}{\cdxgen} & 8.0.5 & Maven package phase & \cmark~(8) & \cmark & \cmark & \cmark~(1)  \\
\href{https://github.com/CycloneDX/cyclonedx-maven-plugin}{\cyclonedxmavenplugin} & 2.7.5 & Maven package phase & \cmark~(8) & \cmark & \cmark & \cmark~(1)  \\
\href{https://github.com/AppThreat/dep-scan}{\depscan} & 3.6.0 & Static source code & \cmark~(8) & \cmark & \cmark & \cmark~(1)  \\
\href{https://github.com/Contrast-Security-OSS/jbom}{\jbom} & 1.2.1 & Post Maven package phase & \cmark~(2) & \xmark & \xmark & \cmark~(1)  \\
\href{https://docs.openrewrite.org/reference/rewrite-maven-plugin}{\openrewrite} & 4.40.0 & Maven package phase & \xmark\,~(0) & \cmark & \cmark & \cmark~(2)  \\
\bottomrule
\hfill
\end{tabular}
\caption{Curated set of SBOM producers subject to our study, supporting Java and the CycloneDX standard. }
%We execute them all in this study.
\label{tab:sbom-tools}
\end{table*}

The core of our study consists in curating and executing state-of-the art SBOM production tools on a set of mature Java projects. Then, we perform a comparative analysis of the SBOMs following the methodology illustrated in \autoref{fig:THEfigure}.

\subsection{SBOM producers}
To curate the list of SBOM producers we start by identifying producers targeting CycloneDX SBOMs for Java projects. We scan through all the candidates from the official \href{https://cyclonedx.org/tool-center/}{CycloneDX tool centre} and query GitHub with the keyword 'SBOM' for projects with at least 100 stars. This process yields 24 producers.

We further select the producers that meet the following criteria: it produces an SBOM containing the dependencies of the project; it is able to analyze Java projects that build with Maven; it is open-source; it can be run as a command-line tool. This latter criterion is essential for automating our experiments. 

Ultimately, this results in a curated set of 6 SBOM producers,   \buildinfogo, \cdxgen, \cyclonedxmavenplugin,  \depscan, \jbom, and \openrewrite, as shown in \autoref{tab:sbom-tools}. For all of these producers, we use their most recent stable releases as of February 17, 2023.



\subsection{Projects under study}

For study subjects, we reuse the curated set of projects from a recent study on dependency management in Java  \cite{depclean}. The dataset includes 31 Maven projects with stable releases and frequent activity -- indicating maturity of the project. Since our work also involves dependency analysis, the dataset is a good fit for our purpose. %after some minor modifications.  
We exclude \texttt{teavm} %\footnote{https://github.com/konsoletyper/teavm}
and \texttt{moshi} %\footnote{https://github.com/square/moshi} 
as these projects have migrated from Maven to using Gradle as build system, as well as \texttt{auto} and \texttt{subzero} since they are not valid Maven projects due to the lack of a \texttt{pom.xml} file at their root directory. 
%and hence are not valid Maven projects. 
We merge \texttt{jenkins-core} and \texttt{jenkins-cli} as a single project \texttt{jenkins} as we execute SBOM producers at the root directory of the project rather than submodules to avoid dependency resolution errors. 
This process gives us a set of 26 popular open-source Maven projects for our analysis.


Table~\ref{tab:descriptive-stats} details the set of analyzed Java projects.
Each project is identified by the name and commit at which we analyze the project.
The projects include between 733 and 1.5 million lines of application code and are composed of up to 211 Maven modules. 
They have between 2 and 221 direct dependencies, and between 1 and 655 transitive dependencies.  
%Such ranges are relevant to the study we want to do.

\begin{table}\centering
\scriptsize
\setlength{\tabcolsep}{4.5pt}
\rowcolors{4}{gray!25}{white}
\begin{tabular}{l r r r r r}
\toprule
\multirow{2.4}{*}{Project Name} & \multirow{2.4}{*}{kLOC} & \multirow{2.4}{*}{\makecell{Maven \\ Modules}} & \multicolumn{3}{c}{Ground Truth} \\
\cmidrule(lr){4-6}
{} & {} & {} & DD & TD & Total \\ 
\midrule
\href{https://github.com/apache/tika/tree/41319f3c294b13de5342a80570b4540f7dd04a3e}{tika} & \numprint{163} & 108 & 186 & 563 & 749 \\ 
\href{https://github.com/Alluxio/alluxio/tree/d5919d8d80ae7bfdd914ade30620d5ca14f3b67e}{alluxio} & \numprint{295} & 66 & 143 & 582 & 725 \\ 
\href{https://github.com/jooby-project/jooby/tree/f71b551213ac03523e44a7fbb8c972b752ffc707}{jooby} & \numprint{65} & 54 & 129 & 368 & 497 \\ 
\href{https://github.com/neo4j/neo4j/tree/c082e80b792d46ad1b342fbf7f1facb2028344c6}{neo4j} & \numprint{686} & 124 & 191 & 273 & 464 \\ 
\href{https://github.com/apache/flink/tree/c41c8e5cfab683da8135d6c822693ef851d6e2b7}{flink} & \numprint{1528} & 211 & 121 & 270 & 391 \\ 
\href{https://github.com/eclipse/steady/tree/3d261afe9513f7c708324aa0183423ab2e9e4692}{steady} & \numprint{99} & 20 & 78 & 267 & 345 \\ 
\href{https://github.com/Erudika/para/tree/41d900574e2e159b05fbd23aaab1f6e554ab8fc3}{para} & \numprint{29} & 6 & 82 & 224 & 306 \\ 
\href{https://github.com/jenkinsci/jenkins/tree/ce7e5d70373a36c8d26d4117384a9c5cb57ff1c1}{jenkins} & \numprint{181} & 10 & 99 & 200 & 299 \\ 
\href{https://github.com/apache/accumulo/tree/706612f859d6e68891d487d624eda9ecf3fea7f9}{accumulo} & \numprint{399} & 18 & 121 & 158 & 279 \\ 
\href{https://github.com/vmi/selenese-runner-java/tree/3e84e8e4e7e06aa1bdacaa8266db00f62ebef559}{selenese-runner-java} & \numprint{21} & 1 & 22 & 114 & 136 \\ 
\href{https://github.com/undertow-io/undertow/tree/f52b70c1520277a1552f0f453c2a908897a8a5dc}{undertow} & \numprint{150} & 10 & 28 & 107 & 135 \\ 
\href{https://github.com/jknack/handlebars.java/tree/2afc50fd5dcd32af28f8305b59689b3fec4a3b07}{handlebars.java} & \numprint{22} & 11 & 36 & 84 & 120 \\ 
\href{https://github.com/google/error-prone/tree/27de40ba6008f967c01a55ec83c9127419bfe433}{error-prone} & \numprint{225} & 10 & 61 & 53 & 114 \\ 
\href{https://github.com/AsyncHttpClient/async-http-client/tree/7a370af58dc8895a27a14d0a81af2a3b91930651}{async-http-client} & \numprint{29} & 14 & 40 & 69 & 109 \\ 
\href{https://github.com/rnewson/couchdb-lucene/tree/855473709bd4e3d92d3f62ece86ab739d0f0de13}{couchdb-lucene} & \numprint{3.9} & 1 & 25 & 51 & 76 \\ 
\href{https://github.com/mybatis/mybatis-3/tree/c195f12808a88a1ee245dc86d9c1621042655970}{mybatis-3} & \numprint{62} & 1 & 27 & 37 & 64 \\ 
\href{https://github.com/orphan-oss/launch4j-maven-plugin/tree/3f9818ee34b36cdcea58e2d6e6542f140b394faf}{launch4j-maven-plugin} & \numprint{1.5} & 1 & 12 & 50 & 62 \\
\href{https://github.com/checkstyle/checkstyle/tree/233c91be45abc1ddf67c1df7bc8f9f8ab64caa1c}{checkstyle} & \numprint{304} & 1 & 22 & 35 & 57 \\ 
\href{https://github.com/orika-mapper/orika/tree/eef82092c8a9dfda04192a5378fa0e49d70ade3a}{orika} & \numprint{43} & 5 & 25 & 30 & 55 \\ 
\href{https://github.com/apache/commons-configuration/tree/59e5152722198526c6ffe5361de7d1a6a87275c7}{commons-configuration} & \numprint{51} & 1 & 33 & 21 & 54 \\ 
\href{https://github.com/INRIA/spoon/tree/ee73f4376aa929d8dce950202fabb8992a77c9fb}{spoon} & \numprint{155} & 1 & 22 & 32 & 54 \\
\href{https://github.com/sarxos/webcam-capture/tree/e19125c2c728a856231a3b507372e94e02fdfd35}{webcam-capture} & \numprint{19} & 2 & 16 & 35 & 51 \\ 
\href{https://github.com/javaparser/javaparser/tree/1ae25f3f77f5d680c135d0742257ccd62916f17d}{javaparser} & \numprint{181} & 11 & 18 & 33 & 51 \\ 
\href{https://github.com/stanfordnlp/CoreNLP/tree/f7782ff5f235584b0fc559f266961b5ab013556a}{CoreNLP} & \numprint{615} & 3 & 23 & 18 & 41 \\ 
\href{https://github.com/radsz/jacop/tree/1a395e6add22caf79590fe9d1b2223bfb6ed0cd0}{jacop} & \numprint{89} & 1 & 6 & 5 & 11 \\ 
\href{https://github.com/giltene/jHiccup/tree/a440bdaed143e1445cbeab7c5bffd30989a435d0}{jHiccup} & \numprint{0.7} & 1 & 2 & 1 & 3 \\   
\bottomrule
\hfill
\end{tabular}
\caption{Descriptive statistics of the analyzed Java projects. Number of thousands of lines of application code (kLOC), number of Maven modules, number of unique direct dependencies (DD), number of unique transitive dependencies (TD), and total number of unique dependencies (Total). Rows are ordered with respect to the total number of dependencies in the projects.}
\label{tab:descriptive-stats}
\end{table}

% square/subzero & d051983f & 4783 & ~ & ~ & ~ \\ 

\subsection{Protocol to compare SBOM producers}
\autoref{fig:THEfigure} illustrates the 5 main steps of the protocol for our experiment.
We run each SBOM producer on each project as shown in step 2 in ~\autoref{fig:THEfigure}.
To support the reproducibility of our experiment, we save the specific git hash of each project and we run the SBOM producers in  a docker container.
%Then, we perform the following steps for each producer and project: start the container; set up the SBOM producer; clone the project's git repository; run the SBOM producer.
This SBOM generation procedure is fully automated, and it ensures that there are no interactions between the producers as the SBOM production for each project is isolated and starts in the same state.
The repository with our study subjects and experimental pipeline is publicly available: \url{https://github.com/chains-project/SBOM-2023}.

An SBOM captures a rich set of information about the software supply chain, including the network of direct and transitive dependencies. As part of our study, we  assess the accuracy of the dependencies in the SBOM with respect to a ground truth. For that purpose, we use the dependency list returned by the command \texttt{tree} of the \texttt{maven-dependency-plugin@3.4.0}.
This plugin is an integral part of the Maven build system, and it is the most common plugin used to perform this single task in the supply chain: resolve dependencies. It provides a deterministic dependency tree for a specific version of a Maven project. Moreover, it has been in production since 2007 and it is continuously maintained since then, with the latest release as recent as 2023. It is very mature and stable, and consequently is the best ground truth for our study.
This is step 3 in ~\autoref{fig:THEfigure}.

To assess the quality of dependency graphs in SBOMs, we distinguish between direct and transitive dependencies. In Maven, a dependency name is a combination of its \texttt{groupId} and \texttt{artifactId}, separated by a colon, for example, \texttt{com.google.guava:guava}. We consider two dependencies to be identical if their name and version match exactly. To compare the accuracy of SBOMs, we compute the precision and recall of direct and transitive dependency list for each producer, as shown in step 4 in~\autoref{fig:THEfigure}. 
The precision is the share of dependencies in the SBOM that are correct with respect to the ground truth.
The recall is the share of correct dependencies that are in the SBOM.

The last step of our methodology consists in manually analyzing a sample of SBOMs in order to get a concrete grasp at the content of the SBOMs produced (step 5 in~\autoref{fig:THEfigure}). This provides us with detailed insights about the challenges that SBOM producers face in order to correctly retrieve all the dependencies in an application's software supply chain.



\section{Experimental Results}

We follow our protocol and run 6 SBOM production tools on 26 Java projects.  The results provide key insights about the tools' behavior as well as the quality of the produced SBOMs.

\subsection{Producer Insights}

\autoref{tab:sbom-tools} summarizes the essential features of SBOM producers we identified and to what extent these features are present in the tools. 


\paragraph{Production Step}

SBOM producers do not all operate at the same moment of the build process. 
We report the step at which the SBOM is produced, per the documentation provided by the developers. 
\buildinfogo, \cdxgen,  \cyclonedxmavenplugin, and \openrewrite generate SBOMs from the Maven build process; \depscan only analyzes the source code of a project to generate the SBOM; \jbom requires a jar file to run on, and analyzes the POM that Maven injected present in it. 

These different steps are significant regarding the production of SBOMs, since the information available about the software supply chain varies at these different stages.
Indeed, software projects go through a Build/\linebreak[4]CI/CD life cycle  and, at every point, the information available is different~\cite{xia2023}.
For example, before the build phase, a SBOM producer cannot know what will be finally included in the binary.
Similarly, after the build,  information about some dependencies may be lost, because the build system has removed redundant or unnecessary dependencies.

The CycloneDX standard does not address this aspect, and the producers do not clearly document or motivate the phase they consider. SBOM producers should state the production step at which they collect information about the software supply chain, to help SBOM consumers decide which SBOM is most appropriate for their needs.

\paragraph{Checksum Diversity}
\autoref{tab:sbom-tools} summarizes the number of different checksum algorithms that each SBOM producer uses. Three producers compute eight types of checksums for each dependency jar:
\cdxgen, \cyclonedxmavenplugin and \depscan provide md5, sha1, sha256, sha512, sha384, sha3-384, sha3-256, and sha3-512 for each dependency in the SBOM. 
One producer, \openrewrite, does not provide any checksums, which is considered a serious limitation. 
The production of different checksums is useful because it maximizes the likelihood of integration of the SBOMs with third-party tools that expect a specific checksum. Our observations help practitioners to select SBOM producers accordingly.


\paragraph{Dependency Tree Hierarchy}

An essential features of SBOM producers consists in eliciting all the dependencies in the software supply chain of an application.
Yet, beyond a flat list, some analyses such as vulnerability analysis, debloating and installation via package managers require the full tree of relationships between the different components in the chain.
The CycloneDX specification provides the attribute \texttt{dependencies} to serve this purpose.
However, only five of six producers report the hierarchy among dependencies.
\jbom is unable to link the dependencies together, since it acts after the build step where some dependencies cannot be resolved.

For the five producers that provide dependency trees, these trees differ noticeably in correctness and completeness.
%Other producers are way more focused on correct information and are more correct, but have less information.
For example, the ground truth for \texttt{mybatis-3}
indicates that \texttt{com.fasterxml.jackson.core:jackson-core} version \texttt{2.13.2} is a transitive dependency at the fourth level.
The producers \buildinfogo, \cdxgen, \cyclonedxmavenplugin, and \depscan report this information correctly.
However, \openrewrite wrongly detects this transitive dependency at the third level in the tree it reports.

\paragraph{Deterministic SBOM Production}
SBOMs are meant to be reference documents, and potentially may become legally binding. To that extent, one must produce them reliably.
In order to assess this feature, we say that SBOM production is deterministic if, for a given repository with a git hash, two executions of the producer generate strictly identical files contentwise, excluding metadata such as timestamps. 
% This means that the SBOM dependency resolution must be deterministic, the order in which data is included in the file must be fixed, and the SBOM must not include any information that is specific to the production context, such as operating system or filesystem specific data.
%This means we can run this experiment on two machines and should get the same file.
For each producer, we generate SBOMs twice and we find that \buildinfogo and \jbom are not deterministic: they do not preserve the order of SBOM elements. Moreover, \jbom also produces different hashes of the components. While this is a fixable implementation issue, it highlights the necessity to consolidate the maturity of SBOM tooling before it can be relied upon in court.


\paragraph{Scopes in SBOM}\label{para:sbom_scope_problem}

The CycloneDX JSON specification supports an optional \texttt{scope}  attribute for each component. This attribute can take the values \texttt{required}, \texttt{optional} or \texttt{excluded}, based on the dependency's behavior at runtime. According to the specification\footnote{\url{https://github.com/CycloneDX/specification/blob/1.4/schema/bom-1.4.xsd\#L514}}, the \texttt{required} scope denotes that the component is required at runtime; the \texttt{optional} scope denotes components that \textit{``[\dots] are not capable of being called due to them not be installed or otherwise accessible by any means''}. Finally, \texttt{excluded} components \textit{``[\dots] provide the ability to document component usage for test and other non-runtime purposes.'}

We observe significant differences among SBOM producers regarding the identification of scopes. 
As an example, \texttt{org.slf4j:slf4j-api@2.0.1} is a dependency of \texttt{mybatis-3}. \cdxgen,  \cyclonedxmavenplugin, and \depscan report its scope as \texttt{optional}, whereas \openrewrite reports the scope as \texttt{required}, while the other producers report no scope at all. 

We note that each SBOM producer only uses a subset of the allowed scope values. \cdxgen, \cyclonedxmavenplugin, and \depscan either label components as \texttt{optional} or provide no scope value. \jbom labels all components as \texttt{required}. \openrewrite marks components as either \texttt{optional} or \texttt{required}, and \buildinfogo does not report \texttt{scope} for any component. It is not clear from the documentation of the producers how these values are computed.
Due to the lack of clarity in the standard and the absence of ground truth, it is impossible to determine which one is correct.

Providing clear information as to how and when in the software lifecycle a component is used -- the scope as we understand the standard -- is an important feature of an SBOM. However, our results show that no SBOM consumer can rely on the \texttt{scope} values produced by current SBOM producers.


\subsection{SBOM Accuracy}


\begin{figure}
  \begin{center}
    \includegraphics[scale=0.5]{img/resultGraphic.pdf}
    \caption{Mean precision and mean recall of each SBOM producer. Blue marks~(\blueDot) indicate statistics for direct dependencies, and red marks~(\redDot) for transitive dependencies.
    The abbreviations stand for the following, \texttt{big} for \buildinfogo, \texttt{cdx} for \cdxgen, \texttt{or} for \openrewrite and \texttt{cdx-mp} for \cyclonedxmavenplugin}
    \label{fig:sbomProducerResults}
  \end{center}
\end{figure}

\autoref{fig:sbomProducerResults} shows the accuracy of the SBOM producers per our ground truth. The X-axis is the precision, and the Y-axis is the recall for each producer. We distinguish between the accuracy of the direct (represented by a \blueDot) and transitive dependencies (represented by a \redDot) captured in the SBOMs.  Each point in the figure represents the average precision and recall of an SBOM producer, over all projects. 
For our experiment, we performed 156 executions of SBOM producers, which produced  121 SBOMs and 35 failures. For the latter, SBOMs were either empty or contained no dependency because the build failed or the producer failed. We exclude these data points of our study. 


Overall we can distinguish four clusters in \autoref{fig:sbomProducerResults}:  \jbom at the bottom-left, with the lowest precision and recall; \cdxgen, \cyclonedxmavenplugin, and \depscan, with  average precision and recall;  \openrewrite in the middle with high precision and low recall;  \buildinfogo in the top right, with the  highest precision and recall for direct and transitive dependencies. 

% JBOM cluster
We identify three main reasons for the low results of \jbom. First, it fails to resolve Maven properties. For example, it reports version \texttt{\$\{guava.version\}} for \texttt{com.google.guava:guava}, instead of  \texttt{31.0.1-jre}. Second, it does not capture the dependency hierarchy information, which results in a lot of transitive dependencies being missed and hence a low recall. 
Third, \jbom also does not resolve test-scoped dependencies which further reduces the recall.


%cdxgen cluster
The results of \cdxgen, \cyclonedxmavenplugin and, \depscan form the middle cluster. These producers perform similarly for the study subjects. All 3 producers share a common backend. In fact, \depscan is a wrapper around \cdxgen, and \cdxgen itself is a wrapper around \cyclonedxmavenplugin.  They produce an average result because of their poor handling of Maven multi-module projects, which are present in our dataset.
For example, consider the project \texttt{tika}. 
The ground truth considers \texttt{tika-example} as root.
However, the producers consider \texttt{tika-parent} as root (with \texttt{tika-example} as one of the direct dependencies), and then use it to derive all dependency relationships. This shows that the semantics of so-called parent module in Maven is inconsistently captured.
Consequently, it causes a different classification of direct and transitive dependency as compared to the ground truth, thus resulting in false positives.
On the other hand, these three producers report high precision when the Java project contains a single Maven module, as there is no ambiguity regarding the relationship between modules.
For example, the precision reported for \texttt{commons-configuration} is 100\%.
% cdxgen backend https://github.com/CycloneDX/cdxgen/blob/4e8d6c53429501e007618d435c3ff87c0509f2db/index.js#L947
% cdxgen-maven-plugin used by cdxgen
% depscan https://github.com/AppThreat/dep-scan/blob/8fa65cba544b7f1d8979531ade9e42dfcc8181c3/depscan/lib/bom.py#L211
% openrewrite cluster

\openrewrite performs relatively well in regard to correct identification of direct dependencies compared to the previous cluster. For example, it is 100\% precise for \texttt{steady}. However, its recall is low because \openrewrite does not resolve test dependencies. 

% build-info-go cluser
\buildinfogo yields the best results in our study
both in terms of precision and recall, and hence its results are positioned at top-right. For example, it performs perfectly with respect to the ground truth for \texttt{selenese-runner-java}, \texttt{checkstyle}, \texttt{launch4j-maven-plugin}, and \texttt{mybatis-3}, retrieving the exact and complete dependency tree for these projects.  A closer look  at its architecture and code shows that \buildinfogo directly uses the Maven APIs to invoke the build and get deeper information, thus improving the accuracy of SBOM.
%This allows it to combine all of this information into a single, accurate SBOM which is clearly better than the rest.
This suggests that SBOM producers  benefit from being language- and build-specific, in order to deep dive in the build process to obtain the right information.

Overall, \autoref{fig:sbomProducerResults} shows significant differences among the  accuracy  of the SBOMs produced by 6 state of the art producers. These results  reveal discrepancies in the list of dependencies  in the SBOMs, spanning different dependency versions, different dependency hierarchies and missed dependencies.
To better illustrate   the different accuracy levels, we manually analyze a sample of the SBOMs. We sample 6 SBOMs: 4 SBOMs with highest and lowest precision on direct dependencies, produced by \buildinfogo and \jbom; 
%the SBOMs with highest and lowest precision on direct dependencies, \jbom; 
2 SBOMs with highest and lowest precision on direct dependencies produced for the \texttt{spoon} project. We pick  SBOMs produced by \buildinfogo and \jbom as these  producers are at both ends of the accuracy range. We pick  SBOMs for \texttt{spoon} as three of authors are maintainers and hence have a deep understanding of this project. 
%In all cases, the analysis was limited to the precision score. 
This analysis was conducted by two of the authors, both experts in Java programming. In case of discrepancies, they met and discussed to resolve them and reach a conclusion.

The ground truth indicates that the single module of \texttt{spoon} has 22 direct dependencies and 32 transitive ones (see \autoref{tab:descriptive-stats}).
The SBOM produced by \buildinfogo correctly contains 9 direct  and 14  transitive dependencies. The precision is consequently high, but some dependencies are clearly missing. 
On the other hand, the SBOM produced by \jbom reports 52 dependencies, but only 15 of them are correct and it reports no dependency tree hierarchy information.

The next two case studies come from \buildinfogo. First, we inspect the SBOM produced for \texttt{mybatis-3}, and we find that \buildinfogo fetches all 27 direct dependencies and 37 transitive dependencies. It also includes the complete dependency tree hierarchy information. Such precise information is important and makes the SBOM consumable. However, we notice that even a solid producer such as \buildinfogo does not always achieve 100\% precision. For example, the SBOM of \texttt{steady}  includes 33 correct direct dependencies out of 78, but it also includes 2 direct dependencies, \texttt{jakarta.xml.bind-api} and \texttt{json-path}, which are not part of \texttt{steady}'s dependencies according to the ground truth.
Both dependencies are transitive, but they are detected as direct dependencies because their parent is missing as a component.
This further confirms that multi-module Maven projects are a caveat for the production of accurate SBOMs.

Unexpectedly, the SBOM produced by \jbom for \texttt{tika} contains only 4 direct dependencies out of 186 and 7 transitive dependencies out of 562.
On a deeper inspection, we observe that most dependencies in the SBOM are identified with wrong versions, resulting in poor precision. Such an SBOM would not be useful for security analysis because incorrect versions of the dependencies would cause many false alarms regarding vulnerability detection.
We analyze the SBOM of \texttt{mybatis-3} produced by \jbom.
This SBOM includes all the direct dependencies, precisely with correct version numbers as they were specified.
The dependencies with a test or any other non-compile scope in the ground truth for \texttt{mybatis-3} are not reported, because of the choice of analyzing the jar file.

\subsection{Take-aways}

% for the Jave developer
\emph{Java developers:}
Our in-depth study shows that \buildinfogo is the best SBOM producer for Java developers.
The reasons are that:
1) it produces different checksums and it supports dependency hierarchies; and  
2) it achieves the highest precision and recall thanks to a tailored integration in Maven. 
Yet, \buildinfogo has room for improvement. First, the precision and recall of 97\% and 72\% respectively can definitely be increased, perhaps to 100\%. Second, assuming that the standard clarifies the matter, it could provide the scope of the dependencies. 

\emph{Standardization committees:} 
Our study identifies two shortcomings in the CycloneDX standard.
The specification needs to ask producers to motivate the exact step at which the SBOM is produced and it must precisely define the notion of scope, which would help both SBOM producers and consumers. 
We believe that the latter is more important as the current state is ambiguous for developers, and ambiguity upstream typically means incorrectness downstream.

\emph{Fundamental difficulty:} 
Beyond concrete opportunities to consolidate the SBOM producers and the CycloneDX standard, our study reveals the fundamental difficulty of producing a complete and useful SBOM.
We have observed two essential difficulties:
one is rooted in the complexity of modern package managers and build systems.
In Java, the modular architecture of Maven projects hinders the accurate collection of a complete dependency tree.
The second difficulty stems from the fact that engineering of SBOMs is in its infancy and SBOM producers cannot target clear-cut SBOM results without precise downstream SBOM consumption use cases.   


\section{Open Challenges}



Our experiments revealed a number of challenges for  the accurate production  and the effective consumption of Software Bill of Materials.

\paragraph{SBOM and Tooling Dependencies}

In our analysis, we observe that the bulk of SBOMs consists of 
collecting accurate dependency trees for an application project. Yet, the software supply chain of an application is made of many more components. For example, the version control system, the testing and build tools  and the infrastructure to deploy or distribute the application are key components of the supply chain. 
In the recent years, we witnessed   attacks such as the Solarwinds incident, which successfully compromised a system through these components~\cite{ladisa2022taxonomy}. 
The CycloneDX standard attempts to document such information by providing an attribute \texttt{externalReferences}. However, there is currently scarce support to generate these attributes and our study shows that the SBOM producers implement this partially and with inconsistencies. The comprehensive collection and documentation of all tools involved in the supply chain is a pressing challenge to produce SBOMs that are amenable to thorough hardening procedures.


\paragraph{SBOMs for Threat Analysis}

In the longer term, the value of SBOMs will increase with enabling automatic security analyses. For example, one key challenge is to let SBOM producers qualify the trust that one can have in the dependencies. This type of assessment of the supply chain relates to threat modeling and analysis, which is already considered good practice for DevOps organizations \cite{rafi2021readiness}.  In order to guide which properties an SBOM should include support reasoning about trust and threats, the attack taxonomy of Ladisa et al. \cite{ladisa2022taxonomy} constitutes an excellent starting point. Furthermore, the work of Zahan et al. \cite{zahan2022} proposes concrete metrics as warning signs of supply chain vulnerabilities that could be mapped to the taxonomy, such as \textit{Too many maintainers} which can match the \textit{Take-over Legitimate Account} as well as the use of \textit{Installation scripts} which relates to the \textit{Running a malicious build job} technique. 

\paragraph{SBOMs at Runtime}

The next challenge will be to bring SBOMs online, as a foundation to enforce security requirements at runtime. For a given SBOM pertaining to a software application, one can develop lightweight dynamic analysis to enforce mandatory access control policies.
This can be achieved by monitoring the usage of dependencies at runtime and ensuring that only the dependencies within the SBOM are used by the application, thus preventing the entire class of vulnerabilities that rely on dynamic inclusion of malicious code and packages. A major challenge for such an approach is that it would require accurate static information about dependencies, which is a challenging endeavor, as we have shown in this article.  


\paragraph{SBOMs in Other Software Stacks}
% sbom in go
The production of SBOMs for other software stacks is likely to face a similar set of challenges as those seen for Java.
However some programming ecosystems have partially solved  the problems that are present in Java.
For instance, the Go ecosystem already enforces the use of checksums for all publicly available dependencies, and these checksums can be validated against an immutable, verifiable database.
% Additionally, a vulnerability database is maintained by the Go security team, and is integrated with other services and development tools.
Additionally, the Go binaries already embed information about how they are built.
In theory, the data provided by these instruments can already be aggregated and used to produce a meaningful SBOM, however, a definitive solution is yet to be established and widely used in the Go ecosystem.

%beyond single stack/tech/language
% Moreover, the heterogeneity of software stacks poses an open challenge by itself. The operation of many modern software projects depends on several tools, each with their own specificity. In these projects, it is common to find diverse files defining e.g. pipelines for continuous testing, integration, and delivery; as well as infrastructure as code configurations.  Comprehensive SBOM solutions must aim to be tech-agnostic and leverage the current standards to aggregate data pertaining to all these different tools.

\section{Conclusion}

We performed a deep-dive into the meaning of Software Bill of Materials and its realization in the Java ecosystem, one of the most commonly used enterprise programming languages.
Our research findings indicate strong interest and vibrant activity in this essential area for software supply chain security and reliability. Yet, we also revealed that SBOMs today rely on a technical foundation that is unstable.
Our empirical insights shed light on important weaknesses that require attention, starting with incorrect or incomplete dependency lists recovered in SBOMs. 
These findings call for further work in clarifying the SBOM standards, as well for more work on improving the quality of SBOM producers' output.
Both academia and industry agree that SBOMs promise great benefits, now the time is ripe to all work together to unleash their full potential.
\IEEEtriggeratref{12}
\bibliographystyle{ieeetr}
\bibliography{main}
\end{document}