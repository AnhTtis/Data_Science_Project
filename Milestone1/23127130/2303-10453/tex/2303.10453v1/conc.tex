\vspace{-0.25cm}

\section{Related Work and Conclusion}\label{sec:conc}

\vspace{-0.3cm}

This paper has described a logic based interpretation of modularity in
logic programming. A natural question that arises in assessing its
contributions is the relationship of the treatment it proposes to that
in functional programming. There are obvious similarities at the
pragmatic level to the ideas of signatures and structures in Standard
ML and existential quantification in programs looks enticingly similar
to existential types that underlie hiding in functional programming
\cite{MP88toplas}. However, there is also a fundamental difference in
that logic programming is based on {\it proof search} rather than on
{\it proof normalization}. Much of the attention in this paper has
been on spelling out a coherent logical viewpoint for modularity in
logic programming and then describing how a satisfactory computational
treatment can be provided to the associated proof search.

Another relevant comparison is with work that endows
actual Prolog systems with modularity capabilities. A major concern
within such efforts (\eg, \cite{cabeza00new,sicstus,quintus}) has been
the interpretation of metalogical predicates such as {\it call} and
the treatment of declarations relating to syntax.  The focus 
on this view of modularity has significant practical relevance---{\it
e.g.}, see \cite{cabeza00new} for its importance to language
extensibility. However, this concern is orthogonal to our primary one 
here relating to name and code scoping. With regard to the handling of
names, these other approaches have been somewhat {\it ad hoc} at a
logical level, permitting the hiding of predicate names but not those
of functors and constants, a critical aspect of data abstraction. The
treatment in the {\it Mercury} language is closer to ours
pragmatically but differs in that it requires either all or none of the
constructors of a type to be hidden \cite{becket05mercury}. Moreover,
our use of existential quantifiers can lead to richer computations
that require a more sophisticated unification procedure. Unfortunately
space does not permit a fuller discussion of this issue.

We should also contrast our work with those in logic programming that
focus on a logic-oriented approach to realizing modularity. The
proposal of Sanella and Wallen \cite{SW92} that brings ideas from ML
into the logic programming setting is one example of this. The
notions of signatures and structures in this proposal once again
correspond closely to our ideas of signatures and modules. One
{\it difference} is that \cite{SW92} does not allow for a
predicate definition to be built up across different
structures/modules; such a capability has potential usefulness in a
logic programming setting as argued in
Section~\ref{sec:modules-practical}. We also note that, in our
setting, the hiding realized through signature specifications is
explained in a logic-based way.  Another proposal is that of
Miller \cite{Miller93elp} that subsumes the constructs we have used
here. Our contribution relative to this work is to demonstrate that an
entirely static subpart of it suffices to realize scoping over clause
definitions as well. Finally we mention the work of Harper and
Pfenning \cite{HP98jlc} that adapts an ML-like approach to modularity
to an LF based logic programming language but that, like
\cite{Mil89jlp}, also allows for dynamic modifications of predicate
definitions.

At an implementation level, we have had to deal with two different
issues: the treatment of scope for existentially quantified variables
and the combining of code for a given predicate that is obtained from
compiling different modules. The second issue is pertinent 
also to multifile definitions in, for instance, the SICStus
system. The solution adopted there is different at least on
the surface: compilation is done directly to core and indexing is
realized interpretively based on a data structure that is built up
incrementally as each clause is compiled \cite{Carlsson07}. It is of
interest, however, to see if aspects of that approach can be adapted
to our separate compilation setting as well.  

There are different aspects relevant to the work we have presented
here such as the logical features underlying our proposal for
modularity, the syntax chosen to support this notion, the treatment of
name scopes in compilation and computation (or, more precisely, in
unification) and the realization of separate compilation. Each of
these aspects has received consideration individually in past work,
raising the question of what precisely the contribution of this
paper is. The main novelty here, in our estimation, is in the
way we combine these different ideas to yield a logic motivated 
approach to modularity that is pragmatically useful and that has a
simple, separate-compilation based implementation.

The modules language that we have described has been implemented
within the {\it Teyjus} system. Experience relative to this system
with the approach to scoping that we have advocated has been positive:
users have adapted easily to this method from the dynamic, import
based approach that is also supported. The ideas presented in
Section~\ref{sec:sep-compilation} are part of a re-implementation of
this system whose release is imminent and that now also supports
separate compilation. 

