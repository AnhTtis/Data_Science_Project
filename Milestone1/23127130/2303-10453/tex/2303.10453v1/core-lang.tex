\vspace{-0.35cm}

\section{The Underlying Logical Language}\label{sec:core-lang}

\vspace{-0.3cm}

Our approach to information hiding involves the use of existential
quantification. Since we desire the ability to hide the names of
predicates and functions in addition to (first-order) constants, the
right context for our ideas is that of a higher-order
logic. We shall assume also that our language is typed although our
main ideas apply equally in an untyped setting. 

%The particular logical language that we use here is the one
%underlying $\lambda$Prolog. This choice is not essential: our main
%ideas apply equally to an (untyped) higher-order language that
%suitably generalizes Prolog.   

%Our logic, then, is both typed and higher-order. 
%that is a fragment of the 
%intuitionistic version of Church's Simple Theory of Types
%\cite{Church40}, 
%is typed and higher-order. 
We work with a set of types that initially contains 
{\it int}, {\it real}, {\it string} and {\it o}, those that can be
formed using the unary type constructor {\it list} and, finally, all
the function types, written as $\alpha \rightarrow \beta$, that can be
formed  from these types. The type {\it o} is that of
propositions. Type variables, denoted by tokens starting with
uppercase letters, are introduced as a shorthand for an infinite
collection of instance types.
Terms in the language are constructed from collections of typed 
constant and variable symbols using the operations of application and
abstraction. 
The initial set of constants includes the logical symbols {\it true}
denoting the always true proposition, $\supset$, $\lor$ and $\land$
denoting infix forms of implication, disjunction and conjunction and
two `schema' constants {\it sigma} and {\it pi} of type $(A
\rightarrow o) \rightarrow o$. The last two (family of) constants
represent generalized existential and universal quantifiers: $\exists
x\, P(x)$ and $\forall x\, P(x)$ are rendered in this logic as
$(sigma\ \lambda x P(x))$ and $(pi\ \lambda x P(x))$
respectively.\footnote{We write $P(x)$ to denote a term that possibly
has free occurrences of $x$.} We also assume the usual constants
denoting integers, reals and strings  
% (whose specific structures we do not describe here) 
and the schema
constants {\it   nil} of type {\it list~A} and the infix \verb+::+ of
type $A \rightarrow (list\ A) \rightarrow (list\ A)$ that provide for
a `builtin' notion of lists. 
Application is assumed to be left
associative. This leads to a curried notation for terms. If $p$
is an $n$-ary relation symbol, the expression 
$(p\ t_1\ \ldots\ t_n)$ denotes this relation between the terms
$t_1,\ldots,t_n$. Such an expression constitutes an atomic 
formula if its `head' $p$ is either {\it true} or is not a logical
constant. 
\ignore{
The initial set of constants also includes those
given by  sequences of digits denoting integers, by two sequences of
digits separated by a period denoting reals, by sequences of characters
enclosed between double quotes denoting strings and the schema
constants {\it   nil} of type {\it list~A} and the infix \verb+::+ of
type $A \rightarrow (list\ A) \rightarrow (list\ A)$ that provide for
a `builtin' notion of lists. 
}

In any real application it is necessary to introduce new sorts and
type constructors as well as new nonlogical constants. We describe
mechanisms in the next section for declaring such symbols. 
\ignore{As we shall
see there, modules provide a natural means for delineating the scope
of such declarations.} Types must also be associated with
variables. Such type information can be filled in by an inference
process and the language syntax may also allow it to be explicitly
provided.  

The logic that we shall use to expose our ideas is slightly expanded
version of the higher-order theory of Horn clauses. The central
components of this logic are the $G$ and $E$ formulas 
identified by the following syntax rules:
%\vspace{-0.5cm}
\begin{tabbing}
\qquad\=D\quad\=::=\quad\=\kill
\>$G$\>::=\>$true \ \vert\  A \ \vert\  G \lor G \ \vert\
G \land G \ \vert\  \exists x\,G $\\
\>$D$\>::=\>$A_r \ \vert\  G \supset A_r \ \vert\  \forall x\,D\
\vert\  D \land D$\\
\>$E$\>::=\>$D \ \vert\ E \land E\ \vert\ \exists x\,E$
\end{tabbing}
%\vspace{-0.5cm}
\noindent $A$ denotes atomic formulas here and $A_r$ 
represents atomic formulas whose heads are either constants distinct
from {\it true} or are existentially quantified in the enclosing
context. 
\ignore{Existential quantifiers in $E$ formulas are treated as
constants in the computation model described below. From this it
becomes clear that the head of an $A_r$ formula is always a nonlogical 
constant, albeit of smaller or larger scope.} A $D$ formula of the form
$A_r$ or $G \supset A_r$ is said to have $A_r$ as its head and its
body is either empty or $G$ depending on the case in
question. Such a formula is, as usual, part
of the definition of a predicate whose name is the head of the $A_r$
formula; this interpretation is meaningful because the computation model
described next ensures that this head is eventually always a
nonlogical constant. Restricted to the first-order setting, our
$D$ formulas are essentially typed versions of definite Horn
clauses or program clauses that underlie Prolog. 

Computation in the core language is oriented around trying to solve a
goal given by a $G$ formula given a collection of closed $E$
formulas that defines a program. Semantically, this notion is explained via
provability in intuitionistic logic. At a procedural level, this
translates into carrying out the following steps.\footnote{This
description should be read as a {\it precise} but {\it abbreviated}
rendition necessitated by paucity of space of an alternative
presentation via a transition system.} First, a signature is
determined by the (global) constants appearing in the program and the
goal and is used to determine instantiations for the free variables in
the goal. Then, the existential quantifiers at the front of $E$
formulas are instantiated by new constants, the available signature is
expanded to include these constants and conjunctions are eliminated to
transform the program to a set of $D$ formulas of the form $A_r$ or $G
\supset A_r$. Next, a complex goal is reduced recursively based on its
structure: a conjunctive goal results in an attempt to solve each
conjunct from the same program, a disjunctive goal becomes an attempt
to solve one of the disjuncts and an existential goal is instantiated
by a chosen closed term based on the current signature and not
containing $pi$ or $\supset$. Eventually, the goal encountered must be
atomic. This goal is solved trivially if it is {\it true}. If not, it
is matched with the head of a closed instance of a $D$ formula in the
program, resulting in a solution if the body is empty and the body of
the $D$ formula as a new goal to be processed in an identical fashion
otherwise.

The framework for computation described above possesses an interesting
ability to treat scope. Specifically, existentially quantified
variables in programs correspond to names or constants and explicit
quantification makes it possible to indicate a scope for such
names. Thus, in a program that contains the  formulas $\exists
x\,D_1(x)$ and $\exists x\,D_2(x)$, the `names' $x$ 
that appear in the two contexts are to be thought of as {\it distinct}
constants. This situation is to be contrasted with one where the
program contains the formulas $D_1(x)$ and $D_2(x)$, assuming that the
two $x$s meet the syntactic criteria for being treated as 
constants. Existential quantification also has an impact on the
availability of names in an outside context. Thus, the constant $x$ is
allowed to appear in instantiations of the free variable $y$ when an
attempt is made to solve the goal $G(y)$ from a program containing the
formula $D_1(x)$. However, this constant {\it may not} be so used if
the program formula is changed to $\exists x\,D_1(x)$ instead.

\ignore{
A substantive fact about the logic being considered is that the
procedure we have outlined for solving a $G$ formula from a set of $E$
formulas exactly captures provability in intuitionistic logic.
}
