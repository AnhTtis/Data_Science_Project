\documentclass{llncs}
\usepackage{eepic}
\usepackage{epic}
\usepackage{latexsym}

\input macros

\usepackage{makeidx}  % allows for indexgeneration

\bibliographystyle{plain}

\begin{document}

\pagestyle{plain}

\mainmatter 

\title{Modularity and Separate Compilation\\ in Logic Programming
\vspace{-0.4cm}}

\titlerunning{Modularity and Separate Compilation}

\author{Steven Holte and Gopalan Nadathur}

\institute{Department of Computer Science and Engineering,
University of Minnesota,\\
4-192 EE/CS Building, 200 Union Street SE, Minneapolis, MN 55455\\
\email{Email: \{holte,gopalan\}@cs.umn.edu, Fax: 612-625-0572}\\
\ignore { Home Page: \texttt{http://www.cs.umn.edu/\homedir gopalan}}
}


\maketitle 

\vspace{-0.5cm}

\begin{abstract}
The ability to compose code in a modular fashion is important to
the construction of large programs. 
In the logic programming setting, it is desirable that such
capabilities be realized through logic-based devices. 
We describe here an approach for doing this that is a simplification
and a rationalization of features previously supported in the {\it
  Teyjus} 
implementation of the $\lambda$Prolog language. 
Within this scheme, a module corresponds to a block of code whose
external view is mediated by a signature.  
Thus, signatures impose a form of hiding that is explained, at the
logical level, via existential quantifications over predicate,
function and constant names.  
Module interaction is based on {\it accumulation}, a mechanism
that translates into conjoining the clause definitions in them while 
respecting the scopes of existential quantifiers arising from  
signature interpretation.
Our first contribution is to show that this simple device for
statically structuring name spaces suffices for realizing features 
related to code scoping for which the dynamic control of predicate
definitions was earlier considered necessary. 
The module capabilities we present have previously been implemented in
the {\it Teyjus} system via the compile-time inlining of accumulated
modules. 
This approach has the drawback of not supporting separate
compilation. 
Our second contribution is a scheme that allows each distinct module
to be compiled separately, moving the task of inlining to a later,
complementary linking process.
\end{abstract}

\vspace{-0.5cm}

\input intro
%\vspace{-0.15cm}
\input core-lang
%\vspace{-0.15cm}
\input modularity-basis
%\vspace{-0.15cm}
\input modules-practical
%\vspace{-0.15cm}
\input sep-compilation
%\vspace{-0.15cm}
\input conc
%\vspace{-0.15cm}
\input ack

\input{holte-nadathur.bbl}

\end{document}

