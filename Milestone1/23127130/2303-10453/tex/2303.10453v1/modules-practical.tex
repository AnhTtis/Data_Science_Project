\vspace{-0.25cm}

\section{The Practical Use of Modules}\label{sec:modules-practical}

\vspace{-0.25cm}

Although the modules language described in the previous section is
simple, it is quite versatile at a programming level. We attempt to
bring this facet out in this section by considering some paradigms for
its use.  

A module in our language allows code that supports a desired
functionality to be collected into a named unit and an associated
signature provides a window into this code. Now, the
capabilities implemented by a module may be needed in the context of
another module. Module accumulation supports the realization of such
an interaction. As an example, suppose that we wish to implement a
heuristic-based graph search procedure. This procedure would
initialize a collection of states and then expand this set based on
the rules for generating new states and an underlying strategy for
selecting the next state for expansion. To realize what is required of
it, this code may need the implementation of a store. This can be
obtained by accumulating the module \verb+store+ presented earlier.
Figure~\ref{fig:graphsearch} displays part of the definition of a
graph search module to illustrate this idea. The accumulation of
\verb+store+ gives this module a type for stores that is used in the
type declarations of \verb+init_open+ and
\verb+expand_graph+. This accumulation also provides for use the
procedures \verb+init+, \verb+add+ and \verb+remove+. An aspect worthy
of note is that while the (universally quantified) variables
in the program clauses in this module can be instantiated with store
representations, these representations are still abstract: the
implicit existential quantification over local constants imposes
visibility restrictions that ensure that their inner structure can
only be accessed by recourse to operations in the module
\verb+store+. Note also that by excluding declarations
for \verb+init+, \verb+add+ and \verb+remove+ from the signature for
\verb+graph_search+, the predicate definitions in \verb+store+ can be
made entirely private to the graph search module. Thus, in contrast to
the \verb+import+ construct of \cite{Mil89jlp}, we are able to achieve
code scoping by simply structuring name spaces in a {\it completely
  statically determined} collection of code. 

\begin{figure}[t]
\begin{tabbing}
\qquad\=\qquad\qquad\=\kill
\>\verb+module graph_search.+\\
\>\verb+accumulate store.+\\
\>\verb+kind state,action type.+\\
\>\verb+type graph_search list action -> o.+\\
\>\verb+type init_open store state -> o.+\\
\>\verb+type expand_graph store state -> list state -> list action -> o.+\\
\>\verb+...+\\[3pt]
\>\verb+graph_search Soln :- init_open Open, expand_graph Open nil Soln.+\\
\>\verb+init_open Open :- start_state State, init Op, add State Op.+\\
\>\verb+expand_graph Open Closed Soln :-+\\ 
\>\>\verb+remove State Open Rest, final_state State, soln State Soln.+\\
\>\verb+expand_graph Open Closed Soln :-+\\
\>\>\verb+expand_node State NStates,+\\
\>\>\verb+add_states NStates ROp (State::Closed) NOp,+\\
\>\>\verb+expand_graph NOp (State::Closed) Soln.+\\
\>\verb+...+
\end{tabbing}
\vspace{-0.5cm}
\caption{A Module Implementing Graph Search}
\vspace{-0.5cm}
\label{fig:graphsearch}
\end{figure}

The above example shows how a {\it private} copy of code can be
acquired by a module. While this may be the desired behaviour in some
situations, the accumulated module may in many other cases represent a
common capability that is to be shared between different modules in a
large system. A specific example of this kind is provided by
``library'' predicates such as \verb+append+ on lists: given the
ubiquitous nature of lists, these predicates are likely to be needed
in many places and it is desirable to use {\it one} copy of the code
in the entire system rather than replicating the code at each place it is
needed. 

A solution to this problem is to think of modules that use such
library capabilities as being {\it parameterized} by them. Our modules 
language supports this kind of parameterization in a natural
way. For
example, suppose that we wish to think of the module \verb+graph_search+
as one that depends on an externally provided implementation of
stores rather than one that it accumulates. This dependency can be
manifest by including appropriate declarations in its signature. In
particular, this signature would identify the type constructor
\verb+store+ and the constants \verb+init+, \verb+add+ and
\verb+remove+. We would, of course, have to provide the module with
the functionality it needs eventually. This can be done by 
accumulating the module \verb+store+ at the relevant place. As a
specific illustration, suppose we wish to test our implementation of
graph search. A harness suitable for this purpose can be expressed via the
following module: 
\vspace{-0.15cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+module test_graph_search.+\\
\>\verb+accumulate graph_search, store.+
\end{tabbing}
\vspace{-0.15cm}
By endowing this module with a signature that makes the needed
types, data representations and predicates from the module
\verb+graph_search+ externally visible, we can pose queries against it
that exercise the capabilities that are to be
tested.\footnote{This discussion also shows how different modules in a
composite system can share ``library'' capabilities: they can be
parameterized as described and the parameter can be
discharged by accumulating the library module into a common context.}

Predicate definitions in the logic programming context can be expanded
by adding further clauses. The definitions emanating from an
accumulated module have the potential of being extended in this way in
the accumulating module. It is often desirable 
to curtail this possibility. Referring to the module
\verb+store+, for instance, we may want to freeze
the definition of the operations \verb+init+, \verb+add+ and
\verb+remove+ that it provides. This possibility is supported by 
permitting an ``export'' annotation in
signatures. Specifically, by replacing
\vspace{-0.25cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+type  add  A -> (store A) -> (store A) -> o.+
\end{tabbing}
\vspace{-0.25cm}
with the annotated declaration 
\vspace{-0.25cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+exportdef  add  A -> (store A) -> (store A) -> o.+
\end{tabbing}
\vspace{-0.25cm}
in the signature of the module \verb+store+, we may signal that the
definition of \verb+add+ may not be altered by the accumulating
context. Paying attention to the model for pairing functionality that
we have just sketched, our modules language also provides a
complementary ``useonly'' annotation. Thus, by using the declaration 
\vspace{-0.5cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+useonly  add  A -> (store A) -> (store A) -> o.+
\end{tabbing}
\vspace{-0.25cm}
in the module \verb+graph_search+ instead of the type declaration for
\verb+add+ we indicate that this predicate is only to be used without
alteration in this module. We note that at a logical level both the 
\verb+exportdef+ and \verb+useonly+ declarations are {\it identical
to type declarations}. They differ from type declarations only at a
pragmatic level by imposing special wellformedness restrictions---that
must be checked and can be made use of by a compiler---on 
module composition. The restrictions can, however, be quite useful in
practice: they impart a completeness property to definitions that can
help in reasoning about program properties and also in generating
better object code especially in a separate compilation setting. 

The parameterization idea that we have described requires 
signatures to be repeated in several places. To simplify program
structure and thereby to provide better documentation, we provide the
ability to accumulate signatures. To include a signature in
another signature or module, a declaration of the
form   
\vspace{-0.25cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+accum_sig  foo.+
\end{tabbing}
\vspace{-0.25cm}
may be used. A wrinkle here is that the signature \verb+foo+ may
contain annotations on predicates that mark them as of an
\verb+exportdef+ kind that may actually need to be complemented in the
accumulating context. The declaration 
\vspace{-0.25cm}
\begin{tabbing}
\qquad\=\kill
\>\verb+use_sig foo.+
\end{tabbing}
\vspace{-0.25cm}
may be used instead in these cases. This declaration also causes the
mentioned signature to be included in place but only after  each 
\verb+exportdef+ declaration is converted to a \verb+useonly+ one.

While predicate definitions will usually be determined entirely by
specific modules either because of annotations of the kind described
in this section or because they pertain to local constants, they can
if needed be distributed across  
interacting modules. This feature has some uses as witnessed by
multifile declarations in Prolog. As another example, 
consider the task of implementing proof relations in different
logics. A common part to all these logics may be the treatment of
propositional rules. This treatment may be isolated in a particular
module named, say, \verb+prop_logic+. A realization of first-order
logic may then accumulate \verb+prop_logic+ and extend the predicates
defined therein. While this ability to extend definitions across
module boundaries is useful, it also raises special problems for
separate compilation as we discuss next.
