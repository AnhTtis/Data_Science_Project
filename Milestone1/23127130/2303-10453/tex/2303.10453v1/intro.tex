\vspace{-0.5cm}

\section{Introduction}\label{sec:intro}

\vspace{-0.25cm}

We are concerned in this paper with a treatment of modularity in logic
programming. Support for this feature is important to significant 
applications of the paradigm. The ability to develop a system
through the composition of small, well-defined units of code is
central to managing complexity and also facilitates
the reuse of programming effort. Moreover, modular development
installs boundaries in programs that can be important to the practical 
use of static analysis techniques and that are fundamental to the
notion of separate compilation and testing. In light of these facts,
it is not surprising that modularity aspects as they pertain to logic
programming have received theoretical treatment
\cite{HP98jlc,Mil89jlp,MP89,SW92}, have been included 
in practical systems \cite{ciao97,sicstus,quintus} and have been the
topic of  standardization deliberations concerning Prolog
\cite{ISO-Prolog-Modules}.  

Modularity notions have typically been incorporated into logic
programming systems by going outside the logical base
and introducing metalinguistic mechanisms for composing separately
constructed program fragments. This approach is a little unfortunate:
a strength of logic programming is its basis in 
logic that, with proper choices, can also be used to reason about
interactions between units of code \cite{Miller93elp}.
\ignore{
\footnote{Logic
can also be in informing particular choices such as those between
``atom-based'' and ``predicate-based'' approaches to hiding as we see
in this paper.}}
However, there is also a danger in focussing too heavily on just the 
logical aspects. Early logic-based approaches to controlling code
availability have, for instance, utilized 
the idea of implications or contexts in goals \cite{Mil89jlp,MP89}. These
mechanisms call for a dynamic management of predicate definitions and,
as such, their implementation is costly. Moreover, the
particular way in which context is handled leads sometimes to 
program behaviour that is counter to the practical understanding
of modularity. 

We describe a treatment of modularity in this paper that balances
logical and pragmatic considerations. This treatment draws on 
experience with a logic based approach \cite{Miller93elp}
employed in the {\it Teyjus} implementation \cite{NM99cade} of the
language $\lambda$Prolog. However, our ideas are quite general and can
be used in any logic programming setting that correctly implements
sequences of alternating existential and universal quantifiers in
goals.\footnote{Such a capability can be added to common logic
programming languages by changing the unification computation 
as indicated later.}
The devices we use are, in fact, surprisingly 
simple at a logical level. To support information hiding, we utilize
existential quantification over names. 
\ignore{; since such names could be those of
predicates and functions in addition to (first-order) constants, the
appropriate context for our ideas is that of a higher-order logic.}
Pragmatically, the hiding of names is effected by associating a 
signature with each module of code; all the names used in the module
and not appearing in the signature are treated as being implicitly
existentially quantified.  The composition of units of code,
accomplished via a mechanism known as {\it accumulation}, translates into the
conjoining of formulas. This leads to a {\it statically determined} 
code space but one in which the availability of predicate definitions
can be controlled by appropriately scoped existential
quantifiers. We show that these simple devices suffice for realizing
features such as scoping of predicate definitions,
data abstraction and module parameterization for which more
complicated dynamic code structuring capabilities were previously
thought to be necessary \cite{Mil89jlp,MP89}. A noteworthy point is
that the often problematic aspect of higher-order programming coexists
{\it completely naturally} with this approach to modularity.  
From a implementation perspective, accumulation can be treated through
a compile-time inlining of code \cite{NT99jflp}. 
However, true modularity requires support for separate compilation.   
Our second contribution consists of showing that this can be provided.  
In particular, we describe a scheme that 
permits each module to be compiled separately with the inlining
function being relegated to a later, link-time process. Although we do
not explicitly demonstrate it here, this two phase process
cumulatively expends effort similar to the compile-time inlining
method and it produces an identical executable image.

The rest of the paper is structured as follows. In the next section we
introduce a logical language that includes all the features needed to
capture our treatment of modularity. In
Section~\ref{sec:modularity-basis} we describe the main components of
the modules language and indicate their translation into the logical
core. The following section discusses usage paradigms and also
some practical embellishments to the basic modules language.
\ignore{
The following
section describes embellishments in the form of annotations or
compiler directives to the basic modules language; these directives do
not affect the translation into logic but can be used to control
acceptability of programs in pragmatically meaningful ways and may
also lead to more efficient implementations. }
In Section~\ref{sec:sep-compilation} we consider the issue of separate
compilation. Section~\ref{sec:conc} concludes the paper by contrasting
its contents with related work.

