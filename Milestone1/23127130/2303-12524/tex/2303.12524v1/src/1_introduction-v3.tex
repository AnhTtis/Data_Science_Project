\section{Introduction}
\label{sec:introduction}

\begin{figure}[t]
\begin{center}
\includegraphics[width=.95\linewidth]{figures/Figure_1.png}
\end{center}
\caption{\textit{The \mname{} framework}: \textit{i)} Determine the saliency-based split point candidates. The inputs are fed into a neural network to extract the saliency maps using the \gradcam{} algorithm at each layer. Then, we average over all the maps to generate the final \textit{Cumulative Saliency} (\cs{}) curve with the candidate split points. \textit{ii)} Simulate each candidate by reproducing its computation and its transmission. \textit{iii)} Use the simulation statistics to find the best-split point satisfying the application constraints on accuracy and latency.}
\label{fig:Schema}
\end{figure}

In the last decade, DNNs achieved state-of-the-art performance in a broad range of problems~\cite{abiodun2018state}, \eg{}, object classification~\cite{zhao2017survey} and feature detection~\cite{li2015survey}, spanning from smart building~\cite{capogrosso2022toward} to healthcare~\cite{skenderi2021dohmo}. The flexibility that makes DNNs such a pervasive technology comes at a price: the computational requirements of some DNNs preclude their deployment on most of the resource-constrained devices available today. A possible alternative is running simplified models, such as MobileNetV2~\cite{sandler2018mobilenetv2}, on the devices; we refer to this scenario as \textit{local-only computing} (LC)~\cite{matsubara2021split}. 
However, using simplified models negatively affects the overall accuracy.
Therefore, the solution that is most widely used to date is usually referred to as \textit{remote-only computing} (RC)~\cite{shi2012serendipity}, which consists in transferring the data captured by the device to a high-performance machine through a communication network and then sending back the results to the device if needed. In this case, the communication network may become a bottleneck and it should be properly configured to match the quality of service requirements of the application. \textit{Split computing} (SC) has been recently proposed~\cite{kang2017neurosurgeon} to divide the DNN model into a ``head'' on the sensing device and a ``tail'' on the remote server: the output of the last layer of the head is transmitted over the communication network as input for the tail.

Therefore, the design of distributed deep learning applications consists in exploring a three-dimensional design space. Indeed, the final implementation will be determined by the choices of the \textit{computation platform}, the \textit{communication architecture}, and the \textit{DNN}.
Whereas the first dimension is deterministic, in the sense that the choice of a specific platform produces certain performances,
%a given choice of platform brings a certain performance, 
dealing with communication networks and DNNs introduces uncertainty. A DNN is a statistical classifier with millions of parameters whose timing is non-deterministic, as it is its efficacy that is usually measured in terms of accuracy. It follows that a given DNN can be evaluated only by training and testing it on some validation partition. Regarding SC scenarios, the situation becomes even harder since the splitting technique typically requires specific training~\cite{matsubara2022bottlefit}, while manipulating diverse SC configurations requires days~\cite{matsubara2021split}.

%Where to split a DNN is not a trivial task~\cite{hu2020fast}: different parameters have to been to take into account, such as computational time, transmission topology, protocol, and accuracy. In general, for each split configuration, the designer has to retrain the whole distributed framework and redo the testing step on the validation data partition.

This work shows that the optimal split point to match the quality of service (QoS) requirements of an application depends on the \textit{saliency} of the network layers. %For the first time ever, 
This idea lowers the design and deployment time from days to hours, offering a %precious 
practical developing framework grounded on a solid theory. 
%In simple words, 
Each layer interrogates its input about specific signal properties, such as the shape of the objects contained in an image. Some of the properties are crucial (\ie{}, \textit{salient}) for the final classification. For example, if a DNN has to recognize different shapes, the information flows have to be preserved until the shape layer; after that, a split can be carried out. 

As a major result, this work shows that split locations must account not only for \textit{dense}~\cite{sbai2021cut} but also for \textit{informative} data. The rationale is to use a saliency-based splitting point search~\cite{cunico2022split} to preserve the portions of the network where crucial decisions are taken. We further generalize the theory in~\cite{cunico2022split}. Then, on top of the theory, we propose \mname{}\footnote{\url{https://github.com/luigicapogrosso/split_et_impera}} (Figure~\ref{fig:Schema}): a fast and user-friendly framework that eases the design of a distributed architecture executing one or more DNNs. Other than accurately mimicking diverse communication protocols and application requirements, \mname{} introduces a unique feature: it suggests the proper configuration to match the application's QoS requirements and provide optimal performance in terms of accuracy and latency time. Furthermore, since manipulating diverse SC configurations may require days of computation, \mname{} allows eliminating several configurations through communication-aware simulations. 

\mname{} has been applied to simulate a classification task within a real Industry 4.0 scenario, using the LC, RC, and SC settings. It allows finding a set of possible split points for DNNs and deciding which is the best design to match the QoS requirements through a simulation. Furthermore, we used \mname{} to evaluate the application design and transmission protocol selection by modeling the application's transmission details. Experiments show the effectiveness of the proposed frameworks.

%The paper is organized as follows. Section~\ref{sec:related} shows some background. Section~\ref{sec:saliency} describes the saliency-based split point search while Section~\ref{sec:simulator} presents the simulation architecture of \mname{}. Section~\ref{sec:experimental} shows experiments on the potentiality of the tool. Finally, conclusions are drawn in Section~\ref{sec:conclusions}.
