
\section{Fidelity derivation}\label{sec:derivation}

Here, we use algorithms to generate the analytical expressions of \cref{eq:withoutpurificaiton} and \cref{eq:SsDpFidelity} coded in \texttt{python} using \texttt{sympy} and \texttt{pandas} for visualization. The algorithms combinatorically calculates the probability of all possible combinations of depolarizing errors that could occur on qubits to be used in operations. With probabilities of all combination calculated, additional operations are performed such as entanglement purification. Finally, the probabilities of scenarios that will result in an expected Bell pairs are summed together and normalized by the summation of the probabilities of all events of interest. The result is effectively the fidelity of a Bell pair. Please refer to our \url{https://github.com/PorametPat/qwanta/blob/main/experiments/exp_id4_QubitModule/exp_id4_Purification.ipynb} for codes and results. 

\section{Details of simulation}\label{subsec:simulation}

To simulate the complex behavior of the quantum network, time delay and resource management, we use \texttt{SimPy}, the discrete-event simulation package written in Python. For noise simulation, as large quantum systems needed to be simulated, similarly to Stabilizer formalism, we use error-basis model \cite{Satoh2021} which collects only the information about the noise of each qubit thus allow us to efficiently simulate the system. Although this is not the representation of a quantum state, the choice is preferred as it is relatively easier to implement and the information of the noise is enough to be used for the fidelity discussed in \cref{subsec:FidelityEvaluation}.

In the following, we explain the implementation of operation in quantum network in our discrete-event simulator. Entanglement whether physical or logical Bell pair is referred to as a resource. We categorize operations in quantum networks into the elementary process as described in detail below.   %\PCc{what is the purpose of the word 'now'? Would it be beter using more generic tone like "In our work we expand the implementation of....."}

% Explain each process
 % 1. Generate physical resource
\emph{Generate physical resource} Generation of physical resource or link-level entanglement generation is a process that takes two external physical qubits from adjacent nodes and creates a Bell pair. Consider Node 1 and Node 2, after the \emph{Emitter} sub-process receives a fresh physical qubit from each node. We assume that the qubit $q_1$ at Node 1 will emit a photon qubit to the Bell state analyzer (BSA) at Node 2. $q_1$ is initialized (setting time reference to the beginning of the simulation), and the time required for light to travel from Node 1 to Node 2, $t_{\text{delay}}$, is calculated and used to delay the next step. The BSA is incorporated into one of the nodes, so that photons are traveling the link distance in only one direction. This architecture is referred to as "memory-memory" (MM) link~\cite{jones2016design}. In the following sub-process, \emph{Qubit} $q_2$ is initialized, and it emits a photon to its BSA. The probability of detecting both photons, $p_{\text{success}} = 10^{-\xi\cdot d/10}$, is used to determine the link-generation result, where $\xi$ is loss measured in unit of \si{\dB/\km}, and $d$ is the relative distance in \si{km} between Node 1 and Node 2. The result is then sent from the Node sub-process to  Node 1, which will delay the next step by $t_{\text{delay}}$ in a form of classical message. If the attempt is success, the depolarizing channel as describe in \cref{eq:depolarizingChannel} will applied to both matter qubits, and those two qubits will be registered as a physical Bell pair for other subsequent processes. On the other hand, if the attempt fails, both qubits are reset, and put back for subsequent attempts. 

% 2. Generate logical resource
A process for generating logical Bell pairs is \emph{Generate logical resource}. There are two approaches to generating logical Bell pairs. One method is to use non-local CNOT gates to perform logical CNOT gates on both logical qubits at each node. To perform a non-local CNOT gate in this method, we need seven physical Bell pairs. After acquiring seven physical Bell pairs and seven qubits to encode logical qubits on each node, the protocol begins, where the logical qubits are initialized at each node. At Node 1, the CNOT gates are performed using each physical qubit as a control and one end of the physical Bell pair as a target; this end of the physical Bell pairs are measured in the $Z$ basis, and then measurement results are send to Node 2 with time delay $t_{\text{delay}}$. With measurement results, error is propagate and correction operator is perform with probability of $1/2$. At Node 2, CNOT gates are performed with a qubit from a Bell pair as a control qubit and physical qubit used for encoding logical qubit as a target qubit, on control qubit, Hadamard gates are performed then, measuring in Z-basis. Measurement results are sent, inducing a delay of $t_{\text{delay}}$, with measurement results, errors are propagate and correction operators are perform with probability of $1/2$ each. The qubits composing Bell pairs used for this process are then reset and returned to be used later. The logical Bell pair is then registered as a new logical resource shared between Node 1 and Node 2. Another method uses one physical Bell pair as an input for logical qubit encoding, and the two logical qubits will result in a logical Bell pair. After getting one physical Bell pair shared between Node 1 and Node 2, and the six physical qubits for encoding from each node, the encoding process starts. Each node will use one-end of the Bell pair and six physical qubits to encode the logical qubit. The resulting logical Bell pair will be registered as a new logical resource. 
% 3. Purification
\emph{Entanglement Purification} is a process that purifies one physical Bell pair referred to as a resource pair with auxiliary Bell pairs. We use the Ss-Dp purification protocol \cite{matsuo2019quantum, Matsuo2019, fujii2009entanglement} which requires two auxiliary Bell pairs. After getting three physical Bell pairs at each node, we apply CNOT using a resource qubit as a control and the first auxiliary qubit as a target, then we apply CNOT using the second auxiliary qubit as a control and a resource qubit as a target. We then measure the first auxiliary qubit in the $Z$ basis and the second auxiliary qubit in the $X$ basis, and the measurement result will be shared to determine the next step. If measurement result from both qubits of the pair agree, then the resource pair is accepted as a purified resource, and is registered in the resource pool. Also, the auxiliary qubits are reset and returned to the fundamental pool. Otherwise, all qubits are reset and put back in the fundamental pool. 
        
% 4. Entanglement swapping
%\naphann{It seems to me that the correction operations are only applied at the end nodes as mentioned in~\ref{subsec:theoryPOV} , so it is not clear to me about the waiting time differences between each strategy. I think it should be mentioned a little clearer here.} \PP{Added in the bottom.}
\emph{Entanglement swapping} is a process that creates a Bell pair from two Bell pairs. In this situation, we assume that Node 1 shares a Bell pair with Swapper, and Swapper shares a Bell pair with Node 2. After getting two Bell pairs, one from each node, we perform the following step, depending on whether the logical Bell pair or physical Bell pair is received. For a physical Bell pair, Swapper proceeds to change the measurement basis for each qubit from each pair to a Bell basis with CNOT and Hadamard gate. Swapper then measures both qubits in the $Z$ basis, and returns the measured qubits to the fundamental resource. For a logical qubit, each node will request six qubits for syndrome measurement, and we perform quantum error correction (QEC) on both logical qubits, once before and one after the application of CNOT gate. QEC is performed again on the logical qubit after the Hadamard gate is applied, but we do not apply QEC on another logical qubit. Both qubits are then measured in the $Z$ basis. After acquiring the measurement results, the delay induced is the time for sending a classical message to Node 1 and Node 2. However, only the longer time delay will be used in a subsequent process. As errors can propagate from measurement results, correction operators are performed assuming that four possible combination measurement results are equally likely. The correction and error propagation is done only to qubits in Node 2. After the correction, a new logical Bell pair will then be registered in the resource pool.
%\PP{I added the following to clarify the process further.} 
Regarding the swapping strategy used, we implement a round-based approach. For 2 hops, we need only one entanglement swapping, the strategy is trivial. For 4 hops, in the first stage, we perform entanglement swapping on nodes (0, 1, 2) and nodes (2, 3, 4) simultaneously, and then in the second stage, Bell pairs from the first stage are used to perform entanglement swapping on node (0, 2, 4). Lastly, for 8 hops, in the first stage, we perform protocol on (0, 1, 2), (2, 3 ,4), (4, 5, 6), (6, 7, 8), Bell pairs produced are used for second stage on nodes (0, 2, 4) and (4, 6, 8), then final stage with nodes (0, 4, 8). We also note that this entanglement swapping is implemented for all memory qubits only. For entanglement swapping of memory-photon Bell pairs is already done via measurement using BSA. 
        
% 5. Fidelity estimation
\emph{Fidelity estimation} is a process which uses many Bell pairs to estimate the fidelity of a resulting qubit with a Bell state. The process uses one Bell pair at a time, where the measurement results will be stored and used to calculate the fidelity after number of measurements required, $n_\text{meas}$, is reached. After acquiring a Bell pair, if it is a logical Bell pair, we perform the following step. Each node requests six auxiliary qubits and uses QEC. After syndrome measurement, the auxiliary qubits will be reset and returned to the fundamental pool. We measure each qubit in each basis in the following order, $XX, YY, \text{and } ZZ$ for $\lfloor n_\text{meas}/3 \rfloor$ each. After measurement, qubits are reset and put back in the fundamental pool. If the measurement occurs $n_\text{meas}$ times, then the fidelity is calculated as described in section \cref{subsec:FidelityEvaluation}.
We used the \texttt{dill} package \cite{McKerns2010Pathos:Computing, McKerns2012BuildingScience} for saving and loading data in our simulation.

% \subsection{Fidelity Derivation for 0G}

% \begin{lstlisting}[language=Python, caption=Code for generation of look-up table and equation derivation of simple Bell pair passing through depolarizing channel, label={code:0GEquation}]

% import numpy as np
% import pandas as pd
% from sympy import symbols

% Paulis = ['I', 'X', 'Y', 'Z']

% possible_error = []
% for pauli_1 in Paulis:
%     for pauli_2 in Paulis:
%         possible_error.append(''.join([pauli_1, pauli_2]))
        
% results = []
% p = symbols('p')
% for error in possible_error:

%     tmp = {}

%     Bell00, Bell01 = GetQubit(), GetQubit()
%     qubitList = [Bell00, Bell01]

%     # Apply error to qubit
%     prob = 1
%     for index, (e, q) in enumerate(zip(error, qubitList)):
%         if e == 'X':
%             q.addXerror()
%         if e == 'Y':
%             q.addXerror()
%             q.addZerror()
%         if e == 'Z':
%             q.addZerror()
%         if e == 'I':
%             prob *= 1 - p
%         else:
%             prob *= p/3
%         tmp[f'q{index}'] = e

%     # Record result
%     tmp['probability'] = prob

%     # Check each basis
%     is_Bell = True
%     # Z-basis
%     if Bell00.error_x != Bell01.error_x:
%         is_Bell = False

%     # X-basis
%     if Bell00.error_z != Bell01.error_z:
%         is_Bell = False

%     # Y-basis
%     if (Bell00.error_x != Bell00.error_z) != (Bell01.error_x != Bell01.error_z):
%         is_Bell = False


%     tmp['is Bell'] = is_Bell

%     results.append(tmp)

% probabilities = pd.DataFrame(results)

% fidelity = sum( probabilities.loc[probabilities['is Bell'] == True]['probability'] )

% \end{lstlisting}

% \subsection{Fidelity Derivation for Ss-Dp Protocol}
% \begin{lstlisting}[language=Python, caption=Code for generation of look-up table and equation derivation of Bell pairs passing through depolarizing channel and performing Ss-Dp purification protocol, label={code:1GEquation}]
% Paulis = ['I', 'Z', 'X', 'Y']

% possible_error = []
% for pauli_1 in Paulis:
%     for pauli_2 in Paulis:
%         for pauli_3 in Paulis:
%             for pauli_4 in Paulis:
%                 for pauli_5 in Paulis:
%                     for pauil_6 in Paulis:
%                         possible_error.append(''.join([pauli_1, pauli_2, pauli_3, pauli_4, pauli_5, pauil_6]))
                        
% results = []
% F = symbols('F')
% Prob_list = {
%     'II': F, 'IX': (1 - F)/3, 'IY': (1 - F)/3, 'IZ': (1 - F)/3, 
%     'XX': F, 'XI': (1 - F)/3, 'XY': (1 - F)/3, 'XZ': (1 - F)/3, 
%     'YY': F, 'YI': (1 - F)/3, 'YX': (1 - F)/3, 'YZ': (1 - F)/3, 
%     'ZZ': F, 'ZI': (1 - F)/3, 'ZY': (1 - F)/3, 'ZX': (1 - F)/3, 
% }
% for error in possible_error:

%     tmp = {}

%     Bell00, Bell01, Bell10, Bell11, Bell20, Bell21 = GetQubit(), GetQubit(), GetQubit(), GetQubit() , GetQubit(), GetQubit()
%     qubitList = [Bell00, Bell01, Bell10, Bell11, Bell20, Bell21]
    
%     # Apply error to qubit
%     prob_Bell = 1
%     e_com = ''
%     for index, (e, q) in enumerate(zip(error, qubitList)):
%         if e == 'X':
%             q.addXerror()
%         if e == 'Y':
%             q.addXerror()
%             q.addZerror()
%         if e == 'Z':
%             q.addZerror()

%         tmp[f'q{index}'] = e

%         e_com += e
%         if index % 2 == 1:
%             # Reset prob
%             prob_Bell *= Prob_list[e_com]
%             e_com = ''

%     # Ss-Dp purification
%     Bell10.CNOT_gate(Bell00)

%     Bell11.CNOT_gate(Bell01)

%     Bell00.CNOT_gate(Bell20)
%     Bell01.CNOT_gate(Bell21)

%     resX1 = Bell10.measureZ()
%     resX2 = Bell11.measureZ()

%     resZ1 = Bell20.measureX()
%     resZ2 = Bell21.measureX()

%     # Record result
%     tmp['probability'] = prob
%     tmp['purification result'] = 'Success' if (resX1 == resX2) and (resZ1 == resZ2) else 'Fail'
%     tmp['probability Bell'] = prob_Bell

%     is_X = False
%     is_Z = False 

%     # Check each basis
%     is_Bell = True
%     # Z-basis
%     if Bell00.error_x != Bell01.error_x:
%         is_Bell = False
%         is_X = True

%     # X-basis
%     if Bell00.error_z != Bell01.error_z:
%         is_Bell = False
%         is_Z = True

%     # Y-basis
%     if (Bell00.error_x != Bell00.error_z) != (Bell01.error_x != Bell01.error_z):
%         is_Bell = False

%     tmp['is Bell'] = is_Bell

%     if is_X and is_Z:
%          tmp['Bell'] = 'psi-'
%     elif is_X:
%         tmp['Bell'] = 'psi+'
%     elif is_Z:
%         tmp['Bell'] = 'phi-'
%     else:
%         tmp['Bell'] = 'phi+'

%     results.append(tmp)

% probablities = pd.DataFrame(results)

% # Summation of probabilities of interested events
% normalizer = sum(probablities.loc[probablities['purification result'] == 'Success']['probability Bell'])

% # Summation of probabilities that resulting in expected Bell pair
% Bell_event = sum(probablities.loc[(probablities['purification result'] == 'Success') & (probablities['is Bell'] == True)]['probability Bell'])

% # Thus the fidelity is then, 
% fidelity_Bell = Bell_event / normalizer

% \end{lstlisting}
