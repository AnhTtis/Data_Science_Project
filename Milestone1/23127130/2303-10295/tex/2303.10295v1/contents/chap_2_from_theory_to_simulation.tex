\section{From Theory to Simulation} \label{section:fromTheoryToSimulation}

%\PP{Discuss about method to distribute Bell pair in the literature. Quantum repeater is categorized into three generation as in [Muralidharan2016]. This should softly introduce noises in quantum network. Each generation will be briefly discuss, 0G will introduce entanglement swapping. Then 1G will introduce entanglement purification along with the protocol that we will used in the work, Ss-Dp. 2G will introduce with Quantum error correction, stressing on Steane code as we use this code in the work. From the needed to simulate large among of qubit, we discuss our method via error-basis model, show noise channel and evaluation against analytical expression.}

In this section, we briefly introduce the essential elements used in a quantum network. 
We then discuss the error models we used and verify the output of our simulation by comparing it with analytically derived expressions for simple scenarios.

\subsection{Quantum Network: Theoretical Framework}\label{subsec:theoryPOV}

While it is possible to distribute Bell pairs directly via optical fiber, it is not efficient since the probability of success decreases exponentially as the distance increases.
This exponential attenuation can be overcome by the use of a quantum repeater~\cite{Briegel1998}.
This way, Bell pairs need only be distributed over short distances connecting individual repeaters.
The main function of a quantum repeater is then to splice this link-level entanglement into entangled states shared between far-away nodes in the network through entanglement swapping, as well as managing the inevitable operational errors via purification or quantum error correction. We will now give a brief overview of these basic functions of a quantum repeater.

% A quantum repeater, proposed in~\cite{Briegel1998}, is an intermediate quantum node placed between two destination nodes.
% Each end node first shares matter-matter Bell pairs with a quantum repeater; then the Bell measurement is performed on the qubits at the repeater to produce long-range Bell pair between the two end nodes. Unfortunately, photon loss and decoherence are not all the noise that exist in the system; a quantum network also suffers from quantum gate errors, measurement errors, and depolarizing noise in a quantum channel. To tackle the problems, a network of quantum repeaters is extended and categorized into first generation (1G), second generation (2G) and third generation (3G) with different configurations to minimize errors and maintain high fidelity, as proposed in \cite{muralidharan2016optimal}. Before proceeding to state the precise description of each generation of quantum repeaters, we will first briefly discuss an entanglement swapping protocol as it is used in both 1G and 2G network of quantum repeaters.

\textit{Entanglement Swapping} is a form of quantum teleportation where the entanglement between a pair of qubits is transferred to a new qubit.
It can be demonstrated on a simple example of two Bell pairs, one shared between qubits A and B, and the other between qubits C and D, respectively.
Measurement of qubits B and C in the Bell basis will project previously independent qubits A and D onto one of the maximally entangled state.
The randomness of the measurement outcome can be compensated by applying a correction operator conditioned on the two classical bits representing the measurement results.

Entanglement swapping is at the heart of the entanglement-splicing function of a quantum repeater as pictured in~\cref{fig:LinearChain}.
Two end nodes, here referred to as the Source and Destination nodes, can share an entangled Bell pair with the aid of a chain of $n$ repeaters.
The qubit that is held by the Source node's qubit is labeled as $l$, while the Destination node's qubit is labeled as $r$.
Repeater $i$ is in possession of at least two qubits, labeled as $a_i$ and $b_i$, respectively.
Each repeater measures its two qubits in the Bell basis, producing two classical bits, which we also label as $a_i$ and $b_i$.
The total correction needed to be applied by either the Source node or the Destination node is then $\Pi_i X^{b_i}Z^{a_i}$, which can be simplified by further use of the anticommutation property of the Pauli matrices $XZ=-ZX$. However, our implementation of entanglement swapping is not simultaneously executed, but in a round-based approach; please refer to \ref{subsec:simulation}.

% In the simplest case where $n = 1$, two Bell pairs and three quantum nodes will involve in the protocol. To have the initiator node (A) share a Bell pair with the responder node (C), the intermediate node (B) performs BSM on two qubits from each Bell pair that it holds. Measurement results $a_{1} \text{and } b_{1}$ are then sent to the initiator or responder nodes, which inform the end node of which operation is needed to perform on the qubit in order to correct the state to the Bell state.

In reality, distributed Bell pairs will be affected by various types of noise.
Assuming that the probability of any of the Pauli matrices affecting the entangled state is equal, the distributed state of fidelity $F$ can be written as
\begin{equation}
    \label{eq:densityBell}
    \rho = F \dya{\Phi^{+}} + \frac{1 - F}{3} (\dya{\Phi^{-}} + \dya{\Psi^{+}} +\dya{\Psi^{-}}),
\end{equation}
where $|\Phi^{\pm}\rangle = (|00\rangle \pm |11\rangle) / \sqrt{2}$,  $|\Psi^{\pm}\rangle = ( |01\rangle \pm |10\rangle) / \sqrt{2}$.
Performing entanglement swapping on two such mixed states, shared between qubit pairs A-B and C-D with fidelities $F_{AB}$ and $F_{CD}$, respectively, will result in a mixed state shared between the qubits A-D with fidelity \cite{doi:https://doi.org/10.1002/9781118648919.ch10}
\begin{equation}
    \label{eq:fidelityES}
    F_{AD} = F_{AB}F_{CD} + \frac{(1 - F_{AB})(1 - F_{CD})}{3}.
\end{equation}
% Assuming only Pauli noise, the density matrix of Bell pair can be expressed in terms of the Bell basis as Werner state, 
%     \begin{equation}
%         \label{eq:densityBell}
%         \rho = F \dya{\Phi^{+}} + \frac{(1 - F)}{3} (\dya{\Phi^{-}} + \dya{\Psi^{+}} +\dya{\Psi^{-}}),
%     \end{equation}
%     where $|\Phi^{\pm}\rangle = 1/\sqrt{2} |00\rangle \pm |11\rangle$,  $|\Psi^{\pm}\rangle = 1/\sqrt{2} |01\rangle \pm |10\rangle$ and $F$ is a probability of each Bell basis.
% After the entanglement swapping protocol, the fidelity of the resulting Bell pair using Bell pair as described in \cref{eq:densityBell} is
%     \begin{equation}
%         \label{eq:fidelityES}
%         F_{AC} = F_{AB}F_{BC} + \frac{(1 - F_{AB})(1 - F_{BC})}{3},
%     \end{equation}
%     where $F_{AB}$ and $F_{BC}$ are the fidelity of quantum channel between the pair of initiator and intermediate nodes $(AB)$, and that of the intermediate and responder nodes $(BC)$, respectively. They are also the probability of the $|\Phi^{+}\rangle$ state as in \cref{eq:densityBell}.
    
    % For situation in \cref{fig:LinearChain}, the entanglement swapping can be optimized by letting every intermediate node do BSM independently and/or simultaneously \cite{jiang2009quantum}. However, the correction operation is needed, as described in the following the equation
    % \begin{equation}
    %     |\Phi^{+}\rangle = \Pi^{n}_{i = 1} I\otimes X^{b_{i}}Z^{a_{i}}|l,r\rangle.
    % \end{equation}
    % The correction operation can be further optimized by using the identity $XZ = -ZX$, which reduces the possible correction operations to $I, X, Z, \text{and } XZ$. The optimization algorithm is easily as bit-wise XOR between consecutive correction operators.
    \begin{figure}
        \centering
        % \includegraphics[width=\columnwidth]{contents/linear-chain-2.pdf}
        \includegraphics[width=0.9\columnwidth]{contents/figures/fig2-entanglement-swapping.pdf}
        \caption{Linear chain of quantum repeaters from the source (initiator) node to the destination (responder) node. The figure uses icons proposed in Ref.~\cite{9951258} with permission.}
        \label{fig:LinearChain}
    \end{figure}

\textit{Entanglement Purification:} We now turn our attention to how quantum repeaters manage errors.
We begin with 1G quantum repeaters which use entanglement purification \cite{dur1999quantum, Deutsch1996} to detect errors affecting the entangled states.
If no error is detected, our confidence in the state's quality increases leading to improved fidelity.
We use the single selection, double purification (Ss-Dp) protocol \cite{fujii2009entanglement,matsuo2019quantum, Matsuo2019} where three Bell pairs are required for this protocol, as depicted in Fig.~\ref{fig:error_management}(a).
One auxiliary Bell pair is used to measure information about the Pauli $X$ error, and another one for measuring the Pauli $Z$ error.

\textit{Quantum Error Correction:} 2G and 3G quantum repeaters rely on quantum error correction to both detect and correct errors.
We use the $[[7, 1, 3]]$ Steane code \cite{Steane1996}, which uses seven physical qubits to encode one logical qubit.
%, and can independently correct the Pauli $X$ and Pauli $Z$ errors using 3 additional qubits each.
The Steane code is a stabilizer code \cite{Gottesman97} which has a set of stabilizer generators given as follows: $g_1 = XIXIXIX$, $g_2 = IXXIIXX$, $g_3 = IIIXXXX$, $g_4 = ZIZIZIZ$, $g_5 = IZZIIZZ$, $g_6 = IIIZZZZ$ and logical operators $\Bar{X} = XXXXXXX$, and $\Bar{Z} = ZZZZZZZ$.
Measuring these generators results in an error syndrome which identifies an error on the physical qubits.
We denote the physical qubits of a logical qubit $A$ by lower case $a_i$ where $i=1,...,7$. One important feature of the Steane code is that the logical Clifford gates can be implemented transversally; logical Hadamard and logical $S$ gates can be implemented by applying corresponding physical gates on all physical qubits, while a logical CNOT gate, $\text{CNOT}(A,B)$, can be implemented between two blocks of code by applying physical $\text{CNOT}(a_i,b_i)$ between all seven pairs of physical qubits.

%As the Steane code belongs to the CSS code family \cite{CSS}, the syndrome measurements of $Z$ and $X$ errors can be performed simultaneously.\TT{How? Isn't this true for any stabilizer code?}

As the Steane code belongs to the CSS code family \cite{Steane1996, CSS}, one can correct an $X$-type (or a $Z$-type) error using only the measurement results obtained from $Z$-type (or $X$-type) generators. In this work, the error syndrome is obtained by measuring all generators concurrently using three auxiliary qubits per type, hence six auxiliary qubits in total. Figure~\ref{fig:error_management}(b) shows an example of stabilizer generator $g_3$.
Simultaneous generator measurements can be beneficial to a matter qubit which requires long measurement and re-initialization time, as one does not need to reset the qubit between each generator measurement. However, the process comes with the cost of additional auxiliary qubits. Once the error syndrome is obtained, quantum error correction can be done by applying a Pauli operator corresponding to the syndrome to the physical qubits. The quantum error correction is performed before and after each logical quantum gate.

%Hence, it is beneficial to a matter qubit, which requires long measurement and re-initialization time, in the sense that one does not need to reset the qubit after one syndrome measurement before the other with the cost of requiring additional auxiliary qubits. 

%In this work, we apply a syndrome measurement to detect the $X$ and $Z$ errors simultaneously using six auxiliary qubits in total. The error correction is performed before and after each logical quantum gate.

%The measurement readout of a logical qubit using the Steane code can be obtained in a number of ways~\cite{devitt2013quantum}. One approach is to apply a decoding operation to the logical qubit and measure the input qubit as shown in \cref{fig:measurement_1} \TT{output qubit?} \PP{Should be clear from the figure}, which represents the readout of the logical qubit. The second approach is to use one auxiliary qubit where physical CNOT gates are applied on each encoded physical qubit targeting the auxiliary qubit. The second approach is to use one auxiliary qubit and apply physical CNOT gates between all physical qubits and the auxiliary qubit, see \cref{fig:measurmenet_2}\TT{The second approach is to use one auxiliary qubit and apply physical CNOT gates between all physical qubits and the auxiliary qubit, see Fig.} \PP{Added} The measurement readout of the logical qubit is then extracted from measuring the auxiliary qubit where 0 and 1 corresponding to logical 0 and 1.\TT{where +1 and -1 correspond to ...} \PP{Added}. Another approach as shown in \cref{fig:measurement_3} is simply to measure all encoded physical qubits, where the measurement result should be one of the codewords depending on the logical state.\TT{depending on the logical state} \PP{Added} The last approach is preferred in our simulation since applying a decoder might induce errors during the operation. Furthermore, the Steane code as a CSS code inherits a parity check from the classical error correction, so that one can adopt a parity matrix to detect and correct a bit-flip error on the readout result. In our work, we perform syndrome measurement before the measurement on a logical qubit and perform classical error correction after measurement. However, it should be pointed out that this procedure is not fault-tolerant. \TT{Should add figures that compare these three approaches} \PP{Added} \michal{[Do we need a detailed description of all 3 approaches? We are only using the last one.]}

The measurement readout of a logical qubit using the Steane code can be obtained in a number of ways~\cite{devitt2013quantum}.
In this work, a logical qubit measurement in an $X, Y,$ or $Z$ basis is done by measuring all physical qubits in the corresponding Pauli basis.
If there is no error on the physical qubits and the measurements are perfect, the bitstring of measurement outcomes will be one of the codewords of the $[7,4,3]$ classical Hamming code, thus the logical state can be found by applying classical decoding to the bitstring.
On the other hand, if there is an error on one physical qubit or a single-qubit measurement error (but not both), the bitstring of measurement outcomes will differ from a codeword of the $[7,4,3]$ classical Hamming code by one bit.
In this case, the logical state can be obtained by applying classical error correction to the bitstring followed by classical decoding.
Here we also perform quantum error correction before each logical qubit measurement. The whole procedure is illustrated in \cref{fig:error_management}(c).
However, it should be pointed out that this procedure is not fault tolerant. This means that any errors, including memory errors, errors arising from faulty gates, and measurement errors, can propagate to other qubits depending on the subsequent operations.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\textwidth]{contents/figures/fig3_error_management.pdf}
    \caption{(a) 1G repeaters use entanglement purification as a form of error detection. We make use of the Ss-Dp protocol that requires two ancillary Bell pairs to check whether the original Bell pair is affected by $X$ or $Z$ Pauli errors. (b) Example of a syndrome measurement of the stabilizer generator $g_3=IIIXXXX$. (c) The full procedure to measure a logical qubit. The measurement basis of the logical qubit depends on the measurement basis of the physical qubits.}
    \label{fig:error_management}
\end{figure}

% Quantum circuit example using Qcircuit package
% \begin{figure}
%     \centering
%     $\begin{array}{c}
%     \Qcircuit @C=1em @R=1em {
%         \lstick{\ket{1}} & \targ & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{1}} & \ctrl{-1} & \rstick{\ket{1}} \qw
%     }
%     \end{array}$
%     \caption{Caption}
%     \label{fig:my_label}
% \end{figure}

% \begin{figure}
%      \centering
%      \begin{subfigure}[b]{0.45\textwidth}
%          \centering
%          $\begin{array}{c}
%     \Qcircuit @C=1em @R=1em {
%         \lstick{\ket{\psi}} & \multigate{6}{\text{encode}} & \multigate{6}{\text{decode}}  & \meter  \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \ghost{\text{decode}} & \rstick{\ket{0}} \qw \\
%         % \lstick{\txt{bit}} & \cw & \cw & \cw
%     }
%     \end{array}$
%          \caption{}
%          \label{fig:measurement_1}
%      \end{subfigure}
%      \hfill
%      \begin{subfigure}[b]{0.45\textwidth}
%          \centering
%     $\begin{array}{c}
%     \Qcircuit @C=1em @R=1em {
%         \lstick{\ket{\psi}} & \multigate{6}{\text{encode}}  & \meter  \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\ 
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \meter \\
%     }
%     \end{array}$
%          \caption{}
%          \label{fig:measurement_3}
%      \end{subfigure}
%      \hfill
%      \begin{subfigure}[b]{0.9\textwidth}
%          \centering
%           $\begin{array}{c}
%     \Qcircuit @C=1em @R=1em {
%         \lstick{\ket{\psi}} & \multigate{6}{\text{encode}} & \ctrl{7} & \qw & \qw & \qw & \qw & \qw & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \ctrl{6} & \qw & \qw & \qw & \qw & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \qw & \ctrl{5} & \qw & \qw & \qw & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \qw & \qw & \ctrl{4} & \qw & \qw & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \qw & \qw & \qw & \ctrl{3} & \qw & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \qw & \qw & \qw & \qw & \ctrl{2} & \qw & \qw \\
%         \lstick{\ket{0}} & \ghost{\text{encode}} & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{1} & \qw  \\
%         \lstick{\ket{0}} & \qw & \targ & \targ & \targ & \targ & \targ & \targ & \targ & \meter
%         % \lstick{\txt{bit}} & \cw & \cw & \cw
%     }
%     \end{array}$
%          \caption{}
%          \label{fig:measurmenet_2}
%      \end{subfigure}
%         \caption{The measurement readout approaches of logical qubit encoded using Steane code. (a) The first logical measurement approach: By apply decode block define as a complex conjugate of encoding block. The measurement readout of the logical qubit could be extracted by measuring the input qubit. (b) The third logical measurement approach: One could simply measure all physical qubits used to encode logical qubit. The logical readout could be obtained by decoding the measurement results using the classical method. If there is an error, it should be detected and correct via the classical decoding sequence. (c) The second logical measurement approach: By using one auxiliary qubit, and applying CNOT gates between encoding physical qubits targeting auxiliary qubit, measurement readout of logical qubit could be obtained by measuring auxiliary qubit. Where the 0 and 1 corresponding to logical readout 0 and 1.}
%         \label{fig:measurement}
% \end{figure}


% \TT{Suggestions for the QEC part: (1) Define the Steane code as a stabilizer code (e.g., generators, logical operators). (2) Explain syndrome measurements and QEC procedure. May display some circuits. Point out that this process is not fault tolerant. (3) Explain why the Steane code helps (may show fidelity improvement under depolarizing noise). (4) On logical qubit readout, should also mention the measurement method that uses ancilla qubits. (5) Add more details in the appendix if needed.}



    
\subsection{Error Models and Assumptions} \label{sec:ErrorModelAssumption}

We now provide details of the error models used in our work. Our design and assumptions of the error propagation follow those in Ref.\cite{Satoh2021}, which tracks information about whether a qubit has been affected by a Pauli $Z$ and/or $X$ error along with a time stamp when it was initiated.
We now summarize the error sources which contribute towards the degradation of the fidelity of the end-to-end entangled state.

We begin by considering the link-level entanglement distribution involving the entanglement swapping of two light-matter Bell pairs that results in a matter-matter Bell pair.
The \emph{depolarizing channel} is applied to each matter qubit, where the depolarizing action on a quantum state $\rho$ is defined as
    \begin{equation}\label{eq:depolarizingChannel}
        % Depolarizing error
        \mathcal{E}_{\text{depo}}(\rho) = (1 - p_{\text{depo}}) \rho + \frac{ p_{\text{depo}}}{3} (X\rho X^{\dagger} + Y\rho Y^{\dagger} + Z\rho Z^{\dagger}),
    \end{equation} 
where $p_{\text{depo}}$ denotes a depolarizing error probability.

% Gate error
\emph{Gate error} is implemented in the form of a depolarizing channel acting on the qubit with the probability controlled by the parameter $\lambda_{\text{gate}}$. For a single-qubit gate $G_1$, the quantum channel with gate errors acting on $\rho$ was implemented as

%Likewise, \emph{gate error} is also implemented in the form of depolarizing channel acting on a qubit with probability $p_{\text{gate}}$, and $P_i$ are Pauli matrices. For a single-qubit gate $G_1$, the gate error on $\rho$ is defined as
    \begin{equation} \label{eq:oneQubitChannel}
        % One qubit gate error channel
        \mathcal{E}_{1}(\rho) = (1 - \lambda_{\text{gate}})G_1 \rho G_1^{\dagger} + \frac{\lambda_{\text{gate}} }{4}\sum_{i\in\{I, X, Y, Z\}} P_{i} G_1\rho G_1^{\dagger}P_{i}^{\dagger},
    \end{equation}
where $P_i$ represents Pauli operators. Similarly, the quantum channel for a two-qubit gate $G_2$ with gate errors acting on $\rho$ is defined as
\begin{equation} \label{eq:twoQubitChannel}
        % Two qubit gate error channel
        \mathcal{E}_{2}(\rho) = (1 - \lambda_{\text{gate}})G_2 \rho G_2^{\dagger} + \frac{\lambda_{\text{gate}} }{16}\sum_{i, j\in\{I, X, Y, Z\}} (P_{i}\otimes P_{j}) G_2\rho G_2^{\dagger}(P_{i}^{\dagger}\otimes P_{j}^{\dagger}).
\end{equation}    
We use a single parameter $\lambda_{\text{gate}}$ to control the error rates for both single- and two-qubit gates.
Our implementation takes into account the fact that two-qubit gates usually have higher error rates.
A given value of $\lambda_{\text{gate}}$ results in the single-qubit gate error rate of $p_1 = \frac{3 \lambda_{\text{gate}}}{4}$ and the two-qubit gate error rate of $p_2 = \frac{15 \lambda_{\text{gate}}}{16}$. Thus, the quantum channels corresponding to one-qubit and two-qubit gates, respectively, are
\begin{align} 
    % \label{eq:oneQubitChannel}
    % One qubit gate error channel
    \mathcal{E}_1(\rho) & = (1 - \frac{4}{3}p_1)G_1 \rho G_1^{\dagger} + \frac{p_1 }{3}\sum_{i\in\{I, X, Y, Z\}} P_{i} G_1\rho G_1^{\dagger}P_{i}^{\dagger}, \\
    %\label{eq:twoQubitChannel}
    % Two qubit gate error channel
    \mathcal{E}_2(\rho) & = (1 - \frac{16}{15}p_2)G_2 \rho G_2^{\dagger} + \frac{p_2 }{15}\sum_{i, j\in\{I, X, Y, Z\}} (P_{i}\otimes P_{j}) G_2\rho G_2^{\dagger}(P_{i}^{\dagger}\otimes P_{j}^{\dagger}).
\end{align} 
Ideally, the two error rates should be independent, but for the sake of keeping the simulation time reasonable while still reflecting the current state of quantum hardware, we have opted for this approach.

% Memory error
%We do not implement memory error as a relaxation process.
Similarly to Ref.\cite{Hartmann2007}, our simulator assumes \emph{memory error} to be a depolarizing error with probability $p_{\text{mem}}$ defined as
    \begin{equation} \label{eq:memoryModel}
        p_{\text{mem}} = 1- \left(\frac{3e^{-t/\tau} + 1}{4} \right) = \frac{3}{4}(1-e^{-t/\tau}),
    \end{equation} 
where $t$ denotes the time of measurement, and $\tau$ the memory lifetime. The quantum channel with memory errors acting on $\rho$ is 
\begin{equation}\label{eq:memoryChannel}
        \mathcal{E}_{\text{mem}}(\rho) = (1-p_{\text{mem}}) \rho + \frac{ p_{\text{mem}}}{3} \left(X\rho X^{\dagger} + Y\rho Y^{\dagger} + Z\rho Z^{\dagger} \right),
\end{equation}
and it is applied to the qubit immediately before any measurement.

(Although \cref{eq:depolarizingChannel} and \cref{eq:memoryChannel} are similar, $\mathcal{E}_{\text{depo}}(\rho)$ is time-independent and applies only when link-level Bell pair is generated, while $\mathcal{E}_{\text{mem}}(\rho)$ is time-dependent is applies only before any measurement on a physical qubit.)

% Measurement error
The measurement process is essential in a quantum network, especially with Bell state measurement (BSM) and quantum teleportation, and it can incur errors on a measured qubit. We model \emph{measurement error} as a bit flip on the classical readout.
% As our simulator yields only bit-flip errors in a measure basis, the measurement error could be easily implemented.
The simulator flips the measurement outcome with probability $p_{\text{meas}}$.
More details about the error model and how it is applied can be found in \ref{subsec:simulation}.

% \TT{Comment: As $\frac{1}{4}\sum_{i\in\{I, X, Y, Z\}} G_{i} \rho G_{i}^{\dagger}$ = $\frac{I}{2} = \frac{1}{4}\sum_{i\in\{I, X, Y, Z\}} G_{i} O\rho O^\dagger G_{i}^{\dagger}$, Eq.4 can actually be written as $(1 - p_{\text{gate}})O \rho O^{\dagger} + \frac{p_{\text{gate}} }{4}\sum_{i\in\{I, X, Y, Z\}} G_{i} O\rho O^\dagger G_{i}^{\dagger}$. This implies that the error model in this work is similar to the conventional model. However, because there is also the term with identity in the sum, the actual \emph{one-qubit gate error probability} is $\frac{3}{4}p_{gate}$, not $p_{gate}$. Similarly, Eq.5 can be written as $\mathcal{E}_{\text{gate}}(\rho) = (1 - p_{\text{gate}})O \rho O^{\dagger} + \frac{p_{\text{gate}} }{16}\sum_{i, j\in\{I, X, Y, Z\}} (G_{i}\otimes G_{j}) O\rho O^\dagger (G_{i}^{\dagger}\otimes G_{j}^{\dagger})$. However, the actual \emph{two-qubit gate error probability} is $\frac{15}{16}p_{gate}$. Because of the difference in scaling, it looks like the single-qubit and two-qubit gate probabilities are not equal in the existing model and the plots cannot be simply fixed by rescaling... Any suggestions?}

% \TT{New equations below}
% \begin{equation} %\label{eq:oneQubitChannel}
%         % One qubit gate error channel
%         \mathcal{E}_{\text{gate}}(\rho) = (1 - \frac{4}{3}p_{\text{gate}})O \rho O^{\dagger} + \frac{p_{\text{gate}} }{3}\sum_{i\in\{I, X, Y, Z\}} G_{i} O\rho O^{\dagger}G_{i}^{\dagger}.
%     \end{equation}
% \begin{equation} %\label{eq:twoQubitChannel}
%         % Two qubit gate error channel
%         \mathcal{E}_{\text{gate}}(\rho) = (1 - \frac{16}{15}p_{\text{gate}})O \rho O^{\dagger} + \frac{p_{\text{gate}} }{15}\sum_{i, j\in\{I, X, Y, Z\}} (G_{i}\otimes G_{j}) O\rho O^{\dagger}(G_{i}^{\dagger}\otimes G_{j}^{\dagger}).
% \end{equation} 
% \PP{New equations above, just as a closing tag.}
    
\subsection{Fidelity Evaluation} \label{subsec:FidelityEvaluation}
The main goal of our simulator is to evaluate the quality of the distributed end-to-end Bell pairs.
State tomography could be used to estimate the final state but would incur a heavy computational tax.
Our primary metric of interest is the fidelity of the distributed state with respect to a certain Bell state, which can be estimated without the full knowledge of the density matrix in certain cases~\cite{flammia2011direct}.

The fidelity of a Bell pair can be estimated by measuring its stabilizer operators. We will now demonstrate how this method works by expressing the Bell pair $|\Phi^+\rangle$ in terms of the Pauli operators,
\begin{equation}\label{eq:Bellpair}
    |\Phi^{+}\rangle \langle \Phi^{+}| = \frac{1}{4} \left( II + XX - YY + ZZ \right).
\end{equation}
An arbitrary two-qubit state $\rho$ can be written as
\begin{equation}
    \rho = \frac{1}{4} \sum_{i,j\in I,X,Y,Z} \langle P_i \otimes P_j \rangle P_i \otimes P_j,
\end{equation}
where $\langle P_i \otimes P_j\rangle = \text{Tr} \left[ (P_i \otimes P_j) \rho \right]$.
Using the properties of the Pauli matrices, it can be readily shown that the fidelity of this arbitrary state with respect to the Bell pair is
\begin{equation} \label{eq:fidelityBell}
    F(\rho, |\Phi^{+}\rangle \langle \Phi^{+}|) = \langle \Phi^{+}| \rho |\Phi^{+}\rangle
    = \frac{1}{4}\left(1 + \langle XX \rangle - \langle YY \rangle + \langle ZZ \rangle \right).
\end{equation}

% As we want to evaluate the quality of a Bell pair created, the standard state tomography could be used to reconstruct the quantum state of many of the copies that we could produce, but such the calculation is computationally expensive. In contrast, if we only want to calculate fidelity of a Bell pair with respect to a Bell state, the state tomography is not necessary. In this case, we can calculate the quantum state fidelity directly by measuring the stabilizer of the Bell pair produced. Our simulation only keeps track of the presence of the Pauli error on each qubit. In this section, we show how we can estimate the desired fidelity using that information, referred to as \emph{direct fidelity estimate}. Subsequently, we verify and validate the results of the convergence of the method compared to theoretical calculations in simple scenarios, where analytical expressions can be easily derived.
    
%    \HR{HELP ME CITE THIS PROPERLY}
    
% Consider an ideal Bell state expressed in terms of the Pauli operators, 
%     \begin{equation}\label{eq:Bellpair}
%         |\Phi^{+}\rangle \langle \Phi^{+}| = \frac{1}{4} \left( II + XX - YY + ZZ \right).
%     \end{equation}
% As a Bell pair evolution is modelled as 
%     \begin{equation} \label{eq:wernerState}
%         \rho = \sum_{G_i, G_j = \{I, X, Y, Z \}} p_{i, j} G_{i}G_{j} |\Phi^{+}\rangle \langle \Phi^{+}| G_{i}^{\dagger}G_{j}^{\dagger},
%     \end{equation}  
% the fidelity of $\rho$ in \cref{eq:wernerState} with respect to the Bell state in \cref{eq:Bellpair} can be expressed as 
%     \begin{align} \label{eq:fidelityBell}
%         F(\rho, |\Phi^{+}\rangle \langle \Phi^{+}|) &= \langle \Phi^{+}| \rho |\Phi^{+}\rangle \\
%         &= \frac{1}{4}\left(1 + \langle XX \rangle - \langle YY \rangle + \langle ZZ \rangle \right).
%     \end{align}

Our simulator tracks the probability that a qubit is affected by a particular Pauli error.
The correlations $\langle P_i \otimes P_i \rangle$ in \cref{eq:fidelityBell} can be obtained directly from these error probabilities in the following way.
We check whether $P_i \otimes P_i$ commutes or anticommutes with a particular Pauli error operator.
If it commutes, then we leave its probability as is. If it anticommutes, we multiply its error probability by $-1$.
Finally, we sum all the probabilities and renormalize them by the number of qubits, which in this case is two.
This can be done during the quantum state evolution without having to collect data and constructing a quantum state from a tomographic process.
We refer to this method of computing the fidelity as \emph{direct fidelity estimate}; see \ref{subsec:simulation}.
    
\subsection{Validation with Theoretical Model} \label{sec:Validation}
In this subsection, we verify the direct estimation of the fidelity used in our simulation by comparing it with analytically derived expressions for certain simple scenarios.
The setting we consider is that of two end nodes trying to share a Bell pair with the help of a single quantum repeater placed half-way between the two end nodes.
The case of unequal link lengths has been investigated in Ref.\cite{pathumsoot2021optimizing}.
This is the same scenario discussed in \cref{subsec:theoryPOV}, but this time due to the assumption of equidistant separation of the end nodes and the repeater, the link-level entangled states will have the same fidelity, $F_{AB} = F_{CD} = F_{\text{link}}$.
% Considering the depolarizing channel defined in \cref{eq:depolarizingChannel}, it is possible to derive analytical expressions for the fidelity of a distributed Bell pair after entanglement swapping as well as after purification.

%\naphann{Waiting for Poramet's confirmation. Appendix B seems to suggest this is correct. MM-link is used but the equation suggests that both ends initialize qubits at the same time thus undergoing a waiting time of $2L/c$. Also, we probably should add a note that our fiber only has loss error and no Pauli error.} \PP{I added explanation in the appendix B about that, but for Puali error, does depolarizing channel count?}
Considering the depolarizing channel in \cref{eq:depolarizingChannel}, the link-level fidelity with respect to the state $|\Phi^+\rangle$ is
    \begin{equation}\label{eq:withoutpurificaiton}
        F_{\text{link}} = \frac{ p_{\text{depo}}^2}{3} + (1 -  p_{\text{depo}})^2.
    \end{equation}
% From \cref{eq:densityBell}, we identify that $F = F_{\text{raw}}$.
Using \cref{eq:fidelityES}, we obtain the fidelity $ F_{\text{E2E}}$ of the end-to-end Bell pair after entanglement swapping:
\begin{equation}
    F_{\text{E2E}} = \left(\frac{p_{\text{depo}}^{2}}{3} + \left(1 - p_{\text{depo}}\right)^{2}\right)^{2} + \frac{1}{3} \left(1 - \frac{p_{\text{depo}}^{2}}{3} - \left(1 - p_{\text{depo}}\right)^{2} \right)^{2}.
\end{equation}
We benchmark the results generated by our simulator with the analytic expression of this model, as shown in the left panel of \cref{fig:0G_1G_model} with varying values of $p_{\text{depo}}$.
    
    % \begin{figure}
    %     \centering
    %     \includegraphics[width=\columnwidth]{0G_model.png}
    %     \caption{Fidelity of analytic and simulated Bell pair after entanglement swapping using noisy Bell pairs passing through a depolarizing channel. Each point is a mean value of 10 trajectories, and \num{9000} measurements for each trajectory.}
    %     \label{fig:0G_model}
    % \end{figure}

    
    \begin{figure}
        \centering
        \includegraphics[width=\columnwidth]{contents/figures/fig4-Fidelity_0G_1G_model.pdf}
        \caption{(Left) Fidelity of the end-to-end Bell pair after entanglement swapping using noisy Bell pairs passing through a depolarizing channel. Good agreement of analytical and simulated results  is evident. Each point is an averaged value of 10 trajectories, and \num{9000} measurements for each trajectory. (Right) Fidelity of the end-to-end Bell pair after entanglement swapping using purified noisy Bell pairs (by the Ss-Dp protocol) passing through depolarizing channel. Likewise, each point is a an average value of 10 trajectories, and \num{9000} measurements for each trajectory.}
        \label{fig:0G_1G_model}
    \end{figure}
    
Moreover, the analytical fidelity of the Bell pair resulting from the Ss-Dp protocol corresponding to \cref{eq:densityBell} is given by
    \begin{equation} \label{eq:SsDpFidelity}
        F_{\text{Ss-Dp}} = \frac{14 F_{\text{link}}^{2} - 7 F_{\text{link}} + 2}{16 F_{\text{link}}^{2} - 14 F_{\text{link}} + 7},
    \end{equation}
where $F_{\text{link}}$ is the fidelity of the link-level physical Bell pair given by \cref{eq:depolarizingChannel}; see \ref{sec:derivation}. The right panel of Fig.~\ref{fig:0G_1G_model} shows the end-to-end fidelity of obtained by first applying the Ss-Dp purification protocol to both links before executing entanglement swapping.
We denote this fidelity by $F_{\text{Ss-Dp} \rightarrow \text{E2E}}$.
The analytic expression for this fidelity is lengthy, and it can be obtained by using \cref{eq:withoutpurificaiton} and \cref{eq:SsDpFidelity} along with \cref{eq:fidelityES}.
The simulated and analytical results show excellent agreement.
Small discrepancies occur in both cases because our direct fidelity estimate is a statistical measure, paid in exchange for lower computational cost.
    
    % \begin{figure}
    %     \centering
    %     \includegraphics[width=\columnwidth]{1G_model.png}
    %     \caption{Fidelity of analytic and simulated Bell pair after entanglement swapping using purified noisy Bell pairs passing through depolarizing channel. Each point is a mean value of 10 trajectories, and \num{9000} measurements for each trajectory.}
    %     \label{fig:1G_model}
    % \end{figure}