\section{Taxonomy Levels and Defects Description}

In this section, we traverse the taxonomy tree and present a brief description of all categories and individual vulnerabilities, which are identified according to the respective numbers in Figure \ref{fig:taxonomytree1} and Figure \ref{fig:taxonomytree1}. In order to keep the used space under reasonable limits, most of the descriptions consist of brief explanations. For further information, the reader may refer to \cite{openscvSite} for further details and also examples. The exception to this is the first vulnerability discussed in the text (i.e., \textit{1.1.1 Unsafe credit transfer}), which, for illustrative purposes, we present with complete detail.

%\begin{snugshade*}

\subsection*{\hl{\textbf{1. Unsafe External Calls}}}


%\end{snugshade*}

This category represents a set of vulnerabilities in which there is an interaction between at least two contracts. 

\subsection*{\textbf{1.1 Reentrancy}}

The first subcategory is reentrancy, in which two contracts are involved: the vulnerable contract and the malicious contract. Overall, this type of vulnerability occurs when the malicious contract, after initiating a call, is allowed to make new calls to the vulnerable contract before the initial call has been completed. Thus, unexpected state changes may occur, such as depletion of credit. We identified two main types of reentrancy vulnerabilities: one type associated with loss of credit and the other one associated with unexpected state changes. This is in line with several vulnerability detection tools, such as Securify \cite{Tsankov2018}, Slither \cite{feist_slither_2019_git}, or \cite{momeni_machine_2019} \cite{feist_slither_2019} which also distinguish these two cases (although using different names). 



\subsubsection*{1.1.1 Unsafe Credit Transfer}

Known due to the DAO attack event \cite{Siegel2016}, this vulnerability allows attackers to maliciously change balance via credit transfer calls that are allowed to take place before a previous call has been completed. Let us consider the case where a smart contract maintains the balance of several addresses, allowing the retrieval of funds. A malicious contract may initiate a withdrawal operation which would lead the vulnerable contract to send funds to the malicious one before updating the balance of the malicious contract. On the malicious contract side, funds would be accepted, and a new withdrawal could be initiated (before the balance had been updated on the vulnerable contract side). As a consequence, the malicious contract could withdraw funds multiple times, with the total sum exceeding its own funds.

Using the Orthogonal Defect Classification (ODC) as a reference, this defect can be classified as being of type \textit{Algorithm} as the nature of the defect sits in the logic created by the programmer. The ODC qualifier is defined as \textit{wrong} as the error is related to incorrect logic (i.e., not \textit{missing} or \textit{extraneous} logic), related to the order of the instructions in the code.

Regarding the relationship to CWE, we classify this vulnerability (and actually the whole reentrancy group) as CWE-841, which describes a situation where \textit {"the software supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence}". This vulnerability is also known in the literature as "reentrancy" \cite{kalra_zeus_2018, mavridou_designing_2018,bauer_semantic_2018,mavridou_verisolid_2019,Brent2018,tsankov_securify_2018,arganaraz_detection_2020,ye_clairvoyance_2020,tikhomirov_smartcheck_2018,lu_neucheck_2019,liu_reguard_2018,jiang_contractfuzzer_2018,Rodler2019,liao_soliaudit_2019,Chen2020a,ashouri_etherolic_2020,ashraf_gasfuzzer_2020,nguyen_sfuzz_2020,luu_making_2016,feng_precise_2019,wang_vultron_2019,feist_slither_2019,akca_solanalyser_2019,chinen_hunting_2020,andesta_testing_2020,chapman_deviant_2019,wang_contractward_2020,song_machine_2019, Hu2023, SAILFISH_2022,smartpulse_2021,SMARTIAN_2021, Ma2022,Li2023} , "re-entrancy with balance change" \cite{momeni_machine_2019} or "SWC-107 reentrancy" \cite{swc}.




\subsubsection*{1.1.2 Unsafe System State Changes}

This vulnerability is similar in nature to \textit{v1.1.1}, with the main difference being the fact that there is no credit involved and, thus, no impact on users' funds. Due to the way the contract is coded, a call that reaches the vulnerable contract before a previous one has ended may allow an attacker to place the program in an unexpected state, leading to various effects, depending on the type of contract involved, including performance or availability issues. This vulnerability is also known in the literature as "ReentrancyNoETH" \cite{tsankov_securify_2018}, "Reentrancy" \cite{mavridou_designing_2018, mavridou_verisolid_2019}, 
 "Re-entrancy without balance change" \cite{momeni_machine_2019}, or "SWC-107 reentrancy" \cite{swc}.

 % Os 2 artigos do autor mavridou, considera reentrada em relacao a ataques de dinheir e tambem como mudanca de estado, por isso esta repetindo em ambas.

\subsection*{\textbf{1.2 Malicious Fallback Function}}

Fallback functions are functions that are executed when a program receives a call to a function whose signature does not exist, i.e., either the name does not exist or the parameters do not match the parameters of any of the existing functions. For instance, an attacker could deploy a smart contract with a malicious fallback function, which could be used to drain funds or alter the system's state. By mistake, a user could invoke it and reach a state that was not expecting to reach \cite{Chen2020a}. This vulnerability is also known in the literature as "Call to the unknown" \cite{Atzei2017, arganaraz_detection_2020, chapman_deviant_2019} or "Unexpected function invocation" \cite{Chen2020a}.

\subsection*{\textbf{1.3 Improper Check of External Call Result}}

This category groups vulnerabilities that verify the execution of external contracts in an improper manner (i.e., verification is wrong or even missing), which affects the subsequent logic of the calling contract. The result of invoking a certain external operation should be verified, first of all, because it may simply fail, but especially because the called operation may be malicious (or may just have been poorly coded, resulting in an unexpected result); thus, the direct use of the result may lead to unexpected behavior.

\subsubsection*{1.3.1 Improper Check of External Call Return Value}

This defect consists of an incorrect (or missing) verification of the returned value from the external execution of a contract. When a smart contract invokes another one, the returned value should be verified because the called operation may return an unexpected value (i.e., either because the callee is malicious or may just have been poorly coded, resulting in an unexpected result) \cite{Chen2020a}. This vulnerability is also known in the literature as 
"Unchecked call return value" \cite{Zheng2021},
"Unused return" \cite{tsankov_securify_2018, momeni_machine_2019}, 
 "Unchecked external call"  \cite{tikhomirov_smartcheck_2018},  "No check after contract invocation" \cite{Chen2020a},
  "Call-depth" \cite{liao_soliaudit_2019},
 "Not checked return values" \cite{andesta_testing_2020}, ,
 "Call-stack Depth Attack" \cite{wang_contractward_2020,song_machine_2019} or "SWC-104 Unchecked Call Return Value" \cite{swc}.


\subsubsection*{1.3.2 Improper Exception Handling of External Calls}

In the case of this defect, the problem resides in the incorrect (or missing) handling of exceptional behavior thrown by a call (i.e., instead of residing in the handling of values, as in the case of vulnerability \textit{v1.3.1}). The improper verification of exceptions thrown by the callee may lead to unexpected behavior in the caller contract. There are various reasons why the callee may exhibit exceptional behavior. For instance, the callee could be under malicious control, the execution of the transaction could activate a fault in the callee contract, the transaction could be terminated due to reaching the gas limit, or the callee contract may have been terminated (e.g., after a software fault has been detected in the contract). This vulnerability is also known in the literature as  "DoS by external contract" \cite{zhang_soliditycheck_2019,tikhomirov_smartcheck_2018,lu_neucheck_2019}, "Denial of service" \cite{ashouri_etherolic_2020,andesta_testing_2020} or "SWC-113	
DoS with Failed Call" \cite{swc}.


\subsubsection*{1.3.3 Improper Check of Low-Level Call Return Value}

Languages like Solidity offer the possibility of using low-level calls that operate over raw addresses. Such calls do not verify that the code exists or the success of the calls. Thus, its use may lead to unexpected behavior \cite{large_lowlevel_2023}. As a result, using such calls can be risky and should be avoided in most cases. This vulnerability is also known in the literature as "LowLevelCalls" \cite{tsankov_securify_2018, liao_soliaudit_2019}, "Unchecked calls" \cite{feng_precise_2019, Hu2023}, "InlineAssembly" \cite{liao_soliaudit_2019}, "Usage of low-level calls" \cite{momeni_machine_2019}, or {"Check-effects"} \cite{liao_soliaudit_2019}.


\subsection*{\textbf{1.4	Improper Locking During External Calls}}

A vulnerable contract uses a lock mechanism in an erroneous manner, which may cause deadlocks. This may result, for instance, in the impossibility of executing transfers and eventually in Denial of Service \cite{mavridou_verisolid_2019}. This vulnerability is also known in the literature as "Deadlock-freedom" \cite{mavridou_verisolid_2019} or "SWC-132 Unexpected Ether balance"\cite{swc}.


\subsection*{\textbf{1.5 Interoperability Issues with Other Contracts}}

This issue relates to interoperability issues between contracts built in different language versions. Newer contracts may execute or inherit discontinued functionality present in older contracts \cite{interoperable_2021}. For instance, Solidity has introduced the operation code \texttt{STATICCALL} to allow a contract to call another contract (or itself) without modifying the state. Starting from V0.5.0, \textit{pure} and \textit{view} functions must now be called using the code \texttt{STATICCALL} instead of the usual \texttt{CALL} code. Consequently, when defining an interface for older contracts, the programmer should only use \textit{view} instead of constant in the case s/he is absolutely sure that the function will work with \texttt{STATICCALL} \cite{solidity_0_8_17}. This vulnerability is also known in the literature as "AssemblyUsage" \cite{tsankov_securify_2018, momeni_machine_2019}.


\subsection*{\textbf{1.6	Delegatecall to Untrusted Callee}}

Calling untrusted contracts using the delegate feature is generally highly problematic because it opens the possibility for the called contract to change sensitive variables (e.g., \texttt{msg.data} or \texttt{sender}) of the source contract \cite{jiang_contractfuzzer_2018}. This type of issue has been most notably known as the Parity hack, which allowed attackers to reset the ownership and usage arguments of existing user wallets  \cite{krupp_teether_2018}. This vulnerability is also known as "Unrestricted delegate call" \cite{tsankov_securify_2018}, 
"Dangerous delegate call"  \cite{jiang_contractfuzzer_2018, ashraf_gasfuzzer_2020}, "Unchecked delegate call function" \cite{nguyen_sfuzz_2020},
"Code injection"  \cite{krupp_teether_2018}, "Control-flow Hijack" \cite{SMARTIAN_2021},
"Delegated call"  \cite{andesta_testing_2020,Li2023,Hu2023}, 
"Cross Program Invocation"	\cite{Cui2022},
"Tainted delegatecall"  \cite{brent_ethainter_2020} or "SWC-112 Delegatecall to Untrusted Callee" \cite{swc}.

%\begin{snugshade*}
\subsection*{\hl{\textbf{2. Mishandled Events}}}
%\end{snugshade*}

This category includes a set of vulnerabilities in which exceptional events are mishandled. In Solidity, there are specific functions that can be used to verify if certain conditions exist and to throw exceptions in the case the conditions are not met, namely \texttt{require} and \texttt{assert}. There are, however, fundamental differences. When the  \texttt{require} function returns false, all executed changes are reverted, and all remaining gas fees are refunded. When the \texttt{assert} function returns false, it reverts all changes but consumes all remaining gas. However, such differences have become a frequent source of problems \cite{solc-verify_2020}.

\subsection*{\textbf{2.1 Improper Exceptional Events Handling}}

This first group of vulnerabilities is directly related to exceptional events, which, when mishandled, are many times linked to the loss of atomicity in operations as well as other effects, such as excessive gas consumption or unauthorized access.

\subsubsection*{2.1.1 Improper Use of Exception Handling Functions}

Diverse runtime errors (e.g., out-of-gas error, data type overflow error, division by zero error, array-out-of-index error, etc.) may happen after a compiled smart contract is deployed. However, Solidity has many functions for error handling (e.g., \texttt{throw}, \texttt{assert}, \texttt{require}, \texttt{revert}), but their correct use relies on the experience and expertise of the developer. This defect occurs when the developer misuses the handling exception functions, which can lead the program to unexpected behavior. 
This vulnerability is also known in the literature as  
"Mishandled exceptions" \cite{bauer_semantic_2018, SMARTIAN_2021,zhang_soliditycheck_2019,  nguyen_sfuzz_2020, luu_making_2016}, "UnhandledException" \cite{ashouri_etherolic_2020,tsankov_securify_2018}, "Exception disorder \cite{jiang_contractfuzzer_2018}", or
"Exception state" \cite{momeni_machine_2019}.

\subsubsection*{2.1.2 Improper Exception Handling in a Loop}

This vulnerability occurs when a transaction is excessively large (i.e., it executes too many statements) and may lead to excessive costs. For instance, when one of the statements in a transaction fails (e.g., due to a software bug), the transaction will not be packaged into a block, and the consumed gas will not be returned to the user (and actually the concluded operations are reverted and must be executed again). Thus, such kinds of transactions should be decomposed into smaller parts so that the likelihood of success increases and the negative effects associated with the failure cases diminish. This vulnerability is also known in the literature as "CallInLoop" \cite{tsankov_securify_2018}, "Revert DOS" \cite{smartpulse_2021},
"Costly loop" \cite{zhang_soliditycheck_2019, tikhomirov_smartcheck_2018, lu_neucheck_2019},
"Multiple calls in a single transaction"  \cite{momeni_machine_2019},  "UnboundedMassOperation" \cite{grech_madmax_2020} or "SWC-128: DoS With Block Gas Limit" \cite{swc}.

\subsubsection*{2.1.3 Incorrect Revert Implementation in a Loop}

In the case of this vulnerability, the developer incorrectly specifies how the revert operation should be handled (in the context of a loop or a transaction composed of multiple operations), which ends up in a partial revert of the whole set of operations that should be reverted. This vulnerability is also known in the literature as  "Nonisolated calls (wallet griefing)" \cite{grech_madmax_2020}, "Push DOS " \cite{smartpulse_2021}, or "SWC-126 Insufficient Gas Griefing" \cite{swc}.


\subsection*{\textbf{2.2 Improper Token Exception Handling}}

The ERC-20 standard \cite{Vogelsteller2015} provides functionalities to exchange tokens. Besides describing the functionalities, the standard specifies good practices for developers to implement its features. Regarding the \texttt{transfer} function, exceptional events can become problematic if they are not handled properly.


\subsubsection*{2.2.1 Missing Thrown Exception}

Regarding the \texttt{transfer} function (i.e., functionality to transfer tokens from one account to another), the ERC-20 standard recommends to the developer throw an exception when a condition of the caller’s account balance does not have enough tokens to spend. This allows the caller to understand the reason for which the transfer is not completed and take appropriate action. %This action may avoid a Dos attack because a thrown exception is an event indicating something wrong is happening in the program. 
This vulnerability is also known in the literature as "Non-standard Implementation of Tokens" \cite{Ji2020}, Missing the Transfer Event \cite{Chen2020a}.


\subsubsection*{2.2.2 Extraneous Exception Handling}

This type of defect refers to the implementation of extra actions compared to what is recommended in a certain specification. The specification does not recommend actions like the use of guard functions (e.g., require or assert) in addition to throwing an exception in the case when there is no balance in the caller. The extra actions might be arbitrary and incompatible with the purpose of a transfer functionality (e.g., returning true or false to report the success of the execution). This vulnerability is also known
in the literature as "Token API violation"  \cite{zhang_soliditycheck_2019, tikhomirov_smartcheck_2018}

%\begin{snugshade*}
\subsection*{\hl{\textbf{3. Gas Depletion}}}
%\end{snugshade*}

This category groups defects that, in different ways, lead to gas depletion of the account used for the smart contract execution.

\subsection*{\textbf{3.1 Improper Gas Requirements Checking}}

This defect represents missing or wrong checking of the prerequisites (i.e., in terms of gas) for executing a certain operation, causing unnecessary processing and use of memory resources. For cost management reasons, languages offer programmers several ways to deal with the cost of the executing a certain operation in a contract. For instance, for transferring credits, Solidity provides the functions \texttt{transfer()} and \texttt{send()}, which have a limit of 2300 gas units for each execution. An alternative is to build a custom transfer function, where the gas limit is defined by a variable (e.g., \texttt{address.call.value(ethAmount).gas(gasAmount)()}). Despite having several ways of managing the program costs, it is challenging for programmers to predict which part of the code may fail. If an out-of-gas exception is triggered, the result may be unexpected behavior. This vulnerability is also known in the literature as "Send without Gas" \cite{arganaraz_detection_2020},
"Gassless send"  \cite{jiang_contractfuzzer_2018,ashraf_gasfuzzer_2020,nguyen_sfuzz_2020,feng_precise_2019,wang_vultron_2019,chang_scompile_2019,chapman_deviant_2019}, "Gas Dos" \cite{smartpulse_2021},
"Out of gas" \cite{akca_solanalyser_2019} or "SWC-126 Insufficient Gas Griefing" \cite{swc}. 


\subsection*{\textbf{3.2 Call with Hardcoded Gas Amount}}

This defect refers to the impossibility of adjusting the amount of gas used by a certain program after being deployed. This issue is related to the observation that certain transfer credit in real contracts was being deployed using a fixed amount of gas (i.e., 2300 gas). If the gas cost of EVM instructions changes during, for instance, a hard fork, previously deployed smart contracts will easily break. This vulnerability is also known
in the literature as "SWC-134 Message call with hardcoded gas amount" \cite{swc}.

%\begin{snugshade*}
\subsection*{\hl{\textbf{4. Bad Programming Practices and Language Weaknesses}}}
%\end{snugshade*}

This category represents issues that are mostly related to bad programming practices (i.e., error-prone or insecure coding practices) and language weaknesses, which are mostly related to insufficient protection mechanisms offered by the language, allowing the developers to make mistakes that could be avoided, e.g., by language constructs.

\subsection*{\textbf{4.1 Bad Randomness}}
%\hl{faz sentido termos este grupo de apenas um item?}\hl{FV Acho que sim, porque podemos futuramente achar um exemplo de cada variavel (blockhash, nounce,  etc) criar novas entradas no grupo. Explicar outros grupos}

This vulnerability is related to the use of the variables that control the blocks in a blockchain as a way of generating randomness, which is not secure. Such variables may be manipulated by miners so that the randomness is subverted, compromising the security of the blockchain, with its information becoming vulnerable to attacks. In fact, generating a strong enough source of randomness can be very challenging. The use of variables like \texttt{block.timestamp}, \texttt{blockhash}, \texttt{block.difficulty}, and other fields is problematic as these can be manipulated by miners. For example, a miner could select a specific timestamp within a delimited range, or use powerful hardware to mine several blocks quickly, choose the block that would provide an interesting hash, and drop the remaining. This vulnerability is also known
in the literature as 
"Generating Randomness" \cite{bauer_semantic_2018,tsankov_securify_2018},  
"Random generation" \cite{arganaraz_detection_2020}, "Bump Seeds"	\cite{Cui2022},
"Dependence on predictable variables"  \cite{lu_neucheck_2019},
"Bad randomness"  \cite{ashouri_etherolic_2020,Hu2023}, 
"Bad random" \cite{feng_precise_2019} or "SWC-120 Weak Sources of Randomness from Chain Attributes" \cite{swc}.

\subsection*{\textbf{4.2 Improper Initialization}}

The smart contract has resources that are either not initialized or are initialized in an incorrect manner, leading to unexpected behavior.

\subsubsection*{4.2.1 Missing Constructor}

A smart contract constructor is a function that is executed exactly once during the lifetime of a contract. It executes at deployment time and initializes state variables, performs a few necessary tasks that the specific contract requires, and sets the contract owner. If there is no constructor, the developer will have to implement such tasks manually, which is prone to security issues (e.g., variables may be set with incorrect values or forgotten, which may result in security problems). This vulnerability is also known in the literature as 
"Unsecure balance" \cite{Brent2018},  
"Missing constructor" \cite{zhang_soliditycheck_2019} or "SWC-118 Incorrect Constructor Name" \cite{swc}.


\subsubsection*{4.2.2 Wrong Constructor Name}

Contract published without a constructor because the programmer created a function, imagining that it would behave like a constructor. Usually, the construction function has sensitive code (e.g., assignment of the owner of the contract), and by declaring a wrong function name, any user can call the function, thus, causing serious security risks. This vulnerability is also known in the literature as "Constructor name"  \cite{andesta_testing_2020}, "Erroneous Constructor Name"	\cite{Hu2023} or "SWC-118 Incorrect Constructor Name" \cite{swc}.

\subsubsection*{4.2.3 Missing Variable Initialization}

This defect refers to the lack of initialization of variables that are used throughout the contract. Obviously, the effects can largely vary, depending on the variable itself and on the context in which is being used. This vulnerability is also known in the literature as 
"UninitializedStateVariable" \cite{tsankov_securify_2018}, 
"Uninitialized-local" \cite{tsankov_securify_2018} or 
"Uninitialized variables"  \cite{feist_slither_2019}.

\subsubsection*{4.2.4 Uninitialized Storage Variables}


In Solidity, state variables are assigned to memory or storage. When a state variable is declared, it is assigned to a certain storage slot. If that variable is not initialized, it will be stored in slot 0 (the first one) of the contract's storage. Thus, it may conflict with the next variable that is declared in the same slot, causing an address conflict. This latter variable will overwrite the first, leading to unexpected behavior. This is the reason why it is important to initialize all state variables in a smart contract so that they are set into the correct storage slots (and possible conflicts are avoided)\cite{antonopoulos_mastering_2018}. This vulnerability is also known
in the literature as 
"Uninitialized storage pointers" \cite{antonopoulos_mastering_2018}, "UninitializedStorage" \cite{tsankov_securify_2018,Hu2023} or "SWC-109 Uninitialized Storage Pointer" \cite{swc}.


\subsection*{\textbf{4.3 Improper Credit Transfer}}

This category groups defects which are generally related to improper credit transfer operations.

\subsubsection*{4.3.1 Missing Check On Transfer Credit}

This defect refers to the absence of verification after a transfer event, which can lead to an erroneous vision of the correct balance of the account. Indeed, the balance of the account may not reflect the currency transferred in an exact manner, leading to potential errors and opening the door to security issues. This vulnerability is also known in the literature as 
"Unchecked send" \cite{kalra_zeus_2018,smartpulse_2021,Brent2018,akca_solanalyser_2019,lu_neucheck_2019}.


\subsubsection*{4.3.2 Unprotected Transfer Value}

The \texttt{transfer} function uses a numeric variable for transfers and may be vulnerable if it does not protect or specify limits for the values. When attribute \texttt{address.balance} is used for identifying the amount to be transferred, it will result in transferring the total balance at once, which is a high-risk operation for the cases where the amount is high \cite{zhang_ethploit_2020}. This vulnerability is also known in the literature as 
"Unchecked transfer value" \cite{zhang_ethploit_2020} ,
"Transfer forwards all gas"  \cite{tikhomirov_smartcheck_2018},  
"UnrestrictedEtherFlow" \cite{tsankov_securify_2018},
"Ether Leak" \cite{SMARTIAN_2021},
"Manipulated Balance" \cite{Hu2023},
"Multiple Send"	\cite{SMARTIAN_2021}
or 
"SWC-105 Unprotected Ether Withdrawal" \cite{swc}.

% 
\subsubsection*{4.3.3 Wrong use of Transfer Credit Function}

Depending on the programming language, there are different ways to carry out credit transfer operations. In Solidity, \texttt{transfer} and \texttt{send} will both allow executing a credit transfer. However, in the case of a problem, \texttt{transfer}  will abort the process with an exception, whereas \texttt{send} function will return \texttt{false}, and transaction execution is continued. An attacker may manipulate the \texttt{send} function and be able to continue executing a credit transfer operation without proper authorization. This vulnerability is also known
in the literature as 
"Failed Send"  \cite{kalra_zeus_2018}, "Use of send instead of transfer"\cite{arganaraz_detection_2020}, or
"Send instead of transfer" \cite{tikhomirov_smartcheck_2018}. 

% Erro de copiar e colar... era Use of send instead of transfer que estava na referencia e nao exception disorder.


% Chequei tb o Failed send. Esta correto, veja a descricao do artigo FAILED S E N D. Best practices [16] suggest executing a
%throw upon a failed send, in order %to revert the transaction.
%However, this paradigm can also put %contracts at risk.


\subsection*{\textbf{4.4 Error in Function Call}}

In a blockchain context, each function in a smart contract is identified by its name, input parameters, and output parameters. Thus, these items compose the function \textit{signature}, which is used by the contracts to verify that the right function is being called. 
This category groups defects in which a developer uses a function in the wrong manner: either a wrong signature is used, wrong arguments are used, or a wrong function is called. 

\subsubsection*{4.4.1 Wrong Function Call}

The issue occurs when a contract executes a certain function at a wrong address, i.e., at the address used by another function, which, however, has the same signature as the intended function. This vulnerability is also known in the literature as "Type casts" \cite{Atzei2017}.


\subsubsection*{4.4.2 Wrong Selection of Guard Function}

\texttt{Assert} is a Solidity function, which is recommended to be used only in the development phase. Intentionally, the programmer inserts the function at a specific point in the program where a bug is suspected. If running the program results in gas depletion, the suspicion is confirmed.

Thus, this defect refers to the cases in which the \texttt{assert} function is implemented with the wrong purpose, not having the expected effect. In more severe cases, in which the programmer forgets to remove it from the code or does not replace it with \texttt{require}, the impact of this defect can be serious. This vulnerability is
also known in the literature as 
"AssertFail" \cite{liao_soliaudit_2019}, "Assertion Failure" \cite{SMARTIAN_2021} or
"SWC-110 Assert Violation" \cite{swc}.

\subsubsection*{4.4.3 Function Call with Wrong Arguments}

This defect refers to the presence of certain control characters within the arguments of a function call, namely the \textit{right-to-left override control character}, which can cause the function to execute with arguments in reverse order. This is a known issue also in other computing areas \cite{Yosifova2021}. This vulnerability is also known
in the literature as "RightToLeftOverride" \cite{tsankov_securify_2018} or "SWC-130 Right-To-Left-Override control character (U+202E)". 


\subsection*{\textbf{4.5 Wrong Class Inheritance Order}}

Contracts may have inheritance relationships with other contracts. In the case of solidity, the code of the inherited contract is always executed first, e.g., so that state variables are initialized properly. Solidity uses an algorithm named C3 linearization to determine the order in which the contracts are to be executed. Developers specify the inheritance relationships in a \texttt{inherit} statement and may believe that the order in which the inherited contracts are specified in that statement reflects the order in which the linearization algorithm should work. This opens space for security issues due to the wrong order of the contract in the \texttt{inherit} statement. This vulnerability is also known
in the literature as "Unpredictable state" \cite{bauer_semantic_2018,arganaraz_detection_2020} or "SWC-125 Incorrect Inheritance Order"\cite{swc}.

\subsection*{\textbf{4.6 Improper Type Usage}}

This category groups vulnerabilities in which there is some misuse of types of data structures or functions.

\subsubsection*{4.6.1 Missing return type on Function}

This vulnerability refers to a missing return type in the definition of a smart contract interface. At runtime, if a contract that implements that interface contains two functions with the same name and arguments but have different return types, there is a chance that the wrong function will be called. This may lead to unexpected results once the calling contract receives the wrong data type \cite{zhang_soliditycheck_2019}. This vulnerability is also known in the literature as 
"ERC20Interface"\cite{tsankov_securify_2018}, 
"Unsafe inherit from token"  \cite{lu_neucheck_2019}, "Missing Return Statement"	\cite{Hu2023} or
"Incorrect ERC20 interface" \cite{momeni_machine_2019}.


\subsubsection*{4.6.2 Function Return Type Mismatch}

In this case, the developer implemented a function (starting from an interface), but it selected the wrong data type for the value to be returned (i.e., it differs from what is specified in the interface). This vulnerability is known in the literature in the context of non-fungible tokens by the name of 
"ERC721Interface" \cite{tsankov_securify_2018} or "SWC-127 Arbitrary Jump with Function Type Variable" \cite{swc}.


\subsubsection*{4.6.3 Parameter Type Mismatch}
%\hl{o problema é apenas com interfaces? R: SIM }
This issue refers to a divergence regarding the types of arguments used in a function that implements an interface. In this situation, even if the call is done with the right function name and arguments, the EVM considers it to be a non-existent function error. 
This vulnerability is also known in the literature as 
"Types conversion" \cite{arganaraz_detection_2020},  
"Unindexed ERC20 event parameters" \cite{momeni_machine_2019} or  "ERC20Indexed" \cite{tsankov_securify_2018} in the context of fungible tokens.

\subsubsection*{4.6.4 Missing Type in Variable Declaration}

In Solidity, whenever a variable is declared without an associated type, the compiler infers the data type based on the assigned value. This additional computation may lead to higher costs (i.e., in gas) and memory usage and especially allows for  overflow or underflow problems to occur. For instance, the compiler may infer that a signed integer is the right datatype for a certain variable, where an unsigned integer should be used. This vulnerability is also known in the literature as 
"Unsafe type inference" \cite{zhang_soliditycheck_2019,tikhomirov_smartcheck_2018} or 
"Unsafe-type declaration" \cite{lu_neucheck_2019} .

\subsubsection*{4.6.5 Wrong Type in Variable Declaration}

%\hl{este também não parece estar bem em shadowing}

%\hl{FV.. tb acho que nao. Talvez seja algo a declaracao da variavel .. ou wrong type.. algo assim}

This issue refers to a wrong selection of datatypes that leads to the allocation of more memory than what would be necessary for the intended function, leading to an increase in gas consumption. As an example, in Solidity, the \texttt{byte[]} type reserves 31 bytes of space for each element, whereas the \texttt{bytes} requires a single byte per element, thus being more space efficient. This vulnerability is also known in the literature as  
"byte[ ]" \cite{zhang_soliditycheck_2019},
 "Byte array" \cite{tikhomirov_smartcheck_2018}, or
"Costly bytes"  \cite{lu_neucheck_2019}.

\subsubsection*{4.6.6 Wrong Type of Function}


In Solidity, it is possible to specify a type for each function. Functions of type \texttt{view} can read data from state variables but cannot modify them, and no gas costs are involved, whereas functions of type \texttt{pure} neither can read nor modify state variables and similarly to view functions, no gas costs are associated with this type of function. This vulnerability occurs when a developer uses the wrong type for a function. For instance, there is an issue reported in Ethereum's GitHub \cite{Pure_Issue_2022} in which a state variable conversion operation (from storage to memory) inside a \texttt{pure} function results in a problem (i.e., to avoid this problem, the function type should be \texttt{view}). This vulnerability is also known in the literature as 
"Function type operators" \cite{chapman_deviant_2019}.

%https://github.com/ethereum/solidity/issues/13174


%Wrong use of the function type, not consistent with the purpose that the type presents. For example, view are functions that do not allow modifying state variables, but can read them. Pure defines a function that can neither read nor modify state variables (which are declared out of scope of the function).


\subsection*{\textbf{4.7 Useless Code}}

This category groups a set of vulnerabilities in which the program contains a unit of code that, in practice, has no effect.% regarding intended functionality.

\subsubsection*{4.7.1 Unreachable Payable Function}

This defect refers to the case of contracts that allow the use of functions that accept credit but do not have any functionality for transacting it. They are insecure, as there is no way to recover the credit once it has been sent to the contract \cite{zhang_soliditycheck_2019}. This vulnerability is
also known in the literature as  
"Locked Ether" \cite{chapman_deviant_2019,ashouri_etherolic_2020,feist_slither_2019,tsankov_securify_2018},
"Lost ether in the transactions" \cite{arganaraz_detection_2020}, "Locked Money"  \cite{zhang_soliditycheck_2019,tikhomirov_smartcheck_2018,lu_neucheck_2019}, "Frozen Ether"	\cite{Hu2023},
"Freezing Ether" \cite{nguyen_sfuzz_2020,SMARTIAN_2021,jiang_contractfuzzer_2018,ashraf_gasfuzzer_2020},
"Be no black hole" \cite{chang_scompile_2019}, 
"Function Can/Cannot Receive Ether" \cite{chapman_deviant_2019}, "Locked Funds"	\cite{smartpulse_2021},
"Leaking Ether to Arbitraty Address"	\cite{Hu2023} or "Contracts that lock ether" \cite{momeni_machine_2019}.

\subsubsection*{4.7.2 No Effect Code Execution}

This vulnerability refers to the presence of code that has no practical purpose (i.e., it has no effect on the intended functionality). Within a smart contract, it increases the size of the program's binary code, which results in more gas consumption than would otherwise be necessary. This vulnerability is also known in the literature as 
"CallToDefaultConstructor" \cite{tsankov_securify_2018}, "Useless Assignment"	\cite{Hu2023} or "SWC-135 Code With No Effects" \cite{swc}. 



\subsubsection*{4.7.3 Unused Variables}


This defect refers to the declaration of variables that are not used in the contract, which results directly in the allocation of unnecessary space in memory. As a consequence, the gas cost of executing the contract increases as well as the attack surface of the contract. Other effects are related to the readability or maintainability of the code. This vulnerability is
also known in the literature as 
"UnusedStateVariable" \cite{tsankov_securify_2018,Hu2023}, 
"Presence of unused variables" \cite{swc} or "SWC-131 Presence of unused variables" \cite{swc}.


\subsection*{\textbf{4.8 Version Issues}}

This category refers to issues that relate to the versioning of various aspects, including the use of deprecated versions of functions.

\subsubsection*{4.8.1 Undetermined Program Version Prevalence}

This defect refers to the case where the developer allows a certain contract to be compiled across multiple versions. This allows the known faults in older versions to be easily activated. \cite{zhang_soliditycheck_2019}. This vulnerability is
also known in the literature as  
"SolcVersion" \cite{tsankov_securify_2018},
"Compiler version not fixed" \cite{tikhomirov_smartcheck_2018},
"Unfixed compiler version" \cite{lu_neucheck_2019}, 
"Usage of complex pragma statement" \cite{momeni_machine_2019} or  "SWC-103 Floating Pragma" \cite{swc}.

\subsubsection*{4.8.2 Outdated Compiler Version}

Contracts that have been developed against an outdated compiler version can bring in several risks, mainly because newer versions may have resolved certain bugs or even introduced security mechanisms to avoid particular issues (e.g., the \texttt{throw} function has been disallowed in Solidity 0.5.0 and superior versions, in favor of \texttt{assert}, \texttt{require⁄}, and \texttt{revert}). This vulnerability is
also known in the literature as 
"Compiler version problem" \cite{zhang_soliditycheck_2019} ,  
"Unfixed compiler version" \cite{lu_neucheck_2019} or "SWC-102 Outdated Compiler Version" \cite{swc}.

\subsubsection*{4.8.3 Use of Deprecated Functions}

Deprecated functions are not recommended due to the fact that they are usually replaced by functions that solve known security issues or even operate in a more efficient manner (i.e., may consume less gas). As an example, \texttt{sha3} was marked as a deprecated function in Solidity 0.5 and replaced by \texttt{keccak256}, which is more secure and efficient. This vulnerability is
also known in the literature as 
"SWC-111 Use of deprecated solidity functions" \cite{swc}.


%\subsection*{\textbf{4.9 Improper Use of Conventions}}

%This group presents name convention problems that can lead programmers to make mistakes.


%\subsection*{4.9.1 Improper Use of Naming Conventions}

%This issue refers to developers' lack of adoption of naming conventions (e.g., data types, functions) for elements present in the contract. The style guide is a practice also found in other languages (e.g., Python \cite{Rossum2001}), which aims to make the code more consistent. Overlooking the recommendations can lead programmers to make mistakes in their coding, opening the door to security attacks. This vulnerability is also known in the literature as
%"NamingConvention"  \cite{tsankov_securify_2018}, 
%"Style guide violation" \cite{zhang_soliditycheck_2019,tikhomirov_smartcheck_2018}, or
%"Unstandardized naming"  \cite{lu_neucheck_2019}.

\subsection*{\textbf{4.9 Inadequate Data Representation}}

The numbers to represent the credits (e.g., Ether) can be very large (i.e., literals with many digits are difficult to read and review). Thus it is recommended that the programmer use the native resources of the language to make this representation (e.g., Solidity 10000000000000000000 for 1 ether). This vulnerability is also known in the literature as "too-many-digits" \cite{tsankov_securify_2018}.

\subsection*{\textbf{4.10 Improper Modifier}}

This group gathers defects that relate to the use of modifiers in functions and variables.

\subsection*{4.10.1 Wrong Function Modifier}

This defect refers to the case of functions that are written solely to be used by other contracts (i.e., not within the contract). Such functions should be marked with the \texttt{external} modifier instead of \texttt{public}. The \texttt{public} modifier allows both external and internal calls. Marking a function with \texttt{external} results in gas savings, as every invocation will be using \texttt{calldata} (a special memory region to store arguments, which cannot be later modified by the function) and can avoid unnecessary read and write operations to memory, which occur with internal calls (i.e., that do not use \texttt{calldata}). This vulnerability is also known in the literature as 
"external-function" \cite{tsankov_securify_2018} or "SWC-100: Function Default Visibility" \cite{swc}.

\subsection*{4.10.2 Missing Constant Modifier in Variable Declaration}
%\hl{de acordo mas isto não parece encaixar em shadowing. Este é parecido com o 4.11 apesar do nome do 4.11 não transparecer. No 4.11 é um modifier de uma função que está errado e aqui é um modifier de uma variavel errado. Vamos ver se podemos agrupar.} 

%\hl{FV. 4.14.4
%4.14.5
%4.11, sao implementaçoes que estao incoerentes com a definicao da linguagem.. Talvez poderiamos ter um nome para isso}

Variables that are not modified during the execution flow should be declared as constants to save gas. In the absence of the \texttt{constant} modifier, it is assumed that the variable's value can be changed. This vulnerability is also known in the literature as 
"ConstableStates" \cite{tsankov_securify_2018} or
"State  variables that could be declared as constant" \cite{momeni_machine_2019}.

\subsubsection*{4.10.3	Missing Visibility Modifier in Variable Declaration}

Variables have different visibility states, which determine the context for accessing them. In Solidity, by default, the visibility of state variables and functions is \texttt{internal}, which allows access from functions in the same contract or derived contracts. A developer that is unaware of this may create a contract that allows exposure of sensitive data or allow unexpected behavior. This vulnerability is also known in the literature
as 
"StateVariablesDefaultVisibility" \cite{tsankov_securify_2018}, 
 "Visibility level" \cite{tikhomirov_smartcheck_2018,zhang_soliditycheck_2019},
 "Unspecified visibility level" \cite{lu_neucheck_2019},
"Gain/Lose visibility" \cite{chapman_deviant_2019} or "SWC-108: State Variable Default Visibility" \cite{swc}.

\subsection*{\textbf{4.11 Redundant Functionality}}

Contracts that are written with redundant functionality increase code size and make maintainability difficult. In a simple scenario,  a programmer creates a function and later (by bad practices) ends up creating the same functionality again in a new function. He/she identifies a vulnerability in the new function and fixes it, but the old function with the defect is used by the caller. This vulnerability is also known in the literature as 
"Redundant refusal of payment"  \cite{zhang_soliditycheck_2019}, "Redundant fallback function" \cite{tikhomirov_smartcheck_2018}, or
"Unnecessary payable fallback function"  \cite{lu_neucheck_2019}.

\subsection*{\textbf{4.12 Shadowing}}

This category groups defects in which there are code elements (e.g., a function or a variable) with the same name, which can lead to erroneous and unexpected behavior.% in the event the developer erroneously uses the wrong element.


\subsubsection*{4.12.1	Use of Same Variable or Function Name In Inherited Contract}

When using the same name as a local variable, which was previously declared by an inherited contract, the program loses the reference of the inherited variable, causing the local variable to assume the role of the other variable. This vulnerability is also known in the literature as 
"Shadowing state variables" \cite{tsankov_securify_2018}, 
"Shadow memory"  \cite{ashouri_etherolic_2020}, 
"Shadowing"  \cite{feist_slither_2019} or "SWC-119: Shadowing State Variables" \cite{swc}.


\subsubsection*{4.12.2	Variables or Functions Named After Reserved Words}

This bug occurs when creating variables named after keywords of the language itself. For example, in Solidity, creating a variable with the name \textit{now} conflicts with the function that returns the date and time. This vulnerability is also known in the literature as "ShadowedBuiltin" \cite{tsankov_securify_2018}.


\subsubsection*{4.12.3	Use of the Same Variable or Function Name In a Single Contract}

This vulnerability refers to cases where the same name is used for more than one variable or function inside the contract. This makes the program lose the reference of the variable of the class, assuming the variable of the function as its role. This vulnerability is also known in the literature as "ShadowedLocalVariable" \cite{tsankov_securify_2018}, "Redefined Variable" \cite{Hu2023} or
"Local variable shadowing" \cite{momeni_machine_2019}.


\subsection*{\textbf{4.13 Buffer Overflow}}

This category refers to overflow vulnerabilities (e.g., stack-based, heap-based) in which it is possible to write more data than what the buffer can hold, thus modifying memory areas outside the expected.

\subsubsection*{4.13.1 Stack-based Buffer Overflow}

The EVM keeps an execution stack that manages the execution of contracts. If an attacker is allowed to overflow this stack (e.g., by using specially crafted inputs), it can potentially overwrite control variables (e.g., timestamp or block number) and, for instance, gain unauthorized access to certain resources. This vulnerability is also known in the literature as "Stack size limited"  \cite{arganaraz_detection_2020}.

\subsubsection*{4.13.2 Write to Arbitrary Storage Location}

In solidity, arrays are stored as contiguous fixed-size slots. In the absence of a bounds verification, a malicious user could write data to a particular storage slot used to store the contract owner's address, which could be overwritten and then used to further harm the contract. This vulnerability is also known in the literature as "UnrestrictedWrite"  \cite{tsankov_securify_2018} ,
"Storage modification" \cite{krupp_teether_2018},"Arbitrary Write"	\cite{SMARTIAN_2021} or "SWC-124: Write to Arbitrary Storage Location" \cite{swc}.

\subsection*{\textbf{4.14 Use of Malicious Libraries}}

This defect refers to the use of third-party libraries containing malicious code. This vulnerability is also known in the literature as "Malicious libraries"  \cite{tikhomirov_smartcheck_2018},
"Unknown libraries" \cite{lu_neucheck_2019}, or
"Dynamic libraries"  \cite{andesta_testing_2020}.


\subsection*{\textbf{4.15 Typographical Error}}

%\subsubsection*{5.6.1	Use of Incorrect Operator}

This defect refers to single-digit errors made by programmers while typing source code, e.g., in logic or arithmetic operations. For example, for value assignment, a developer may type by mistake "$+=$" instead of "$=$" or may use "$-$" instead of "$+$" or "$--$" instead of "$++$" \cite{Hartel2019}. This vulnerability is also known in the literature as 
"Assignment operator replacement", "Binary operator replacement",
 "Unary operator replacement or deletion" \cite{Hartel2019}, or "SWC-129 Typographical Error"	\cite{swc}.

 
%\begin{snugshade*}
\subsection*{\hl{\textbf{5. Incorrect Control Flow}}}
%\end{snugshade*}

This category groups a set of vulnerabilities that, if exploited, cause changes in the control flow of the program.

%\hl{FV. Sugestao: CWE-691: Insufficient Control Flow Management}

%\hl{FV. program behavioral problems (CWE-438)}

%\hl{FV.https://ieeexplore.ieee.org/document/8882745}

\subsection*{\textbf{5.1 Incorrect Sequencing of Behavior}}

This category gathers vulnerabilities that end up in a sequence of behaviors that are carried out in the wrong order, leading to unexpected results.


\subsubsection*{5.1.1 Incorrect Use of Event Blockchain variables for Time}

Contracts that rely on using block control information (i.e., timestamp, coinbase, number, difficulty, and gas limit) for sequential event control are vulnerable to tampering by the miner. This vulnerability is also known in the literature as 
"Block state dependence"  \cite{kalra_zeus_2018},
"Time restrictions"  \cite{arganaraz_detection_2020},
"Blockchain effects time dependency" \cite{zhang_ethploit_2020}, "Block State Dependency"	\cite{SMARTIAN_2021},
"Timestamp dependence" \cite{Ma2022, Hu2023,song_machine_2019,wang_contractward_2020,andesta_testing_2020,akca_solanalyser_2019,feng_precise_2019,luu_making_2016,nguyen_sfuzz_2020,ashraf_gasfuzzer_2020,Chen2020a,jiang_contractfuzzer_2018,tikhomirov_smartcheck_2018, zhang_soliditycheck_2019},
"Block number dependency"    \cite{Chen2020a,jiang_contractfuzzer_2018},
"BlockTimestamp" \cite{liao_soliaudit_2019},
"Time dependency" \cite{liao_soliaudit_2019},
"Race condition" \cite{ashouri_etherolic_2020}
"Block No. Dependency" \cite{ashraf_gasfuzzer_2020}, 
"Block number dependency" \cite{nguyen_sfuzz_2020}, 
"Event-ordering (EO) bugs" \cite{kolluri_exploiting_2019} or "SWC-116: Block values as a proxy for time" \cite{swc}.



\subsubsection*{5.1.2 Incorrect Function Call Order}

This defect refers to the creation of public functions that expect to be called in a certain sequence, originating unanticipated results whenever clients do not follow the right call order \cite{mavridou_designing_2018}. This vulnerability is also known in the literature , "Transaction-ordering dependence"   \cite{mavridou_designing_2018} or "SWC-114: Transaction Order Dependence" \cite{swc}.
 


\subsubsection*{5.1.3 Improper Locking}

This issue refers to the case where a contract assumes that all entities participating in a transaction must have the same credit balance before the contract operations can execute. If there are no adequate (e.g., wrong or even missing) locking mechanisms, an attacker can forcefully send credit to the other entity, which would cause the verification of the balance condition to never be met. Thus, the contract may become unusable or show unexpected behavior (or unexpected state changes). This vulnerability is also known in the literature as 
"IncorrectEquality" \cite{tsankov_securify_2018}, 
"Balance equality"  \cite{tikhomirov_smartcheck_2018, zhang_soliditycheck_2019},
"Strict equality"  \cite{lu_neucheck_2019},
"Strict Check for Balance" \cite{Chen2020a}, 
"Arbitrary sending of ether"  \cite{feist_slither_2019} or "SWC-132: Unexpected Ether balance" \cite{swc}.


\subsubsection*{5.1.4 Transfer Pre-Condition Dependent on Transaction Order}

In the case of this vulnerability, the order in which transactions are executed influence a pre-condition that guards the execution of the transfer. This influence may erroneously result in, for instance, a transaction not being executed at all. This defect is known in the literature as TODTransfer \cite{tsankov_securify_2018},
TOD \cite{SAILFISH_2022} or
Transaction Order Dependence  \cite{swc}.


\subsubsection*{5.1.5 Transfer Amount Dependent on Transaction Order }

This issue refers to the case where the value of the variable that stores or determines an amount of a digital asset (to be transferred) is modified before it is sent to the recipient due to transaction ordering within a block. The amount may be changed due to the effect of multiple transactions being grouped in a block and executed in a specific order having the effect of producing unexpected changes in the value being transferred. This vulnerability is also known in the literature as "TODAmount"  \cite{tsankov_securify_2018} ,
"TOD" \cite{liao_soliaudit_2019,wang_contractward_2020,SAILFISH_2022} or "SWC-114: Transaction Order Dependence" \cite{swc}.


\subsubsection*{5.1.6 Transfer Recipient Dependent on Transaction Order}

In the case of this defect, the transfer recipient is modified before the send event due to transaction ordering within a block. As an example, if the intended recipient address is stored as a storage variable and a transfer is to execute based on this address, there is a chance the address may be changed or overwritten by another transaction prior to the transfer. This vulnerability is also known in the literature as  "TODReceiver"  \cite{tsankov_securify_2018} , 
"Direct value transfer"  \cite{krupp_teether_2018}, "Transaction order dependence"  \cite{kalra_zeus_2018,Hu2023}, "Transaction-ordering dependence" \cite{song_machine_2019, bauer_semantic_2018, luu_making_2016,grieco_echidna_2020}, "TOD" \cite{SAILFISH_2022} or  "SWC-114: Transaction Order Dependence" \cite{swc}.

%Extraneous
\subsubsection*{5.1.7 Exposed state variables}

This vulnerability refers to the case where a developer erroneously exposes a state variable, whose value may then be modified by an attacker so that this modification influences the execution of a certain contract operation. As an example, consider a contract that executes a credit transfer from one user to another and has a \texttt{require} statement for verifying that there is sufficient credit to conclude the operation. If the balance is stored as a public state variable, a malicious use could change its value so that the \texttt{require} is avoided allowing the user to run a transfer that exceeds the amount of credit actually held by the malicious user. This vulnerability is also known in the literature as "Vulnerable state" \cite{krupp_teether_2018}.



\subsection*{\textbf{5.2 Inadequate Input Validation}}

This group refers to defects involving the inadequate validation of functional conditions, which are requirements that a contract must meet so that it can operate correctly. Such conditions may offer protection against certain types of attacks or force certain business rules to be followed.

\subsubsection*{5.2.1 Improper Input Validation}

This type of problem occurs when an attacker calls a certain contract operation using invalid or malicious input data, capable of affecting the functioning of the contract due to the fact that either it does not validate the incoming inputs or validates them in an incorrect manner. For instance, in the context of Solidity, a Short Address Attack occurs when a contract receives less data than it was expecting, which leads the system to fill the missing bytes with zeros \cite{Chen2020a}. As a consequence, the behavior may become unexpected if the code assumes that the input data will comply with a certain length or format. This vulnerability is also known in the literature as 
"Invalid input data" \cite{Chen2020a,grieco_echidna_2020},
"Short address attack" \cite{ashouri_etherolic_2020},
"Short address" \cite{feng_precise_2019}, or
"Avoid non-existing address" \cite{chang_scompile_2019}.

%SWC-110

\subsubsection*{5.2.2 Extraneous Input Validation}

In this particular case, the functional conditions of the contract are too strong and do not allow certain behaviors (which would be valid) to occur, making the contract unable to meet the requirements. This vulnerability is also known in the literature as "Requirement Violation"	\cite{SMARTIAN_2021} or 
"SWC-123 Requirement violation" \cite{swc}. 


%SWC-123
%4.4.2 
%Essa vulnerabilidade nao esta correta.. O texto foi se perdendo e a descricao abaixo nao condiz com o SWC-110. Ja temos o SWC-110 mapeado na 4.4.2.. entao nao temos referencia para o texto de baixo (embora a vulnerabilidade faca sentido), nao ha como evidenciar no moemento com referencias.

%\subsubsection*{5.2.3 Guard Function With no Effect}

%Guard functions protect the code against the execution in certain conditions (e.g., the \texttt{assert} and \texttt{require} functions). If programmed incorrectly, they have no effect on the code execution, becoming a useless test condition and consuming gas unnecessarily. In the case the guard function is inside a loop, the effect of this may be more serious. \hl{qual o nome? REF... dúvidas} \cite{swc}.

 

%\textbf{5.2	Control Flow Changes}

%This category groups defects in which the control flow execution differs from the intended execution, leading to unexpected behavior.


%\begin{snugshade*}
\subsection*{\hl{\textbf{6. Arithmetic Issues}}}
%\end{snugshade*}

This category groups different vulnerabilities that share the outcome of resulting in arithmetic problems.


\subsection*{\textbf{6.1 Overflow and Underflow}}

This category refers to the use of operations (e.g., addition, subtraction) over values that result in a value that is less than (or greater than) the minimum values (or maximum value) that a variable can hold, which produces a value different from the correct result.


\subsubsection*{6.1.1 Integer Underflow}

This defect refers to operations over an Integer variable that result in a value that is less than the minimum value allowed by the Integer type. This vulnerability is also known in the literature as  "Integer Bug"	\cite{SMARTIAN_2021},
"Integer underflow"  \cite{smartpulse_2021,song_machine_2019,momeni_machine_2019,wang_contractward_2020,kalra_zeus_2018},
"Integer overflow/underflow"  \cite{wang_vultron_2019,lu_neucheck_2019,so_verismart_2020},
"Integer overflow and integer underflow" \cite{ayoade_smart_2019},
"Arithmetic bugs" \cite{torres_osiris_2018},
"Underflow" \cite{liao_soliaudit_2019},
"Integer overflow and underflow" \cite{nguyen_sfuzz_2020,ashouri_etherolic_2020},
"Overflow/Underflow" \cite{Ma2022,Cui2022,Hu2023,akca_solanalyser_2019}, 
"Arithmetic issues" \cite{andesta_testing_2020} or "SWC-101: Integer Overflow and Underflow" \cite{swc}.

\subsubsection*{6.1.2	Integer Overflow}

This defect refers to operations over an Integer variable that results in a value that is larger than the maximum value allowed by the Integer type. This vulnerability is also known in the literature as  "Integer Bug"	\cite{SMARTIAN_2021},
"Integer overflow" \cite{smartpulse_2021,wang_contractward_2020,kalra_zeus_2018},
 "Integer overflow/underflow" \cite{Ma2022,Cui2022,Hu2023,so_verismart_2020,wang_vultron_2019},
"Integer overflow and integer underflow" \cite{ayoade_smart_2019},
"Integer overflows" \cite{grieco_echidna_2020,grech_madmax_2020},
"Arithmetic Bugs" \cite{torres_osiris_2018}, 
"Overflow detector" \cite{gao_easyflow_2019}, 
"Overflow" \cite{liao_soliaudit_2019},
"Integer overflow and underflow"  \cite{nguyen_sfuzz_2020,ashouri_etherolic_2020},
"BatchOverflow" \cite{feng_precise_2019},
"Overflow/Underflow" \cite{akca_solanalyser_2019},
"Arithmetic issues"  \cite{andesta_testing_2020}, 
"Integer Overflow vulnerability"   \cite{song_machine_2019} or "SWC-101: Integer Overflow and Underflow" \cite{swc}.


\subsection*{\textbf{6.2 Division Bugs}}

This category groups issues related to erroneous division operations. 

\subsubsection*{6.2.1 Divide by Zero}

This issue refers to the attempt of a program to divide a value by zero. This vulnerability is also known in the literature as 
"Division-by-zero" \cite{so_verismart_2020},
"Arithmetic Bugs" \cite{torres_osiris_2018}, or
"Division by zero" \cite{akca_solanalyser_2019}.


\subsection*{6.2.2	Integer Division}

At the time of writing, a smart contract mainstream language like Solidity does not support floating point or decimal types. Thus, the remainder of a division operation is always lost. Developers may use fixed-point arithmetic and external libraries to handle this kind of operation. This vulnerability is also known in the literature as  "Numerical Precision Error" \cite{Cui2022},
"Integer division" \cite{tikhomirov_smartcheck_2018} ,
"Using fixed point number type" \cite{zhang_soliditycheck_2019} or "SWC-101: Integer Overflow and Underflow" \cite{swc}.

\subsection*{\textbf{6.3 Conversion Bugs}}

This category groups a set of vulnerabilities where there are issues related to the conversion between different datatypes.

\subsubsection*{6.3.1 Truncation Bugs}

This vulnerability refers to the case where a variable declared in a certain type is converted to a smaller type, which means that data is lost during the conversion process. This vulnerability is also known in the literature as "Truncation bugs"  \cite{torres_osiris_2018} or "SWC-101: Integer Overflow and Underflow" \cite{swc}.

\subsubsection*{6.3.2 Signedness Bugs}

The conversion of a signed integer type to an
unsigned type of the same width may change a negative value to a positive one (the opposite may also happen) \cite{torres_osiris_2018}. This vulnerability is also known in the literature as "Signedness bugs" \cite{torres_osiris_2018} or "SWC-101: Integer Overflow and Underflow" \cite{swc}.

%\begin{snugshade*}
\subsection*{\hl{\textbf{7. Improper Access Control}}}
%\end{snugshade*}

This category groups a set of vulnerabilities that are strongly related to authentication or access control.

\subsection*{\textbf{7.1	Incorrect Authentication or Authorization}}

The smart contract fails to properly identify a client or determine its privileges, resulting in wrong access privileges for that particular client.

\subsubsection*{7.1.1 Wrong Caller Identification}

In Solidity, \texttt{tx.origin} allows obtaining the address of the account that initiated a transaction and \texttt{msg.sender} allows obtaining the address of the contract that has called the function being executed. The use of the \texttt{tx.origin} for access control may be a way of opening an entry point to a malicious user. A malicious user may create a contract that calls the vulnerable function (i.e., the one that uses \texttt{tx.origin} to check the identity of the caller). Thus, \texttt{msg.sender} will differ from \texttt{tx.origin}. In the case the vulnerable function uses \texttt{tx.origin} for access control, it will allow the user to perform actions it should not be able to. This vulnerability is also known in the literature as  "Transaction Origin Use"	\cite{SMARTIAN_2021},
"Transaction state dependence" \cite{kalra_zeus_2018},  
"Use of origin" \cite{Brent2018}, 
"TxOrigin" \cite{Hu2023,Li2023,akca_solanalyser_2019,liao_soliaudit_2019,tsankov_securify_2018},  "Tx.origin for authentication" \cite{zhang_soliditycheck_2019},  "Tx.origin" \cite{lu_neucheck_2019,tikhomirov_smartcheck_2018}, 
"Incorrect Check for Authorization" \cite{Chen2020a}, 
"Unprotected usage of tx.origin" \cite{momeni_machine_2019} or "SWC-115: Authorization through tx.origin" \cite{swc}.

\subsubsection*{7.1.2 Owner Manipulation}

%\hl{o owner no texto original estava como exemplo, mas o nome indica mesmo owner. O problema refere-se apenas a owner ou pode ser outra coisa?}
%\hl{FV sim, na referncia 83 é bem especifico sobre o problema de definir o owner de forma incorreta. O Owner deve ser definido no construtor do contrato (que é quando o contrato é deployed na blocchain. Se fazer a definicao do ower por outro tipo de mecanismo é uma vulnerabilidade, poruqe permite a atacantes explorarem e trocaremo owner para eles propprios)}.

This vulnerability allows an attacker to exploit some function or feature of the smart contract by manipulating the owner control variable. This allows the attacker to perform some kind of restricted operations \cite{zhang_ethploit_2020}. This vulnerability is also known in the literature as  "Missing Owner Check"	\cite{Cui2022}, "Unprotected Function" \cite{smartpulse_2021},
"Vulnerable access control" \cite{zhang_ethploit_2020},
"Access control" \cite{feng_precise_2019,lu_neucheck_2019}, or
"Tainted owner variable" \cite{brent_ethainter_2020}

%\subsubsection*{7.1.3 Tampering resources through external function (5.2.1)}
%\hl{veio do grupo 5. Coloquei aqui por causa do owner, a ref. também é mesmo especifica do owner -  agora ao ver... será a mesma do 7.1.2? A descrição é muito parecida}
%The contract has external functions that allow an attacker to change the program flow, namely by allowing changes to the ownership of the contract. A contract may have an external function to change the owner of the contract, which could be used by an attacker to perform the change to their own address and gain full control of the contract. This vulnerability is also known in the literature as  .


\subsubsection*{7.1.3 Missing Verification for Program Termination}

This issue refers to the lack of a secure verification for terminating a published (deployed) contract, allowing an attacker to terminate it in an unauthorized manner. \texttt{Selfdestruct} is an EVM instruction that is able to nullify the bytecode of a deployed contract. When invoked, it stops the execution of the EVM, deletes the contract’s bytecode, and sends the remaining fund to a certain address. Access to this kind of function by non-authorized clients may result in security issues. This vulnerability is also known in the literature as  "Suicidal Contract"	\cite{SMARTIAN_2021},
"Unprotected Suicide"	\cite{Hu2023},
"Destroyable contract" \cite{Brent2018},
"SelfDestruct" \cite{liao_soliaudit_2019},
"Suicidal contracts" \cite{feist_slither_2019},
"Guard suicide" \cite{chang_scompile_2019},
"Unprotected usage of selfdestruct" \cite{momeni_machine_2019},
"Accessible selfdestruct" \cite{brent_ethainter_2020},
"Tainted selfdestruct" \cite{brent_ethainter_2020} or "SWC-106: Unprotected SELFDESTRUCT Instruction" \cite{swc}.

\subsection*{\textbf{7.2 Improper Protection of Sensitive Data}}

This category generally refers to the issues that result in the inability to protect sensitive information from non-authorized clients.

\subsubsection*{7.2.1 Exposed Private Data}

This issue refers to the cases in which contracts store unencrypted sensitive data in public blockchain transactions. Solidity, like other programming languages, support the \texttt{private} keyword that indicates that data is only accessible within the contract itself. However, in blockchain environments, marking a variable with \texttt{private} does not make it fully invisible to the outside world. Miners, which are responsible for validating transactions on the blockchain, can view the code of the contract and the value of its state variables \cite{zhang_soliditycheck_2019}. This vulnerability is also known in the literature as 
"Keeping Secrets" \cite{arganaraz_detection_2020},
"Exposed secret" \cite{zhang_ethploit_2020}, 
"Private modifier" \cite{lu_neucheck_2019,tikhomirov_smartcheck_2018,zhang_soliditycheck_2019} or "SWC-136: Unencrypted Private Data On-Chain"  \cite{swc}.



\subsubsection*{7.2.2 Dependency on External State Data (Unsolvable constraints of external critical state data)}

This vulnerability refers to the use of data that is not under control nor is generated by the contract (i.e., external critical state data). A malicious user may exploit this situation if such data determines the outcome of the execution of the contract. This vulnerability is also known in the literature as 
"Unsolvable constraints" \cite{zhang_ethploit_2020}.


\subsection*{\textbf{7.3 Cryptography Misuse}}

This category groups vulnerabilities that generally reflect misuse of cryptography mechanisms.

\subsubsection*{7.3.1 Incorrect Verification of Cryptographic Signature} 

This issue refers to the wrong verification of the authenticity and integrity of messages with the use of message signatures. As an example, a developer could develop a vulnerable contract that relies on a signature in a signed message hash for representing the earlier verification of previous messages. A client could generate a malicious message with a valid signature and include it in the hash. The contract then would validate the signature and update the hash, indicating that the message was processed. This vulnerability is also known in the literature as  "Missing Key Check"	\cite{Cui2022},
"SWC-117: Signature Malleability" \cite{swc}. 

\subsubsection*{7.3.2 Improper Check against Signature Replay Attacks}

This defect refers to a situation where a malicious client is able to obtain the message hash of a legitimate transaction and is allowed to use the same signature to impersonate the legitimate client and execute fraudulent transactions. This vulnerability is also known in the literature as 
"SWC-121: Missing Protection against Signature Replay Attacks" \cite{swc}.


\subsubsection*{7.3.3 Improper Authenticity Check}

In this case, a contract may tolerate off-chain signed messages instead of waiting for an on-chain signature. This is usually done with the goal of improving performance but may come at the expense of compromising the authenticity of the message. This vulnerability is also known in the literature as "Missing Signer Check"	\cite{Cui2022},
"SWC-122: Lack of proper signature verification" \cite{swc}.


\subsubsection*{7.3.4. Incorrect Argument Encoding}

This defect refers to the misuse of one-way hash functions (i.e., Solidity keccak256) namely in the incorrect encoding of the function arguments, which can result in a higher likelihood of hash collisions for different entries. This vulnerability is also known in the literature as
"Authorization" \cite{mavridou_designing_2018} ,
"Hash collision" \cite{lu_neucheck_2019} or "SWC-133: Hash Collisions With Multiple Variable Length Arguments" \cite{swc}.