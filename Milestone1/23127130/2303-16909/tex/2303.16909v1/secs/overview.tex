%!TEX root = ../main.tex
\section{System Architecture}
\label{sec:overview}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!t]
    \centering 
    \includegraphics[width=.9\textwidth]{figs/overview.pdf}
    %\vspace{-2em}
    \caption{An Overview of \sys.}
    \label{fig:overview} 
    \vspace{-1em}
 \end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Figure~\ref{fig:overview} shows the architecture of \sys. 
%In this section, we explain each of its components.

\stitle{User Input.}
The user uploads a relational table and indicates which column(s) contain the missing values to be fixed. The user can optionally specify a subset of non-dirty pivot  columns as relevant
to the cleaning task (i.e., these columns functionally determine the values in the dirty column). 

Take the following configuration as an example (refer to the $3^{rd}$ column in ``health.csv'' table in Figure~\ref{fig:overview}):
\begin{lstlisting}[language=Python, caption=Not retrieval-based configuration]
table = "health.csv"
dirty_column = "Gender"
relevant_columns = ['Name','Age'] 
value = 'NULL'
is_local_model = False # use ChatGPT
\end{lstlisting}
\vspace{-2mm}
Here,  the user wants to impute the missing  values (indicated by value = NULL) 
in the Gender column. 
The Name and Age columns are identified as the pivot columns.
Assuming that these columns are not highly sensitive, the user asks \sys to use \chat to perform the missing value imputation task.

Another example of a configuration is (refer to the $4^{th}$ column in ``health.csv'' table):
\begin{lstlisting}[language=Python, caption=Retrieval-based configuration]
table = "health.csv"
dirty_column = "BT" # BT is blood type
relevant_columns = ALL 
value = 'NULL'
datalake = "/Users/hosp_tables/" # A folder of CSV files
is_local_model = True 
\end{lstlisting}
\vspace{-2mm}
Here, the user wants to impute the missing values in the Blood Type (BT) column. 
Such details are most probably not available as world knowledge, but could be available in a local data lake, \eg a hospital database. 
Therefore, the user opts for and specifies the use of a data lake.
The local mode flag is set to True, which indicates the use of the custom local foundation model, possibly for privacy concerns. 


We offer a user-friendly Graphical User Interface (GUI)  (see  Section~\ref{sec:scenarios}) to simplify the process of specifying the user's requirements.


\stitle{Non-retrieval based data cleaning.}
\sys employs a tuple-by-tuple cleaning approach. 
%to address dirty data. 
In the case the user opts for non-retrieval-based methods (\eg cleaning $t_1$ and $t_4$ in column Gender), \sys reads one tuple at a time and passes it to \chat in the \att{Reasoner} module. 
In this case, retrieval-related modules (i.e., the Indexer and Reranker) are bypassed. 
This allows \chat to impute values for $t_1$ and $t_4$, as depicted in the output of Figure~\ref{fig:overview}. 


\stitle{Retrieval-based data cleaning.}
If the user opts for a retrieval-based method, \sys will index all tuples in the specified data lake. 
The \att{Tuple-Based Indexer} module supports both a syntactic index using Elasticsearch and a semantic index using Meta Faiss~\cite{faiss}. 
The indexes are typically constructed offline--but for the demo purpose, we allow uploading small data lakes for on-the-fly indexing. 
Then, given a dirty tuple (\eg $t_2$ in the BT column), 
\sys first retrieves the top-$n$ relevant tuples, where $n$ is large enough (e.g., $n = 100$) for ensuring high recall. 
Then, the tuples are passed to the \att{Reranker} module. The main role of the \att{Reranker}
is to refine and reorder the retrieved tuples using more advanced methods, e.g., ColBERT~\cite{colbert} or CrossBERT~\cite{crossbert}, and finally produces the top-$k$ candidates, where $k \ll n$ (\eg $k = 5$), to ensure high precision. The \att{Reranker} and \att{Reasoner} are designed as separate modules to provide flexibility so we can easily use \chat as the \att{Reasoner}.


Given a dirty tuple (\eg $t_2$) and top-$k$ retrieved tuples, the \att{Reasoner} module employs either \chat or the local model to determine the appropriate retrieved tuple to use (matching step) and the value to extract for cleaning the dirty value (extraction). This step is performed in a pair-wise fashion, i.e., the query tuple and each individual retrieved tuple will form a candidate pair that is passed to the \att{Reasoner} module.
The module not only infers the imputed value (\eg blood type B for $t_2[BT]$), but also identifies the tuple and attribute from which the value is obtained (i.e., the lineage information), as demonstrated in the output of Figure~\ref{fig:overview} (the dotted lines in the output box).
It is important to note that the matching step here is beyond simple entity matching, our aim is to find any tuple in the data lake that semantically overlaps with the input tuple to be cleaned.

\stitle{Remarks.} 
\sys can also be used to detect and repair data errors. For instance, if the user wishes to validate all Gender values, then Line 4 in the example configurations (Listings 1 and 2) is omitted, and thus \sys will infer all values, and then compare the inferred values with the existing values (if present) to identify and rectify data errors.

%We will present demonstration scenarios in Section~\ref{sec:scenarios} and discuss implementation details and preliminary results in Section~\ref{sec:details}.