\section{\optimizationproblem: Problem Setup}
\label{sec:problem_setup}

This section formally defines \optimizationproblem, namely \textit{speeding up MV refresh runs via intermediate data storage under bounded memory}.
\Cref{tbl:symbols} lists symbols we use in describing \optimizationproblem.


\mypara{Problem Inputs} \optimizationproblem has 3 inputs:

\begin{enumerate}
    \item A directed acyclic graph (DAG) $\mathcal{G} := \{\mathcal{V}, \mathcal{E}\}$ of the MV refresh run.
    $\mathcal{V} = \{v_1,...,v_n\}$ is the set of $n$ individual MV updates (nodes), and $\mathcal{E}$ is the set of dependencies between the MV updates (edges). 
    \item The set of intermediate table sizes produced by each node $\mathcal{S} = \{s_1,...,s_n\}$, which we will abbreviate as \textit{node sizes}. 
    Each $s_i$ measures the amount of memory space required to keep the intermediate table produced by $v_i$.
    \item The set of speedup scores of each node $\mathcal{T} = \{t_1,...,t_n\}$, where $t_i$ measures the estimated speedup for the MV refresh run achieved by keeping the output of $v_i$ in memory (which we say \textit{flagging the node}).
\end{enumerate}

\begin{table}[t]
\centering
\caption{Table of Symbols}
\label{tbl:symbols}

\vspace{-2mm}
\small
\begin{tabular}{ll}
\toprule
\textbf{Symbols}              & \textbf{Definition}           \\ \midrule
$\mathcal{G} := \{\mathcal{V}, \mathcal{E}\}$         & The dependency graph                    \\
$\mathcal{V} = \{v_1,...,v_n\}$            & Set of $|\mathcal{V}| = n$ nodes       \\
$\mathcal{E}$            & Set of $|\mathcal{E}| = m$ dependencies            \\
\hline
$\mathcal{S} = \{s_1,...,s_n\}$        & Set of intermediate table (node) sizes \\
$\mathcal{T} = \{t_1,...,t_n\}$        & Set of speedup scores    \\\hline
$M$ & \memory size      \\\hline
$\tau: [1..n] \rightarrow [1..n]$ & MV refresh (execution) order   \\
$\mathcal{U} \subseteq \mathcal{V}$ & \makecell[l]{Nodes results kept in memory (flagged nodes)}     \\
\bottomrule
\end{tabular}
\vspace{-4mm}
\end{table}

\mypara{Speedup Scores} 
The speedup score $t_i$ of node $n_i$ is computed as follows:
\begin{multline*}
t_i = \Big( \sum\nolimits_{(v_i, v_j) \in \mathcal{E}} \text{data-access-time}(v_j | v_i\, \text{on disk}) 
    \\[-0.2em]-  \text{data-access-time}(v_j | v_i\, \text{in memory}) \Big) 
    \\[-0.2em] + \text{time}(\text{create}\, v_i\, \text{on disk}) 
        -  \text{time}(\text{create}\, v_i\, \text{in memory})
\end{multline*}

\noindent
Speedup $t_i$ of flagging $v_i$ is computed w.r.t.~to the baseline approach of performing MV refresh operations sequentially: 
For each downstream node $v_j$ depending on $v_i$, data access time is saved by reading $v_i$ from memory instead of from external storage. For executing $v_i$, write time can be reduced by materializing $v_i$ to external storage in parallel with minimal interference with downstream computations. (\Cref{sec:job_representation})


\mypara{Memory Usage and Execution Order}

Given the \memory size $M$, the peak memory usage of an MV refresh run---the maximum combined size of flagged nodes coexisting in memory---at any time during the run should not exceed $M$. 
The peak memory usage of a set of flagged nodes depends on the execution order $\tau: [1..n] \rightarrow [1..n]$ in which the nodes are executed: $v_i$ is the $\tau(i)^{th}$ executed node.

The execution order determines when a flagged node can be released from memory---a flagged node can be released only when all of its downstream nodes (children) are computed. 
Hence, it plays a key role in determining the feasibility of a set of flagged nodes under the \memory size constraint.  
A good execution order will allow us to release flagged nodes faster, which in turn allows us to flag more nodes throughout the MV refresh run, leading to a higher total speedup score under the same \memory size constraint.

\subfile{plots/fig_toy_example}

Consider the toy example shown in \cref{fig:toyexample}.
For simplicity, assume the speedup score of a node is equal to its size in GB; ideally, we want to flag both 100GB nodes $v_1$ and $v_3$ with \memory size $M=100GB$. 
As $v_1$ can be released after $v_4$ is executed, $\tau_2$ allows both $v_1$ and $v_3$ to be flagged by executing $v_4$ before $v_3$, while $\tau_1$ does not. The maximum possible  score of $210$ is achieved under $\tau_2$ by flagging both of $v_1$ and $v_3$ (and $v_6$). This is much higher than the maximum possible score of $120$ achieved by flagging $v_1, v_5, v_6$ under $\tau_1$.

\mypara{Problem Definition}

According to our problem setup, we define \optimizationproblem as a joint optimization problem of the set of flagged nodes $\mathcal{U}$ and execution order $\tau$:

\begin{problem}{\optimizationproblem}
\label{prof:optimization}
\begin{description}[leftmargin=1.25cm]
\item[\normalfont Input:\,\,\,\,\hspace{0.05em}]\begin{enumerate}
    \item Dependency graph $\mathcal{G} = \{\mathcal{V}, \mathcal{E}\}$
    \item Node sizes $\mathcal{S}$
    \item Speedup scores $\mathcal{T}$
    \item \memory size $M$
\end{enumerate}
\item[\normalfont Output:]\begin{enumerate}
    \item A subset $\mathcal{U} \subseteq \mathcal{V}$ of flagged nodes
    \item An execution order $\tau$
\end{enumerate}
\item[\normalfont Objective function:]
    Maximize total speedup score $\sum_{i: v_i \in \mathcal{U}} t_i$ of flagged nodes
\item[\normalfont Constraint:]
    Flagging $\mathcal{U}$ is feasible under execution order $\tau$ and \memory size $M$
\end{description}
\end{problem}

