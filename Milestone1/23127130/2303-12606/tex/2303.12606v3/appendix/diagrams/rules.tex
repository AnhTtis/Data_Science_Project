%!TEX root = ../../main.tex
\section{Rules of the operational semantics (Section~\ref{ssec:semantics}).}
\label{app:rules}


\begin{figure} [H]
    \small
      \centering
      \begin{mathpar}
        \inferrule[spawn]{\tr \mbox{ fresh}\quad e \mbox{ fresh}\quad  \mathsf{P}(j) = \ibegin; \mathsf{Body}; \icommit; \mathsf{S} \quad \vec{\mathsf{B}}(j) = \epsilon}{
          \hist,\vec{\gamma},\vec{\mathsf{B}},\mathsf{P}
          \Rightarrow_I
          \hist \oplus_j \tup{\tr,\{\tup{e,\ebegin}\},\emptyset},\vec{\gamma}[j\mapsto \emptyset],\vec{\mathsf{B}}[j\mapsto \mathsf{Body}; \icommit],\mathsf{P}[j\mapsto \mathsf{S}]
        } 
    
        \inferrule[if-true]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ true} \\
        \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{Instr};\mathsf{B}],\mathsf{P}
        } 
    
        \inferrule[if-false]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ false} \\
        \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
        } 
    
        \inferrule[local]{v = \vec{\gamma}(j)(e) \\ \vec{\mathsf{B}}(j) = a := e;\mathsf{B}
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist,\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
        } 
    
        \inferrule[write]{v = \vec{\gamma}(j)(x)\quad e\mbox{ fresh} \quad 
        \vec{\mathsf{B}}(j) = \iwrite(\key,\xvar);\mathsf{B}\quad \hist \oplus_j \tup{e,\ewrt{\key,\val}}\mbox{ satisfies $I$}
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist \oplus_j \tup{e,\ewrt{\key,\val}},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}], \mathsf{P}
        } 
    
        \inferrule[read-local]{
        \writeOp{\mathit{last}(\hist,j)}\mbox{ contains a }\wrt{\key}{\val}\mbox{ event}\\
        e\mbox{ fresh } \\
        \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B}
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist \oplus_j \tup{e,\erd{\key}},\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
        } 
    
        \inferrule[read-extern]{
        \writeOp{\mathit{last}(\hist,j)}\mbox{ does not contain a }\wrt{\key}{\val}\mbox{ event} \\
        e\mbox{ fresh }\\
        \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B} \\
        \hist=(T,\so,\wro) \\
        \tr =\mathit{last}(\hist,j) \\
        \wrt{\key}{\val}\in\writeOp{\tr'}\mbox{ with $\tr'\in \transC{\hist}$ and $\tr\neq \tr'$} \\
        \hist' = (\hist \oplus_j \tup{e,\erd{\key}}) \oplus \wro(\tr',e) \\
        \hist' \mbox{ satisfies }I }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist',\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
        } 
    
        \inferrule[commit]{e\mbox{ fresh} \quad 
        \vec{\mathsf{B}}(j) = \icommit 
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist \oplus_j \tup{e,\icommit},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \epsilon], \mathsf{P}
        } 
    
        \inferrule[abort]{e\mbox{ fresh} \quad 
        \vec{\mathsf{B}}(j) = \iabort; B
        }{
          \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
          \Rightarrow_I
          \hist \oplus_j \tup{e,\iabort},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \epsilon], \mathsf{P}
        }
      \end{mathpar}
    % \vspace{-5mm}
      \caption{An operational semantics for transactional programs. Above, $\mathit{last}(h,j)$ denotes the last transaction log in the session order $\so(j)$ of $h$, and $\transC{\hist}$ denotes the set of transaction logs in $\hist$ that are committed}.
      \label{fig:op:sem:baseline}
    \end{figure}
    
Figure~\ref{fig:op:sem:baseline} uses the following notation. Let $\hist$ be a history that contains a representation of $\so$ as above. We use $\hist\oplus_j \tup{\tr,E,\po_t}$ to denote a history where $\tup{\tr,E,\po_t}$ is appended to $\so(j)$. 
Also, for an event $e$, $\hist\oplus_j e$ is the history obtained from $\hist$ by adding $e$ to the last transaction log in $\so(j)$ and as a last event in the program order of this log (i.e.,  if $\so(j)=\sigma; \tup{t,E,\po_t}$, then the session order $\so'$ of $\hist\oplus_j e$ is defined by $\so'(k)=\so(k)$ for all $k\neq j$ and $\so(j) =\sigma; \tup{t,E\cup\{e\},\po_t\cup \{(e',e): e'\in E\}}$). Finally, for a history $\hist = \tup{T, \so, \wro}$, $\hist\oplus\wro(\tr,e)$ is the history obtained from $\hist$ by adding $(\tr,e)$ to the write-read relation.

\textsc{spawn} starts a new transaction in a session $j$ provided that this session has no live transaction ($\vec{\mathsf{B}}(j) = \epsilon$). It adds a transaction log with a single $\ebegin$ event to the history and schedules the body of the transaction. \textsc{if-true} and \textsc{if-false} check the truth value of a Boolean condition of an $\mathtt{if}$ conditional. \textsc{local} models the execution of an assignment to a local variable which does not impact the stored history. \textsc{read-local} and \textsc{read-extern} concern read instructions. \textsc{read-local} handles the case where the read follows a write on the variable $x$ in the same transaction: the read returns the value written by the last write on $x$ in that transaction. Otherwise, \textsc{read-extern} corresponds to reading a value written in another transaction $\tr'$. The transaction $\tr'$ is chosen non-deterministically as long as extending the current history with the write-read dependency associated to this choice leads to a history that still satisfies $I$. \textsc{read-extern} applies only when the executing transaction contains no write on the same variable. \textsc{commit} confirms the end of a transaction making its writes visible while \textsc{abort} ends the transaction's execution immediately.

    