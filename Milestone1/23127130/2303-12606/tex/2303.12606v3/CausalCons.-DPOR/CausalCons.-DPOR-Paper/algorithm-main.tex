%!TEX root = main.tex
\section{Swapping-based model checking for Prefix-Closed and Causally-Extensible Isolation Levels}
\label{sec:CC-algorithm}

%The main goal in this section is describing a deterministic algorithm for transactional model-checking under a causally-closed model $\mathcal{M}$ that obtains all possible behaviors a program may have. We present during this section a swapping-based sound, complete and optimal algorithm employing polynomial memory. In particular, we will show that our algorithm has at most one pending transaction and why this is key to guarantee the rest of the properties. For the legibility of this document, we will postpone their proofs to section \ref{sec:proofs-algorithm}.

We define a concrete implementation of $\textsc{explore}$, denoted as $\textsc{explore-ce}$, that is $I$-sound, $I$-complete, and strongly optimal for any isolation level $I$ that is prefix-closed and causally-extensible. The isolation level $I$ is a parameter of $\textsc{explore-ce}$. The space complexity of $\textsc{explore-ce}$ is polynomial in the size of the program. An important invariant of this implementation is that it explores histories with \emph{at most one} pending transaction and this transaction is maximal in session order. This invariant is used to avoid fruitless explorations: since $I$ is assumed to be causally-extensible, there always exists an extension of the current history with one more event that continues to satisfy $I$. \nver{Moreover, this invariant is sufficient to guarantee completeness in the sense defined above of exploring all histories of ``full'' program executions (that end in a final configuration).}

Section~\ref{ssec:extensions} describes the implementations of $\genericNext$ and $\genericValidWrites$ used to extend a given execution, Section~\ref{subsection:SwappingHistories} describes the functions $\genericCompute$ and $\genericSwap$ used to compute re-ordered executions, and Section~\ref{ssec:optimality} describes the $\genericProtocol$ restriction on re-ordering. We assume that the function $\genericEvaluate$ is defined as simply $\genericEvaluate(\hist) ::= true$ (no filter before outputting). Section~\ref{ssec:corr} discusses correctness arguments\appendixver{ (see App.~\ref{sec:proofs-algorithm} for proofs)}.

\input{extending}

\input{swaps}

%\input{blocking-branches}

%\input{maximally-added}

\subsection{Correctness}\label{ssec:corr}

The following theorem states the correctness of the algorithm presented in this section:
\begin{restatable}{theorem}{algoCorrect}
\label{th:corr}
For any prefix-closed and causally extensible isolation level $I$, $\textsc{explore-ce}$ is $I$-sound, $I$-complete, strongly optimal, and polynomial space.
\end{restatable}

$I$-soundness is a consequence of the $\genericValidWrites$ and $\genericProtocol$ definitions which guarantee that all histories given to recursive calls are $I$-consistent, and of the $\genericSwap$ definition which ensures to only produce feasible histories (which can be obtained using the operational semantics defined in Section~\ref{ssec:semantics}). The fact that this algorithm never engages in fruitless explorations follows easily from causal-extensibility which ensures that any current history can be extended with any event returned by $\genericNext$. Polynomial space is also quite straightforward since the \textbf{for all} loops in Algorithm~\ref{algorithm:algo-class} have a linear number of iterations: the number of iterations of the loop in $\textsc{explore}$, resp., $\textsc{exploreSwaps}$, is bounded by the number of write, resp., read, events in the current history (which is smaller than the size of the program; recall that we assume bounded programs with no loops as usual in SMC algorithms). On the other hand, the proofs of $I$-completeness and optimality are quite complex. \oldver{For $I$-completeness, given a history $\hist\in \histOf[I]{\prog}$, we first show how to effectively compute the order $<$ associated to $\hist$ if $\textsc{explore}$ were to output this history. Then, we define an ``inverse'' of $\textsc{explore-sc}$ and an invariant on ordered histories reached by $\textsc{explore-sc}$, which enable constructing a chain of ordered histories going backwards from $(\hist,<)$ to the initial empty history. Then, we show that $\textsc{explore-sc}$ can proceed forwardly  in this chain and indeed output $\hist$.}


%In particular, we observe that if two transactions $t, t'$ have a $(\so \cup \wro)^*$ dependency, the history order in the algorithm orders them analogously. But if they are $(\so \cup \wro)^*$-incomparable, the algorithm prioritizes the one that is read by a smaller $\iread$ event according $\ora$. Combining both arguments recursively we obtain a \textit{canonical order} for a history, which is formally defined with the function presented below. 

\nver{$I$-completeness means that for any given program $\prog$, the algorithm outputs every history $h$ in $\histOf[I]{\prog}$. The proof of $I$-completeness defines a sequence of histories produced by the algorithm starting with an empty history and ending in $h$, for every such history $h$. 
% a collection of reachable histories that starts in the initial state and ends in $h$. The structure of the proof is as follows:
It consists of several steps:}
\begin{enumerate}
    \item \nver{Define a \emph{canonical} total order $<$ for every unordered partial history $h$, such that if the algorithm reaches $h_{<'}$, for some order $<'$, then $<$ and $<'$ coincide. This canonical order is useful in future proof steps as it allows to extend several definitions to arbitrary histories that are not necessarily reachable, such as $\genericProtocol$ or $\textsc{swapped}$.}
    \item \nver{Define the notion of \emph{$\ora$-respectfulness}, an invariant satisfied by every (partial) ordered history reached by the algorithm. Briefly, a history is $\ora$-respectful if it has only one pending transaction and for every two events $e, e'$ such that $e <_{\ora} e'$, either $e < e'$ or there is a swapped event $e''$ in between. 
%    We require of canonical order to proper define swapped events on arbitrary histories.
 } 
    \item \nver{Define a deterministic function $\prev$ which takes as input a partial history (not necessarily reachable), such that if $h$ is reachable, then $\prev(h)$ returns the history computed by the algorithm just before $h$ (i.e., the previous history in the call stack). Prove that if a history $h$ is $\ora$-respectful, then $\prev(h)$ is also $\ora$-respectful.}
    
    \item \nver{Deduce that if $h$ is $\ora$-respectful, then there is a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$, and $h_i = \prev(h_{i+1})$ for each $i$. The $\ora$-respectfulness invariant and the causal-extensibility of the isolation level are key to being able to construct such a collection. In particular, they are used to prove that $h_i$ has at most the same number of swapped events as $h_{i+1}$ and in case of equality, $h_i$ contain exactly one event less than $h_{i+1}$, which implies that the collection is indeed finite.}
    
    \item \nver{Prove that if $h$ is $\ora$-respectful and $\prev(h)$ is reachable, then $h$ is also reachable. Conclude by induction that every history in $H_h$ is reachable, as $h_0$ is the initial state and $h_i = \prev(h_{i+1})$.}
    %\item \nver{Constructing a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$.}
\end{enumerate}

%As $h_0$ corresponds to the initial state, we can thus conclude that $h$ is reachable by induction on the histories in $H_h$: the base case, $h_0$, is always reachable while if $h_i$ is reachable, by the property (1) of $\prev$, $h_{i+1}$ is also reachable. 

%Then, we can prove by exploiting property (2) of $\prev$ that, for every $\ora$-respectful history $h$ there exists a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$.

% Thirdly, we describe a function $\prev$ defined over the set of all partial histories that, if $h$ is reachable, $\prev(h)$ returns the previous history to $h$ computed by $\textsc{explore-ce}$. This function $\prev$ satisfies (1) the previous of an $\ora$-respectful history is also $\ora$-respectful and (2) if the previous of a history is reachable, then the history is reachable.

%\nver{ For showing $I$-completeness, we prove that for any given program $\prog$, it outputs every history $h$ in $\histOf[I]{\prog}$. For doing it so, we explicit show a collection of reachable histories that starts in the initial state and ends in $h$. However, algorithm \ref{algorithm:algo-class} works with ordered histories. Therefore, we first have to furnish $h$ with a total order called \textit{canonical order} that, if $(h, <)$ were reachable, it would coincide with its history order; so one can always work with histories instead of ordered histories. This order is based in two facts about our algorithm: (1) for every pair of transactions, if $(t, t') \in (\so \cup \wro)^*$ in $h$, then $t < t'$ and (2) if $t, t'$ are $(\so \cup \wro)^*$-incomparable, the algorithm prioritizes the one that is read by a smaller $\iread$ event according $\ora$. Secondly, we define the notion of \textit{$\ora$-respectfulness}, an invariant that every partial history reachable with $\textsc{explore-sc}$ satisfy. Briefly, a history is $\ora$-respectful if it has only one pending transaction and for every two events $e, e'$ such that $e <_{\ora} e'$, either $e < e'$ or there is a swapped event $e''$ in between. Thirdly, we describe a function $\prev$ defined over the set of all partial histories that, if $h$ is reachable, $\prev(h)$ returns the previous history to $h$ computed by $\textsc{explore-ce}$. This function $\prev$ satisfies (1) the previous of an $\ora$-respectful history is also $\ora$-respectful and (2) if the previous of a history is reachable, then the history is reachable. Then, we can prove by exploiting property (2) of $\prev$ that, for every $\ora$-respectful history $h$ there exists a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$. As $h_0$ corresponds to the initial state, we can thus conclude that $h$ is reachable by induction on the histories in $H_h$: the base case, $h_0$, is always reachable while if $h_i$ is reachable, by the property (1) of $\prev$, $h_{i+1}$ is also reachable. }

%Finally, albeit some intuition about the optimality arguments was given in Section~\ref{ssec:optimality}\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. If a history $h$ would have a computable path different, it would have a immediate predecessor $h'$ that is different than $\prev(h)$.}
%Finally, albeit some intuition about the optimality arguments was given in Section~\ref{ssec:optimality}
\nver{The proof of strong optimality relies on arguments employed for $I$-completeness. It can be shown that if the algorithm would reach a (partial) history $h$ twice, then for one of the two exploration branches, the history $h'$ computed just before $h$ would be different from $\prev(h)$, which contradicts the definition of $\prev(h)$.}

%\nver{On one hand, when no swaps are required for $\textsc{explore-ce}$ arrive to $h$ from $h'$, $\prev(h)$ coincide with $h'$ by definition of $\prev(h)$. On the other hand, if $h$ is obtained by swapping some read event with respect a transaction from $h'$ (potentially removing some other events in the process), we distinguish between two class of events in $h'$: the events that remain in $h$ and those which have been removed. The definition of $\prev$ function guarantees that $h'$ and $\prev(h)$ coincide on the events that are not deleted while the $\ora$-respectfulness of reachable histories and $\genericProtocol$'s definition allows us to conclude that they also coincide on the deleted events.}

%\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. Given a history $h$, the definition of both its canonical order and $\prev(h)$ only depends on the relations $\ora, \so$ and $\wro$. Thus, exploiting both notions we can deduce that every predecessor of a reachable history $h$ coincides with $\prev(h)$. By induction on the collection $H_h$, we conclude $h$ has only one computable path.}

\nver{In terms of time complexity, the $\textsc{explore-ce}(I)$ algorithm achieves polynomial time between consecutive outputs for isolation
levels $I$ where checking $I$-consistency of a history is polynomial time, e.g., \RC, \RA, and \CC.} 
%This
%would not be true for EXPLORE(I0, I) where I is SI or SER (checking consistency in this case
%is known to be NP-complete).

%\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. Simply, as both the canonical order and $\prev$ function's definition are agnostic of \textsc{explore-sc}'s procedure, every predecessor of a reachable history $h$ coincides with $\prev(h)$. By applying induction on the collection $H_h$, we conclude $h$ has only one computable path.}

%Reasoning by contradiction, if a reachable history $h$ with minimal number of events swapped would have two computable paths, it would have two predecessors $h_1$ and $h_2$; and without loss of generality, $h_1 = \prev(h)$. However, by defintion of $\prev$ we can conclude that actually $h_1 = h_2$.

%as well in property (2) of $\prev$. This property stablish an univoque correspondance between a reachable history and its predecsor, so when applied to the collection $H_h$ one can conclude there is only one reachable path from the initial state, $h_0$ to any other history.}

%Finally, albeit some intuition about the optimality arguments was given in Section~\ref{ssec:optimality}\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. In particular, the proof relies in the collection of histories $H_h$ defined during the proof of $I$-completeness as well in property (2) of $\prev$. This property stablish an univoque correspondance between a reachable history and its predecsor, so when applied to the collection $H_h$ one can conclude there is only one reachable path from the initial state, $h_0$ to any other history. }


% and secondly show how to define the inverse function of $\textsc{explore}$ and $\textsc{explore-sc}$ for, exploiting a common invariant on the histories explored by the algorithm, deducing a chain of histories starting from the initial state to $\hist$ and concluding that $\hist$ is indeed outputted. For $I$-optimality, we exploit the fact that the history order can be described without referencing any computable path along with the $\genericProtocol$ restriction on re-orderings, to conclude that there is only one possible branch that lead to it. See Appendix~\ref{sec:proofs-algorithm} (in the supplementary material) for more details.
%
%Strong optimality follows from causal extensibility which 
%
%. The former ensure that every extension with a new event returned by $\genericNext$ is $I$-consistent, and the latter implies that $\genericSwap$ outputs histories which are $I$-consistent because 
%
% and the definition 
%
% and causal extensibility: 
%\begin{itemize}
%	\item every history given as an input to a recursive call has at most one pending transaction and this is maximal in $(\so\cup\wro)+$, which implies that it admits an extension with any event,
%	\item and $\genericSwap$ outputs histories which modulo a last read in the pending transaction are prefixes of the input history, and therefore $I$-consistent assuming that the input one is.
%\end{itemize}
%
%As we show in Section~\ref{sec:proofs-algorithm}, the algorithm described above is $I$-sound assuming that $\genericEvaluate(\hist) ::= true$. Therefore, any history computed by applying the functions described above will satisfy the intended isolation level $I$.
%
%TODO THIS SHOULD PROBABLY BE ABOUT CORRECTNESS, STATING IT AND EXPLAINING A LITTLE BIT THE PROOFS.

%Altogether, our swapping-based algorithm can simply being defined as an instance of \ref{algorithm:algo-class}: $\textsc{explore}_{\mathcal{M}}(\nextEvent,\evaluate , \validWrites, \compute, \protocol, \swap)$. A full detailed pseudocode of this procedure can be seen as algorithm \ref{algorithm:optimal-instantiated}; with initial call $h = \emptyset$.

%\begin{algorithm}[H]
%	\caption{Optimal recursive \textsc{STMC}}
%	\begin{algorithmic}[1]
%		\InputAlgorithmic $h$: history
%		\Statex
%		\State $e \gets  \next(h)$
%		\If{$e = \bot$}
%		\If{$\evaluate(h)$}
%		\State \textbf{output} $h$
%		\EndIf
%		%\State $\textbf{\genericEvaluate}(h)$
%		\State \Return
%		\ElsIf{$\textsc{type}(e) = \iread$}
%		
%		\ForAll{$w \in \validWrites(h,e)$} %\writeVar{w}{x}
%		
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet_w e)$
%		\EndFor
%		\Else
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet e)$
%		\EndIf
%		
%		\Statex
%		
%		\ForAll{$(\alpha, \beta) \in \compute(h)$}
%		\If{$\protocol(h \bullet e, \alpha, \beta)$}
%		\State $\textsc{explore}_{\mathcal{M}}(\swap(h \bullet e, \alpha, \beta))$	
%		
%		\EndIf
%		\EndFor
%	\end{algorithmic}
%	\label{algorithm:optimal-instantiated}
%\end{algorithm}
