%!TEX root = main.tex
\section{Swapping-based model checking for Snapshot Isolation and Serializability}\label{sec:ser}

%As show in section \ref{sec:proofs-algorithm}, algorithm \ref{algorithm:optimal-instantiated}'s completeness proof (theorem \ref{theorem:completeness}) is model-depending, as it heavily relies on its causal-extensibility. Immediately, the question of the algorithm's extensibility to stricter isolation levels arise. For understanding the difference between the formers and $\SI$ or $\SER$, let's analyze how algorithm \ref{algorithm:optimal-instantiated} behaves for the program depicted in figure \ref{fig:ser-non-optimal:a} under them. We study this example as it has exactly two consistent executions but a dead-lock one under $\SI$ and $\SER$.
For $\textsc{explore-ce}$, the part of strong optimality concerning \emph{not} engaging in fruitless explorations was a direct consequence of causal extensibility (of the isolation level). However, isolation levels such as SI and SER are \emph{not} causally extensible (see Section~\ref{ssec:causal_ext}). Therefore, the question we investigate in this section is whether there exists another implementation of $\textsc{explore}$ that can ensure strong optimality along with $I$-soundness and $I$-completeness for $I$ being SI or SER. We answer this question in the negative, and as a result, propose an SMC algorithm that extends $\textsc{explore-ce}$ by just filtering histories before outputting to be consistent with SI or SER.

\begin{restatable}{theorem}{impossibility}
\label{th:impos}
If $I$ is \textit{Snapshot Isolation} or \textit{Serializability}, there exists no $\textsc{explore}$ algorithm that is $I$-sound, $I$-complete, and strongly optimal.
\end{restatable}

The proof of Th.~\ref{th:impos} given in App.~\ref{proof:impossibility} defines a program with two transactions and shows that 
%We consider the program in Figure~\ref{fig:ser-non-optimal:prog}, and show that 
any concrete instance of $\textsc{explore}$ in Alg.~\ref{algorithm:algo-class} \emph{cannot be both} $I$-complete and strongly optimal. 
%This program contains two transactions, where only the first 3 instructions in each transaction are important.


%As $\mathcal{P}$ is symmetric and every computed partial execution have at most one pending transaction, we can assume, without loss of generality, the oracle order where $T_1$ precedes $T_2$. In this setting, when $A$ execute the read event $r_1 \coloneqq a \gets \rd{x}$, it will only be able to read from $\init$. After completing $T_1$, it executes the read-event $r_2 \coloneqq b \gets \rd{x}$ from $T_2$. One one hand, if $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$ we will obtain a history $h'$ that leads to a deadlock (figure \ref{fig:ser-non-optimal:c}) and cannot be swapped before $T_2$'s completion; otherwise we would obtain a partial history $h''$ with two pending transaction. To sum up, algorithm \ref{algorithm:optimal-instantiated} is incomplete for $\SI$ and $\SER$.
%
%This show that our proposal is not flexible enough to satisfy the constraints that new models may require. Therefore, we want to analyze what properties shall we weak for still obtaining a $\mathcal{M}$-sound, complete and optimal while employing polynomial memory; for $\SI$ and $\SER$ models. Let's suppose then that there exists such an algorithm $A \in \mathcal{S}_{\mathcal{M}}$ and see how it behaves under the same program $\mathcal{P}$. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history (the algorithm cannot deduce in advance if a dead-lock/inconsistency will appear later on). In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_2 \coloneqq \wrt{x}{2} \not \in h$. By definition of $\genericNext$ function, $a = \genericNext(h) \in h$, and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ is an extension of $h$ that will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_2$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_2)$ for any extension $h'$ of $h$. Therefore, there is a history $h'$ that extends $h$ where all events but those in $T_2$ $\po$-after $w_2$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.


%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.

%\begin{theorem}
%There is no algorithm in $\mathcal{S}_{\mathcal{M}} \cap \mathcal{O}^n_{\mathcal{M}}$, $n$ in $\mathbb{N}$, for neither SI nor SER.
%\label{theorem:si-ser-bad-models}
%\begin{comment}
%\begin{proof}
%
%\textcolor{red}{
%During this proof let's call $\mathcal{P}$ to the program depicted in \ref{fig:ser-non-optimal:a}. Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.
%}

%\underline{$S_{\mathcal{M}} \cap \mathcal{L}^1_{\mathcal{M}} = \emptyset$}. 

%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is in $\mathcal{L}^1_{\mathcal{M}}$ and $\mathcal{P}$ is symmetric, with out loss of generality we can assume $A$ execute first $T_1$ and then $T_2$. Then, it will execute the read event $r_1 \coloneqq a \gets \rd{x}$, which can only read from $\init$. After $T_1$, it executes the first event of $T_2$: $r_2 \coloneqq b \gets \rd{x}$. If $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$, we will obtain a history $h'$ that leads to a deadlock and cannot be swapped before $T_2$'s completion; otherwise $A$ would have two pending transaction. Therefore, $A$ would only explore exactly one execution, so it is incomplete. This contradicts $A$ is in $\mathcal{L}^1_{\mathcal{M}}$.

%from this history, there %only has two transactions, $A$ can either execute the first or the second transaction at a time. As $A$ is complete and the history depicted in \ref{fig:ser-non-optimal:b} is consistent, there is an execution $h$ extending that history
%As after executing any event, $A$ has no information on the future events' availability, it will explore any possible consistent history. 

%\textcolor{red}{The first case is due to the non-$\wro \cup \so$-maximality of SI, SER (second example we discussed). The second one is the example when there is only one branch computed (first example we discussed).}
%\end{proof}
%\end{comment}
%\end{theorem}
%
%In particular, the program in figure \ref{fig:ser-non-optimal} shows that both $\SI$ and $\SER$ are actually not causally-extensible. Nevertheless, we present a swapping-based $\mathcal{M}$-sound, complete, weakly optimal algorithm employing polynomial memory based on \ref{algorithm:optimal-instantiated}:

Given this negative result, we define an implementation of $\textsc{explore}$ for an isolation level $I\in\{SI,SER\}$ that ensures optimality instead of strong optimality, along with soundness, completeness, and polynomial space bound. Thus, let $\textsc{explore-ce}(I_0)$ be an instance of $\textsc{explore-ce}$ parametrized by $I_0\in \{\RC,\RA,\CC\}$. We define an implementation of $\textsc{explore}$ for $I$, denoted by $\textsc{explore-ce}^*(I_0,I)$, which is exactly $\textsc{explore-ce}(I_0)$ except that 
% extension of any instance of $\textsc{explore-ce}$ parametrized by a prefix-closed and causally-extensible isolation level $I$ which is weaker than SI, which is only optimal and not strongly optimal.
% that for isolation levels $I$ like SI and SER has the same guarantees except that it is only optimal and not strongly optimal.
%any $\textsc{explore-ce}$ parametrized isolation level $I$, which 
instead of $\genericEvaluate(\hist) ::= true$, it uses 
\begin{equation*}
	\begin{array}{ccc}
		\genericEvaluate(\hist) & \coloneqq & \hist \mbox{ satisfies }I
	\end{array}
\end{equation*}
$\textsc{explore-ce}^*(I_0,I)$ enumerates exactly the same histories as $\textsc{explore-ce}(I_0)$ except that it outputs only histories consistent with $I$. The following is a direct consequence of Theorem~\ref{th:corr}.
%because the set of histories admitted by a program under $I\in\{SI,SER\}$ is a subset of the set of histories admitted under $I_0\in \{\RC,\RA,\CC\}$.

\begin{corollary}
%For any $I_0\in \{\RC,\RA,\CC\}$ and $I\in\{SI,SER\}$, $\textsc{explore-ce}^*(I_0,I)$ is $I$-sound, $I$-complete, optimal, and polynomial space.
For any isolation levels $I_0$ and $I$ such that $I_0$ is prefix-closed and causally extensible, and $I_0$ is weaker than $I$, $\textsc{explore-ce}^*(I_0,I)$ is $I$-sound, $I$-complete, optimal, and polynomial space.
\end{corollary}

%Note that the corollary above extends to any isolation level $I_0$ which is prefix closed and causally extensible and any isolation level $I$ which is stronger than $I_0$.

%\textcolor{red}{Discuss the exponential total branches ditched}
%The reason why theorem \ref{theorem:si-ser-bad-models} holds for $\SI$ and $\SER$ but not for the rest of isolation levels described in \ref{fig:consistency_defs} is due to the lack of causal-extensibility. Nevertheless, weakening

% Under any of them the event $\wrt{x}{2}$ would always be eligible to be added to the aforementioned history $h$, and therefore any final dead-lock would be reached.

