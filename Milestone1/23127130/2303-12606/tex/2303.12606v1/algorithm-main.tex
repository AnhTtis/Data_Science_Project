%!TEX root = main.tex
\section{Swapping-based model checking for Prefix-Closed and Causally-Extensible Isolation Levels}
\label{sec:CC-algorithm}

%The main goal in this section is describing a deterministic algorithm for transactional model-checking under a causally-closed model $\mathcal{M}$ that obtains all possible behaviors a program may have. We present during this section a swapping-based sound, complete and optimal algorithm employing polynomial memory. In particular, we will show that our algorithm has at most one pending transaction and why this is key to guarantee the rest of the properties. For the legibility of this document, we will postpone their proofs to section \ref{sec:proofs-algorithm}.

We define a concrete implementation of $\textsc{explore}$, denoted as $\textsc{explore-ce}$, that is $I$-sound, $I$-complete, and strongly optimal for any isolation level $I$ that is prefix-closed and causally-extensible. The isolation level $I$ is a parameter of $\textsc{explore-ce}$. The space complexity of $\textsc{explore-ce}$ is polynomial in the size of the program. An important invariant of this implementation is that it explores histories with \emph{at most one} pending transaction and this transaction is maximal in session order. This invariant is used to avoid fruitless explorations: since $I$ is assumed to be causally-extensible, there always exists an extension of the current history with one more event that continues to satisfy $I$. 

Section~\ref{ssec:extensions} describes the implementations of $\genericNext$ and $\genericValidWrites$ used to extend a given execution, Section~\ref{subsection:SwappingHistories} describes the functions $\genericCompute$ and $\genericSwap$ used to compute re-ordered executions, and Section~\ref{ssec:optimality} describes the $\genericProtocol$ restriction on re-ordering. We assume that the function $\genericEvaluate$ is defined as simply $\genericEvaluate(\hist) ::= true$ (no filter before outputting). Section~\ref{ssec:corr} discusses correctness arguments (see App.~\ref{sec:proofs-algorithm} in the supplementary material for proofs).

\input{extending}

\input{swaps}

%\input{blocking-branches}

%\input{maximally-added}

\subsection{Correctness}\label{ssec:corr}

The following theorem states the correctness of the algorithm presented in this section:
\begin{restatable}{theorem}{algoCorrect}
\label{th:corr}
For any prefix-closed and causally extensible isolation level $I$, $\textsc{explore-ce}$ is $I$-sound, $I$-complete, strongly optimal, and polynomial space.
\end{restatable}

$I$-soundness is a consequence of the $\genericValidWrites$ and $\genericProtocol$ definitions which guarantee that all the histories given to recursive calls are $I$-consistent, and of the $\genericSwap$ definition which ensures to only produce feasible histories (which can be obtained using the operational semantics defined in Section~\ref{ssec:semantics}). The fact that this algorithm never engages in fruitless explorations follows easily from causal-extensibility which ensures that any current history can be extended with any event returned by $\genericNext$. Polynomial space is also quite straightforward since the \textbf{for all} loops in Algorithm~\ref{algorithm:algo-class} have a linear number of iterations: the number of iterations of the loop in $\textsc{explore}$, resp., $\textsc{exploreSwaps}$, is bounded by the number of write, resp., read, events in the current history (which is smaller than the size of the program; recall that we assume bounded programs with no loops as usual in SMC algorithms). On the other hand, the proofs of $I$-completeness and optimality are quite complex. 


%In particular, we observe that if two transactions $t, t'$ have a $(\so \cup \wro)^*$ dependency, the history order in the algorithm orders them analogously. But if they are $(\so \cup \wro)^*$-incomparable, the algorithm prioritizes the one that is read by a smaller $\iread$ event according $\ora$. Combining both arguments recursively we obtain a \textit{canonical order} for a history, which is formally defined with the function presented below. 

\nver{For showing $I$-completeness, we prove that for any given program $\prog$, it outputs every history $h$ in $\histOf[I]{\prog}$. For doing it so, we explicit show a collection of reachable histories that starts in the initial state and ends in $h$. The structure of the proof is as follows:}

\begin{enumerate}
    \item \nver{Explicitly define a total order $<$ called \textit{canonical order} for every unordered partial history $h$ such that if $h_{<'}$ is reachable, $<$ and $<'$ coincide. This canonical order allows to extend several definitions to arbitrary histories that are not necessarily reachable, such as $\genericProtocol$ or $\textsc{swapped}$.}
    \item \nver{Define the notion of \textit{$\ora$-respectfulness}, an invariant that every partial history reachable via $\textsc{explore-ce}$ satisfy. Briefly, a history is $\ora$-respectful if it has only one pending transaction and for every two events $e, e'$ such that $e <_{\ora} e'$, either $e < e'$ or there is a swapped event $e''$ in between. }
    \item \nver{Describe a function $\prev$ defined over the set of all partial histories that such that if $h$ is reachable, $\prev(h)$ returns the previous history to $h$ computed by $\textsc{explore-ce}$.}
    \item \label{item:sketch-completeness}\nver{Prove that if a history $h$ is $\ora$-respectful, $\prev(h)$ is $\ora$-respectful also. Deduce that if $h$ is $\ora$-respectful, there is a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$.}
    \item \nver{Prove that if $\prev(h)$ is reachable, $h$ is also reachable. Conclude that every history in $H_h$ is reachable.}
    %\item \nver{Constructing a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$.}
\end{enumerate}

%As $h_0$ corresponds to the initial state, we can thus conclude that $h$ is reachable by induction on the histories in $H_h$: the base case, $h_0$, is always reachable while if $h_i$ is reachable, by the property (1) of $\prev$, $h_{i+1}$ is also reachable. 

%Then, we can prove by exploiting property (2) of $\prev$ that, for every $\ora$-respectful history $h$ there exists a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$.

% Thirdly, we describe a function $\prev$ defined over the set of all partial histories that, if $h$ is reachable, $\prev(h)$ returns the previous history to $h$ computed by $\textsc{explore-ce}$. This function $\prev$ satisfies (1) the previous of an $\ora$-respectful history is also $\ora$-respectful and (2) if the previous of a history is reachable, then the history is reachable.

%\nver{ For showing $I$-completeness, we prove that for any given program $\prog$, it outputs every history $h$ in $\histOf[I]{\prog}$. For doing it so, we explicit show a collection of reachable histories that starts in the initial state and ends in $h$. However, algorithm \ref{algorithm:algo-class} works with ordered histories. Therefore, we first have to furnish $h$ with a total order called \textit{canonical order} that, if $(h, <)$ were reachable, it would coincide with its history order; so one can always work with histories instead of ordered histories. This order is based in two facts about our algorithm: (1) for every pair of transactions, if $(t, t') \in (\so \cup \wro)^*$ in $h$, then $t < t'$ and (2) if $t, t'$ are $(\so \cup \wro)^*$-incomparable, the algorithm prioritizes the one that is read by a smaller $\iread$ event according $\ora$. Secondly, we define the notion of \textit{$\ora$-respectfulness}, an invariant that every partial history reachable with $\textsc{explore-sc}$ satisfy. Briefly, a history is $\ora$-respectful if it has only one pending transaction and for every two events $e, e'$ such that $e <_{\ora} e'$, either $e < e'$ or there is a swapped event $e''$ in between. Thirdly, we describe a function $\prev$ defined over the set of all partial histories that, if $h$ is reachable, $\prev(h)$ returns the previous history to $h$ computed by $\textsc{explore-ce}$. This function $\prev$ satisfies (1) the previous of an $\ora$-respectful history is also $\ora$-respectful and (2) if the previous of a history is reachable, then the history is reachable. Then, we can prove by exploiting property (2) of $\prev$ that, for every $\ora$-respectful history $h$ there exists a finite collection of $\ora$-respectful histories $H_h = \{h_i\}_{i=0}^{n}$ such that $h_n = h$, $h_0 = \emptyset$ and $h_i = \prev(h_{i+1})$. As $h_0$ corresponds to the initial state, we can thus conclude that $h$ is reachable by induction on the histories in $H_h$: the base case, $h_0$, is always reachable while if $h_i$ is reachable, by the property (1) of $\prev$, $h_{i+1}$ is also reachable. }

Finally, albeit some intuition about the optimality arguments was given in Section~\ref{ssec:optimality}
\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. Given a history $h$, the definition of both its canonical order and $\prev(h)$ only depends on the relations $\ora, \so$ and $\wro$. Thus, exploiting both notions we can deduce that every predecessor of a reachable history $h$ coincides with $\prev(h)$. By induction on the collection $H_h$, we conclude $h$ has only one computable path.}
%\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. Simply, as both the canonical order and $\prev$ function's definition are agnostic of \textsc{explore-sc}'s procedure, every predecessor of a reachable history $h$ coincides with $\prev(h)$. By applying induction on the collection $H_h$, we conclude $h$ has only one computable path.}

%Reasoning by contradiction, if a reachable history $h$ with minimal number of events swapped would have two computable paths, it would have two predecessors $h_1$ and $h_2$; and without loss of generality, $h_1 = \prev(h)$. However, by defintion of $\prev$ we can conclude that actually $h_1 = h_2$.

%as well in property (2) of $\prev$. This property stablish an univoque correspondance between a reachable history and its predecsor, so when applied to the collection $H_h$ one can conclude there is only one reachable path from the initial state, $h_0$ to any other history.}

%Finally, albeit some intuition about the optimality arguments was given in Section~\ref{ssec:optimality}\nver{, one can deduce the optimality from the arguments employed for $I$-completeness. In particular, the proof relies in the collection of histories $H_h$ defined during the proof of $I$-completeness as well in property (2) of $\prev$. This property stablish an univoque correspondance between a reachable history and its predecsor, so when applied to the collection $H_h$ one can conclude there is only one reachable path from the initial state, $h_0$ to any other history. }


% and secondly show how to define the inverse function of $\textsc{explore}$ and $\textsc{explore-sc}$ for, exploiting a common invariant on the histories explored by the algorithm, deducing a chain of histories starting from the initial state to $\hist$ and concluding that $\hist$ is indeed outputted. For $I$-optimality, we exploit the fact that the history order can be described without referencing any computable path along with the $\genericProtocol$ restriction on re-orderings, to conclude that there is only one possible branch that lead to it. See Appendix~\ref{sec:proofs-algorithm} (in the supplementary material) for more details.
%
%Strong optimality follows from causal extensibility which 
%
%. The former ensure that every extension with a new event returned by $\genericNext$ is $I$-consistent, and the latter implies that $\genericSwap$ outputs histories which are $I$-consistent because 
%
% and the definition 
%
% and causal extensibility: 
%\begin{itemize}
%	\item every history given as an input to a recursive call has at most one pending transaction and this is maximal in $(\so\cup\wro)+$, which implies that it admits an extension with any event,
%	\item and $\genericSwap$ outputs histories which modulo a last read in the pending transaction are prefixes of the input history, and therefore $I$-consistent assuming that the input one is.
%\end{itemize}
%
%As we show in Section~\ref{sec:proofs-algorithm}, the algorithm described above is $I$-sound assuming that $\genericEvaluate(\hist) ::= true$. Therefore, any history computed by applying the functions described above will satisfy the intended isolation level $I$.
%
%TODO THIS SHOULD PROBABLY BE ABOUT CORRECTNESS, STATING IT AND EXPLAINING A LITTLE BIT THE PROOFS.

%Altogether, our swapping-based algorithm can simply being defined as an instance of \ref{algorithm:algo-class}: $\textsc{explore}_{\mathcal{M}}(\nextEvent,\evaluate , \validWrites, \compute, \protocol, \swap)$. A full detailed pseudocode of this procedure can be seen as algorithm \ref{algorithm:optimal-instantiated}; with initial call $h = \emptyset$.

%\begin{algorithm}[H]
%	\caption{Optimal recursive \textsc{STMC}}
%	\begin{algorithmic}[1]
%		\InputAlgorithmic $h$: history
%		\Statex
%		\State $e \gets  \next(h)$
%		\If{$e = \bot$}
%		\If{$\evaluate(h)$}
%		\State \textbf{output} $h$
%		\EndIf
%		%\State $\textbf{\genericEvaluate}(h)$
%		\State \Return
%		\ElsIf{$\textsc{type}(e) = \iread$}
%		
%		\ForAll{$w \in \validWrites(h,e)$} %\writeVar{w}{x}
%		
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet_w e)$
%		\EndFor
%		\Else
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet e)$
%		\EndIf
%		
%		\Statex
%		
%		\ForAll{$(\alpha, \beta) \in \compute(h)$}
%		\If{$\protocol(h \bullet e, \alpha, \beta)$}
%		\State $\textsc{explore}_{\mathcal{M}}(\swap(h \bullet e, \alpha, \beta))$	
%		
%		\EndIf
%		\EndFor
%	\end{algorithmic}
%	\label{algorithm:optimal-instantiated}
%\end{algorithm}
