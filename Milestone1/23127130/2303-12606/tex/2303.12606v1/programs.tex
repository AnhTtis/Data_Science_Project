%!TEX root = main.tex
\section{Transactional Programs}\label{sec:prelims}

\subsection{Program Syntax}

\begin{figure}
\small
\begin{align*}
\key\in \Vars\quad \xvar\in\LVars
\end{align*}
\begin{minipage}[t]{.4\textwidth}
\vspace{-4mm}
\begin{align*}
\mathsf{Prog} &  \eqdef  \mathsf{Sess} \ \mid\  \mathsf{Sess}\,||\,\mathsf{Prog} \\
\mathsf{Sess} & \eqdef  \mathsf{Trans} \ \mid\  \mathsf{Trans}; \mathsf{Sess} \\
\mathsf{Trans} & \eqdef  \ibegin; \mathsf{Body}; \icommit\\
\end{align*}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\vspace{-4mm}
\begin{align*}
\mathsf{Body} & \eqdef  \mathsf{Instr} \ \mid\  \mathsf{Instr}; \mathsf{Body} \\
\mathsf{Instr} & \eqdef  \mathsf{InstrDB} \ \mid\  a := e \mid\ \iif{\phi(\vec{a})}{\mathsf{Instr}} \\
\mathsf{InstrDB} & \eqdef \xvar := \iread(\key)  \ \mid\  \iwrite(\key,\xvar) \ \mid \ \iabort
%\mathsf{Local} & \eqdef  x := e
\end{align*}
\end{minipage}
\vspace{-7mm}
\caption{Program syntax. The set of global variables is denoted by $\Vars$ while $\LVars$ denotes the set of local variables.
We use $\phi$ to denote Boolean expressions over local variables, and $e$ to denote expressions over local variables interpreted as values. We use $\vec{\cdot}$ to denote vectors of elements.}
\label{fig:syntax}
\vspace{-4mm}
\end{figure}

Figure~\ref{fig:syntax} lists the definition of a simple programming language
that we use to represent applications running on top of a database. A program is a set of \emph{sessions} running in parallel, each
session being composed of a sequence of \emph{transactions}. Each transaction is
delimited by $\ibegin$ and either $\icommit$ or $\iabort$ instructions, 
%\footnote{We do not consider involuntary aborts, i.e. aborts caused by the particular implementation of the database.},
 and its body contains instructions that access the
database and manipulate a set $\LVars$ of local variables. 
We use symbols $a$, $b$, etc. to denote elements of $\LVars$.

For simplicity, we abstract the database state as a valuation to a set $\Vars$ of \emph{global} variables\footnote{In the context of a relational database, global variables correspond to fields/rows of a table while in the context of a key-value store, they correspond to keys.}, ranged over using $x$, $y$, etc. The instructions accessing the database correspond to reading the value of a global variable and storing it into a local variable $a$ ($a := \iread(x)$) , writing the value of a local variable $a$ to a global variable $x$ ($\iwrite(x,a)$), or an assignment to a local variable $a$ ($a := e$). The set of values of global or local variables is denoted by $\Vals$. Assignments to local variables use expressions $e$ over local variables, which are interpreted as values and whose syntax is left unspecified. Each of these instructions can be guarded by a Boolean condition $\phi(\vec{a})$ over a set of local variables $\vec{a}$ (their syntax is not important). Our results assume bounded programs, as usual in SMC algorithms, and therefore, we omit other constructs like $\mathtt{while}$ loops. 
SQL statements (SELECT, JOIN, UPDATE) that manipulate relational tables can be compiled to reads or writes of variables that represent fields or rows in a table (see for instance,~\cite{DBLP:journals/pacmpl/RahmaniNDJ19,DBLP:journals/pacmpl/BiswasKVEL21}). 
%\nver{Our work focuses on the problem of enumerating interleavings of reads and write "effects" from different transactions, modeled as reads and write of a set of global variables, and the issue of translating SQL statements to such reads and writes (which is prevalent in concurrency control mechanisms as well) is beyond the scope of our paper.} 
%\nver{SQL tables are modelled by a ``set'' variable whose content is the set of ids (primary keys) of the rows present in the table. SQL statements such as INSERT and DELETE statements are modelled as writes on that set variable while SQL statements with a WHERE clause (SELECT, JOIN, UPDATE) can be compiled to reads or writes of variables that represent fields or rows in a table following a starting read of the table's set variable.} (see~\cite{DBLP:journals/pacmpl/RahmaniNDJ19,DBLP:journals/pacmpl/BiswasKVEL21}).
% \nver{All SQL instructions are translated to key-value paradigm by adding a ``set'' variable per table whose content is the set of  ids (primary keys) of the rows present in the table. The translation of every SQL instruction with a WHERE clause starts reading this variable while INSERT and DELETE are modelled as writes on it.}

%Other constructs like $\mathtt{while}$ loops can be defined in a similar way. 
%Let $\KVProgs$ denote the set of programs where a transaction body can contain only such instructions.

\subsection{Isolation Levels}

We present the axiomatic framework introduced
by \citet{DBLP:journals/pacmpl/BiswasE19} for defining isolation levels. %\footnote{Isolation levels are called consistency models by \citet{DBLP:journals/pacmpl/BiswasE19}.}.
Isolation levels are defined as logical constraints, called \emph{axioms}, over \emph{histories}, which are an abstract representation of the interaction between a program and the database in an execution. 
% that record the sequence of reads and writes executed in each transaction, the order between transactions in each session, and a write-read relation (also called read-from) that ``justifies'' read values by associating each read to a write that wrote the value returned by the read.

%TODO SOME INTRO EXPLAINING THAT ISOLATION LEVELS ARE DEFINED AS AXIOMS OVER HISTORIES, WHICH REPRESENT THE INTERACTION BETWEEN A PROGRAM AND A STORE. 
\vspace{-2mm}
\subsubsection{Histories}

Programs interact with a database by issuing transactions formed of $\ibegin$, $\icommit$, $\iabort$, $\textsf{read}$ and $\textsf{write}$ instructions. The effect of executing one such instruction is represented using an \emph{event} $\langle e, \mathit{type} \rangle$ where $e$ is an \textit{identifier} and $\mathit{type} $ is a \textit{type}. There are five types of events: $\ebegin$, $\ecommit$, $\eabort$, $\erd{x}$ for reading the global variable $x$, and $\ewrt{x,v}$ for writing value $v$ to $x$. $\Events$ denotes the set of events.
For a read/write event $e$, we use $\mathit{var}(e)$ to denote the variable $x$. % and $\mathit{val}(e)$ the value $v$.

A \emph{transaction log} $\tup{t,E, \po_t}$ is an identifier $t$ and a finite set of events $E$ along with a strict total order $\po_t$ on $E$, called \emph{program order} (representing the order between instructions in the body of a transaction).
%$T$  is a finite sequence of events ordered by a strict total order $\po_T$ called \emph{program order}. 
The minimal element of $\po_t$ is a $\ebegin$ event. A transaction log without neither a $\ecommit$ nor an $\eabort$ event is called \emph{pending}. Otherwise, it is called \emph{complete}. A complete transaction log with a $\ecommit$ event is called \textit{committed} and \textit{aborted} otherwise. If a $\ecommit$ or an $\eabort$ event occurs, then it is maximal in $\po_t$; $\ecommit$ and $\eabort$ cannot occur simultaneously in the same transaction log. The set $E$ of events in a transaction log $t$ is denoted by $\events{t}$. Note that a transaction is aborted because it executed an $\iabort$ instruction. Histories do not include transactions aborted by the database because their effect should not be visible to other transactions and the abort is not under the control of the program. For simplicity, we may use the term \emph{transaction} instead of transaction log.

Isolation levels differ in the values returned by read events which are not preceded by a write on the same variable in the same transaction. \nver{We assume in the following that every transaction in a program is executed under the same isolation level.} For every isolation level that we are aware of, 
%
%The program order $\po_t$ represents the order between instructions in the body of a transaction. 
%We assume that %each transaction log is well-formed in the sense that 
if a read of a global variable $x$ is preceded by a write to $x$ in $\po_t$, then it should return the value written by the last write to $x$ before the read (w.r.t. $\po_t$). 
%This property is implicit in the definition of every isolation level that we are aware of.  Therefore, %The  set of all transaction logs is denoted by $\mathsf{Tlogs}$.

%For every transaction $T$, we denote $\po_T$ the total order existing between the events in $T$.
%During the whole paper we will assume that every pair of transactions are disjoint and that both $\mathcal{E}$ and $\mathcal{T}$ are finite. Therefore, we denote the function $tr: \mathcal{E} \to \mathcal{T}$ that associates every event to the unique transaction it belongs to. %Moreover, we will assume there is a special transaction called \callout{initial} that contains exactly one write event for every possible variable.

The set of $\erd{x}$ events in a transaction log $t$ that are \textit{not} preceded by a write to $x$ in $\po_t$, for some $x$, is denoted by $\readOp{t}$. 
%As mentioned above, the other read events take their values from writes in the same transaction and their behavior is independent of other transactions. 
Also, if $t$ does \textit{not} contain an $\eabort$ event, the set of $\ewrt{x,\_}$ events in $t$ that are \textit{not} followed by other writes to $x$ in $\po_t$, for some $x$, is denoted by $\writeOp{t}$. If a transaction contains multiple writes to the same variable, then only the last one (w.r.t. $\po_t$) can be visible to other transactions (w.r.t. any isolation level that we are aware of). If $t$ contains an abort event, then we define $\writeOp{t}$ to be the empty set. This is because the effect of aborted transactions (its set of writes) should not be visible to other transactions.
The extension to sets of transaction logs is defined as usual. 
Also, we say that a transaction log $t$ \emph{writes} $x$, denoted by $\writeVar{t}{x}$, when $\writeOp{t}$ contains some $\ewrt{x,\_}$ event. 

A \emph{history} contains a set of transaction logs (with distinct identifiers)
ordered by a (partial) \emph{session order} $\so$ that represents the order
between transactions in the same session. %\footnote{For our programming language, $\so$ would be a union of total orders. This constraint is not important for defining isolation levels.}. 
It also includes a
%ordering constraints imposed by the applications using the database. Most often, $\so$ is a union of sequences, each sequence being called a \emph{session}. 
\emph{write-read} relation (also called read-from) that defines read values by associating each read to a transaction that wrote that value. Read events do \emph{not} contain a value, and their return value is defined as the value written by the transaction associated by the write-read relation.
%
\nver{Let $T$ be a set of transaction logs.}
For a write-read relation \nver{$\wro\subseteq \writeOp{T}\times \readOp{T}$} and variable $\key$, $\wro_\key$ is the restriction of $\wro$ to reads of $\key$, \nver{$\wro_\key=\wro\cap (\writeOp{T}\times \{ e\ |\ e \mbox{ is a }\erd{\key} \mbox{ event}\})$}. We extend the relations $\wro$ and $\wro_\key$ to pairs of transactions by $\tup{t_1,t_2}\in \wro$, resp., $\tup{t_1,t_2}\in \wro_\key$, iff there exists \nver{a $\wrt{x}{\_}$ event $w$ in $t_1$ and} a $\rd{\key}$ event $r$ in $t_2$  s.t. \nver{$\tup{w,r}\in \wro$, resp., $\tup{w, r}\in \wro_\key$.} \nver{Analogously, $\wro$ and $\wro_\key$ can be extended to tuples formed of a transaction (containing a write) and a read event.} We say that the transaction log $t_1$ is \emph{read} by the transaction log $t_2$ when $\tup{t_1,t_2}\in \wro$. 

\vspace{-1mm}
\begin{definition}
A \emph{history} $\tup{T, \so, \wro}$ is a set of transaction logs $T$ along with a strict partial \emph{session order} $\so$, and a 
\emph{write-read} relation \nver{$\wro\subseteq \writeOp{T}\times \readOp{T}$} such that
\vspace{-1mm}
\begin{itemize}
	\item the inverse of $\wro$ is a total function, 
	\item \nver{if $(w,r)\in \wro$, then $w$ and $r$ are a write and respectively, a read, of the same variable,} and
	\item $\so\cup\wro$ is acyclic (here we use the extension of $\wro$ to pairs of transactions).
\end{itemize}
\vspace{-2mm}
\end{definition}

Every history includes a distinguished transaction writing the initial values of all global variables. This transaction precedes all the other transactions in $\so$. We use $\hist$, $\hist_1$, $\hist_2$, $\ldots$ to range over histories. 

The set of transaction logs $T$ in a history $\hist=\tup{T, \so, \wro}$ is denoted by $\tlogs{\hist}$, and $\events{\hist}$ is the union of $\events{t}$ for $t\in T$.  For a history $\hist$ and an event $e$ in $\hist$, $\trans{h}{e}$ is the transaction $t$ in $\hist$ that contains $e$. Also, $\writeOp{\hist}=\bigcup_{t\in \tlogs{h}}\writeOp{t}$ and $\readOp{\hist}=\bigcup_{t\in \tlogs{h}}\readOp{t}$.

We extend $\so$ to pairs of events by $(e_1,e_2)\in \so$ if $(\trans{h}{e_1},\trans{h}{e_2})\in\so$. We also define $\po=\bigcup_{t\in T} \po_t$.


%TODO NOT SURE THAT THE FOLLOWING DEFINITION IS NEEDED
%
%\begin{definition}
%Let $h$ be a history:
%\begin{itemize}
%\item $h$ is called \callout{complete} if every transaction is non-pending and \callout{incomplete} otherwise;
%\item $h$ is \callout{executed in isolation} if it contains at most one pending transaction;
%\item $h$ is called \callout{total} if it is complete and contains every transaction $T \in \mathcal{T}$.
%\end{itemize}
%\end{definition}
%
%\textcolor{red}{\sout{If the event $e =\nextEvent(h)$ is $\ibegin, \iwrite$ or $\iend$, we will denote by $h \bullet e$ the history $h' = \langle E', \so', \wro\rangle$ where $E' = \events{h} \cup \{e\}$ and $\so' = \so \cup \{\langle e', e \rangle \ | \ e' \in h \land \thread{e} = \thread{e'}\}$. On the other hand, if $e$ is a $\iread$ event, we will define the history $h_w' = h \bullet_w e$ for some $\iwrite$ event $w \in h$ as $\langle E', \so', \wro \cup \{\langle w, r \rangle\} \rangle$; where $E'$ and $\so'$ defined as before.}: Not well defined, just cut-pasted from below}. 
%
%\textcolor{red}{EXTENSIONS, $\mathcal{H}^<$ AND $\bullet$ OPERATOR NOT (yet) DEFINED IN THIS SECTION!!!!!!!}

\vspace{-1mm}
\subsubsection{Axiomatic Framework}

A history satisfies a certain isolation level if there is a strict total order $\co$ on its transactions, called \emph{commit order}, which extends the write-read relation and the session order, and which satisfies certain properties. These properties, called \emph{axioms}, relate the commit order with the $\so$ and $\wro$ relations in a history and are
%the session-order and the write-read relation in the history. 
%The axioms define mandatory $\co$ predecessors $\tr_2$ of a transaction $\tr_1$ that is read in the history. 
%They are 
defined as 
first-order formulas of the form:
\label{eq:axioms}
\begin{align}
  & \forall \key,\ \forall \tr_1\neq \tr_2,\ \forall \tr_3.\ \nonumber\\
  & \hspace{3mm}  \tup{\tr_1,t_3}\in \wro_\key \land \writeVar{\tr_2}{\key} \land \phi(\tr_2,\tr_3) \implies \tup{\tr_2,\tr_1}\in\co \label{eq:axiom}
%  & \hspace{5.4cm} \implies \tup{\tr_2,\tr_1}\in\co \nonumber
\end{align}
where $\phi$ is a property relating $\tr_2$ and $\tau$ (i.e., the read or the
transaction reading from $\tr_1$) that varies from one axiom to another.\footnote{These formulas are interpreted on tuples $\tup{\hist,\co}$ of a history $\hist$ and a commit order $\co$ on the transactions in $\hist$ as usual.} Note that an aborted transaction $t$ cannot take the role of $\tr_1$ nor $\tr_2$ in equation \ref{eq:axiom} as the set $\writeOp{t}$ is empty. Intuitively, this axiom schema states the following: in order for $\tau$ to read specifically $t_1$'s write on $k$, it must be the case that every $t_2$ that also writes $k$ and satisfies $\phi(t_2,\tau)$ was committed before $t_1$. 
%Note that in all cases we consider, $\phi(t_2,\tau)$ already ensures that $t_2$ is committed before the read $\tau$, so this axiom schema ensures that $t_2$ is furthermore committed before $t_1$'s write.
The property $\phi$ relates $\tr_2$ and $\tau$ using the relations in a history and the commit order. 
Figure~\ref{fig:consistency_defs} shows two axioms which correspond to their homonymous isolation levels: \textit{Causal Consistency} ($\CC$) and \textit{Serializability} ($\SER$). The conjunction of the other two axioms Conflict and Prefix defines \textit{Snapshot Isolation} ($\SI$). \textit{Read Atomic} ($\RA$) is a weakening of $\CC$ where $(\so \cup \wro)^+$ is replaced with $\so \cup \wro$. \textit{Read Committed} ($\RC$) is defined similarly (see Appendix~\ref{sec:def:RA-RC} in the supplementary material).
%Analogously, some isolation levels such as \textit{Read Committed} ($\RC$), \textit{Read Atomic} ($\RA$) can be defined in the same way (Appendix~\ref{sec:def:RA-RC}).
Note that $\SER$ is stronger than $\SI$ (i.e., every history satisfying $\SER$ satisfies $\SI$ as well), $\SI$ is stronger than $\CC$, $\CC$ is stronger than $\RA$, and $\RA$ is stronger than $\RC$.
% as the model where prefix and conflict axioms both hold. 
%We say a history $h$ satisfies an isolation level $I$ if there is a total order called \callout{commit order} $\co$ that extend $\so \cup \wro$ and satisfies its axioms. However, by the definition of $\RC, \RA$ and $\CC$, it is clear that for every history $h$ s.t. the relation $\co$ deduced from $\so \cup \wro$ is acyclic exists a commit order for those isolation levels.
%Figure~\ref{fig:consistency_defs} shows the axioms defining Read Committed, Causal Consistency, and Serializability (see \citet{DBLP:journals/pacmpl/BiswasE19} for axioms defining Read Atomic, Prefix, and Snapshot Isolation). 

\begin{figure}[t]
	\resizebox{\textwidth}{!}{
		\footnotesize
		\begin{tabular}{|c|c|c|c|}
			\hline & & & \\ [-2mm]
			\begin{subfigure}[b]{.24\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
					\node[transaction state] at (2,0)       (t_3)           {$t_3$};
					\node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{\key}$}}] at (-.5,1.5) (t_2) {$t_2$};
					\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[bend left] node {$(\so \cup \wro)^+$} (t_3);
					%   \path [->, decoration={snake}] (t_2) edge[decorate] node[auto] {F} (t_3);
					\path (t_2) edge[left,double equal sign distance,coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$ $ \\

					$t_1\neq t_2\ \land \tup{t_1,t_3}\in \wro_x \ \land $
					
					\hspace{2mm}$\writeVar{t_2}{x}\ \land$ 

					\hspace{2mm}$\tup{t_2,t_3}\in(\so \cup \wro)^+$
					
					\hspace{4mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Causal\ Consistency}$}
				\label{cc_def}
			\end{subfigure}
			
			&     
			\begin{subfigure}[b]{.24\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
				 semithick, transform shape]
				\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
				\node[transaction state] at (2,0)       (t_3)           {$t_3$};
				\node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{x}$}}] at (-0.5,1.5) (t_2) {$t_2$};
				\node[transaction state] at (1.5,1.5) (t_4) {$t_4$};
				\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
				% \path (t_2) edge[blue] node {$\CO$} (t_1);
				\path (t_2) edge[] node {$\co^*$} (t_4);
				\path (t_4) edge[left] node {$(\so \cup \wro)$} (t_3);
				\path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
				
				$ $ \\

				$t_1\neq t_2\ \land \tup{t_1,t_3}\in \wro_x \ \land $
				
				\hspace{2mm}$\writeVar{t_2}{x}\ \land$ 
				
				\hspace{2mm}$\tup{t_2,t_3}\in\co^*\circ\,(\wro\cup\so)$
				
				\hspace{4mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Prefix}$}
				\label{pre_def}
				\end{subfigure}
			&
			\hspace{-1mm}

			\begin{subfigure}[b]{.24\textwidth}
			    \centering
			    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
			      semithick, transform shape]
			     \node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
			     \node[transaction state, label={[xshift=-5]below:$\writeVar{ }{\yvar}$}] at (2,0)       (t_3)           {$t_3$};
			     \node[transaction state, text=black,label={above:$\writeVar{}{x}$}] at (-.5,1.5) (t_2) {$t_2$};
			     \node[transaction state, label={[yshift=-2]above:{$\writeVar{}{\yvar}$}}] at (1.5,1.5) (t_4) {$t_4$};
			     \path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
			     % \path (t_2) edge[blue] node {$\CO$} (t_1);
			     \path (t_2) edge node {$\co^*$} (t_4);
			     \path (t_4) edge node {$\co$} (t_3);
			     \path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
			    \end{tikzpicture}
			    \parbox{\textwidth}{

			     $t_1\neq t_2\ \land \ \tup{t_1,t_3}\in \wro_x \ \land$
			     
			     \hspace{2mm}$ \writeVar{t_2}{\xvar}\ \land \ \writeVar{t_3}{\yvar}\ \land$ 
			     
			     \hspace{2mm}$ \writeVar{t_4}{\yvar} \land  \tup{t_2,t_4}\in\co^*$ 
			     
			     \hspace{2mm}$\land \ \tup{t_4,t_3}\in\co$
			     
			     \hspace{4mm}$\implies \tup{t_2,t_1}\in\co$
			    }
			    
			    \caption{$\mathsf{Conflict}$}
			    \label{confl_def}
			   \end{subfigure}
			
			   & 
    
			\begin{subfigure}[b]{.24\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
					\node[transaction state] at (2,0)       (t_3)           {$t_3$};
					\node[transaction state, text=black, label={above:\textcolor{black}{$\writeVar{ }{x}$}}] at (-.5,1.5) (t_2) {$t_2$};
					\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[bend left] node {$\co$} (t_3);
					\path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$ $ \\
					$ $ \\


					$t_1\neq t_2\ \land \ \tup{t_1,t_3}\in \wro_x \land$
					
					\hspace{2mm}$ \writeVar{t_2}{x}\ \land \ \tup{t_2,t_3}\in\co$ 
										
					\hspace{4mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Serializability}$}
				\label{ser_def}
			\end{subfigure}
			
			\\ \hline			  
		\end{tabular}
	}
	\vspace{-2mm}
	\caption{Axioms defining isolations levels (all logical variables representing transactions, e.g., $t_1$, are universally quantified). The reflexive and transitive, resp., transitive, closure of a relation $rel$ is denoted by $rel^*$, resp., $rel^+$. Also, $\circ$ denotes the composition of two relations, i.e., $rel_1 \circ rel_2 = \{\tup{a, b} | \exists c. \tup{a, c} \in rel_1 \land \tup{c, b} \in rel_2\}$.}
	\label{fig:consistency_defs}
	\vspace{-3mm}
\end{figure}


%For instance, $\mathsf{Read\ Committed}$~\cite{DBLP:conf/sigmod/BerensonBGMOO95} requires that every read returns a value written in a committed transaction, and also, that the reads in the same transaction are ``monotonic'', i.e., they do not return values that are older, w.r.t. the commit order, than values read in the past.
%%\footnote{This monotonicity property corresponds to the fact that in the original formulation of $\mathsf{Read\ Committed}$~\cite{DBLP:conf/sigmod/BerensonBGMOO95}, every write is guarded by the acquisition of a lock on the written key, that is held until the end of the transaction.}. 
%While the first condition holds for every history (because of the surjectivity of $\wro$), the second condition is expressed by the axiom $\mathsf{Read\ Committed}$ in Figure~\ref{lock_rc_def}, which states that for any transaction $\tr_1$ writing a key $\key$ that is read at an operaion $\alpha$ in a transaction, the set of transactions $\tr_2$ writing $\key$ and read previously in the same transaction (these reads may concern other keys) must precede $\tr_1$ in commit order. 
%For instance, Figure~\ref{rc_example:1} shows a history and a (partial) commit order that does not satisfy this axiom because $\rd{\key_1}{1}$ returns the value written in a transaction ``older'' than the transaction read in the previous $\rd{\key_2}{2}$. %An exa

\begin{wrapfigure}{r}{0.4\textwidth}
\vspace{-2mm}
   \centering
%   \begin{subfigure}{.3\textwidth}
%  \resizebox{\textwidth}{!}{
%\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%    semithick, transform shape]
%    \node[draw, rounded corners=2mm] (t1) at (0, 0) {\begin{tabular}{l} $\wrt{\key_1}{1}$ \end{tabular}};
%   \node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.5) {\begin{tabular}{l} $\wrt{\key_1}{2}$ \\ $\wrt{\key_2}{2}$\end{tabular}};
%   \node[draw, rounded corners=2mm, minimum width=1.8cm, minimum height=2.5cm] (t3) at (3, -0.75) {};
%   \node[style={inner sep=0,outer sep=0}] (t3_1) at (3, 0) {\begin{tabular}{l} $\rd{\key_2}{2}$ \end{tabular}};
%   \node[style={inner sep=0,outer sep=0}] (t3_2) at (3, -1.5) {\begin{tabular}{l} $\rd{\key_1}{1}$ \end{tabular}};
%   % \path (t1) edge node {} (t3_2);
%   % \path (t2) edge node {} (t3_1);
%   \path (t1) edge node {$\co$} (t2);
%   \path (t3_1) edge node {$\po$} (t3_2);
%   \path (t1) edge[below] node[yshift=-4,xshift=4] {$\wro$} (t3_2);
%   \path (t2) edge node[yshift=-2,xshift=7] {$\wro$} (t3_1);
%  \end{tikzpicture}  
%    }
%    \caption{$\mathsf{Read\ Committed}$ violation.}
%    \label{rc_example:1}
%\end{subfigure}
%\hspace{1cm}
%\begin{subfigure}{.4\textwidth}
\resizebox{0.38\textwidth}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
 semithick, transform shape]
 \node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]180:$t_1$}] (t1) at (0, 1.5) {$\ewrt{x,1}$};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]0:$t_2$}] (t2) at (3, 1.5) {\begin{tabular}{l} $\erd{x}$ \\ $\ewrt{x,2}$ \end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]0:$t_3$}] (t3) at (3, 0) {\begin{tabular}{l} $\erd{x}$ \\ $\erd{y}$ \end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]180:$t_4$}] (t4) at (0, 0) {\begin{tabular}{l} $\erd{x}$ \\ $\ewrt{y,1}$\end{tabular}};

\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t2);

\path (t1) edge[below] node[yshift=-3,xshift=3] {$\wro_x$} (t3);

\path (t2) edge[above] node[yshift=-6,xshift=-18] {$\wro_x$} (0,0.58);

\path (t4) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3);
\end{tikzpicture}  
}
% \caption{Causal C violation.}
% \label{cc_example:1}
%\end{subfigure}
\vspace{-2mm}
  \caption{Causal Consistency violation. Boxes group events from the same transaction.}
  \label{counter_example:1}
\vspace{-4mm}
\end{wrapfigure}
For instance, the axiom defining Causal Consistency~\cite{DBLP:journals/cacm/Lamport78} states that for any transaction $\tr_1$ writing a variable $x$ that is read in a transaction $\tr_3$, the set of $(\wro\cup \so)^+$ predecessors of $\tr_3$ writing $x$ must precede $\tr_1$ in commit order ($(\wro\cup \so)^+$ is usually called the \emph{causal} order). A violation of this axiom can be found in Figure~\ref{counter_example:1}: the transaction $\tr_2$ writing 2 to $x$ is a $(\wro\cup \so)^+$ predecessor of the transaction $\tr_3$ reading 1 from $x$ because the transaction $\tr_4$, writing 1 to $y$, reads $x$ from $\tr_2$ and $\tr_3$ reads $y$ from $\tr_4$. This implies that $\tr_2$ should precede in commit order the transaction $\tr_1$ writing 1 to $x$, which is inconsistent with the write-read relation ($\tr_2$ reads from $\tr_1$).

The $\mathsf{Serializability}$ axiom requires that for any transaction $\tr_1$ writing to a variable $x$ that is read in a transaction $\tr_3$, the set of $\co$ predecessors of $\tr_3$ writing $x$ must precede $\tr_1$ in commit order. This ensures that each transaction observes the effects of all the $\co$ predecessors. 

%It was shown in~\cite{DBLP:journals/pacmpl/BiswasE19} that as expected, $\mathsf{Serializability}$ implies $\mathsf{Causal}$, which implies $\mathsf{Read\ Committed}$ (when interpreted as first-order formulas).

\begin{definition}
For an isolation level $I$ defined by a set of axioms $X$, a history
$\hist=\tup{T, \so, \wro}$ \emph{satisfies} $I$ iff there is a strict total
order $\co$ s.t. $\wro\cup\so\subseteq \co$ and $\tup{h,\co}$ satisfies $X$. %\footnote{Isolation levels like Snapshot Isolation require more than one axiom.}
 % Given a $\CO$(\textit{commit order}), a total order on $T$ which extends $\wro \cup \so$, we can define consistency axioms from table \ref{consistency_defs}. For each axiom, the situation in the table implies, $\Path{\tr_2}{\CO}{\tr_1}$.
 \label{axiom-criterion}
\end{definition}

A history that satisfies an isolation level $I$ is called $I$-consistent. For two isolation levels $I_1$ and $I_2$, $I_1$ is \emph{weaker than} $I_2$ when every $I_1$-consistent history is also $I_2$-consistent.

%=====
%
%To fully model any behavior of a transactional concurrent program we are obliged to formally describe the database section. This notion will be depicted as the concept of \textit{model}:
%
%%Those notions are generic enough to only describe a possible set of instructions that a parallel program may execute along with the $\wr$ relations that exist between them.
%
%\begin{comment}
%\begin{definition}
%An axiomatic \callout{model} $\mathcal{M}$ over histories is a collection of rules that enforce a \callout{consistency criterion} over them. The histories that satisfy those criteria are called \callout{consistent} while the rest are simply denoted inconsistent. 
%\end{definition}
%\end{comment}
%
%\begin{definition}
%An axiomatic \callout{model} $\mathcal{M}$ over histories is a collection of rules that enforce a \callout{consistency criterion} over them. The histories that satisfy those criteria are called \callout{$\mathcal{M}$-consistent} while the rest are simply denoted $\mathcal{M}$-inconsistent. If there is no ambiguity on the model, we will simply denote them consistent or inconsistent.%
%
%\end{definition}
%
%
%
%In figure \ref{fig:consistency_defs} it is depicted five axioms which correspond to their homonymous isolation levels: \textit{Read Committed} ($\RC$), \textit{Read Atomic} ($\RA$), \textit{Causal Consistency} ($\CC$)  \textit{Prefix Consistency} ($\PRE$) and \textit{Serializability} ($\SER$); along with the conflict axiom. Conflict and Prefix allow us to define \textit{Snapshot Isolation} ($\SI$) as the model where prefix and conflict axioms both hold. We say a history $h$ satisfies an isolation level $I$ if there is a total order called \callout{commit order} $\co$ that extend $\so \cup \wro$ and satisfies its axioms. However, by the definition of $\RC, \RA$ and $\CC$, it is clear that for every history $h$ s.t. the relation $\co$ deduced from $\so \cup \wro$ is acyclic exists a commit order for those isolation levels.
%
%TODO DEFINE $I$-consistent histories

\subsection{Program Semantics}\label{ssec:semantics}

We define a small-step operational semantics for transactional programs, which is parametrized by an isolation level $I$. The semantics keeps a history of previously executed database accesses in order to maintain consistency with $I$. 

For readability, we define a program as a partial function $\prog:\mathsf{SessId}\rightharpoonup \mathsf{Sess}$ that associates session identifiers in $\mathsf{SessId}$ with concrete code as defined in Figure~\ref{fig:syntax} (i.e., sequences of transactions). Similarly, the session order $\so$ in a history is defined as a partial function $\so:\mathsf{SessId}\rightharpoonup \mathsf{Tlogs}^*$ that associates session identifiers with sequences of transaction logs. Two transaction logs are ordered by $\so$ if one occurs before the other in some sequence $\so(j)$ with 
$j\in \mathsf{SessId}$.

The operational semantics is defined as a transition relation $\Rightarrow_I$ between \emph{configurations}, which are defined as tuples containing the following:
\begin{itemize}
	\item history $\hist$ storing the events generated by database accesses executed in the past, 
	\item a valuation map $\vec{\gamma}$ that records local variable values in the current transaction of each session ($\vec{\gamma}$ associates identifiers of sessions with valuations of local variables),
	\item a map $\vec{B}$ that stores the code of each live transaction (mapping session identifiers to code), 
	\item sessions/transactions $\prog$ that remain to be executed from the original program.
\end{itemize}

The relation $\Rightarrow_I$ is defined using a set of rules as expected (their precise definition can be found in Appendix~\ref{app:rules}). %(the others can be defined in a similar manner). 
Starting a new transaction in a session $j$ is enabled as long as this session has no live transactions ($\vec{\mathsf{B}}(j) = \epsilon$) and results in adding a transaction log with a single $\ebegin$ event to the history and scheduling the body of the transaction (adding it to $\vec{\mathsf{B}}(j)$). Local steps, i.e., checking the truth value of a Boolean condition or computation with local variables, manipulate the local variable valuations and advance the code as expected. Read instructions of some global variable $x$ can have two possible behaviors: (1) if the read follows a write on $x$ in the same transaction, then it returns the value written by the last write on $x$ in that transaction, and (2) otherwise, the read reads from another transaction $\tr'$ which is chosen non-deterministically as long as extending the current history with the write-read dependency associated to this choice leads to a history that still satisfies $I$. \nver{Depending on the isolation level, there may not exist a transaction $\tr'$ the read can read from (see Appendix~\ref{app:impossibility} for a concrete example).} For other instructions, e.g., $\icommit$ and $\iabort$, the history is simply extended with the corresponding events while ending the transaction execution in the case of $\iabort$.

%\textsc{spawn} starts a new transaction in a session $j$ provided that this session has no live transaction ($\vec{\mathsf{B}}(j) = \epsilon$). It adds a transaction log with a single $\ebegin$ event to the history and schedules the body of the transaction. \textsc{if-true} and \textsc{if-false} check the truth value of a Boolean condition of an $\mathtt{if}$ conditional. \textsc{local} models the execution of an assignment to a local variable which does not impact the stored history. \textsc{read-local} and \textsc{read-extern} concern read instructions. \textsc{read-local} handles the case where the read follows a write on the variable $x$ in the same transaction: the read returns the value written by the last write on $x$ in that transaction. Otherwise, \textsc{read-extern} corresponds to reading a value written in another transaction $\tr'$. The transaction $\tr'$ is chosen non-deterministically as long as extending the current history with the write-read dependency associated to this choice leads to a history that still satisfies $I$. \textsc{read-extern} applies only when the executing transaction contains no write on the same variable. \textsc{commit} confirms the end of a transaction making its writes visible while \textsc{abort} ends the transaction's execution immediately.

An \emph{initial} configuration for program $\prog$ contains the program $\prog$ along with a history $\hist=\tup{\{\tr_0\},\emptyset,\emptyset}$, where $\tr_0$ is a transaction log containing only writes that write the initial values of all variables, and empty current transaction code ($\mathsf{B}=\epsilon$). 
An execution of a program $\prog$ under an isolation level $I$ is a sequence of configurations $c_0 c_1\ldots c_n$ where $c_0$ is an initial configuration for $\prog$, and $c_m\Rightarrow_I c_{m+1}$, for every $0\leq m < n$. We say that $c_n$ is \emph{$I$-reachable} from $c_0$.
The history of such an execution is the history $\hist$ in the last configuration $c_n$. 
A configuration is called \emph{final} if it contains the empty program ($\prog=\emptyset$).
Let $\histOf[I]{\prog}$ denote the set of all histories of an execution of $\prog$ under $I$ that ends in a final configuration.

