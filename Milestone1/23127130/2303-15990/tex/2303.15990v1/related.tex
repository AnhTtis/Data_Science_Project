%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background \& Related Work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Writing a Dockerfile is the first step to containerize an application using Docker.
A Dockerfile specifies the dependencies and execution environment to build and execute the target application using domain-specific instructions \cite{web:dockerreference}.
% \eject
The first instruction is the \texttt{FROM}, which defines on which existing image the new image builds upon, \ie the \textit{base image}.
Then, we have instructions that perform actions during the build, such as \texttt{RUN}, to execute scripts, \texttt{WORKDIR}, to change the working directory, and \texttt{COPY/ADD}, to copy files, folders and compressed archives.
Other instructions are for metadata and documentation (\texttt{LABEL}, \texttt{EXPOSE}), build arguments (\texttt{ARG}), environment variables (\texttt{ENV}), and commands that the container must execute when the image is run (\texttt{CMD}, \texttt{ENTRYPOINT}).
Each Docker image built from a Dockerfile is uniquely identified by a \textit{digest}, a hash value computed upon the files that compose the image.
While building a Dockerfile, Docker creates a \textit{layer} for each instruction, which constitutes a temporary image that allows to cache and speed-up the next build by avoiding the build of previously-built layers, when possible.
The layers are also identified by a unique \textit{digest}.

Several tools and approaches are available to help developers in writing Dockerfiles. Due to space constraints, we only focus on such approaches, which are the most related to our work.
\textit{GitHub Copilot} \cite{web:copilot} has been recently introduced as a general-purpose code completion tool, and it works also with Dockerfiles. \textit{Humpback} \cite{hanayama2020humpback} achieves a similar goal, but it is specifically designed for Dockerfiles. The tool by Zhang \etal \cite{zhang2022recommending} helps developers choosing the right \textit{base image}.
Other approaches provide more advanced support.
Horton \etal \cite{horton2019dockerizeme} proposed \textsc{DockerizeMe}, an approach for the automatic inference of environment dependencies starting from Python source code, without requiring inputs from developers.
However, it only targets the execution dependencies for Python code.
Ye \etal \cite{ye2021dockergen}, proposed \textsc{DockerGen}, an approach that uses knowledge graphs, built upon 220k Dockerfiles, for generating Dockerfiles for a specific software application.
Starting from a target software, \textsc{DockerGen} infers all the dependencies required for the execution environment including the selection of a suitable base image.
However, the support provided by \textsc{DockerGen} is limited to the recommendation of dependencies, while we aim at generating complete Dockerfiles (including, for example, the \texttt{RUN} instructions required for building an external package, as the ones in \figref{fig:intro:example}).

Other tools take as input the context (\ie the root folder of the project) and suggest whole Dockerfiles based on it. 
An example is the tool \textit{starter} \cite{web:starter}, that generates a Dockerfile and a \textit{docker-compose.yml} file from arbitrary source code.
Some other tools provide a more in-depth support for specific programming languages, based on the project context. 
For example, there are tools specific for R \cite{nust2019containerit}, Node.js \cite{web:dockerfilegenerator}, Ruby \cite{web:boxing}, and PHP \cite{web:phpdockerio}. Others support multiple languages, such as \textit{generator-docker} \cite{web:generatordocker}.
To the best of our knowledge, no previous work introduced an approach that is able to generate complete Dockerfiles given high-level requirements.
% In closing, due to space constraints that limit our discussion about works using DL techniques for code generation, we point the reader to the systematic literature review by Watson \etal \cite{watson2022systematic} (deep learning in software engineering).



