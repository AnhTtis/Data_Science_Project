\section{Introduction}
Software companies are more and more often starting adopting the DevOps methodology for developing their products. DevOps strongly relies on technologies for automating the build and the deployment of the systems (CI/CD), and it results in shorter release cycles \cite{humble2010continuous}.
In this context, containerization technologies are fundamental to allow developers take control over the execution environment of their products. Such tools allow developers to reduce the risks of issues arising from possible differences between the development/testing environment and the production environment. Docker is the leading containerization technology, becoming the ``Most Loved" and ``Most Wanted" platform, according to the 2022 Stack Overflow survey \cite{webstacksurvey}.
When using Docker for a specific software product, developers are required to write a Dockerfile, which contains a sequence of instructions that, when executed, allow to build an image (Docker image) which can be run in one or more lightweight virtual machines (Docker containers).

Writing Dockerfiles is not trivial. First, system administration skills are required, which developers do not always have. 

Second, while basic Dockerfiles templates can be used as a starting point, they need to be adapted to the specific requirements of the software system at hand. To clarify this, let us consider the scenario in which a developer needs an environment that contains both Apache Tomcat as a web server and FFMpeg for processing videos, with the support of the x265 codec. 
% \eject
While templates exist for the former, they do not contain hints about how to provide also the latter. \figref{fig:intro:example} shows an example of possible solution: Such a Dockerfile starts from a pre-defined image which contains Tomcat and it installs FFMpeg with the support of x265 on top of it. It can be noticed that determining the commands required to achieve the latter goal requires a moderate effort and it is prone to errors. This problem has been observed in the literature. For example, in the survey conducted by Reis \etal \cite{reis2021developing}, the authors observed that developers (especially the less experienced ones) perceive the creation of Dockerfiles as a time consuming activity.
Moreover, using Dockerfiles from tutorials and blob posts as a support for their creation can lead to broken Docker images \cite{web:dockerizinghard}.

\begin{figure}
\begin{lstlisting}
FROM tomcat:7.0.75-jre8

RUN echo deb http://archive.ubuntu.com/ubuntu precise universe multiverse >> /etc/apt/sources.list; apt-get update && \
    apt-get -y --fix-missing install autoconf automake build-essential \
    git mercurial cmake libass-dev libgpac-dev libtheora-dev libtool \
    libvdpau-dev libvorbis-dev pkg-config texi2html zlib1g-dev \
    libmp3lame-dev wget yasm && \
    apt-get clean
    
WORKDIR /usr/local/src
# Install x265
RUN hg clone https://bitbucket.org/multicoreware/x265 && \
    cd /usr/local/src/x265/build/linux && \
    cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr ../../source && \
    make -j 8 && \
    make install

WORKDIR /usr/local/src
# Install ffmpeg.
RUN git clone --depth 1 && \
    cd ffmpeg && \
    git://source.ffmpeg.org/ffmpeg && ./configure \
    --extra-libs="-ldl" --enable-gpl --enable-libass \
    --enable-libvorbis --enable-libx265 --enable-nonfree && \
    make -j 8 && \
    make install

WORKDIR /
\end{lstlisting}
\caption{Example of Dockerfile for Tomcat and FFMpeg.}
\label{fig:intro:example}
\vspace{-0.5cm}
\end{figure}

Some tools and approaches have been introduced to help developers to write Dockerfiles.
Some of them \cite{horton2019dockerizeme,nust2019containerit,web:starter,web:boxing,web:dockerfilegenerator} take as input the context and suggest whole Dockerfiles based on it. 
Such tools are handy since they allow developers to quickly have a starting point. They also require limited effort from the developers.\eject

However, they are not able to recognize the need for specific libraries (like FFMpeg, in the previous example). 
Other tools provide a more in-depth support, but they are limited to specific programming languages (\eg DockerizeMe for Python). 
The approach recently introduced by Ye \etal \cite{ye2021dockergen} can recommend packages that need to be installed given an initial set of dependencies, but it only supports developers in the definition of the dependencies to install. The developer still needs to  write complex instructions, like the ones required to build the FFMpeg and x265 libraries in \figref{fig:intro:example}.
% \eject

Finally, there are code completion tools that support developers while writing Dockerfiles. A recent example is GitHub Copilot \cite{web:copilot}, which relies on Deep Learning (DL) to achieve this goal. Such tools, however, require that developers manually write part of the Dockerfile, so that they can complete it.
None of such tools and approaches is able to generate complete Dockerfiles from a high-level description of what the developer wants in the Dockerfile (\ie software requirements), minimizing the effort required, in terms of writing and knowledge required, to create Dockerfiles.
Previous research \cite{tufano2019empirical, mastropaolo2021studying, mastropaolo2022tse, watson2022systematic} show that DL is a viable solution for code generation-related tasks. However, to the best of our knowledge, no previous work tested to what extent DL can be used to generate complete Dockerfiles.

In this paper, we aim to fill this gap.
We first define the format of a structured high-level specification to define, via natural language, the requirements for the definition of Dockerfiles. Then, we define a methodology for automatically inferring such a \nlRecipeName (\nlRecipe) from existing Dockerfiles, so that we can build a dataset large enough to train and test a DL model. To this aim, we rely on the largest collection of Dockerfiles available in the literature \cite{eng2021revisiting}, containing 9.4M Dockerfile snapshots extracted from \textbf{all} the open-source projects hosted on GitHub. We run our specification-inference tool on them and, after a filtering procedure where duplicates and invalid Dockerfiles are removed, we end up with a set of \datasetInstancesAll unique pairs $\langle$\nlRecipe, Dockerfile$\rangle$. We use this dataset to train and test a state-of-the-art DL model, the Text-to-Text Transfer Transformer (T5) \cite{raffel2020exploring}, which has been proven effective when supporting several coding tasks \cite{mastropaolo2021studying, mastropaolo2022tse},
following the same pipeline defined in the literature.
We compare the DL-based approach with two Information Retrieval (IR)-based approaches (\ie less complex and less-resource-requiring alternatives), and we check to what extent, given a \nlRecipe, the output Dockerfiles of the three techniques: (i) meet the input requirements, (ii) are similar to the target Dockerfile, and (iii) allow to build a Docker image similar to the target one.

We obtain mixed results: While \approach achieves similar results to the best baseline in terms of adherence to the requirements, it generates Dockerfiles less similar to the target Dockerfile. On the other hand, we found that the build of the Dockerfiles generated with \approach succeeds more often and that a higher percentage of intermediate layers produced during the build match the ones obtained with the target Dockerfiles. Interestingly, we also found that \approach truncates the Dockerfiles. 
\eject

This might be due to two main issues. 
First, \textbf{a larger training dataset might be needed for this task}: Despite we consider the largest collection of Dockerfiles in the literature \cite{eng2021revisiting}, our results suggest that the T5 learning could benefit from more training data, considering the number of used instances to previous studies working on source code~\cite{mastropaolo2021empirical}. 
Second, \textbf{a different \approach training stop criterion needs to be defined}: The stop criterion we adopt, which is the one currently used for coding tasks \cite{mastropaolo2022tse}, is based on the convergence in terms of BLEU-4 score. However, considering our results, it seems to be ineffective in the evaluated context.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% force table positions before approach section

\input{tab-nl-recipe-stuct}

\begin{figure*}[htp]
    \centering
    \includegraphics[width=\linewidth]{figs/workflow}
    \caption{Steps performed to train \approach for generating Dockerfiles from specifications.}
	\label{fig:workflow}
	\vspace{-0.3cm}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
