\section{Preliminaries}
In this paper we address the task of detecting anomalies in sequential data which we view as a multi-set of unlabeled sequences ranging over a finite set of symbols.
While this is a restriction in general, it is a common approach in data mining to use methods such as Symbolic aggregate approximation (SAX)~\cite{DBLP:journals/datamine/LinKWL07} to discretize continuous data.
In order to emphasize this restriction linguistically we revert to a standard notation of automata theory by referring to a sequence $w = a_1 \dots a_n$ as a \emph{finite word}.
Moreover, we call the nonempty, finite set of \emph{symbols} over which these words can range an \emph{alphabet $\Sigma$}.
The sequence without any symbols, also referred to as \emph{empty word}, is denoted by $\epsilon$.
Furthermore, denote the set of all words over an alphabet $\Sigma$ as $\Sigma^*$.
In the remainder of this paper we will refer to the multi-set of sequential data $\sample =\{w_1,\dots, w_n\}$ as a \emph{sample}. Since a word $w$ can be contained multiple times in a sample $\sample$, we denote the number of occurrences of $w$ in $\sample$ as $\sample(w)$.

From a given sample we learn a \emph{deterministic finite automata (DFA)} as an anomaly detector.
DFAs are commonly known in computer science, easy to understand even for non-experts, and inherently interpretable~\cite{Shvo2021InterpretableSequenceClassification}.
Formally, a DFA is a tuple $\dfa = (Q, \Sigma, q_I, \delta, F)$ where $Q$ is a finite set of states, $\Sigma$ is a finite set of (input) symbols, $q_I \in Q$ is the \emph{initial state}, $\delta: Q \times \Sigma \to Q$ is the \emph{state-transition function}, and $F \subseteq Q$ is a set of accepting states.
The \emph{size} of a DFA is defined to be the number of its states $\abs{Q}$.
A \emph{run} on a word $w = a_1 \dots a_n$ is a sequence of states $q_0 \dots q_n$ such that $q_0 = q_I$ and $q_i = \delta(q_{i-1}, a_i)$ for $i \in \{1, \dots, n\}$.
We call a run \emph{accepting} if $q_n \in F$, otherwise \emph{rejecting}.
In order to indicate whether a word $w$ is accepted or rejected by a DFA $\dfa$ we define the indicator function 
\[\dfa(w)\coloneqq\begin{cases}
						  1&\text{if }\dfa\text{ accepts }w,\\
						  0&\text{otherwise}
\end{cases}\]
The \emph{language} of a DFA~$\dfa$, denoted~$L(\dfa)$, is the set of all words accepted by~$\dfa$.

As mentioned in the introduction we reduce the task of learning a DFA into a series of \emph{mixed-integer linear programming (MILP)} problems.
Let $\mathit{Var}$ be a finite set of real variables.
An MILP problem consists of two parts, a linear function over the variables, referred to as \emph{objective function} $\mathit{obj}$, and a conjunction of \emph{linear constraints} $\Phi$ on these variables.
The solution to such a MILP problem is an assignment $\mathit{Var} \to \mathbb{R}$, referred to as (feasable) \emph{model}, such that the value of the objective function $\mathit{obj}$ is optimal (i.e. minimal/maximal respectively) while satisfying $\Phi$ (i.e. all constraints).



