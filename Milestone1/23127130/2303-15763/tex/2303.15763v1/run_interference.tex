After analyzing each application solely, this section presents our analysis of each application in the co-running environment. For each co-running pair, we classify the two applications as follows.
\begin{itemize}
\item {\bf Background application}: the application executed in background infinitely when foreground benchmark is running. It will be stopped at once, when foreground benchmark stops.
\item {\bf Foreground application}: the application executed in foreground, we measure its execution time. 
\end{itemize}

To form a fair sharing setup, each applications' thread number is set to 4. Each thread takes one physical core exclusively.  
%The execution time of the foreground application is collected. 
Figure \ref{fig:corun_heatmap} shows a heat map of the normalized execution time of each foreground application to the execution time of the application running without the interfering neighbor. The application shown on y-axis is the foreground task and one shown on x-axis is the corresponding background one.

Based on the change of application's runtime, we define three kinds of relationship for application $A$ and $B$ in a co-running pair:
\begin{itemize}
\item \textbf{Harmony}: Both $A$ and $B$ in the co-running pair performs well in multi-tenant execution. No matter $A$ or $B$ is treated as foreground application, its relative execution time is $<1.5\times$.
\item \textbf{Victim-Offender}: The runtime of application $A$ in co-running pair is increased by $\ge 1.5\times$, while $B$ performs relatively well (runtime increment $<1.5\times$). 
\item \textbf{Both-Victim}: The performance of both application $A$ and $B$ are severely impacted. 
Compared to the sole-run, both $A$'s and $B$'s runtime increase $\ge 1.5\times$.
%$A$'s relative execution time running with $B$ is beyond 1.5, while $B$'s relative execution time running with $A$ is beyond 1.5.
\end{itemize}

In the cloud computing or warehouse-scale computing, the \textbf{Harmony} relationship is the most preferable one, as it can significantly increase the hardware utilization rate, which results in higher overall throughout and energy efficiency. \textbf{Victim-Offender} is also acceptable, as long as the foreground task maintains its performance at a pre-defined level (not a victim). \textbf{Both-Victim} should be definitely avoided. 
%In real co-running environment with shared resources, we prefer co-running relationship type of Harmony. Because both applications in this co-running types will not affect each other, and increase the overall system throughput.

\subsection{Performance Degradation of Co-running Pairs}
As shown in Figure \ref{fig:corun_heatmap}, we can find most of the co-running pairs are in a \textbf{Harmony} relationship. Especially, when swaptions, nab, deepsjeng and blackscholes are treated as background applications, any foreground applications' execution time increases less than $10\%$. Besides, no matter which background application is chosen to co-run with these benchmarks, their execution time is affected very little (less than $10\%$). These benchmarks are more ``friendly" for the shared-resource environment. From bandwidth perspective (shown in Figure \ref{fig:bandwidth_eachapp}), the bandwidth consumption of these workloads is much less than the overall bandwidth resource the whole system can supply. 

We also find several \textbf{Victim-Offender} co-running pairs: G-CC with CIFAR, G-CC with fotonik3d, P-PR with fotonik3d, IRSmk with fotonik3d, etc. 
For example, when G-CC is co-locating with CIFAR, the execution time of G-CC is increased by nearly $54.7\%$ as compared to its runtime in no-interference case. 
%For example, G-CC is more affected than CIFAR, when they are running together. the execution time of G-CC is slowed down by nearly $54.7\%$, running with CIFAR. 
However, CIFAR's slowdown is only $25\%$. Therefore, we can clearly conclude that G-CC is the victim and CIFAR is the offender in this pair. When G-CC is running with fotonik3d, G-CC's performance is even worse, with the execution time goes up to $198\%$, while fotonik3d's execution time only grows $46\%$. That means fotonik3d incurs more interference/contention to G-CC than that to CIFAR. For all of these \textbf{Victim-Offender} co-running pairs shown in Figure \ref{fig:corun_heatmap}, we can conclude that graph analytical applications are more likely to be \textbf{Victim}. CIFAR, fotonik3d, and IRSmk are offenders frequently. We can find some hints from individual study of each benchmark from Section~\ref{sec:nointerference}. Fotonik3d and IRSmk have high memory bandwidth consumption and are very prefetcher sensitive. Therefore, we can conclude that application with a regular access pattern and high bandwidth cost is more likely to be a \textbf{Offender} in co-running environments. Note that AMG2006 is an exception here. As aforementioned, the third phase of AMG2006 consumes a large amount of bandwidth, which only lasts for a short execution period. 

%some applications are offenders frequently: CIFAR, fotonik3d, and IRSmk. Some applications are more likely to be \textbf{Victim}: five graph applications in GeminiGraph, three graph applications in Powergraph, and fotonik3d. 
Finally, our experiments also reveal couple of \textbf{Both-Victim} co-running pairs, such as CIFAR with fotonik3d. For this co-running pair, the execution time of CIFAR and fontonik3d increase by $52\%$ and $54\%$, respectively. Both of these benchmarks affect each other. Such consolidating pairs should definitely be avoided for cloud/warehouse-scale computing. 

%From our In co-running case, these three benchmarks are \textbf{Offender} very frequently. We can find some hints from individual study of each benchmark from section III: As shown in Figure \ref{fig:prefetch_sensitivity}, we find that fotonik3d, IRSmk and streamcluster are very prefetcher-sensitive, and their memory access pattern are very regular. Besides, these three benchmarks also consumes a lot of bandwidth, shown in Figure \ref{fig:bandwidth_eachapp}. So we draw a conclusion here: Application with regular access pattern and much bandwidth consuming, is very likely to be a \textbf{Offender} in co-running cases. 
%Here, AMG2006 is not in this case. As aforementioned, the third phase of AMG2006 consumes a large amount of bandwidth, which only lasts for a short execution period. 





\subsection{Bandwidth consumption of co-running pairs}
After analyzing applications' co-running performance , we leverage the Intel PCM tool to collect the bandwidth consumption of these co-running pairs.
%Intel PCM bandwidth measurement, we can collect the bandwidth consumption of co-running pairs. 
In this paper, we are interested in two types of co-running pairs: \textbf{Victim-Offender} (e.g. foreground task is the victim) and \textbf{Both-Victim}. Because these two types of co-running pairs can either hurt user's experience by increasing foreground task's runtime or minimize the overall system throughput. To evaluate the bandwidth consumption of these two types of co-running pairs, we choose 5 co-running pairs to analyze. We also take each application's bandwidth consumption in these 5 co-running pairs for comparison. The baseline of such comparison is measured when the application is running alone. The bandwidth information is summarized in Table \ref{tab:bandwidth_corun}. The bandwidth consumption of all co-running pairs is less than the summation of two application's bandwidth consumption. 
All application in Table~\ref{tab:bandwidth_corun} are memory intensive ones, which can generate a significant amount of traffic on the bus. Pairing foreground tasks with them can diminish their responsiveness or elongate their execution time. Pairing such applications together can stress out the memory bandwidth, which results in reduced system throughput. After showing these phenomenon, we leverage the profiling tools (Vtune) to deep dive into these applications for the root cause of slow down.
%Each application in this table generate significant amount of bandwidth, and they are all memory intensive applications. 

\begin{table}[]
\centering
\scriptsize
\caption{Bandwidth Consumption of Specific Co-running Pairs. }
\label{tab:bandwidth_corun}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{Co-running Pairs} & \multicolumn{3}{c|}{Bandwidth Consumption(GB/S)} \\ \cline{2-4} 
 & Co-running pair & Application A & Application B \\ \hline
\begin{tabular}[c]{@{}c@{}}CIFAR(A) with \\ fotonik(B)\end{tabular} & 18.0 & 7.3 & 18.4 \\ \hline
\begin{tabular}[c]{@{}c@{}}IRSmk(A) with \\ fotonik(B)\end{tabular} & 24.5 & 18.1 & 18.4 \\ \hline
\begin{tabular}[c]{@{}c@{}}CC-G(A) with \\ fotonik(B)\end{tabular} & 18.6 & 17.8 & 18.4 \\ \hline
\begin{tabular}[c]{@{}c@{}}CC-G(A) with \\ IRSmk(B)\end{tabular} & 26.3 & 17.8 & 18.1 \\ \hline
\begin{tabular}[c]{@{}c@{}}CC-G(A) with \\ CIFAR(B)\end{tabular} & 18.6 & 17.8 & 18.0 \\ \hline
\end{tabular}
\end{table}

 











