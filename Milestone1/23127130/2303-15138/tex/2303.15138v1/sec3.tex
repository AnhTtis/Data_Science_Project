%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inference rules for binary predicates
%%% Stephen J. Hegner
%%% Section 3
%%% 22 October 2018
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



 \section{Background on Proof Systems}\label{sec:proofsys}


   The results of this paper are based upon simple notions of
mathematical logic in general, and of propositional logic in
particular.  There are many excellent presentations of those subjects,
at various levels and from various perspectives, including, but not
limited to, \mycite{Monk76},
\mycite{Mendelson97_book}, \mycite{Enderton01_book},
\mycite{BenAri12_book}, and \mycite{Gallier15}.
  It is assumed that the reader is familiar with the basic ideas
presented in the appropriate chapters of those books.
   The purpose of this section is to establish notation and
terminology for proof systems.

 \begin{metalabpara}{notation}{}
     {Notation}\envlabel{not:not3}
    $\natnum$ denotes the set $\setbr{0,1,2,\ldots}$ of natural
numbers.
  Unless stated specifically to the contrary, an expression of the
form $\ccinterval{n_1}{n_2}$, with $n_1,n_2 \in \natnum$, denotes the
interval $\setdef{n \in \natnum}{n_1 \leq n \leq n_2}$.
    \par
  $\cardof{S}$ denotes the cardinality of the set $S$.
%    \par
%  For a sequence $p$, $\lengthof{p}$ denotes its length.
 \end{metalabpara}


 \begin{metalabpara}{context}{}
     {Context --- SMAS}\envlabel{ctxt:gransch}
   Unless stated specifically to the contrary, for the rest of this
paper, $\smasdef{G}$ will denote an arbitrary SMAS. 
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
     {WFFs for granule logic}\envlabel{def:granwff}
     At first glance, it might seem that $\allbinconstrgrsch{G}$ forms
a suitable set over which to express inference rules for binary
granule constraints.  However, that choice is too limiting.  For
example, to express that the subsumption relation $\gnleleq{}$ is
transitive, it would be necessary to have a separate rule of the form
   \[
    \tag{\ref{def:granwff}-1}
    \begin{prooftree}
       \hypoii{\subrulep{g_1}{g_2}}
              {\subrulep{g_2}{g_3}}
       \inferi{\subrulep{g_1}{g_3}}
    \end{prooftree}
   \]
 for each triple $\abr{g_1,g_2,g_3}$ of granules.  It would be far
better to be able to assert, with a single rule, that that such a
relationship holds for any triple of granules.  To this end, it is
appropriate to introduce a set
   $\setbr{\granvar{g}_1,\granvar{g}_2,\ldots,\granvar{g}_i,\ldots}$
 of granule variables, with the understanding that each such variable,
by default, may be bound to any granule.  The general transitivity
rule then becomes
   \[
    \tag{\ref{def:granwff}-2}
    \begin{prooftree}
       \hypoii{\subrulep{\granvar{g}_1}{\granvar{g}_2}}
              {\subrulep{\granvar{g}_2}{\granvar{g}_3}}
       \inferi{\subrulep{\granvar{g}_1}{\granvar{g}_3}}
    \end{prooftree}
   \]
 with $\abr{\granvar{g}_1,\granvar{g}_2,\granvar{g}_3}$
 representing any triple of granules, as already illustrated in
Fig.\ \ref{fig:infrulespmain}.
    In the case that variable may only be bound to certain granules,
an explicit qualifier may be used, as already illustrated in the rules
of Figs.\ \ref{fig:infrulespunsat} and \ref{fig:infrulesntaut} by
the use of  $|{\scriptscriptstyle(\granvar{g} \neq \bot)}$.
     \par
    To formalize this, begin by associating with $\granschemaname{G}$
a countable set
   $\varsetgrsch{G} =
 \preformat{\linebreak}
     \setbr{\granvar{g}_1,\granvar{g}_2,\ldots,\granvar{g}_i,\ldots}$
 of \emph{granule variables}, with
  $\varsetgrsch{G} \intersect \granulesofsch{G} = \emptyset$.
    Relative to this set, the \emph{positive binary well-formed
formulas} (or \emph{positive binary WFFs}) of $\granschemaname{G}$,
denoted $\pbinwffgrsch{G}$, is the set consisting of all expressions
of the forms $\subrulep{\gamma_1}{\gamma_2}$ and
$\disjrulep{\gamma_1}{\gamma_2}$ with
  $\gamma_1, \gamma_2 \in \granulesofsch{G} \union \varsetgrsch{G}$.
    In other words, $\pbinwffgrsch{G}$ is similar to
$\pbinconstrgrsch{G}$, except that both granule names and granule
variables may be used in the expressions.  Thus, in addition to the
members of $\pbinconstrgrsch{G}$, $\pbinwffgrsch{G}$ includes all
expressions of the forms
   $\subrulep{\granvar{g}_1}{g_2}$,
   $\subrulep{g_1}{\granvar{g}_2}$,
   $\subrulep{\granvar{g}_1}{\granvar{g}_2}$,
   $\disjrulep{\granvar{g}_1}{g_2}$,
   $\disjrulep{g_1}{\granvar{g}_2}$,
  and
   $\disjrulep{\granvar{g}_1}{\granvar{g}_2}$,
  for $\granvar{g}_1, \granvar{g}_2 \in \varsetgrsch{G}$
  and $g_1, g_2 \in \granulesofsch{G}$.
    Similarly, the \emph{negative binary WFFs} of $\granschemaname{G}$,
denoted $\nbinwffgrsch{G}$, is the set consisting of all expressions
of the forms $\nsubrulep{\gamma_1}{\gamma_2}$ and
$\ndisjrulep{\gamma_1}{\gamma_2}$ with
  $\gamma_1, \gamma_2 \in \granulesofsch{G} \union \varsetgrsch{G}$.
  Finally, the set of \emph{all binary WFFs} of $\granschemaname{G}$,
denoted $\allbinwffgrsch{G}$, is
  $\pbinwffgrsch{G} \union \nbinwffgrsch{G}$.
    \par
  A more formal and complete development of inference rules is found
in \envref{def:ruleproofnot} and that which follows.
 \end{metalabpara}


 \begin{metalabpara}{context}{}
     {Context --- Granule variables}\envlabel{ctxt:granvarset3}
   Unless stated specifically to the contrary, for the rest of this
paper,
   $\varsetgrsch{G} =
     \setbr{\granvar{g}_1,\granvar{g}_2,\ldots,\granvar{g}_i,\ldots}$
 will denote a countable set of granule variables for the SMAS
$\smasname{G}$ identified in \envref{ctxt:gransch}.
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
     {Semantics of WFFs}\envlabel{disc:semwff}
   To extend the notions of semantic entailment and model of
\envref{def:granstrsem} to WFFs involving variables, it is necessary
to bind those variables to granules.
 More precisely, define a \emph{substitution} for $\granschemaname{G}$
to be a possibly partial function
 $\fn{s}{\varsetgrsch{G}}{\varsetgrsch{G}\union\granulesofsch{G}}$.
  Define $\substgr{\varphi}{s}$ to be the WFF in which each variable
$\granvar{g}$ in the domain of $s$ is replaced by $s(\granvar{g})$.
  For example, if
   $s_0 = \setbr{\elfd{\granvar{g}_1}{g_3},
              \elfd{\granvar{g}_2}{g_4},
              \elfd{\granvar{g}_3}{\granvar{g}_3}}$,
  then
    $\substgr{\subrulep{\granvar{g}_1}{\granvar{g}_2}}{s_0}
        = \subrulep{g_3}{g_4}$.
  A \emph{ground} substitution $s$ is one for which
     $s(\varsetgrsch{G}) \subseteq \granulesofsch{G}$;
 in other words, for every $\granvar{g}$ for which s(\granvar{g}) is
defined, $s(\granvar{g})$ is a granule, never a variable.
   A substitution \emph{complete} for
 $\varphi \in \allbinwffgrsch{G}$
 if it is defined for every $\granvar{g} \in \varsetgrsch{G}$ which
occurs in $\varphi$.
  If $s$ is ground and complete for $\varphi$, say that $\varphi$
  \emph{holds for $s$} in a granule structure $\sigma$ 
 if $\substgr{\varphi}{s}$ holds in $\sigma$.
  Thus, a WFF is assigned a truth value once all of its variables have
been bound to granules.
   Now, for $\varphi_1, \varphi_2 \in \allbinwffgrsch{G}$,
  $\varphi_1 \sentails \varphi_2$, precisely in the case that
  $\substgr{\varphi_1}{s} \sentails \substgr{\varphi_2}{s}$ for every
ground substitution $s$ which is complete for both $\varphi_1$ and
$\varphi_2$.
   \par
  These ideas extend easily to $\Phi \subseteq \allbinwffgrsch{G}$.
  Define
   $\substgr{\Phi}{s}
      = \setdef{\substgr{\psi}{s}}{\psi \in \Phi}$,
 say that $s$ is \emph{complete} for $\Phi$ if it is complete for each
$\psi \in \Phi$, and for $\varphi \in \allbinwffgrsch{G}$, define
  $\Phi \sentails \varphi$ to hold iff
  $\substgr{\Phi}{s} \sentails \substgr{\varphi}{s}$ for every ground
substitution $s$ which is complete for both $\Phi$ and $\psi$,
  Similarly, for $\Phi' \subseteq \allbinwffgrsch{G}$,
    $\Phi \sentails \Phi'$ holds iff
  $\substgr{\Phi}{s} \sentails \substgr{\Phi'}{s}$ for every ground
substitution $s$ which is complete for $\Phi \union \Phi'$.
    \par
   Finally, satisfiability is always defined with respect to ground
substitutions.  More precisely,
 $\varphi \in \allbinwffgrsch{G}$
 (resp.\ $\Phi \subseteq \allbinwffgrsch{G}$)
 is \emph{satisfiable} if there is a ground substitution $s$ which is
complete for $\varphi$ (resp.\ for $\Phi$) with
n \mbox{$\modelsof{\substgr{\varphi}{s}} \neq \emptyset$}
 (resp.\
 \preformat{\linebreak}
 $\modelsof{\substgr{\Phi}{s}} \neq \emptyset$).
     \par
    It is easy to see that these notions for $\allbinwffgrsch{G}$
generalize those of \envref{def:granstrsem} for
$\allbinconstrgrsch{G}$.
 \end{metalabpara}

 \begin{metalabpara}{context}{}
     {General logical systems and negation}\envlabel{disc:logicsys}
    Many of the concepts introduced in the remainder of this section,
as well as in Secs.\ \ref{sec:negarm} and \ref{sec:ninfrules}, apply
in a more general setting than just $\allbinwffgrsch{G}$.  In this
spirit, the framework of a general logical system $\logicsys{L}$ will
be assumed as a context, as needed.  This context includes notions of
WFFs (denoted $\wffof{L}$), structure, model, and semantic entailment
(denoted $\sentails$).  It is assumed that $\logicsys{L}$ is
\emph{nontrivial} in that there is at least one
 $\varphi \in \wffof{L}$ which is satisfiable, and that it contains at
least one tautology $\true$ and one unsatisfiable assertion $\false$.
It is furthermore assumed that $\logicsys{L}$ has a negation operator,
with $\mlnot\varphi$ denoting the negation of $\varphi \in \wffof{L}$,
$\mlnot\mlnot\varphi$ equivalent to $\varphi$, and excluded middle
($\varphi$ and $\mlnot\varphi$ cannot both be satisfiable).  Further
detailed properties of $\logicsys{L}$ will not be developed here,
except as necessary in for a particular issue.  However, it is
worthwhile noting that there is no assumption that $\logicsys{L}$ be
closed under conjunction or disjunction.  In fact, the main example of
$\logicsys{L}$ in this paper, $\allbinwffgrsch{G}$, is closed under
neither.
     \par
     For readers not comfortable with this generalization, it suffices
to fix $\wffof{L}$ to be $\allbinwffgrsch{G}$ and $\sentails$ to be
the semantic entailment relation for that context.  The assertion
$\true$ (resp.\ $\false$) may be taken to be (a synonym for) any
element of $\pbintautgrsch{G}$ (resp.\ $\pbinunsatgrsch{G}$).
     In $\allbinwffgrsch{G}$, to avoid unnecessary pedantry,
$\nsubrulep{g_1}{g_2}$ (resp. $\ndisjrulep{g_1}{g_2}$), will be
regarded as the same WFF as $\mlnot\subrulep{g_1}{g_2}$
(resp. $\mlnot\disjrulep{g_1}{g_2}$).
%  Similarly, 
%$\subrulep{g_1}{g_2}$ (resp. $\disjrulep{g_1}{g_2}$), will be
%regarded as the same WFF as $\mlnot\nsubrulep{g_1}{g_2}$
%(resp. $\mlnot\ndisjrulep{g_1}{g_2}$).
   \end{metalabpara}


 \begin{metalabpara}{discussion}{}
     {Proof systems}\envlabel{disc:proofsys}
     Semantic entailment is a purely model-based means of relating
WFFs.  In order to deduce that a set of formulas implies
another; that is, to determine whether $\Phi \sentails \varphi$ holds,
a computational procedure is necessary.  This is the r{\^o}le of a
proof system.
     \par
     More precisely, a {proof system} $\proofsys{A}$ for a set
$\wffset{A} \subseteq \wffof{L}$ consists of a set of inference rules,
denoted
 $\infrulesof{A}$, by which new WFFs may be obtained from others. Let
$\Phi \subseteq \wffset{A}$ and let
 $\varphi \in \wffset{A}$.
  Write
 $\Phi \syntailss[\proofsys{A}] \varphi$ just in case
 $\varphi$ may be obtained from $\Phi$ by repeated application of the
inference rules of $\proofsys{A}$.
  Write
 $\Phi \syntailssi[\proofsys{A}] \varphi$ just in case
 $\varphi$ may be obtained from $\Phi$ by a single application of a
single inference rule of $\proofsys{A}$.
     \par
     The proof system $\proofsys{A}$ is \emph{sound} if whenever $\Phi
\syntailss[\proofsys{A}] \varphi$, then
 $\Phi \sentails \varphi$.  In words, only conclusions which are true
(in the sense of $\sentails$) may be proven.  Soundness is always an
essential property of a proof system.
     \par
     The proof system $\proofsys{A}$ is \emph{complete} if
whenever $\Phi \sentails \varphi$, then
 $\Phi \syntailss[\proofsys{A}] \varphi$.  In words, all inferences
which are true may be proven using $\proofsys{A}$.
 While not essential, completeness is nevertheless a highly desirable
property.
     \par
     The proof system $\proofsys{A}$ is \emph{decidable} if there is
an algorithm (which always terminates) for determining whether or not
$\Phi \syntailss[\proofsys{A}] \varphi$ holds.  All proof systems
considered in this report are decidable, since the set $\wffset{A}$
will always be finite.
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
       {Sat-conditional completeness}\envlabel{def:satcompl}
    A proof system $\proofsys{A}$ for $\wffset{A}$ is said to be
\emph{sat-complete} if for any satisfiable
  $\Phi \subseteq \wffset{A}$ and any $\varphi \in \wffset{A}$,
 $\Phi \sentails \varphi$ implies
  $\Phi \syntailss[\proofsys{A}] \varphi$.
   \par
    Thus, $\proofsys{A}$ is complete as long as the input set $\Phi$
is satisfiable, but it need not be complete in the case that $\Phi$ is
not satisfiable.
    (Of course, if $\Phi$ is not satisfiable, then
  $\Phi \sentails \varphi$ holds trivially, so sat-completeness is not
a serious limitation.  It does, require, however, that an alternate
means of detecting unsatisfiability be used.)
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
        {Notation for rules and proofs}\envlabel{def:ruleproofnot}
    The representation of proof rules employed in this paper is widely
used; the purpose here is to clarify terminology and notation.  A
generic rule is illustrated in (\ref{def:ruleproofnot}-1) below.
     \[
       \tag{\ref{def:ruleproofnot}-1}
       \begin{prooftree}
         \hypoi{\alpha_1~\alpha_2~\ldots~\alpha_k}
         \inferi[(r)]{\beta}
       \end{prooftree}
     \]
   The set $\setdef{\alpha_i}{i \in \ccinterval{1}{k}}
          \subseteq \wffof{L}$
consists of the \emph{antecedents} of the rule
 and is denoted $\antecedentsof{r}$.
   Similarly, $\beta \in \wffof{L}$ is the \emph{consequent},
 and is denoted $\consequentof{r}$.
    This rule denotes exactly that
  $\setdef{\alpha_i}{i \in \ccinterval{1}{k}}
                      \syntailss[\proofsys{A}] \beta$
  using a single application of the rule named $r$.
    If the rule name is clear from context, it may be omitted.
  If $k=0$; \ie, if
   $\setdef{\alpha_i}{i \in \ccinterval{1}{k}} = \emptyset$,
 then the rule expresses that $\beta$ is a tautology.  If $\beta$ is
$\false$, the rule expresses that
  $\alpha_1 \mland \alpha_2 \mland \ldots \mland \alpha_k$
 is unsatisfiable.
     \par
   As already suggested in \envref{def:granwff}, substitutions may be
applied to rules (as well as formulas).  For example,
(\ref{def:granwff}-1) is the result of applying the substitution
   $s_1 = \setbr{\elfd{\granvar{g}_1}{g_1},
              \elfd{\granvar{g}_2}{g_2},
              \elfd{\granvar{g}_3}{g_3}}$,
to (\ref{def:granwff}-2).
   If the set of substitutions is restricted, this is expressed via an
appropriate expression in angle brackets, as illustrated in
Figs. \ref{fig:infrulesptaut} and \ref{fig:infrulesntaut}.
     \par
   The result of applying a substitution to a rule is called an
\emph{instance} of that rule.  It will sometimes be useful to label a
rule instance in a proof.  For example, (\ref{def:ruleproofnot}-2) below
shows a single instance labelled with $d$.  In order to distinguish
rule names from labels, the former will always be written in
parentheses (as illustrated in (\ref{def:ruleproofnot}-1), while labels
will never be enclosed in parentheses.  Note that while a rule will in
general have only one name, there may be several instances of it (and
hence labels for those instances) in a single proof.
     \[
       \tag{\ref{def:ruleproofnot}-2}
       \begin{prooftree}
         \hypoi{\alpha_1~\alpha_2~\ldots~\alpha_k}
         \inferi[d]{\beta}
       \end{prooftree}
     \]
   As examples,
Figs.\ \ref{fig:infrulespmain}--\ref{fig:infrulesunsatpr} provide the
rules on granules which will be studied in this paper.  Later in the
paper, \envref{def:bininfpos}, \envref{def:swapclpbininf}, and
\envref{def:compprrules} provide the same rules, with names.
   \par
    A great advantage of the notation of \envref{def:ruleproofnot} is
that proofs involving the application of several rules may be
presented in a clear fashion visually.  For example, formulas
(\ref{def:ruleproofnot}-3) and (\ref{def:ruleproofnot}-4) below show
two ways of proving $\subrulep{g_1}{g_5}$ from the set
 \nlrightt
   $S_{\scriptsize\mbox{\ref{def:ruleproofnot}}}
      = \setbr{\subrulep{g_1}{g_2},
           \subrulep{g_2}{g_3},
           \subrulep{g_3}{g_4},
           \subrulep{g_4}{g_5}}$,
    \newline
 using the rule to the left in Fig.\ \ref{fig:infrulespmain}.
    The various deduction instances have been labelled, with
$d_1$--$d_3$ in (\ref{def:ruleproofnot}-3) and with $d_1'$--$d_3$ in
(\ref{def:ruleproofnot}-4).  All are instances of the rule
(\ref{def:granwff}-2).
 \begin{gather*}
    \tag{\ref{def:ruleproofnot}-3}
    \begin{prooftreem}
     \hypoii{\subrulep{g_1}{g_2}}
            {\subrulep{g_2}{g_3}}
     \inferi[d_1]{\subrulep{g_1}{g_3}}
     \hypoi{\subrulep{g_3}{g_4}}
     \inferii[d_2]{\subrulep{g_1}{g_4}}
     \hypoi{\subrulep{g_4}{g_5}}
     \inferii[d_3]{\subrulep{g_1}{g_5}}
    \end{prooftreem}
     \\[0.9em]
    \tag{\ref{def:ruleproofnot}-4}
    \begin{prooftreem}
     \hypoii{\subrulep{g_1}{g_2}}
            {\subrulep{g_2}{g_3}}
     \inferi[d_1']{\subrulep{g_1}{g_3}}
     \hypoii{\subrulep{g_3}{g_4}}
            {\subrulep{g_4}{g_5}}
     \inferi[d_2']{\subrulep{g_3}{g_5}}
     \inferii[d_3']{\subrulep{g_1}{g_5}}
    \end{prooftreem}
    \end{gather*}
    Diagrams such as (\ref{def:ruleproofnot}-3) and
(\ref{def:ruleproofnot}-3) are called \emph{proof trees} (for the
inference system under consideration).
     \par
    The \emph{antecedents} of a combined rule are the formulas which
are at the top level.  In both (\ref{def:ruleproofnot}-3) and
(\ref{def:ruleproofnot}-4), the set of
antecedents is $S_{\scriptsize\mbox{\ref{def:ruleproofnot}}}$.
    Each combined rule has a single \emph{consequent}, which is at the
bottom.  In both examples, it is $\subrulep{g_1}{g_5}$.
     \par
     A formula which occurs in a proof tree, other than as an
antecedent or consequent, is called an \emph{internal formula}.
     In (\ref{def:ruleproofnot}-3), the set
of internal formulas is
 $\setbr{\subrulep{g_1}{g_3}, \subrulep{g_1}{g_4}}$,
 while in (\ref{def:ruleproofnot}-4), it is
 $\setbr{\subrulep{g_1}{g_3}, \subrulep{g_3}{g_5}}$,
    \par
   Finally, a formula $\varphi$ which is regarded as an axiom will
always be regarded as a proof of itself.
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
        {Soundness and minimality of rules
                    and proof systems}\envlabel{def:minrule}
    Let $\proofsys{A}$ be a proof system for $\wffset{A}$, and let $r$
be a rule, as depicted in (\ref{def:minrule}-1) below.
     \[
       \tag{\ref{def:minrule}-1}
       \begin{prooftree}
         \hypoi{\alpha_1~\alpha_2~\ldots~\alpha_k}
         \inferi[(r)]{\beta}
       \end{prooftree}
     \]
  Call $r$ \emph{sound} if it produces consistent inference by
itself; \ie, if
     $\setbr{\alpha_1,\alpha_2,\ldots,\alpha_k} \sentails \beta$.
   \par
  Call a sound $r$ \emph{minimal} if whenever any $\alpha_i$ is
removed from the antecedents, the resulting rule $r'$, as shown in
(\ref{def:minrule}-2) below, is no longer sound.
     \[
       \tag{\ref{def:minrule}-2}
       \begin{prooftree}
         \hypoi{\alpha_1~\alpha_2~\ldots~\alpha_{i-1}~~
                     \alpha_{i+1}~\ldots~ \alpha_k}
         \inferi[(r')]{\beta}
       \end{prooftree}
     \]
  Put another way, the rule $r$ is minimal if for any
 $j \in \ccinterval{1}{k}$,
  $\setdef{\alpha_i}{i \in \ccinterval{1}{k}\setminus\setbr{i}}
    \not\sentails \beta$.
    \par
   Say that $\proofsys{A}$ is \emph{sound}
(resp.\ \emph{minimal}) if all members of $\infrulesof{A}$ have that
property.
 \end{metalabpara}


 \begin{metalabpara}{mydefinition}{}
        {Single-use vs.\ multiple-use proofs}\envlabel{def:single}
    It may be the case that an antecedent of a proof is used several
times.  For example, given the set
 \nlrightt
   $S_{\scriptsize\mbox{\ref{def:single}}}
      = \setbr{\subrulep{g_1}{g_2},
           \subrulep{g_2}{g_3},
           \subrulep{g_3}{g_2},
           \subrulep{g_2}{g_3},
           \subrulep{g_3}{g_4}}$,
 \newline
 of constraints, in the proof shown in
 (\ref{def:single}-1) below, each of $\subrulep{g_1}{g_2}$,
$\subrulep{g_1}{g_3}$, and $\subrulep{g_1}{g_3}$ is used more than once.
 \[
    \tag{\ref{def:single}-1}
    \begin{prooftreem}
     \hypoii{\subrulep{g_1}{g_2}}
            {\subrulep{g_2}{g_3}}
     \inferi[d_1]{\subrulep{g_1}{g_3}}
     \hypoi{\subrulep{g_3}{g_2}}
     \inferii[d_2]{\subrulep{g_1}{g_2}}
     \hypoi{\subrulep{g_2}{g_3}}
     \inferii[d_3]{\subrulep{g_1}{g_3}}
     \hypoi{\subrulep{g_3}{g_4}}
     \inferii[d_4]{\subrulep{g_1}{g_4}}
    \end{prooftreem}
 \]
  Call such a proof \emph{multiple use}.  On the other hand, call
proofs in which no formula occurs as an antecedent more than once
\emph{single use}.  The proofs of (\ref{def:ruleproofnot}-1) and
(\ref{def:ruleproofnot}-2) are single use.
     \par
   Call a proof system \emph{single use} if for any set
 $\setbr{\alpha_1,\alpha_2,\ldots,\alpha_k}$ of formulas, and any
single formula $\beta$, if there is a proof of $\beta$ from 
 $\setbr{\alpha_1,\alpha_2,\ldots,\alpha_k}$, then there is a
single-use proof.
     \par
   It is worth noting now that even though the proof of
(\ref{def:single}-1) is multiple use, a single-use proof is also
possible, as shown in (\ref{def:single}-2) below.
 \[
    \tag{\ref{def:single}-2}
    \begin{prooftreem}
     \hypoii{\subrulep{g_1}{g_2}}
            {\subrulep{g_2}{g_3}}
     \inferi[d_1]{\subrulep{g_1}{g_3}}
     \hypoi{\subrulep{g_3}{g_4}}
     \inferii[d_4]{\subrulep{g_1}{g_4}}
    \end{prooftreem}
 \]
  The proof systems developed in this paper for granule rules
are all single use, as will be established later.
     \par
   The idea of ``using up'' formulas, without permitting their re-use,
was introduced by Girard in the context of \emph{linear logic}
\mycite{Girard95_all}.
   Since it is not central to the results of this paper, linear logic
will not be considered further.
 \end{metalabpara}


 \begin{metalabpara}{summary}{}
         {Armstrong models}\envlabel{summ:armstrong}
      Let $\armctxt{C}$ be any set of sentences in a framework for
logic.  Given $\Phi \subseteq \cal{C}$, an \emph{Armstrong model} $M$
of $\Phi$, relative to $\armctxt{C}$, has the property that for every
 $\varphi \in \cal{C}$, it is the case that $M \in \modelsof{\varphi}$
iff $\Phi \sentails \varphi$.
    In other words, an Armstrong model $M$ is minimal in the sense that it
satisfies only those constraints of $\cal{C}$ which must be
satisfied in order for $M$ to be a model of $\Phi$.
     Say that $\cal{C}$ \emph{admits Armstrong models}, or that it is
an \emph{Armstrong context}, if every satisfiable subset of
$\armctxt{C}$ has such a model.
    See \mycite{Fagin82} for a comprehensive discussion of Armstrong
models, including a succinct characterization of the conditions under
which they exist \mycite[Thm.\ 3.1]{Fagin82}.
    \par
    In the context of this paper, the important case is
  $\cal{C} = \pbinconstrgrsch{G}$.  While it follows easily from the
more general result of \mycite[3.18]{HegnerRo17_inform} that
$\pbinconstrgrsch{G}$ admits Armstrong models, a much stronger result
is established in this section.  Specifically, it is shown how to
construct an Armstrong model, called the canonical model, for
$\pconstrgrsch{G}$.  Since $\granschemaname{G}$ is arbitrary, this is
essentially equivalent to showing how to construct a canonical model
for any
 $\Phi \subseteq \pbinconstrgrsch{G}$.  Using that model, it is shown
that the positive inference rules identified in Sec.\ \ref{sec:intro}
are both sound and complete.
 \end{metalabpara}

