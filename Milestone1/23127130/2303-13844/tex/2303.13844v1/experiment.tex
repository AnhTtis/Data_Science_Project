\begin{table*}[ht]
	\centering
	\caption{Datasets Statistics}
	\footnotesize
	\begin{tabular}{|c|c|c|c|c|} 
		\hline
		Datasets & triples & entities & predicates & literals \\
		\hline
		% LUBM10M & 10,828,077 & 1,843,219 & 18 & 3,561,817 \\
		LUBM  & 534,355,247 & 86,990,882 & 18 & 44,658,530 \\
		\hline
		DBpedia & 830,030,460 & 96,375,582 & 57,471 & 59,825,935 \\
		\hline
	\end{tabular}
	% \normalsize
	\label{tab:ds}
	\vspace{-0.1in}
\end{table*}


\begin{table*}[ht]
\begin{minipage}{9cm}	
 \centering
	\caption{Query Statistics on LUBM}
	\footnotesize
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		&Query & Type & $Count_{BGP}$ & $Depth$ & $|[\![Q]\!]_D|$ \\ \hline
		\multirow{5}{*}{Group 1}&{q1.1} & {U} & {9} & {2} & {645,666}  \\ \cline{2-6}
		&{q1.2} & {O} & {3} & {2} & {44,653,510}  \\ \cline{2-6} 
		&{q1.3} & {O} & {4} &{4} & {76}  \\ \cline{2-6}  
		&{q1.4} & {O} & {4} &{4} & {5,583}  \\ \cline{2-6} 
		&{q1.5} & {UO} & {6} &{3} & {4,348}  \\ \cline{2-6}
		&{q1.6} & {UO} & {9} &{3} & {37}  \\ 
		\hline \hline
		\multirow{6}{*}{Group 2}&{q2.1} & {O} & {3} &{1} & {4,176,432}  \\ \cline{2-6} 
		&{q2.2} & {O} & {4} &{3} & {8,698}  \\ \cline{2-6} 
		&{q2.3} & {O} & {4} &{3} & {13,124,940}  \\ \cline{2-6}  
		&{q2.4} & {O} & {2} &{3} & {10}  \\ \cline{2-6}  
		&{q2.5} & {O} & {2} &{2} & {10}  \\ \cline{2-6}  
		&{q2.6} & {O} & {2} &{2} & {7} \\ \hline 
	\end{tabular}
	\label{tab:exp_uo_lubm}
 \end{minipage}
 \begin{minipage}{9cm}
 \centering
	\caption{Query Statistics on DBpedia}
	\footnotesize
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		& Query & Type & $Count_{BGP}$ & $Depth$ & $|[\![Q]\!]_D|$ \\ \hline
		\multirow{5}{*}{Group 1}&{q1.1} & {U} & {6} &{2} & {153,325}  \\ \cline{2-6}
		&{q1.2} & {UO} & {4} &{3} & {610,434}  \\ \cline{2-6}  
		&{q1.3} & {O} & {5} &{5} & {1,192}  \\ \cline{2-6}  
		&{q1.4} & {UO} & {7} &{5} & {92,041}  \\ \cline{2-6}   
		&{q1.5} & {UO} & {6} &{3} & {3,699,995}  \\ \cline{2-6}
		&{q1.6} & {UO} & {10} &{4} & {176} \\ \hline \hline
		\multirow{6}{*}{Group 2}
		&{q2.1} & {O} & {5} &{3} & {490,876}  \\ \cline{2-6}  
		&{q2.2} & {O} & {2} &{2} & {55,054}  \\ \cline{2-6}
		&{q2.3} & {O} & {2} &{2} & {61,318}  \\ \cline{2-6}   
		&{q2.4} & {O} & {3} &{2} & {4,757} \\ \cline{2-6}  
		&{q2.5} & {O} & {2} &{2} & {5,330}  \\ \cline{2-6} 
		&{q2.6} & {O} & {9} &{2} & {36} \\ 
		\hline
	\end{tabular}
	\label{tab:exp_uo_dbpedia}
 \end{minipage}
\end{table*}

\nop{
\begin{table}[ht]
	\centering
	\caption{Query Statistics on DBpedia}
	\small
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		&query & type & $Count_{BGP}(Q)$ & $Depth(Q)$ & $|[\![Q]\!]_D|$ \\ \hline
		\multirow{5}{*}{Group 1}&{q1.1} & {U} & {6} &{2} & {153,325}  \\ \cline{2-6}
		&{q1.2} & {UO} & {4} &{3} & {610,434}  \\ \cline{2-6}  
		&{q1.3} & {O} & {5} &{5} & {1,192}  \\ \cline{2-6}  
		&{q1.4} & {UO} & {7} &{5} & {92,041}  \\ \cline{2-6}   
		&{q1.5} & {UO} & {6} &{3} & {3,699,995}  \\ \cline{2-6}
		&{q1.6} & {UO} & {10} &{4} & {176} \\ \hline \hline
		\multirow{6}{*}{Group 2}
		&{q2.1} & {O} & {5} &{3} & {490,876}  \\ \cline{2-6}  
		&{q2.2} & {O} & {2} &{2} & {55,054}  \\ \cline{2-6}
		&{q2.3} & {O} & {2} &{2} & {61,318}  \\ \cline{2-6}   
		&{q2.4} & {O} & {3} &{2} & {4,757} \\ \cline{2-6}  
		&{q2.5} & {O} & {2} &{2} & {5,330}  \\ \cline{2-6} 
		&{q2.6} & {O} & {9} &{2} & {36} \\ 
		\hline
	\end{tabular}
	\label{tab:exp_uo_dbpedia}
\end{table}}

\nop{
\begin{figure}
	\centering
	\includegraphics[scale=0.5]{exp/Tab5.pdf}
	\vspace{-0.1in}
	\caption{\texttt{UNION} \& \texttt{OPTIONAL} \& \texttt{FILTER}   Performance on LUBM}
	\label{exp:uof-performance:lubm}
	\vspace{-0.1in}
\end{figure}


\begin{figure}
	\centering
	\includegraphics[scale=0.5]{exp/Tab6.pdf}
	\vspace{-0.1in}
	\caption{\texttt{UNION} \& \texttt{OPTIONAL} \& \texttt{FILTER} Performance on DBpedia}
	\label{exp:uof-performance:dbpedia}
	\vspace{-0.1in}
\end{figure}
}
\vspace{-0.2in}
\section{Experiments}\label{Sec:experiments}

% TODO: replace (or add) experimental results of Jena
To evaluate the effectiveness of our approach, we employ the BGP query engines of Jena and gStore to implement our BGP-based cost-aware SPARQL-UO evaluation strategy. We pull the latest version of Jena as of 27 June, 2022 from their GitHub repository\footnote{\url{https://github.com/apache/jena}.}. All the experiments run on Jena have enabled the statistics-based optimizations. We forked a branch from the main branch of gStore (v0.91) and implement our proposed SPARQL-UO optimizer based on it\footnote{Our implementation is available at \url{https://anonymous.4open.science/r/gStore-UO/}.}. Experiments are conducted on both synthetic (LUBM \cite{lubmurl}) and real (DBpedia\footnote{The DBpedia data dump that we use is V3.9, which is downloadable at \url{http://downloads.dbpedia.org/3.9/en/}. We use the concatenation of all the N-Triples files.}\cite{Dbpediaurl}) RDF datasets, the statistics of which are listed in Table \ref{tab:ds}. Our implementation and all the queries used in our experiments can be found in our anonymous GitHub repository\footnote{\url{https://anonymous.4open.science/r/gStore-UO-opt/}.}. We conduct experiments on a Linux server with an Intel Xeon Gold 6126 CPU @ 2.60GHz CPU and 256GB memory.

%implement them in both gStore and Jena and replace their original SPARQL-UO query engine. We pull the latest version of Jena as of 27 June, 2022 from their GitHub repository \footnote{\url{https://github.com/apache/jena}.}. 



% Specifically, we generate two synthetic LUBM datasets of different sizes (LUBM10M and LUBM500M) to be used in different sets of experiments.


\subsection{Verification of Optimizations} \label{subsec:expr_optimizations}

In this section, we verify the effectiveness of the proposed optimizations in Section \ref{sec:transformation} and evaluate the following four approaches:
\begin{enumerate}
    \item The baseline (abbreviated as \texttt{base}), which invokes the BGP-based query evaluation method (Algorithm \ref{alg:bgpe}) on the original BE-tree, analogous to the original SPARQL-UO implementations in Jena and gStore;
    \item Tree transformation (abbreviated as \texttt{TT}), which transforms the original BE-tree by Algorithm \ref{alg:multi_level} and then invokes Algorithm \ref{alg:bgpe} on it;
    \item Candidate pruning (abbreviated as \texttt{CP}), which invokes Algorithm \ref{alg:bgpe} augmented with candidate pruning (Section \ref{sec:cand_pruning}) on the original BE-tree, using a fixed threshold of 1\% of the total number of triples in the database;% 1,000,000;
    \item The full version that coordinates tree transformation and candidate pruning (abbreviated as \texttt{full}), which transforms the original BE-tree by Algorithm \ref{alg:multi_level}, and then invokes Algorithm \ref{alg:bgpe} augmented by candidate pruning, using an adaptive threshold on the candidate result size.
\end{enumerate}
% We denote the baseline that invokes the BGP-based query evaluation method (Algorithm \ref{alg:bgpe}) on the original BE-tree as \texttt{BGPE}, and the optimized approach that invokes the BGP-based method with candidate pruning on the transformed BE-tree as \texttt{BGPE-T}.

Since there is no benchmark tailored for SPARQL-UO queries to our knowledge, we construct a mini-benchmark with realistic semantics and varying complexities, containing six queries on LUBM and DBpedia, respectively, denoted as q1.1-1.6 in the following and given in Appendix A of \cite{zouSPARQLUO:22}.
% use SPARQL queries that contain a variety of \texttt{UNION} and \texttt{OPTIONAL} clauses.
% These queries can be divided into three categories: those that can be accelerated by \texttt{TT} but not \texttt{CP}, those that can be accelerated by \texttt{CP} but not \texttt{TT}, and those on which \texttt{TT} and \texttt{CP} coordinate to achieve the best performance.
% (q1.1: only \texttt{UNION}, q1.2: only \texttt{OPTIONAL}, q1.3: \texttt{UNION} only outside \texttt{OPTIONAL}, q1.4: \texttt{UNION} only inside \texttt{OPTIONAL}, q1.5: \texttt{UNION} both inside and outside \texttt{OPTIONAL}).
Let $Q$ be the outermost group graph pattern in the query. To measure the complexity of a query, we define two metrics: (1) the BGP count ($Count_{BGP}(Q)$), and (2) the maximum depth of nested group graph patterns ($Depth(Q)$).

$Count_{BGP}(P)$ of a graph pattern $P$ is recursively defined:
\begin{enumerate}
	\item If $P$ is a BGP, $Count_{BGP}(P) = 1$.
	\item If $P = \{P_1\}$, $Count_{BGP}(P) = Count_{BGP}(P_1)$.
	\item If $P = P_1 \ \texttt{AND} \ P_2$ or $P_1 \ \texttt{UNION} \ P_2$ or $P_1 \ \texttt{OPTIONAL} \ P_2$, \\$Count_{BGP}(P) = Count_{BGP}(P_1) + Count_{BGP}(P_2)$.
	% \item If $P = (P_1 \ \texttt{FILTER} \ R)$, $Count_{BGP}(P) = Count_{BGP}(P_1)$.
\end{enumerate}

$Depth(P)$ of a graph pattern $P$ is recursively defined as follows:
\begin{enumerate}
	\item If $P$ is a BGP, $Depth(P) = 0$.
	\item If $P = \{P_1\}$, $Depth(P) = Depth(P_1) + 1$.
	\item If $P = P_1 \ \texttt{AND} \ P_2$ or $P_1 \ \texttt{UNION} \ P_2$ or $P_1 \ \texttt{OPTIONAL} \ P_2$, \\ $Depth(P) = \max (Depth(P_1),Depth(P_2))$.
	% \item If $P = P_1 \ \texttt{FILTER} \ R$, $Depth_{OPT}(P) = Depth_{OPT}(P_1)$.
\end{enumerate}

Suppose $P$ is the outermost group graph pattern of query $Q$, we have $Count_{BGP}(Q) = Count_{BGP}(P), Depth(Q) = Depth(P)$. Group 1 in Tables \ref{tab:exp_uo_lubm} and \ref{tab:exp_uo_dbpedia} summarizes the statistics and the result sizes of the queries used in this subsection. % Besides the two aforementioned metrics, we also give the results sizes of queries.
% Note that the result sizes of LUBM are those on LUBM500M.

% Since \texttt{BGPE} runs out of time or memory on all five queries on LUBM500M, we use LUBM10M in the experiments of this section.

\nop{
\begin{figure*}
	\centering
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{exp/verify_opt_lubm_gStore.pdf}
		\caption{gStore}
		\label{exp:uo-performance:lubm:gStore}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{exp/verify_opt_lubm_Jena.pdf}
		\caption{Jena}
		\label{exp:uo-performance:lubm:Jena}
	\end{subfigure}
	\vspace{-0.1in}
	\caption{Verification of optimizations on LUBM}
	\label{exp:uo-performance:lubm}
	\vspace{-0.1in}
\end{figure*}

\begin{figure*}
	\centering
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{exp/verify_opt_dbpedia_gStore.pdf}
		\caption{gStore}
		\label{exp:uo-performance:dbpedia:gStore}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{exp/verify_opt_dbpedia_Jena.pdf}
		\caption{Jena}
		\label{exp:uo-performance:dbpedia:Jena}
	\end{subfigure}
	\vspace{-0.1in}
	\caption{Verification of optimizations on DBpedia}
	\label{exp:uo-performance:dbpedia}
	\vspace{-0.0in}
\end{figure*}
}

\begin{figure*}[!h]
    \centering
	\includegraphics[scale=0.4]{exp/verify_opt_wide.pdf}
	\vspace{-0.2in}
	\caption{Verification of optimizations.}
	\label{fig:exp-verify}
	\vspace{-0.1in}
\end{figure*}

\begin{figure*}[!h]
	\centering
	\includegraphics[scale=0.5]{exp/explain.pdf}
	\vspace{-0.1in}
	\caption{The execution time and join space of queries.}
	\label{fig:exp-explain}
	\vspace{-0.1in}
\end{figure*}

We measure the performance by the query execution time. We also report the time spent carrying out the tree transformations for \texttt{TT} and \texttt{full}.
% total response time of a query, which for \texttt{BGPE} is equal to the query execution time, and for \texttt{BGPE-T} is the sum of the time spent carrying out the BE-tree transformations introduced in \ref{sec:transformation} and the query execution time.
The performance of our approaches on LUBM and DBpedia is shown in Figure \ref{fig:exp-verify}.
% Note that the total response time of \texttt{BGPE-T} is represented by stacked bars, the upper parts of which indicate the time spent on transformations, and the lower parts indicate the query execution time.
The absence of a bar indicates an out-of-memory error on the query. A query is considered timed-out if the execution time exceeds $2 \times 10^6$ microseconds.
% When the execution of a query runs out of memory, we delete the corresponding bar in the figure; when the total response time on a query exceeds three hours, we draw a bar that reaches the upper limit of the time axis.

The trends of the results across gStore and Jena are similar, showing the adaptability of our approach regardless of the underlying BGP execution engine. % We hence focus on the results of gStore in the following analysis.
Both of our proposed optimizations are shown to be effective since \texttt{TT}, \texttt{CP} and \texttt{full} perform better than \texttt{base} on all queries. \texttt{TT} and \texttt{CP} can be more advantageous on different queries and datasets than the other. Their optimization effects are cumulative when combined: \texttt{full} performs best all queries and datasets (except on q1.2 on gStore, where \texttt{CP} beats \texttt{full} by a small margin), beating the baseline by at least 2x and up to over an order of magnitude. Our optimized approaches also consume less memory. While \texttt{base} runs out of memory on 13 out of 24 queries, \texttt{full} successfully runs all the queries.

In the following, we try to draw some conclusions about the applicability of our optimizations to different SPARQL-UO queries by analyzing the benchmark queries and the behavior of the optimized approaches on them.

\Paragraph{When \texttt{TT} is effective.} q1.1 on DBpedia (Listing \ref{lst:q1.1_dbpedia}, Appendix \ref{app:queries} of \cite{zouSPARQLUO:22}) is a query on which \texttt{TT} is effective, but \texttt{CP} is not. In this query, two \texttt{UNION} clauses are given first (Lines 2-3), whose child BGPs all have low selectivity. There is no high-selectivity graph pattern before them to enable \texttt{CP}. However, \texttt{TT} can merge the high-selectivity BGP in Lines 5-8 with the \texttt{UNION} clause in Line 3 to accelerate query processing and reduce memory overhead, as evidenced in Figure \ref{fig:exp-verify}. q1.2 on LUBM and q1.2 on DBpedia also belong to this category. (Note that q1.2 on LUBM corresponds to the special case mentioned in Section \ref{sec:cand_pruning}, where there is only a BGP before an \texttt{OPTIONAL} clause, and thus \texttt{TT} and \texttt{CP} have a similar effect.)
\Paragraph{When \texttt{CP} is effective.} q1.3 on LUBM (Listing \ref{lst:q1.3_lubm}, Appendix \ref{app:queries} of \cite{zouSPARQLUO:22}) is a query on which \texttt{CP} is effective, but \texttt{TT} is not. In this query, the BGP in Line 2 has high selectivity, followed by nested \texttt{OPTIONAL}s with low-selectivity child BGPs. \texttt{TT} can inject the BGP into the outermost \texttt{OPTIONAL} but cannot reach the inner \texttt{OPTIONAL}s, thus having limited effect. However, \texttt{CP} can carry the small number of results into the innermost \texttt{OPTIONAL} and set them as candidates to accelerate query processing. q1.3-4 on LUBM and q1.3-4 on DBpedia also belong to this category.
\Paragraph{When \texttt{TT} and \texttt{CP} are jointly effective.} q1.6 on LUBM (Listing \ref{lst:q1.6_lubm}, Appendix \ref{app:queries} of \cite{zouSPARQLUO:22}) is a query on which \texttt{TT} and \texttt{CP} work complementarily, causing \texttt{full} to perform much better than \texttt{TT} and \texttt{CP}. In this query, the BGP in Lines 2-3 has high selectivity, while the BGP in Line 4 has relatively low selectivity. Upon obtaining their considerably large results, \texttt{CP} has limited effect on the following \texttt{UNION} clauses. \texttt{TT}, however, can pick the high-selectivity BGP to merge with the \texttt{UNION} in Line 5. Having executed the graph patterns up to Line 6, \texttt{CP} can accelerate the processing of upcoming \texttt{OPTIONAL}s. q1.1 and q1.5 on LUBM and q1.5 and q1.6 DBpedia also belong to this category.


\nop{
\begin{itemize}
	\item \textbf{When \texttt{TT} is effective.} q1.1 on DBpedia (Listing \ref{lst:TT_effective} ) is a query on which \texttt{TT} is effective, but \texttt{CP} is not. In this query, two \texttt{UNION} clauses are given first (Lines 11-12), whose child BGPs all have low selectivity. There is no high-selectivity graph pattern before them to enable \texttt{CP}. However, \texttt{TT} can merge the high-selectivity BGP in Lines 14-17 with the \texttt{UNION} clause in Line 12 to accelerate query processing and reduce memory overhead, as evidenced in Figure \ref{fig:exp-verify}. q1.2 on LUBM and q1.2 on DBpedia also belong to this category. (Note that q1.2 on LUBM corresponds to the special case mentioned in Section \ref{sec:cand_pruning}, where there is only a BGP before an \texttt{OPTIONAL} clause, and thus \texttt{TT} and \texttt{CP} have a similar effect.)
	\item \textbf{When \texttt{CP} is effective.} q1.3 on LUBM (Listing \ref{lst:CP_effective}) is a query on which \texttt{CP} is effective, but \texttt{TT} is not. In this query, the BGP in Line 5 has high selectivity, followed by nested \texttt{OPTIONAL}s with low-selectivity child BGPs. \texttt{TT} can inject the BGP into the outermost \texttt{OPTIONAL} but cannot reach the inner \texttt{OPTIONAL}s, thus having limited effect. However, \texttt{CP} can carry the small number of results into the innermost \texttt{OPTIONAL} and set them as candidates to accelerate query processing. q1.3-4 on LUBM and q1.3-4 on DBpedia also belong to this category.
	\item \textbf{When \texttt{TT} and \texttt{CP} are jointly effective.} q1.6 on LUBM (Listing \ref{lst:TTCP_effective}) is a query on which \texttt{TT} and \texttt{CP} work complementarily, causing \texttt{full} to perform much better than \texttt{TT} and \texttt{CP}. In this query, the BGP in Lines 4-5 has high selectivity, while the BGP in Line 6 has relatively low selectivity. Upon obtaining their considerably large results, \texttt{CP} has limited effect on the following \texttt{UNION} clauses. \texttt{TT}, however, can pick the high-selectivity BGP to merge with the \texttt{UNION} in Line 7. Having executed the graph patterns up to Line 8, \texttt{CP} can accelerate the processing of upcoming \texttt{OPTIONAL}s. q1.1 and q1.5 on LUBM and q1.5 and q1.6 DBpedia also belong to this category.
\end{itemize}
}
\nop{
\begin{lstlisting}[caption={q1.1 on DBpedia (Effective \texttt{TT})}, label={lst:TT_effective}, frame=single, breaklines=true, basicstyle=\footnotesize, morekeywords={PREFIX, SELECT, WHERE, UNION, OPTIONAL}, numbers=left, numbersep=4pt, numberstyle=\tiny\color{gray}]
PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#>
PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
PREFIX purl:  <http://purl.org/dc/terms/>
PREFIX skos:  <http://www.w3.org/2004/02/skos/core#>
PREFIX nsprov:  <http://www.w3.org/ns/prov#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX dbo:  <http://dbpedia.org/ontology/>
PREFIX dbr:  <http://dbpedia.org/resource/>

SELECT * WHERE {
{ ?v3 rdfs:label ?v7. } UNION { ?v3 foaf:name ?v7. }
{ ?v1 purl:subject ?v3. } UNION { ?v3 skos:subject ?v1. }
?v3 rdfs:label ?v4.
?v5 nsprov:wasDerivedFrom ?v2.
?v1 owl:sameAs ?v6.
?v1 dbo:wikiPageWikiLink dbr:Economic_system.
?v1 nsprov:wasDerivedFrom ?v2. }
\end{lstlisting}

\begin{lstlisting}[caption={q1.3 on LUBM (Effective \texttt{CP})}, label={lst:CP_effective}, frame=single, breaklines=true, basicstyle=\footnotesize, morekeywords={PREFIX, SELECT, WHERE, UNION, OPTIONAL}, numbers=left, numbersep=4pt, numberstyle=\tiny\color{gray}]
PREFIX ub:  <http://swat.cse.lehigh.edu/onto/univ-bench.owl#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT * WHERE {
<http://www.Department1.University0.edu/UndergraduateStudent363> ub:takesCourse ?v1.
OPTIONAL { ?v2 ub:teachingAssistantOf ?v1.
OPTIONAL { ?v2 ub:memberOf ?v3.
?v4 ub:subOrganizationOf ?v3.
?v4 ub:subOrganizationOf ?v5.
?v4 rdf:type ?v6.
OPTIONAL { ?v5 ub:subOrganizationOf ?v7. } } } }
\end{lstlisting}

\begin{lstlisting}[caption={q1.6 on LUBM (Jointly effective \texttt{TT} and \texttt{CP})}, label={lst:TTCP_effective}, frame=single, breaklines=true, basicstyle=\footnotesize, morekeywords={PREFIX, SELECT, WHERE, UNION, OPTIONAL}, numbers=left, numbersep=4pt, numberstyle=\tiny\color{gray}]
PREFIX ub: <http://swat.cse.lehigh.edu/onto/univ-bench.owl#>

SELECT * WHERE {
?v4 ub:headOf ?v1.
<http://www.Department1.University0.edu/UndergraduateStudent256> ub:memberOf ?v1.
?v3 ub:subOrganizationOf ?v5.
{ ?v2 ub:worksFor ?v1. } UNION { ?v2 ub:headOf ?v1. }
{ ?v2 ub:worksFor ?v3. } UNION { ?v2 ub:headOf ?v3. }
OPTIONAL { ?v6 ub:publicationAuthor ?v2. }
OPTIONAL { { ?v7 ub:headOf ?v1. } UNION { ?v7 ub:worksFor ?v1. } } }
\end{lstlisting}
}

For a quantitative perspective on the optimization effects, we define the join space of a graph pattern $JS(P)$ as follows:

\begin{enumerate}
	\item If $P$ is a BGP, $JS(P) = |[\![P]\!]_D|$.
	\item If $P = \{P_1\}$, $JS(P) = JS(P_1)$.
	\item If $P = P_1 \ \texttt{AND} \ P_2$ or $P_1 \ \texttt{OPTIONAL} \ P_2$, $JS(P) = JS(P_1) \times JS(P_2)$.
	\item If $P = P_1 \ \texttt{UNION} \ P_2$, $JS(P) = JS(P_1) + JS(P_2)$.
\end{enumerate}

\begin{figure*}
	\centering
	\includegraphics[scale=0.5]{exp/scalability.pdf}
	\vspace{-0.1in}
	\caption{Query execution time (ms) of \texttt{full} on LUBM datasets of different sizes (``B'' is short for billion).}
	\label{exp:scalability}
	\vspace{-0.1in}
\end{figure*}

The join space of a query estimates the largest intermediate result size that is materialized during the execution of this query. Therefore, it is indicative of both the query's execution time and memory overhead. We plot the execution time of all the queries on gStore and Jena (the y-axis on the left) with their respective join spaces (the y-axis on the right) in Figure \ref{fig:exp-explain}. Across the tested approaches, these three metrics show a similar trend. On all the queries, the join spaces of \texttt{TT} and \texttt{CP} are smaller than those of \texttt{base}, and \texttt{full} has the smallest join space overall, which corroborates the qualitative analysis above.

\nop{We note that on q1.3 and q1.4 of both datasets, \texttt{full} and \texttt{CP} have nearly identical query execution time, but the overall response time of \texttt{full} exceeds that of \texttt{CP} due to the extra time cost of tree transformation. This is when tree transformation actively decides to defer the optimization to run-time, as described in Section \ref{sec:cand_pruning}, and the fixed threshold on result size happens to perform well enough. Apparently, such a phenomenon does not render tree transformation unnecessary, because \texttt{CP} still performs significantly worse than \texttt{full} on other queries. Even on these queries, it is difficult to tune an appropriate threshold without the BGP result size estimation. We take on the mission of further reducing the cost of tree transformation (e.g., by parallelization) as future work.}

% The baseline, \texttt{BGPE}, runs out of memory on four queries, and out of time in one query out of ten, while the optimized \texttt{BGPE-T} can successfully run all queries. On the remaining five queries where both methods can successfully run, \texttt{BGPE-T} is up to three orders of magnitude faster than \texttt{BGPE} even taking the time spent on transformations into account, except on q1.1 of DBpedia, where the two methods perform comparably.

\nop{
\begin{figure}
	\centering
	\includegraphics[scale=1.90]{new_figure/case_study.png}
	\vspace{-0.1in}
	\caption{The original and transformed q1.1 of DBpedia}
	\label{fig:case_study}
	\vspace{-0.1in}
\end{figure}
}

% TODO: refine this analysis.
% In order to analyze why \texttt{BGPE-T} does not exhibit the same level of efficiency on q1.1 of DBpedia as on other queries, we show the original query and the query mapped to its transformed BE-tree in Figure \ref{fig:case_study}. We note that two transformations are made: one is a \emph{merge} between the BGP \texttt{?v3 rdfs:label ?v4} and the first \texttt{UNION}, and the other is a \emph{merge} between the BGP formed from the remaining triples and the last \texttt{UNION}. Actually, if only the second transformation is carried out, the query execution is faster than \texttt{BGPE}. Thus the first transformation is to blame for the relative inefficiency, which seems obvious, since the predicate \texttt{rdfs:label} has low selectivity. However, this is in fact a challenging case for a cost model, since the BGPs in first \texttt{UNION} also have low selectivity. Since a \emph{merge} eliminates the cost of the implicit \texttt{AND} between the triple and the \texttt{UNION}, it is easy for the cost model to favor the \emph{merge} if the BGP engine does not give an accurate enough estimation. Our cost model makes the decision by a small margin ($<10\%$ of the overall $\Delta$-cost).

\nop{
In summary, the experiments conducted in this section show that the cost-driven BE-tree transformations and candidate pruning can significantly improve both the time and space efficiency of SPARQL-UO query evaluation.
}

\subsection{Comparison with State-of-the-Art}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{exp/sota.pdf}
	\vspace{-0.1in}
	\caption{Comparison with state-of-the-art on LUBM.}
	\label{exp:overall-lubm}
	\vspace{-0.15in}
\end{figure}



\nop{
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.45]{exp/sota_dbpedia.pdf}
	\vspace{-0.1in}
	\caption{Comparison with state-of-the-art on DBpedia.}
	\label{exp:overall-dbpedia}
	\vspace{-0.1in}
\end{figure}
}

The only work that considers SPARQL with \texttt{OPTIONAL} query optimization is LBR \cite{DBLP:conf/sigmod/Atre15}. Thus, we compare our \texttt{full} approach with LBR. We also implement LBR in C++.
% The queries q1.2 is the same as those used in Section \ref{subsec:expr_optimizations}. 
% Since LBR cannot process queries with \texttt{UNION} clauses, 
%the results on the queries q1.1 and q1.3-1.5 are omitted. In addition,
We experiment on the queries provided in LBR \cite{DBLP:conf/sigmod/Atre15} on LUBM and DBpedia, listed as q2.1-2.6, given in Appendix \ref{app:queries} of \cite{zouSPARQLUO:22}. The statistics of these queries are given in the second group in Tables \ref{tab:exp_uo_lubm} and \ref{tab:exp_uo_dbpedia}. q2.1-2.3 are complex with multiple nested group graph patterns, each containing a low-selectivity BGP followed by an \texttt{OPTIONAL} with a single low-selectivity child BGP. Meanwhile, q2.4-2.6 are simple without nested group graph patterns, and their outermost group graph pattern contains a high-selectivity BGP followed by an \texttt{OPTIONAL}.
% Since we only compare our optimized method, \texttt{BGPE-T}, with LBR, we use the larger synthetic dataset, LUBM500M, in the experiments of this section.

The total response time of \texttt{full} and LBR are shown in Figures \ref{exp:overall-lubm}.
% As in Section \ref{subsec:expr_optimizations}, the total response time of \texttt{BGPE-T} is the sum of the time spent carrying out BE-tree transformations and the query execution time, while that of LBR is equal to its query execution time.
\texttt{full} is significantly faster than LBR on all queries, and the improvement on q2.4-2.6 is more significant than on q2.1-2.3. This is because candidate pruning can take advantage of the high-selectivity BGPs in q2.4-2.6, while q2.1-2.3 does not contain high-selectivity BGPs. (Note that since all the group graph patterns in q2.1-2.6 contain a BGP followed by an \texttt{OPTIONAL} clause, they correspond to the special case mentioned in Section \ref{sec:cand_pruning} where tree transformation and candidate pruning are equivalent, hence only candidate pruning is performed.) The results show that when candidate pruning takes effect, it is more efficient than LBR's heavy-weight pruning strategies. On q2.1-2.3, \texttt{full} is still faster than LBR since its BGP-based evaluation scheme is more efficient than LBR's separate treatment of triple patterns. % This needs to be more accurate
% This empirically shows that although LBR is specially optimized for \texttt{OPTIONAL} queries, our more general optimization techniques are still more effective than theirs.

In summary, our approach outperforms LBR on \texttt{OPTIONAL} queries, despite LBR being optimized for \texttt{OPTIONAL}.

% We also evaluate the scalability of our method on Wikidata, which contains more than 2 billion triples, in Table \ref{tab:exp_overall_wikidata}, showing that our method achieves better performance than Jena. The reason is that our method can significantly reduce search space by our proposed pruning techniques. 


\subsection{Scalability Study}

Lastly, we evaluate how well our approach scales to larger datasets. By setting the scaling factor of LUBM, i.e., the number of universities, we generate three more LUBM datasets with 1, 1.5 and 2 billion triples, respectively. We run the \texttt{full} approach on q1.1-q1.6 on these datasets and plot how the execution time changes with the dataset size on each query in Figure \ref{exp:scalability}.



These plots are empirical complexity curves of our approach.
% Although BGP evaluation (\emph{i.e., } subgraph matching) is NP-hard \cite{},
Our approach scales almost linearly to the number of triples in the datasets. The growth rate of the query execution time correlates with each query's result sizes: the execution time of queries with larger result sizes grows faster with the dataset size. (The result sizes of q1.3-1.6 on larger LUBM datasets are equal to those shown in Table \ref{tab:exp_uo_lubm}, while those of q1.1-1.2 grow linearly.)
% On the largest dataset with 2 billion triples, the longest query execution time does not exceed half an hour. (It is common for commercial RDF stores to perform on par with this on complex queries. For example, )