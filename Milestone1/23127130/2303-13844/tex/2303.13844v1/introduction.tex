\vspace{-0.10in}
\section{Introduction}
The proliferation of knowledge graphs has generated many RDF (Resource Description Framework) data management problems. RDF is the de-facto data model for knowledge graphs, where each edge is a triple of $\langle$subject, predicate, object$\rangle$. SPARQL has been the focus of a significant body of research as the standard language for accessing RDF datasets. Most of the existing work focus on basic graph pattern (BGP) execution \cite{Neumann2009,DBLP:journals/pvldb/ZouMCOZ11,DBLP:journals/pvldb/YuanLWJZL13}, which is the basic building block of SPARQL. On the other hand, how to execute and optimize queries containing operators on graph patterns, such as \texttt{UNION} and \texttt{OPTIONAL}, has received much less attention.

%A triple models a pair of entities connected by a named relationship or an entity associated with a named attribute value.

\texttt{UNION} and \texttt{OPTIONAL} expressions are essential in SPARQL grammar. RDF is a semi-structured data model that does not enforce the underlying data to adhere to a predefined schema, which provides flexibility in integrating diverse sources of RDF data, but leads to challenges when issuing queries since the same information can be represented in many ways in RDF graphs. The \texttt{UNION} operator is crucial in this case since it groups diversely expressed information. For example, in DBpedia \cite{DBLP:journals/semweb/LehmannIJJKMHMK15}, an open-domain knowledge graph extracted from Wikipedia, persons' names are represented using the predicate $\langle$\texttt{foaf:name}$\rangle$ or $\langle$\texttt{rdfs:label}$\rangle$. Thus, to fully retrieve all the names of a group of persons (e.g., Presidents of the United States), it is necessary to use the \texttt{UNION} operator (Figure \ref{fig:bgpeupb}(a)).

\begin{figure*}
	\centering
	\includegraphics[scale=0.5]{figure/motivation-query.pdf}
	\vspace{-0.1in}
	\caption{An Example Query with a \texttt{UNION} and  \texttt{OPTIONAL} Clause}
	\label{fig:bgpeupb}
	\vspace{-0.1in}
\end{figure*}

In addition to the diversity of representation, incompleteness is another feature of RDF datasets. Specifically, an entity may lack some attributes or relationships of most other similar entities (which are most likely to be stored in the same table in a relational database). The {OPTIONAL} operator is crucial in this case since it allows attaching some attributes or relations as optional information. For example, the \texttt{OPTIONAL} query in Figure \ref{fig:bgpeupb}(b) fetches all the presidents of the United States, along with other references to them that are not on the same Wikipedia page (through the predicate \texttt{owl:sameAs}). Since not every president has multiple references in the database, the triple with the predicate \texttt{owl:sameAs} is enclosed in an \texttt{OPTIONAL} expression, so those presidents without alternative references are still retained in the results.

\nop{
\begin{figure*}
	\centering
	\includegraphics[scale=1.0]{figure/bgpeopb-new-new.png}
	\vspace{-0.1in}
	\caption{An Example Query with an \texttt{OPTIONAL} Clause}
	\label{fig:bgpeopb}
	\vspace{-0.1in}
\end{figure*}
}

\texttt{UNION} and \texttt{OPTIONAL} expressions are widely used in real-world SPARQL workloads and are part of the SPARQL 1.1 specification. Recent empirical studies \cite{bonifati2020analytical} show that \texttt{UNION} and \texttt{OPTIONAL} expressions occur in $25.10\%$ and $31.72\%$ of the valid queries from real SPARQL query logs across a diverse range of endpoints, respectively. In this paper, we address the efficient execution of SPARQL queries with \texttt{UNION} and \texttt{OPTIONAL} expressions, which we abbreviate as SPARQL-UO queries.
\Paragraph{Our Solution.} Since BGP has been well studied, it is desirable to build SPARQL-UO query optimization on a well-performing BGP engine. Therefore, we first propose a BGP-based query evaluation scheme. Specifically, we propose a \emph{B}GP-based \emph{E}valuation (BE)-tree (Definition \ref{def:betree}) for the evaluation plan of SPARQL-UO queries. However, if the BE-tree is evaluated as it is, some BGPs may generate large intermediate results. Therefore, we propose a BE-tree transformation method to generate a more efficient query plan.

We introduce two types of transformations, \emph{merge} and \emph{inject}, that target \texttt{UNION} and \texttt{OPTIONAL} operators, respectively. These transformations expose opportunities for reducing the cost during the evaluation of BGPs, \texttt{UNION} and \texttt{OPTIONAL} operators while preserving query semantics. Since there are many different ways to transform a BE-tree,
% each of which having its unique pros and cons,
we
% decide on the final transformation by estimating the cost of evaluating the transformed tree. To this end, we
devise a cost model that accounts for the cost of evaluating both BGPs and these operators, and choose the transformation that most reduces the cost. Because of the vast space of possible transformations,
% In order to balance the efficiency of BE-tree transformation and query execution, we propose a method to estimate the cost incurred by the local change due to the transformation, called $\Delta$-cost, and further design 
we propose a greedy strategy to determine the transformation step-by-step. The transformed BE-tree is then evaluated by the BGP-based scheme, enhanced by the query-time optimization called \emph{candidate pruning}, which prunes the search space of BGP evaluation on-the-fly whenever possible.

To summarize, we make the following contributions: 
\begin{enumerate}
% \item We propose a systematic framework to evaluate SPARQL-UO queries and define the BE-tree (Definition \ref{def:betree}) to represent the evaluation plan of a SPARQL-UO query.
\item We propose a novel BE-tree representation for the evaluation plan of a SPARQL-UO query and design two BE-tree transformation primitives, \emph{merge} and \emph{inject}, to generate more efficient SPARQL-UO query plans.    
\item We propose a cost model for SPARQL-UO queries and a cost-driven BE-tree transformation algorithm.
\item We design a query-time optimization called \emph{candidate pruning} that augments the BGP-based query evaluation scheme by pruning the search space.
\item We conduct experiments on large-scale real and synthetic RDF datasets, which shows that our method outperforms existing techniques by orders of magnitude.
\end{enumerate}

The remainder of the paper is organized as follows. A brief review of related work is given in Section \ref{sec:related}. Some necessary preliminary information is laid out in Section \ref{sec:preliminary}. Section \ref{sec:bgp} presents the BE-tree plan representation and transformations, as well as the query evaluation scheme. The cost-driven plan selection algorithm is proposed in Section \ref{sec:plan_selection}, and the query-time optimization is presented in \ref{sec:cand_pruning}. We experimentally evaluate our method in Section \ref{Sec:experiments} and conclude the paper in Section \ref{sec:conclusion}.


\section{Related Work}\label{sec:related}

Although the optimization of SPARQL queries has been extensively studied, most of the focus has been on evaluating BGPs \cite{DBLP:conf/sigmod/Atre15}, including graph-based approaches and relational approaches. Graph-based approaches include works on effective index strategies (e.g., gStore \cite{DBLP:journals/pvldb/ZouMCOZ11}) and join order optimization (e.g.,WCOJ \cite{10.1007/978-3-030-30793-6_15}). In contrast, relational approaches rely on a relational DBMS and consider RDF graphs as three-column tables or other complex table organizations \cite{vldb07_Abadi:2007,DBLP:conf/sigmod/BorneaDKSDUB13}. Processing SPARQL queries is then mapped to its relational counterparts, as done in Apache Jena \cite{Wilkinson:Jena2} and Virtuoso \cite{virtuosourl}. % However, graph-based approaches can reduce the candidate vertex set size by building structure-aware indices (such as neighborhood-connection pruning \cite{DBLP:journals/pvldb/ZouMCOZ11}) and make use of efficient subgraph matching algorithms to reduce the intermediate results \cite{DBLP:journals/pvldb/MhedhbiS19}.
Relational BGP optimization approaches focus primarily on efficient data organization (e.g., property table \cite{Wilkinson:Jena2}, vertical partitioning \cite{DBLP:journals/vldb/AbadiMMH09} and single table exhaustive indexing \cite{Neumann2009}). However, these BGP optimization techniques
% aimed at improving the efficiency of queries involving only a single BGP (e.g., \cite{DBLP:journals/pvldb/ZouMCOZ11,DBLP:journals/pvldb/MhedhbiS19}), which mainly focus on finding a better join order in the subgraph matching process,
cannot optimize \texttt{UNION} and \texttt{OPTIONAL} since the semantics of these operators are fundamentally different from joins. As explained in later sections, our solution relies on BGP evaluation as a basic building block, and our proposed optimization techniques operate on a higher level than BGP evaluation techniques.

%We build on these theoretical results in developing our query approach. 

The existing research on SPARQL with \texttt{UNION} and \texttt{OPTIONAL} operators is primarily theoretical, studying their semantics and complexity \cite{DBLP:journals/tods/PerezAG09}. For example, Letelier et al. \cite{10.1145/2500130} propose a WDPT (well-designed pattern tree), which focuses on the analysis of containment and equivalence of a class of SPARQL graph patterns called \emph{well-designed patterns} and identifying the tractable components of their evaluation. However, no work has yet considered SPARQL-UO query optimization from the systems perspective, i.e., how to design an efficient SPARQL query processor to evaluate SPARQL-UO queries. To the best of our knowledge, LBR \cite{DBLP:conf/sigmod/Atre15} is the only work that considers \texttt{OPTIONAL} query optimization. It designs a new data structure GoSN, which is reminiscent of WDPT but focuses on the practical aspects of \texttt{OPTIONAL} pattern evaluation. Concretely, it proposes a query rewriting technique to reduce intermediate results of left-outer joins, the join semantics represented by \texttt{OPTIONAL}. To remove inconsistent variable bindings, LBR uses the \emph{nullification} and \emph{best-match} techniques previously studied in SQL left-outer joins \cite{DBLP:conf/sigmod/RaoPZ04}. LBR also proposes a semijoin strategy to prune candidates, extending the operator for the minimality of acyclic inner joins \cite{DBLP:journals/jacm/BernsteinC81}. However, it follows an execution strategy of two-pass semijoin scans following the graph of join variables, which introduces additional overhead during query execution.
% Furthermore, both \texttt{WDPT} and \texttt{LBR} only deal with well-designed \texttt{OPTIONAL}-only queries, which is a subset of SPARQL.
In this paper, we propose a more comprehensive approach that deals with \texttt{UNION} and \texttt{OPTIONAL}.
% , no matter whether it is a well-designed pattern.
Experiments also demonstrate that our techniques significantly outperform LBR on \texttt{OPTIONAL} queries. 

%Note that \texttt{LBR} \cite{DBLP:conf/sigmod/Atre15} only studies OPTIONAL expression without supporting UNION or FILTER. 

% The main challenge in evaluating SPARQL-UO is the large intermediate result sizes due to the flexibility of \texttt{UNION} and \texttt{OPTIONAL} operators.

% Therefore, we develop graph-based techniques to process SPARQL-UO queries in this work.

% It is also noteworthy that the SPARQL-UO query has a counterpart in relational databases.
% {\color{blue} We should be more careful about discussing the counterpart in RDBMS.}
% TODO:
% Namely...
% We need to point out the uniqueness (novelty) of our work (either unique to the graph setting, or our techniques have not been proposed before even in the relational setting; in the latter case, we need to make clear whether our technique is also applicable to relational queries.)

Note that our techniques to optimize \texttt{UNION} expressions can also be applied to conjunctive relational queries with unions due to their semantic similarity. In fact, all SPARQL-UO queries can be equivalently mapped to SQL, but the mapping of \texttt{OPTIONAL} expressions involves sub-selects in SQL, so our techniques cannot be applied without major adaptations \cite{prud'hommeaux_bertails_2008,chebotko2009semantics}. We are aware of a recent demonstration \cite{al2017optimizing} that proposes a \emph{join pushing} technique on conjunctive queries with unions, which pushes the join condition into the unioned sets if a cost model deems it more efficient. This is principally similar to our approach when applied to relational queries, but no description of the employed cost model is provided, which renders further comparison impossible.

% Though it may appear similar at first glance, our solution is actually distinct from theirs. Firstly, in a SPARQL query, there may be multiple \texttt{UNION} expressions in the same group graph pattern, which are implicitly joined. We consider these \texttt{UNION} expressions in a holistic fashion, while such syntax is non-existent in relational queries. Secondly, join pushing in \cite{al2017optimizing} only serves to reduce the intermediate result size, while our solution also expose optimization opportunities for BGP evaluation on top of that. It is clear that the techniques used to optimize this type of relational queries cannot be trivially extended to optimize SPARQL-UO queries.

