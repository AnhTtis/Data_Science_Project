\section{Plan Representation: BGP-based Evaluation Tree}\label{sec:bgp}

The most straightforward approach for evaluating a graph pattern $P$ is to employ a bottom-up strategy on the binary tree representation. In each step, we either evaluate a triple pattern, or perform a binary operator (\texttt{AND}, \texttt{UNION}, or \texttt{OPTIONAL}).
This binary-tree-based evaluation  strictly follows the SPARQL semantics discussed in Section \ref{sec:preliminary}, but it has a number of inherent performance limitations due to the large number of intermediate results generated for each triple pattern at the leaf nodes of the binary tree expression. To illustrate this, consider the simple SPARQL query in Figure \ref{fig:semetpb}. Note that the outermost group graph pattern of this query only contains a BGP. Following the binary tree expression-based method, we first need to obtain $[\![t_1]\!]_D$ and  $[\![t_2]\!]_D$. Obviously, the triple pattern $t_2$ will generate a large number of intermediate results, since most persons in the database have their birth dates as an attribute.

\begin{figure*}[ht]
	\centering
	\includegraphics[scale=1.4]{figure/semetpb-new.pdf}
	\vspace{-0.1in}
	\caption{Inefficiency of binary-tree-based query evaluation}
	\label{fig:semetpb}
	\vspace{-0.1in}
\end{figure*}

It is evidently more desirable to use BGP evaluation as the basic building block for executing SPARQL queries, employing an optimized BGP query evaluation method such as those used in RDF-3x \cite{Neumann2009}, SW-store \cite{vldb07_Abadi:2007}, gStore \cite{DBLP:journals/pvldb/ZouMCOZ11} and Jena~\cite{Wilkinson:Jena2}. Therefore, in our approach, we design a \underline{B}GP-based \underline{E}valuation Tree (BE-tree) to represent a SPARQL query evaluation plan. 


%Since we focus on the optimized evaluation of \texttt{UNION} and \texttt{OPTIONAL} expressions in this work, we leave out the treatment of \texttt{FILTER} for now, and discuss how \texttt{FILTER} may be incorporated into our framework at the end. 

\subsection{BE-Tree Structure}

\nop{
\begin{definition}[\underline{B}GP-based \underline{E}valuation Tree (BE-tree)] 
\label{def:betree}
Given a group graph pattern $Q$, its corresponding BE-tree $T(Q)$ is recursively defined as follows:
\begin{itemize}
    \item The root of $T(Q)$ is a group graph pattern node representing query $Q$;
    \item A \underline{group graph pattern node} represents a group graph pattern (Definition \ref{def:grouppattern}). It has one or more child nodes, which may be a group graph pattern node, a BGP node, a \texttt{UNION} node, an \texttt{OPTIONAL} node, or a \texttt{FILTER} node;
    \item A \underline{BGP node} represents a BGP (Definition \ref{def:bgp}), and must be a leaf node;
    \item A \underline{\texttt{UNION} node} represents the \texttt{UNION} expression that links two or more group graph patterns, called \texttt{UNION}'ed group graph patterns. It has two or more child nodes, which are all group graph pattern nodes;
    \item An \underline{\texttt{OPTIONAL} node} represents the \texttt{OPTIONAL} expression that links the graph patterns to its left and the adjacent group graph pattern to its right, called the \texttt{OPTIONAL}-right group graph pattern. It has exactly one child node, which is a group graph pattern node representing the adjacent group graph pattern to its right;
    \item A \underline{\texttt{FILTER} node} represents the \texttt{FILTER} expression and its accompanying built-in condition, and must be a leaf node.
\end{itemize}
\end{definition}
}

% \mynote{I am attempting a recursive definition; pls check it out.}
\begin{definition}[\underline{B}GP-based \underline{E}valuation Tree (BE-tree)] 
\label{def:betree}
Given a group graph pattern $Q$, its corresponding BE-tree $T(Q)$ is recursively defined as follows:
\begin{itemize}
    \item The root of $T(Q)$ is a \underline{group graph pattern node} (Definition \ref{def:grouppattern}) representing the query $Q$;
    \item An internal node of $T(Q)$ can be one of \{\texttt{UNION}, \texttt{OPTIONAL}, group graph pattern\} nodes:
    \begin{itemize}
        \item A \underline{\texttt{UNION} node} represents the \texttt{UNION} expression that links two or more group graph patterns, called \texttt{UNION}'ed group graph patterns. It has two or more child nodes, which are all group graph pattern nodes;
        \item An \underline{\texttt{OPTIONAL} node} represents the \texttt{OPTIONAL} expression that links \texttt{OPTIONAL}-left and \texttt{OPTIONAL}-right graph patterns. It has exactly one child node: the \texttt{OPTIONAL}-right graph pattern, which is a group graph pattern node;
    \end{itemize}
        \item A leaf node of $T(Q)$ is a \texttt{BGP} node (Definition \ref{def:bgp}).
        \nop{\begin{itemize}
            \item A \underline{BGP node} represents a BGP (Definition \ref{def:bgp});
            \item A \underline{\texttt{FILTER} node} represents the \texttt{FILTER} expression and its accompanying built-in condition.
        \end{itemize}}
\end{itemize}
\end{definition}

According to the above definition, each leaf node in a BE-tree corresponds to a BGP, and each internal node corresponds to a group graph pattern, a \texttt{UNION} expression, or an \texttt{OPTIONAL} expression. 
Figure \ref{fig:hrgp} shows the general structure of a BE-tree. The edge labels indicate how many child nodes of this type are permitted to occur: $k$ indicates that exactly $k$ such child nodes must occur, and $k..*$ indicates that $k$ or more such child nodes can occur. For convenience, we call a group of sibling nodes a \emph{level} of nodes. 

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.325]{figure/hrgp-new-nofilter-colored.pdf}
	\vspace{-0.1in}
	\caption{Hierarchical structure of the BE-tree}
	\label{fig:hrgp}
	\vspace{-0.1in}
\end{figure}

It is straightforward to construct a BE-tree from a SPARQL query. Joins between graph patterns are implicitly expressed in the BE-tree as the sibling relation between nodes. Therefore, we first initiate a group graph pattern node as the root, denoting the outermost group graph pattern in the query. Then we put each joined graph pattern within the outermost group graph pattern as the root's children in the original order. For each nested group graph pattern, we consider them in turn as the root of a subtree, and recursively execute the aforementioned process.

Note that such a construction procedure generates triple pattern nodes, which are not identified in Definition \ref{def:betree}. In order to eliminate them, we coalesce sibling triple pattern nodes into \emph{maximal} BGP nodes, in that no further coalescing can be performed (The coalescability of triple patterns and BGPs is defined in Definitions \ref{def:coalesce-triple} and \ref{def:coalesce-bgp}). We place BGP nodes where its constituent leftmost triple pattern originally resides. It is evident that there is a one-to-one mapping between SPARQL queries and BE-trees by this construction process.

As a concrete example, the BE-tree of the query in Figure \ref{fig:sparql}(a) is given below (Figure \ref{fig:betree-example}). Note that the triple patterns $t_1$ and $t_6$ are coalesced to form a BGP node; no other triple patterns cannot be coalesced, and thus form individual BGP nodes on their own.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.35]{figure/betree-example-nofilter-colored.pdf}
	\vspace{-0.1in}
	\caption{An example BE-tree}
	\label{fig:betree-example}
	\vspace{-0.1in}
\end{figure}

\begin{algorithm}\small
	\caption{\small BGP-based query evaluation}
	\label{alg:bgpe}
	\SetKwInOut{KwIn}{Input}
	\KwIn{RDF dataset $D$, BE-tree $T(Q)$}
	\SetKwInOut{KwOut}{Output}
	\KwOut{${\left[\!\left[ {Q} \right]\!\right]_D}$}
	
	\SetKwFunction{FMain}{BGPBasedEvaluation}
	\SetKwFunction{FBGP}{EvaluateBGP}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$D, T(Q)$}}
	{
		$r \leftarrow \emptyset$\;
		Let $root$ be the root of $T(Q)$ \;
		%\While {$i < |GGP.e|$}
		\ForEach{child node $e_i$ of $root$}
		{
			\If {$e_i$ is a group graph pattern node}
			{
				\If {$r = \emptyset$}
				{
					$r \leftarrow \FMain(D, T(e_i))$\;
				}
				\Else
				{
					$r \leftarrow r \ \Join \ \FMain(D, T(e_i))$\;
				}
			}
			\ElseIf {$e_i$ is a BGP node}
			{
				$r \leftarrow r \ \Join \ \FBGP(D, e_i)$\;
			}
			\ElseIf {$e_i$ is a \texttt{UNION} node}
			{
				$u \leftarrow \emptyset$\;
				\ForEach {child group graph pattern node $P$ of $e_i$}
				{
					$u \leftarrow u \ \cup_{bag} \ \FMain(D, T(P))$\;
				}
				$r \leftarrow r \ \Join \ u$\;
			}
			\ElseIf {$e_i$ is an \texttt{OPTIONAL} node}
			{
				Get the child group graph pattern node $P$ of $e_i$\;
				$o \leftarrow \FMain(D, T(P))$\;
				$r \leftarrow r \ {\tiny \textbf{\textifsym{d|><|}}} \ o$\;
			}
		}
		\nop{\ForEach {child node $e_i$ of $root$}
		{
			\If{$e_i$ is a \texttt{FILTER} node}
			{
			    Get the built-in condition $C$ of $e_i$\;
			    $r \leftarrow \{ \mu \ | \ \mu \in r \wedge {\mu(C)} \}$
			}
		}}
		\Return $r$
	}
\end{algorithm}

Algorithm \ref{alg:bgpe} shows the pseudocode of the BGP-based solution for answering SPARQL query $Q$ based on BE-tree $T(Q)$. The basic idea is to rely on the underlying BGP evaluation engine to evaluate each BGP separately, and combine the results afterwards based on the BE-tree. The return variable $r$, which indicates the result set, is first initialized to be empty (Line 2). Then the child nodes of the BE-tree's root are processed (Lines 4-20).

During the iteration across child nodes of the root, the following cases are considered:
\begin{itemize}
    \item If the current child node is a group graph pattern node, it is recursively evaluated by calling the function on the subtree rooted at it, and the retrieved results are joined with $r$ (Lines 5-9).
    \item If the current child node is a BGP node, it is evaluated by some existing BGP query evaluation technique, and the retrieved results are joined with $r$ (Lines 10-11).
    \item If the current child node is a \texttt{UNION} node, each of its child group graph pattern nodes is recursively evaluated, the results of which are merged by the $\cup_{bag}$ operation. The merged result is finally joined with $r$ (Lines 12-16).
    \item If the current child node is an \texttt{OPTIONAL} node, its child group graph pattern node is recursively evaluated, and the retrieved results are left-outer-joined with $r$ (Lines 17-20).
\end{itemize}

\nop{In the second pass, all the \texttt{FILTER} nodes are handled by filtering $r$ by their built-in conditions (Lines 21-24). \texttt{FILTER} expressions cannot be handled in the first pass because the scope of them is the entire group graph pattern.}

\subsection{BE-Tree Transformations}
\label{sec:transformation}

% UNION unfolding is quite trivial, don't discuss here

In the previous subsection, we invoke the BGP-based evaluation procedure (Algorithm \ref{alg:bgpe}) on the BE-tree directly constructed from the query. However, it is possible to improve the efficiency of query evaluation by altering the plan. We achieve this by making certain semantics-preserving \emph{transformations} to the BE-tree.

% However, there are still opportunities for further optimization concerning BGPs associated by \texttt{UNION} and \texttt{OPTIONAL}.

\subsubsection{Goals}
Our aim is to transform the original BE-tree so that the resulting BE-tree has the following properties:

\begin{itemize}
    \item \emph{Validity:} the resulting BE-tree should maintain the previously defined tree structure and have the same node types. It should be one-to-one mapped to a syntactically valid SPARQL query by the direct construction process introduced in Section \ref{sec:bgp}.
    \item \emph{Efficiency:} the evaluation of the resulting BE-tree should be more efficient than the original BE-tree. In other words, the expected cost of evaluating the resulting BE-tree should be lower.
\end{itemize}

\subsubsection{Semantics-Preserving Transformations}

We set out to transform the BE-tree with the two aforementioned goals in mind.
% We may insert or delete nodes, modify the type or associated triple patterns (in the case of BGP nodes) of nodes, or modify the endpoints of edges.
In order to optimize for query execution efficiency while maintaining correctness, we need to leverage the inherent semantic equivalences regarding the \texttt{UNION} and \texttt{OPTIONAL} operators, formally expressed through the following two theorems.
% the appendix of the full version \cite{}

\begin{theorem}
For any graph pattern $P_1$, $P_2$, $P_3$ and any RDF dataset $D$, we have
    {\small \begin{equation}
        [\![P_1 \ \texttt{AND} \ (P_2  \ \texttt{UNION} \ P_3)]\!]_D = [\![(P_1 \ \texttt{AND} \ P_2) \ \texttt{UNION} \ (P_1 \ \texttt{AND} \ P_3)]\!]_D. \nonumber
    \end{equation}}
\label{thm:union_eq}
\end{theorem}


\begin{proof}
By Definition \ref{def:eval} and the definitions of the operators on bags, we have
    {\small \begin{equation}
    \begin{split}
        & [\![P_1 \ \texttt{AND} \ (P_2  \ \texttt{UNION} \ P_3)]\!]_D \\
        = \ & [\![P_1]\!]_D \Join [\![P_2  \ \texttt{UNION} \ P_3]\!]_D \\
        = \ & [\![P_1]\!]_D \Join ([\![P_2]\!]_D \ \cup_{bag} \ [\![P_3]\!]_D) \\
        = \ & ([\![P_1]\!]_D \Join [\![P_2]\!]_D) \cup_{bag} ([\![P_1]\!]_D \Join [\![P_3]\!]_D) \\
        = \ & [\![P_1 \ \texttt{AND} \ P_2]\!]_D \cup_{bag} [\![P_1 \ \texttt{AND} \ P_3]\!]_D \\
        = \ & [\![(P_1 \ \texttt{AND} \ P_2) \ \texttt{UNION} \ (P_1 \ \texttt{AND} \ P_3)]\!]_D. \nonumber
    \end{split}
    \end{equation}}
\end{proof}


Note that Theorem \ref{thm:union_eq} is also trivially extendable to \texttt{UNION} nodes with more than two child nodes.

\begin{theorem}
For any graph pattern $P_1$, $P_2$ and any RDF dataset $D$, we have
    {\small \begin{equation}
        [\![P_1 \ \texttt{OPTIONAL} \ P_2]\!]_D = [\![P_1 \ \texttt{OPTIONAL} \ (P_1 \ \texttt{AND} \ P_2)]\!]_D. \nonumber
    \end{equation}}
\label{thm:optional_eq}
\end{theorem}
These two equivalences correspond to two semantics-preserving transformations on the BE-tree: that of \emph{merging} a node with the child nodes of its sibling \texttt{UNION} node, and that of \emph{injecting} a node into the child node of its sibling \texttt{OPTIONAL} node. We define these transformations as follows.


\begin{proof}
Similarly, we have
    {\small \begin{equation}
    \begin{split}
        & [\![P_1 \ \texttt{OPTIONAL} \ (P_1 \ \texttt{AND} \ P_2)]\!]_D \\
        = \ & ([\![P_1]\!]_D \Join [\![P_1 \ \texttt{AND} \ P_2]\!]_D) \cup_{bag} ([\![P_1]\!]_D \setminus [\![P_1 \ \texttt{AND} \ P_2]\!]_D) \\
        = \ & ([\![P_1]\!]_D \Join ([\![P_1]\!]_D \Join [\![P_2]\!]_D)) \\ 
        & \cup_{bag} ([\![P_1]\!]_D \setminus ([\![P_1]\!]_D \Join [\![P_2]\!]_D)) \\
        = \ & ([\![P_1]\!]_D \Join [\![P_2]\!]_D) \cup_{bag} ([\![P_1]\!]_D \setminus [\![P_2]\!]_D) \\
        = \ & [\![P_1 \ \texttt{OPTIONAL} \ P_2]\!]_D. \nonumber
    \end{split}
    \end{equation}}
\end{proof}




% {\color{blue} ToDo: formally define the two transformation primitives and illustrate them by some running examples.}

\begin{definition}[Merge transformation] 
\label{def:merge}
A \underline{merge} transformation is the action performed on a node, which represents the graph pattern $P_1$, and one of its sibling \texttt{UNION} nodes, the child nodes of which represents the group graph patterns $P_2, P_3, \cdots, P_n$, when both of the following conditions are met:
\begin{enumerate}
    \item $P_1$ is a BGP node;
    \item At least one of the group graph patterns in $P_2, P_3, \cdots, P_n$ is the parent node of a BGP node that is coalescable with $P_1$.
\end{enumerate}

The action consists of the following steps:
\begin{enumerate}
    \item Insert $P_1$ 
    %(or one of its sub-BGPs that is coalescable with some BGP child nodes of $P_2, P_3, \cdots, P_n$)
    as the leftmost child node of $P_2, P_3, \cdots, P_n$;
    \item Coalesce $P_1$ 
    % (or the selected sub-BGP)
    with the other BGP child nodes if possible, until all the BGP nodes are maximal;
    \item Remove $P_1$ from its original position.
    % (or remove the triples in the selected sub-BGP from $P_1$).
\end{enumerate}
\end{definition}

\begin{definition}[Inject transformation] 
\label{def:inject}
An \underline{inject} transformation is the action performed on a node, which represents the graph pattern $P_1$, and one of its sibling \texttt{OPTIONAL} nodes to its right, the child node of which represents the group graph pattern $P_2$, when both of the following conditions are met:
\begin{enumerate}
    \item $P_1$ is a BGP node;
    \item $P_2$ is the parent node of a BGP node that is coalescable with $P_1$.
\end{enumerate}

The action consists of the following steps:
\begin{enumerate}
    \item Insert $P_1$ 
    % (or one of its sub-BGPs that is coalescable with some BGP child nodes of $P_2$)
    as the leftmost child node of $P_2$;
    \item Coalesce $P_1$ 
    % (or the selected sub-BGP)
    with the other BGP child nodes if possible, until all the BGP child nodes are maximal.
\end{enumerate}
\end{definition}

% Note that when considering a transformation, a BGP node is actually not the minimum inseparable unit, since it corresponds to a maximal BGP. We additionally consider sub-BGPs so as to further enrich the plan space and thus introduce more flexibility. Sub-BGPs are formally defined as follows:

\nop{
\begin{definition}[Sub-BGP] 
\label{def:sub-bgp}
A BGP $b'$ formed from one or more triple patterns of the BGP $b$ is called a \underline{sub-BGP} of $b$. Note that each of these triple patterns must be coalescable with one of the others by Definition \ref{def:bgp}.
\end{definition}
}

% Suppose a BGP node consists of $k$ triples, then it has at most $2^k$ sub-BGPs. The overhead incurred by considering $2^k$ possibilities is usually acceptable, since in real queries $k$ is typically small \cite{bonifati2020analytical}.
% TODO: Check this statement

% Having formally introduced sub-BGPs, we note that it is possible for the BGP child nodes of the \texttt{UNION}'ed group graph patterns ($P_2, P_3, \cdots, P_n$) to have common sub-BGPs. According to Theorem \ref{thm:union_eq}, such a common sub-BGP can be \emph{extracted}, exposing more optimization opportunities. Hence, if any of such common sub-BGPs are coalescable with $P_1$, we perform the extraction and coalescing before considering the \emph{merge} transformation.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{figure/example_optional-colored.pdf}
	\vspace{-0.1in}
	\caption{Favorable \emph{Inject} Transformation}
	\label{fig:example_optional}
	\vspace{-0.1in}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{figure/example_union_fail-colored.pdf}
	\vspace{-0.1in}
	\caption{Unfavorable \emph{Merge} Transformation}
	\label{fig:example_union}
	\vspace{-0.1in}
\end{figure}

Figures \ref{fig:example_optional} and \ref{fig:example_union} are examples of these two types of transformations in action. The graph database targeted by the queries in these figures is DBpedia, which is an encyclopedic open-domain knowledge graph containing information about a vast number of real-world entities. Via these examples, we give a qualitative overview of the effects of these transformations on the plan's efficiency.

In Figure \ref{fig:example_optional}, $b_4$ is a grandchild BGP node of the \texttt{OPTIONAL} node to the right of $b_1$, and $b_1$ and $b_4$ are coalescable. Therefore, the available \emph{inject} transformation will coalesce $b_4$ with $b_1$, which can help improve efficiency. According to the original BE-tree, $b_4$ is directly evaluated, and the results are left-outer-joined with those of $b_1$. Since a large number of entities have the \texttt{?sameAs} relation, which denotes the equivalence between references to the same real-world object, $b_4$ has many matches, causing both its evaluation and the left-outer-join to be costly. However, presidents of the United States is a minority of the entities, making $b_1$ highly selective, which the \emph{inject} transformation takes advantage of. After the \emph{inject}, we can rely on the underlying evaluation engine to efficiently evaluate the coalesced $b_1 b_4$ by choosing a join order that evaluates the much more selective $b_1$ first. The left-outer-join is also rendered less expensive due to the decrease in the number of results of $b_1 b_4$ compared with $b_4$.

This example also helps explain the reason why certain conditions need to be met in Definitions \ref{def:merge} and \ref{def:inject}. It is observable that only by coalescing BGPs is it possible to accelerate BGP evaluation. If no coalescing happens, the repetitive evaluation of the merged or injected BGP will instead incur extra overhead.
% As for the cost of performing operations...

However, not all available transformations can help improve efficiency. Figure \ref{fig:example_union} shows an available \emph{merge} transformation on an example \texttt{UNION} query, which merges the BGP $b_1$ with its sibling \texttt{UNION} node. Since $b_1$ has low selectivity, merging it does not accelerate BGP evaluation or reduce the number of intermediate results, and even incurs extra overhead because it now has to be evaluated twice.
%The grandchild BGP nodes of the \texttt{UNION} node, $b_2$ and $b_3$, are coalesced with either $t_{1, 1}$ or $t_{1, 2}$, which is subtracted from $b_1$. From the discussion of Figure \ref{fig:example_optional}, we know that $t_{1, 2}$ ($b_4$ in Figure \ref{fig:example_optional}) has many matches, and therefore low selectivity. Consequently, the first \emph{merge} on $t_{1, 2}$ has no positive effect on efficiency. On the other hand, $t_{1, 1}$ is much more selective than $b_2$ and $b_3$, whose predicates \texttt{foaf:name} and \texttt{rdfs:label} indicate attributes possessed by nearly all the entities. Therefore, the second \emph{merge} renders both the evaluation of the coalesced BGPs and the bag union operation more efficient.

% 0.5~1 column
%In summary, we need to carefully choose the most efficient semantics-preserving transformation for execution. The means to attain this will be introduced in the next section. % We achieve this by designing a \textbf{cost model for BE-trees}.

%\vspace{-0.2in}