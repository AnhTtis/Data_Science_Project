\vspace{-0.1in}
\section{Preliminaries}\label{sec:preliminary}
\vspace{-0.1in}
\Paragraph{RDF Dataset.} Table \ref{tab:rdf} is an example RDF dataset (defined as follows) containing seven triples.

%we use prefixed names instead of IRIs to make the expression more concise.
%An RDF dataset is a collection of triples of the form $\langle$subject, property, object$\rangle$, formally defined as follows:
%\subsection{RDF Dataset}

%The RDF (Resource Description Framework) data model was originally proposed by W3C for modeling Web objects as part of developing the semantic web; its use has  widened over time. An RDF dataset is a collection of triples of the form $\langle$subject, property, object$\rangle$. A triple can naturally be seen as a pair of entities connected by a  named relationship or an entity associated with a named attribute value. Formally, an RDF dataset is defined as follows:



\begin{definition} [RDF dataset] Let pairwise disjoint infinite sets $I$, $B$, and $L$ denote IRI, blank nodes and literals, respectively. An RDF dataset $D$ is a collection of triples $D = \{ t_1, t_2, ..., t_{|D|} \}$, where each triple is a three-tuple  $t = \langle subject,property,object \rangle \in (I \cup B)  \times I \times (I\cup B \cup L)$.
\end{definition} 
\Paragraph{SPARQL Query---Syntax.} Assume that there is an infinite set $V$ representing the variables that appear in the query. All variables differ from IRIs and literals by leading with a question mark (\texttt{?}), so  the set $V$ is disjoint with $I$ and $L$. This work focuses on \texttt{SELECT} queries, which retrieve results by matching the graph pattern in the query with the dataset. We note that SPARQL provides other query forms for updating the database, constructing RDF datasets, asking whether a graph pattern exists in the database and describing resources, etc., that are beyond the scope of our consideration. A \texttt{SELECT} query is of the form ``\texttt{SELECT} ${v_1}$ ${v_2}$ ... ${v_k}$ \texttt{WHERE} \{...\}'', in which the \texttt{SELECT} clause represents the query header, and the \texttt{WHERE} clause represents the query body (Figure \ref{fig:sparql}(a)). The \texttt{SELECT} clause determines the projection variables that need to appear in the query results, and the \texttt{WHERE} clause gives the group graph pattern that needs to be matched over the RDF dataset, which may consists of many other types of graph patterns, defined as follows.
%The subject $s$ belongs to $I$ (i.e., IRI set) representing an entity in the real world. There are two cases for predicate $p$ and object $o$. In the first case, object $o$ also belongs to $I$ and represents another entity, and predicate $p$ belongs to $I$ and represents the relationship between the subject $s$ and object $o$. In the second case, predicate $p$ belongs to $I$ and represents property name, and object $o$ belongs to $L$ (literal set) representing the property value. 

%As a notation, the IRIs are enclosed in angle brackets ($\langle\ldots  \rangle$), and the literals are enclosed in double quotes (``... '') or single quotes (`...'). 

%To sum up, a triple $t$ satisfies $t = (s, p, o) \in I \times I \times (I \cup L)$, and an RDF dataset $D$ can be denoted by $D = \{ t_1, t_2, ..., t_{|D|} \}$, i.e., a set of triples.






%A prefixed name consists of a prefix label and a local part, separated by a colon (:). For example, \texttt{dbr:Bill\_Clinton} is a prefixed name, \texttt{dbr} is a prefix label, and \texttt{Bill\_Clinton} is the local part. Each prefix label corresponds to an IRI, e.g., the prefix label \texttt{dbr} corresponds to the IRI $\langle$http://dbpedia.org/resource/$\rangle$. A prefixed name can be converted to a complete IRI by concatenating the IRI associated with the prefix label and the local part: \texttt{dbr:Bill\_Clinton} can be converted to $\langle$http://dbpedia.org/resource/Bill\_Clinton$\rangle$.
%All the prefix labels used in this paper are listed in the appendix.



\begin{table*}[!htbp]
	\centering
	\caption{An example RDF dataset}
	\scriptsize
	% \tiny
	\begin{tabular}{|c|c|l|}
		\hline
		Subject & Predicate & \multicolumn{1}{c|}{Object} \\ \hline
		\texttt{dbr:George\_W.\_Bush} & \texttt{foaf:name} & ``George Walker Bush"@en \\ \hline
		\texttt{dbr:George\_W.\_Bush} & \texttt{rdfs:label} & ``George W. Bush"@en \\ \hline
		\texttt{dbr:George\_W.\_Bush} & \texttt{dbo:wikiPageWikiLink} & \texttt{dbr:President\_of\_the\_United\_States} \\ \hline
		\texttt{dbr:Bill\_Clinton} & \texttt{foaf:name} & ``Bill Clinton"@en \\ \hline
		\texttt{dbr:Bill\_Clinton} & \texttt{dbo:wikiPageWikiLink} & \texttt{dbr:President\_of\_the\_United\_States} \\ \hline
		\texttt{dbr:Bill\_Clinton} & \texttt{dbp:birthDate} & ``1946-08-19"\textasciicircum \textasciicircum \texttt{xsd:date} \\ \hline
		\texttt{dbr:Bill\_Clinton} & \texttt{owl:sameAs} & \texttt{fbp:Clinton\_William\_Jefferson\_1946-} \\ \hline
	\end{tabular}
	\label{tab:rdf}
\end{table*}


%for the sake of simplicity, these query forms are not considered at this time, we just focus on the most common query form.


%in any given portion.

%A SPARQL query can be represented in the form of  $H \gets B$,  where $H$ is the query header providing the return result form, and $B$ is the query body providing the query graph pattern needed to match.

%SPARQL queries also provide other query forms, including updating triples, constructing triples, asking for existence and describing resources, etc.
%For the sake of simplicity, these query forms are not considered at this time, we just focus on the most common query form.

\begin{definition}[Triple Pattern]\label{def:triple_pattern}
A triple $t \in (V \cup I) \times (V \cup I) \times (V \cup I \cup L)$ is a \emph{triple pattern}.
\end{definition}

Basic graph patterns (BGPs) are composed of triple patterns. To give a formal definition of BGPs, we need to first introduce the notion of \emph{coalescability}.

\begin{definition}[Coalescable triple patterns] 
\label{def:coalesce-triple}
We say that the triple patterns $t_1 = \langle s_1,p_1,o_1 \rangle$ and $t_2 = \langle s_2,p_2,o_2 \rangle$ are \underline{coalescable} if and only if $\{s_1$, $o_1\}$ and $\{s_2$, $o_2\}$ share at least one common variable. 
%at least one of the following conditions are met: 
\end{definition}
\nop{
\begin{itemize}
    \item $s_1$ and $s_2$ are variables, $s_1 = s_2$;
    \item $s_1$ and $o_2$ are variables, $s_1 = o_2$;
    \item $o_1$ and $s_2$ are variables, $o_1 = s_2$;
    \item $o_1$ and $o_2$ are variables, $o_1 = o_2$.
\end{itemize}
}

Intuitively, two triple patterns are coalescable if they have common variables at the subject or object positions. Since a BGP is composed of triple patterns, we can extend coalescability to BGPs, where we require some of their constituent triple patterns to be coalescable.

%For example, the triple patterns $t_1$ and $t_4$ in Figure \ref{fig:sparql} are coalescable, since \texttt{?x} is a common variable at their subject positions. 

\begin{definition}[Coalescable BGPs] 
\label{def:coalesce-bgp}
We say that the BGPs $b_1$ and $b_2$ are \underline{coalescable} if there exist $t_{i_1} \in b_1$ and $t_{i_2} \in b_2$ such that $t_1$ and $t_2$ are coalescable triple patterns.
\end{definition}

%BGPs can thus be formally defined via coalescability.

\begin{definition}[Basic Graph Pattern (BGP)]\label{def:bgp}
A BGP is recursively defined as follows:
\begin{enumerate}
\item  A triple pattern $t$ is a BGP;
\item if $P_1$ and $P_2$ are coalescable BGPs, $P_1$ \texttt{AND} $P_2$ is also a BGP.
\end{enumerate}
\end{definition}

\begin{definition}[Graph Pattern, Group Graph Pattern] \label{def:grouppattern}

A \underline{graph pattern} is recursively defined as follows:
\begin{enumerate}
	\item if $P$ is a BGP, $P$ is a graph pattern;
	\item if $P$ is a group graph pattern (defined below), $P$ is a graph pattern;
	\item if $P_1$ and $P_2$ are both graph patterns, $P_1$ \texttt{AND} $P_2$ is also a graph pattern;
            \item if $P_1$ and $P_2$ are both graph patterns,  $\{P_1 \}$ \texttt{UNION} $\{P_2\}$, $P_1$ \texttt{OPTIONAL}
$\{P_2\}$ are both graph patterns. Note that $\{P_i\}$ denotes a \textit{group graph pattern} (defined below);
%	\item if $P$ is a graph pattern and $C$ is a SPARQL built-in condition (constructed using elements of $I \cup L \cup V$ and constants, including logical operators ($\neg$, $\wedge$, $\vee$), comparison operators ($<$, $\leq$, $>$, $\geq$, $=$), unary functions (bound, isBlank, isIRI), and other features), $P \ \texttt{FILTER} \ C$ is a graph pattern.
\end{enumerate}

A \emph{group graph pattern} $P$ is recursively defined as follows:
\begin{enumerate}
            \item If $P$ is a graph pattern, $\{P\}$ is a group graph pattern.
\end{enumerate}
\end{definition}

Figure \ref{fig:sparql} is an example SPARQL query with six triple patterns (${t_{1..6}}$) and \texttt{UNION} and \texttt{OPTIONAL} operators.

%and \texttt{FILTER} clauses.

\begin{figure}
	\centering
	\includegraphics[scale=0.55]{figure/sparql.pdf}
	\vspace{-0.1in}
	\caption{(a) An example SPARQL query and (b) Binary Tree Expression}
	\label{fig:sparql}
	\vspace{-0.1in}
\end{figure}

\nop{
\begin{figure}
	\centering
	\includegraphics[scale=0.6]{figure/semexpt.pdf}
	\vspace{-0.1in}
	\caption{Binary tree expression of Graph Pattern}
	\label{fig:semexpt}
	\vspace{-0.1in}
\end{figure}
}
\Paragraph{SPARQL Query---Semantics.} The semantics of any graph pattern can be uniquely determined, since the \texttt{OPTIONAL} clause is left-associative and the priority of operators is defined as $\{\}$ $\prec$ \texttt{UNION} $\prec$ \texttt{AND} $\prec$ \texttt{OPTIONAL}.

%$\prec$ %\texttt{FILTER}.

%the scope of \texttt{FILTER} is the entire group pattern that it belongs to, 

A graph pattern can then be converted to an expression containing triple patterns, built-in conditions, and binary operators \texttt{AND}, \texttt{UNION} and \texttt{OPTIONAL}, which accept two graph patterns as their operands. Such an expression can be equivalently represented by a binary tree, where each leaf node represents a triple pattern and each internal node represents a binary operator. Figure \ref{fig:sparql}(b) shows such a binary tree expression of the outermost group graph pattern of the query in Figure \ref{fig:sparql}(a).

A graph pattern $P$ is matched on an RDF dataset $D$ (denoted by $[\![P]\!]_D$) to produce a bag (i.e., multi-set) of mappings $\{{\mu_1}, {\mu_2}, \ ... \ , \ {\mu_n}\}$, which may contain duplicate mappings. A mapping $\mu : V \mapsto U$ is a partial function from $V$ to $(I \cup L)$, where $V$ represents the variables that appear in the query, and $I$ and $L$ denote the sets of IRI and literals, respectively. The set of variables appearing in mapping $\mu$ is denoted by $dom(\mu)$. The two mappings ${\mu_1}$ and ${\mu_2}$ are defined to be \emph{compatible} (denoted by ${\mu_1} \sim {\mu_2}$) if and only if for all variables $v \in dom({\mu_1}) \ \cap \ dom({\mu_2})$ satisfying ${\mu_1}(v) = {\mu_2}(v)$. Intuitively, this means that the common variables of ${\mu_1}$ and ${\mu_2}$ are mapped to the same values. In the case where ${\mu_1}$ and ${\mu_2}$ are compatible, ${\mu_1} \cup {\mu_2}$ is also a mapping. If the two mappings ${\mu_1}$ and ${\mu_2}$ are \emph{incompatible}, we denote the case as ${\mu_1} \nsim {\mu_2}$.

We denote two bags of mappings by ${\Omega_1}$ and ${\Omega_2}$, and define several operators on bags as follows:
\begin{enumerate}
	\item ${\Omega_1} \Join {\Omega_2} = \{ {\mu_1} \cup {\mu_2} \ | \ {\mu_1} \in {\Omega_1} \wedge {\mu_2} \in {\Omega_2} \wedge {\mu_1} \sim {\mu_2} \}$.
	\item ${\Omega_1} \cup_{bag} {\Omega_2} =  \{ {\mu_1} \ | \ {\mu_1} \in {\Omega_1} \} \bigcup_{bag} \{ {\mu_2} \ | \ {\mu_2} \in {\Omega_2} \}$.
	\item ${\Omega_1} \setminus {\Omega_2} = \{{\mu_1} \in {\Omega_1}\ | \ \forall {\mu_2} \in {\Omega_2} \ : \ {\mu_1} \nsim {\mu_2} \}$.
	\item ${\Omega_1} \ {\tiny \textbf{\textifsym{d|><|}}} \ {\Omega_2} = ({\Omega_1} \Join {\Omega_1}) \bigcup_{bag} ({\Omega_1} \setminus {\Omega_1})$
\end{enumerate}

Note that the operators above all preserve duplicate elements, as they follow the bag semantics.

\begin{definition} [Evaluation of Graph Patterns on an RDF dataset]\label{def:eval}
The evaluation of graph patterns $P$ on an RDF dataset $D$ (denoted by $[\![P]\!]_D$) is recursively defined as follows:
\begin{enumerate}
	\item If $P$ is a triple pattern $t$, $[\![P]\!]_D = \{ \mu \ | \ var(t)=dom(\mu) \ \wedge \ \mu(t) \in D \}$ ($var(t)$ represents all variables occurring in $t$, and $\mu(t)$ mean that all variables appearing in $t$ are replaced by $\mu$).
	\item If $P = \{P_1\}$, $[\![P]\!]_D = [\![P_1]\!]_D$.
	\item If $P = (P_1 \ \texttt{AND} \ P_2)$, $[\![P]\!]_D = [\![P_1]\!]_D \Join [\![P_2]\!]_D$.
	\item If $P = (P_1 \ \texttt{UNION} \ P_2)$, $[\![P]\!]_D = [\![P_1]\!]_D \bigcup_{bag} [\![P_2]\!]_D$.
	\item If $P = (P_1 \ \texttt{OPTIONAL} \ P_2)$, $[\![P]\!]_D = [\![P_1]\!]_D \ {\tiny \textbf{\textifsym{d|><|}}} \ [\![P_2]\!]_D$. We say that ${P_1}$ is a \texttt{OPTIONAL}-left graph pattern, and ${P_2}$ is a \texttt{OPTIONAL}-right graph pattern.
%	\item If $P = (P_1 \ \texttt{FILTER} \ C)$, $[\![P]\!]_D = \{ \mu \ | \ \mu \in [\![P_1]\!]_D \wedge {\mu(C)} \}$ (If all the variables appearing in $C$ are replaced by $\mu$ (denoted by $\mu(C)$), the value of $\mu(C)$ is \texttt{True}).
\end{enumerate}
\end{definition}

