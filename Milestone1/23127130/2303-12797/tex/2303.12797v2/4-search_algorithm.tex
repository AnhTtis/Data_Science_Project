\section{Search algorithm} \label{part 4}

The search space from DRAGON $\Omega = (\mathcal{A} \times \{\Lambda(\alpha), \alpha \in \mathcal{A}\})$ defined in the previous section is a mixed and variable space: it may contain integers, float, and categorical values, and the dimension of its elements, the DNNs, is not fixed. We need to design a search algorithm able to efficiently navigate through this search space. While several metaheuristics can solve mixed and variable-size optimization problems \citep{talbi2023}, we chose to start with an evolutionary algorithm. This metaheuristic was the most intuitive for us to  manipulate directed acyclic graphs. It has been used to optimize graphs in other fields, for example on logic circuits \citep{aguirre2003evolutionary}. In Section~\ref{part5} we compare our model to other simple metaheuristics: the Random Search and the Simulated Annealing, but the design of more complex metaheuristics using our search space and their comparison with the evolutionary algorithm are left to future work.

%******************************************
\subsection{Evolutionary algorithm design} \label{part: search algo}
%******************************************

Evolutionary algorithms represent popular metaheuristics which are well adapted to solve mixed and variable-space optimization algorithms \citep{talbi2023}. They have been widely used for the automatic design of DNNs \citep{li2022survey}. The idea is to evolve a randomly generated population of DAGs to converge towards an optimal DNN. An optimal solution for a time series forecasting task is defined as a DNN minimizing a forecasting error. As training a DNN is expensive in time and computational resources, we implemented an asynchronous version, also called steady-state, of the evolutionary algorithm. This version is more efficient on High-Performance Computing (HPC) systems as detailed by \citet{liu2018hierarchical}. At the beginning of the algorithm, a set of $K$ random DNNs is generated. Each solution is train on $\mathcal{D}_{train}$ and evaluate on $\mathcal{D}_{valid}$ to create a population of size $K$. Then, for a certain number of iterations or a fixed time budget $B$, once a processus is free, a selection operator selects two solutions from the population. Those solutions are modified using crossover and mutation operators to create two offsprings. Those are trained and evaluated by the free process. Then, for each offspring, if its loss $\ell$ is less than the worst loss from the population, the offspring replaces the worst individual. Using an asynchronous version instead of the classical one avoids waiting for a whole generation to be evaluated and saves some time. The complete flowchart is shown in Figure \ref{fig:ga_framework}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[auto, thick]
         \draw
            node [input] (init) {}
            node [in_out, minimum height = 1cm, minimum width=4.5cm, below of=init, fill=output_red!10] (crit) {Is the final criterium $B$ reached?}
            node [in_out, minimum height = 1cm, minimum width=4.5cm, below =1cm of crit, fill=output_red!20] (select) {Tournament selection}
            node [in_out, minimum height = 1cm, minimum width=4.5cm, below =0.4cm of select, fill=input_purple!60] (repro) {Reproduction:\\crossover and mutation}
            node [in_out, minimum height = 1cm, minimum width=4.5cm, below =0.4cm of repro, fill=output_red!30] (replacement) {Offsprings evaluation}
            node [in_out, minimum height = 1cm, minimum width=4.5cm, below =0.4cm of replacement, fill=output_red!40] (end) {Replacement}
            node[input, right =1.5cm of crit] (out){};
            
            
        \draw[->](init) node[above] {\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}} $\rightarrow$ Create and initialize a population of size $K$} -- (crit);
        \draw[->](crit) -- node[left]{No} (select);
        \draw[->](select) -- (repro);
        \draw[->](repro) -- (replacement);
        \draw[->](replacement) -- (end);
        \draw[->] (crit.east) -- node[below] {Yes} (out) node[right] {Best model};
        \draw[->] (end.west) -| (crit.191);
    \end{tikzpicture}
    \caption{Evolutionary algorithm flowchart.}
    \label{fig:ga_framework}
\end{figure}

DRAGON's search space defined Section~\ref{part 3} is not directly efficient with common mutation and crossover operators. Therefore, we had to define evolution operators specific for our search space. Those operators can be used with various metaheuristics: a mutation operator for example can be used as a neighborhood operator for a local search. We split the operators into two categories: hyperparameters specific operators and architecture operators. The idea is to allow a sequential or joint optimization of the hyperparameters and the architecture. All the candidate operations which can be used in the the graphs nodes do not share the same hyperparameters. Thus, drawing a new layer means modifying all its parameters and one can lose the optimization made on the hyperparameters of the previous operation. Using sequential optimization, the algorithm can first find well-performing architectures and operations during the architecture search and then fine-tune the found DNNs during the hyperparameters search.


%************************************
\subsection{Architecture evolution}
%************************************

 In this section, we introduce the architecture-specific search operators from DRAGON. By architecture, we mean the search space $\mathcal{A}$ defined above: the nodes' operation and the edges between them. 
 
 \paragraph{Mutation.}The mutation operators are simple modifications inspired by the Graph Edit Distance \citep{abu2015exact}: insertion, deletion and substitution of both nodes and edges. Given a graph $\Gamma = (\mathcal{L}, M)$, the mutation operator will draw the set $\mathcal{L}' \subseteq \mathcal{L}$ and apply a transformation to each node of $\mathcal{L}'$. Let's have $v_i \in \mathcal{L}'$ the node that will be transformed:
\begin{itemize}
\item \textbf{Node insertion:} we draw a new node with its combiner, operation and activation function. We insert the new node in our graph at the position $i + 1$. We draw its incoming and outgoing edges by verifying that we do not generate an isolated node.
\item \textbf{Node deletion:} we delete the node $v_i$. In the case where it generates other isolated nodes, we draw new edges.
\item \textbf{Parents modification:} we modify the incoming edges for $v_i$ and make sure we always have at least one.
\item \textbf{Children modification:} we modify the outgoing edges for $v_i$ and make sure we always have at least one.
\item \textbf{Node modification:} we draw the new content of $v_i$, the new combiner, the operation and/or the activation function.
\end{itemize}
%
Thanks to these mutation operators, we make our search space connected, as explained in Section~\ref{part 2}. In fact, by successively using these operations, we can move from any graph to any other, since the Graph Edit Distance can be used with any pair of graphs.

\paragraph{Crossover.} The second architecture-specific operator we implemented is the crossover. The idea is to inherit patterns from two parents to create two offsprings. The original crossover is applied to two vectors. It exchanges two parts of these vectors. In our case, the individuals are graphs. Let's say we have two parents $\Gamma_1$ and $\Gamma_2$. The first step is to randomly select one subgraph from each parent, $\gamma_1 \subset \Gamma_1$ and $\gamma_2 \subset \Gamma_2$ to exchange (see figure \ref{fig:crossover_1}). Next the two offspring $\Gamma_1'$ and $\Gamma_2'$ are generated from $\Gamma_1$ and $\Gamma_2$ by removing $\gamma_1$ and $\gamma_2$, as shown in figure \ref{fig:crossover_2}. Next, we need to define the position at which each of the subgraphs will be inserted into the host graph. The idea is to preserve the overall structure of the graph. In other words, if the subgraph was at the beginning of the parent graph, it should also be at the beginning of the child graph, and vice versa. 
We denote here, for a node $v \in \Gamma$, $p(v, \Gamma)$ its position in the graph $\Gamma$, and $P(\Gamma) = \{p(v, \Gamma), v \in \Gamma\}$ the set of all nodes positions in $\Gamma$. We compute the future positions of each node $v \in \gamma_1$ in $\Gamma_2'$ sequentially, starting with the first node, $v_1 \in \argmin_{v \in \gamma_1} p(v, \gamma_1)$. The position $p(v_1, \Gamma_2')$ of $v_1$ in the graph $\Gamma_2'$ can be computed as:
\begin{align*}
    p(v_1, \Gamma_2') \in \underset{p \in P(\Gamma_2')}\argmin(|p - p(v_1, \Gamma_1)|)
\end{align*}
The positions from the following nodes $\{v_2, ..., v_g\} \in \gamma_1$ are computed to respect the structure of $\Gamma_1$ and $\gamma_1$:

\begin{align*}
    p{(v_i, \Gamma_2')} = \min\big(p{(v_i, \Gamma_1)} - p{(v_{i-1}, \Gamma_1)} + p{(v_{i-1}, \Gamma_2')}, |\Gamma_2'| + |\gamma_1|\big)
\end{align*}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {1}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [num_circle, dotted, left=0.3cm of a2, fill=input_purple!70] (a1) {$a_1$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Parent 1: $\Gamma_1$}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
             node [a_dia, dotted, below=0.2cm of in2, fill=output_red!70] (b3) {$b_3$}
             node [a_dia, left=0.2cm of b3] (b1) {$b_1$}
             node [a_dia, right=0.2cm of b3] (b4) {$b_4$}
             node [a_dia, dotted, right = 0.7cm of in2.north, fill=output_red!70] (b2) {$b_2$}
             node [in_out, below=0.2cm of b3, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Parent 2: $\Gamma_2$};
             \draw[->] (in1.west) to [out=180,in=90] (a1);
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a1) to [out=270,in=160] (ou1.west);
             \draw[->] (a1) -- (a2);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b3) -- (ou2);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
            \draw[->] (in2.north) to [out=90, in=180] (b2.north west);
            \draw[->] (b2) -- (b4);
            \draw[->] (b2.south) to [out=240, in=60] (b3.north east);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 1.5) grid (7, -1);
            \foreach \y in {1,...,5}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 1.5) rectangle (7, -1);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (5, 1.5) rectangle (5.5, -0.5);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (4.5, 1) rectangle (6.5, 0.5);
            \node at (5.25, 1.25) {1};
            \node at (5.25, 0.75) {0};
            \node at (5.25, 0.25) {0};
            \node at (5.25, -0.25) {0};
            \node at (4.75, 0.75) {0};
            \node at (5.75, 0.75) {1};
            \node at (6.25, 0.75) {0};
            \node at (6.75, 0.75) {1};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {1};
            \node at (6.75, 1.25) {0};
            \node at (6.25, 0.25) {1};
            \node at (6.75, 0.25) {1};
            \node at (6.75, -0.25) {1};
    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 2) grid (15.5, -1);
            \foreach \y in {1,...,6}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 2.25-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 2) rectangle (15.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13.5, 1.5) rectangle (14, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (14, 1.5) rectangle (14.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13, 1) rectangle (15.5, 0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13, 0.5) rectangle (15.5, 0);
            \node at (13.25, 1.75) {1};
            \node at (13.75, 1.75) {1};
            \node at (14.25, 1.75) {0};
            \node at (14.75, 1.75) {0};
            \node at (15.25, 1.75) {0};
            \node at (13.75, 1.25) {0};
            \node at (14.25, 1.25) {0};
            \node at (14.75, 1.25) {0};
            \node at (15.25, 1.25) {1};
            \node at (13.25, 0.75) {0};
            \node at (13.75, 0.75) {0};
            \node at (14.25, 0.75) {1};
            \node at (14.75, 0.75) {1};
            \node at (15.25, 0.75) {0};
            \node at (13.25, 0.25) {0};
            \node at (13.75, 0.25) {0};
            \node at (14.25, 0.25) {0};
            \node at (14.75, 0.25) {0};
            \node at (15.25, 0.25) {1};
            \node at (13.75, -0.25) {0};
            \node at (14.25, -0.25) {0};
            \node at (15.25, -0.25) {1};
            \node at (13.75, -0.75) {0};
            \node at (14.25, -0.75) {0};
            
        \end{tikzpicture}

    \subcaption{\centering 1st step: we select the two subgraphs $\gamma_1 \subset \Gamma_1$ and $\gamma_2 \subset \Gamma_2$ that would be exchanged. They are highlighted with dotted lines and darker colors.}
    \label{fig:crossover_1}
    \end{subfigure}
     \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {2}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Offspring 1: $\Gamma_1'$}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
             node [a_dia, dotted, below=0.2cm of in2, white] (b3) {b3}
             node [a_dia, left=0.2cm of b3] (b1) {$b_1$}
             node [a_dia, right=0.2cm of b3] (b4) {$b_4$}
             node [in_out, below=0.2cm of b3, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Offspring 2: $\Gamma_2'$};
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 1.5) grid (6.5, -0.5);
            \foreach \y in {1,...,4}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 1.5) rectangle (6.5, -0.5);
            \node at (5.25, 1.25) {1};
            \node at (5.75, 0.75) {1};
            \node at (6.25, 0.75) {1};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {0};
            \node at (6.25, 0.25) {1};
    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 1.5) grid (14.5, -0.5);
            \foreach \y in {1,...,4}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box,box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 1.5) rectangle (14.5, -0.5);
            \node at (13.25, 1.25) {1};
            \node at (13.75, 1.25) {0};
            \node at (14.25, 1.25) {0};
            \node at (13.75, 0.75) {0};
            \node at (14.25, 0.75) {1};
            \node at (14.25, 0.25) {1};
            
        \end{tikzpicture}
    \subcaption{\centering 2nd step: create the two offsprings $\Gamma_1'$ and $\Gamma_2'$ from $\Gamma_1$ and $\Gamma_2$ by removing $\gamma_1$ and $\gamma_2$.}
    \label{fig:crossover_2}

    \end{subfigure}
     \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {3}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [a_dia, dotted, left = 0.7cm of in1.north, fill=output_red!70] (b2) {$b_2$}
             node [a_dia, dotted, left=0.35cm of a2, fill=output_red!70] (b3) {$b_3$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Offspring 1: $\Gamma_1'$}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
            node [num_circle, dotted, below=0.3cm of in2, fill=input_purple!70] (a1) {$a_1$}
             node [a_dia, left=0.3cm of a1] (b1) {$b_1$}
             node [a_dia, right=0.3cm of a1] (b4) {$b_4$}
             node [in_out, below=0.3cm of a1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Offspring 2: $\Gamma_2'$};
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
             \draw[->, dotted] (in1.north) to [out=90, in=0] (b2.north east);
             \draw[->, dotted] (b2) -- (b3);
             \draw[->, dotted] (b2.south) to [out=300, in=160] (a2.north west);
             \draw[->, dotted] (b3.south east) to [out=330, in=210] (a3.south west);

    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
            \draw[->, dotted] (b1) -- (a1);
            \draw[->, dotted] (a1) -- (b4);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 2) grid (7.5, -1);
            \foreach \y in {1,...,6}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 2.25-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 2) rectangle (7.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (5, 2) rectangle (5.5, -0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (5.5, 2) rectangle (6, -0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (4.5, 1.5) rectangle (7, 1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (4.5, 1) rectangle (7, 0.5);
            \node at (5.25, 1.75) {\textbf{\textcolor{white}{1}}};
            \node at (5.75, 1.75) {0};
            \node at (6.25, 1.75) {1};
            \node at (6.75, 1.75) {1};
            \node at (7.25, 1.75) {0};

            \node at (5.25, 1.25) {0};
            \node at (5.25, 0.75) {0};
            \node at (5.25, 0.25) {0};
            \node at (5.25, -0.25) {0};
            \node at (4.75, 0.75) {0};
            \node at (5.75, 0.75) {0};
            \node at (6.25, 0.75) {0};
            \node at (6.75, 0.75) {1};
            \node at (7.25, 0.75) {\textbf{\textcolor{output_red!70}{0}}};
            \node at (7.25, 1.25) {\textbf{\textcolor{output_red!70}{0}}};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {1};
            \node at (6.75, 1.25) {0};
            \node at (6.75, 0.25) {1};
            \node at (7.25, 0.25) {1};
            \node at (7.25, -0.25) {1};
            \node at (5.75, 0.25) {0};
            \node at (5.75, -0.25) {0};
            \node at (4.75, 1.25) {0};
            \node at (8.2, 1.5) {\large{\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}}};
            \draw[->, color=output_red!70] (8.1, 1.4) to [out=270,in=0] (7.5, 1.25);
            \draw[->, color=output_red!70] (8.1, 1.4) to [out=270,in=0] (7.5, 0.75);


    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 1.5) grid (15, -1);
            \foreach \y in {1,...,5}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 1.5) rectangle (15, -1);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (13.5, 1) rectangle (14, -1);
            \draw[dotted, line width=0.3mm,  fill=input_purple!70] (13, 0.5) rectangle (15, 0);
            \node at (13.25, 1.25) {1};
            \node at (13.75, 1.25) {\textcolor{input_purple!70}{\textbf{0}}};
            \node at (14.25, 1.25) {0};
            \node at (14.75, 1.25) {0};
            \node at (13.75, 0.75) {1};
            \node at (14.25, 0.75) {0};
            \node at (14.75, 0.75) {1};
            \node at (13.25, 0.25) {0};
            \node at (13.75, 0.25) {0};
            \node at (14.25, 0.25) {1};
            \node at (14.75, 0.25) {0};
            \node at (13.75, -0.25) {0};
            \node at (14.75, -0.25) {1};
            \node at (13.75, -0.75) {0};
            \node at (14.5, 2) {\large{\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}}};
            \draw[->, color=input_purple!70] (14, 2) to [out=180,in=90] (13.75, 1.5);
        \end{tikzpicture}
    \subcaption{\centering 3rd step: we insert the nodes from $\gamma_1$ in $\Gamma_2'$ and the nodes from $\gamma_2$ in $\Gamma_1'$ and reconstruct the edges.}
    \label{fig:crossover_3}

    \end{subfigure}
\caption{Crossover operator illustration.}
\label{fig:crossover}
\end{figure}

Finally, as shown Figure \ref{fig:cell_gen_representation}, the rows and columns corresponding to the nodes from $\gamma_1$ and $\gamma_2$ are inserted in the adjacency matrices of $\Gamma_2'$ and $\Gamma_1'$ at the previously computed positions. If the process has generated orphan nodes, we randomly generate the necessary connections.

%******************************************
\subsection{Hyperparameters evolution}
%******************************************

One of the architecture mutations consists in disturbing the node content. In this case, the node content is modified, including the operation. A new set of hyperparameters is then drawn. To refine this search, we defined specific mutations for the search space $\Lambda(\alpha)$. In the hyperparameters case, edges and nodes number are not affected. As for architecture-specific mutation, the operator will draw the set $\mathcal{L}' \subseteq \mathcal{L}$ and apply a transformation on each node of $\mathcal{L}'$. For each node $v_i$ from $\mathcal{L}'$, we draw $h_i$ hyperparameters, which will be modified by a neighbouring value. The hyperparameters in our search space belong to three categories:

\begin{itemize}
    \item \textbf{Categorical values:} the new value is randomly drawn among the set of possibilities deprived of the actual value. For instance, the activation functions, combiners, and recurrence types (LSTM/GRU) belong to this type of categorical variable.
    \item \textbf{Integers:} we select the neighbours inside a discrete interval around the actual value. For instance, it has been applied to convolution kernel size and output dimension.
    \item \textbf{Float:} we select the neighbours inside a continuous interval around the actual value. Such a neighbourhood has been defined for instance to the dropout rate.
\end{itemize}
