\section{Search algorithm} \label{part 4}

The search space $\Omega = (\mathcal{A} \times \{\Lambda(\alpha), \alpha \in \mathcal{A}\})$ that we defined in the previous Section is a mixed and variable space: it contains integers, float, and categorical values, and the dimension of its elements, the DNNs, is not fixed. We need to design a search algorithm able to efficiently navigate through this search space. While several metaheuristics can solve mixed and variable-size optimization problems \citep{talbi2023}, we chose to start with an evolutionary algorithm. For the manipulation of directed acyclic graphs, this metaheuristic was the most intuitive for us. It has been used in other domains, for example on graphs representing logic circuits \citep{aguirre2003evolutionary}. The design of other metaheuristics in our search space and their comparison with the evolutionary algorithm are left to future work.

%******************************************
\subsection{Evolutionary algorithm design} \label{part: search algo}
%******************************************

Evolutionary algorithms represent popular metaheuristics which are well adapted to solve mixed and variable-space optimization algorithms \citep{talbi2023}. They have been widely used for the automatic design of DNNs \citep{li2022survey}. The idea is to evolve a randomly generated population of DAGs to converge towards an optimal DNN. An optimal solution should be a DNN with a small error on our forecasting task. The designed metaheuristic is based on several search operators: selection, mutation, crossover and replacement. The initial population is randomly generated. We then evolve this population during $G$ generations. At the beginning of each new generation $g$, we build the new population starting from the scores obtained by the individuals from the previous generation. We use the tournament selection to pick the best individual among randomly drawn sub-groups. Part of the individuals from this new population comes from the tournament selection, while we randomly draw the remaining ones. The randomly drawn individuals ensure the algorithm to not be dependent on the initial population. Afterwards, the DAGs composing the new population are transformed using variation operators such as crossover and mutation, described thereafter. The generated individuals are called offsprings. After their evaluation, the worst offsprings are replaced by the best individuals from the previous generation. Therefore, the best individuals are kept in memory and used for evolution during the entire process. The replacement rate should stay small to prevent a premature convergence of the algorithm toward a local optimum. The complete framework is shown in Figure \ref{fig:ga_framework}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[auto, thick]
         \draw
            node [input] (init) {}
            node [in_out, minimum height = 1cm, minimum width=4cm, below of=init, fill=output_red!10] (eval) {Training and evaluation\\of each model}
            node [in_out, minimum height = 1cm, minimum width=4cm, below =0.4cm of eval, fill=output_red!20] (select) {Tournament selection\\Random \raisebox{0.5ex}{\epsdice{3}} \raisebox{-0.5ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}}
            node [in_out, minimum height = 1cm, minimum width=4cm, below =0.4cm of select, fill=input_purple!60] (repro) {Reproduction:\\crossover and mutation}
            node [in_out, minimum height = 1cm, minimum width=4cm, below =0.4cm of repro, fill=output_red!30] (replacement) {Replacement}
            node [in_out, minimum height = 1cm, minimum width=4cm, below =0.4cm of replacement, fill=output_red!40] (end) {Iteration number $< G$?}
            node[input, right =1cm of end] (out){};
            
            
        \draw[->](init) node[above] {\Large{\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}} $\rightarrow$ Random population initialization} -- (eval);
        \draw[->](eval) -- (select);
        \draw[->](select) -- (repro);
        \draw[->](repro) -- (replacement);
        \draw[->](replacement) -- (end);
        \draw[-](end.west) node[below left]{Yes} -| (-2.5, -5);
        \draw[->] (-2.5, -5) |- (eval.west);
        \draw[->] (end) -- node[below] {No} (out) node[right] {Best model};

    \end{tikzpicture}
    \caption{Evolutionary algorithm framework.}
    \label{fig:ga_framework}
\end{figure}

To design the algorithm evolution operators, we split them into two categories: hyperparameters specific operators and architecture operators. The idea is to allow a sequential or joint optimization of the hyperparameters and the architecture. The involved layer types do not have the same hyperparameters. Thus, drawing a new layer means modifying all its parameters and one can lose the optimization made on the previous layer type. Using sequential optimization, the algorithm can first find well-performing architectures and layers types during the architecture search and then fine-tune the found DNNs during the hyperparameters search.


%************************************
\subsection{Architecture evolution}
%************************************

In this section, we introduce the architecture-specific search operators. By architecture, we mean the search space $\mathcal{A}$ defined above: the node's operations and the edges between them. The mutation operator is made of several simple operations inspired by the transformations used to compute the Graph Edit Distance \citep{abu2015exact}: insertion, deletion and substitution of both nodes and edges. Given a graph $\Gamma = (\mathcal{L}, M)$, the mutation operator will draw the set $\mathcal{L}' \subseteq \mathcal{L}$ and apply a transformation to each node of $\mathcal{L}'$. Let's have $v_i \in \mathcal{L}'$ the node that will be transformed:

\begin{itemize}
\item \textbf{Node insertion:} we draw a new node with its combiner, operation and activation function. We insert the new node in our graph at the position $i + 1$. We draw its incoming and outgoing edges by verifying that we do not generate an isolated node.
\item \textbf{Node deletion:} we delete the node $v_i$. In the case where it generates other isolated nodes, we draw new edges.
\item \textbf{Parents modification:} we modify the incoming edges for $v_i$ and make sure we always have at least one.
\item \textbf{Children modification:} we modify the outgoing edges for $v_i$ and make sure we always have at least one.
\item \textbf{Node modification:} we draw the new content of $v_i$, the new combiner, the operation and/or the activation function.
\end{itemize}

The crossover idea is to inherit patterns belonging to both parents. The primary crossover operator applies on two arrays and swaps two subparts of those arrays. We draw two subgraphs from our parents, which can be of different sizes, and we swap them. This transformation has an impact on edges. To reconstruct the offsprings, we tried to preserve at most the original edges from the parents and the swapped subgraphs. An illustration of the crossover can be found in Figure \ref{fig:crossover}.

\begin{figure}[htbp]
    \centering
    \caption{Crossover operator illustration.}
    \label{fig:crossover}

    \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {1}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [num_circle, dotted, left=0.3cm of a2, fill=input_purple!70] (a1) {$a_1$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Parent 1}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
             node [a_dia, dotted, below=0.2cm of in2, fill=output_red!70] (b3) {$b_3$}
             node [a_dia, left=0.2cm of b3] (b1) {$b_1$}
             node [a_dia, right=0.2cm of b3] (b4) {$b_4$}
             node [a_dia, dotted, right = 0.7cm of in2.north, fill=output_red!70] (b2) {$b_2$}
             node [in_out, below=0.2cm of b3, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Parent 2};
             \draw[->] (in1.west) to [out=180,in=90] (a1);
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a1) to [out=270,in=160] (ou1.west);
             \draw[->] (a1) -- (a2);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b3) -- (ou2);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
            \draw[->] (in2.north) to [out=90, in=180] (b2.north west);
            \draw[->] (b2) -- (b4);
            \draw[->] (b2.south) to [out=240, in=60] (b3.north east);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 1.5) grid (7, -1);
            \foreach \y in {1,...,5}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 1.5) rectangle (7, -1);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (5, 1.5) rectangle (5.5, -0.5);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (4.5, 1) rectangle (6.5, 0.5);
            \node at (5.25, 1.25) {1};
            \node at (5.25, 0.75) {0};
            \node at (5.25, 0.25) {0};
            \node at (5.25, -0.25) {0};
            \node at (4.75, 0.75) {0};
            \node at (5.75, 0.75) {1};
            \node at (6.25, 0.75) {0};
            \node at (6.75, 0.75) {1};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {1};
            \node at (6.75, 1.25) {0};
            \node at (6.25, 0.25) {1};
            \node at (6.75, 0.25) {1};
            \node at (6.75, -0.25) {1};
    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 2) grid (15.5, -1);
            \foreach \y in {1,...,6}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 2.25-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 2) rectangle (15.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13.5, 1.5) rectangle (14, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (14, 1.5) rectangle (14.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13, 1) rectangle (15.5, 0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (13, 0.5) rectangle (15.5, 0);
            \node at (13.25, 1.75) {1};
            \node at (13.75, 1.75) {1};
            \node at (14.25, 1.75) {0};
            \node at (14.75, 1.75) {0};
            \node at (15.25, 1.75) {0};
            \node at (13.75, 1.25) {0};
            \node at (14.25, 1.25) {0};
            \node at (14.75, 1.25) {0};
            \node at (15.25, 1.25) {1};
            \node at (13.25, 0.75) {0};
            \node at (13.75, 0.75) {0};
            \node at (14.25, 0.75) {1};
            \node at (14.75, 0.75) {1};
            \node at (15.25, 0.75) {0};
            \node at (13.25, 0.25) {0};
            \node at (13.75, 0.25) {0};
            \node at (14.25, 0.25) {0};
            \node at (14.75, 0.25) {0};
            \node at (15.25, 0.25) {1};
            \node at (13.75, -0.25) {0};
            \node at (14.25, -0.25) {0};
            \node at (15.25, -0.25) {1};
            \node at (13.75, -0.75) {0};
            \node at (14.25, -0.75) {0};
            
        \end{tikzpicture}

    \subcaption{1st step: we select the layers that would be exchanged with dotted lines)}
    \end{subfigure}
     \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {2}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Offspring 1}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
             node [a_dia, dotted, below=0.2cm of in2, white] (b3) {b3}
             node [a_dia, left=0.2cm of b3] (b1) {$b_1$}
             node [a_dia, right=0.2cm of b3] (b4) {$b_4$}
             node [in_out, below=0.2cm of b3, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Offspring 2};
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 1.5) grid (6.5, -0.5);
            \foreach \y in {1,...,4}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 1.5) rectangle (6.5, -0.5);
            \node at (5.25, 1.25) {1};
            \node at (5.75, 0.75) {1};
            \node at (6.25, 0.75) {1};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {0};
            \node at (6.25, 0.25) {1};
    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 1.5) grid (14.5, -0.5);
            \foreach \y in {1,...,4}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box,box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 1.5) rectangle (14.5, -0.5);
            \node at (13.25, 1.25) {1};
            \node at (13.75, 1.25) {0};
            \node at (14.25, 1.25) {0};
            \node at (13.75, 0.75) {0};
            \node at (14.25, 0.75) {1};
            \node at (14.25, 0.25) {1};
            
        \end{tikzpicture}
    \subcaption{2nd step: we remove the selected layers from the children graphs}

    \end{subfigure}
     \begin{subfigure}[b]{\textwidth}
         \begin{tikzpicture}[auto, thick,auto,main node/.style={circle,draw}, box/.style={minimum size=0.5cm,draw}]
            \footnotesize
             \draw
             node [num_circle, fill=white] (num1) {3}
             
             node [in_out, above right=0.7cm and 1.5cm of num1, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (in1) {Input}
             node [num_circle, below=0.35cm of in1] (a2) {$a_2$}
             node [a_dia, dotted, left = 0.7cm of in1.north, fill=output_red!70] (b2) {$b_2$}
             node [a_dia, dotted, left=0.35cm of a2, fill=output_red!70] (b3) {$b_3$}
             node [num_circle, right=0.3cm of a2] (a3) {$a_3$}
             node [in_out, below=0.35cm of a2, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch] (ou1) {Output}
             node[in_out, below right=0.5cm and 0.5cm of ou1.center, draw=white, fill=white] (leg1) {Offspring 1}
             
             node [in_out, above right=0.7cm and 9cm of num1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (in2) {Input}
            node [num_circle, dotted, below=0.3cm of in2, fill=input_purple!70] (a1) {$a_1$}
             node [a_dia, left=0.3cm of a1] (b1) {$b_1$}
             node [a_dia, right=0.3cm of a1] (b4) {$b_4$}
             node [in_out, below=0.3cm of a1, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch] (ou2) {Output}
             node[in_out, below right=0.5cm and 0.7cm of ou2.center, draw=white, fill=white] (leg2) {Offspring 2};
             \draw[->] (in1) -- (a2);
             \draw[->] (in1.east) to [out=0,in=90] (a3);
             \draw[->] (a2) -- (a3);
             \draw[->] (a2) -- (ou1);
             \draw[->] (a3) to [out=270,in=20] (ou1.east);
             \draw[->, dotted] (in1.north) to [out=90, in=0] (b2.north east);
             \draw[->, dotted] (b2) -- (b3);
             \draw[->, dotted] (b2.south) to [out=300, in=160] (a2.north west);
             \draw[->, dotted] (b3.south east) to [out=330, in=210] (a3.south west);

    
            \draw[->] (in2.west) to [out=180,in=90] (b1);
            \draw[->] (b1) to [out=270,in=160] (ou2.west);
            \draw[->] (b4) to [out=270,in=20] (ou2.east);
            \draw[->, dotted] (b1) -- (a1);
            \draw[->, dotted] (a1) -- (b4);
        
            \draw[step=0.5cm, color=gray!20] (4.5-0.001, 2) grid (7.5, -1);
            \foreach \y in {1,...,6}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, input_purple!40}, pattern color=white, pattern=crosshatch, draw=input_purple!40] at (4.25+0.5*\x, 2.25-0.5*\y){ };
                }
            \draw[] (4.5-0.001, 2) rectangle (7.5, -1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (5, 2) rectangle (5.5, -0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (5.5, 2) rectangle (6, -0.5);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (4.5, 1.5) rectangle (7, 1);
            \draw[dotted, line width=0.3mm, fill=output_red!70] (4.5, 1) rectangle (7, 0.5);
            \node at (5.25, 1.75) {\textbf{\textcolor{white}{1}}};
            \node at (5.75, 1.75) {0};
            \node at (6.25, 1.75) {1};
            \node at (6.75, 1.75) {1};
            \node at (7.25, 1.75) {0};

            \node at (5.25, 1.25) {0};
            \node at (5.25, 0.75) {0};
            \node at (5.25, 0.25) {0};
            \node at (5.25, -0.25) {0};
            \node at (4.75, 0.75) {0};
            \node at (5.75, 0.75) {0};
            \node at (6.25, 0.75) {0};
            \node at (6.75, 0.75) {1};
            \node at (7.25, 0.75) {\textbf{\textcolor{output_red!70}{0}}};
            \node at (7.25, 1.25) {\textbf{\textcolor{output_red!70}{0}}};
            \node at (5.75, 1.25) {1};
            \node at (6.25, 1.25) {1};
            \node at (6.75, 1.25) {0};
            \node at (6.75, 0.25) {1};
            \node at (7.25, 0.25) {1};
            \node at (7.25, -0.25) {1};
            \node at (5.75, 0.25) {0};
            \node at (5.75, -0.25) {0};
            \node at (4.75, 1.25) {0};
            \node at (8.2, 1.5) {\large{\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}}};
            \draw[->, color=output_red!70] (8.1, 1.4) to [out=270,in=0] (7.5, 1.25);
            \draw[->, color=output_red!70] (8.1, 1.4) to [out=270,in=0] (7.5, 0.75);


    
            \draw[step=0.5cm, color=gray!20] (12.5-0.001, 1.5) grid (15, -1);
            \foreach \y in {1,...,5}
                \foreach \x in {1, ..., \y}
                  {
                    \node [box, preaction={fill, output_red!40}, pattern color=white, pattern=crosshatch, draw=output_red!40] at (12.25+0.5*\x, 1.75-0.5*\y){ };
                }
            \draw[] (12.5-0.001, 1.5) rectangle (15, -1);
            \draw[dotted, line width=0.3mm, fill=input_purple!70] (13.5, 1) rectangle (14, -1);
            \draw[dotted, line width=0.3mm,  fill=input_purple!70] (13, 0.5) rectangle (15, 0);
            \node at (13.25, 1.25) {1};
            \node at (13.75, 1.25) {\textcolor{input_purple!70}{\textbf{0}}};
            \node at (14.25, 1.25) {0};
            \node at (14.75, 1.25) {0};
            \node at (13.75, 0.75) {1};
            \node at (14.25, 0.75) {0};
            \node at (14.75, 0.75) {1};
            \node at (13.25, 0.25) {0};
            \node at (13.75, 0.25) {0};
            \node at (14.25, 0.25) {1};
            \node at (14.75, 0.25) {0};
            \node at (13.75, -0.25) {0};
            \node at (14.75, -0.25) {1};
            \node at (13.75, -0.75) {0};
            \node at (14.5, 2) {\large{\raisebox{1ex}{\epsdice{3}} \raisebox{-1ex}{\rotatebox[origin=c]{45}{\epsdice{2}}}}};
            \draw[->, color=input_purple!70] (14, 2) to [out=180,in=90] (13.75, 1.5);
        \end{tikzpicture}
    \subcaption{3rd step: we insert the layers and reconstruct the edges.}

    \end{subfigure}
   
\end{figure}

%******************************************
\subsection{Hyperparameters evolution}
%******************************************

One of the architecture mutations consists in disturbing the node content. In this case, the node content is modified, including the operation. A new set of hyperparameters is then drawn. To refine this search, we defined specific mutations for the search space $\Lambda(\alpha)$. In the hyperparameters case, edges and nodes number are not affected. As for architecture-specific mutation, the operator will draw the set $\mathcal{L}' \subseteq \mathcal{L}$ and apply a transformation on each node of $\mathcal{L}'$. For each node $v_i$ from $\mathcal{L}'$, we draw $h_i$ hyperparameters, which will be modified by a neighbouring value. The hyperparameters in our search space belong to three categories:

\begin{itemize}
    \item \textbf{Categorical values:} the new value is randomly drawn among the set of possibilities deprived of the actual value. For instance, the activation functions, combiners, and recurrence types (LSTM/GRU) belong to this type of categorical variable.
    \item \textbf{Integers:} we select the neighbours inside a discrete interval around the actual value. For instance, it has been applied to convolution kernel size and output dimension.
    \item \textbf{Float:} we select the neighbours inside a continuous interval around the actual value. Such a neighbourhood has been defined for instance to the dropout rate.
\end{itemize}
