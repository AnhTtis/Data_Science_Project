\section{Our CCuantuMM Method} \label{sec:method}


Previous adiabatic quantum computing methods \cite{SeelbachBenkner2020, SeelbachBenkner2021} can only match two shapes. %
We present a method for matching $N$ shapes. 
To ensure cycle consistency on $N$ shapes, %
it is sufficient that all triplets of shapes are matched cycle consistently~\cite{huang2013consistent}. 
CCuantuMM iteratively solves three-shape problems, which preserve cycle consistency by construction and fit on existing quantum annealers with limited  resources. 
We introduce our formulation for matching three shapes in Sec.~\ref{sec:threeshapes} and then extend it to $N$ shapes in Sec.~\ref{sec:n_shapes}. 

\subsection{Matching Three Shapes}\label{sec:threeshapes}
Consider the problem of matching three non-rigidly deformed shapes $\mathcal{S} = \{\mathcal{X,Y,Z}\}$ of $n$ vertices each, while preserving cycle consistency.
We formulate this as an energy minimisation with respect to $ \mathcal{P} = \{ P_{\cal I J}\in\mathbb{P}_n | \cal I,J \in \cal S \} $, the set of permutations between all pairs in $\mathcal{S}$: %
\begin{equation} 
\begin{aligned} \label{eq:ThreeMatch} 
    &\min_\mathcal{P}  \sum_{\cal I, J \in \mathcal{S}; \cal I \neq \cal J} \operatorname{vec}(P_{\cal I J})^\top W_{\cal I J} \operatorname{vec}(P_{\cal I J}),  \\
    &\textrm{s.t. } \quad P_{\cal X Z} = P_{\cal X Y}P_{\cal Y Z}, 
\end{aligned} 
\end{equation} 
where $W_{\cal I J} \in \mathbb{R}^{n^2 \times n^2}$ is the energy matrix describing how well certain pairwise properties are conserved between shapes $\cal I$ and $\cal J$ (see Sec.~\ref{sec:q_match}), and $P_{\cal X Z} = P_{\cal X Y} P_{\cal Y Z} $ enforces cyclic consistency. %
An overview of the algorithm for three shapes is shown in Alg.~\ref{Alg:3QMatch}.

\subsubsection{QUBO Derivation} 

To perform optimisation on the quantum annealer, we need to transform \eqref{eq:ThreeMatch} into a QUBO problem. 
We adapt the CAE formulation from \cite{SeelbachBenkner2021} (see Sec.~\ref{sec:CAE}) and iteratively update the permutations to decrease the value of \eqref{eq:ThreeMatch}.
Given a set $C = \{c_i\}_{i=1}^k $ of $k$ disjoint 2-cycles and binary decision variables $\alpha$, we can parameterise our permutation matrices as $P_{\cal I J} (\alpha) = P_{\cal I J} + \sum_{i=1}^k \alpha_i (c_i - I) P_{\cal I J}$.
However, CAE alone is not sufficient to transform \eqref{eq:ThreeMatch} into a QUBO as cyclic consistency is still missing. 
A simple solution would be to encourage cyclic consistency as a quadratic soft penalty, but then there are no guarantees on the solution.
Instead, we enforce cyclic consistency by construction:
{\small
\begin{align}
    &P_{\cal XZ}(\alpha, \beta) = \\ \nonumber &(P_{\cal XY} + \sum_{i=1}^k \alpha_i (c_i -I) P_{\cal X Y}) \cdot (P_{\cal YZ} + \sum_{j=1}^k \beta_j( \tilde{c}_j - I) P_{\cal YZ}), 
\end{align}
}
\hspace{-3pt}where $\{c_i\}_i$ $\left(\{\tilde{c}_j\}_j\right)$ are cycles and $\alpha$ ($\beta$) are decision variables for the updates to $P_{\cal X Y}$ ($P_{\cal Y Z}$).
For brevity, we write $C_i = (c_i - I) P_{\cal X Y}$ and $\tilde{C_j} = (\tilde{c}_j - I) P_{\cal Y Z}$. 
We explain how we construct the cycles in  Secs.~\ref{sec:vertices}-\ref{sec:cycles}. 
Thus, we iteratively solve \eqref{eq:ThreeMatch} via a sequence of problems of the form: 
\begin{equation} \label{eq:intermediate_three}
    \min_{\alpha,\beta \in \{0,1\}^k} \exy{E_{\cal X Y}(P_{\cal X Y}(\alpha))} + \eyz{E_{\cal Y Z}(P_{\cal Y Z}(\beta))} + \exz{E_{\cal X Z}({P_{\cal X Z}(\alpha,\beta))}},
\end{equation} 
where $E_{\cal I J}(P,Q) =$ $ \operatorname{vec}(P)^\top W_{\cal I J} \operatorname{vec}(Q)$ and $E_{\cal I J}(P) = $  $ E_{\cal I J}(P,P)$. %
While the first two terms are in QUBO form, the third term contains cubic and bi-quadratic terms (see the supplement for details) which are not compatible with current quantum annealer architectures.
\paragraph{Higher-Order Terms.} 
All of these higher-order terms come from $P_{\cal X Z}(\alpha, \beta)$, specifically from the term $H = \sum_i \sum_j \alpha_i  \beta_j C_i \tilde{C}_j$.
As we only consider 2-cycles, $C_i$ and $\tilde{C}_j$ each have only four non-zero elements. 
Due to this extreme sparsity, %
most summands of $H$ become $0$. 


We could tackle these undesirable terms by decomposing them into quadratic terms by using ancilla variables and adding penalty terms \cite{dattani2019quadratization}. 
This gives exact solutions for sufficiently high weights of the penalty terms.  
However, multiple reasons speak against this: (1) the QUBO matrix is already dense (a clique) under the current formulation (as we will see in \eqref{eq:WTildeForm}) and adding ancilla qubits scales quadratically in $k$, 
(2) adding penalties makes the problem harder to solve%
, and (3) $H$ is sparsely non-zero and in practise we observe no drastic influence on the quality of the solution. %

Alternatively, we could assume $H{=}0$. 
However, this is unnecessarily strong since (1) $H$ also contributes to quadratic terms ($E(H,\cdot)$), and (2) higher-order terms operating on the same decision variable trivially reduce to quadratic terms: $\alpha_i \cdot \alpha_i = \alpha_i$ for binary $\alpha_i$. 
We thus keep those two types of terms and merely assume all truly cubic and bi-quadratic terms to be zero. 

\paragraph{Cycle-Consistent CAE.} After eliminating the higher-order terms and ignoring constants from \eqref{eq:intermediate_three}, we obtain (with the same colour coding): 
\begin{equation} 
{\small
\label{eq:FinalOptimisation}
\footnotesize   
\begin{aligned} 
&\min_{\alpha,\beta} \quad %
\sum_{i=1}^{k} \alpha_i \bigg(%
\exy{F_{\cal X Y}(P_{\cal X Y}, C_i)} + 
\exz{F_{\cal X Z}(P_{\cal XZ}, C_i P_{\cal YZ} )}\bigg) \\
&+ 
\sum_{j=1}^{k} \beta_j \bigg(%
\eyz{F_{\cal Y Z}(P_{\cal Y Z}, \tilde{C}_j)} + 
\exz{F_{\cal X Z}(P_{\cal XZ}, P_{\cal X Y}  \tilde{C}_j )} 
\bigg)  \\  
&+\sum_{i=1}^{k} \sum_{l=1}^{k} \alpha_i \alpha_l \bigg(
\exy{E_{\cal X Y}(C_i,C_l)} + %
\exz{E_{\cal X Z}(C_i P_{\cal YZ},  C_l P_{\cal YZ})}
\bigg)\\
&+ \sum_{j=1}^{k} \sum_{l=1}^{k} \beta_j \beta_l \bigg(
\eyz{E_{\cal Y Z}(\tilde{C}_j,\tilde{C}_l)} + %
\exz{E_{\cal X Z}(P_{\cal X Y} \tilde{C}_j  , P_{\cal X Y} \tilde{C}_l)} 
\bigg) 
\\ %
&+\sum_{i=1}^{k} \sum_{j=1}^{k} \alpha_i \beta_j \bigg( %
\exz{F_{\cal X Z}(P_{\cal X Y} \tilde{C}_j, C_i P_{\cal YZ})} + %
\exz{F_{\cal X Z}(K_{ij},P_{\cal XZ})} \\
&+
\exz{F_{\cal X Z}(K_{ij}, P_{\cal X Y} \tilde{C}_j)} +
\exz{F_{\cal X Z}(K_{ij}, C_i P_{\cal YZ})} %
+\exz{E_{\cal X Z}(K_{ij},K_{ij})} %
\bigg), \\
\end{aligned}
}
\end{equation}
where %
$P_{\cal XZ}=$ $P_{\cal XZ}(\mathbf{0}, \mathbf{0})= $ $ P_{\cal XY}P_{\cal YZ}$, and we use the shorthands $F_{\cal I J}(A,B) =$ $ E_{\cal I J}(A,B) + E_{\cal I J}(B,A)$ and $K_{ij} = $ $C_i \tilde{C}_j$. 
Denoting $\alpha_{k+j} = \beta_j$ for an expanded $\alpha\in \{0,1\}^{2k}$, 
\eqref{eq:FinalOptimisation} can be written in the form:
\begin{equation} \label{eq:WTildeForm}
    \min_{\alpha\in \{0,1\}^{2k}} \quad \alpha^\top \tilde{W} \alpha.
\end{equation}
The full formula for $\tilde{W}$ is provided in the supplement.  
\eqref{eq:WTildeForm}~is finally in QUBO form and we can optimise it classically or on real quantum hardware (see Sec.~\ref{sec:aqc}). 

\subsubsection{Choosing Vertices} \label{sec:vertices}
The question of how to choose the sets of cycles $\{c_i\}_i, \{\tilde{c}_j\}_j$ is still open. 
We first choose a subset of vertices using the ``worst vertices'' criterion introduced in~\cite{SeelbachBenkner2021} based on the relative inconsistency $I_{\cal XY}$ of a vertex $x\in\mathcal{X}$ under the current permutation: 
\begin{equation} \label{eq:Inconsistency}
    I_{\cal XY}(x) = \sum_{w \in \cal X} W_{x \cdot n + x^\top P_{\cal XY}, w\cdot n + w^\top P_{\cal XY} },
\end{equation}
where we treat the one-hot vector $x^\top P_{\cal X Y}$ as a vertex index on $\cal Y$.
A high value indicates that $x$ is inconsistent with many other matches under $P_{\cal X Y}$ and swapping it will likely improve the matching. %
We denote the set of the $m{=}2k$ vertices with the highest $I_{\cal X Y} (\cdot)$ as $V_{\cal X}$. 
Finally, we follow the permutations to get $V_{\cal Y} = \{ x^\top P_{\cal X Y} | x \in V_{\cal X} \} \subset {\cal Y}$. %


In practice, we observe a systematic improvement in the matchings when considering all three possibilities (using $I_{\cal X Y}$, $I_{\cal Y Z}$, or $I_{\cal X Z}$ %
as the starting point). 
We thus use three ``sub''-iterations per iteration, one for each possibility. 


\subsubsection{Choosing Cycles} \label{sec:cycles}

\begin{figure}
    \centering
    \resizebox{\columnwidth}{!}{\input{figures/subiteration.tex}}
    \caption{
    We depict the sub-iteration that starts from $I_{\cal X Y}$, from which we construct $V_\mathcal{X}$, then $\mathcal{C}^\mathit{all}_{\cal X}$, and finally $\mathcal{C}_{\cal X } = $ $\{\mathcal{C}^0_{\cal X},$ $ \mathcal{C}^1_{\cal X}, $ $ \mathcal{C}^2_{\cal X} \}$. 
    We also build $V_\mathcal{Y}$ from $V_\mathcal{X}$  %
    and construct $\mathcal{C}_{\cal Y}$ analogously. 
    Matching each element of $\mathcal{C}_{\cal X}$ with one from $\mathcal{C}_{\cal Y}$ (visualised via matching colours) leads to three sub-sub-iterations. 
    }
    \label{fig:cycleconstruction}
\end{figure}


\begin{figure}
    \centering
    \resizebox{0.8\columnwidth}{!}{\input{figures/subsubiteration.tex}}    
    \caption{
    We depict the sub-sub-iteration for $\mathcal{C}_{\cal X}^{2} = $ $ \{ (u_x,v_x), $ $(w_x,t_x) \} $ %
    and $\mathcal{C}_{\cal Y}^{1} =\{ (u_y,w_y),(v_y,t_y) \} $ %
    from Fig.~\ref{fig:cycleconstruction}. %
    } 
    \label{fig:choosing cycle}
\end{figure}
Given the worst vertices $V_{\cal X}$ and $V_{\cal Y}$ of any sub-iteration, %
we construct the cycles $\{c_i\}_i, \{\tilde{c}_j\}_j$ from them. 
Fig.~\ref{fig:cycleconstruction} visualises this process. 
Focusing on $V_{\cal X}$ for the moment, we want to use all possible 2-cycles $\mathcal{C}_{\mathcal{X}}^\mathit{all} = \{(uv) | u,v\in V_{\cal X}, u\neq v \}$ in each sub-iteration. 
We cannot use all of these cycles at once since they are not disjoint, as CAE requires. 
Instead, we next construct a set $\mathcal{C}_{\cal X}$ by partitioning $\mathcal{C}_{\mathcal{X}}^\mathit{all}$ into $m{-}1$ sets of cycles with each containing $m/2{=}k$ disjoint cycles. 
An analogous methodology is used for $\mathcal{C_Y}$. 

We now have $\mathcal{C_X}$ and $\mathcal{C_Y}$. 
Since we want to consider each cycle of $\mathcal{C}_{\mathcal{X}}^\mathit{all}$ and $\mathcal{C}_{\mathcal{Y}}^\mathit{all}$ once, we need several ``sub-sub'' iterations. 
Thus, we next need to pick one set of cycles from each $\mathcal{C_X}$ and $\mathcal{C_Y}$ for each sub-sub-iteration. 
There are $(m{-}1)^2$ possible pairs between elements of $\mathcal{C_X}$ and $\mathcal{C_Y}$.
Considering all possible pairs is redundant, does not provide significant performance advantage, and increases the computational complexity quadratically. 
Hence, we randomly pair each element of $\mathcal{C}_{\cal X}$ with one element of $\mathcal{C}_{\cal Y}$ (without replacement). 
This leads to $m{-}1$ sub-sub-iterations, with each one solving \eqref{eq:WTildeForm} with its respective cycles; see
Fig.~\ref{fig:choosing cycle}. %







\begin{algorithm}
\caption{Hybrid Three-Shape Matching} 
\label{Alg:3QMatch}
\textbf{Input:} $\mathcal{P}^{i},\mathcal{S}$ \\
\textbf{Output:} $\mathcal{P}^{i+1}$
\begin{algorithmic}[1]
\For {$I \in \{I_{\cal X Y}, I_{\cal Y Z}, I_{\cal X Z}\}$} \hfill \Comment{sub-iterations}
    \State {construct $V_{\cal X}, V_{\cal Y}, V_{\cal Z}$ (see Sec.~\ref{sec:vertices})}
    \State {construct $\cal C_{X}, C_{Y}, C_{Z}$ (see Sec.~\ref{sec:cycles})} 
    \For{$l{=}1$ to $m{-}1$ } \hfill \Comment{sub-sub-iterations}
        \State {compute $\tilde{W}$}
        \State {optimise QUBO \eqref{eq:WTildeForm}} \hfill \Comment{quantum}
    \EndFor
    \State {$P_{\cal XY}=\prod_{i=1}^{k} c_i^{\alpha_i} P_{\cal XY}$ }
    \State {$P_{\cal YZ} = \prod_{j=1}^{k} \tilde{c}_j^{\alpha_{m + j}}P_{\cal YZ}$}
    \State {$ P_{\cal XZ} = P_{\cal XY} \cdot P_{\cal YZ}$ }
\EndFor
\State \Return  {$\mathcal{P}^{i+1} = \{P_{\cal XY}, P_{\cal YZ}, P_{\cal XZ}\}$}
\end{algorithmic}
\end{algorithm}

\subsection{Matching {\large $N$} Shapes }\label{sec:n_shapes}

In this section, we extend our model to matching a shape collection $\mathcal{S}$ with $N$ elements by iteratively matching three shapes while still guaranteeing cycle consistency. 
Similar to the three-shape case \eqref{eq:ThreeMatch}, this can be formulated as an energy minimisation problem with respect to the set of permutations $\mathcal{P}$, except $\mathcal{S}$ now has cardinality $N$:
\begin{equation} 
\begin{aligned} \label{eq:multimatching}
    \min_\mathcal{P} &\sum_{\mathcal{I},\mathcal{J} \in \mathcal{S}; \mathcal{I}\neq \mathcal{J}} E_{\cal I J}(P_{\cal I J}), %
    \\ 
    \textrm{s.t. } \quad & P_{\cal I K} = P_{\cal I J } P_{\cal J K } \quad \forall \mathcal{I,J,K} \in \mathcal{S}. 
\end{aligned}
\end{equation} 
The energy contains summands for each possible pair of shapes.
Solving all of them jointly would be computationally expensive and even more complicated than \eqref{eq:FinalOptimisation}.
This is the reason most multi-shape matching methods apply relaxations at this point or cannot scale to a large $N$.
However, the cycle-consistency constraints still only span over three shapes; triplets are sufficient for global consistency \cite{huang2013consistent}.


We thus iteratively focus on a triplet $\mathcal{X}, \mathcal{Y}, \mathcal{Z} \in \mathcal{S}$ and its set of permutations $\mathcal{P}' = \{P_{\mathcal{X} \mathcal{Y}}, P_{\mathcal{X} \mathcal{Z}}, P_{\mathcal{Y} \mathcal{Z}} \}$. 
We could then minimise \eqref{eq:multimatching} over $\mathcal{P}'$, leading to a block-coordinate descent optimisation of \eqref{eq:multimatching} over $\mathcal{P}$. 
This would make the problem tractable on current quantum hardware since it keeps the number of decision variables limited. %
It would also formally guarantee that our iterative optimisation would never increase the total energy. 
However, each iteration would be linear in $N$ due to the construction of the QUBO matrix, preventing scaling to large $N$ in practice. 
We therefore instead restrict \eqref{eq:multimatching} to those terms that depend \emph{only} on permutations from $\mathcal{P}'$. 
This leads to the same energy as for the three-shape case \eqref{eq:ThreeMatch}, where the minimisation is now over $\mathcal{P}'$. 
Importantly, the computational complexity per triplet becomes independent of $N$, allowing to scale to large $N$. 
While this foregoes the formal guarantee that the \emph{total} energy never increases, we crucially find that it still only rarely increases in practice; see the supplement. 



By iterating over different triples $\mathcal{X}^i, \mathcal{Y}^i, \mathcal{Z}^i$, we cover the entire energy term and reduce it iteratively. 
Specifically, one iteration $i$ of the $N$-shape algorithm runs Alg.~\ref{Alg:3QMatch} on $\mathcal{P}'=\{P^i_{\mathcal{X}^i \mathcal{Y}^i}, P^i_{\mathcal{Y}^i \mathcal{Z}^i}, P^i_{\mathcal{X}^i \mathcal{Z}^i}\}$. 
Here, $\mathcal{X}^i$ $\in\mathcal{S}$ is chosen randomly (we use stratified sampling to pick all shapes equally often), the \emph{anchor} $\mathcal{Y}^i =$ $ A\in\mathcal{S}$ is fixed, and $\mathcal{Z}^i = $ $\mathcal{X}^{i-1}$. 
In practice, we saw slightly better results with this scheme instead of choosing the triplet randomly; see the supplement. 
We note that we only need to explicitly keep track of permutations into the anchor: $\mathcal{P}^{i}=\{P^i_{\mathcal{I} A}\}_{\mathcal{I}\in\mathcal{S},\mathcal{I}\neq A}$. %
We then get $\mathcal{P}^{i+1}$ from $\mathcal{P}^{i}$ by replacing $P^i_{\mathcal{X}^i A}$ and $P^i_{\mathcal{Z}^i A}$ with their updated versions from Alg.~\ref{Alg:3QMatch}. %





\noindent\textbf{Initialisation.} 
We compute an initial set of pairwise permutations $\mathcal{P}^\mathit{init}$ using a descriptor-based similarity of the normalised heat-kernel-signatures (HKS)~\cite{bronstein2010scale} extended by a dimension indicating whether a vertex lies on the left or right side of a shape (a standard practice in the shape-matching literature \cite{Gao2021}). 
Instead of using a random shape as anchor, the results improve when using the following shape: %
\begin{equation}
    A = \argmin_{A \in \mathcal{S}} \sum_{\mathcal{I} \in \mathcal{S}; \mathcal{I} \neq A} E_{\mathcal{I} A}(P^\mathit{init}_{\mathcal{I} A}), %
\end{equation}
where $P^\mathit{init}_{\mathcal{I} A}\in \mathcal{P}^\mathit{init}$. %
We thus have $\mathcal{P}^0 = \{P^\mathit{init}_{\mathcal{I} A}\}_{\mathcal{I} \in \mathcal{S}, \mathcal{I} \neq A}$. 







\noindent\textbf{Time Complexity.} 
Our algorithm scales linearly with the number of shapes. 
Each iteration of Alg.~\ref{Alg:3QMatch} has worst-case time complexity $\mathcal{O}(nk^3)$, as we discuss in the supplement. 



\noindent\textbf{Energy Matrix Schedule.} %
In practise, we first use pure geodesics for a coarse matching and then Gaussian-filtered geodesics to fine-tune. 
Specifically, for a shape collection of three shapes, we use a schedule with $2T$ geodesics iterations followed by $2T$ Gaussian iterations. 
For each additional shape in the shape collection, we add $T$ iterations to both schedules. 
We exponentially decrease the variance of the Gaussians every $N{-}1$ iterations to $\rho(i) = c_2 \exp(\frac{c_1}{i-T})$ where $c_1$ and $c_2$ are chosen such that the variance decreases from $25 \%$ to $ 5 \%$ of the shape diameter over the iterations. %
Thus, \emph{all} shapes undergo one iteration with the same specific variance.
We refer to the supplement for more details.










