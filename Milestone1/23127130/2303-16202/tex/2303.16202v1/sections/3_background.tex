\section{Background}\label{sec:background}

\subsection{Adiabatic Quantum Computing (AQC)}\label{sec:aqc}
AQC is a model of computation that leverages quantum effects to obtain high-quality solutions to the $\mathcal{NP}$-hard problem class of Quadratic Unconstrained Binary Optimisation (QUBO) problems:
    $\min_{x\in \{0,1 \}^k }  x^T Qx$,  
for $k \in \mathbb{N}$ and a QUBO weight matrix $Q\in \mathbb{R}^{k \times k}$. 
Each entry of $x$ corresponds to its own logical qubit, the quantum equivalent of a classical bit. 
The diagonal of $Q$ consists of linear terms, while the off-diagonals are inter-qubit \emph{coupling weights}. 
A QUBO can be classically tackled with simulated annealing (SA)~\cite{van1987simulated} or a variety of other discrete optimisation techniques \cite{kochenberger2014unconstrained,dunning2018works}, which, for large $k$, typically yield only approximate solutions as QUBOs are in general $\mathcal{NP}$-hard. 
AQC holds the potential to systematically outperform classical approaches such as SA, see \cite{denchev2016computational,king2021scaling} for an example. 
AQC exploits the adiabatic theorem of quantum mechanics \cite{BornFock1928}: If, when starting from an equal superposition state of the qubits (where all solutions $\{0,1 \}^k$ have the same probability of being measured) and imposing external influences corresponding to the QUBO matrix on the qubits sufficiently slowly (called \emph{annealing}), they will end up in a quantum state that, when measured, yields a minimizer $x$ of the QUBO. 
Not all physical qubits on a real quantum processing unit (QPU) can be %
connected (coupled) with each other. 
Thus, a \emph{minor embedding} of the logical-qubit graph (defined by non-zero entries of the QUBO matrix) into the physical-qubit graph (defined by the hardware) is required \cite{cai2014practical}. 
This can lead to a chain of multiple physical qubits representing a single logical qubit. 
For details of quantum annealing on D-Wave machines, we recommend \cite{mcgeoch2014adiabatic}.



\subsection{Shape Matching}\label{sec:q_match}
The problem of finding a matching for non-rigidly deformed shapes having $n$ vertices can be formulated as an $\cal N P$-hard
Quadratic Assignment Problem (QAP) \cite{kezurer2015tight,burghard17lifted}:
\begin{align} %\label{eq:ThreeMatch}
    \min_{P\in \mathbb{P}_{n}}  p^T W p,
\end{align}
where $p = \text{vec}(P)\in \{0,1\}^{n^2}$ is a flattened permutation matrix, %
and $W%
\in \mathbb{R}^{n^2 \times n^2}$ is an energy matrix describing how well certain pairwise properties are conserved between two pairs of matches. %
If two shapes $\cal X, \cal Y$ are discretised with $n$ vertices each, $W$ is often chosen as \cite{kezurer2015tight}: 
\begin{equation}
    W_{x_1\cdot n + y_1, x_2\cdot n +y_2} = \| d_{\cal X}^g(x_1,x_2) - d_{\cal Y}^g(y_1,y_2) \|,
    \label{eq:W}
\end{equation}
where  $x_1,x_2$ are vertices on $\cal X$; $y_1,y_2$ are vertices on $\cal Y$; and %
$d_{\cal I}^g(\cdot, \cdot)$ 
is the geodesic distance on the shape $\cal I$. 
Therefore, $W_{x_1\cdot n + y_1, x_2\cdot n +y_2}$ represents how well the geodesic distance is preserved between corresponding pairs of vertices on the two shapes. %
Instead of pure geodesics, Gaussian-filtered geodesics are also a popular choice for $W$ \cite{kernel17}: 
\begin{equation}
    g_{\cal X}(x_1,x_2) = \frac{1}{\rho \sqrt{2 \pi}} \exp {\left( -\frac{1}{2} \left(\frac{d^g_{\cal X}(x_1, x_2)}{\rho} \right)^2\right)}.
\end{equation}
$g_{\mathcal{I}}$ can be used to directly replace $d^g_{\mathcal{I}}$ in \eqref{eq:W}.
A small value of $\rho$ focuses the energy on a local neighbourhood around the vertex, while a large value increases the receptive field. 
Using Gaussian kernels in $W$ places more emphasis on local geometry whereas geodesics have higher values far away from the source vertex. 
Thus, geodesics work well for global alignment and  Gaussians for local fine-tuning. 

\subsection{Cyclic {\large $\boldsymbol{\alpha}$}-Expansion (CAE) } \label{sec:CAE}
CCuantuMM represents matchings as permutation matrices. 
In order to
update 
them, we build on Seelbach~\textit{et al.}'s CAE algorithm \cite{SeelbachBenkner2021} (similar to a fusion move \cite{hutschenreiter2021fusion}), which we describe here. 
A permutation matrix $P$ is called an \emph{$r$-cycle}, if there exist $r$ disjoint indices $i_1, \ldots , i_r$ such that $P_{i_j i_{(j+1) \% r}} = 1$ for all $j \in \{1,\ldots, r\}$ and $P_{l,l} = 1$ for all $l \notin \{i_1, \ldots, i_r\}$, in which case $P = (i_1 i_2 \ldots i_r)$ 
is a common notation.
Two cycles, \emph{i.e.}\ two permutation matrices, are \emph{disjoint} if these indices are pairwise disjoint.
We know that disjoint cycles %
commute, which allows us to represent any permutation $P$ as $P = \left(\prod_{i=1}^{k} c_i\right) \left(\prod_{i=1}^{l} \Tilde{c}_i \right) $, where $\{c_i\}_i$ and $\{\Tilde{c}_i\}_i$ each are sets of disjoint $2$-cycles.

Given a set $\{c_i\}_{i=1}^k$ of $k$ disjoint $2$-cycles, an \emph{update}, or modification, of $P$ can therefore be parameterised as: $P(\alpha) = \prod_{i=1}^{k} c_i^{\alpha_i} P,$ where $\alpha \in \{0,1\}^{k}$ is a binary decision vector determining the update. 
(Note that $\alpha_i$ in $c_i^{\alpha_i}$ is an  exponent, not an index.) 
Crucially, to make this parameterisation compatible with QUBOs, we need to make it linear in $\alpha$. 
To this end, CAE uses the following equality: 
\begin{equation} \label{eq:CAE}
    P(\alpha) = P + \sum_{i=1}^{k} \alpha_i (c_i - I ) P. 
\end{equation}







