\section{Experimental Evaluation}\label{sec:experiments} 



We compare against state-of-the-art multi-matching methods %
with a focus on quantum methods. 
We consider classical works for reference. 
All experiments use Python 3.9 on an Intel Core i7-8565U CPU with 8GB RAM and the D-Wave Advantage System 4.1 (accessed via Leap 2). 
We will release our code, which is accelerated using Numba. 


\noindent\textbf{Hyperparameters.} We set $T{=}11$. %
We set the number of worst vertices $m$ to  $16 \%$ of the number of vertices $n$. 


\noindent\textbf{Quantum Comparisons.} 
The closest quantum work, Q-Match \cite{SeelbachBenkner2021}, matches only two shapes. 
We consider two adaptations to multi-matching: 1) Q-MatchV2-cc, similar to our CCuantuMM, chooses an anchor and matches the other shapes pairwise to it, implicitly enforcing cycle consistency; and 2) Q-MatchV2-nc matches all pairs of shapes directly, without guaranteed cycle consistency. 
In both cases, we use our faster implementation and adapt our energy matrix schedule, which gives significantly better results. 


\noindent\textbf{Classical Comparisons.} For reference, we also compare against the classical, non-learning-based  multi-matching state of the art: IsoMuSh~\cite{Gao2021}  and the \emph{synchronised} version of ZoomOut \cite{melzi2019zoomout}, which both guarantee vertex-wise cycle consistency across multiple shapes. 



\noindent\textbf{Evaluation Metric.} 
We evaluate the correspondences using the Princeton benchmark protocol \cite{VladimirGPCK}. 
Given the ground-truth correspondences $P_{\cal I J}^{*}$ for matching the shape $\mathcal{I}$ to $\mathcal{J}$, the error of vertex $v \in \mathcal{I}$ under our estimated matching $P_{\cal I J}$ is given by the normalised geodesic distance: 
\begin{equation}
    e_v(P_{\cal I J}) = \frac{d_\mathcal{J}^{g}(v^\top P_{\cal I J},v^\top P_{\cal I J}^{*})}{\operatorname{diam}(\mathcal{J})}, \quad
\end{equation}
where $\operatorname{diam}(\cdot)$ is the shape diameter. %
We plot the fraction of errors that is below a threshold in a percentage-of-correct-keypoints (PCK) curve, where the threshold varies along the x-axis. %
As a summary metric, we also report the area-under-the-curve (AUC) of these PCK curves. 

\noindent\textbf{Datasets.} 
The \emph{FAUST} dataset~\cite{Bogo:CVPR:2014} contains real scans of ten humans in different poses. 
We use the registration subset with ten poses for each class and downsample to $500$ vertices. 
\emph{TOSCA}~\cite{bronstein2008numerical} has $76$ shapes from eight classes of humans and animals. 
We downsample to ${\sim}1000$ vertices. 
\emph{SMAL}~\cite{Zuffi:CVPR:2017} has scans of toy animals in arbitrary poses, namely %
$41$ non-isometric shapes from five classes %
registered to the same template. 
(\textit{E.g.,} the felidae (cats) class contains scans of lions, cats, and tigers.)
We downsample to $1000$ vertices. 
We use the same number of vertices as IsoMuSh~\cite{Gao2021}, except that they use $1000$ vertices for FAUST. 



\subsection{Experiments on Real Quantum Annealer} 
\begin{figure}
    \centering
    \resizebox{0.49\linewidth}{!}{
    \input{figures/PCK_QPU_3_Shapes}}
    \resizebox{0.49\linewidth}{!}{
    \input{figures/PCK_QPU_10_shapes}}
    \caption{
    PCK curves for (left) two three-shape and (right) two ten-shape instances using QA and SA. %
    In each plot, we denote one instance by normal lines and the other one by dotted lines. 
    }
    \label{fig:QPU_three_ten}
\end{figure}
We run two three-shapes and two ten-shapes experiments with FAUST on a real QPU. 
However, since our QUBO matrices are dense, we effectively need to embed a clique on the QPU. 
(The supplement contains a detailed analysis of the minor embeddings and the solution quality.) %
Hence, we test a reduced version of our method with 20 worst vertices per shape (40 virtual qubits in total), as more would worsen results significantly on current hardware. 
To compensate for this change, we use more  iterations for the ten-shape experiments. 
We use 200 anneals per QUBO, the default annealing path, and the default annealing time of $20\mu\mathit{s}$. 
As standard chain strength, we choose $1.0001$ times the largest absolute value of entries in $Q$. 
Each ten-shape experiment takes about 10 minutes of QPU time. 
In total, our results took about 30 minutes of QPU time for a total of $5.5 \cdot 10^4$ QUBOs. 
QA under these settings achieves a similar performance as SA under the same settings (Fig.~\ref{fig:QPU_three_ten}). %
As QPU time is expensive and since we have just shown that SA performs comparably to a QPU in terms of result quality, we perform the remaining experiments with SA under our default settings, on classical hardware. 
This is common practice~\cite{SeelbachBenkner2021, Arrigoni2022, Zaech_2022_CVPR } since SA is conceptually close to QA.
For additional results, including results on the new
Zephyr hardware \cite{Zephyr2021}, we refer to the supplement. 


\subsection{Comparison to Quantum and Classical SoTA} 

\begin{table}[h]
\centering

\resizebox{\linewidth}{!}{
\begin{tabular}{|c|ccc|ccc|}\hline
      & Ours            & Q-MatchV2-cc & Q-MatchV2-nc & IsoMuSh        & ZoomOut  & HKS \\ \hline\hline
FAUST & \textbf{0.989}  & 0.886        & 0.879        & \textit{0.974}          & 0.886    & 0.746\\ 
TOSCA & \textbf{0.967}  & 0.932        & 0.940        & \textit{0.952}          & 0.864    & 0.742 \\ 
SMAL  & \textit{0.866}  & 0.771        & 0.813        & \textbf{0.926}          & 0.851    & 0.544 \\ \hline 
\end{tabular}
}
\caption{AUC averaged over all classes of each dataset. For reference, we also include classical methods on the right. 
}
\label{Table:FAUST_TOSCA_SMAL}
\end{table}

\begin{figure}
   \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{c|cccccc}
    
    \raisebox{-0.5\height}{\includegraphics[width=.18\linewidth]{figures/tosca_qual/cat0.png}}
     &
    \raisebox{-0.5\height}{\includegraphics[width=.11\linewidth]{figures/tosca_qual/cat7.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.17\linewidth]{figures/tosca_qual/cat9.png}} & 
    \raisebox{-0.5\height}{\includegraphics[width=.13\linewidth]{figures/tosca_qual/cat3.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.16\linewidth]{figures/tosca_qual/cat4.png}} & 
    \raisebox{-0.5\height}{\includegraphics[width=.11\linewidth]{figures/tosca_qual/cat5.png}} &
    \rotatebox[origin=c]{270}{Ours} \\

    \raisebox{\height}{Source}
    &
    \raisebox{-0.5\height}{\includegraphics[width=.11\linewidth]{figures/tosca_qual_isomush/cat7.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.17\linewidth]{figures/tosca_qual_isomush/cat9.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.13\linewidth]{figures/tosca_qual_isomush/cat3.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.16\linewidth]{figures/tosca_qual_isomush/cat4.png}} &
    \raisebox{-0.5\height}{\includegraphics[width=.11\linewidth]{figures/tosca_qual_isomush/cat5.png}} &
    \rotatebox[origin=c]{270}{IsoMuSh}
    
    \end{tabular}
    }


    \caption{Qualitative results on the TOSCA  \cite{bronstein2008numerical} cat class. 
    We colour a source shape %
    and transfer this colouring to target shapes via the matches estimated by our method or IsoMuSh \cite{Gao2021}. %
    } 
    \label{fig:tosca_qualitative} 
\end{figure} 


\begin{figure*}
    \centering
    
    \begin{subfigure}{0.32 \textwidth}
    \resizebox{\textwidth}{!}{
    \input{figures/PCK_FAUST}
     }
     \caption{FAUST \cite{Bogo:CVPR:2014}}
     \label{fig:FAUSTquant}
    \end{subfigure}
    \begin{subfigure}{0.32 \textwidth}
    \resizebox{\textwidth}{!}{
    \input{figures/PCK_TOSCA}
    }
     \caption{TOSCA \cite{bronstein2008numerical}}
     \label{fig:TOSCAquant}
    \end{subfigure}
    \begin{subfigure}{0.32 \textwidth}
    \resizebox{\textwidth}{!}{
     \input{figures/PCK_SMAL}}
      \caption{SMAL \cite{Zuffi:CVPR:2017}}
      \label{fig:SMALquant}
    
    \end{subfigure}
    \vspace{-1em}
    \caption{
    Quantitative results on all three datasets. %
    For each dataset, we match all shapes within a class and then plot the average PCK curve across classes. 
    We plot classical methods with dashed lines as they are only for reference. 
    HKS is our initialisation (see Sec.~\ref{sec:n_shapes}). 
    }
    \label{fig:FAUST_TOSCA_SMAL}
    \vspace{-1em}
\end{figure*}




\noindent\textbf{FAUST.} 
We outperform both quantum and classical prior work, as Fig.~\ref{fig:FAUSTquant} and Tab.~\ref{Table:FAUST_TOSCA_SMAL} show. 
Because we downsample FAUST more, IsoMuSh's results are better in our experiments than what Gao \textit{et al.}~\cite{Gao2021} report.


\noindent\textbf{Matching $\mathbf{100}$ Shapes.} 
Next, we demonstrate that, unlike IsoMuSh and ZoomOut, our approach can scale to matching all 100 shapes of FAUST. %
Fig.~\ref{fig:teaser} contains qualitative results.
Tab.~\ref{tab:runtime} compares the runtime of our method (using SA) to others. 
Only ours and Q-MatchV2-cc scale well to $100$ shapes while ZoomOut and IsoMuSh cannot. 

\begin{table}[h]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{|c|ccccc|}
    \hline
    \# Shapes       & Ours & Q-MatchV2-cc & Q-MatchV2-nc         & IsoMuSh & ZoomOut    \\
    \hline\hline
    10              & 97   & 16           & 81                   & $(4+)0.3$ & \textbf{4} \\
    100             & 1137 & \textbf{175} & ${\sim}8000^\dagger$ & OOM     & OOM        \\
    \hline
    \end{tabular}
    }
    \caption{Runtime (in \textit{min}) for FAUST. IsoMuSh uses ZoomOut for initialisation. 
    ``OOM''  (out of memory): memory requirements are infeasible. ``$^\dagger$'' denotes an estimate. %
    }
    \label{tab:runtime}
\end{table}


    


\noindent\textbf{TOSCA.} 
Fig.~\ref{fig:TOSCAquant} and Tab.~\ref{Table:FAUST_TOSCA_SMAL} show that our method achieves state-of-the-art results.
While IsoMuSh's PCK curve starts higher (better), the AUC in Tab.~\ref{Table:FAUST_TOSCA_SMAL} suggests that our method performs better overall. 
Fig.~\ref{fig:tosca_qualitative} has qualitative examples. 


\noindent\textbf{SMAL.} 
Our CCuantuMM outperforms the quantum baselines, both in terms of PCK (Fig.~\ref{fig:SMALquant}) and AUC (Tab.~\ref{Table:FAUST_TOSCA_SMAL}). 
At the same time, it achieves performance on par with ZoomOut and below IsoMuSh. 
SMAL is considered the most difficult of the three datasets due to the challenging non-isometric deformations of its shapes. 
All methods thus show worse performance compared to FAUST and TOSCA. 

    

    



\subsection{Ablation Studies} 
We perform an ablation study on FAUST to analyse how different components of our method affect the quality of the matchings. 
We refer to the supplement for more ablations. 

\begin{figure}%
    \resizebox{0.49\linewidth}{!}{
    \input{figures/PCK_Geo_Ablation}
    }
    \resizebox{0.49\linewidth}{!}{
    \input{figures/PCK_Shapes_Ablation}
    }
    \caption{We ablate (left) the usage of Gaussian kernels, and (right) the large-scale multi-shape setting. 
    Gaussian kernels improve the results greatly. 
    Matching more shapes improves results. 
    }
    \label{fig:Ablation}
\end{figure}

\noindent\textbf{Gaussian Energy Schedule.} 
Our schedule, which starts with geodesics and afterwards uses Gaussians, 
provides a significant performance gain over using only geodesics, under the same number of iterations, see Fig~\ref{fig:Ablation}.
That is because Gaussians better correct local errors in our approach. 

\noindent\textbf{Does Using More Shapes Improve Results?} 
We analyse what effect increasing the number of shapes $N$ has on the  matchings' quality. %
We first randomly select three shapes and run our method on them, to obtain the baseline. 
Next, we run our method again and again from scratch, each time adding one more shape to the previously used shapes. 
This isolates the effect of using more shapes from all other factors. 
In Fig.~\ref{fig:Ablation}, we plot the PCK curves \emph{for the three selected shapes}. %
We repeat this experiment for several randomly sampled instances. %
Our results show that including more shapes improves the matchings noticeably overall.  %











\subsection{Discussion and Limitations} 
Our method and all considered methods are based on intrinsic properties like geodesic distances. 
Thus, without left-right labels for initialisation, they would produce partial flips for inter-class instances in FAUST and intra-class instances in TOSCA and SMAL. 
For a large worst-vertices set, contemporary quantum hardware leads to embeddings (see Sec.~\ref{sec:aqc}) with long chains, which are unstable, degrading the result quality. 
Finally, while our method is currently slower in practice than SA, it would immediately benefit from the widely expected quantum advantage in the future. %


