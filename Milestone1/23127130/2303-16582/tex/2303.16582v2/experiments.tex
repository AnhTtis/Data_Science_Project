
\section{Computational Experiments}
\label{sec:experiments}



\begin{figure}
	\begin{center}
		\begin{tabular}{|c ||c|c|c|c| } 
			\hline
			
			& \multicolumn{3}{c|}{Heuristics} & (id.) \\ 
			\hline 
			
			N. solved & Literals & Instantiations & Boxes &   \\
			
			\hhline{|=||=|=|=|=|}
			
			323 &   &  & \boxGridding & \expid{1}{a} \\ 	\hline
			
			355 &   &  & \epsInflation &  \expid{1}{b} \\ 	\hline
			
			356 &   &  & \makecell{\epsInflation \\ \boxGridding }&  \expid{1}{c} \\ \hhline{|=||=|=|=|=|}
			
			362 & \sortWrtCost & & \epsInflation &\expid{2}{b} \\ \hline
			
			361 & \sortWrtCost & & \makecell{\epsInflation  \\ \boxGridding }& \expid{2}{c} \\
			
			 \hhline{|=||=|=|=|=|}
			 
			 370 & \makecell{ \sortWrtCost \\ \filterOverconstr} & & \epsInflation & \expid{3}{b} \\ \hline
			 
			 367 & \makecell{ \sortWrtCost \\ \filterOverconstr} & & \makecell{\epsInflation \\ \boxGridding }& \expid{3}{c} \\
			 
			 \hhline{|=||=|=|=|=|}
			 
			 406 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & & \epsInflation & \expid{4}{b} \\ \hline
			 
			 410 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & & \makecell{\epsInflation \\ \boxGridding }& \expid{4}{c} \\
			 
			 \hhline{|=||=|=|=|=|}		
			 	 
			 409 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \KearfottOrdering & \epsInflation & \expid{5}{b} \\ \hline
			 
			 412 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \KearfottOrdering & \makecell{\epsInflation \\ \boxGridding }& \expid{5}{c} \\
			 
			 \hhline{|=||=|=|=|=|}
			 
			 424 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \makecell{ \KearfottOrdering \\ \filterOverconstrV}& \epsInflation & \expid{6}{b} \\ \hline
			 
			 426 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \makecell{ \KearfottOrdering \\ \filterOverconstrV} & \makecell{\epsInflation \\ \boxGridding }& \expid{6}{c} \\
			 
			 \hhline{|=||=|=|=|=|}
			 
			 427 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \makecell{ \KearfottOrdering \\ \filterOverconstrV \\ \filterRankDeficient}& \epsInflation & \expid{7}{b} \\ \hline
			 
			 426 & \makecell{ \sortWrtCost \\ \filterOverconstr \\ \checkForcedLiterals} & \makecell{ \KearfottOrdering \\ \filterOverconstrV \\ \filterRankDeficient} & \makecell{\epsInflation \\ \boxGridding }& \expid{7}{c} \\
			 
			 \hhline{|=||=|=|=|=|}			
			 441 & \multicolumn{3}{c|}{Virtual best} & \\
			 \hline		
			 
		\end{tabular}
	\end{center}
	
	\caption{\label{fig:experiments} Summary of the results for different heuristics configurations. Each row correspond to a configuration. The  first column from the left contains the number of benchmarks solved; the central columns indicate the heuristics used, separated by search level; the last column contains an identifier of the configuration. The last row is for the virtual best of the different configurations.}
\end{figure}

\label{sec:experiments}

\myparagraphB{Implementation.} 
We implemented the different heuristics presented in the paper in a prototype tool called \ugotNL (firstly presented in \cite{ATVApaper}). In order to make the results comparable with the ones obtained earlier, in addition to the search method discussed in Section~\ref{sec:certificate-search}, we preserve the following heuristics used by \ugotNL: If the local minimizer cannot find any minimum of $\LtoO(\phi)$ for which for every clause $C\in\phi$, the set of approximately satisfiable literals $L_C$ is non-empty, we restart the procedure on every conjunction resulting from the DNF of $\phi$.
The tool handles strict inequalities of the form $f<0$ directly until the box construction phase, where they are replaced by $f\leq -\varepsilon$  (with $\varepsilon=10^{-20}$).
For computing the topological degree, we use \textsc{TopDeg}\footnote{Available at \url{https://www.cs.cas.cz/~ratschan/topdeg/topdeg.html}.}. For the symbolic simplifications used in \checkForcedLiterals, we use the \textit{simplify} and the \textit{solve-eqs} tactics provided by \textsc{z3}~\cite{z3}\footnote{For a description of the two tactics: \url{https://microsoft.github.io/z3guide/docs/strategies/summary}. The version of z3 used is 4.5.1.0.}. For the computation of the rank used in \filterRankDeficient, we observe that the rank of a matrix is equal to the number of non-zero singular values, hence we consider a matrix far from rank-deficiency iff all its singular values are bigger than some threshold (to account for approximation errors). We use a threshold widely used by algorithms for determining the matrix rank, which is $\sigma_{\max} dim(A) \varepsilon$, where $\sigma_{\max}$ is the largest singular value of $A$, and $\varepsilon$ is the machine epsilon.

\myparagraphB{Setup.} We run the experiments\footnote{The results of the experiments are available at \url{https://doi.org/10.5281/zenodo.7774117}} on a cluster of identical machines equipped with 2.6GHz AMD Opteron 6238 processors.	We set a time limit of 1000 seconds, and a memory limit of 2Gb. We considered all \smtnta benchmarks from the dReal distribution\cite{dreal} and other \smtnta benchmarks coming from the discretization of Bounded Model Checking of hybrid automata~\cite{HARE,HYST}, totaling 1931 benchmarks. All of these benchmarks come with "unknown" status. According to experiments performed on other solvers ($\cvctool$, $\mathsat$, $\drealtool$), among these benchmarks 736 (respectively, 136) are claimed to be unsatisfiable (satisfiable) by at least one solver\footnote{For the results of such experiments, see \cite{ATVApaper}.}. 
We tested our tool with different heuristics configurations (Figure \ref{fig:experiments}), and, for each configuration, we checked that our tool never contradict the other tools. We have arranged the heuristics into 3 columns (Literals, Instantiations, and Boxes) according to the search level they are used in. As the number of possible configurations is quite high, we proceed as follows: We start with the simpler configurations (just one method for finding a box that contains a solution), and then we add heuristics.

\myparagraphB{Results.} In the first configurations we tested the 3 possible ways to search for a box. We note that \boxGridding \citeexpid{1}{a} performs  considerably worse than the other two, \epsInflation \citeexpid{1}{b} and \epsInflation+\boxGridding \citeexpid{1}{c}, which produce comparable results. Because of that, and for readability's sake, we did not use \boxGridding alone with other heuristics in the next configurations, but only considered the other two options. We then added heuristics based on the following criteria: first heuristics for the "Literals" choice, then heuristics for the "Instantiations" choice, and first ordering heuristics (i.e. \sortWrtCost and \KearfottOrdering), then filtering heuristics (all the others). At every new heuristic added, we see that the number of benchmarks solved grows regardless of the "Boxes" choice, with the best configuration reaching 427 benchmarks using 7 heuristics. If we consider the virtual best (i.e. run in parallel all the configurations and stop as soon as a certificate is found) we are able to solve 441 benchmarks. This is because in cases such as \epsInflation vs. \epsInflation+\boxGridding, or such as \filterOverconstrV vs. \filterRankDeficient, there is no dominant choice, with each configuration solving benchmarks that the other does not solve and vice-versa. 

\myparagraphB{Discussion.}  The first configuration \citeexpid{1}{a} essentially uses a method proposed earlier~\cite{ATVApaper} and implemented in a tool called \ugotNLeager (of which the tool presented in this paper is an upgrade). Already in the previous paper, \ugotNLeager outperformed the other solvers able to prove satisfiability in $\smtnta$, solving more than three times the benchmarks than \mathsat\cite{mathsat5}, \cvctool \cite{cvc5}, and \isattool\cite{iSAT3}, and almost as twice as the benchmarks solved by the \emph{lazy} version \msatUgot (where \ugotNL had been integrated \emph{lazily} inside \mathsat). Here we show that the new heuristics introduced further improve the performances of our tool, that is now able to solve around 100 benchmarks more.



\myparagraphB{Run-time of the certificate checker.} In Section \ref{sec:goal} we claimed that, with our approach, checking a certificate requires less run-time than the certificate search itself. Here we experimentally quantify this amount: for each benchmark solved by the best configuration \citeexpid{7}{b}, we observe the run-time required to check the certificate (which amounts, essentially, to the computation of topological degree and interval arithmetic for the successful box). In terms of median (respectively, mean), checking the certificate requires $0.10\%$ ($1.07\%$) of the run-time used by the solver.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "./main.tex"
%%% End:
