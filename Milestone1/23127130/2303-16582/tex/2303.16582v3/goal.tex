
\section{Goal}
\label{sec:goal}
Consider an SMT solver that takes as input some formula $\phi$ and as output an element of $\{ \Sat,\Unknown, \Unsat\}$.  How can we gain trust in the correctness of the result of such an SMT solver? One approach would be to ensure that the algorithm itself is correct. Another option is to provide a second algorithm whose output we compare with the original one. Both approaches are, however, very costly, and moreover, the latter approach still may be quite unreliable.

Instead, roughly following McConnell et al.~\cite{McConnell:11} (see also Figure~\ref{fig:certifying}), we require our solver to return---in addition to its result---some information that makes an independent check of this result easy:


\begin{definition}
  \label{def:certifying}
  An SMT solver is \emph{certifying} iff there is a property $W$ such that for every 
   input formula $\phi$, in addition to an element $r\in \{ \Sat, \Unknown, \Unsat \}$, the solver returns an object~$w$ (a \emph{certificate}) such that
	\begin{itemize}
        \item $(\phi, r, w)$ satisfies the property $W$, that is $W(\phi,r,w)$,
        \item     $W(\phi, \Sat, w)$ implies that $\phi$ is satisfiable, 
        \item  $W(\phi, \Unsat, w)$ implies that $\phi$ is unsatisfiable, and
          
		\item   there is an algorithm (a \emph{certificate checker}) that
		\begin{itemize}
			\item takes as input a triple $(\phi, r, w)$ and returns $\top$ iff $W(\phi, r, w)$, and that
			\item is simpler than the SMT solver itself.
		\end{itemize}
		
	\end{itemize}
	
      \end{definition}

      

\begin{figure}[tbh]
\centering
\includegraphics[clip,trim={0cm 3cm 0cm 0cm},width=8cm]{certificate.pdf}
	\caption{Certifying SMT Solver}
	\label{fig:certifying}
\end{figure}




So, for a given formula $\phi$,  one can ensure correctness of the result $(r, w)$ of a certifying SMT solver by using a certificate checker to check the property $W(\phi, r, w)$. Since the certificate checker is simpler than the SMT solver itself, the correctness check is simpler than the computation of the result itself. 

The definition leaves it open, what precisely is meant by  ``simpler''. In general, it could either refer to the run-time of the checker, or to the effort needed for implementing the certificate checker and ensuring its correctness. The former approach is taken in computational complexity theory, the latter in contexts where correctness is the main concern~\cite{McConnell:11}. Indeed, we will later see that our approach succeeds in satisfying both requirements, although we will not use complexity-theoretic measures of run-time, but will measure run-time experimentally. 

The use of such certificates is ongoing research in the unsatisfiable case~\cite{Barbosa:22}. In the satisfiable case, for most theories, one can simply use satisfying assignments (i.e., witnesses) as certificates. Here the property $W$ simply is the property that the given assignment satisfies the formula, which can be checked easily.

For \smtnta, however, the situation is different. In this case, satisfying assignments may involve numbers that are neither rational nor real algebraic. Indirect descriptions of satisfying assignments using formulations such as
  \begin{itemize}
  \item ``the number that is the solution of the equation $\sin x=1$'', or
  \item ``the number corresponding to the infinite sequence of digits that the Turing machine~$T$ writes onto its output tape''  
  \end{itemize}
  also  cannot be used as a basis for representing certificates. In the first case, the problem is that it is not obvious how to check whether the represented number actually exists. In the second case, it is not obvious how to check whether the represented number actually is a solution.

  In general, adding such information to $\nta$-formulas does not reduce the undecidable satisfiability problem to any known decidable class that would enable a certificate checker in the sense of Definition~\ref{def:certifying}.   Hence one needs to use certificates of a different form. For this, we introduce the following definition:
\begin{definition}
  \label{def:certificate}
Let $\phi$ be a formula in \nta. A \emph{(satisfiability) certificate} for $\phi$ is a triple $(\sigma, \nu, \setOfBoxes)$ such that $W(\phi, \Sat, (\sigma, \nu, \setOfBoxes))$ iff
	\begin{itemize}
	\item $\sigma$ is a function selecting a literal from every clause of $\phi$% such that no two selected Boolean literals contradict each other
		\item $\nu$ is a variable assignment in $\mathcal{R}^{V}$ assigning floating point numbers to a subset $V\subseteq\Vars{\sigma(\phi)}$ (where $\sigma(\phi)$ is a compact way of writing $\bigwedge_{ C \in \phi} \sigma(C)$), s.t. $\sigma(\phi)$
		 contains as many equations as real-valued variables not in $V$.
		\item $\setOfBoxes$ is a finite set of interval assignments in $\mathcal{B}^{\Vars{\phi}\setminus V}$% that assign floating point intervals
		such that their set-theoretic union as boxes
		is again a box $B_\beta$ and, 
		for the system of equations  $F:= eq(\nu(\sigma(\phi)))$ 
		and the system of inequalities $G:= ineq(\nu(\sigma(\phi)))$, it holds that:
	
		\begin{itemize}
			%\item the equalities form a square system, that is $F: \mathbb{R}^k\rightarrow\mathbb{R}^k$, for some $k$,
			\item $0\not\in F(\partial B_\beta)$,
			\item $\deg(F, B_\beta, 0)\neq 0$, and
			\item for every $B\in\setOfBoxes$, $\intervalArithmOperator_G(B)\leq 0$.
		\end{itemize}
	\end{itemize}

\end{definition}



\ 

\begin{example}
\label{ex:certificate}
Consider the formula 
\begin{alignat*}{2}
	& \qquad \qquad \qquad \qquad \qquad \phi := C_1 \land C_2 \land C_3 \land C_4  \\
	& C_1 \ \equiv \ \cos(y) = 0 \ \lor \ \sin(y) = \e^x
	&& C_3 \ \equiv \ x-y \leq \cos(z) \\ 
	& C_2 \ \equiv \  \sin(y)=0 \ \lor \  \cos(y) = \sin(8x^2-z) 
	&& C_4 \ \equiv \ x+y \geq \sin(z) 
      \end{alignat*}      
The following $(\sigma, \nu, \beta)$ is a certificate:
\begin{itemize}
	\item $\sigma := \{ C_1 \mapsto \sin(y) = \e^x\ ;\  C_2 \mapsto \cos(y) = \sin(8x^2-z)\ ; \\ C_3 \mapsto C_3\ ;\  C_4 \mapsto C_4\}$ 
	\item $\nu := \{ z \mapsto 0.2 \}$
	\item $\setOfBoxes:=\{B\}$, where $B := \{x \mapsto [-0.1,0.05]\ ;\ y \mapsto [1.4, 1.9] \} $
        \end{itemize}
      \end{example}

      As can be seen in Figure~\ref{fig:example}, the solution sets of $C_1$ and $C_2$ cross at a unique point in $B$, which reflects the fact that the degree of 
      the function $(x,y)\rightarrow (\sin(y)-\e^x,\cos(y)-\sin(8x^2-0.2))$ is non-zero. Moreover, the inequalities $C_3$ and $C_4$ hold on all elements of the box.
      \begin{figure}[tb]
\centering
        \includegraphics[width=8cm]{example.pdf}       
        \caption{Solution sets of equalities for the certificate of Example \ref{ex:certificate}}
        \label{fig:example}
      \end{figure}
\ 

Due to the properties of the topological degree and of interval arithmetic discussed in the preliminaries, we have:
\begin{property}
	$W(\phi, \Sat, (\sigma, \nu, \setOfBoxes))$ implies that $\phi$ is satisfiable.
\end{property}

Such a satisfiability certificate  can only serve as a certificate for an SMT solver if a certificate checker---as required by Definition~\ref{def:certifying}---exists. This certificate checker needs to be able to check the conditions of Definition~\ref{def:certificate}. The topological degree can indeed be computed algorithmically~\cite{Aberth:94,Franek:12b}. The condition $0\not\in F(\partial B_\beta)$ is necessary for the topological degree to be well defined. Due to this, such algorithms~\cite{Aberth:94,Franek:12b} also check this condition, and no separate check is necessary. Finally, the condition $\intervalArithmOperator_G(B)\leq 0$ clearly is algorithmic. 


Note that this definition could be applied to a broader class of formulas than \nta, 
since the algorithms used to compute the topological degree and $\intervalArithmOperator$ can work with any  \emph{interval-computable} function (i.e. functions for which it is possible to compute arbitrarily precise images for every interval domain~\cite{Franek:12}). 
However, in practice, the tools that implement these algorithms do not go beyond the \nta case.
For this reason, given that our approach is application-oriented, we will keep our focus only on \nta.

In this paper, we will show that in addition to the discussed benefits for correctness, formulating satisfiability checking as the problem of search for such certificates also is beneficial for efficiency of the SMT solver itself. Since we will concentrate on satisfiability, we will simply ignore the case when an SMT solver returns $\Unsat$, so the reader can simply assume that an SMT solver such as the one from Figure~\ref{fig:certifying} only returns an element from the set $\{\Sat, \Unknown\}$.

Note that the variable assignment $\nu$ can also be viewed as a system of equalities of the form $\bigwedge_{v \in V} v=\nu(v)$. In general, one could allow a system of equalities of a more general form, for example, a system of linear equalities, arriving at the function $F$ and $G$ by eliminating some of the involved variables by Gaussian elimination. One could even extend the functions $F$ and $G$ by the left-hand sides of those additional equalities. However, our computational experiments will demonstrate that this is not beneficial, in general, which justifies the more specific form of Definition~\ref{def:certificate}.


% For some applications it might make sense to return more information than just ``satisfiable'' or ``unknown'' (e.g., an algorithm-dependent estimate for the probability for future success, or algorithm-independent information about the distance to satisfiability).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "./main.tex"
%%% End:
