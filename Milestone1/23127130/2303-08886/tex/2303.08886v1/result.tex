\label{sec:results}





To examine the potential runtime overhead of vFHE, we have implemented vFHE of code based on SEAL~\cite{SEAL} to insert an FHE integrity verification. Previous research has demonstrated that the FHE-in-TEE approach yields exceptional efficiency for variable FHE, as reported in~\cite{viand2023verifiable}. Accordingly, our baseline is established by incorporating SEAL-based BFV and AMD-SEV TEE. Figure~\ref{fig:results}(a) shows execution time overheads as a function of the matrix size, over unprotected execution (FHE-only), with various arithmetic FHE schemes, including BFV, BGV, and CKKS. As shown in the figure, the overhead of our baseline FHE-in-TEE over the FHE-only method executing matrix multiplication is far more than $1000\%$. With {\em blind hash} support, the overhead decreases to about 4\% for diagonal matrix multiplication with size $n=64$. The runtime overhead of {\em blind hash} is reduced as the matrix size, $n$, increases, with a worst-case overhead of fewer than 5$\times$ when $n=1$. When the matrix size is large enough, its overhead will be near zero. We use Table (b) in Figure~\ref{fig:results} to show execution time comparisons of our {\em blind hash} method in vFHE with the BGV scheme against our baseline and FHE-only method on a diagonal matrix-matrix multiplication with size $n=64$. Our baseline FHE-in-TEE offers verifiable FHE without adding any additional runtime overhead on the client side about encryption (Enc.), decryption (Dec.), and verification (Verf.). However, it does substantially increase overhead on the server side, by approximately 21.6 times, compared to the FHE-only method. In contrast, the FHE computation equipped with our blind hash in vFHE increases $2.1\%$ and $2.2\%$ runtime overhead on the client and server sides, respectively, over the FHE-only method. The preliminary results demonstrate that, with the proposed techniques, vFHE with {\em blind hash} can be applied universally to various FHE schemes (BFV, BGV, CKKS) and can achieve efficiency, indicating the promise of vFHE as a new paradigm for verifiable FHE computation.
%The runtime overhead of SBCR is decreased as the matrix size $n$ and its worst-case overhead when $n=1$ is still less than $5\times$. The preliminary results confirm that with the proposed techniques, SBCR can be universal to various FHE schemes and can be made efficient, indicating the promise of SBCR as a new paradigm for verifiable FHE computation.  





%region-based analysis on LLVM to insert attach and detach into a given C program. Based on Sniper~\cite{carlson2011etloafsaapms}, we built a prototype of the hardware support of the fast attach/detach mechanism~\cite{Xu+:ASPLOS20}, and also the scheme to silent unnecessary detach calls as described in Section~\ref{sec:architecture}. The hardware simulator is presented in Table (a) in Figure~\ref{fig:results}. WHISPER benchmarks~\cite{nalli2017analysis} are used.
%Figure~\ref{fig:results}(b) shows execution time overheads over unprotected execution, broken down into components from attach and detach system calls, re-randomization (Rand), execution of conditional attach/detach instructions (Cond) and other overheads (e.g., permission matrix). As  shown in the figure, the overhead of executing every attach/detach with system calls averages 50\%. With TERP architecture support, the overhead decreases to about 6\% with 40$\mu$s exposure window (EW) and as low as 2\% with 160$\mu$s EW. The preliminary results confirm that with the proposed techniques, TERP controls can be made efficient, indicating the promise of TERP as a new paradigm for memory protection.  
