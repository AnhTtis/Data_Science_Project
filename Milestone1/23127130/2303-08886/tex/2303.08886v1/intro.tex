Privacy-preserving technology in cloud computing is crucial, as it allows for deploying cloud-based applications where data privacy is paramount. This property is especially important in cases where the data is highly sensitive or when compliance with increasingly stringent privacy regulations is required. Fully Homomorphic Encryption (FHE)~\cite{gentry2009fully, brakerski2014leveled, halevi2019BFVimproved, kim2022approximate} is a distinct privacy-preserving technique that enables computation on encrypted data without the need for decryption. 

FHE enables privacy-preserving computation in a variety of applications. For example, data owners such as Alice can gain new insights from their private data through service providers such as Bob, who can perform computations, manipulations, and even aggregations on the data without access. This technique has numerous use cases, such as secure cloud computing for sensitive medical and financial data~\cite{AmazonScience, IBMSecurity, GoogleCloud, Google, Microsoft,reagen2021cheetah} and secure machine learning~\cite{graepel2013ml,lu2016using, chen2018logistic,gilad2016cryptonets, brutzkus2019low}.

\begin{figure}[t!]
\centerline{
  \hspace{0.3cm}
\includegraphics[width=0.5\textwidth]{figures/figure-bag.pdf}}
\caption{Illustrating vFHE with blind hash, which enables the verification of Fully Homomorphic Encryption (FHE) against both malicious tampering and computational errors. }
\label{fig:overview}
\end{figure}

Prior research efforts in FHE have mainly concentrated on boosting its speed, leading to notable advancements in this domain. For instance, recent studies~\cite{CryptoNets:ICML2016, lou2019she, lou2020safenet, lou-2021-cryptogru, lou2020autoprivacy, lou2020falcon, Brutzkus:ICML19, GAZELLE:USENIX18, Pratyush:USENIX2020} have improved the efficiency of FHE through innovative schemes and hardware acceleration, such as the use of GPU support for FHE~\cite{fhe-gpu} and ciphertext batching~\cite{GAZELLE:USENIX18, Pratyush:USENIX2020}, which substantially reduce latency and enhance throughput for privacy-preserving computation.

Despite the significant progress in FHE research, there has been a scarcity of attention given to one of its major challenges: the inability of client-side data owners to verify the integrity of computations performed by service and computation providers, leading to uncertainties about the accuracy of results. This concern is especially pressing in cases where the provider is untrustworthy, unreliable, or acts maliciously and may tamper with the computational results. 


\newcommand*\feature[1]{\ifcase#1 -\or\LEFTcircle\or\CIRCLE\fi}
\newcommand*\f[1]{\feature#1}
\makeatletter
\newcommand*\ex[7]{#1&\f#2&\f#3&\f#4&\f#5&\f#6&\f#7}
\begin{table*}[h]
\centering
\footnotesize
\begin{threeparttable}
\caption{Comparison of current FHE integrity schemes and our Blind Hash method}
\label{tab:features}
\setlength{\tabcolsep}{5pt}
\begin{tabular}{lcccccc}
\toprule
\textbf{Scheme} & \textbf{Universality} & \textbf{Scalability} & \textbf{Security} & \textbf{Low Overhead} & \textbf{Verifiable Model}  & \textbf{No hardware}  \\
\midrule
%\midrule
%\ex{MAC}{1}{0}{2}{0}{0}{2}\\
\ex{MAC'~\cite{chatel2022verifiable}} {1}{0}{2}{0}{0}{2}\\
\ex{Residue\cite{Awadallah2021}  \cite{cryptoeprint:2023/231} }{2}{0}{0}{0}{0}{2}\\
%\ex{ZKP}{1}{0}{2}{0}{2}{2}\\
\ex{ZKP' ~\cite{viand2023verifiable}}{1}{0}{2}{0}{2}{2}\\
\ex{TEE~\cite{natarajan2021chex, viand2023verifiable} }{2}{0}{2}{0}{2}{0}\\
\ex{\textbf{Blind Hash}}{2}{2}{2}{2}{2}{2}\\
\bottomrule
\end{tabular}
\begin{tablenotes}

\begin{small}
\item $\feature2=\text{provides property}$; $\feature1=\text{partially provides property}$;
$\text{\feature0}=\text{does not provide property}$;
%\item \textsuperscript{\dag}has academic publication;
%\textsuperscript{}end-user tool available
\end{small}
\end{tablenotes}
\end{threeparttable}
\end{table*}

Prior work ensuring FHE computational integrity has been {\em non-universal} or {\em incurring too much overhead}. The majority of research focuses on two approaches: cryptographic integrity checking protocol~\cite{bhadauria2020ligero++, bunz2018bulletproofs, gennaro2010non,goldwasser2015delegating, parno2016pinocchio, weng2021wolverine, brakerski2011fully, bois2021flexible, fiore2014efficiently, fiore2020boosting, ganesh2021rinocchio}, including homomorphic message authentication code (MAC and MAC'\cite{chatel2022verifiable}) and zero-knowledge proofs (ZKP and ZKP'\cite{viand2023verifiable}); and relying on trusted execution environment (TEE) hardware~\cite{natarajan2021chex, wang2019toward, coppolino2020vise,sabt2015trusted}. The former approach suffers from non-universality from incompatibility with ring-based FHE schemes. Different FHE schemes, such as BGV~\cite{brakerski2014leveled} and CKKS~\cite{fhe-ckks}, operate over different encoding methods, polynomial structures, and ciphertext space. Thus a cryptographic integrity method, e.g., MAC, MAC', ZKP', that alters the inner encoding and algorithms in a specific FHE scheme needs redesign for a different scheme. The generic ZKP without optimization for a specific FHE scheme suffers from a large overhead. Modifying cryptographic integrity to make it efficient and compatible with all modern FHE schemes without impacting FHE functionalities has so far remained elusive~\cite{chatel2022verifiable}.

% \aji{Prior work on ensuring FHE computational integrity has been incuring too much overhead. The majority of research is focusing on three approaches: Message Authentication Code (MAC), Zero Knowledge Proof (ZKP) and relying on Trusted Execution Environment (TEE). MAC approach suffers large overhead because it requires an interactive authentication to bypass non linear function. Meanwhile, ZKP would suffer when it is used for evaluating highly configurable function. The keys (sk,pk) of ZKP is bind only for one function configuration and needs to be regenerated for different configuration. While deploying a FHE to TEE will ensure integrity, it has a high overhead because of double encryption.}

%A generic and efficient integrity verification that is compatible with various FHE schemes is needed. We propose a \textit{blind hash} method to enable verifiable FHE as Figure~\ref{fig:overview} shows.
For these reasons, there is a need for a generic and efficient integrity verification solution that is compatible with various FHE schemes. In this context, we propose a novel approach called the \textit{blind hash} method, which enables verifiable FHE. The proposed method is based on a plug-in algorithm that can be used with different FHE schemes. The method involves generating a blind hash of the raw data, which is then used to verify the integrity of the computation. We present our vFHE module with blind hash  in Figure~\ref{fig:overview}. In the context of a client-side data owner and a server-side service/computation provider, let's assume that the data owner wants to compute a function $f()$ over an input $x$ resulting in $f(x)$. In order to do so, the raw data $x$ is preprocessed by our proposed \textit{blind hash} function to generate $x_c$. This $x_c$ can be encoded and encrypted into ciphertext $[x_c]$ using any fully homomorphic encryption (FHE) schemes. The server can perform the function $f([x_c])$ without decrypting the data. The encrypted results obtained from the server side can be decrypted by the data owner. Our proposed verifiable FHE (vFHE) method allows for verification of the integrity and correctness of $f(x)$ against any computational errors or malicious tampering. Specifically, if the server-side computation results in $f'([x_c]) = f([x_c])$ where $f'()$ is a tampered result that yields a different output than $f()$, the vFHE method would detect this and alert the data owner of the tampering attempt. 

% \aji{Table I. I remove implementation because all of latest paper has implementation already, I am not sure about Universality, latest paper on FHE-ZKP already provide universality, I remove ML support because blind hash (excluding blind rotation) doesn't support ML}

